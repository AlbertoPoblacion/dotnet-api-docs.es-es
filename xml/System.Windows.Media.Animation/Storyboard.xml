<Type Name="Storyboard" FullName="System.Windows.Media.Animation.Storyboard">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="6ce141dc7761c50fbe3baa83fc9aece459ee15c5" />
    <Meta Name="ms.sourcegitcommit" Value="434f60616a9793fa8436744549fc856e94f7a648" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="es-ES" />
    <Meta Name="ms.lasthandoff" Value="08/25/2018" />
    <Meta Name="ms.locfileid" Value="39764366" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class Storyboard : System.Windows.Media.Animation.ParallelTimeline" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi Storyboard extends System.Windows.Media.Animation.ParallelTimeline" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Media.Animation.Storyboard" />
  <TypeSignature Language="VB.NET" Value="Public Class Storyboard&#xA;Inherits ParallelTimeline" />
  <TypeSignature Language="C++ CLI" Value="public ref class Storyboard : System::Windows::Media::Animation::ParallelTimeline" />
  <TypeSignature Language="F#" Value="type Storyboard = class&#xA;    inherit ParallelTimeline" />
  <AssemblyInfo>
    <AssemblyName>PresentationFramework</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Windows.Media.Animation.ParallelTimeline</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Escala de tiempo contenedora que proporciona la  información de destino de la propiedad y el objeto para sus animaciones secundarias.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
## <a name="interactively-controlling-storyboards"></a>Controlar guiones gráficos de forma interactiva  
 Un guión gráfico controlable puede pausar, reanudar, buscar, detener y se puede quitar. Para hacer un guión gráfico controlable en marcado, especifica el <xref:System.Windows.Media.Animation.BeginStoryboard.Name%2A> propiedad de la <xref:System.Windows.Media.Animation.BeginStoryboard> objeto que lo crea; por ejemplo, vea [Cómo: utilizar desencadenadores de eventos para controlar un guión gráfico después de su inicio](~/docs/framework/wpf/graphics-multimedia/how-to-use-event-triggers-to-control-a-storyboard-after-it-starts.md). Para hacer un guión gráfico controlable en código, debe usar la sobrecarga adecuada del guión gráfico <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> método y especifique `true` para que sea controlable. Para obtener un ejemplo, vea [Cómo: controlar un guión gráfico después de su inicio](~/docs/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts.md).  
  
## <a name="data-binding-and-animating-timelines"></a>Enlace de datos y las escalas de tiempo de animación  
 La mayoría de las propiedades de escala de tiempo pueden ser datos enlazados o animadas; Sin embargo, debido al modo en que funciona el sistema de control de tiempo, las escalas de tiempo enlazados o animados no se comportan como otros datos de datos enlazan o animar objetos. Para entender su comportamiento, ayuda a entender lo que significa activar una escala de tiempo.  
  
 Cuando se activa una escala de tiempo, se realizan copias de la escala de tiempo y sus escalas de tiempo secundarias. Estas copias se inmovilizan (sólo lectura) y <xref:System.Windows.Media.Animation.Clock> se crean objetos de ellos. Estos relojes son los que realmente se encargan de animar las propiedades de destino. Si una escala de tiempo está enlazado datos o animadas, se realiza una instantánea de sus valores actuales cuando se crea su reloj. Aunque la escala de tiempo original puede seguir cambiando, su reloj no.  
  
 Para que una escala de tiempo reflejar los cambios de animación o el enlace de datos, su reloj se deben volver a crearse. Relojes no son volver a crea automáticamente. A continuación se muestran distintas maneras de aplicar cambios a las escalas de tiempo:  
  
-   Si la escala de tiempo es o pertenece a un <xref:System.Windows.Media.Animation.Storyboard>, puede hacer que reflejan los cambios puede volver a aplicar su guion gráfico utilizando un <xref:System.Windows.Media.Animation.BeginStoryboard> o <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> método. El efecto secundario de esta acción es que también se reinicia la animación. En el código, puede usar el <xref:System.Windows.Media.Animation.Storyboard.Seek%2A> hacer una copia de método para avanzar el guión gráfico a su posición anterior.  
  
-   Si aplica una animación directamente a una propiedad mediante el <xref:System.Windows.Media.Animation.Animatable.BeginAnimation%2A> método, llame a la <xref:System.Windows.Media.Animation.Animatable.BeginAnimation%2A> nuevo al método y pásele la animación que se ha modificado.  
  
-   Si está trabajando directamente en el nivel de reloj, crear y aplicar un nuevo conjunto de relojes y utilícelos para reemplazar el conjunto anterior de relojes creados.  
  
 Para un ejemplo de datos de una animación enlazada, consulte [ejemplo Key Spline Animation](http://go.microsoft.com/fwlink/?LinkID=160011) .  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Storyboard ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Storyboard();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Windows.Media.Animation.Storyboard" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Begin">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inicia el conjunto de animaciones asociado a este objeto <see cref="T:System.Windows.Media.Animation.Storyboard" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un guión gráfico controlable puede pausar, reanudar, buscar, detener y se puede quitar. Para hacer un guión gráfico controlable en código, debe usar la sobrecarga adecuada del guión gráfico <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> método y especifique `true` para que sea controlable. Para obtener un ejemplo, vea [Cómo: controlar un guión gráfico después de su inicio](~/docs/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Begin">
      <MemberSignature Language="C#" Value="public void Begin ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Begin() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.Begin" />
      <MemberSignature Language="VB.NET" Value="Public Sub Begin ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Begin();" />
      <MemberSignature Language="F#" Value="member this.Begin : unit -&gt; unit" Usage="storyboard.Begin " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Aplica las animaciones asociadas con este <see cref="T:System.Windows.Media.Animation.Storyboard" /> a sus destinos y las inicia.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Begin">
      <MemberSignature Language="C#" Value="public void Begin (System.Windows.FrameworkContentElement containingObject);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Begin(class System.Windows.FrameworkContentElement containingObject) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.Begin(System.Windows.FrameworkContentElement)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Begin (containingObject As FrameworkContentElement)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Begin(System::Windows::FrameworkContentElement ^ containingObject);" />
      <MemberSignature Language="F#" Value="member this.Begin : System.Windows.FrameworkContentElement -&gt; unit" Usage="storyboard.Begin containingObject" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="containingObject" Type="System.Windows.FrameworkContentElement" />
      </Parameters>
      <Docs>
        <param name="containingObject">Objeto incluido dentro del mismo ámbito de nombres que los destinos de las animaciones de este guión gráfico. Las animaciones que no disponen de <see cref="P:System.Windows.Media.Animation.Storyboard.TargetName" /> se aplican a <c>containingObject</c>.</param>
        <summary>Aplica las animaciones asociadas con este <see cref="T:System.Windows.Media.Animation.Storyboard" /> a sus destinos y las inicia.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si las propiedades de destino ya están animadas, se reemplazan con el <xref:System.Windows.Media.Animation.HandoffBehavior.SnapshotAndReplace> comportamiento de entrega.  
  
 Guiones gráficos iniciados con este método no se en pausa, reanudar o en caso contrario, puede controlar interactivamente después de haberse iniciado. Para poder controlar un guión gráfico, use el <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> o <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> método.  
  
 Activa un guion gráfico a partir de la <xref:System.Windows.Media.Animation.Timeline.CurrentStateInvalidated> y <xref:System.Windows.Media.Animation.Timeline.CurrentGlobalSpeedInvalidated> eventos.  
  
   
  
## Examples  
 En el ejemplo siguiente se usa un guión gráfico para animar un <xref:System.Windows.Media.TextEffect>. El <xref:System.Windows.Media.TextEffect> está dentro de un <xref:System.Windows.FrameworkContentElement>del nombre de ámbito.  
  
 [!code-csharp[StoryboardBeginAnimation_procedural_snip#FrameworkContentElementStoryboardExampleUsingWholePage](~/samples/snippets/csharp/VS_Snippets_Wpf/StoryboardBeginAnimation_procedural_snip/CSharp/FrameworkContentElementStoryboardExample.cs#frameworkcontentelementstoryboardexampleusingwholepage)]
 [!code-vb[StoryboardBeginAnimation_procedural_snip#FrameworkContentElementStoryboardExampleUsingWholePage](~/samples/snippets/visualbasic/VS_Snippets_Wpf/StoryboardBeginAnimation_procedural_snip/visualbasic/frameworkcontentelementstoryboardexample.vb#frameworkcontentelementstoryboardexampleusingwholepage)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Begin">
      <MemberSignature Language="C#" Value="public void Begin (System.Windows.FrameworkElement containingObject);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Begin(class System.Windows.FrameworkElement containingObject) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.Begin(System.Windows.FrameworkElement)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Begin (containingObject As FrameworkElement)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Begin(System::Windows::FrameworkElement ^ containingObject);" />
      <MemberSignature Language="F#" Value="member this.Begin : System.Windows.FrameworkElement -&gt; unit" Usage="storyboard.Begin containingObject" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="containingObject" Type="System.Windows.FrameworkElement" />
      </Parameters>
      <Docs>
        <param name="containingObject">Objeto incluido dentro del mismo ámbito de nombres que los destinos de las animaciones de este guión gráfico. Las animaciones que no disponen de <see cref="P:System.Windows.Media.Animation.Storyboard.TargetName" /> se aplican a <c>containingObject</c>.</param>
        <summary>Aplica las animaciones asociadas con este <see cref="T:System.Windows.Media.Animation.Storyboard" /> a sus destinos y las inicia.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si las propiedades de destino ya están animadas, se reemplazan con el <xref:System.Windows.Media.Animation.HandoffBehavior.SnapshotAndReplace> comportamiento de entrega.  
  
 Guiones gráficos iniciados con este método no se en pausa, reanudar o en caso contrario, puede controlar interactivamente después de haberse iniciado. Para poder controlar un guión gráfico, use el <xref:System.Windows.Media.Animation.Storyboard.Begin%28System.Windows.FrameworkElement%2CSystem.Boolean%29> o <xref:System.Windows.Media.Animation.Storyboard.Begin%28System.Windows.FrameworkElement%2CSystem.Windows.Media.Animation.HandoffBehavior%2CSystem.Boolean%29> método.  
  
 Activa un guion gráfico a partir de la <xref:System.Windows.Media.Animation.Timeline.CurrentStateInvalidated> y <xref:System.Windows.Media.Animation.Timeline.CurrentGlobalSpeedInvalidated> eventos.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Begin">
      <MemberSignature Language="C#" Value="public void Begin (System.Windows.FrameworkContentElement containingObject, bool isControllable);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Begin(class System.Windows.FrameworkContentElement containingObject, bool isControllable) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.Begin(System.Windows.FrameworkContentElement,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Begin (containingObject As FrameworkContentElement, isControllable As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Begin(System::Windows::FrameworkContentElement ^ containingObject, bool isControllable);" />
      <MemberSignature Language="F#" Value="member this.Begin : System.Windows.FrameworkContentElement * bool -&gt; unit" Usage="storyboard.Begin (containingObject, isControllable)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="containingObject" Type="System.Windows.FrameworkContentElement" />
        <Parameter Name="isControllable" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="containingObject">Objeto incluido dentro del mismo ámbito de nombres que los destinos de las animaciones de este guión gráfico. Las animaciones que no disponen de <see cref="P:System.Windows.Media.Animation.Storyboard.TargetName" /> se aplican a <c>containingObject</c>.</param>
        <param name="isControllable">
          <see langword="true" /> si el guión gráfico debe controlarse de forma interactiva; de lo contrario, <see langword="false" />.</param>
        <summary>Aplica las animaciones asociadas con este <see cref="T:System.Windows.Media.Animation.Storyboard" /> a sus destinos y las inicia.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si las propiedades de destino ya están animadas, se reemplazan con el <xref:System.Windows.Media.Animation.HandoffBehavior.SnapshotAndReplace> comportamiento de entrega.  
  
 Para controlar este guión gráfico de forma interactiva, debe especificar los mismos `containingObject` al llamar a los métodos interactivos que usó para iniciar el guión gráfico  
  
 Cuando se llama a este método, <xref:System.Windows.Media.Animation.Clock> se crean objetos para el guión gráfico y las escalas de tiempo contiene. Estos relojes se almacenan con `containingObject`.  
  
 Activa un guion gráfico a partir de la <xref:System.Windows.Media.Animation.Timeline.CurrentStateInvalidated> y <xref:System.Windows.Media.Animation.Timeline.CurrentGlobalSpeedInvalidated> eventos.  
  
   
  
## Examples  
 En el ejemplo siguiente se usa un guión gráfico controlable para animar un <xref:System.Windows.Media.TextEffect>. El <xref:System.Windows.Media.TextEffect> está dentro de un <xref:System.Windows.FrameworkContentElement>del nombre de ámbito.  
  
 [!code-csharp[StoryboardBeginAnimation_procedural_snip#FrameworkContentElementControlStoryboardExampleUsingWholePage](~/samples/snippets/csharp/VS_Snippets_Wpf/StoryboardBeginAnimation_procedural_snip/CSharp/FrameworkContentElementControlStoryboardExample.cs#frameworkcontentelementcontrolstoryboardexampleusingwholepage)]
 [!code-vb[StoryboardBeginAnimation_procedural_snip#FrameworkContentElementControlStoryboardExampleUsingWholePage](~/samples/snippets/visualbasic/VS_Snippets_Wpf/StoryboardBeginAnimation_procedural_snip/visualbasic/frameworkcontentelementcontrolstoryboardexample.vb#frameworkcontentelementcontrolstoryboardexampleusingwholepage)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Begin">
      <MemberSignature Language="C#" Value="public void Begin (System.Windows.FrameworkContentElement containingObject, System.Windows.Media.Animation.HandoffBehavior handoffBehavior);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Begin(class System.Windows.FrameworkContentElement containingObject, valuetype System.Windows.Media.Animation.HandoffBehavior handoffBehavior) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.Begin(System.Windows.FrameworkContentElement,System.Windows.Media.Animation.HandoffBehavior)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Begin(System::Windows::FrameworkContentElement ^ containingObject, System::Windows::Media::Animation::HandoffBehavior handoffBehavior);" />
      <MemberSignature Language="F#" Value="member this.Begin : System.Windows.FrameworkContentElement * System.Windows.Media.Animation.HandoffBehavior -&gt; unit" Usage="storyboard.Begin (containingObject, handoffBehavior)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="containingObject" Type="System.Windows.FrameworkContentElement" />
        <Parameter Name="handoffBehavior" Type="System.Windows.Media.Animation.HandoffBehavior" />
      </Parameters>
      <Docs>
        <param name="containingObject">Objeto incluido dentro del mismo ámbito de nombres que los destinos de las animaciones de este guión gráfico. Las animaciones que no disponen de <see cref="P:System.Windows.Media.Animation.Storyboard.TargetName" /> se aplican a <c>containingObject</c>.</param>
        <param name="handoffBehavior">Comportamiento que la nueva animación debe utilizar para interactuar con las animaciones actuales.</param>
        <summary>Aplica las animaciones asociadas con este objeto <see cref="T:System.Windows.Media.Animation.Storyboard" /> a sus destinos y las inicia utilizando la enumeración <see cref="T:System.Windows.Media.Animation.HandoffBehavior" /> especificada.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Al aplicar un <xref:System.Windows.Media.Animation.Storyboard>, <xref:System.Windows.Media.Animation.AnimationTimeline>, o <xref:System.Windows.Media.Animation.AnimationClock> a una propiedad mediante el <xref:System.Windows.Media.Animation.HandoffBehavior.Compose> <xref:System.Windows.Media.Animation.HandoffBehavior>, cualquier <xref:System.Windows.Media.Animation.Clock> objetos asociados anteriormente a esa propiedad siguen consumiendo recursos del sistema, pero no el sistema de temporización Quite estos relojes automáticamente.  
  
 Para evitar problemas de rendimiento cuando aplique muchos relojes mediante <xref:System.Windows.Media.Animation.HandoffBehavior.Compose>, debe quitar los relojes de composición de la propiedad animada cuando se hayan completado. Hay varias formas de quitar un reloj.  
  
-   Para quitar todos los relojes de una propiedad, utilice el <xref:System.Windows.Media.Animation.Animatable.ApplyAnimationClock%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationClock%29> o <xref:System.Windows.Media.Animation.Animatable.BeginAnimation%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationTimeline%29> método del objeto animado. Especifique la propiedad animada como primer parámetro, y `null` como el segundo. Esto quita todos los relojes de animación de la propiedad.  
  
-   Para quitar un determinado <xref:System.Windows.Media.Animation.AnimationClock> desde una lista de relojes, utilice la <xref:System.Windows.Media.Animation.Clock.Controller%2A> propiedad de la <xref:System.Windows.Media.Animation.AnimationClock> para recuperar un <xref:System.Windows.Media.Animation.ClockController>, a continuación, llame a la <xref:System.Windows.Media.Animation.ClockController.Remove%2A> método de la <xref:System.Windows.Media.Animation.ClockController>. Esto se hace normalmente el <xref:System.Windows.Media.Animation.Clock.Completed> controlador de eventos de un reloj. Tenga en cuenta que los relojes de raíz única pueden controlarse mediante una <xref:System.Windows.Media.Animation.ClockController>; el <xref:System.Windows.Media.Animation.Clock.Controller%2A> devuelve la propiedad de un reloj secundario `null`. Tenga en cuenta también que el <xref:System.Windows.Media.Animation.Clock.Completed> eventos no se llama si la duración efectiva del reloj es para siempre.  En ese caso, el usuario debe determinar cuándo llamar a <xref:System.Windows.Media.Animation.ClockController.Remove%2A>.  
  
 Este problema se produce principalmente en las animaciones de objetos que tienen un período de duración prolongado.  Cuando un objeto se recolecta, sus relojes también se desconectan y el recolector.  
  
 Para obtener más información acerca de los objetos de reloj, consulte [Animation and Timing System Overview](~/docs/framework/wpf/graphics-multimedia/animation-and-timing-system-overview.md).  
  
   
  
## Examples  
 En el ejemplo siguiente se usa el <xref:System.Windows.Media.Animation.HandoffBehavior.SnapshotAndReplace> <xref:System.Windows.Media.Animation.HandoffBehavior> para animar cuando el usuario hace clic y el <xref:System.Windows.Media.Animation.HandoffBehavior.Compose> <xref:System.Windows.Media.Animation.HandoffBehavior> cuando el usuario seleccione.  
  
 [!code-csharp[StoryboardBeginAnimation_procedural_snip#FrameworkContentElementStoryboardWithHandoffBehaviorExampleWholePage](~/samples/snippets/csharp/VS_Snippets_Wpf/StoryboardBeginAnimation_procedural_snip/CSharp/FrameworkContentElementStoryboardWithHandoffBehaviorExample.cs#frameworkcontentelementstoryboardwithhandoffbehaviorexamplewholepage)]
 [!code-vb[StoryboardBeginAnimation_procedural_snip#FrameworkContentElementStoryboardWithHandoffBehaviorExampleWholePage](~/samples/snippets/visualbasic/VS_Snippets_Wpf/StoryboardBeginAnimation_procedural_snip/visualbasic/frameworkcontentelementstoryboardwithhandoffbehaviorexample.vb#frameworkcontentelementstoryboardwithhandoffbehaviorexamplewholepage)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Begin">
      <MemberSignature Language="C#" Value="public void Begin (System.Windows.FrameworkElement containingObject, bool isControllable);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Begin(class System.Windows.FrameworkElement containingObject, bool isControllable) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.Begin(System.Windows.FrameworkElement,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Begin (containingObject As FrameworkElement, isControllable As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Begin(System::Windows::FrameworkElement ^ containingObject, bool isControllable);" />
      <MemberSignature Language="F#" Value="member this.Begin : System.Windows.FrameworkElement * bool -&gt; unit" Usage="storyboard.Begin (containingObject, isControllable)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="containingObject" Type="System.Windows.FrameworkElement" />
        <Parameter Name="isControllable" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="containingObject">Objeto incluido dentro del mismo ámbito de nombres que los destinos de las animaciones de este guión gráfico. Las animaciones que no disponen de <see cref="P:System.Windows.Media.Animation.Storyboard.TargetName" /> se aplican a <c>containingObject</c>.</param>
        <param name="isControllable">
          <see langword="true" /> si el guión gráfico debe controlarse de forma interactiva; de lo contrario, <see langword="false" />.</param>
        <summary>Aplica las animaciones asociadas con este <see cref="T:System.Windows.Media.Animation.Storyboard" /> a sus destinos y las inicia.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si las propiedades de destino ya están animadas, se reemplazan con el <xref:System.Windows.Media.Animation.HandoffBehavior.SnapshotAndReplace> comportamiento de entrega.  
  
 Para controlar este guión gráfico de forma interactiva, debe usar el mismo `containingObject` parámetro al llamar a los métodos interactivos que usó para iniciar el guión gráfico  
  
 Cuando se llama a este método, <xref:System.Windows.Media.Animation.Clock> se crean objetos para el guión gráfico y las escalas de tiempo contiene. Estos relojes se almacenan con `containingObject`.  
  
 Activa un guion gráfico a partir de la <xref:System.Windows.Media.Animation.Timeline.CurrentStateInvalidated> y <xref:System.Windows.Media.Animation.Timeline.CurrentGlobalSpeedInvalidated> eventos.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Begin">
      <MemberSignature Language="C#" Value="public void Begin (System.Windows.FrameworkElement containingObject, System.Windows.FrameworkTemplate frameworkTemplate);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Begin(class System.Windows.FrameworkElement containingObject, class System.Windows.FrameworkTemplate frameworkTemplate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.Begin(System.Windows.FrameworkElement,System.Windows.FrameworkTemplate)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Begin(System::Windows::FrameworkElement ^ containingObject, System::Windows::FrameworkTemplate ^ frameworkTemplate);" />
      <MemberSignature Language="F#" Value="member this.Begin : System.Windows.FrameworkElement * System.Windows.FrameworkTemplate -&gt; unit" Usage="storyboard.Begin (containingObject, frameworkTemplate)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="containingObject" Type="System.Windows.FrameworkElement" />
        <Parameter Name="frameworkTemplate" Type="System.Windows.FrameworkTemplate" />
      </Parameters>
      <Docs>
        <param name="containingObject">Objeto al que se ha aplicado el parámetro <c>frameworkTemplate</c> especificado. Las animaciones que no disponen de <see cref="P:System.Windows.Media.Animation.Storyboard.TargetName" /> se aplican a <c>containingObject</c>.</param>
        <param name="frameworkTemplate">Plantilla que se va a animar.</param>
        <summary>Aplica las animaciones asociadas con este objeto <see cref="T:System.Windows.Media.Animation.Storyboard" /> a sus destinos en la plantilla especificada y las inicia.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si las propiedades de destino ya están animadas, se reemplazan con el <xref:System.Windows.Media.Animation.HandoffBehavior.SnapshotAndReplace> comportamiento de entrega.  
  
 Cuando se llama a este método, <xref:System.Windows.Media.Animation.Clock> se crean objetos para el guión gráfico y las escalas de tiempo contiene. Estos relojes se almacenan con `containingObject`.  
  
 Activa un guion gráfico a partir de la <xref:System.Windows.Media.Animation.Timeline.CurrentStateInvalidated> y <xref:System.Windows.Media.Animation.Timeline.CurrentGlobalSpeedInvalidated> eventos.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Begin">
      <MemberSignature Language="C#" Value="public void Begin (System.Windows.FrameworkElement containingObject, System.Windows.Media.Animation.HandoffBehavior handoffBehavior);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Begin(class System.Windows.FrameworkElement containingObject, valuetype System.Windows.Media.Animation.HandoffBehavior handoffBehavior) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.Begin(System.Windows.FrameworkElement,System.Windows.Media.Animation.HandoffBehavior)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Begin(System::Windows::FrameworkElement ^ containingObject, System::Windows::Media::Animation::HandoffBehavior handoffBehavior);" />
      <MemberSignature Language="F#" Value="member this.Begin : System.Windows.FrameworkElement * System.Windows.Media.Animation.HandoffBehavior -&gt; unit" Usage="storyboard.Begin (containingObject, handoffBehavior)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="containingObject" Type="System.Windows.FrameworkElement" />
        <Parameter Name="handoffBehavior" Type="System.Windows.Media.Animation.HandoffBehavior" />
      </Parameters>
      <Docs>
        <param name="containingObject">Objeto incluido dentro del mismo ámbito de nombres que los destinos de las animaciones de este guión gráfico. Las animaciones en las que no se ha especificado <see cref="P:System.Windows.Media.Animation.Storyboard.TargetName" /> se aplican a <c>containingObject</c>.</param>
        <param name="handoffBehavior">Comportamiento que la nueva animación debe utilizar para interactuar con las animaciones actuales.</param>
        <summary>Aplica las animaciones asociadas con este objeto <see cref="T:System.Windows.Media.Animation.Storyboard" /> a sus destinos y las inicia utilizando la enumeración <see cref="T:System.Windows.Media.Animation.HandoffBehavior" /> especificada.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 En el ejemplo siguiente se usa el <xref:System.Windows.Media.Animation.HandoffBehavior.SnapshotAndReplace> <xref:System.Windows.Media.Animation.HandoffBehavior> para animar cuando el usuario hace clic y el <xref:System.Windows.Media.Animation.HandoffBehavior.Compose> <xref:System.Windows.Media.Animation.HandoffBehavior> cuando el usuario seleccione.  
  
 [!code-csharp[StoryboardBeginAnimation_procedural_snip#GraphicsMMFrameworkElementStoryboardHandoffBehaviorExample](~/samples/snippets/csharp/VS_Snippets_Wpf/StoryboardBeginAnimation_procedural_snip/CSharp/FrameworkElementStoryboardHandoffBehaviorExample.cs#graphicsmmframeworkelementstoryboardhandoffbehaviorexample)]
 [!code-vb[StoryboardBeginAnimation_procedural_snip#GraphicsMMFrameworkElementStoryboardHandoffBehaviorExample](~/samples/snippets/visualbasic/VS_Snippets_Wpf/StoryboardBeginAnimation_procedural_snip/visualbasic/frameworkelementstoryboardhandoffbehaviorexample.vb#graphicsmmframeworkelementstoryboardhandoffbehaviorexample)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Begin">
      <MemberSignature Language="C#" Value="public void Begin (System.Windows.FrameworkContentElement containingObject, System.Windows.Media.Animation.HandoffBehavior handoffBehavior, bool isControllable);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Begin(class System.Windows.FrameworkContentElement containingObject, valuetype System.Windows.Media.Animation.HandoffBehavior handoffBehavior, bool isControllable) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.Begin(System.Windows.FrameworkContentElement,System.Windows.Media.Animation.HandoffBehavior,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Begin(System::Windows::FrameworkContentElement ^ containingObject, System::Windows::Media::Animation::HandoffBehavior handoffBehavior, bool isControllable);" />
      <MemberSignature Language="F#" Value="member this.Begin : System.Windows.FrameworkContentElement * System.Windows.Media.Animation.HandoffBehavior * bool -&gt; unit" Usage="storyboard.Begin (containingObject, handoffBehavior, isControllable)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="containingObject" Type="System.Windows.FrameworkContentElement" />
        <Parameter Name="handoffBehavior" Type="System.Windows.Media.Animation.HandoffBehavior" />
        <Parameter Name="isControllable" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="containingObject">Objeto incluido dentro del mismo ámbito de nombres que los destinos de las animaciones de este guión gráfico. Las animaciones en las que no se ha especificado <see cref="P:System.Windows.Media.Animation.Storyboard.TargetName" /> se aplican a <c>containingObject</c>.</param>
        <param name="handoffBehavior">Comportamiento que la nueva animación debe utilizar para interactuar con las animaciones actuales.</param>
        <param name="isControllable">Declara si la animación se puede controlar (se puede pausar) una vez que se ha iniciado.</param>
        <summary>Aplica las animaciones asociadas con este objeto <see cref="T:System.Windows.Media.Animation.Storyboard" /> a sus destinos y las inicia utilizando la enumeración <see cref="T:System.Windows.Media.Animation.HandoffBehavior" /> especificada.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si las propiedades de destino ya están animadas, se reemplazan con el comportamiento de entrega especificada.  
  
 Para controlar este guión gráfico de forma interactiva, debe especificar los mismos `containingObject` al llamar a los métodos interactivos que usó para iniciar el guión gráfico  
  
 Cuando se llama a este método, <xref:System.Windows.Media.Animation.Clock> se crean objetos para el guión gráfico y las escalas de tiempo contiene. Estos relojes se almacenan con `containingObject`.  
  
 Activa un guion gráfico a partir de la <xref:System.Windows.Media.Animation.Timeline.CurrentStateInvalidated> y <xref:System.Windows.Media.Animation.Timeline.CurrentGlobalSpeedInvalidated> eventos.  
  
## <a name="using-the-compose-handoffbehavior"></a>Mediante el campo Compose de HandoffBehavior  
 Al aplicar un <xref:System.Windows.Media.Animation.Storyboard>, <xref:System.Windows.Media.Animation.AnimationTimeline>, o <xref:System.Windows.Media.Animation.AnimationClock> a una propiedad mediante el <xref:System.Windows.Media.Animation.HandoffBehavior.Compose> <xref:System.Windows.Media.Animation.HandoffBehavior>, cualquier <xref:System.Windows.Media.Animation.Clock> objetos asociados anteriormente a esa propiedad siguen consumiendo recursos del sistema, pero no el sistema de temporización Quite estos relojes automáticamente.  
  
 Para evitar problemas de rendimiento cuando aplique muchos relojes mediante <xref:System.Windows.Media.Animation.HandoffBehavior.Compose>, debe quitar los relojes de composición de la propiedad animada cuando se hayan completado. Hay varias formas de quitar un reloj.  
  
-   Para quitar todos los relojes de una propiedad, utilice el <xref:System.Windows.Media.Animation.Animatable.ApplyAnimationClock%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationClock%29> o <xref:System.Windows.Media.Animation.Animatable.BeginAnimation%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationTimeline%29> método del objeto animado. Especifique la propiedad animada como primer parámetro, y `null` como el segundo. Esto quita todos los relojes de animación de la propiedad.  
  
-   Para quitar un determinado <xref:System.Windows.Media.Animation.AnimationClock> desde una lista de relojes, utilice la <xref:System.Windows.Media.Animation.Clock.Controller%2A> propiedad de la <xref:System.Windows.Media.Animation.AnimationClock> para recuperar un <xref:System.Windows.Media.Animation.ClockController>, a continuación, llame a la <xref:System.Windows.Media.Animation.ClockController.Remove%2A> método de la <xref:System.Windows.Media.Animation.ClockController>. Esto se hace normalmente el <xref:System.Windows.Media.Animation.Clock.Completed> controlador de eventos de un reloj. Tenga en cuenta que los relojes de raíz única pueden controlarse mediante una <xref:System.Windows.Media.Animation.ClockController>; el <xref:System.Windows.Media.Animation.Clock.Controller%2A> devuelve la propiedad de un reloj secundario `null`. Tenga en cuenta también que el <xref:System.Windows.Media.Animation.Clock.Completed> eventos no se llama si la duración efectiva del reloj es para siempre.  En ese caso, el usuario debe determinar cuándo llamar a <xref:System.Windows.Media.Animation.ClockController.Remove%2A>.  
  
 Este problema se produce principalmente en las animaciones de objetos que tienen un período de duración prolongado.  Cuando un objeto se recolecta, sus relojes también se desconectan y el recolector.  
  
 Para obtener más información acerca de los objetos de reloj, consulte [Animation and Timing System Overview](~/docs/framework/wpf/graphics-multimedia/animation-and-timing-system-overview.md).  
  
   
  
## Examples  
 En el ejemplo siguiente se usa un guión gráfico controlable para animar un <xref:System.Windows.Media.TextEffect>. El <xref:System.Windows.Media.TextEffect> está dentro de un <xref:System.Windows.FrameworkContentElement>del nombre de ámbito.  
  
 [!code-csharp[StoryboardBeginAnimation_procedural_snip#FrameworkContentElementControlStoryboardExampleUsingWholePage](~/samples/snippets/csharp/VS_Snippets_Wpf/StoryboardBeginAnimation_procedural_snip/CSharp/FrameworkContentElementControlStoryboardExample.cs#frameworkcontentelementcontrolstoryboardexampleusingwholepage)]
 [!code-vb[StoryboardBeginAnimation_procedural_snip#FrameworkContentElementControlStoryboardExampleUsingWholePage](~/samples/snippets/visualbasic/VS_Snippets_Wpf/StoryboardBeginAnimation_procedural_snip/visualbasic/frameworkcontentelementcontrolstoryboardexample.vb#frameworkcontentelementcontrolstoryboardexampleusingwholepage)]  
  
 En el ejemplo siguiente se usa el <xref:System.Windows.Media.Animation.HandoffBehavior.SnapshotAndReplace> <xref:System.Windows.Media.Animation.HandoffBehavior> para animar cuando el usuario hace clic y el <xref:System.Windows.Media.Animation.HandoffBehavior.Compose> <xref:System.Windows.Media.Animation.HandoffBehavior> cuando el usuario seleccione.  
  
 [!code-csharp[StoryboardBeginAnimation_procedural_snip#FrameworkContentElementStoryboardWithHandoffBehaviorExampleWholePage](~/samples/snippets/csharp/VS_Snippets_Wpf/StoryboardBeginAnimation_procedural_snip/CSharp/FrameworkContentElementStoryboardWithHandoffBehaviorExample.cs#frameworkcontentelementstoryboardwithhandoffbehaviorexamplewholepage)]
 [!code-vb[StoryboardBeginAnimation_procedural_snip#FrameworkContentElementStoryboardWithHandoffBehaviorExampleWholePage](~/samples/snippets/visualbasic/VS_Snippets_Wpf/StoryboardBeginAnimation_procedural_snip/visualbasic/frameworkcontentelementstoryboardwithhandoffbehaviorexample.vb#frameworkcontentelementstoryboardwithhandoffbehaviorexamplewholepage)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Begin">
      <MemberSignature Language="C#" Value="public void Begin (System.Windows.FrameworkElement containingObject, System.Windows.FrameworkTemplate frameworkTemplate, bool isControllable);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Begin(class System.Windows.FrameworkElement containingObject, class System.Windows.FrameworkTemplate frameworkTemplate, bool isControllable) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.Begin(System.Windows.FrameworkElement,System.Windows.FrameworkTemplate,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Begin(System::Windows::FrameworkElement ^ containingObject, System::Windows::FrameworkTemplate ^ frameworkTemplate, bool isControllable);" />
      <MemberSignature Language="F#" Value="member this.Begin : System.Windows.FrameworkElement * System.Windows.FrameworkTemplate * bool -&gt; unit" Usage="storyboard.Begin (containingObject, frameworkTemplate, isControllable)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="containingObject" Type="System.Windows.FrameworkElement" />
        <Parameter Name="frameworkTemplate" Type="System.Windows.FrameworkTemplate" />
        <Parameter Name="isControllable" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="containingObject">Objeto al que se ha aplicado el parámetro <c>frameworkTemplate</c> especificado.  Las animaciones que no disponen de <see cref="P:System.Windows.Media.Animation.Storyboard.TargetName" /> se aplican a <c>containingObject</c>.</param>
        <param name="frameworkTemplate">Plantilla que se va a animar.</param>
        <param name="isControllable">
          <see langword="true" /> si el guión gráfico debe controlarse de forma interactiva; de lo contrario, <see langword="false" />.</param>
        <summary>Aplica las animaciones asociadas con este objeto <see cref="T:System.Windows.Media.Animation.Storyboard" /> a sus destinos en la plantilla especificada y las inicia.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si las propiedades de destino ya están animadas, se reemplazan con el <xref:System.Windows.Media.Animation.HandoffBehavior.SnapshotAndReplace> comportamiento de entrega.  
  
 Para controlar este guión gráfico de forma interactiva, debe especificar los mismos `containingObject` al llamar a los métodos interactivos que usó para iniciar el guión gráfico  
  
 Cuando se llama a este método, <xref:System.Windows.Media.Animation.Clock> se crean objetos para el guión gráfico y las escalas de tiempo contiene. Estos relojes se almacenan con `containingObject`.  
  
 Activa un guion gráfico a partir de la <xref:System.Windows.Media.Animation.Timeline.CurrentStateInvalidated> y <xref:System.Windows.Media.Animation.Timeline.CurrentGlobalSpeedInvalidated> eventos.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Begin">
      <MemberSignature Language="C#" Value="public void Begin (System.Windows.FrameworkElement containingObject, System.Windows.FrameworkTemplate frameworkTemplate, System.Windows.Media.Animation.HandoffBehavior handoffBehavior);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Begin(class System.Windows.FrameworkElement containingObject, class System.Windows.FrameworkTemplate frameworkTemplate, valuetype System.Windows.Media.Animation.HandoffBehavior handoffBehavior) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.Begin(System.Windows.FrameworkElement,System.Windows.FrameworkTemplate,System.Windows.Media.Animation.HandoffBehavior)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Begin(System::Windows::FrameworkElement ^ containingObject, System::Windows::FrameworkTemplate ^ frameworkTemplate, System::Windows::Media::Animation::HandoffBehavior handoffBehavior);" />
      <MemberSignature Language="F#" Value="member this.Begin : System.Windows.FrameworkElement * System.Windows.FrameworkTemplate * System.Windows.Media.Animation.HandoffBehavior -&gt; unit" Usage="storyboard.Begin (containingObject, frameworkTemplate, handoffBehavior)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="containingObject" Type="System.Windows.FrameworkElement" />
        <Parameter Name="frameworkTemplate" Type="System.Windows.FrameworkTemplate" />
        <Parameter Name="handoffBehavior" Type="System.Windows.Media.Animation.HandoffBehavior" />
      </Parameters>
      <Docs>
        <param name="containingObject">Objeto al que se ha aplicado el parámetro <c>frameworkTemplate</c> especificado. Las animaciones que no disponen de <see cref="P:System.Windows.Media.Animation.Storyboard.TargetName" /> se aplican a <c>containingObject</c>.</param>
        <param name="frameworkTemplate">Plantilla que se va a animar.</param>
        <param name="handoffBehavior">Comportamiento que la nueva animación debe utilizar para interactuar con las animaciones actuales.</param>
        <summary>Aplica las animaciones asociadas con este objeto <see cref="T:System.Windows.Media.Animation.Storyboard" /> a sus destinos en la plantilla especificada y las inicia.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cuando se llama a este método, <xref:System.Windows.Media.Animation.Clock> se crean objetos para el guión gráfico y las escalas de tiempo contiene. Estos relojes se almacenan con `containingObject`.  
  
 Activa un guion gráfico a partir de la <xref:System.Windows.Media.Animation.Timeline.CurrentStateInvalidated> y <xref:System.Windows.Media.Animation.Timeline.CurrentGlobalSpeedInvalidated> eventos.  
  
## <a name="using-the-compose-handoffbehavior"></a>Mediante el campo Compose de HandoffBehavior  
 Al aplicar un <xref:System.Windows.Media.Animation.Storyboard>, <xref:System.Windows.Media.Animation.AnimationTimeline>, o <xref:System.Windows.Media.Animation.AnimationClock> a una propiedad mediante el <xref:System.Windows.Media.Animation.HandoffBehavior.Compose> <xref:System.Windows.Media.Animation.HandoffBehavior>, cualquier <xref:System.Windows.Media.Animation.Clock> objetos asociados anteriormente a esa propiedad siguen consumiendo recursos del sistema, pero no el sistema de temporización Quite estos relojes automáticamente.  
  
 Para evitar problemas de rendimiento cuando aplique muchos relojes mediante <xref:System.Windows.Media.Animation.HandoffBehavior.Compose>, debe quitar los relojes de composición de la propiedad animada cuando se hayan completado. Hay varias formas de quitar un reloj.  
  
-   Para quitar todos los relojes de una propiedad, utilice el <xref:System.Windows.Media.Animation.Animatable.ApplyAnimationClock%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationClock%29> o <xref:System.Windows.Media.Animation.Animatable.BeginAnimation%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationTimeline%29> método del objeto animado. Especifique la propiedad animada como primer parámetro, y `null` como el segundo. Esto quita todos los relojes de animación de la propiedad.  
  
-   Para quitar un determinado <xref:System.Windows.Media.Animation.AnimationClock> desde una lista de relojes, utilice la <xref:System.Windows.Media.Animation.Clock.Controller%2A> propiedad de la <xref:System.Windows.Media.Animation.AnimationClock> para recuperar un <xref:System.Windows.Media.Animation.ClockController>, a continuación, llame a la <xref:System.Windows.Media.Animation.ClockController.Remove%2A> método de la <xref:System.Windows.Media.Animation.ClockController>. Esto se hace normalmente el <xref:System.Windows.Media.Animation.Clock.Completed> controlador de eventos de un reloj. Tenga en cuenta que los relojes de raíz única pueden controlarse mediante una <xref:System.Windows.Media.Animation.ClockController>; el <xref:System.Windows.Media.Animation.Clock.Controller%2A> devuelve la propiedad de un reloj secundario `null`. Tenga en cuenta también que el <xref:System.Windows.Media.Animation.Clock.Completed> eventos no se llama si la duración efectiva del reloj es para siempre.  En ese caso, el usuario debe determinar cuándo llamar a <xref:System.Windows.Media.Animation.ClockController.Remove%2A>.  
  
 Este problema se produce principalmente en las animaciones de objetos que tienen un período de duración prolongado.  Cuando un objeto se recolecta, sus relojes también se desconectan y el recolector.  
  
 Para obtener más información acerca de los objetos de reloj, consulte [Animation and Timing System Overview](~/docs/framework/wpf/graphics-multimedia/animation-and-timing-system-overview.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Begin">
      <MemberSignature Language="C#" Value="public void Begin (System.Windows.FrameworkElement containingObject, System.Windows.Media.Animation.HandoffBehavior handoffBehavior, bool isControllable);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Begin(class System.Windows.FrameworkElement containingObject, valuetype System.Windows.Media.Animation.HandoffBehavior handoffBehavior, bool isControllable) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.Begin(System.Windows.FrameworkElement,System.Windows.Media.Animation.HandoffBehavior,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Begin(System::Windows::FrameworkElement ^ containingObject, System::Windows::Media::Animation::HandoffBehavior handoffBehavior, bool isControllable);" />
      <MemberSignature Language="F#" Value="member this.Begin : System.Windows.FrameworkElement * System.Windows.Media.Animation.HandoffBehavior * bool -&gt; unit" Usage="storyboard.Begin (containingObject, handoffBehavior, isControllable)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="containingObject" Type="System.Windows.FrameworkElement" />
        <Parameter Name="handoffBehavior" Type="System.Windows.Media.Animation.HandoffBehavior" />
        <Parameter Name="isControllable" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="containingObject">Objeto incluido dentro del mismo ámbito de nombres que los destinos de las animaciones de este guión gráfico. Las animaciones en las que no se ha especificado <see cref="P:System.Windows.Media.Animation.Storyboard.TargetName" /> se aplican a <c>containingObject</c>.</param>
        <param name="handoffBehavior">Comportamiento que la nueva animación debe utilizar para interactuar con las animaciones actuales.</param>
        <param name="isControllable">Declara si la animación se puede controlar (se puede pausar) una vez que se ha iniciado.</param>
        <summary>Aplica las animaciones asociadas con este <see cref="T:System.Windows.Media.Animation.Storyboard" /> a sus destinos y las inicia.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para controlar este guión gráfico de forma interactiva, debe usar el mismo `containingObject` parámetro al llamar a los métodos interactivos que usó para iniciar el guión gráfico  
  
 Cuando se llama a este método, <xref:System.Windows.Media.Animation.Clock> se crean objetos para el guión gráfico y las escalas de tiempo contiene. Estos relojes se almacenan con `containingObject`.  
  
 Activa un guion gráfico a partir de la <xref:System.Windows.Media.Animation.Timeline.CurrentStateInvalidated> y <xref:System.Windows.Media.Animation.Timeline.CurrentGlobalSpeedInvalidated> eventos.  
  
## <a name="using-the-compose-handoffbehavior"></a>Mediante el campo Compose de HandoffBehavior  
 Al aplicar un <xref:System.Windows.Media.Animation.Storyboard>, <xref:System.Windows.Media.Animation.AnimationTimeline>, o <xref:System.Windows.Media.Animation.AnimationClock> a una propiedad mediante el <xref:System.Windows.Media.Animation.HandoffBehavior.Compose> <xref:System.Windows.Media.Animation.HandoffBehavior>, cualquier <xref:System.Windows.Media.Animation.Clock> objetos asociados anteriormente a esa propiedad siguen consumiendo recursos del sistema, pero no el sistema de temporización Quite estos relojes automáticamente.  
  
 Para evitar problemas de rendimiento cuando aplique muchos relojes mediante <xref:System.Windows.Media.Animation.HandoffBehavior.Compose>, debe quitar los relojes de composición de la propiedad animada cuando se hayan completado. Hay varias formas de quitar un reloj.  
  
-   Para quitar todos los relojes de una propiedad, utilice el <xref:System.Windows.Media.Animation.Animatable.ApplyAnimationClock%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationClock%29> o <xref:System.Windows.Media.Animation.Animatable.BeginAnimation%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationTimeline%29> método del objeto animado. Especifique la propiedad animada como primer parámetro, y `null` como el segundo. Esto quita todos los relojes de animación de la propiedad.  
  
-   Para quitar un determinado <xref:System.Windows.Media.Animation.AnimationClock> desde una lista de relojes, utilice la <xref:System.Windows.Media.Animation.Clock.Controller%2A> propiedad de la <xref:System.Windows.Media.Animation.AnimationClock> para recuperar un <xref:System.Windows.Media.Animation.ClockController>, a continuación, llame a la <xref:System.Windows.Media.Animation.ClockController.Remove%2A> método de la <xref:System.Windows.Media.Animation.ClockController>. Esto se hace normalmente el <xref:System.Windows.Media.Animation.Clock.Completed> controlador de eventos de un reloj. Tenga en cuenta que los relojes de raíz única pueden controlarse mediante una <xref:System.Windows.Media.Animation.ClockController>; el <xref:System.Windows.Media.Animation.Clock.Controller%2A> devuelve la propiedad de un reloj secundario `null`. Tenga en cuenta también que el <xref:System.Windows.Media.Animation.Clock.Completed> eventos no se llama si la duración efectiva del reloj es para siempre.  En ese caso, el usuario debe determinar cuándo llamar a <xref:System.Windows.Media.Animation.ClockController.Remove%2A>.  
  
 Este problema se produce principalmente en las animaciones de objetos que tienen un período de duración prolongado.  Cuando un objeto se recolecta, sus relojes también se desconectan y el recolector.  
  
 Para obtener más información acerca de los objetos de reloj, consulte [Animation and Timing System Overview](~/docs/framework/wpf/graphics-multimedia/animation-and-timing-system-overview.md).  
  
   
  
## Examples  
 El ejemplo siguiente muestra cómo crear un guión gráfico controlable.  
  
 [!code-csharp[animation_ovws_procedural_snip#ControllableStoryboardExampleWholePage](~/samples/snippets/csharp/VS_Snippets_Wpf/animation_ovws_procedural_snip/CSharp/ControllableStoryboardExample.cs#controllablestoryboardexamplewholepage)]
 [!code-vb[animation_ovws_procedural_snip#ControllableStoryboardExampleWholePage](~/samples/snippets/visualbasic/VS_Snippets_Wpf/animation_ovws_procedural_snip/visualbasic/controllablestoryboardexample.vb#controllablestoryboardexamplewholepage)]  
  
 En el ejemplo siguiente se usa el <xref:System.Windows.Media.Animation.HandoffBehavior.SnapshotAndReplace> <xref:System.Windows.Media.Animation.HandoffBehavior> para animar cuando el usuario hace clic y el <xref:System.Windows.Media.Animation.HandoffBehavior.Compose> <xref:System.Windows.Media.Animation.HandoffBehavior> cuando el usuario seleccione.  
  
 [!code-csharp[StoryboardBeginAnimation_procedural_snip#GraphicsMMFrameworkElementStoryboardHandoffBehaviorExample](~/samples/snippets/csharp/VS_Snippets_Wpf/StoryboardBeginAnimation_procedural_snip/CSharp/FrameworkElementStoryboardHandoffBehaviorExample.cs#graphicsmmframeworkelementstoryboardhandoffbehaviorexample)]
 [!code-vb[StoryboardBeginAnimation_procedural_snip#GraphicsMMFrameworkElementStoryboardHandoffBehaviorExample](~/samples/snippets/visualbasic/VS_Snippets_Wpf/StoryboardBeginAnimation_procedural_snip/visualbasic/frameworkelementstoryboardhandoffbehaviorexample.vb#graphicsmmframeworkelementstoryboardhandoffbehaviorexample)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Begin">
      <MemberSignature Language="C#" Value="public void Begin (System.Windows.FrameworkElement containingObject, System.Windows.FrameworkTemplate frameworkTemplate, System.Windows.Media.Animation.HandoffBehavior handoffBehavior, bool isControllable);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Begin(class System.Windows.FrameworkElement containingObject, class System.Windows.FrameworkTemplate frameworkTemplate, valuetype System.Windows.Media.Animation.HandoffBehavior handoffBehavior, bool isControllable) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.Begin(System.Windows.FrameworkElement,System.Windows.FrameworkTemplate,System.Windows.Media.Animation.HandoffBehavior,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Begin(System::Windows::FrameworkElement ^ containingObject, System::Windows::FrameworkTemplate ^ frameworkTemplate, System::Windows::Media::Animation::HandoffBehavior handoffBehavior, bool isControllable);" />
      <MemberSignature Language="F#" Value="member this.Begin : System.Windows.FrameworkElement * System.Windows.FrameworkTemplate * System.Windows.Media.Animation.HandoffBehavior * bool -&gt; unit" Usage="storyboard.Begin (containingObject, frameworkTemplate, handoffBehavior, isControllable)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="containingObject" Type="System.Windows.FrameworkElement" />
        <Parameter Name="frameworkTemplate" Type="System.Windows.FrameworkTemplate" />
        <Parameter Name="handoffBehavior" Type="System.Windows.Media.Animation.HandoffBehavior" />
        <Parameter Name="isControllable" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="containingObject">Objeto al que se ha aplicado el parámetro <c>frameworkTemplate</c> especificado. Las animaciones que no disponen de <see cref="P:System.Windows.Media.Animation.Storyboard.TargetName" /> se aplican a <c>containingObject</c>.</param>
        <param name="frameworkTemplate">Plantilla que se va a animar.</param>
        <param name="handoffBehavior">Comportamiento que la nueva animación debe utilizar para interactuar con las animaciones actuales.</param>
        <param name="isControllable">
          <see langword="true" /> si el guión gráfico debe controlarse de forma interactiva; de lo contrario, <see langword="false" />.</param>
        <summary>Aplica las animaciones asociadas con este objeto <see cref="T:System.Windows.Media.Animation.Storyboard" /> a sus destinos en la plantilla especificada y las inicia.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para controlar este guión gráfico de forma interactiva, debe especificar los mismos `containingObject` al llamar a los métodos interactivos que usó para iniciar el guión gráfico  
  
 Cuando se llama a este método, <xref:System.Windows.Media.Animation.Clock> se crean objetos para el guión gráfico y las escalas de tiempo contiene. Estos relojes se almacenan con `containingObject`.  
  
 Activa un guion gráfico a partir de la <xref:System.Windows.Media.Animation.Timeline.CurrentStateInvalidated> y <xref:System.Windows.Media.Animation.Timeline.CurrentGlobalSpeedInvalidated> eventos.  
  
## <a name="using-the-compose-handoffbehavior"></a>Mediante el campo Compose de HandoffBehavior  
 Al aplicar un <xref:System.Windows.Media.Animation.Storyboard>, <xref:System.Windows.Media.Animation.AnimationTimeline>, o <xref:System.Windows.Media.Animation.AnimationClock> a una propiedad mediante el <xref:System.Windows.Media.Animation.HandoffBehavior.Compose> <xref:System.Windows.Media.Animation.HandoffBehavior>, cualquier <xref:System.Windows.Media.Animation.Clock> objetos asociados anteriormente a esa propiedad siguen consumiendo recursos del sistema, pero no el sistema de temporización Quite estos relojes automáticamente.  
  
 Para evitar problemas de rendimiento cuando aplique muchos relojes mediante <xref:System.Windows.Media.Animation.HandoffBehavior.Compose>, debe quitar los relojes de composición de la propiedad animada cuando se hayan completado. Hay varias formas de quitar un reloj.  
  
-   Para quitar todos los relojes de una propiedad, utilice el <xref:System.Windows.Media.Animation.Animatable.ApplyAnimationClock%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationClock%29> o <xref:System.Windows.Media.Animation.Animatable.BeginAnimation%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationTimeline%29> método del objeto animado. Especifique la propiedad animada como primer parámetro, y `null` como el segundo. Esto quita todos los relojes de animación de la propiedad.  
  
-   Para quitar un determinado <xref:System.Windows.Media.Animation.AnimationClock> desde una lista de relojes, utilice la <xref:System.Windows.Media.Animation.Clock.Controller%2A> propiedad de la <xref:System.Windows.Media.Animation.AnimationClock> para recuperar un <xref:System.Windows.Media.Animation.ClockController>, a continuación, llame a la <xref:System.Windows.Media.Animation.ClockController.Remove%2A> método de la <xref:System.Windows.Media.Animation.ClockController>. Esto se hace normalmente el <xref:System.Windows.Media.Animation.Clock.Completed> controlador de eventos de un reloj. Tenga en cuenta que los relojes de raíz única pueden controlarse mediante una <xref:System.Windows.Media.Animation.ClockController>; el <xref:System.Windows.Media.Animation.Clock.Controller%2A> devuelve la propiedad de un reloj secundario `null`. Tenga en cuenta también que el <xref:System.Windows.Media.Animation.Clock.Completed> eventos no se llama si la duración efectiva del reloj es para siempre.  En ese caso, el usuario debe determinar cuándo llamar a <xref:System.Windows.Media.Animation.ClockController.Remove%2A>.  
  
 Este problema se produce principalmente en las animaciones de objetos que tienen un período de duración prolongado.  Cuando un objeto se recolecta, sus relojes también se desconectan y el recolector.  
  
 Para obtener más información acerca de los objetos de reloj, consulte [Animation and Timing System Overview](~/docs/framework/wpf/graphics-multimedia/animation-and-timing-system-overview.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Clone">
      <MemberSignature Language="C#" Value="public System.Windows.Media.Animation.Storyboard Clone ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Media.Animation.Storyboard Clone() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.Clone" />
      <MemberSignature Language="VB.NET" Value="Public Function Clone () As Storyboard" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Media::Animation::Storyboard ^ Clone();" />
      <MemberSignature Language="F#" Value="override this.Clone : unit -&gt; System.Windows.Media.Animation.Storyboard" Usage="storyboard.Clone " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Media.Animation.Storyboard</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Crea un clon modificable de este <see cref="T:System.Windows.Media.Animation.Storyboard" /> y hace copias en profundidad de los valores de este objeto. Cuando se copian propiedades de dependencia, este método copia las referencias de recursos y enlaces de datos (aunque podrían no resolverse), pero no copia las animaciones ni sus valores actuales.</summary>
        <returns>Clon modificable del objeto actual. La propiedad <see cref="P:System.Windows.Freezable.IsFrozen" /> del objeto clonado es <see langword="false" /> aunque la propiedad <see cref="P:System.Windows.Freezable.IsFrozen" /> del origen sea <see langword="true." /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método se usa para producir copias modificables de inmovilizado <xref:System.Windows.Freezable> objetos (o cualquier <xref:System.Windows.Freezable> objeto). Para mayor comodidad, este método prevalece sobre la versión heredada con una implementación fuertemente tipada.  
  
 Para obtener más información, vea <xref:System.Windows.Freezable.Clone%2A?displayProperty=nameWithType>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateInstanceCore">
      <MemberSignature Language="C#" Value="protected override System.Windows.Freezable CreateInstanceCore ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance class System.Windows.Freezable CreateInstanceCore() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.CreateInstanceCore" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function CreateInstanceCore () As Freezable" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override System::Windows::Freezable ^ CreateInstanceCore();" />
      <MemberSignature Language="F#" Value="override this.CreateInstanceCore : unit -&gt; System.Windows.Freezable" Usage="storyboard.CreateInstanceCore " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Freezable</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Crea una nueva instancia de la clase <see cref="T:System.Windows.Media.Animation.Storyboard" />.</summary>
        <returns>Nueva instancia de <see cref="T:System.Windows.Media.Animation.Storyboard" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método se llama internamente en <xref:System.Windows.Freezable.CreateInstance%2A> al crear nuevas instancias de la <xref:System.Windows.Media.Animation.Storyboard> clase para los distintos métodos de clonación (como <xref:System.Windows.Freezable.Clone%2A> y <xref:System.Windows.Freezable.CloneCurrentValue%2A>).  
  
   
  
## Examples  
 El ejemplo siguiente muestra una implementación típica de <xref:System.Windows.Freezable.CreateInstanceCore%2A>.  
  
 [!code-csharp[freezablesample_procedural#CreateInstanceCoreExample](~/samples/snippets/csharp/VS_Snippets_Wpf/freezablesample_procedural/CSharp/freezablesample.cs#createinstancecoreexample)]
 [!code-vb[freezablesample_procedural#CreateInstanceCoreExample](~/samples/snippets/visualbasic/VS_Snippets_Wpf/freezablesample_procedural/visualbasic/freezablesample.vb#createinstancecoreexample)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Cada <see cref="T:System.Windows.Media.Animation.Storyboard" /> subclase debe implementar este método. Implementación típica consiste simplemente en llamar al constructor de clase predeterminado y devolver el resultado.</para>
        </block>
        <altmember cref="M:System.Windows.Freezable.CreateInstanceCore" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetCurrentGlobalSpeed">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Recupera la propiedad <see cref="P:System.Windows.Media.Animation.Clock.CurrentGlobalSpeed" /> del objeto <see cref="T:System.Windows.Media.Animation.Clock" /> creado para este objeto <see cref="T:System.Windows.Media.Animation.Storyboard" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un reloj <xref:System.Windows.Media.Animation.Clock.CurrentGlobalSpeed%2A> velocidad es la velocidad a la que actualmente se lleva a cabo su tiempo, en comparación con el tiempo real.  
  
 Para usar este método para recuperar información sobre el reloj de un guión gráfico, el guión gráfico debe ser controlable. Para hacer un guión gráfico controlable en código, debe usar la sobrecarga adecuada del guión gráfico <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> método y especifique `true` para que sea controlable. Para obtener un ejemplo, vea [Cómo: controlar un guión gráfico después de su inicio](~/docs/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts.md).  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Media.Animation.Clock.CurrentGlobalSpeed" />
      </Docs>
    </MemberGroup>
    <Member MemberName="GetCurrentGlobalSpeed">
      <MemberSignature Language="C#" Value="public double GetCurrentGlobalSpeed ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance float64 GetCurrentGlobalSpeed() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.GetCurrentGlobalSpeed" />
      <MemberSignature Language="VB.NET" Value="Public Function GetCurrentGlobalSpeed () As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; double GetCurrentGlobalSpeed();" />
      <MemberSignature Language="F#" Value="member this.GetCurrentGlobalSpeed : unit -&gt; double" Usage="storyboard.GetCurrentGlobalSpeed " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Recupera la propiedad <see cref="P:System.Windows.Media.Animation.Clock.CurrentGlobalSpeed" /> del objeto <see cref="T:System.Windows.Media.Animation.Clock" /> creado para este objeto <see cref="T:System.Windows.Media.Animation.Storyboard" />.</summary>
        <returns>Velocidad global actual ó 0 si se detiene el reloj.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetCurrentGlobalSpeed">
      <MemberSignature Language="C#" Value="public Nullable&lt;double&gt; GetCurrentGlobalSpeed (System.Windows.FrameworkContentElement containingObject);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Nullable`1&lt;float64&gt; GetCurrentGlobalSpeed(class System.Windows.FrameworkContentElement containingObject) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.GetCurrentGlobalSpeed(System.Windows.FrameworkContentElement)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetCurrentGlobalSpeed (containingObject As FrameworkContentElement) As Nullable(Of Double)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Nullable&lt;double&gt; GetCurrentGlobalSpeed(System::Windows::FrameworkContentElement ^ containingObject);" />
      <MemberSignature Language="F#" Value="member this.GetCurrentGlobalSpeed : System.Windows.FrameworkContentElement -&gt; Nullable&lt;double&gt;" Usage="storyboard.GetCurrentGlobalSpeed containingObject" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Double&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="containingObject" Type="System.Windows.FrameworkContentElement" />
      </Parameters>
      <Docs>
        <param name="containingObject">Objeto especificado cuando se llamó al método <see cref="M:System.Windows.Media.Animation.Storyboard.Begin(System.Windows.FrameworkContentElement,System.Boolean)" />. Este objeto contiene los objetos <see cref="T:System.Windows.Media.Animation.Clock" /> que se crearon para este guión gráfico y sus elementos secundarios.</param>
        <summary>Recupera la propiedad <see cref="P:System.Windows.Media.Animation.Clock.CurrentGlobalSpeed" /> del objeto <see cref="T:System.Windows.Media.Animation.Clock" /> creado para este objeto <see cref="T:System.Windows.Media.Animation.Storyboard" />.</summary>
        <returns>Velocidad global actual ó <see langword="null" /> si se detiene el reloj.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un reloj <xref:System.Windows.Media.Animation.Clock.CurrentGlobalSpeed%2A> velocidad es la velocidad a la que actualmente se lleva a cabo su tiempo, en comparación con el tiempo real.  
  
 Para usar este método para recuperar información sobre el reloj de un guión gráfico, el guión gráfico debe ser controlable. Para hacer un guión gráfico controlable en código, debe usar la sobrecarga adecuada del guión gráfico <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> método y especifique `true` para que sea controlable. Para obtener un ejemplo, vea [Cómo: controlar un guión gráfico después de su inicio](~/docs/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts.md).  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Media.Animation.Clock.CurrentGlobalSpeed" />
      </Docs>
    </Member>
    <Member MemberName="GetCurrentGlobalSpeed">
      <MemberSignature Language="C#" Value="public Nullable&lt;double&gt; GetCurrentGlobalSpeed (System.Windows.FrameworkElement containingObject);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Nullable`1&lt;float64&gt; GetCurrentGlobalSpeed(class System.Windows.FrameworkElement containingObject) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.GetCurrentGlobalSpeed(System.Windows.FrameworkElement)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetCurrentGlobalSpeed (containingObject As FrameworkElement) As Nullable(Of Double)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Nullable&lt;double&gt; GetCurrentGlobalSpeed(System::Windows::FrameworkElement ^ containingObject);" />
      <MemberSignature Language="F#" Value="member this.GetCurrentGlobalSpeed : System.Windows.FrameworkElement -&gt; Nullable&lt;double&gt;" Usage="storyboard.GetCurrentGlobalSpeed containingObject" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Double&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="containingObject" Type="System.Windows.FrameworkElement" />
      </Parameters>
      <Docs>
        <param name="containingObject">Objeto especificado cuando se llamó al método <see cref="M:System.Windows.Media.Animation.Storyboard.Begin(System.Windows.FrameworkElement,System.Boolean)" />. Este objeto contiene los objetos <see cref="T:System.Windows.Media.Animation.Clock" /> que se crearon para este guión gráfico y sus elementos secundarios.</param>
        <summary>Recupera la propiedad <see cref="P:System.Windows.Media.Animation.Clock.CurrentGlobalSpeed" /> del objeto <see cref="T:System.Windows.Media.Animation.Clock" /> creado para este objeto <see cref="T:System.Windows.Media.Animation.Storyboard" />.</summary>
        <returns>Velocidad global actual ó <see langword="null" /> si se detiene el reloj.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un reloj <xref:System.Windows.Media.Animation.Clock.CurrentGlobalSpeed%2A> velocidad es la velocidad a la que actualmente se lleva a cabo su tiempo, en comparación con el tiempo real.  
  
 Para usar este método para recuperar información sobre el reloj de un guión gráfico, el guión gráfico debe ser controlable. Para hacer un guión gráfico controlable en código, debe usar la sobrecarga adecuada del guión gráfico <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> método y especifique `true` para que sea controlable. Para obtener un ejemplo, vea [Cómo: controlar un guión gráfico después de su inicio](~/docs/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts.md).  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Media.Animation.Clock.CurrentGlobalSpeed" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetCurrentIteration">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Recupera la propiedad <see cref="P:System.Windows.Media.Animation.Clock.CurrentIteration" /> del objeto <see cref="T:System.Windows.Media.Animation.Clock" /> creado para este objeto <see cref="T:System.Windows.Media.Animation.Storyboard" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetCurrentIteration">
      <MemberSignature Language="C#" Value="public int GetCurrentIteration ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 GetCurrentIteration() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.GetCurrentIteration" />
      <MemberSignature Language="VB.NET" Value="Public Function GetCurrentIteration () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int GetCurrentIteration();" />
      <MemberSignature Language="F#" Value="member this.GetCurrentIteration : unit -&gt; int" Usage="storyboard.GetCurrentIteration " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Recupera la propiedad <see cref="P:System.Windows.Media.Animation.Clock.CurrentIteration" /> del objeto <see cref="T:System.Windows.Media.Animation.Clock" /> creado para este objeto <see cref="T:System.Windows.Media.Animation.Storyboard" />.</summary>
        <returns>Iteración actual de este reloj dentro de su período activo actual o <see langword="null" /> si se detiene este reloj.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Primera iteración de un reloj tiene un valor de 1.  
  
 Si tiene este guión gráfico una <xref:System.Windows.Media.Animation.Timeline.AutoReverse%2A> de `true`, una iteración completa consta de un par de avance inverso, no solo uno de estos segmentos.  
  
 Para usar este método para recuperar información sobre el reloj de un guión gráfico, el guión gráfico debe ser controlable. Para hacer un guión gráfico controlable en código, debe usar la sobrecarga adecuada del guión gráfico <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> método y especifique `true` para que sea controlable. Para obtener un ejemplo, vea [Cómo: controlar un guión gráfico después de su inicio](~/docs/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts.md).  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Media.Animation.Clock.CurrentIteration" />
      </Docs>
    </Member>
    <Member MemberName="GetCurrentIteration">
      <MemberSignature Language="C#" Value="public Nullable&lt;int&gt; GetCurrentIteration (System.Windows.FrameworkContentElement containingObject);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Nullable`1&lt;int32&gt; GetCurrentIteration(class System.Windows.FrameworkContentElement containingObject) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.GetCurrentIteration(System.Windows.FrameworkContentElement)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetCurrentIteration (containingObject As FrameworkContentElement) As Nullable(Of Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Nullable&lt;int&gt; GetCurrentIteration(System::Windows::FrameworkContentElement ^ containingObject);" />
      <MemberSignature Language="F#" Value="member this.GetCurrentIteration : System.Windows.FrameworkContentElement -&gt; Nullable&lt;int&gt;" Usage="storyboard.GetCurrentIteration containingObject" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="containingObject" Type="System.Windows.FrameworkContentElement" />
      </Parameters>
      <Docs>
        <param name="containingObject">Objeto especificado cuando se llamó al método <see cref="M:System.Windows.Media.Animation.Storyboard.Begin(System.Windows.FrameworkContentElement,System.Boolean)" />. Este objeto contiene los objetos <see cref="T:System.Windows.Media.Animation.Clock" /> que se crearon para este guión gráfico y sus elementos secundarios.</param>
        <summary>Recupera la propiedad <see cref="P:System.Windows.Media.Animation.Clock.CurrentIteration" /> del objeto <see cref="T:System.Windows.Media.Animation.Clock" /> creado para este objeto <see cref="T:System.Windows.Media.Animation.Storyboard" />.</summary>
        <returns>Iteración actual de este reloj dentro de su período activo actual o <see langword="null" /> si se detiene este reloj.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Primera iteración de un reloj tiene un valor de 1.  
  
 Si tiene este guión gráfico una <xref:System.Windows.Media.Animation.Timeline.AutoReverse%2A> de `true`, una iteración completa consta de un par de avance inverso, no solo uno de estos segmentos.  
  
 Para usar este método para recuperar información sobre el reloj de un guión gráfico, el guión gráfico debe ser controlable. Para hacer un guión gráfico controlable en código, debe usar la sobrecarga adecuada del guión gráfico <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> método y especifique `true` para que sea controlable. Para obtener un ejemplo, vea [Cómo: controlar un guión gráfico después de su inicio](~/docs/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts.md).  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Media.Animation.Clock.CurrentIteration" />
      </Docs>
    </Member>
    <Member MemberName="GetCurrentIteration">
      <MemberSignature Language="C#" Value="public Nullable&lt;int&gt; GetCurrentIteration (System.Windows.FrameworkElement containingObject);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Nullable`1&lt;int32&gt; GetCurrentIteration(class System.Windows.FrameworkElement containingObject) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.GetCurrentIteration(System.Windows.FrameworkElement)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetCurrentIteration (containingObject As FrameworkElement) As Nullable(Of Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Nullable&lt;int&gt; GetCurrentIteration(System::Windows::FrameworkElement ^ containingObject);" />
      <MemberSignature Language="F#" Value="member this.GetCurrentIteration : System.Windows.FrameworkElement -&gt; Nullable&lt;int&gt;" Usage="storyboard.GetCurrentIteration containingObject" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="containingObject" Type="System.Windows.FrameworkElement" />
      </Parameters>
      <Docs>
        <param name="containingObject">Objeto especificado cuando se llamó al método <see cref="M:System.Windows.Media.Animation.Storyboard.Begin(System.Windows.FrameworkElement,System.Boolean)" />. Este objeto contiene los objetos <see cref="T:System.Windows.Media.Animation.Clock" /> que se crearon para este guión gráfico y sus elementos secundarios.</param>
        <summary>Recupera la propiedad <see cref="P:System.Windows.Media.Animation.Clock.CurrentIteration" /> del objeto <see cref="T:System.Windows.Media.Animation.Clock" /> creado para este objeto <see cref="T:System.Windows.Media.Animation.Storyboard" />.</summary>
        <returns>Iteración actual de este reloj dentro de su período activo actual o <see langword="null" /> si se detiene este reloj.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Primera iteración de un reloj tiene un valor de 1.  
  
 Si la escala de tiempo del reloj tiene una <xref:System.Windows.Media.Animation.Timeline.AutoReverse%2A> de `true`, una iteración completa consta de un par de avance inverso, no solo uno de estos segmentos.  
  
 Independientemente de su iteración actual, que buscan un reloj, devuelve su iteración actual en 1. Reiniciar un reloj también devuelve su iteración actual en 1.  
  
 Para usar este método para recuperar información sobre el reloj de un guión gráfico, el guión gráfico debe ser controlable. Para hacer un guión gráfico controlable en código, debe usar la sobrecarga adecuada del guión gráfico <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> método y especifique `true` para que sea controlable. Para obtener un ejemplo, vea [Cómo: controlar un guión gráfico después de su inicio](~/docs/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts.md).  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Media.Animation.Clock.CurrentIteration" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetCurrentProgress">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Recupera la propiedad <see cref="P:System.Windows.Media.Animation.Clock.CurrentProgress" /> del objeto <see cref="T:System.Windows.Media.Animation.Clock" /> creado para este objeto <see cref="T:System.Windows.Media.Animation.Storyboard" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetCurrentProgress">
      <MemberSignature Language="C#" Value="public double GetCurrentProgress ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance float64 GetCurrentProgress() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.GetCurrentProgress" />
      <MemberSignature Language="VB.NET" Value="Public Function GetCurrentProgress () As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; double GetCurrentProgress();" />
      <MemberSignature Language="F#" Value="member this.GetCurrentProgress : unit -&gt; double" Usage="storyboard.GetCurrentProgress " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Recupera la propiedad <see cref="P:System.Windows.Media.Animation.Clock.CurrentProgress" /> del objeto <see cref="T:System.Windows.Media.Animation.Clock" /> creado para este objeto <see cref="T:System.Windows.Media.Animation.Storyboard" />.</summary>
        <returns>Es <see langword="null" /> si este reloj tiene el estado <see cref="F:System.Windows.Media.Animation.ClockState.Stopped" />, o 0,0 si este reloj está activo y su propiedad <see cref="P:System.Windows.Media.Animation.Clock.Timeline" /> tiene un valor para <see cref="P:System.Windows.Media.Animation.Timeline.Duration" /> de <see cref="P:System.Windows.Duration.Forever" />; de lo contrario, es un valor comprendido entre 0,0 y 1,0, lo que indica el progreso actual de este reloj dentro de su iteración actual. Un valor de 0,0 no indica ningún progreso, mientras que un valor de 1,0 indica que el reloj se encuentra al final de su iteración actual.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para usar este método para recuperar información sobre el reloj de un guión gráfico, el guión gráfico debe ser controlable. Para hacer un guión gráfico controlable en código, debe usar la sobrecarga adecuada del guión gráfico <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> método y especifique `true` para que sea controlable. Para obtener un ejemplo, vea [Cómo: controlar un guión gráfico después de su inicio](~/docs/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetCurrentProgress">
      <MemberSignature Language="C#" Value="public Nullable&lt;double&gt; GetCurrentProgress (System.Windows.FrameworkContentElement containingObject);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Nullable`1&lt;float64&gt; GetCurrentProgress(class System.Windows.FrameworkContentElement containingObject) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.GetCurrentProgress(System.Windows.FrameworkContentElement)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetCurrentProgress (containingObject As FrameworkContentElement) As Nullable(Of Double)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Nullable&lt;double&gt; GetCurrentProgress(System::Windows::FrameworkContentElement ^ containingObject);" />
      <MemberSignature Language="F#" Value="member this.GetCurrentProgress : System.Windows.FrameworkContentElement -&gt; Nullable&lt;double&gt;" Usage="storyboard.GetCurrentProgress containingObject" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Double&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="containingObject" Type="System.Windows.FrameworkContentElement" />
      </Parameters>
      <Docs>
        <param name="containingObject">Objeto especificado cuando se llamó al método <see cref="M:System.Windows.Media.Animation.Storyboard.Begin(System.Windows.FrameworkContentElement,System.Boolean)" />. Este objeto contiene los objetos <see cref="T:System.Windows.Media.Animation.Clock" /> que se crearon para este guión gráfico y sus elementos secundarios.</param>
        <summary>Recupera la propiedad <see cref="P:System.Windows.Media.Animation.Clock.CurrentProgress" /> del objeto <see cref="T:System.Windows.Media.Animation.Clock" /> creado para este objeto <see cref="T:System.Windows.Media.Animation.Storyboard" />.</summary>
        <returns>Es <see langword="null" /> si este reloj tiene el estado <see cref="F:System.Windows.Media.Animation.ClockState.Stopped" />, o 0,0 si este reloj está activo y su propiedad <see cref="P:System.Windows.Media.Animation.Clock.Timeline" /> tiene un valor para <see cref="P:System.Windows.Media.Animation.Timeline.Duration" /> de <see cref="P:System.Windows.Duration.Forever" />; de lo contrario, es un valor comprendido entre 0,0 y 1,0, lo que indica el progreso actual de este reloj dentro de su iteración actual. Un valor de 0,0 no indica ningún progreso, mientras que un valor de 1,0 indica que el reloj se encuentra al final de su iteración actual.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para usar este método para recuperar información sobre el reloj de un guión gráfico, el guión gráfico debe ser controlable. Para hacer un guión gráfico controlable en código, debe usar la sobrecarga adecuada del guión gráfico <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> método y especifique `true` para que sea controlable. Para obtener un ejemplo, vea [Cómo: controlar un guión gráfico después de su inicio](~/docs/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetCurrentProgress">
      <MemberSignature Language="C#" Value="public Nullable&lt;double&gt; GetCurrentProgress (System.Windows.FrameworkElement containingObject);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Nullable`1&lt;float64&gt; GetCurrentProgress(class System.Windows.FrameworkElement containingObject) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.GetCurrentProgress(System.Windows.FrameworkElement)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetCurrentProgress (containingObject As FrameworkElement) As Nullable(Of Double)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Nullable&lt;double&gt; GetCurrentProgress(System::Windows::FrameworkElement ^ containingObject);" />
      <MemberSignature Language="F#" Value="member this.GetCurrentProgress : System.Windows.FrameworkElement -&gt; Nullable&lt;double&gt;" Usage="storyboard.GetCurrentProgress containingObject" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Double&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="containingObject" Type="System.Windows.FrameworkElement" />
      </Parameters>
      <Docs>
        <param name="containingObject">Objeto especificado cuando se llamó al método <see cref="M:System.Windows.Media.Animation.Storyboard.Begin(System.Windows.FrameworkElement,System.Boolean)" />. Este objeto contiene los objetos <see cref="T:System.Windows.Media.Animation.Clock" /> que se crearon para este guión gráfico y sus elementos secundarios.</param>
        <summary>Recupera la propiedad <see cref="P:System.Windows.Media.Animation.Clock.CurrentProgress" /> del objeto <see cref="T:System.Windows.Media.Animation.Clock" /> creado para este objeto <see cref="T:System.Windows.Media.Animation.Storyboard" />.</summary>
        <returns>Es <see langword="null" /> si este reloj tiene el estado <see cref="F:System.Windows.Media.Animation.ClockState.Stopped" />, o 0,0 si este reloj está activo y su propiedad <see cref="P:System.Windows.Media.Animation.Clock.Timeline" /> tiene un valor para <see cref="P:System.Windows.Media.Animation.Timeline.Duration" /> de <see cref="P:System.Windows.Duration.Forever" />; de lo contrario, es un valor comprendido entre 0,0 y 1,0, lo que indica el progreso actual de este reloj dentro de su iteración actual. Un valor de 0,0 no indica ningún progreso, mientras que un valor de 1,0 indica que el reloj se encuentra al final de su iteración actual.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para usar este método para recuperar información sobre el reloj de un guión gráfico, el guión gráfico debe ser controlable. Para hacer un guión gráfico controlable en código, debe usar la sobrecarga adecuada del guión gráfico <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> método y especifique `true` para que sea controlable. Para obtener un ejemplo, vea [Cómo: controlar un guión gráfico después de su inicio](~/docs/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetCurrentState">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Recupera la propiedad <see cref="P:System.Windows.Media.Animation.Clock.CurrentState" /> del objeto <see cref="T:System.Windows.Media.Animation.Clock" /> creado para este objeto <see cref="T:System.Windows.Media.Animation.Storyboard" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetCurrentState">
      <MemberSignature Language="C#" Value="public System.Windows.Media.Animation.ClockState GetCurrentState ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Windows.Media.Animation.ClockState GetCurrentState() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.GetCurrentState" />
      <MemberSignature Language="VB.NET" Value="Public Function GetCurrentState () As ClockState" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Media::Animation::ClockState GetCurrentState();" />
      <MemberSignature Language="F#" Value="member this.GetCurrentState : unit -&gt; System.Windows.Media.Animation.ClockState" Usage="storyboard.GetCurrentState " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Media.Animation.ClockState</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Recupera la propiedad <see cref="P:System.Windows.Media.Animation.Clock.CurrentState" /> del objeto <see cref="T:System.Windows.Media.Animation.Clock" /> creado para este objeto <see cref="T:System.Windows.Media.Animation.Storyboard" />.</summary>
        <returns>Estado actual del reloj creado para este guión gráfico: <see cref="F:System.Windows.Media.Animation.ClockState.Active" />, <see cref="F:System.Windows.Media.Animation.ClockState.Filling" /> o <see cref="F:System.Windows.Media.Animation.ClockState.Stopped" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método no indica si se pone en pausa un guión gráfico. Para determinar si un guion gráfico está en pausa, utilice el <xref:System.Windows.Media.Animation.Storyboard.GetIsPaused%2A> método.  
  
 Para usar este método para recuperar información sobre el reloj de un guión gráfico, el guión gráfico debe ser controlable. Para hacer un guión gráfico controlable en código, debe usar la sobrecarga adecuada del guión gráfico <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> método y especifique `true` para que sea controlable. Para obtener un ejemplo, vea [Cómo: controlar un guión gráfico después de su inicio](~/docs/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetCurrentState">
      <MemberSignature Language="C#" Value="public System.Windows.Media.Animation.ClockState GetCurrentState (System.Windows.FrameworkContentElement containingObject);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Windows.Media.Animation.ClockState GetCurrentState(class System.Windows.FrameworkContentElement containingObject) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.GetCurrentState(System.Windows.FrameworkContentElement)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetCurrentState (containingObject As FrameworkContentElement) As ClockState" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Media::Animation::ClockState GetCurrentState(System::Windows::FrameworkContentElement ^ containingObject);" />
      <MemberSignature Language="F#" Value="member this.GetCurrentState : System.Windows.FrameworkContentElement -&gt; System.Windows.Media.Animation.ClockState" Usage="storyboard.GetCurrentState containingObject" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Media.Animation.ClockState</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="containingObject" Type="System.Windows.FrameworkContentElement" />
      </Parameters>
      <Docs>
        <param name="containingObject">Objeto especificado cuando se llamó al método <see cref="M:System.Windows.Media.Animation.Storyboard.Begin(System.Windows.FrameworkContentElement,System.Boolean)" />. Este objeto contiene los objetos <see cref="T:System.Windows.Media.Animation.Clock" /> que se crearon para este guión gráfico y sus elementos secundarios.</param>
        <summary>Recupera la propiedad <see cref="P:System.Windows.Media.Animation.Clock.CurrentState" /> del objeto <see cref="T:System.Windows.Media.Animation.Clock" /> creado para este objeto <see cref="T:System.Windows.Media.Animation.Storyboard" />.</summary>
        <returns>Estado actual del reloj creado para este guión gráfico: <see cref="F:System.Windows.Media.Animation.ClockState.Active" />, <see cref="F:System.Windows.Media.Animation.ClockState.Filling" /> o <see cref="F:System.Windows.Media.Animation.ClockState.Stopped" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método no indica si se pone en pausa un guión gráfico. Para determinar si un guion gráfico está en pausa, utilice el <xref:System.Windows.Media.Animation.Storyboard.GetIsPaused%2A> método.  
  
 Para usar este método para recuperar información sobre el reloj de un guión gráfico, el guión gráfico debe ser controlable. Para hacer un guión gráfico controlable en código, debe usar la sobrecarga adecuada del guión gráfico <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> método y especifique `true` para que sea controlable. Para obtener un ejemplo, vea [Cómo: controlar un guión gráfico después de su inicio](~/docs/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetCurrentState">
      <MemberSignature Language="C#" Value="public System.Windows.Media.Animation.ClockState GetCurrentState (System.Windows.FrameworkElement containingObject);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Windows.Media.Animation.ClockState GetCurrentState(class System.Windows.FrameworkElement containingObject) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.GetCurrentState(System.Windows.FrameworkElement)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetCurrentState (containingObject As FrameworkElement) As ClockState" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Media::Animation::ClockState GetCurrentState(System::Windows::FrameworkElement ^ containingObject);" />
      <MemberSignature Language="F#" Value="member this.GetCurrentState : System.Windows.FrameworkElement -&gt; System.Windows.Media.Animation.ClockState" Usage="storyboard.GetCurrentState containingObject" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Media.Animation.ClockState</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="containingObject" Type="System.Windows.FrameworkElement" />
      </Parameters>
      <Docs>
        <param name="containingObject">Objeto especificado cuando se llamó al método <see cref="M:System.Windows.Media.Animation.Storyboard.Begin(System.Windows.FrameworkElement,System.Boolean)" />. Este objeto contiene los objetos <see cref="T:System.Windows.Media.Animation.Clock" /> que se crearon para este guión gráfico y sus elementos secundarios.</param>
        <summary>Recupera la propiedad <see cref="P:System.Windows.Media.Animation.Clock.CurrentState" /> del objeto <see cref="T:System.Windows.Media.Animation.Clock" /> creado para este objeto <see cref="T:System.Windows.Media.Animation.Storyboard" />.</summary>
        <returns>Estado actual del reloj creado para este guión gráfico: <see cref="F:System.Windows.Media.Animation.ClockState.Active" />, <see cref="F:System.Windows.Media.Animation.ClockState.Filling" /> o <see cref="F:System.Windows.Media.Animation.ClockState.Stopped" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método no indica si se pone en pausa un guión gráfico. Para determinar si un guion gráfico está en pausa, utilice el <xref:System.Windows.Media.Animation.Storyboard.GetIsPaused%2A> método.  
  
 Para usar este método para recuperar información sobre el reloj de un guión gráfico, el guión gráfico debe ser controlable. Para hacer un guión gráfico controlable en código, debe usar la sobrecarga adecuada del guión gráfico <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> método y especifique `true` para que sea controlable. Para obtener un ejemplo, vea [Cómo: controlar un guión gráfico después de su inicio](~/docs/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetCurrentTime">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Recupera la propiedad <see cref="P:System.Windows.Media.Animation.Clock.CurrentTime" /> del objeto <see cref="T:System.Windows.Media.Animation.Clock" /> creado para este objeto <see cref="T:System.Windows.Media.Animation.Storyboard" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetCurrentTime">
      <MemberSignature Language="C#" Value="public TimeSpan GetCurrentTime ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.TimeSpan GetCurrentTime() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.GetCurrentTime" />
      <MemberSignature Language="VB.NET" Value="Public Function GetCurrentTime () As TimeSpan" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; TimeSpan GetCurrentTime();" />
      <MemberSignature Language="F#" Value="member this.GetCurrentTime : unit -&gt; TimeSpan" Usage="storyboard.GetCurrentTime " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Recupera la propiedad <see cref="P:System.Windows.Media.Animation.Clock.CurrentTime" /> del objeto <see cref="T:System.Windows.Media.Animation.Clock" /> creado para este objeto <see cref="T:System.Windows.Media.Animation.Storyboard" />.</summary>
        <returns>
          <see langword="null" /> si el reloj de este guión gráfico es <see cref="F:System.Windows.Media.Animation.ClockState.Stopped" />; de lo contrario, la hora actual del reloj del guión gráfico.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para usar este método para recuperar información sobre el reloj de un guión gráfico, el guión gráfico debe ser controlable. Para hacer un guión gráfico controlable en código, debe usar la sobrecarga adecuada del guión gráfico <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> método y especifique `true` para que sea controlable. Para obtener un ejemplo, vea [Cómo: controlar un guión gráfico después de su inicio](~/docs/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts.md).  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Media.Animation.Clock.CurrentTime" />
      </Docs>
    </Member>
    <Member MemberName="GetCurrentTime">
      <MemberSignature Language="C#" Value="public Nullable&lt;TimeSpan&gt; GetCurrentTime (System.Windows.FrameworkContentElement containingObject);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Nullable`1&lt;valuetype System.TimeSpan&gt; GetCurrentTime(class System.Windows.FrameworkContentElement containingObject) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.GetCurrentTime(System.Windows.FrameworkContentElement)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetCurrentTime (containingObject As FrameworkContentElement) As Nullable(Of TimeSpan)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Nullable&lt;TimeSpan&gt; GetCurrentTime(System::Windows::FrameworkContentElement ^ containingObject);" />
      <MemberSignature Language="F#" Value="member this.GetCurrentTime : System.Windows.FrameworkContentElement -&gt; Nullable&lt;TimeSpan&gt;" Usage="storyboard.GetCurrentTime containingObject" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.TimeSpan&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="containingObject" Type="System.Windows.FrameworkContentElement" />
      </Parameters>
      <Docs>
        <param name="containingObject">Objeto especificado cuando se llamó al método <see cref="M:System.Windows.Media.Animation.Storyboard.Begin(System.Windows.FrameworkContentElement,System.Boolean)" />. Este objeto contiene los objetos <see cref="T:System.Windows.Media.Animation.Clock" /> que se crearon para este guión gráfico y sus elementos secundarios.</param>
        <summary>Recupera la propiedad <see cref="P:System.Windows.Media.Animation.Clock.CurrentTime" /> del objeto <see cref="T:System.Windows.Media.Animation.Clock" /> creado para este objeto <see cref="T:System.Windows.Media.Animation.Storyboard" />.</summary>
        <returns>
          <see langword="null" /> si el reloj de este guión gráfico es <see cref="F:System.Windows.Media.Animation.ClockState.Stopped" />; de lo contrario, la hora actual del reloj del guión gráfico.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para usar este método para recuperar información sobre el reloj de un guión gráfico, el guión gráfico debe ser controlable. Para hacer un guión gráfico controlable en código, debe usar la sobrecarga adecuada del guión gráfico <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> método y especifique `true` para que sea controlable. Para obtener un ejemplo, vea [Cómo: controlar un guión gráfico después de su inicio](~/docs/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts.md).  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Media.Animation.Clock.CurrentTime" />
      </Docs>
    </Member>
    <Member MemberName="GetCurrentTime">
      <MemberSignature Language="C#" Value="public Nullable&lt;TimeSpan&gt; GetCurrentTime (System.Windows.FrameworkElement containingObject);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Nullable`1&lt;valuetype System.TimeSpan&gt; GetCurrentTime(class System.Windows.FrameworkElement containingObject) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.GetCurrentTime(System.Windows.FrameworkElement)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetCurrentTime (containingObject As FrameworkElement) As Nullable(Of TimeSpan)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Nullable&lt;TimeSpan&gt; GetCurrentTime(System::Windows::FrameworkElement ^ containingObject);" />
      <MemberSignature Language="F#" Value="member this.GetCurrentTime : System.Windows.FrameworkElement -&gt; Nullable&lt;TimeSpan&gt;" Usage="storyboard.GetCurrentTime containingObject" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.TimeSpan&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="containingObject" Type="System.Windows.FrameworkElement" />
      </Parameters>
      <Docs>
        <param name="containingObject">Objeto especificado cuando se llamó al método <see cref="M:System.Windows.Media.Animation.Storyboard.Begin(System.Windows.FrameworkElement,System.Boolean)" />. Este objeto contiene los objetos <see cref="T:System.Windows.Media.Animation.Clock" /> que se crearon para este guión gráfico y sus elementos secundarios.</param>
        <summary>Recupera la propiedad <see cref="P:System.Windows.Media.Animation.Clock.CurrentTime" /> del objeto <see cref="T:System.Windows.Media.Animation.Clock" /> creado para este objeto <see cref="T:System.Windows.Media.Animation.Storyboard" />.</summary>
        <returns>
          <see langword="null" /> si el reloj de este guión gráfico es <see cref="F:System.Windows.Media.Animation.ClockState.Stopped" />; de lo contrario, la hora actual del reloj del guión gráfico.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para usar este método para recuperar información sobre el reloj de un guión gráfico, el guión gráfico debe ser controlable. Para hacer un guión gráfico controlable en código, debe usar la sobrecarga adecuada del guión gráfico <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> método y especifique `true` para que sea controlable. Para obtener un ejemplo, vea [Cómo: controlar un guión gráfico después de su inicio](~/docs/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts.md).  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Media.Animation.Clock.CurrentTime" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetIsPaused">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Recupera un valor que indica si el objeto <see cref="T:System.Windows.Media.Animation.Clock" /> creado para este <see cref="T:System.Windows.Media.Animation.Storyboard" /> está en pausa.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetIsPaused">
      <MemberSignature Language="C#" Value="public bool GetIsPaused ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool GetIsPaused() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.GetIsPaused" />
      <MemberSignature Language="VB.NET" Value="Public Function GetIsPaused () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool GetIsPaused();" />
      <MemberSignature Language="F#" Value="member this.GetIsPaused : unit -&gt; bool" Usage="storyboard.GetIsPaused " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Recupera un valor que indica si el objeto <see cref="T:System.Windows.Media.Animation.Clock" /> creado para este <see cref="T:System.Windows.Media.Animation.Storyboard" /> está en pausa.</summary>
        <returns>
          <see langword="true" /> si el objeto <see cref="T:System.Windows.Media.Animation.Clock" /> creado para <see cref="T:System.Windows.Media.Animation.Storyboard" /> está en pausa; de lo contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para usar este método para recuperar información sobre el reloj de un guión gráfico, el guión gráfico debe ser controlable. Para hacer un guión gráfico controlable en código, debe usar la sobrecarga adecuada del guión gráfico <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> método y especifique `true` para que sea controlable. Para obtener un ejemplo, vea [Cómo: controlar un guión gráfico después de su inicio](~/docs/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts.md).  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Media.Animation.Clock.IsPaused" />
      </Docs>
    </Member>
    <Member MemberName="GetIsPaused">
      <MemberSignature Language="C#" Value="public bool GetIsPaused (System.Windows.FrameworkContentElement containingObject);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool GetIsPaused(class System.Windows.FrameworkContentElement containingObject) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.GetIsPaused(System.Windows.FrameworkContentElement)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetIsPaused (containingObject As FrameworkContentElement) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool GetIsPaused(System::Windows::FrameworkContentElement ^ containingObject);" />
      <MemberSignature Language="F#" Value="member this.GetIsPaused : System.Windows.FrameworkContentElement -&gt; bool" Usage="storyboard.GetIsPaused containingObject" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="containingObject" Type="System.Windows.FrameworkContentElement" />
      </Parameters>
      <Docs>
        <param name="containingObject">Objeto especificado cuando se llamó al método <see cref="M:System.Windows.Media.Animation.Storyboard.Begin(System.Windows.FrameworkContentElement,System.Boolean)" />. Este objeto contiene los objetos <see cref="T:System.Windows.Media.Animation.Clock" /> que se crearon para este guión gráfico y sus elementos secundarios.</param>
        <summary>Recupera un valor que indica si el objeto <see cref="T:System.Windows.Media.Animation.Clock" /> creado para este <see cref="T:System.Windows.Media.Animation.Storyboard" /> está en pausa.</summary>
        <returns>
          <see langword="true" /> si el objeto <see cref="T:System.Windows.Media.Animation.Clock" /> creado para <see cref="T:System.Windows.Media.Animation.Storyboard" /> está en pausa; de lo contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para usar este método para recuperar información sobre el reloj de un guión gráfico, el guión gráfico debe ser controlable. Para hacer un guión gráfico controlable en código, debe usar la sobrecarga adecuada del guión gráfico <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> método y especifique `true` para que sea controlable. Para obtener un ejemplo, vea [Cómo: controlar un guión gráfico después de su inicio](~/docs/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts.md).  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Media.Animation.Clock.IsPaused" />
      </Docs>
    </Member>
    <Member MemberName="GetIsPaused">
      <MemberSignature Language="C#" Value="public bool GetIsPaused (System.Windows.FrameworkElement containingObject);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool GetIsPaused(class System.Windows.FrameworkElement containingObject) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.GetIsPaused(System.Windows.FrameworkElement)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetIsPaused (containingObject As FrameworkElement) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool GetIsPaused(System::Windows::FrameworkElement ^ containingObject);" />
      <MemberSignature Language="F#" Value="member this.GetIsPaused : System.Windows.FrameworkElement -&gt; bool" Usage="storyboard.GetIsPaused containingObject" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="containingObject" Type="System.Windows.FrameworkElement" />
      </Parameters>
      <Docs>
        <param name="containingObject">Objeto especificado cuando se llamó al método <see cref="M:System.Windows.Media.Animation.Storyboard.Begin(System.Windows.FrameworkElement,System.Boolean)" />. Este objeto contiene los objetos <see cref="T:System.Windows.Media.Animation.Clock" /> que se crearon para este guión gráfico y sus elementos secundarios.</param>
        <summary>Recupera un valor que indica si el objeto <see cref="T:System.Windows.Media.Animation.Clock" /> creado para este <see cref="T:System.Windows.Media.Animation.Storyboard" /> está en pausa.</summary>
        <returns>
          <see langword="true" /> si el objeto <see cref="T:System.Windows.Media.Animation.Clock" /> creado para <see cref="T:System.Windows.Media.Animation.Storyboard" /> está en pausa; de lo contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para usar este método para recuperar información sobre el reloj de un guión gráfico, el guión gráfico debe ser controlable. Para hacer un guión gráfico controlable en código, debe usar la sobrecarga adecuada del guión gráfico <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> método y especifique `true` para que sea controlable. Para obtener un ejemplo, vea [Cómo: controlar un guión gráfico después de su inicio](~/docs/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts.md).  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Media.Animation.Clock.IsPaused" />
      </Docs>
    </Member>
    <Member MemberName="GetTarget">
      <MemberSignature Language="C#" Value="public static System.Windows.DependencyObject GetTarget (System.Windows.DependencyObject element);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.DependencyObject GetTarget(class System.Windows.DependencyObject element) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.GetTarget(System.Windows.DependencyObject)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTarget (element As DependencyObject) As DependencyObject" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::DependencyObject ^ GetTarget(System::Windows::DependencyObject ^ element);" />
      <MemberSignature Language="F#" Value="static member GetTarget : System.Windows.DependencyObject -&gt; System.Windows.DependencyObject" Usage="System.Windows.Media.Animation.Storyboard.GetTarget element" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyObject</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
      </Parameters>
      <Docs>
        <param name="element">Escala de tiempo de la que se va a recuperar el valor de <see cref="P:System.Windows.Media.Animation.Storyboard.TargetName" />.</param>
        <summary>Recupera el valor de <see cref="P:System.Windows.Media.Animation.Storyboard.Target" /> del objeto <see cref="T:System.Windows.Media.Animation.Timeline" /> especificado.</summary>
        <returns>Objeto de dependencia que es el destino de <paramref name="element" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use el <xref:System.Windows.Media.Animation.Storyboard.Target%2A> adjunta la propiedad con escalas de tiempo de animación para indicar el objeto de destino. Para obtener más información acerca de cómo funcionan los destinos de guión gráfico, vea <xref:System.Windows.Media.Animation.Storyboard.TargetName%2A>. Para obtener más información sobre cómo funcionan las propiedades adjuntas cómo, consulte [Attached Properties Overview](~/docs/framework/wpf/advanced/attached-properties-overview.md).  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Media.Animation.Storyboard.TargetName" />
      </Docs>
    </Member>
    <Member MemberName="GetTargetName">
      <MemberSignature Language="C#" Value="public static string GetTargetName (System.Windows.DependencyObject element);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetTargetName(class System.Windows.DependencyObject element) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.GetTargetName(System.Windows.DependencyObject)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTargetName (element As DependencyObject) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetTargetName(System::Windows::DependencyObject ^ element);" />
      <MemberSignature Language="F#" Value="static member GetTargetName : System.Windows.DependencyObject -&gt; string" Usage="System.Windows.Media.Animation.Storyboard.GetTargetName element" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
      </Parameters>
      <Docs>
        <param name="element">Escala de tiempo de la que se va a recuperar el valor de <see cref="P:System.Windows.Media.Animation.Storyboard.TargetName" />.</param>
        <summary>Recupera el valor de <see cref="P:System.Windows.Media.Animation.Storyboard.TargetName" /> del objeto <see cref="T:System.Windows.Media.Animation.Timeline" /> especificado.</summary>
        <returns>El nombre del objeto de dependencia de destino de <paramref name="element" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método obtiene la <xref:System.Windows.Media.Animation.Storyboard.TargetName%2A> propiedad adjunta en el objeto especificado. Para obtener más información acerca de cómo funcionan los destinos de guión gráfico, vea <xref:System.Windows.Media.Animation.Storyboard.TargetName%2A>. Para obtener más información sobre cómo funcionan las propiedades adjuntas cómo, consulte [Attached Properties Overview](~/docs/framework/wpf/advanced/attached-properties-overview.md).  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Media.Animation.Storyboard.TargetName" />
      </Docs>
    </Member>
    <Member MemberName="GetTargetProperty">
      <MemberSignature Language="C#" Value="public static System.Windows.PropertyPath GetTargetProperty (System.Windows.DependencyObject element);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.PropertyPath GetTargetProperty(class System.Windows.DependencyObject element) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.GetTargetProperty(System.Windows.DependencyObject)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTargetProperty (element As DependencyObject) As PropertyPath" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::PropertyPath ^ GetTargetProperty(System::Windows::DependencyObject ^ element);" />
      <MemberSignature Language="F#" Value="static member GetTargetProperty : System.Windows.DependencyObject -&gt; System.Windows.PropertyPath" Usage="System.Windows.Media.Animation.Storyboard.GetTargetProperty element" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.PropertyPath</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
      </Parameters>
      <Docs>
        <param name="element">Objeto de dependencia del que se obtiene <see cref="P:System.Windows.Media.Animation.Storyboard.TargetProperty" />.</param>
        <summary>Recupera el valor de <see cref="P:System.Windows.Media.Animation.Storyboard.TargetProperty" /> del objeto <see cref="T:System.Windows.Media.Animation.Timeline" /> especificado.</summary>
        <returns>Propiedad de destino de <paramref name="element" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método obtiene la <xref:System.Windows.Media.Animation.Storyboard.TargetProperty%2A> propiedad adjunta en el objeto especificado. Para obtener más información acerca de cómo funcionan los destinos de guión gráfico, vea <xref:System.Windows.Media.Animation.Storyboard.TargetProperty%2A> propiedad adjunta. Para obtener más información sobre cómo funcionan las propiedades adjuntas cómo, consulte [Attached Properties Overview](~/docs/framework/wpf/advanced/attached-properties-overview.md).  
  
 Observe que si el <xref:System.Windows.Media.Animation.Storyboard.TargetProperty%2A> se estableció en el marcado, este método devuelve un valor vacío <xref:System.Windows.PropertyPath> porque se resuelve la referencia de propiedad y se almacenan internamente cuando se analiza.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Media.Animation.Storyboard.TargetProperty" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Pause">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Pausa el objeto <see cref="T:System.Windows.Media.Animation.Clock" /> que se creó para este objeto <see cref="T:System.Windows.Media.Animation.Storyboard" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Pause">
      <MemberSignature Language="C#" Value="public void Pause ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Pause() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.Pause" />
      <MemberSignature Language="VB.NET" Value="Public Sub Pause ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Pause();" />
      <MemberSignature Language="F#" Value="member this.Pause : unit -&gt; unit" Usage="storyboard.Pause " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Pausa el objeto <see cref="T:System.Windows.Media.Animation.Clock" /> que se creó para este objeto <see cref="T:System.Windows.Media.Animation.Storyboard" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método pone en pausa el guión gráfico, pero no tiene ningún efecto apreciable si no está activa o en pausa actualmente. Como efecto secundario, también se interrumpen todos los elementos secundarios asociados.  
  
 Un guión gráfico controlable puede pausar, reanudar, buscar, detener y se puede quitar. Para hacer un guión gráfico controlable en código, debe usar la sobrecarga adecuada del guión gráfico <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> método y especifique `true` para que sea controlable. Para obtener un ejemplo, vea [Cómo: controlar un guión gráfico después de su inicio](~/docs/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts.md).  
  
## <a name="beginning-a-paused-storyboard"></a>A partir de un guión gráfico en pausa  
 Cuando se <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> un guión gráfico que estaba en pausa, aparece para reanudar y reiniciar. Sin embargo, es no lo que sucede realmente. El <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> método reemplaza realmente la pausa <xref:System.Windows.Media.Animation.Storyboard> con una nueva versión no está en pausa. Cada vez que el <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> se llama al método, se crean los objetos de reloj para guión gráfico. Estos relojes se distribuyen a las propiedades que animan. Por tanto, cuando el <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> se llama al método nuevo, no se reinician sus relojes; lo reemplaza con los relojes nuevo.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Pause">
      <MemberSignature Language="C#" Value="public void Pause (System.Windows.FrameworkContentElement containingObject);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Pause(class System.Windows.FrameworkContentElement containingObject) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.Pause(System.Windows.FrameworkContentElement)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Pause (containingObject As FrameworkContentElement)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Pause(System::Windows::FrameworkContentElement ^ containingObject);" />
      <MemberSignature Language="F#" Value="member this.Pause : System.Windows.FrameworkContentElement -&gt; unit" Usage="storyboard.Pause containingObject" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="containingObject" Type="System.Windows.FrameworkContentElement" />
      </Parameters>
      <Docs>
        <param name="containingObject">Objeto especificado cuando se llamó al método <see cref="M:System.Windows.Media.Animation.Storyboard.Begin(System.Windows.FrameworkContentElement,System.Boolean)" />. Este objeto contiene los objetos <see cref="T:System.Windows.Media.Animation.Clock" /> que se crearon para este guión gráfico y sus elementos secundarios.</param>
        <summary>Pausa el <see cref="T:System.Windows.Media.Animation.Clock" /> del <see cref="T:System.Windows.FrameworkContentElement" /> especificado asociado a este <see cref="T:System.Windows.Media.Animation.Storyboard" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método pone en pausa el guión gráfico, pero no tiene ningún efecto apreciable si no está activa o en pausa actualmente. Como efecto secundario, también se interrumpen todos los elementos secundarios asociados.  
  
 Busca un guión gráfico en pausa no reanuda. La única forma de reanudar un guión gráfico en pausa es utilizar el <xref:System.Windows.Media.Animation.Storyboard.Resume%2A> método. Una llamada a la <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> método nuevo reemplaza el guión gráfico en pausa por uno nuevo, lo que tiene el aspecto de reanudarlo.  
  
 Para controlar este guión gráfico de forma interactiva, debe usar el mismo `containingObject` parámetro al llamar a los métodos interactivos que usó para iniciar el guión gráfico. Un guión gráfico controlable puede pausar, reanudar, buscar, detener y se puede quitar. Para hacer un guión gráfico controlable en código, debe usar la sobrecarga adecuada del guión gráfico <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> método y especifique `true` para que sea controlable. Para un ejemplo, vea [Cómo: controlar un guión gráfico después de su inicio](~/docs/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts.md).  
  
 Pausar los desencadenadores de reloj de un guión gráfico el <xref:System.Windows.Media.Animation.Timeline.CurrentGlobalSpeedInvalidated> eventos.  
  
## <a name="beginning-a-paused-storyboard"></a>A partir de un guión gráfico en pausa  
 Cuando se <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> un guión gráfico que estaba en pausa, aparece para reanudar y reiniciar. Sin embargo, es no lo que sucede realmente. El <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> método realmente se reemplaza con una versión no está en pausa. Cada vez que el <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> se llama al método, se crean los objetos de reloj para guión gráfico. Estos relojes se distribuyen a las propiedades que animan. Por tanto, cuando el <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> se llama al método nuevo, no se reinician sus relojes; lo reemplaza con los relojes nuevo.  
  
   
  
## Examples  
 En el ejemplo siguiente se usa un guión gráfico controlable para animar un <xref:System.Windows.Media.TextEffect>. El <xref:System.Windows.Media.TextEffect> está dentro de un <xref:System.Windows.FrameworkContentElement>del nombre de ámbito.  
  
 [!code-csharp[StoryboardBeginAnimation_procedural_snip#FrameworkContentElementControlStoryboardExampleUsingWholePage](~/samples/snippets/csharp/VS_Snippets_Wpf/StoryboardBeginAnimation_procedural_snip/CSharp/FrameworkContentElementControlStoryboardExample.cs#frameworkcontentelementcontrolstoryboardexampleusingwholepage)]
 [!code-vb[StoryboardBeginAnimation_procedural_snip#FrameworkContentElementControlStoryboardExampleUsingWholePage](~/samples/snippets/visualbasic/VS_Snippets_Wpf/StoryboardBeginAnimation_procedural_snip/visualbasic/frameworkcontentelementcontrolstoryboardexample.vb#frameworkcontentelementcontrolstoryboardexampleusingwholepage)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Media.Animation.Storyboard.Resume(System.Windows.FrameworkContentElement)" />
      </Docs>
    </Member>
    <Member MemberName="Pause">
      <MemberSignature Language="C#" Value="public void Pause (System.Windows.FrameworkElement containingObject);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Pause(class System.Windows.FrameworkElement containingObject) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.Pause(System.Windows.FrameworkElement)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Pause (containingObject As FrameworkElement)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Pause(System::Windows::FrameworkElement ^ containingObject);" />
      <MemberSignature Language="F#" Value="member this.Pause : System.Windows.FrameworkElement -&gt; unit" Usage="storyboard.Pause containingObject" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="containingObject" Type="System.Windows.FrameworkElement" />
      </Parameters>
      <Docs>
        <param name="containingObject">Objeto especificado cuando se llamó al método <see cref="M:System.Windows.Media.Animation.Storyboard.Begin(System.Windows.FrameworkElement,System.Boolean)" />. Este objeto contiene los objetos <see cref="T:System.Windows.Media.Animation.Clock" /> que se crearon para este guión gráfico y sus elementos secundarios.</param>
        <summary>Pausa el <see cref="T:System.Windows.Media.Animation.Clock" /> del <see cref="T:System.Windows.FrameworkElement" /> especificado asociado a este <see cref="T:System.Windows.Media.Animation.Storyboard" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método pone en pausa el guión gráfico, pero no tiene ningún efecto apreciable si no está activa o en pausa actualmente. Como efecto secundario, también se interrumpen todos los elementos secundarios asociados.  
  
 Busca un guión gráfico en pausa no reanuda. La única forma de reanudar un guión gráfico en pausa es utilizar el <xref:System.Windows.Media.Animation.Storyboard.Resume%2A> método. Una llamada a la <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> método nuevo reemplaza el guión gráfico en pausa por uno nuevo, lo que tiene el aspecto de reanudarlo.  
  
 Para controlar este guión gráfico de forma interactiva, debe usar el mismo `containingObject` parámetro al llamar a los métodos interactivos que usó para iniciar el guión gráfico. Un guión gráfico controlable puede pausar, reanudar, buscar, detener y se puede quitar. Para hacer un guión gráfico controlable en código, debe usar la sobrecarga adecuada del guión gráfico <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> método y especifique `true` para que sea controlable. Para obtener un ejemplo, vea [Cómo: controlar un guión gráfico después de su inicio](~/docs/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts.md).  
  
 Pausar los desencadenadores de reloj de un guión gráfico el <xref:System.Windows.Media.Animation.Timeline.CurrentGlobalSpeedInvalidated> eventos.  
  
## <a name="beginning-a-paused-storyboard"></a>A partir de un guión gráfico en pausa  
 Cuando se <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> un guión gráfico que estaba en pausa, aparece para reanudar y reiniciar. Sin embargo, es no lo que sucede realmente. El <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> método realmente se reemplaza con una versión no está en pausa. Cada vez que el <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> se llama al método, se crean los objetos de reloj para guión gráfico. Estos relojes se distribuyen a las propiedades que animan. Por tanto, cuando el <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> se llama al método nuevo, no se reinician sus relojes; lo reemplaza con los relojes nuevo.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Media.Animation.Storyboard.Resume(System.Windows.FrameworkElement)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Remove">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Quita los objetos <see cref="T:System.Windows.Media.Animation.Clock" /> creados para este <see cref="T:System.Windows.Media.Animation.Storyboard" />. Las animaciones que pertenecen a este <see cref="T:System.Windows.Media.Animation.Storyboard" /> ya no afectan a las propiedades que animaban, independientemente del valor de <see cref="P:System.Windows.Media.Animation.Timeline.FillBehavior" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Remove">
      <MemberSignature Language="C#" Value="public void Remove ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Remove() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.Remove" />
      <MemberSignature Language="VB.NET" Value="Public Sub Remove ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Remove();" />
      <MemberSignature Language="F#" Value="member this.Remove : unit -&gt; unit" Usage="storyboard.Remove " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Quita los objetos <see cref="T:System.Windows.Media.Animation.Clock" /> creados para este <see cref="T:System.Windows.Media.Animation.Storyboard" />. Las animaciones que pertenecen a este <see cref="T:System.Windows.Media.Animation.Storyboard" /> ya no afectan a las propiedades que animaban, independientemente del valor de <see cref="P:System.Windows.Media.Animation.Timeline.FillBehavior" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un guión gráfico controlable puede pausar, reanudar, buscar, detener y se puede quitar. Para hacer un guión gráfico controlable en código, debe usar la sobrecarga adecuada del guión gráfico <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> método y especifique `true` para que sea controlable. Para obtener un ejemplo, vea [Cómo: controlar un guión gráfico después de su inicio](~/docs/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts.md).  
  
 Todas las acciones interactivas realizadas en un <xref:System.Windows.Media.Animation.Clock>y por lo tanto, también en un <xref:System.Windows.Media.Animation.Storyboard>, se producen en el siguiente paso del motor de tiempo, lo que sucede poco antes de la siguiente representación. Esto significa que el <xref:System.Windows.Media.Animation.Storyboard.Remove%2A> método todavía afecta a las propiedades animadas hasta este momento. En otras palabras, la próxima vez que se muestra el marco, se quita el guión gráfico. Si necesita desasociar una animación de una propiedad antes de ese momento, use la <xref:System.Windows.UIElement.BeginAnimation%2A> método con un `animation` valor del parámetro de `null`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Remove">
      <MemberSignature Language="C#" Value="public void Remove (System.Windows.FrameworkContentElement containingObject);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Remove(class System.Windows.FrameworkContentElement containingObject) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.Remove(System.Windows.FrameworkContentElement)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Remove (containingObject As FrameworkContentElement)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Remove(System::Windows::FrameworkContentElement ^ containingObject);" />
      <MemberSignature Language="F#" Value="member this.Remove : System.Windows.FrameworkContentElement -&gt; unit" Usage="storyboard.Remove containingObject" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="containingObject" Type="System.Windows.FrameworkContentElement" />
      </Parameters>
      <Docs>
        <param name="containingObject">Objeto especificado cuando se llamó al método <see cref="M:System.Windows.Media.Animation.Storyboard.Begin(System.Windows.FrameworkContentElement,System.Boolean)" />. Este objeto contiene los objetos <see cref="T:System.Windows.Media.Animation.Clock" /> que se crearon para este guión gráfico y sus elementos secundarios.</param>
        <summary>Quita los objetos <see cref="T:System.Windows.Media.Animation.Clock" /> creados para este <see cref="T:System.Windows.Media.Animation.Storyboard" />. Las animaciones que pertenecen a este <see cref="T:System.Windows.Media.Animation.Storyboard" /> ya no afectan a las propiedades que animaban, independientemente del valor de <see cref="P:System.Windows.Media.Animation.Timeline.FillBehavior" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para controlar este guión gráfico de forma interactiva, debe usar el mismo `containingObject` parámetro al llamar a los métodos interactivos que usó para iniciar el guión gráfico. Un guión gráfico controlable puede pausar, reanudar, buscar, detener y se puede quitar. Para hacer un guión gráfico controlable en código, debe usar la sobrecarga adecuada del guión gráfico <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> método y especifique `true` para que sea controlable. Para obtener un ejemplo, vea [Cómo: controlar un guión gráfico después de su inicio](~/docs/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts.md).  
  
 Eliminación de desencadenadores de reloj de un guión gráfico el <xref:System.Windows.Media.Animation.Timeline.RemoveRequested> eventos.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Remove">
      <MemberSignature Language="C#" Value="public void Remove (System.Windows.FrameworkElement containingObject);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Remove(class System.Windows.FrameworkElement containingObject) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.Remove(System.Windows.FrameworkElement)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Remove (containingObject As FrameworkElement)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Remove(System::Windows::FrameworkElement ^ containingObject);" />
      <MemberSignature Language="F#" Value="member this.Remove : System.Windows.FrameworkElement -&gt; unit" Usage="storyboard.Remove containingObject" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="containingObject" Type="System.Windows.FrameworkElement" />
      </Parameters>
      <Docs>
        <param name="containingObject">Objeto especificado cuando se llamó al método <see cref="M:System.Windows.Media.Animation.Storyboard.Begin(System.Windows.FrameworkElement,System.Boolean)" />. Este objeto contiene los objetos <see cref="T:System.Windows.Media.Animation.Clock" /> que se crearon para este guión gráfico y sus elementos secundarios.</param>
        <summary>Quita los objetos <see cref="T:System.Windows.Media.Animation.Clock" /> creados para este <see cref="T:System.Windows.Media.Animation.Storyboard" />. Las animaciones que pertenecen a este <see cref="T:System.Windows.Media.Animation.Storyboard" /> ya no afectan a las propiedades que animaban, independientemente del valor de <see cref="P:System.Windows.Media.Animation.Timeline.FillBehavior" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para controlar este guión gráfico de forma interactiva, debe usar el mismo `containingObject` parámetro al llamar a los métodos interactivos que usó para iniciar el guión gráfico. Un guión gráfico controlable puede pausar, reanudar, buscar, detener y se puede quitar. Para hacer un guión gráfico controlable en código, debe usar la sobrecarga adecuada del guión gráfico <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> método y especifique `true` para que sea controlable. Para obtener un ejemplo, vea [Cómo: controlar un guión gráfico después de su inicio](~/docs/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts.md).  
  
 Eliminación de desencadenadores de reloj de un guión gráfico el <xref:System.Windows.Media.Animation.Timeline.RemoveRequested> eventos.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Resume">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Reanuda el objeto <see cref="T:System.Windows.Media.Animation.Clock" /> creado para este <see cref="T:System.Windows.Media.Animation.Storyboard" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Resume">
      <MemberSignature Language="C#" Value="public void Resume ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Resume() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.Resume" />
      <MemberSignature Language="VB.NET" Value="Public Sub Resume ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Resume();" />
      <MemberSignature Language="F#" Value="member this.Resume : unit -&gt; unit" Usage="storyboard.Resume " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Reanuda el objeto <see cref="T:System.Windows.Media.Animation.Clock" /> creado para este <see cref="T:System.Windows.Media.Animation.Storyboard" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un guión gráfico controlable puede pausar, reanudar, buscar, detener y se puede quitar. Para hacer un guión gráfico controlable en código, debe usar la sobrecarga adecuada del guión gráfico <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> método y especifique `true` para que sea controlable. Para obtener un ejemplo, vea [Cómo: controlar un guión gráfico después de su inicio](~/docs/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Resume">
      <MemberSignature Language="C#" Value="public void Resume (System.Windows.FrameworkContentElement containingObject);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Resume(class System.Windows.FrameworkContentElement containingObject) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.Resume(System.Windows.FrameworkContentElement)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Resume (containingObject As FrameworkContentElement)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Resume(System::Windows::FrameworkContentElement ^ containingObject);" />
      <MemberSignature Language="F#" Value="member this.Resume : System.Windows.FrameworkContentElement -&gt; unit" Usage="storyboard.Resume containingObject" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="containingObject" Type="System.Windows.FrameworkContentElement" />
      </Parameters>
      <Docs>
        <param name="containingObject">Objeto especificado cuando se llamó al método <see cref="M:System.Windows.Media.Animation.Storyboard.Begin(System.Windows.FrameworkContentElement,System.Boolean)" />. Este objeto contiene los objetos <see cref="T:System.Windows.Media.Animation.Clock" /> que se crearon para este guión gráfico y sus elementos secundarios.</param>
        <summary>Reanuda el objeto <see cref="T:System.Windows.Media.Animation.Clock" /> creado para este <see cref="T:System.Windows.Media.Animation.Storyboard" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Reanuda un guión gráfico que no está en pausa no tiene ningún efecto.  
  
 Para controlar este guión gráfico de forma interactiva, debe usar el mismo `containingObject` parámetro al llamar a los métodos interactivos que usó para iniciar el guión gráfico. Un guión gráfico controlable puede pausar, reanudar, buscar, detener y se puede quitar. Para hacer un guión gráfico controlable en código, debe usar la sobrecarga adecuada del guión gráfico <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> método y especifique `true` para que sea controlable. Para obtener un ejemplo, vea [Cómo: controlar un guión gráfico después de su inicio](~/docs/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts.md).  
  
 Busca un guión gráfico en pausa no reanuda. La única forma de reanudar un guión gráfico en pausa es utilizar el <xref:System.Windows.Media.Animation.Storyboard.Resume%2A> método. Una llamada a la <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> método una vez iniciado el guión gráfico reemplaza el guión gráfico anterior, que tiene el aspecto de reanudarlo.  
  
 Reanudación de un reloj de un guión gráfico desencadena pausa el <xref:System.Windows.Media.Animation.Timeline.CurrentGlobalSpeedInvalidated> eventos.  
  
   
  
## Examples  
 En el ejemplo siguiente se usa un guión gráfico controlable para animar un <xref:System.Windows.Media.TextEffect>. El <xref:System.Windows.Media.TextEffect> está dentro de un <xref:System.Windows.FrameworkContentElement>del nombre de ámbito.  
  
 [!code-csharp[StoryboardBeginAnimation_procedural_snip#FrameworkContentElementControlStoryboardExampleUsingWholePage](~/samples/snippets/csharp/VS_Snippets_Wpf/StoryboardBeginAnimation_procedural_snip/CSharp/FrameworkContentElementControlStoryboardExample.cs#frameworkcontentelementcontrolstoryboardexampleusingwholepage)]
 [!code-vb[StoryboardBeginAnimation_procedural_snip#FrameworkContentElementControlStoryboardExampleUsingWholePage](~/samples/snippets/visualbasic/VS_Snippets_Wpf/StoryboardBeginAnimation_procedural_snip/visualbasic/frameworkcontentelementcontrolstoryboardexample.vb#frameworkcontentelementcontrolstoryboardexampleusingwholepage)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Media.Animation.Storyboard.Pause(System.Windows.FrameworkContentElement)" />
      </Docs>
    </Member>
    <Member MemberName="Resume">
      <MemberSignature Language="C#" Value="public void Resume (System.Windows.FrameworkElement containingObject);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Resume(class System.Windows.FrameworkElement containingObject) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.Resume(System.Windows.FrameworkElement)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Resume (containingObject As FrameworkElement)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Resume(System::Windows::FrameworkElement ^ containingObject);" />
      <MemberSignature Language="F#" Value="member this.Resume : System.Windows.FrameworkElement -&gt; unit" Usage="storyboard.Resume containingObject" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="containingObject" Type="System.Windows.FrameworkElement" />
      </Parameters>
      <Docs>
        <param name="containingObject">Objeto especificado cuando se llamó al método <see cref="M:System.Windows.Media.Animation.Storyboard.Begin(System.Windows.FrameworkElement,System.Boolean)" />. Este objeto contiene los objetos <see cref="T:System.Windows.Media.Animation.Clock" /> que se crearon para este guión gráfico y sus elementos secundarios.</param>
        <summary>Reanuda el objeto <see cref="T:System.Windows.Media.Animation.Clock" /> creado para este <see cref="T:System.Windows.Media.Animation.Storyboard" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Reanuda un guión gráfico que no está en pausa no tiene ningún efecto.  
  
 Para controlar este guión gráfico de forma interactiva, debe usar el mismo `containingObject` parámetro al llamar a los métodos interactivos que usó para iniciar el guión gráfico. Un guión gráfico controlable puede pausar, reanudar, buscar, detener y se puede quitar. Para hacer un guión gráfico controlable en código, debe usar la sobrecarga adecuada del guión gráfico <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> método y especifique `true` para que sea controlable. Para obtener un ejemplo, vea [Cómo: controlar un guión gráfico después de su inicio](~/docs/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts.md).  
  
 Busca un guión gráfico en pausa no reanuda. La única forma de reanudar un guión gráfico en pausa es utilizar el <xref:System.Windows.Media.Animation.Storyboard.Resume%2A> método. Una llamada a la <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> método una vez iniciado el guión gráfico reemplaza el guión gráfico anterior, que tiene el aspecto de reanudarlo.  
  
 Reanudación de un reloj de un guión gráfico desencadena pausa el <xref:System.Windows.Media.Animation.Timeline.CurrentGlobalSpeedInvalidated> eventos.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Media.Animation.Storyboard.Pause(System.Windows.FrameworkElement)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Seek">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Busca este objeto <see cref="T:System.Windows.Media.Animation.Storyboard" /> en una nueva posición cuando tiene lugar el siguiente paso del reloj.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Seek">
      <MemberSignature Language="C#" Value="public void Seek (TimeSpan offset);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Seek(valuetype System.TimeSpan offset) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.Seek(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Seek (offset As TimeSpan)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Seek(TimeSpan offset);" />
      <MemberSignature Language="F#" Value="member this.Seek : TimeSpan -&gt; unit" Usage="storyboard.Seek offset" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="offset" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="offset">Valor positivo o negativo que describe cuánto debe avanzar o retroceder la escala de tiempo.</param>
        <summary>Busca este objeto <see cref="T:System.Windows.Media.Animation.Storyboard" /> en la posición especificada. <see cref="T:System.Windows.Media.Animation.Storyboard" /> realiza la búsqueda solicitada cuando tiene lugar el siguiente paso del reloj.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Tenga en cuenta que las operaciones de búsqueda no toman del guión gráfico <xref:System.Windows.Media.Animation.Timeline.SpeedRatio%2A> o <xref:System.Windows.Media.Animation.ParallelTimeline.SlipBehavior%2A> la configuración de cuenta. El guión gráfico se trata como si tuviera un <xref:System.Windows.Media.Animation.Timeline.SpeedRatio%2A> de 1 y ningún <xref:System.Windows.Media.Animation.ParallelTimeline.SlipBehavior%2A>.  
  
 Para controlar este guión gráfico de forma interactiva, debe usar el mismo `containingObject` parámetro al llamar a los métodos interactivos que usó para iniciar el guión gráfico. Un guión gráfico controlable puede pausar, reanudar, buscar, detener y se puede quitar. Para hacer un guión gráfico controlable en código, debe usar la sobrecarga adecuada del guión gráfico <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> método y especifique `true` para que sea controlable. Para obtener un ejemplo, vea [Cómo: controlar un guión gráfico después de su inicio](~/docs/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Seek">
      <MemberSignature Language="C#" Value="public void Seek (TimeSpan offset, System.Windows.Media.Animation.TimeSeekOrigin origin);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Seek(valuetype System.TimeSpan offset, valuetype System.Windows.Media.Animation.TimeSeekOrigin origin) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.Seek(System.TimeSpan,System.Windows.Media.Animation.TimeSeekOrigin)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Seek (offset As TimeSpan, origin As TimeSeekOrigin)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Seek(TimeSpan offset, System::Windows::Media::Animation::TimeSeekOrigin origin);" />
      <MemberSignature Language="F#" Value="member this.Seek : TimeSpan * System.Windows.Media.Animation.TimeSeekOrigin -&gt; unit" Usage="storyboard.Seek (offset, origin)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="offset" Type="System.TimeSpan" />
        <Parameter Name="origin" Type="System.Windows.Media.Animation.TimeSeekOrigin" />
      </Parameters>
      <Docs>
        <param name="offset">Valor positivo o negativo que describe cuánto debe avanzar o retroceder la escala de tiempo desde el <c>origin</c> especificado.</param>
        <param name="origin">Posición desde la que se aplica <c>offset</c>.</param>
        <summary>Busca este objeto <see cref="T:System.Windows.Media.Animation.Storyboard" /> en la posición especificada. <see cref="T:System.Windows.Media.Animation.Storyboard" /> realiza la búsqueda solicitada cuando tiene lugar el siguiente paso del reloj.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Tenga en cuenta que las operaciones de búsqueda no toman del guión gráfico <xref:System.Windows.Media.Animation.Timeline.SpeedRatio%2A> o <xref:System.Windows.Media.Animation.ParallelTimeline.SlipBehavior%2A> la configuración de cuenta. El guión gráfico se trata como si tuviera un <xref:System.Windows.Media.Animation.Timeline.SpeedRatio%2A> de 1 y ningún <xref:System.Windows.Media.Animation.ParallelTimeline.SlipBehavior%2A>.  
  
 Para controlar este guión gráfico de forma interactiva, debe usar el mismo `containingObject` parámetro al llamar a los métodos interactivos que usó para iniciar el guión gráfico. Un guión gráfico controlable puede pausar, reanudar, buscar, detener y se puede quitar. Para hacer un guión gráfico controlable en código, debe usar la sobrecarga adecuada del guión gráfico <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> método y especifique `true` para que sea controlable. Para obtener un ejemplo, vea [Cómo: controlar un guión gráfico después de su inicio](~/docs/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Seek">
      <MemberSignature Language="C#" Value="public void Seek (System.Windows.FrameworkContentElement containingObject, TimeSpan offset, System.Windows.Media.Animation.TimeSeekOrigin origin);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Seek(class System.Windows.FrameworkContentElement containingObject, valuetype System.TimeSpan offset, valuetype System.Windows.Media.Animation.TimeSeekOrigin origin) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.Seek(System.Windows.FrameworkContentElement,System.TimeSpan,System.Windows.Media.Animation.TimeSeekOrigin)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Seek (containingObject As FrameworkContentElement, offset As TimeSpan, origin As TimeSeekOrigin)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Seek(System::Windows::FrameworkContentElement ^ containingObject, TimeSpan offset, System::Windows::Media::Animation::TimeSeekOrigin origin);" />
      <MemberSignature Language="F#" Value="member this.Seek : System.Windows.FrameworkContentElement * TimeSpan * System.Windows.Media.Animation.TimeSeekOrigin -&gt; unit" Usage="storyboard.Seek (containingObject, offset, origin)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="containingObject" Type="System.Windows.FrameworkContentElement" />
        <Parameter Name="offset" Type="System.TimeSpan" />
        <Parameter Name="origin" Type="System.Windows.Media.Animation.TimeSeekOrigin" />
      </Parameters>
      <Docs>
        <param name="containingObject">Objeto especificado cuando se llamó al método <see cref="M:System.Windows.Media.Animation.Storyboard.Begin(System.Windows.FrameworkContentElement,System.Boolean)" />. Este objeto contiene los objetos <see cref="T:System.Windows.Media.Animation.Clock" /> que se crearon para este guión gráfico y sus elementos secundarios.</param>
        <param name="offset">Valor positivo o negativo que describe cuánto debe avanzar o retroceder la escala de tiempo desde el <c>origin</c> especificado.</param>
        <param name="origin">Posición desde la que se aplica <c>offset</c>.</param>
        <summary>Busca este objeto <see cref="T:System.Windows.Media.Animation.Storyboard" /> en la posición especificada. <see cref="T:System.Windows.Media.Animation.Storyboard" /> realiza la búsqueda solicitada cuando tiene lugar el siguiente paso del reloj.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Tenga en cuenta que las operaciones de búsqueda no toman del guión gráfico <xref:System.Windows.Media.Animation.Timeline.SpeedRatio%2A> o <xref:System.Windows.Media.Animation.ParallelTimeline.SlipBehavior%2A> la configuración de cuenta. El guión gráfico se trata como si tuviera un <xref:System.Windows.Media.Animation.Timeline.SpeedRatio%2A> de 1 y ningún <xref:System.Windows.Media.Animation.ParallelTimeline.SlipBehavior%2A>.  
  
 Este método cambia el reloj guión gráfico <xref:System.Windows.Media.Animation.Clock.CurrentState%2A> a <xref:System.Windows.Media.Animation.ClockState.Active>. Este método no tiene ningún efecto en el árbol de control de tiempo hasta la próxima vez que se procese un paso. Como efecto secundario, los eventos adecuados también no se generan hasta ese momento.  
  
 Para controlar este guión gráfico de forma interactiva, debe usar el mismo `containingObject` parámetro al llamar a los métodos interactivos que usó para iniciar el guión gráfico. Un guión gráfico controlable puede pausar, reanudar, buscar, detener y se puede quitar. Para hacer un guión gráfico controlable en código, debe usar la sobrecarga adecuada del guión gráfico <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> método y especifique `true` para que sea controlable. Para obtener un ejemplo, vea [Cómo: controlar un guión gráfico después de su inicio](~/docs/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts.md).  
  
 Búsqueda activa un guión gráfico el <xref:System.Windows.Media.Animation.Timeline.CurrentGlobalSpeedInvalidated> y <xref:System.Windows.Media.Animation.Timeline.CurrentStateInvalidated> eventos.  
  
   
  
## Examples  
 El ejemplo siguiente muestra tanto el <xref:System.Windows.Media.Animation.Storyboard.Seek%2A> y <xref:System.Windows.Media.Animation.Storyboard.SeekAlignedToLastTick%2A> métodos.  
  
 [!code-csharp[StoryboardBeginAnimation_procedural_snip#FrameworkContentElementSeekExampleUsingWholePage](~/samples/snippets/csharp/VS_Snippets_Wpf/StoryboardBeginAnimation_procedural_snip/CSharp/FrameworkContentElementSeekExample.cs#frameworkcontentelementseekexampleusingwholepage)]
 [!code-vb[StoryboardBeginAnimation_procedural_snip#FrameworkContentElementSeekExampleUsingWholePage](~/samples/snippets/visualbasic/VS_Snippets_Wpf/StoryboardBeginAnimation_procedural_snip/visualbasic/frameworkcontentelementseekexample.vb#frameworkcontentelementseekexampleusingwholepage)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Seek">
      <MemberSignature Language="C#" Value="public void Seek (System.Windows.FrameworkElement containingObject, TimeSpan offset, System.Windows.Media.Animation.TimeSeekOrigin origin);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Seek(class System.Windows.FrameworkElement containingObject, valuetype System.TimeSpan offset, valuetype System.Windows.Media.Animation.TimeSeekOrigin origin) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.Seek(System.Windows.FrameworkElement,System.TimeSpan,System.Windows.Media.Animation.TimeSeekOrigin)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Seek (containingObject As FrameworkElement, offset As TimeSpan, origin As TimeSeekOrigin)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Seek(System::Windows::FrameworkElement ^ containingObject, TimeSpan offset, System::Windows::Media::Animation::TimeSeekOrigin origin);" />
      <MemberSignature Language="F#" Value="member this.Seek : System.Windows.FrameworkElement * TimeSpan * System.Windows.Media.Animation.TimeSeekOrigin -&gt; unit" Usage="storyboard.Seek (containingObject, offset, origin)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="containingObject" Type="System.Windows.FrameworkElement" />
        <Parameter Name="offset" Type="System.TimeSpan" />
        <Parameter Name="origin" Type="System.Windows.Media.Animation.TimeSeekOrigin" />
      </Parameters>
      <Docs>
        <param name="containingObject">Objeto especificado cuando se llamó al método <see cref="M:System.Windows.Media.Animation.Storyboard.Begin(System.Windows.FrameworkElement,System.Boolean)" />. Este objeto contiene los objetos <see cref="T:System.Windows.Media.Animation.Clock" /> que se crearon para este guión gráfico y sus elementos secundarios.</param>
        <param name="offset">Valor positivo o negativo que describe cuánto debe avanzar o retroceder la escala de tiempo desde el <c>origin</c> especificado.</param>
        <param name="origin">Posición desde la que se aplica <c>offset</c>.</param>
        <summary>Busca este objeto <see cref="T:System.Windows.Media.Animation.Storyboard" /> en la posición especificada. <see cref="T:System.Windows.Media.Animation.Storyboard" /> realiza la búsqueda solicitada cuando tiene lugar el siguiente paso del reloj.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Tenga en cuenta que las operaciones de búsqueda no toman del guión gráfico <xref:System.Windows.Media.Animation.Timeline.SpeedRatio%2A> o <xref:System.Windows.Media.Animation.ParallelTimeline.SlipBehavior%2A> la configuración de cuenta. El guión gráfico se trata como si tuviera un <xref:System.Windows.Media.Animation.Timeline.SpeedRatio%2A> de 1 y ningún <xref:System.Windows.Media.Animation.ParallelTimeline.SlipBehavior%2A>.  
  
 Este método cambia el reloj guión gráfico <xref:System.Windows.Media.Animation.Clock.CurrentState%2A> a <xref:System.Windows.Media.Animation.ClockState.Active>. Este método no tiene ningún efecto en el árbol de control de tiempo hasta la próxima vez que se procese un paso. Como efecto secundario, los eventos adecuados también no se generan hasta ese momento.  
  
 Para controlar este guión gráfico de forma interactiva, debe usar el mismo `containingObject` parámetro al llamar a los métodos interactivos que usó para iniciar el guión gráfico. Un guión gráfico controlable puede pausar, reanudar, buscar, detener y se puede quitar si se realiza controlable. Para hacer un guión gráfico controlable en código, debe usar la sobrecarga adecuada del guión gráfico <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> método y especifique `true` para que sea controlable. Para obtener un ejemplo, vea [Cómo: controlar un guión gráfico después de su inicio](~/docs/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts.md).  
  
 Búsqueda activa un guión gráfico el <xref:System.Windows.Media.Animation.Timeline.CurrentGlobalSpeedInvalidated> y <xref:System.Windows.Media.Animation.Timeline.CurrentStateInvalidated> eventos.  
  
   
  
## Examples  
 El ejemplo siguiente muestra cómo buscar (omitir) a un segundo después de que comienza un guión gráfico.  
  
 [!code-csharp[timingbehaviors_procedural_snip#SeekStoryboardExampleWholePage](~/samples/snippets/csharp/VS_Snippets_Wpf/timingbehaviors_procedural_snip/CSharp/SeekStoryboardExample.cs#seekstoryboardexamplewholepage)]
 [!code-vb[timingbehaviors_procedural_snip#SeekStoryboardExampleWholePage](~/samples/snippets/visualbasic/VS_Snippets_Wpf/timingbehaviors_procedural_snip/visualbasic/seekstoryboardexample.vb#seekstoryboardexamplewholepage)]  
  
 En el ejemplo siguiente se muestra tanto el <xref:System.Windows.Media.Animation.Storyboard.Seek%2A> y <xref:System.Windows.Media.Animation.Storyboard.SeekAlignedToLastTick%2A> métodos.  
  
 [!code-csharp[StoryboardBeginAnimation_procedural_snip#SeekExampleUsingWholePage](~/samples/snippets/csharp/VS_Snippets_Wpf/StoryboardBeginAnimation_procedural_snip/CSharp/SeekExample.cs#seekexampleusingwholepage)]
 [!code-vb[StoryboardBeginAnimation_procedural_snip#SeekExampleUsingWholePage](~/samples/snippets/visualbasic/VS_Snippets_Wpf/StoryboardBeginAnimation_procedural_snip/visualbasic/seekexample.vb#seekexampleusingwholepage)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Media.Animation.Storyboard.SeekAlignedToLastTick(System.Windows.FrameworkElement,System.TimeSpan,System.Windows.Media.Animation.TimeSeekOrigin)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="SeekAlignedToLastTick">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Busca de forma inmediata (sincrónicamente) este objeto <see cref="T:System.Windows.Media.Animation.Storyboard" /> en una nueva posición.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SeekAlignedToLastTick">
      <MemberSignature Language="C#" Value="public void SeekAlignedToLastTick (TimeSpan offset);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SeekAlignedToLastTick(valuetype System.TimeSpan offset) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.SeekAlignedToLastTick(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SeekAlignedToLastTick (offset As TimeSpan)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SeekAlignedToLastTick(TimeSpan offset);" />
      <MemberSignature Language="F#" Value="member this.SeekAlignedToLastTick : TimeSpan -&gt; unit" Usage="storyboard.SeekAlignedToLastTick offset" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="offset" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="offset">Valor positivo o negativo que describe cuánto debe avanzar o retroceder la escala de tiempo.</param>
        <summary>Busca de forma inmediata (sincrónicamente) este objeto <see cref="T:System.Windows.Media.Animation.Storyboard" /> en una nueva posición.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Media.Animation.Storyboard.SeekAlignedToLastTick%2A> se alinea a la hora de búsqueda del <xref:System.Windows.Media.Animation.Storyboard> con el último paso del reloj. Los valores se actualizan inmediatamente para reflejar los cambios debido a <xref:System.Windows.Media.Animation.Storyboard.SeekAlignedToLastTick%2A>, aunque la pantalla no refleja estos cambios hasta que las actualizaciones de pantalla.  
  
 Tenga en cuenta que las operaciones de búsqueda no toman del guión gráfico <xref:System.Windows.Media.Animation.Timeline.SpeedRatio%2A> o <xref:System.Windows.Media.Animation.ParallelTimeline.SlipBehavior%2A> la configuración de cuenta. El guión gráfico se trata como si tuviera un <xref:System.Windows.Media.Animation.Timeline.SpeedRatio%2A> de 1 y ningún <xref:System.Windows.Media.Animation.ParallelTimeline.SlipBehavior%2A>.  
  
 Para hacer un guión gráfico controlable en código, debe usar la sobrecarga adecuada del guión gráfico <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> método y especifique `true` para que sea controlable. Para obtener un ejemplo, vea [Cómo: controlar un guión gráfico después de su inicio](~/docs/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SeekAlignedToLastTick">
      <MemberSignature Language="C#" Value="public void SeekAlignedToLastTick (TimeSpan offset, System.Windows.Media.Animation.TimeSeekOrigin origin);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SeekAlignedToLastTick(valuetype System.TimeSpan offset, valuetype System.Windows.Media.Animation.TimeSeekOrigin origin) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.SeekAlignedToLastTick(System.TimeSpan,System.Windows.Media.Animation.TimeSeekOrigin)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SeekAlignedToLastTick (offset As TimeSpan, origin As TimeSeekOrigin)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SeekAlignedToLastTick(TimeSpan offset, System::Windows::Media::Animation::TimeSeekOrigin origin);" />
      <MemberSignature Language="F#" Value="member this.SeekAlignedToLastTick : TimeSpan * System.Windows.Media.Animation.TimeSeekOrigin -&gt; unit" Usage="storyboard.SeekAlignedToLastTick (offset, origin)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="offset" Type="System.TimeSpan" />
        <Parameter Name="origin" Type="System.Windows.Media.Animation.TimeSeekOrigin" />
      </Parameters>
      <Docs>
        <param name="offset">Valor positivo o negativo que describe cuánto debe avanzar o retroceder la escala de tiempo desde el <c>origin</c> especificado.</param>
        <param name="origin">Posición desde la que se aplica <c>offset</c>.</param>
        <summary>Busca de forma inmediata (sincrónicamente) este objeto <see cref="T:System.Windows.Media.Animation.Storyboard" /> en una nueva posición.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Media.Animation.Storyboard.SeekAlignedToLastTick%2A> se alinea a la hora de búsqueda del <xref:System.Windows.Media.Animation.Storyboard> con el último paso del reloj. Los valores se actualizan inmediatamente para reflejar los cambios debido a <xref:System.Windows.Media.Animation.Storyboard.SeekAlignedToLastTick%2A>, aunque la pantalla no refleja estos cambios hasta que las actualizaciones de pantalla.  
  
 Tenga en cuenta que las operaciones de búsqueda no toman del guión gráfico <xref:System.Windows.Media.Animation.Timeline.SpeedRatio%2A> o <xref:System.Windows.Media.Animation.ParallelTimeline.SlipBehavior%2A> la configuración de cuenta. El guión gráfico se trata como si tuviera un <xref:System.Windows.Media.Animation.Timeline.SpeedRatio%2A> de 1 y ningún <xref:System.Windows.Media.Animation.ParallelTimeline.SlipBehavior%2A>.  
  
 Para hacer un guión gráfico controlable en código, debe usar la sobrecarga adecuada del guión gráfico <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> método y especifique `true` para que sea controlable. Para obtener un ejemplo, vea [Cómo: controlar un guión gráfico después de su inicio](~/docs/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SeekAlignedToLastTick">
      <MemberSignature Language="C#" Value="public void SeekAlignedToLastTick (System.Windows.FrameworkContentElement containingObject, TimeSpan offset, System.Windows.Media.Animation.TimeSeekOrigin origin);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SeekAlignedToLastTick(class System.Windows.FrameworkContentElement containingObject, valuetype System.TimeSpan offset, valuetype System.Windows.Media.Animation.TimeSeekOrigin origin) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.SeekAlignedToLastTick(System.Windows.FrameworkContentElement,System.TimeSpan,System.Windows.Media.Animation.TimeSeekOrigin)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SeekAlignedToLastTick (containingObject As FrameworkContentElement, offset As TimeSpan, origin As TimeSeekOrigin)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SeekAlignedToLastTick(System::Windows::FrameworkContentElement ^ containingObject, TimeSpan offset, System::Windows::Media::Animation::TimeSeekOrigin origin);" />
      <MemberSignature Language="F#" Value="member this.SeekAlignedToLastTick : System.Windows.FrameworkContentElement * TimeSpan * System.Windows.Media.Animation.TimeSeekOrigin -&gt; unit" Usage="storyboard.SeekAlignedToLastTick (containingObject, offset, origin)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="containingObject" Type="System.Windows.FrameworkContentElement" />
        <Parameter Name="offset" Type="System.TimeSpan" />
        <Parameter Name="origin" Type="System.Windows.Media.Animation.TimeSeekOrigin" />
      </Parameters>
      <Docs>
        <param name="containingObject">Objeto especificado cuando se llamó al método <see cref="M:System.Windows.Media.Animation.Storyboard.Begin(System.Windows.FrameworkContentElement,System.Boolean)" />. Este objeto contiene los objetos <see cref="T:System.Windows.Media.Animation.Clock" /> que se crearon para este guión gráfico y sus elementos secundarios.</param>
        <param name="offset">Valor positivo o negativo que describe cuánto debe avanzar o retroceder la escala de tiempo desde el <c>origin</c> especificado.</param>
        <param name="origin">Posición desde la que se aplica <c>offset</c>.</param>
        <summary>Busca de forma inmediata (sincrónicamente) este objeto <see cref="T:System.Windows.Media.Animation.Storyboard" /> en una nueva posición.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Media.Animation.Storyboard.SeekAlignedToLastTick%2A> se alinea a la hora de búsqueda del <xref:System.Windows.Media.Animation.Storyboard> con el último paso del reloj. Los valores se actualizan inmediatamente para reflejar los cambios debido a <xref:System.Windows.Media.Animation.Storyboard.SeekAlignedToLastTick%2A>, aunque la pantalla no refleja estos cambios hasta que las actualizaciones de pantalla.  
  
 Tenga en cuenta que las operaciones de búsqueda no toman del guión gráfico <xref:System.Windows.Media.Animation.Timeline.SpeedRatio%2A> o <xref:System.Windows.Media.Animation.ParallelTimeline.SlipBehavior%2A> la configuración de cuenta. El guión gráfico se trata como si tuviera un <xref:System.Windows.Media.Animation.Timeline.SpeedRatio%2A> de 1 y ningún <xref:System.Windows.Media.Animation.ParallelTimeline.SlipBehavior%2A>.  
  
 Este método cambia el reloj guión gráfico <xref:System.Windows.Media.Animation.Clock.CurrentState%2A> a  
  
 <xref:System.Windows.Media.Animation.ClockState.Active>.  
  
 Búsqueda activa un guión gráfico el <xref:System.Windows.Media.Animation.Timeline.CurrentGlobalSpeedInvalidated> y <xref:System.Windows.Media.Animation.Timeline.CurrentStateInvalidated> eventos.  
  
 Para controlar este guión gráfico de forma interactiva, debe usar el mismo `containingObject` parámetro al llamar a los métodos interactivos que usó para iniciar el guión gráfico. Un guión gráfico controlable puede pausar, reanudar, buscar, detener y se puede quitar. Para hacer un guión gráfico controlable en código, debe usar la sobrecarga adecuada del guión gráfico <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> método y especifique `true` para que sea controlable. Para obtener un ejemplo, vea [Cómo: controlar un guión gráfico después de su inicio](~/docs/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts.md).  
  
   
  
## Examples  
 El ejemplo siguiente muestra tanto el <xref:System.Windows.Media.Animation.Storyboard.Seek%2A> y <xref:System.Windows.Media.Animation.Storyboard.SeekAlignedToLastTick%2A> métodos.  
  
 [!code-csharp[StoryboardBeginAnimation_procedural_snip#FrameworkContentElementSeekExampleUsingWholePage](~/samples/snippets/csharp/VS_Snippets_Wpf/StoryboardBeginAnimation_procedural_snip/CSharp/FrameworkContentElementSeekExample.cs#frameworkcontentelementseekexampleusingwholepage)]
 [!code-vb[StoryboardBeginAnimation_procedural_snip#FrameworkContentElementSeekExampleUsingWholePage](~/samples/snippets/visualbasic/VS_Snippets_Wpf/StoryboardBeginAnimation_procedural_snip/visualbasic/frameworkcontentelementseekexample.vb#frameworkcontentelementseekexampleusingwholepage)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SeekAlignedToLastTick">
      <MemberSignature Language="C#" Value="public void SeekAlignedToLastTick (System.Windows.FrameworkElement containingObject, TimeSpan offset, System.Windows.Media.Animation.TimeSeekOrigin origin);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SeekAlignedToLastTick(class System.Windows.FrameworkElement containingObject, valuetype System.TimeSpan offset, valuetype System.Windows.Media.Animation.TimeSeekOrigin origin) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.SeekAlignedToLastTick(System.Windows.FrameworkElement,System.TimeSpan,System.Windows.Media.Animation.TimeSeekOrigin)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SeekAlignedToLastTick (containingObject As FrameworkElement, offset As TimeSpan, origin As TimeSeekOrigin)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SeekAlignedToLastTick(System::Windows::FrameworkElement ^ containingObject, TimeSpan offset, System::Windows::Media::Animation::TimeSeekOrigin origin);" />
      <MemberSignature Language="F#" Value="member this.SeekAlignedToLastTick : System.Windows.FrameworkElement * TimeSpan * System.Windows.Media.Animation.TimeSeekOrigin -&gt; unit" Usage="storyboard.SeekAlignedToLastTick (containingObject, offset, origin)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="containingObject" Type="System.Windows.FrameworkElement" />
        <Parameter Name="offset" Type="System.TimeSpan" />
        <Parameter Name="origin" Type="System.Windows.Media.Animation.TimeSeekOrigin" />
      </Parameters>
      <Docs>
        <param name="containingObject">Objeto especificado cuando se llamó al método <see cref="M:System.Windows.Media.Animation.Storyboard.Begin(System.Windows.FrameworkElement,System.Boolean)" />. Este objeto contiene los objetos <see cref="T:System.Windows.Media.Animation.Clock" /> que se crearon para este guión gráfico y sus elementos secundarios.</param>
        <param name="offset">Valor positivo o negativo que describe cuánto debe avanzar o retroceder la escala de tiempo desde el <c>origin</c> especificado.</param>
        <param name="origin">Posición desde la que se aplica <c>offset</c>.</param>
        <summary>Busca de forma inmediata (sincrónicamente) este objeto <see cref="T:System.Windows.Media.Animation.Storyboard" /> en una nueva posición.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Media.Animation.Storyboard.SeekAlignedToLastTick%2A> se alinea a la hora de búsqueda del <xref:System.Windows.Media.Animation.Storyboard> con el último paso del reloj. Los valores se actualizan inmediatamente para reflejar los cambios debido a <xref:System.Windows.Media.Animation.Storyboard.SeekAlignedToLastTick%2A>, aunque la pantalla no refleja estos cambios hasta que las actualizaciones de pantalla.  
  
 Tenga en cuenta que las operaciones de búsqueda no toman del guión gráfico <xref:System.Windows.Media.Animation.Timeline.SpeedRatio%2A> o <xref:System.Windows.Media.Animation.ParallelTimeline.SlipBehavior%2A> la configuración de cuenta. El guión gráfico se trata como si tuviera un <xref:System.Windows.Media.Animation.Timeline.SpeedRatio%2A> de 1 y ningún <xref:System.Windows.Media.Animation.ParallelTimeline.SlipBehavior%2A>.  
  
 Este método cambia el reloj guión gráfico <xref:System.Windows.Media.Animation.Clock.CurrentState%2A> a  
  
 <xref:System.Windows.Media.Animation.ClockState.Active>.  
  
 Búsqueda activa un guión gráfico el <xref:System.Windows.Media.Animation.Timeline.CurrentGlobalSpeedInvalidated> y <xref:System.Windows.Media.Animation.Timeline.CurrentStateInvalidated> eventos.  
  
 Para controlar este guión gráfico de forma interactiva, debe usar el mismo `containingObject` parámetro al llamar a los métodos interactivos que usó para iniciar el guión gráfico. Un guión gráfico controlable puede pausar, reanudar, buscar, detener y se puede quitar. Para hacer un guión gráfico controlable en código, debe usar la sobrecarga adecuada del guión gráfico <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> método y especifique `true` para que sea controlable. Para obtener un ejemplo, vea [Cómo: controlar un guión gráfico después de su inicio](~/docs/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts.md).  
  
   
  
## Examples  
 El ejemplo siguiente muestra tanto el <xref:System.Windows.Media.Animation.Storyboard.Seek%2A> y <xref:System.Windows.Media.Animation.Storyboard.SeekAlignedToLastTick%2A> métodos.  
  
 [!code-csharp[StoryboardBeginAnimation_procedural_snip#SeekExampleUsingWholePage](~/samples/snippets/csharp/VS_Snippets_Wpf/StoryboardBeginAnimation_procedural_snip/CSharp/SeekExample.cs#seekexampleusingwholepage)]
 [!code-vb[StoryboardBeginAnimation_procedural_snip#SeekExampleUsingWholePage](~/samples/snippets/visualbasic/VS_Snippets_Wpf/StoryboardBeginAnimation_procedural_snip/visualbasic/seekexample.vb#seekexampleusingwholepage)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="SetSpeedRatio">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Establece la relación de velocidad interactiva del objeto <see cref="T:System.Windows.Media.Animation.Clock" /> que se creó para este objeto <see cref="T:System.Windows.Media.Animation.Storyboard" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SetSpeedRatio">
      <MemberSignature Language="C#" Value="public void SetSpeedRatio (double speedRatio);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetSpeedRatio(float64 speedRatio) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.SetSpeedRatio(System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetSpeedRatio (speedRatio As Double)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetSpeedRatio(double speedRatio);" />
      <MemberSignature Language="F#" Value="member this.SetSpeedRatio : double -&gt; unit" Usage="storyboard.SetSpeedRatio speedRatio" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="speedRatio" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="speedRatio">Valor finito mayor que cero que es la nueva relación de velocidad interactiva del guión gráfico. Este valor se multiplica por el valor de <see cref="P:System.Windows.Media.Animation.Timeline.SpeedRatio" /> del guión gráfico para determinar la velocidad efectiva del guión gráfico. Este valor no sobrescribe la propiedad <see cref="P:System.Windows.Media.Animation.Timeline.SpeedRatio" /> del guión gráfico. Por ejemplo, al llamar a este método y especificar una relación de velocidad interactiva de 3 en un guión gráfico cuya propiedad <see cref="P:System.Windows.Media.Animation.Timeline.SpeedRatio" /> es 0,5, se asigna al guión gráfico una velocidad eficaz de 1,5.</param>
        <summary>Establece la relación de velocidad interactiva del objeto <see cref="T:System.Windows.Media.Animation.Clock" /> que se creó para este objeto <see cref="T:System.Windows.Media.Animation.Storyboard" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un guión gráfico controlable puede pausar, reanudar, buscar, detener y se puede quitar. Para hacer un guión gráfico controlable en código, debe usar la sobrecarga adecuada del guión gráfico <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> método y especifique `true` para que sea controlable. Para obtener un ejemplo, vea [Cómo: controlar un guión gráfico después de su inicio](~/docs/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetSpeedRatio">
      <MemberSignature Language="C#" Value="public void SetSpeedRatio (System.Windows.FrameworkContentElement containingObject, double speedRatio);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetSpeedRatio(class System.Windows.FrameworkContentElement containingObject, float64 speedRatio) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.SetSpeedRatio(System.Windows.FrameworkContentElement,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetSpeedRatio (containingObject As FrameworkContentElement, speedRatio As Double)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetSpeedRatio(System::Windows::FrameworkContentElement ^ containingObject, double speedRatio);" />
      <MemberSignature Language="F#" Value="member this.SetSpeedRatio : System.Windows.FrameworkContentElement * double -&gt; unit" Usage="storyboard.SetSpeedRatio (containingObject, speedRatio)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="containingObject" Type="System.Windows.FrameworkContentElement" />
        <Parameter Name="speedRatio" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="containingObject">Objeto especificado cuando se llamó al método <see cref="M:System.Windows.Media.Animation.Storyboard.Begin(System.Windows.FrameworkContentElement,System.Boolean)" />. Este objeto contiene los objetos <see cref="T:System.Windows.Media.Animation.Clock" /> que se crearon para este guión gráfico y sus elementos secundarios.</param>
        <param name="speedRatio">Valor finito mayor que cero que es la nueva relación de velocidad interactiva del guión gráfico. Este valor se multiplica por el valor de <see cref="P:System.Windows.Media.Animation.Timeline.SpeedRatio" /> del guión gráfico para determinar la velocidad efectiva del guión gráfico. Este valor no sobrescribe la propiedad <see cref="P:System.Windows.Media.Animation.Timeline.SpeedRatio" /> del guión gráfico. Por ejemplo, al llamar a este método y especificar una relación de velocidad interactiva de 3 en un guión gráfico cuya propiedad <see cref="P:System.Windows.Media.Animation.Timeline.SpeedRatio" /> es 0,5, se asigna al guión gráfico una velocidad eficaz de 1,5.</param>
        <summary>Establece la relación de velocidad interactiva del objeto <see cref="T:System.Windows.Media.Animation.Clock" /> que se creó para este objeto <see cref="T:System.Windows.Media.Animation.Storyboard" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para controlar este guión gráfico de forma interactiva, debe usar el mismo `containingObject` parámetro al llamar a los métodos interactivos que usó para iniciar el guión gráfico. Un guión gráfico controlable puede pausar, reanudar, buscar, detener y se puede quitar. Para hacer un guión gráfico controlable en código, debe usar la sobrecarga adecuada del guión gráfico <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> método y especifique `true` para que sea controlable. Para obtener un ejemplo, vea [Cómo: controlar un guión gráfico después de su inicio](~/docs/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts.md).  
  
 Llamar a este método desencadena el <xref:System.Windows.Media.Animation.Timeline.CurrentGlobalSpeedInvalidated> eventos.  
  
   
  
## Examples  
 En el ejemplo siguiente se usa un guión gráfico controlable para animar un <xref:System.Windows.Media.TextEffect>. El <xref:System.Windows.Media.TextEffect> está dentro de un <xref:System.Windows.FrameworkContentElement>del nombre de ámbito.  
  
 [!code-csharp[StoryboardBeginAnimation_procedural_snip#FrameworkContentElementControlStoryboardExampleUsingWholePage](~/samples/snippets/csharp/VS_Snippets_Wpf/StoryboardBeginAnimation_procedural_snip/CSharp/FrameworkContentElementControlStoryboardExample.cs#frameworkcontentelementcontrolstoryboardexampleusingwholepage)]
 [!code-vb[StoryboardBeginAnimation_procedural_snip#FrameworkContentElementControlStoryboardExampleUsingWholePage](~/samples/snippets/visualbasic/VS_Snippets_Wpf/StoryboardBeginAnimation_procedural_snip/visualbasic/frameworkcontentelementcontrolstoryboardexample.vb#frameworkcontentelementcontrolstoryboardexampleusingwholepage)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetSpeedRatio">
      <MemberSignature Language="C#" Value="public void SetSpeedRatio (System.Windows.FrameworkElement containingObject, double speedRatio);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetSpeedRatio(class System.Windows.FrameworkElement containingObject, float64 speedRatio) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.SetSpeedRatio(System.Windows.FrameworkElement,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetSpeedRatio (containingObject As FrameworkElement, speedRatio As Double)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetSpeedRatio(System::Windows::FrameworkElement ^ containingObject, double speedRatio);" />
      <MemberSignature Language="F#" Value="member this.SetSpeedRatio : System.Windows.FrameworkElement * double -&gt; unit" Usage="storyboard.SetSpeedRatio (containingObject, speedRatio)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="containingObject" Type="System.Windows.FrameworkElement" />
        <Parameter Name="speedRatio" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="containingObject">Objeto especificado cuando se llamó al método <see cref="M:System.Windows.Media.Animation.Storyboard.Begin(System.Windows.FrameworkElement,System.Boolean)" />. Este objeto contiene los objetos <see cref="T:System.Windows.Media.Animation.Clock" /> que se crearon para este guión gráfico y sus elementos secundarios.</param>
        <param name="speedRatio">Valor finito mayor que cero que es la nueva relación de velocidad interactiva del guión gráfico. Este valor se multiplica por el valor de <see cref="P:System.Windows.Media.Animation.Timeline.SpeedRatio" /> del guión gráfico para determinar la velocidad efectiva del guión gráfico. Este valor no sobrescribe la propiedad <see cref="P:System.Windows.Media.Animation.Timeline.SpeedRatio" /> del guión gráfico. Por ejemplo, al llamar a este método y especificar una relación de velocidad interactiva de 3 en un guión gráfico cuya propiedad <see cref="P:System.Windows.Media.Animation.Timeline.SpeedRatio" /> es 0,5, se asigna al guión gráfico una velocidad eficaz de 1,5.</param>
        <summary>Establece la relación de velocidad interactiva del objeto <see cref="T:System.Windows.Media.Animation.Clock" /> que se creó para este objeto <see cref="T:System.Windows.Media.Animation.Storyboard" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para controlar este guión gráfico de forma interactiva, debe usar el mismo `containingObject` parámetro al llamar a los métodos interactivos que usó para iniciar el guión gráfico. Un guión gráfico controlable puede pausar, reanudar, buscar, detener y se puede quitar. Para hacer un guión gráfico controlable en código, debe usar la sobrecarga adecuada del guión gráfico <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> método y especifique `true` para que sea controlable. Para obtener un ejemplo, vea [Cómo: controlar un guión gráfico después de su inicio](~/docs/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts.md).  
  
 Llamar a este método desencadena el <xref:System.Windows.Media.Animation.Timeline.CurrentGlobalSpeedInvalidated> eventos.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetTarget">
      <MemberSignature Language="C#" Value="public static void SetTarget (System.Windows.DependencyObject element, System.Windows.DependencyObject value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetTarget(class System.Windows.DependencyObject element, class System.Windows.DependencyObject value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.SetTarget(System.Windows.DependencyObject,System.Windows.DependencyObject)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetTarget (element As DependencyObject, value As DependencyObject)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetTarget(System::Windows::DependencyObject ^ element, System::Windows::DependencyObject ^ value);" />
      <MemberSignature Language="F#" Value="static member SetTarget : System.Windows.DependencyObject * System.Windows.DependencyObject -&gt; unit" Usage="System.Windows.Media.Animation.Storyboard.SetTarget (element, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
        <Parameter Name="value" Type="System.Windows.DependencyObject" />
      </Parameters>
      <Docs>
        <param name="element">
          <see cref="T:System.Windows.Media.Animation.Timeline" /> que debería ser el destino del objeto de dependencia especificado.</param>
        <param name="value">Objeto de dependencia de destino.</param>
        <summary>Hace que el objeto <see cref="T:System.Windows.Media.Animation.Timeline" /> especificado tenga como destino el objeto de dependencia.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método establece el <xref:System.Windows.Media.Animation.Storyboard.Target%2A> propiedad adjunta en el objeto especificado. Para obtener más información acerca de cómo funcionan los destinos de guión gráfico, vea <xref:System.Windows.Media.Animation.Storyboard.TargetName%2A>. Para obtener más información sobre cómo funcionan las propiedades adjuntas cómo, consulte [Attached Properties Overview](~/docs/framework/wpf/advanced/attached-properties-overview.md).  
  
> [!NOTE]
>  El <xref:System.Windows.Media.Animation.Storyboard.Target%2A> propiedad no es serializable, porque se puede establecer en cualquier <xref:System.Windows.DependencyObject>. No se garantiza que se puede hacer referencia a este objeto correctamente desde XAML.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Media.Animation.Storyboard.TargetName" />
      </Docs>
    </Member>
    <Member MemberName="SetTargetName">
      <MemberSignature Language="C#" Value="public static void SetTargetName (System.Windows.DependencyObject element, string name);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetTargetName(class System.Windows.DependencyObject element, string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.SetTargetName(System.Windows.DependencyObject,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetTargetName (element As DependencyObject, name As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetTargetName(System::Windows::DependencyObject ^ element, System::String ^ name);" />
      <MemberSignature Language="F#" Value="static member SetTargetName : System.Windows.DependencyObject * string -&gt; unit" Usage="System.Windows.Media.Animation.Storyboard.SetTargetName (element, name)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="element">
          <see cref="T:System.Windows.Media.Animation.Timeline" /> que debería ser el destino del objeto de dependencia especificado.</param>
        <param name="name">Nombre del objeto de dependencia que se establecerá como destino.</param>
        <summary>Convierte el destino de <see cref="T:System.Windows.Media.Animation.Timeline" /> especificado en el objeto de dependencia con el nombre establecido.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método establece el <xref:System.Windows.Media.Animation.Storyboard.TargetName%2A> propiedad adjunta en el objeto especificado. Para obtener más información acerca de cómo funcionan los destinos de guión gráfico, vea <xref:System.Windows.Media.Animation.Storyboard.TargetName%2A>. Para obtener más información sobre cómo funcionan las propiedades adjuntas cómo, consulte [Attached Properties Overview](~/docs/framework/wpf/advanced/attached-properties-overview.md).  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Media.Animation.Storyboard.TargetName" />
      </Docs>
    </Member>
    <Member MemberName="SetTargetProperty">
      <MemberSignature Language="C#" Value="public static void SetTargetProperty (System.Windows.DependencyObject element, System.Windows.PropertyPath path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetTargetProperty(class System.Windows.DependencyObject element, class System.Windows.PropertyPath path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.SetTargetProperty(System.Windows.DependencyObject,System.Windows.PropertyPath)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetTargetProperty (element As DependencyObject, path As PropertyPath)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetTargetProperty(System::Windows::DependencyObject ^ element, System::Windows::PropertyPath ^ path);" />
      <MemberSignature Language="F#" Value="static member SetTargetProperty : System.Windows.DependencyObject * System.Windows.PropertyPath -&gt; unit" Usage="System.Windows.Media.Animation.Storyboard.SetTargetProperty (element, path)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
        <Parameter Name="path" Type="System.Windows.PropertyPath" />
      </Parameters>
      <Docs>
        <param name="element">
          <see cref="T:System.Windows.Media.Animation.Timeline" /> con el que se va a asociar la propiedad de dependencia especificada.</param>
        <param name="path">Ruta de acceso que describe la propiedad de dependencia que se va a animar.</param>
        <summary>Convierte el destino de <see cref="T:System.Windows.Media.Animation.Timeline" /> especificado en la propiedad de dependencia establecida.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método establece el <xref:System.Windows.Media.Animation.Storyboard.TargetProperty%2A> propiedad adjunta en el objeto especificado. Para obtener más información acerca de cómo funcionan los destinos de guión gráfico, vea <xref:System.Windows.Media.Animation.Storyboard.TargetProperty%2A>. Para obtener más información sobre cómo funcionan las propiedades adjuntas cómo, consulte [Attached Properties Overview](~/docs/framework/wpf/advanced/attached-properties-overview.md).  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Media.Animation.Storyboard.TargetProperty" />
      </Docs>
    </Member>
    <MemberGroup MemberName="SkipToFill">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Adelanta la hora actual del objeto <see cref="T:System.Windows.Media.Animation.Clock" /> de este guión gráfico hasta el final de su período activo.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SkipToFill">
      <MemberSignature Language="C#" Value="public void SkipToFill ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SkipToFill() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.SkipToFill" />
      <MemberSignature Language="VB.NET" Value="Public Sub SkipToFill ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SkipToFill();" />
      <MemberSignature Language="F#" Value="member this.SkipToFill : unit -&gt; unit" Usage="storyboard.SkipToFill " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Adelanta la hora actual del objeto <see cref="T:System.Windows.Media.Animation.Clock" /> de este guión gráfico hasta el final de su período activo.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un guión gráfico controlable puede pausar, reanudar, buscar, detener y se puede quitar. Para hacer un guión gráfico controlable en código, debe usar la sobrecarga adecuada del guión gráfico <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> método y especifique `true` para que sea controlable. Para obtener un ejemplo, vea [Cómo: controlar un guión gráfico después de su inicio](~/docs/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SkipToFill">
      <MemberSignature Language="C#" Value="public void SkipToFill (System.Windows.FrameworkContentElement containingObject);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SkipToFill(class System.Windows.FrameworkContentElement containingObject) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.SkipToFill(System.Windows.FrameworkContentElement)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SkipToFill (containingObject As FrameworkContentElement)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SkipToFill(System::Windows::FrameworkContentElement ^ containingObject);" />
      <MemberSignature Language="F#" Value="member this.SkipToFill : System.Windows.FrameworkContentElement -&gt; unit" Usage="storyboard.SkipToFill containingObject" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="containingObject" Type="System.Windows.FrameworkContentElement" />
      </Parameters>
      <Docs>
        <param name="containingObject">Objeto especificado cuando se llamó al método <see cref="M:System.Windows.Media.Animation.Storyboard.Begin(System.Windows.FrameworkContentElement,System.Boolean)" />. Este objeto contiene los objetos <see cref="T:System.Windows.Media.Animation.Clock" /> que se crearon para este guión gráfico y sus elementos secundarios.</param>
        <summary>Adelanta la hora actual del objeto <see cref="T:System.Windows.Media.Animation.Clock" /> de este guión gráfico hasta el final de su período activo.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método avanza del guión gráfico hora actual al final de su período activo; comportamiento del guión gráfico en este momento especificado por su <xref:System.Windows.Media.Animation.Timeline.FillBehavior%2A> configuración. Si <xref:System.Windows.Media.Animation.Timeline.FillBehavior%2A> está establecido en <xref:System.Windows.Media.Animation.FillBehavior.HoldEnd>, rellena el guión gráfico; si la propiedad se establece en <xref:System.Windows.Media.Animation.FillBehavior.Stop>, los delimitadores de guión gráfico.  
  
 Llamar a este método en un guión gráfico con una duración infinita, un número infinito de repeticiones no tiene ningún efecto. Llamar a este método en un guión gráfico inactivo no tiene ningún efecto.  
  
 Avanzar un reloj para su relleno desencadenadores períodos el <xref:System.Windows.Media.Animation.Timeline.CurrentGlobalSpeedInvalidated> y <xref:System.Windows.Media.Animation.Timeline.CurrentStateInvalidated> eventos.  
  
 Para controlar este guión gráfico de forma interactiva, debe usar el mismo `containingObject` parámetro al llamar a los métodos interactivos que usó para iniciar el guión gráfico. Un guión gráfico controlable puede pausar, reanudar, buscar, detener y se puede quitar. Para hacer un guión gráfico controlable en código, debe usar la sobrecarga adecuada del guión gráfico <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> método y especifique `true` para que sea controlable. Para obtener un ejemplo, vea [Cómo: controlar un guión gráfico después de su inicio](~/docs/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts.md).  
  
   
  
## Examples  
 En el ejemplo siguiente se usa un guión gráfico controlable para animar un <xref:System.Windows.Media.TextEffect>. El <xref:System.Windows.Media.TextEffect> está dentro de un <xref:System.Windows.FrameworkContentElement>del nombre de ámbito.  
  
 [!code-csharp[StoryboardBeginAnimation_procedural_snip#FrameworkContentElementControlStoryboardExampleUsingWholePage](~/samples/snippets/csharp/VS_Snippets_Wpf/StoryboardBeginAnimation_procedural_snip/CSharp/FrameworkContentElementControlStoryboardExample.cs#frameworkcontentelementcontrolstoryboardexampleusingwholepage)]
 [!code-vb[StoryboardBeginAnimation_procedural_snip#FrameworkContentElementControlStoryboardExampleUsingWholePage](~/samples/snippets/visualbasic/VS_Snippets_Wpf/StoryboardBeginAnimation_procedural_snip/visualbasic/frameworkcontentelementcontrolstoryboardexample.vb#frameworkcontentelementcontrolstoryboardexampleusingwholepage)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SkipToFill">
      <MemberSignature Language="C#" Value="public void SkipToFill (System.Windows.FrameworkElement containingObject);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SkipToFill(class System.Windows.FrameworkElement containingObject) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.SkipToFill(System.Windows.FrameworkElement)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SkipToFill (containingObject As FrameworkElement)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SkipToFill(System::Windows::FrameworkElement ^ containingObject);" />
      <MemberSignature Language="F#" Value="member this.SkipToFill : System.Windows.FrameworkElement -&gt; unit" Usage="storyboard.SkipToFill containingObject" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="containingObject" Type="System.Windows.FrameworkElement" />
      </Parameters>
      <Docs>
        <param name="containingObject">Objeto especificado cuando se llamó al método <see cref="M:System.Windows.Media.Animation.Storyboard.Begin(System.Windows.FrameworkElement,System.Boolean)" />. Este objeto contiene los objetos <see cref="T:System.Windows.Media.Animation.Clock" /> que se crearon para este guión gráfico y sus elementos secundarios.</param>
        <summary>Adelanta la hora actual del objeto <see cref="T:System.Windows.Media.Animation.Clock" /> de este guión gráfico hasta el final de su período activo.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método avanza del guión gráfico hora actual al final de su período activo; comportamiento del guión gráfico en este momento especificado por su <xref:System.Windows.Media.Animation.Timeline.FillBehavior%2A> configuración. Si <xref:System.Windows.Media.Animation.Timeline.FillBehavior%2A> está establecido en <xref:System.Windows.Media.Animation.FillBehavior.HoldEnd>, rellena el guión gráfico; si la propiedad se establece en <xref:System.Windows.Media.Animation.FillBehavior.Stop>, los delimitadores de guión gráfico.  
  
 Llamar a este método en un guión gráfico con una duración infinita, un número infinito de repeticiones no tiene ningún efecto. Llamar a este método en un guión gráfico inactivo no tiene ningún efecto.  
  
 Avanzar un reloj para su relleno desencadenadores períodos el <xref:System.Windows.Media.Animation.Timeline.CurrentGlobalSpeedInvalidated> y <xref:System.Windows.Media.Animation.Timeline.CurrentStateInvalidated> eventos.  
  
 Para controlar este guión gráfico de forma interactiva, debe usar el mismo `containingObject` parámetro al llamar a los métodos interactivos que usó para iniciar el guión gráfico. Un guión gráfico controlable puede pausar, reanudar, buscar, detener y se puede quitar. Para hacer un guión gráfico controlable en código, debe usar la sobrecarga adecuada del guión gráfico <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> método y especifique `true` para que sea controlable. Para obtener un ejemplo, vea [Cómo: controlar un guión gráfico después de su inicio](~/docs/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Stop">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Detiene el objeto <see cref="T:System.Windows.Media.Animation.Clock" /> que se creó para este <see cref="T:System.Windows.Media.Animation.Storyboard" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Stop">
      <MemberSignature Language="C#" Value="public void Stop ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Stop() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.Stop" />
      <MemberSignature Language="VB.NET" Value="Public Sub Stop ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Stop();" />
      <MemberSignature Language="F#" Value="member this.Stop : unit -&gt; unit" Usage="storyboard.Stop " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Detiene el objeto <see cref="T:System.Windows.Media.Animation.Clock" /> que se creó para este <see cref="T:System.Windows.Media.Animation.Storyboard" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Tenga en cuenta que la detención de un guión gráfico no se activa el <xref:System.Windows.Media.Animation.Timeline.Completed> eventos.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stop">
      <MemberSignature Language="C#" Value="public void Stop (System.Windows.FrameworkContentElement containingObject);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Stop(class System.Windows.FrameworkContentElement containingObject) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.Stop(System.Windows.FrameworkContentElement)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Stop (containingObject As FrameworkContentElement)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Stop(System::Windows::FrameworkContentElement ^ containingObject);" />
      <MemberSignature Language="F#" Value="member this.Stop : System.Windows.FrameworkContentElement -&gt; unit" Usage="storyboard.Stop containingObject" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="containingObject" Type="System.Windows.FrameworkContentElement" />
      </Parameters>
      <Docs>
        <param name="containingObject">Objeto especificado cuando se llamó al método <see cref="M:System.Windows.Media.Animation.Storyboard.Begin(System.Windows.FrameworkContentElement,System.Boolean)" />. Este objeto contiene los objetos <see cref="T:System.Windows.Media.Animation.Clock" /> que se crearon para este guión gráfico y sus elementos secundarios.</param>
        <summary>Detiene el objeto <see cref="T:System.Windows.Media.Animation.Clock" /> que se creó para este <see cref="T:System.Windows.Media.Animation.Storyboard" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un <xref:System.Windows.Media.Animation.ClockState.Stopped> guión gráfico ya no afecta a sus propiedades de destino: las propiedades que se anima revertirán los valores anteriores.  
  
 Deteniendo activa un reloj el <xref:System.Windows.Media.Animation.Timeline.CurrentGlobalSpeedInvalidated> y <xref:System.Windows.Media.Animation.Timeline.CurrentStateInvalidated> eventos, pero no la <xref:System.Windows.Media.Animation.Timeline.Completed> eventos.  
  
 Para controlar este guión gráfico de forma interactiva, debe usar el mismo `containingObject` parámetro al llamar a los métodos interactivos que usó para iniciar el guión gráfico. Un guión gráfico controlable puede pausar, reanudar, buscar, detener y se puede quitar. Para hacer un guión gráfico controlable en código, debe usar la sobrecarga adecuada del guión gráfico <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> método y especifique `true` para que sea controlable. Para obtener un ejemplo, vea [Cómo: controlar un guión gráfico después de su inicio](~/docs/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts.md).  
  
   
  
## Examples  
 En el ejemplo siguiente se usa un guión gráfico controlable para animar un <xref:System.Windows.Media.TextEffect>. El <xref:System.Windows.Media.TextEffect> está dentro de un <xref:System.Windows.FrameworkContentElement>del nombre de ámbito.  
  
 [!code-csharp[StoryboardBeginAnimation_procedural_snip#FrameworkContentElementControlStoryboardExampleUsingWholePage](~/samples/snippets/csharp/VS_Snippets_Wpf/StoryboardBeginAnimation_procedural_snip/CSharp/FrameworkContentElementControlStoryboardExample.cs#frameworkcontentelementcontrolstoryboardexampleusingwholepage)]
 [!code-vb[StoryboardBeginAnimation_procedural_snip#FrameworkContentElementControlStoryboardExampleUsingWholePage](~/samples/snippets/visualbasic/VS_Snippets_Wpf/StoryboardBeginAnimation_procedural_snip/visualbasic/frameworkcontentelementcontrolstoryboardexample.vb#frameworkcontentelementcontrolstoryboardexampleusingwholepage)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stop">
      <MemberSignature Language="C#" Value="public void Stop (System.Windows.FrameworkElement containingObject);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Stop(class System.Windows.FrameworkElement containingObject) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.Stop(System.Windows.FrameworkElement)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Stop (containingObject As FrameworkElement)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Stop(System::Windows::FrameworkElement ^ containingObject);" />
      <MemberSignature Language="F#" Value="member this.Stop : System.Windows.FrameworkElement -&gt; unit" Usage="storyboard.Stop containingObject" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="containingObject" Type="System.Windows.FrameworkElement" />
      </Parameters>
      <Docs>
        <param name="containingObject">Objeto especificado cuando se llamó al método <see cref="M:System.Windows.Media.Animation.Storyboard.Begin(System.Windows.FrameworkElement,System.Boolean)" />. Este objeto contiene los objetos <see cref="T:System.Windows.Media.Animation.Clock" /> que se crearon para este guión gráfico y sus elementos secundarios.</param>
        <summary>Detiene el objeto <see cref="T:System.Windows.Media.Animation.Clock" /> que se creó para este <see cref="T:System.Windows.Media.Animation.Storyboard" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un <xref:System.Windows.Media.Animation.ClockState.Stopped> guión gráfico ya no afecta a sus propiedades de destino: las propiedades que se anima revertirán los valores anteriores.  
  
 Deteniendo activa un reloj el <xref:System.Windows.Media.Animation.Timeline.CurrentGlobalSpeedInvalidated> y <xref:System.Windows.Media.Animation.Timeline.CurrentStateInvalidated> eventos, pero no la <xref:System.Windows.Media.Animation.Timeline.Completed> eventos.  
  
 Para controlar este guión gráfico de forma interactiva, debe usar el mismo `containingObject` parámetro al llamar a los métodos interactivos que usó para iniciar el guión gráfico. Un guión gráfico controlable puede pausar, reanudar, buscar, detener y se puede quitar. Para hacer un guión gráfico controlable en código, debe usar la sobrecarga adecuada del guión gráfico <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> método y especifique `true` para que sea controlable. Para obtener un ejemplo, vea [Cómo: controlar un guión gráfico después de su inicio](~/docs/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Target">
      <MemberSignature Language="C#" Value="see GetTarget, and SetTarget" />
      <MemberSignature Language="ILAsm" Value="see GetTarget, and SetTarget" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Media.Animation.Storyboard.Target" />
      <MemberSignature Language="VB.NET" Value="see GetTarget, and SetTarget" />
      <MemberSignature Language="F#" Value="see GetTarget, and SetTarget" Usage="see GetTarget, and SetTarget" />
      <MemberType>AttachedProperty</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Obtiene o establece el objeto que debe animarse.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El objeto de destino debe ser un objeto de dependencia.  
  
> [!NOTE]
>  El <xref:System.Windows.Media.Animation.Storyboard.Target%2A> propiedad no es serializable, porque se puede establecer en cualquier <xref:System.Windows.DependencyObject>. No hay ninguna garantiza que se puede hacer referencia a este objeto correctamente en XAML.  
  
<a name="dependencyPropertyInfo_Target"></a>   
## <a name="dependency-property-information"></a>Información sobre propiedades de dependencia  
  
|||  
|-|-|  
|Campo de identificador|<xref:System.Windows.Media.Animation.Storyboard.TargetProperty>|  
|Establecen las propiedades de metadatos en `true`|None|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TargetName">
      <MemberSignature Language="C#" Value="see GetTargetName, and SetTargetName" />
      <MemberSignature Language="ILAsm" Value="see GetTargetName, and SetTargetName" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Media.Animation.Storyboard.TargetName" />
      <MemberSignature Language="VB.NET" Value="see GetTargetName, and SetTargetName" />
      <MemberSignature Language="F#" Value="see GetTargetName, and SetTargetName" Usage="see GetTargetName, and SetTargetName" />
      <MemberType>AttachedProperty</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Obtiene o establece el objeto que se va a animar. El objeto debe pertenecer a la clase <see cref="T:System.Windows.FrameworkElement" />, <see cref="T:System.Windows.FrameworkContentElement" />o <see cref="T:System.Windows.Freezable" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Al establecer esta propiedad es opcional. Si el <xref:System.Windows.Media.Animation.Storyboard.TargetName%2A> no se especifica, las animaciones de un guión gráfico se aplican a uno de los siguientes:  
  
-   Si el guión gráfico al que pertenece la animación se inició mediante un <xref:System.Windows.Media.Animation.BeginStoryboard>, el elemento que posee el <xref:System.Windows.Media.Animation.BeginStoryboard> se destina la acción que desencadena el guión gráfico.  
  
-   Si se inició el guión gráfico mediante la <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> método, el <xref:System.Windows.FrameworkElement> o <xref:System.Windows.FrameworkContentElement> especificado cuando se inicia el guión gráfico con el <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> se destina el método.  
  
 Cuando esta propiedad se establece en una escala de tiempo con elementos secundarios, esos objetos Timeline secundarios "hereda" del elemento primario <xref:System.Windows.Media.Animation.Storyboard.TargetName%2A> a menos que especifiquen sus propias.  
  
## <a name="making-an-object-targetable"></a>Hacer que un objeto como destino  
 Cuando se usa [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)], realizar una de las dos acciones siguientes para crear un objeto como destino por un guión gráfico:  
  
-   Si el objeto es un <xref:System.Windows.FrameworkElement> o un <xref:System.Windows.FrameworkContentElement>, establezca su <xref:System.Windows.FrameworkElement.Name%2A> propiedad.  
  
-   Si el objeto es un <xref:System.Windows.Freezable> o una personalizada <xref:System.Windows.FrameworkContentElement> o <xref:System.Windows.FrameworkContentElement>, asignarle un nombre mediante el [x: Name Directive](~/docs/framework/xaml-services/x-name-directive.md) extensión de marcado.  
  
 Cuando se utiliza código, se crea un objeto como destino mediante el uso de la <xref:System.Windows.NameScope.RegisterName%2A> método para asignar un nombre de objeto.  
  
<a name="dependencyPropertyInfo_TargetName"></a>   
## <a name="dependency-property-information"></a>Información sobre propiedades de dependencia  
  
|||  
|-|-|  
|Campo de identificador|<xref:System.Windows.Media.Animation.Storyboard.TargetNameProperty>|  
|Establecen las propiedades de metadatos en `true`|None|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TargetNameProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty TargetNameProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty TargetNameProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Media.Animation.Storyboard.TargetNameProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly TargetNameProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ TargetNameProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable TargetNameProperty : System.Windows.DependencyProperty" Usage="System.Windows.Media.Animation.Storyboard.TargetNameProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifica la propiedad adjunta <see cref="P:System.Windows.Media.Animation.Storyboard.TargetName" />.</summary>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Windows.Media.Animation.Storyboard.TargetName" />
      </Docs>
    </Member>
    <Member MemberName="TargetProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty TargetProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty TargetProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Media.Animation.Storyboard.TargetProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly TargetProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ TargetProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable TargetProperty : System.Windows.DependencyProperty" Usage="System.Windows.Media.Animation.Storyboard.TargetProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifica la propiedad adjunta <see cref="P:System.Windows.Media.Animation.Storyboard.Target" />.</summary>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Windows.Media.Animation.Storyboard.TargetName" />
      </Docs>
    </Member>
    <Member MemberName="TargetPropertyProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty TargetPropertyProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty TargetPropertyProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Media.Animation.Storyboard.TargetPropertyProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly TargetPropertyProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ TargetPropertyProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable TargetPropertyProperty : System.Windows.DependencyProperty" Usage="System.Windows.Media.Animation.Storyboard.TargetPropertyProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifica la propiedad adjunta <see cref="P:System.Windows.Media.Animation.Storyboard.TargetProperty" />.</summary>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Windows.Media.Animation.Storyboard.TargetProperty" />
      </Docs>
    </Member>
  </Members>
</Type>