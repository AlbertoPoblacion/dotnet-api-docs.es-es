<Type Name="Storyboard" FullName="System.Windows.Media.Animation.Storyboard">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="40aaa35f3a1b40896d02850b6d8ad6be43644bf5" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="es-ES" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
    <Meta Name="ms.locfileid" Value="30661069" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class Storyboard : System.Windows.Media.Animation.ParallelTimeline" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi Storyboard extends System.Windows.Media.Animation.ParallelTimeline" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Media.Animation.Storyboard" />
  <TypeSignature Language="VB.NET" Value="Public Class Storyboard&#xA;Inherits ParallelTimeline" />
  <TypeSignature Language="C++ CLI" Value="public ref class Storyboard : System::Windows::Media::Animation::ParallelTimeline" />
  <AssemblyInfo>
    <AssemblyName>PresentationFramework</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Windows.Media.Animation.ParallelTimeline</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Escala de tiempo contenedora que proporciona la  información de destino de la propiedad y el objeto para sus animaciones secundarias.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
## <a name="interactively-controlling-storyboards"></a>Controlar guiones gráficos de forma interactiva  
 Un guión gráfico controlable se puede pausar, reanudar, buscar, detener y se quitan. Para poder controlar en el marcado de un guión gráfico, especifique la <xref:System.Windows.Media.Animation.BeginStoryboard.Name%2A> propiedad de la <xref:System.Windows.Media.Animation.BeginStoryboard> el objeto que lo crea; para obtener un ejemplo, vea [Cómo: utilizar desencadenadores de eventos para controlar un guión gráfico después de que se inicia](~/docs/framework/wpf/graphics-multimedia/how-to-use-event-triggers-to-control-a-storyboard-after-it-starts.md). Para realizar un guión gráfico controlable en el código, debe utilizar la sobrecarga adecuada del guión gráfico <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> método y especifique `true` para que sea controlable. Para obtener un ejemplo, vea [Cómo: controlar un guión gráfico después de que se inicia](~/docs/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts.md).  
  
## <a name="data-binding-and-animating-timelines"></a>Enlace de datos y animar escalas de tiempo  
 La mayoría de las propiedades de escala de tiempo puede ser enlazadas a datos o animar; Sin embargo, debido al modo en que funciona el sistema de temporización, las escalas de tiempo enlazados o animados no se comportan como otros datos de datos había enlazado o animar objetos. Para entender su comportamiento, es útil para comprender lo que significa para activar una escala de tiempo.  
  
 Cuando se activa una escala de tiempo, se realizan copias de la escala de tiempo y sus escalas de tiempo secundarias. Estas copias se inmovilizan (establecer como de solo lectura) y <xref:System.Windows.Media.Animation.Clock> objetos se crean a partir de ellos. Estos relojes son los que realmente se encargan de animar las propiedades de destino. Si una escala de tiempo está enlazado a datos o animadas, se realiza una instantánea de sus valores actuales cuando se crea su reloj. Aunque la escala de tiempo original puede seguir cambiando, su reloj no.  
  
 Para que una escala de tiempo reflejar los cambios de animación o enlace de datos, debe volver a crearse su reloj. Los relojes no se recrean automáticamente automáticamente. A continuación se muestran distintas maneras de aplicar cambios a las escalas de tiempo:  
  
-   Si la escala de tiempo es o pertenece a un <xref:System.Windows.Media.Animation.Storyboard>, puede hacer que reflejar los cambios puede volver a aplicar su guión gráfico utilizando una <xref:System.Windows.Media.Animation.BeginStoryboard> o <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> método. El efecto secundario de esta acción es que también se reinicia la animación. En el código, puede utilizar el <xref:System.Windows.Media.Animation.Storyboard.Seek%2A> volver del método para avanzar el guión gráfico en su posición anterior.  
  
-   Si aplica una animación directamente a una propiedad mediante el <xref:System.Windows.Media.Animation.Animatable.BeginAnimation%2A> método, llame a la <xref:System.Windows.Media.Animation.Animatable.BeginAnimation%2A> nuevo al método y pásele la animación que se ha modificado.  
  
-   Si está trabajando directamente en el nivel de reloj, crear y aplicar un nuevo conjunto de relojes y úselos para reemplazar el conjunto anterior de relojes creados.  
  
 Para un ejemplo de los datos enlazados animación, consulte [Key Spline Animation Sample](http://go.microsoft.com/fwlink/?LinkID=160011) .  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Storyboard ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Storyboard();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Windows.Media.Animation.Storyboard" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Begin">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inicia el conjunto de animaciones asociado a este objeto <see cref="T:System.Windows.Media.Animation.Storyboard" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un guión gráfico controlable se puede pausar, reanudar, buscar, detener y se quitan. Para realizar un guión gráfico controlable en el código, debe utilizar la sobrecarga adecuada del guión gráfico <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> método y especifique `true` para que sea controlable. Para obtener un ejemplo, vea [Cómo: controlar un guión gráfico después de que se inicia](~/docs/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Begin">
      <MemberSignature Language="C#" Value="public void Begin ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Begin() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.Begin" />
      <MemberSignature Language="VB.NET" Value="Public Sub Begin ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Begin();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Aplica las animaciones asociadas con este <see cref="T:System.Windows.Media.Animation.Storyboard" /> a sus destinos y las inicia.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Begin">
      <MemberSignature Language="C#" Value="public void Begin (System.Windows.FrameworkContentElement containingObject);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Begin(class System.Windows.FrameworkContentElement containingObject) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.Begin(System.Windows.FrameworkContentElement)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Begin (containingObject As FrameworkContentElement)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Begin(System::Windows::FrameworkContentElement ^ containingObject);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="containingObject" Type="System.Windows.FrameworkContentElement" />
      </Parameters>
      <Docs>
        <param name="containingObject">Objeto incluido dentro del mismo ámbito de nombres que los destinos de las animaciones de este guión gráfico. Las animaciones que no disponen de <see cref="P:System.Windows.Media.Animation.Storyboard.TargetName" /> se aplican a <c>containingObject</c>.</param>
        <summary>Aplica las animaciones asociadas con este <see cref="T:System.Windows.Media.Animation.Storyboard" /> a sus destinos y las inicia.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si las propiedades de destino ya están animadas, se reemplazan con la <xref:System.Windows.Media.Animation.HandoffBehavior.SnapshotAndReplace> comportamiento de entrega.  
  
 Los guiones gráficos iniciados con este método no se se en pausa, reanudar o en caso contrario, controlar de forma interactiva después de haberse iniciado. Para poder controlar un guión gráfico, use la <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> o <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> método.  
  
 Activa un guión gráfico a partir del <xref:System.Windows.Media.Animation.Timeline.CurrentStateInvalidated> y <xref:System.Windows.Media.Animation.Timeline.CurrentGlobalSpeedInvalidated> eventos.  
  
   
  
## Examples  
 En el ejemplo siguiente se utiliza un guión gráfico para animar un <xref:System.Windows.Media.TextEffect>. El <xref:System.Windows.Media.TextEffect> está dentro de un <xref:System.Windows.FrameworkContentElement>del nombre de ámbito.  
  
 [!code-csharp[StoryboardBeginAnimation_procedural_snip#FrameworkContentElementStoryboardExampleUsingWholePage](~/samples/snippets/csharp/VS_Snippets_Wpf/StoryboardBeginAnimation_procedural_snip/CSharp/FrameworkContentElementStoryboardExample.cs#frameworkcontentelementstoryboardexampleusingwholepage)]
 [!code-vb[StoryboardBeginAnimation_procedural_snip#FrameworkContentElementStoryboardExampleUsingWholePage](~/samples/snippets/visualbasic/VS_Snippets_Wpf/StoryboardBeginAnimation_procedural_snip/visualbasic/frameworkcontentelementstoryboardexample.vb#frameworkcontentelementstoryboardexampleusingwholepage)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Begin">
      <MemberSignature Language="C#" Value="public void Begin (System.Windows.FrameworkElement containingObject);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Begin(class System.Windows.FrameworkElement containingObject) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.Begin(System.Windows.FrameworkElement)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Begin (containingObject As FrameworkElement)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Begin(System::Windows::FrameworkElement ^ containingObject);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="containingObject" Type="System.Windows.FrameworkElement" />
      </Parameters>
      <Docs>
        <param name="containingObject">Objeto incluido dentro del mismo ámbito de nombres que los destinos de las animaciones de este guión gráfico. Las animaciones que no disponen de <see cref="P:System.Windows.Media.Animation.Storyboard.TargetName" /> se aplican a <c>containingObject</c>.</param>
        <summary>Aplica las animaciones asociadas con este <see cref="T:System.Windows.Media.Animation.Storyboard" /> a sus destinos y las inicia.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si las propiedades de destino ya están animadas, se reemplazan con la <xref:System.Windows.Media.Animation.HandoffBehavior.SnapshotAndReplace> comportamiento de entrega.  
  
 Los guiones gráficos iniciados con este método no se se en pausa, reanudar o en caso contrario, controlar de forma interactiva después de haberse iniciado. Para poder controlar un guión gráfico, use la <xref:System.Windows.Media.Animation.Storyboard.Begin%28System.Windows.FrameworkElement%2CSystem.Boolean%29> o <xref:System.Windows.Media.Animation.Storyboard.Begin%28System.Windows.FrameworkElement%2CSystem.Windows.Media.Animation.HandoffBehavior%2CSystem.Boolean%29> método.  
  
 Activa un guión gráfico a partir del <xref:System.Windows.Media.Animation.Timeline.CurrentStateInvalidated> y <xref:System.Windows.Media.Animation.Timeline.CurrentGlobalSpeedInvalidated> eventos.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Begin">
      <MemberSignature Language="C#" Value="public void Begin (System.Windows.FrameworkContentElement containingObject, bool isControllable);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Begin(class System.Windows.FrameworkContentElement containingObject, bool isControllable) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.Begin(System.Windows.FrameworkContentElement,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Begin (containingObject As FrameworkContentElement, isControllable As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Begin(System::Windows::FrameworkContentElement ^ containingObject, bool isControllable);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="containingObject" Type="System.Windows.FrameworkContentElement" />
        <Parameter Name="isControllable" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="containingObject">Objeto incluido dentro del mismo ámbito de nombres que los destinos de las animaciones de este guión gráfico. Las animaciones que no disponen de <see cref="P:System.Windows.Media.Animation.Storyboard.TargetName" /> se aplican a <c>containingObject</c>.</param>
        <param name="isControllable">
          <see langword="true" /> si el guión gráfico debe controlarse de forma interactiva; de lo contrario, <see langword="false" />.</param>
        <summary>Aplica las animaciones asociadas con este <see cref="T:System.Windows.Media.Animation.Storyboard" /> a sus destinos y las inicia.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si las propiedades de destino ya están animadas, se reemplazan con la <xref:System.Windows.Media.Animation.HandoffBehavior.SnapshotAndReplace> comportamiento de entrega.  
  
 Para controlar este guión gráfico de forma interactiva, debe especificar los mismos `containingObject` al llamar a los métodos interactivos que usó para iniciar el guión gráfico.  
  
 Cuando se llama a este método, <xref:System.Windows.Media.Animation.Clock> se crean objetos para el guión gráfico y las escalas de tiempo contiene. Estos relojes se almacenan con `containingObject`.  
  
 Activa un guión gráfico a partir del <xref:System.Windows.Media.Animation.Timeline.CurrentStateInvalidated> y <xref:System.Windows.Media.Animation.Timeline.CurrentGlobalSpeedInvalidated> eventos.  
  
   
  
## Examples  
 En el ejemplo siguiente se utiliza un guión gráfico controlable para animar un <xref:System.Windows.Media.TextEffect>. El <xref:System.Windows.Media.TextEffect> está dentro de un <xref:System.Windows.FrameworkContentElement>del nombre de ámbito.  
  
 [!code-csharp[StoryboardBeginAnimation_procedural_snip#FrameworkContentElementControlStoryboardExampleUsingWholePage](~/samples/snippets/csharp/VS_Snippets_Wpf/StoryboardBeginAnimation_procedural_snip/CSharp/FrameworkContentElementControlStoryboardExample.cs#frameworkcontentelementcontrolstoryboardexampleusingwholepage)]
 [!code-vb[StoryboardBeginAnimation_procedural_snip#FrameworkContentElementControlStoryboardExampleUsingWholePage](~/samples/snippets/visualbasic/VS_Snippets_Wpf/StoryboardBeginAnimation_procedural_snip/visualbasic/frameworkcontentelementcontrolstoryboardexample.vb#frameworkcontentelementcontrolstoryboardexampleusingwholepage)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Begin">
      <MemberSignature Language="C#" Value="public void Begin (System.Windows.FrameworkContentElement containingObject, System.Windows.Media.Animation.HandoffBehavior handoffBehavior);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Begin(class System.Windows.FrameworkContentElement containingObject, valuetype System.Windows.Media.Animation.HandoffBehavior handoffBehavior) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.Begin(System.Windows.FrameworkContentElement,System.Windows.Media.Animation.HandoffBehavior)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Begin(System::Windows::FrameworkContentElement ^ containingObject, System::Windows::Media::Animation::HandoffBehavior handoffBehavior);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="containingObject" Type="System.Windows.FrameworkContentElement" />
        <Parameter Name="handoffBehavior" Type="System.Windows.Media.Animation.HandoffBehavior" />
      </Parameters>
      <Docs>
        <param name="containingObject">Objeto incluido dentro del mismo ámbito de nombres que los destinos de las animaciones de este guión gráfico. Las animaciones que no disponen de <see cref="P:System.Windows.Media.Animation.Storyboard.TargetName" /> se aplican a <c>containingObject</c>.</param>
        <param name="handoffBehavior">Comportamiento que la nueva animación debe utilizar para interactuar con las animaciones actuales.</param>
        <summary>Aplica las animaciones asociadas con este objeto <see cref="T:System.Windows.Media.Animation.Storyboard" /> a sus destinos y las inicia utilizando la enumeración <see cref="T:System.Windows.Media.Animation.HandoffBehavior" /> especificada.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Al aplicar un <xref:System.Windows.Media.Animation.Storyboard>, <xref:System.Windows.Media.Animation.AnimationTimeline>, o <xref:System.Windows.Media.Animation.AnimationClock> a una propiedad mediante el <xref:System.Windows.Media.Animation.HandoffBehavior.Compose> <xref:System.Windows.Media.Animation.HandoffBehavior>, cualquier <xref:System.Windows.Media.Animation.Clock> objetos asociados anteriormente a esa propiedad siguen consumiendo recursos del sistema; el sistema de temporización no quita estos relojes automáticamente.  
  
 Para evitar problemas de rendimiento cuando se aplica un gran número de relojes con <xref:System.Windows.Media.Animation.HandoffBehavior.Compose>, debe quitar los relojes de composición de la propiedad animada cuando se hayan completado. Hay varias formas de quitar un reloj.  
  
-   Para quitar todos los relojes de una propiedad, utilice la <xref:System.Windows.Media.Animation.Animatable.ApplyAnimationClock%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationClock%29> o <xref:System.Windows.Media.Animation.Animatable.BeginAnimation%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationTimeline%29> método del objeto animado. Especifique la propiedad que se está animada como el primer parámetro, y `null` como el segundo. Esto quita todos los relojes de animación de la propiedad.  
  
-   Para quitar un determinado <xref:System.Windows.Media.Animation.AnimationClock> en una lista de relojes, use la <xref:System.Windows.Media.Animation.Clock.Controller%2A> propiedad de la <xref:System.Windows.Media.Animation.AnimationClock> para recuperar un <xref:System.Windows.Media.Animation.ClockController>, a continuación, llame a la <xref:System.Windows.Media.Animation.ClockController.Remove%2A> método de la <xref:System.Windows.Media.Animation.ClockController>. Esto se hace normalmente en el <xref:System.Windows.Media.Animation.Clock.Completed> controlador de eventos para un reloj. Tenga en cuenta que los relojes de raíz única pueden controlarse mediante una <xref:System.Windows.Media.Animation.ClockController>; el <xref:System.Windows.Media.Animation.Clock.Controller%2A> propiedad de un reloj secundario devuelve `null`. Tenga en cuenta también que la <xref:System.Windows.Media.Animation.Clock.Completed> eventos no se llama si la duración efectiva del reloj es para siempre.  En ese caso, el usuario debe determinar cuándo se debe llamar a <xref:System.Windows.Media.Animation.ClockController.Remove%2A>.  
  
 Este problema se produce principalmente en las animaciones de objetos que tienen un período de duración prolongado.  Si un objeto se han recopilado, sus relojes también se desconectan y el recolector.  
  
 Para obtener más información acerca de los objetos de reloj, consulte [animación y temporización información general del sistema](~/docs/framework/wpf/graphics-multimedia/animation-and-timing-system-overview.md).  
  
   
  
## Examples  
 En el ejemplo siguiente se usa el <xref:System.Windows.Media.Animation.HandoffBehavior.SnapshotAndReplace> <xref:System.Windows.Media.Animation.HandoffBehavior> para animar cuando el usuario hace clic y el <xref:System.Windows.Media.Animation.HandoffBehavior.Compose> <xref:System.Windows.Media.Animation.HandoffBehavior> cuando el usuario seleccione.  
  
 [!code-csharp[StoryboardBeginAnimation_procedural_snip#FrameworkContentElementStoryboardWithHandoffBehaviorExampleWholePage](~/samples/snippets/csharp/VS_Snippets_Wpf/StoryboardBeginAnimation_procedural_snip/CSharp/FrameworkContentElementStoryboardWithHandoffBehaviorExample.cs#frameworkcontentelementstoryboardwithhandoffbehaviorexamplewholepage)]
 [!code-vb[StoryboardBeginAnimation_procedural_snip#FrameworkContentElementStoryboardWithHandoffBehaviorExampleWholePage](~/samples/snippets/visualbasic/VS_Snippets_Wpf/StoryboardBeginAnimation_procedural_snip/visualbasic/frameworkcontentelementstoryboardwithhandoffbehaviorexample.vb#frameworkcontentelementstoryboardwithhandoffbehaviorexamplewholepage)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Begin">
      <MemberSignature Language="C#" Value="public void Begin (System.Windows.FrameworkElement containingObject, bool isControllable);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Begin(class System.Windows.FrameworkElement containingObject, bool isControllable) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.Begin(System.Windows.FrameworkElement,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Begin (containingObject As FrameworkElement, isControllable As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Begin(System::Windows::FrameworkElement ^ containingObject, bool isControllable);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="containingObject" Type="System.Windows.FrameworkElement" />
        <Parameter Name="isControllable" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="containingObject">Objeto incluido dentro del mismo ámbito de nombres que los destinos de las animaciones de este guión gráfico. Las animaciones que no disponen de <see cref="P:System.Windows.Media.Animation.Storyboard.TargetName" /> se aplican a <c>containingObject</c>.</param>
        <param name="isControllable">
          <see langword="true" /> si el guión gráfico debe controlarse de forma interactiva; de lo contrario, <see langword="false" />.</param>
        <summary>Aplica las animaciones asociadas con este <see cref="T:System.Windows.Media.Animation.Storyboard" /> a sus destinos y las inicia.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si las propiedades de destino ya están animadas, se reemplazan con la <xref:System.Windows.Media.Animation.HandoffBehavior.SnapshotAndReplace> comportamiento de entrega.  
  
 Para controlar este guión gráfico de forma interactiva, debe usar el mismo `containingObject` parámetro al llamar a los métodos interactivos que usó para iniciar el guión gráfico.  
  
 Cuando se llama a este método, <xref:System.Windows.Media.Animation.Clock> se crean objetos para el guión gráfico y las escalas de tiempo contiene. Estos relojes se almacenan con `containingObject`.  
  
 Activa un guión gráfico a partir del <xref:System.Windows.Media.Animation.Timeline.CurrentStateInvalidated> y <xref:System.Windows.Media.Animation.Timeline.CurrentGlobalSpeedInvalidated> eventos.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Begin">
      <MemberSignature Language="C#" Value="public void Begin (System.Windows.FrameworkElement containingObject, System.Windows.FrameworkTemplate frameworkTemplate);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Begin(class System.Windows.FrameworkElement containingObject, class System.Windows.FrameworkTemplate frameworkTemplate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.Begin(System.Windows.FrameworkElement,System.Windows.FrameworkTemplate)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Begin(System::Windows::FrameworkElement ^ containingObject, System::Windows::FrameworkTemplate ^ frameworkTemplate);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="containingObject" Type="System.Windows.FrameworkElement" />
        <Parameter Name="frameworkTemplate" Type="System.Windows.FrameworkTemplate" />
      </Parameters>
      <Docs>
        <param name="containingObject">Objeto al que se ha aplicado el parámetro <c>frameworkTemplate</c> especificado. Las animaciones que no disponen de <see cref="P:System.Windows.Media.Animation.Storyboard.TargetName" /> se aplican a <c>containingObject</c>.</param>
        <param name="frameworkTemplate">Plantilla que se va a animar.</param>
        <summary>Aplica las animaciones asociadas con este objeto <see cref="T:System.Windows.Media.Animation.Storyboard" /> a sus destinos en la plantilla especificada y las inicia.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si las propiedades de destino ya están animadas, se reemplazan con la <xref:System.Windows.Media.Animation.HandoffBehavior.SnapshotAndReplace> comportamiento de entrega.  
  
 Cuando se llama a este método, <xref:System.Windows.Media.Animation.Clock> se crean objetos para el guión gráfico y las escalas de tiempo contiene. Estos relojes se almacenan con `containingObject`.  
  
 Activa un guión gráfico a partir del <xref:System.Windows.Media.Animation.Timeline.CurrentStateInvalidated> y <xref:System.Windows.Media.Animation.Timeline.CurrentGlobalSpeedInvalidated> eventos.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Begin">
      <MemberSignature Language="C#" Value="public void Begin (System.Windows.FrameworkElement containingObject, System.Windows.Media.Animation.HandoffBehavior handoffBehavior);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Begin(class System.Windows.FrameworkElement containingObject, valuetype System.Windows.Media.Animation.HandoffBehavior handoffBehavior) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.Begin(System.Windows.FrameworkElement,System.Windows.Media.Animation.HandoffBehavior)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Begin(System::Windows::FrameworkElement ^ containingObject, System::Windows::Media::Animation::HandoffBehavior handoffBehavior);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="containingObject" Type="System.Windows.FrameworkElement" />
        <Parameter Name="handoffBehavior" Type="System.Windows.Media.Animation.HandoffBehavior" />
      </Parameters>
      <Docs>
        <param name="containingObject">Objeto incluido dentro del mismo ámbito de nombres que los destinos de las animaciones de este guión gráfico. Las animaciones en las que no se ha especificado <see cref="P:System.Windows.Media.Animation.Storyboard.TargetName" /> se aplican a <c>containingObject</c>.</param>
        <param name="handoffBehavior">Comportamiento que la nueva animación debe utilizar para interactuar con las animaciones actuales.</param>
        <summary>Aplica las animaciones asociadas con este objeto <see cref="T:System.Windows.Media.Animation.Storyboard" /> a sus destinos y las inicia utilizando la enumeración <see cref="T:System.Windows.Media.Animation.HandoffBehavior" /> especificada.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 En el ejemplo siguiente se usa el <xref:System.Windows.Media.Animation.HandoffBehavior.SnapshotAndReplace> <xref:System.Windows.Media.Animation.HandoffBehavior> para animar cuando el usuario hace clic y el <xref:System.Windows.Media.Animation.HandoffBehavior.Compose> <xref:System.Windows.Media.Animation.HandoffBehavior> cuando el usuario seleccione.  
  
 [!code-csharp[StoryboardBeginAnimation_procedural_snip#GraphicsMMFrameworkElementStoryboardHandoffBehaviorExample](~/samples/snippets/csharp/VS_Snippets_Wpf/StoryboardBeginAnimation_procedural_snip/CSharp/FrameworkElementStoryboardHandoffBehaviorExample.cs#graphicsmmframeworkelementstoryboardhandoffbehaviorexample)]
 [!code-vb[StoryboardBeginAnimation_procedural_snip#GraphicsMMFrameworkElementStoryboardHandoffBehaviorExample](~/samples/snippets/visualbasic/VS_Snippets_Wpf/StoryboardBeginAnimation_procedural_snip/visualbasic/frameworkelementstoryboardhandoffbehaviorexample.vb#graphicsmmframeworkelementstoryboardhandoffbehaviorexample)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Begin">
      <MemberSignature Language="C#" Value="public void Begin (System.Windows.FrameworkContentElement containingObject, System.Windows.Media.Animation.HandoffBehavior handoffBehavior, bool isControllable);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Begin(class System.Windows.FrameworkContentElement containingObject, valuetype System.Windows.Media.Animation.HandoffBehavior handoffBehavior, bool isControllable) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.Begin(System.Windows.FrameworkContentElement,System.Windows.Media.Animation.HandoffBehavior,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Begin(System::Windows::FrameworkContentElement ^ containingObject, System::Windows::Media::Animation::HandoffBehavior handoffBehavior, bool isControllable);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="containingObject" Type="System.Windows.FrameworkContentElement" />
        <Parameter Name="handoffBehavior" Type="System.Windows.Media.Animation.HandoffBehavior" />
        <Parameter Name="isControllable" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="containingObject">Objeto incluido dentro del mismo ámbito de nombres que los destinos de las animaciones de este guión gráfico. Las animaciones en las que no se ha especificado <see cref="P:System.Windows.Media.Animation.Storyboard.TargetName" /> se aplican a <c>containingObject</c>.</param>
        <param name="handoffBehavior">Comportamiento que la nueva animación debe utilizar para interactuar con las animaciones actuales.</param>
        <param name="isControllable">Declara si la animación se puede controlar (se puede pausar) una vez que se ha iniciado.</param>
        <summary>Aplica las animaciones asociadas con este objeto <see cref="T:System.Windows.Media.Animation.Storyboard" /> a sus destinos y las inicia utilizando la enumeración <see cref="T:System.Windows.Media.Animation.HandoffBehavior" /> especificada.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si las propiedades de destino ya están animadas, se reemplazan con el comportamiento de entrega especificado.  
  
 Para controlar este guión gráfico de forma interactiva, debe especificar los mismos `containingObject` al llamar a los métodos interactivos que usó para iniciar el guión gráfico.  
  
 Cuando se llama a este método, <xref:System.Windows.Media.Animation.Clock> se crean objetos para el guión gráfico y las escalas de tiempo contiene. Estos relojes se almacenan con `containingObject`.  
  
 Activa un guión gráfico a partir del <xref:System.Windows.Media.Animation.Timeline.CurrentStateInvalidated> y <xref:System.Windows.Media.Animation.Timeline.CurrentGlobalSpeedInvalidated> eventos.  
  
## <a name="using-the-compose-handoffbehavior"></a>Mediante el campo Compose de HandoffBehavior  
 Al aplicar un <xref:System.Windows.Media.Animation.Storyboard>, <xref:System.Windows.Media.Animation.AnimationTimeline>, o <xref:System.Windows.Media.Animation.AnimationClock> a una propiedad mediante el <xref:System.Windows.Media.Animation.HandoffBehavior.Compose> <xref:System.Windows.Media.Animation.HandoffBehavior>, cualquier <xref:System.Windows.Media.Animation.Clock> objetos asociados anteriormente a esa propiedad siguen consumiendo recursos del sistema; el sistema de temporización no quita estos relojes automáticamente.  
  
 Para evitar problemas de rendimiento cuando se aplica un gran número de relojes con <xref:System.Windows.Media.Animation.HandoffBehavior.Compose>, debe quitar los relojes de composición de la propiedad animada cuando se hayan completado. Hay varias formas de quitar un reloj.  
  
-   Para quitar todos los relojes de una propiedad, utilice la <xref:System.Windows.Media.Animation.Animatable.ApplyAnimationClock%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationClock%29> o <xref:System.Windows.Media.Animation.Animatable.BeginAnimation%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationTimeline%29> método del objeto animado. Especifique la propiedad que se está animada como el primer parámetro, y `null` como el segundo. Esto quita todos los relojes de animación de la propiedad.  
  
-   Para quitar un determinado <xref:System.Windows.Media.Animation.AnimationClock> en una lista de relojes, use la <xref:System.Windows.Media.Animation.Clock.Controller%2A> propiedad de la <xref:System.Windows.Media.Animation.AnimationClock> para recuperar un <xref:System.Windows.Media.Animation.ClockController>, a continuación, llame a la <xref:System.Windows.Media.Animation.ClockController.Remove%2A> método de la <xref:System.Windows.Media.Animation.ClockController>. Esto se hace normalmente en el <xref:System.Windows.Media.Animation.Clock.Completed> controlador de eventos para un reloj. Tenga en cuenta que los relojes de raíz única pueden controlarse mediante una <xref:System.Windows.Media.Animation.ClockController>; el <xref:System.Windows.Media.Animation.Clock.Controller%2A> propiedad de un reloj secundario devuelve `null`. Tenga en cuenta también que la <xref:System.Windows.Media.Animation.Clock.Completed> eventos no se llama si la duración efectiva del reloj es para siempre.  En ese caso, el usuario debe determinar cuándo se debe llamar a <xref:System.Windows.Media.Animation.ClockController.Remove%2A>.  
  
 Este problema se produce principalmente en las animaciones de objetos que tienen un período de duración prolongado.  Si un objeto se han recopilado, sus relojes también se desconectan y el recolector.  
  
 Para obtener más información acerca de los objetos de reloj, consulte [animación y temporización información general del sistema](~/docs/framework/wpf/graphics-multimedia/animation-and-timing-system-overview.md).  
  
   
  
## Examples  
 En el ejemplo siguiente se utiliza un guión gráfico controlable para animar un <xref:System.Windows.Media.TextEffect>. El <xref:System.Windows.Media.TextEffect> está dentro de un <xref:System.Windows.FrameworkContentElement>del nombre de ámbito.  
  
 [!code-csharp[StoryboardBeginAnimation_procedural_snip#FrameworkContentElementControlStoryboardExampleUsingWholePage](~/samples/snippets/csharp/VS_Snippets_Wpf/StoryboardBeginAnimation_procedural_snip/CSharp/FrameworkContentElementControlStoryboardExample.cs#frameworkcontentelementcontrolstoryboardexampleusingwholepage)]
 [!code-vb[StoryboardBeginAnimation_procedural_snip#FrameworkContentElementControlStoryboardExampleUsingWholePage](~/samples/snippets/visualbasic/VS_Snippets_Wpf/StoryboardBeginAnimation_procedural_snip/visualbasic/frameworkcontentelementcontrolstoryboardexample.vb#frameworkcontentelementcontrolstoryboardexampleusingwholepage)]  
  
 En el ejemplo siguiente se utiliza la <xref:System.Windows.Media.Animation.HandoffBehavior.SnapshotAndReplace> <xref:System.Windows.Media.Animation.HandoffBehavior> para animar cuando el usuario hace clic y el <xref:System.Windows.Media.Animation.HandoffBehavior.Compose> <xref:System.Windows.Media.Animation.HandoffBehavior> cuando el usuario seleccione.  
  
 [!code-csharp[StoryboardBeginAnimation_procedural_snip#FrameworkContentElementStoryboardWithHandoffBehaviorExampleWholePage](~/samples/snippets/csharp/VS_Snippets_Wpf/StoryboardBeginAnimation_procedural_snip/CSharp/FrameworkContentElementStoryboardWithHandoffBehaviorExample.cs#frameworkcontentelementstoryboardwithhandoffbehaviorexamplewholepage)]
 [!code-vb[StoryboardBeginAnimation_procedural_snip#FrameworkContentElementStoryboardWithHandoffBehaviorExampleWholePage](~/samples/snippets/visualbasic/VS_Snippets_Wpf/StoryboardBeginAnimation_procedural_snip/visualbasic/frameworkcontentelementstoryboardwithhandoffbehaviorexample.vb#frameworkcontentelementstoryboardwithhandoffbehaviorexamplewholepage)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Begin">
      <MemberSignature Language="C#" Value="public void Begin (System.Windows.FrameworkElement containingObject, System.Windows.FrameworkTemplate frameworkTemplate, bool isControllable);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Begin(class System.Windows.FrameworkElement containingObject, class System.Windows.FrameworkTemplate frameworkTemplate, bool isControllable) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.Begin(System.Windows.FrameworkElement,System.Windows.FrameworkTemplate,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Begin(System::Windows::FrameworkElement ^ containingObject, System::Windows::FrameworkTemplate ^ frameworkTemplate, bool isControllable);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="containingObject" Type="System.Windows.FrameworkElement" />
        <Parameter Name="frameworkTemplate" Type="System.Windows.FrameworkTemplate" />
        <Parameter Name="isControllable" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="containingObject">Objeto al que se ha aplicado el parámetro <c>frameworkTemplate</c> especificado.  Las animaciones que no disponen de <see cref="P:System.Windows.Media.Animation.Storyboard.TargetName" /> se aplican a <c>containingObject</c>.</param>
        <param name="frameworkTemplate">Plantilla que se va a animar.</param>
        <param name="isControllable">
          <see langword="true" /> si el guión gráfico debe controlarse de forma interactiva; de lo contrario, <see langword="false" />.</param>
        <summary>Aplica las animaciones asociadas con este objeto <see cref="T:System.Windows.Media.Animation.Storyboard" /> a sus destinos en la plantilla especificada y las inicia.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si las propiedades de destino ya están animadas, se reemplazan con la <xref:System.Windows.Media.Animation.HandoffBehavior.SnapshotAndReplace> comportamiento de entrega.  
  
 Para controlar este guión gráfico de forma interactiva, debe especificar los mismos `containingObject` al llamar a los métodos interactivos que usó para iniciar el guión gráfico.  
  
 Cuando se llama a este método, <xref:System.Windows.Media.Animation.Clock> se crean objetos para el guión gráfico y las escalas de tiempo contiene. Estos relojes se almacenan con `containingObject`.  
  
 Activa un guión gráfico a partir del <xref:System.Windows.Media.Animation.Timeline.CurrentStateInvalidated> y <xref:System.Windows.Media.Animation.Timeline.CurrentGlobalSpeedInvalidated> eventos.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Begin">
      <MemberSignature Language="C#" Value="public void Begin (System.Windows.FrameworkElement containingObject, System.Windows.FrameworkTemplate frameworkTemplate, System.Windows.Media.Animation.HandoffBehavior handoffBehavior);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Begin(class System.Windows.FrameworkElement containingObject, class System.Windows.FrameworkTemplate frameworkTemplate, valuetype System.Windows.Media.Animation.HandoffBehavior handoffBehavior) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.Begin(System.Windows.FrameworkElement,System.Windows.FrameworkTemplate,System.Windows.Media.Animation.HandoffBehavior)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Begin(System::Windows::FrameworkElement ^ containingObject, System::Windows::FrameworkTemplate ^ frameworkTemplate, System::Windows::Media::Animation::HandoffBehavior handoffBehavior);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="containingObject" Type="System.Windows.FrameworkElement" />
        <Parameter Name="frameworkTemplate" Type="System.Windows.FrameworkTemplate" />
        <Parameter Name="handoffBehavior" Type="System.Windows.Media.Animation.HandoffBehavior" />
      </Parameters>
      <Docs>
        <param name="containingObject">Objeto al que se ha aplicado el parámetro <c>frameworkTemplate</c> especificado. Las animaciones que no disponen de <see cref="P:System.Windows.Media.Animation.Storyboard.TargetName" /> se aplican a <c>containingObject</c>.</param>
        <param name="frameworkTemplate">Plantilla que se va a animar.</param>
        <param name="handoffBehavior">Comportamiento que la nueva animación debe utilizar para interactuar con las animaciones actuales.</param>
        <summary>Aplica las animaciones asociadas con este objeto <see cref="T:System.Windows.Media.Animation.Storyboard" /> a sus destinos en la plantilla especificada y las inicia.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cuando se llama a este método, <xref:System.Windows.Media.Animation.Clock> se crean objetos para el guión gráfico y las escalas de tiempo contiene. Estos relojes se almacenan con `containingObject`.  
  
 Activa un guión gráfico a partir del <xref:System.Windows.Media.Animation.Timeline.CurrentStateInvalidated> y <xref:System.Windows.Media.Animation.Timeline.CurrentGlobalSpeedInvalidated> eventos.  
  
## <a name="using-the-compose-handoffbehavior"></a>Mediante el campo Compose de HandoffBehavior  
 Al aplicar un <xref:System.Windows.Media.Animation.Storyboard>, <xref:System.Windows.Media.Animation.AnimationTimeline>, o <xref:System.Windows.Media.Animation.AnimationClock> a una propiedad mediante el <xref:System.Windows.Media.Animation.HandoffBehavior.Compose> <xref:System.Windows.Media.Animation.HandoffBehavior>, cualquier <xref:System.Windows.Media.Animation.Clock> objetos asociados anteriormente a esa propiedad siguen consumiendo recursos del sistema; el sistema de temporización no quita estos relojes automáticamente.  
  
 Para evitar problemas de rendimiento cuando se aplica un gran número de relojes con <xref:System.Windows.Media.Animation.HandoffBehavior.Compose>, debe quitar los relojes de composición de la propiedad animada cuando se hayan completado. Hay varias formas de quitar un reloj.  
  
-   Para quitar todos los relojes de una propiedad, utilice la <xref:System.Windows.Media.Animation.Animatable.ApplyAnimationClock%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationClock%29> o <xref:System.Windows.Media.Animation.Animatable.BeginAnimation%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationTimeline%29> método del objeto animado. Especifique la propiedad que se está animada como el primer parámetro, y `null` como el segundo. Esto quita todos los relojes de animación de la propiedad.  
  
-   Para quitar un determinado <xref:System.Windows.Media.Animation.AnimationClock> en una lista de relojes, use la <xref:System.Windows.Media.Animation.Clock.Controller%2A> propiedad de la <xref:System.Windows.Media.Animation.AnimationClock> para recuperar un <xref:System.Windows.Media.Animation.ClockController>, a continuación, llame a la <xref:System.Windows.Media.Animation.ClockController.Remove%2A> método de la <xref:System.Windows.Media.Animation.ClockController>. Esto se hace normalmente en el <xref:System.Windows.Media.Animation.Clock.Completed> controlador de eventos para un reloj. Tenga en cuenta que los relojes de raíz única pueden controlarse mediante una <xref:System.Windows.Media.Animation.ClockController>; el <xref:System.Windows.Media.Animation.Clock.Controller%2A> propiedad de un reloj secundario devuelve `null`. Tenga en cuenta también que la <xref:System.Windows.Media.Animation.Clock.Completed> eventos no se llama si la duración efectiva del reloj es para siempre.  En ese caso, el usuario debe determinar cuándo se debe llamar a <xref:System.Windows.Media.Animation.ClockController.Remove%2A>.  
  
 Este problema se produce principalmente en las animaciones de objetos que tienen un período de duración prolongado.  Si un objeto se han recopilado, sus relojes también se desconectan y el recolector.  
  
 Para obtener más información acerca de los objetos de reloj, consulte [animación y temporización información general del sistema](~/docs/framework/wpf/graphics-multimedia/animation-and-timing-system-overview.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Begin">
      <MemberSignature Language="C#" Value="public void Begin (System.Windows.FrameworkElement containingObject, System.Windows.Media.Animation.HandoffBehavior handoffBehavior, bool isControllable);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Begin(class System.Windows.FrameworkElement containingObject, valuetype System.Windows.Media.Animation.HandoffBehavior handoffBehavior, bool isControllable) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.Begin(System.Windows.FrameworkElement,System.Windows.Media.Animation.HandoffBehavior,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Begin(System::Windows::FrameworkElement ^ containingObject, System::Windows::Media::Animation::HandoffBehavior handoffBehavior, bool isControllable);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="containingObject" Type="System.Windows.FrameworkElement" />
        <Parameter Name="handoffBehavior" Type="System.Windows.Media.Animation.HandoffBehavior" />
        <Parameter Name="isControllable" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="containingObject">Objeto incluido dentro del mismo ámbito de nombres que los destinos de las animaciones de este guión gráfico. Las animaciones en las que no se ha especificado <see cref="P:System.Windows.Media.Animation.Storyboard.TargetName" /> se aplican a <c>containingObject</c>.</param>
        <param name="handoffBehavior">Comportamiento que la nueva animación debe utilizar para interactuar con las animaciones actuales.</param>
        <param name="isControllable">Declara si la animación se puede controlar (se puede pausar) una vez que se ha iniciado.</param>
        <summary>Aplica las animaciones asociadas con este <see cref="T:System.Windows.Media.Animation.Storyboard" /> a sus destinos y las inicia.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para controlar este guión gráfico de forma interactiva, debe usar el mismo `containingObject` parámetro al llamar a los métodos interactivos que usó para iniciar el guión gráfico.  
  
 Cuando se llama a este método, <xref:System.Windows.Media.Animation.Clock> se crean objetos para el guión gráfico y las escalas de tiempo contiene. Estos relojes se almacenan con `containingObject`.  
  
 Activa un guión gráfico a partir del <xref:System.Windows.Media.Animation.Timeline.CurrentStateInvalidated> y <xref:System.Windows.Media.Animation.Timeline.CurrentGlobalSpeedInvalidated> eventos.  
  
## <a name="using-the-compose-handoffbehavior"></a>Mediante el campo Compose de HandoffBehavior  
 Al aplicar un <xref:System.Windows.Media.Animation.Storyboard>, <xref:System.Windows.Media.Animation.AnimationTimeline>, o <xref:System.Windows.Media.Animation.AnimationClock> a una propiedad mediante el <xref:System.Windows.Media.Animation.HandoffBehavior.Compose> <xref:System.Windows.Media.Animation.HandoffBehavior>, cualquier <xref:System.Windows.Media.Animation.Clock> objetos asociados anteriormente a esa propiedad siguen consumiendo recursos del sistema; el sistema de temporización no quita estos relojes automáticamente.  
  
 Para evitar problemas de rendimiento cuando se aplica un gran número de relojes con <xref:System.Windows.Media.Animation.HandoffBehavior.Compose>, debe quitar los relojes de composición de la propiedad animada cuando se hayan completado. Hay varias formas de quitar un reloj.  
  
-   Para quitar todos los relojes de una propiedad, utilice la <xref:System.Windows.Media.Animation.Animatable.ApplyAnimationClock%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationClock%29> o <xref:System.Windows.Media.Animation.Animatable.BeginAnimation%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationTimeline%29> método del objeto animado. Especifique la propiedad que se está animada como el primer parámetro, y `null` como el segundo. Esto quita todos los relojes de animación de la propiedad.  
  
-   Para quitar un determinado <xref:System.Windows.Media.Animation.AnimationClock> en una lista de relojes, use la <xref:System.Windows.Media.Animation.Clock.Controller%2A> propiedad de la <xref:System.Windows.Media.Animation.AnimationClock> para recuperar un <xref:System.Windows.Media.Animation.ClockController>, a continuación, llame a la <xref:System.Windows.Media.Animation.ClockController.Remove%2A> método de la <xref:System.Windows.Media.Animation.ClockController>. Esto se hace normalmente en el <xref:System.Windows.Media.Animation.Clock.Completed> controlador de eventos para un reloj. Tenga en cuenta que los relojes de raíz única pueden controlarse mediante una <xref:System.Windows.Media.Animation.ClockController>; el <xref:System.Windows.Media.Animation.Clock.Controller%2A> propiedad de un reloj secundario devuelve `null`. Tenga en cuenta también que la <xref:System.Windows.Media.Animation.Clock.Completed> eventos no se llama si la duración efectiva del reloj es para siempre.  En ese caso, el usuario debe determinar cuándo se debe llamar a <xref:System.Windows.Media.Animation.ClockController.Remove%2A>.  
  
 Este problema se produce principalmente en las animaciones de objetos que tienen un período de duración prolongado.  Si un objeto se han recopilado, sus relojes también se desconectan y el recolector.  
  
 Para obtener más información acerca de los objetos de reloj, consulte [animación y temporización información general del sistema](~/docs/framework/wpf/graphics-multimedia/animation-and-timing-system-overview.md).  
  
   
  
## Examples  
 En el ejemplo siguiente se muestra cómo crear un guión gráfico controlable.  
  
 [!code-csharp[animation_ovws_procedural_snip#ControllableStoryboardExampleWholePage](~/samples/snippets/csharp/VS_Snippets_Wpf/animation_ovws_procedural_snip/CSharp/ControllableStoryboardExample.cs#controllablestoryboardexamplewholepage)]
 [!code-vb[animation_ovws_procedural_snip#ControllableStoryboardExampleWholePage](~/samples/snippets/visualbasic/VS_Snippets_Wpf/animation_ovws_procedural_snip/visualbasic/controllablestoryboardexample.vb#controllablestoryboardexamplewholepage)]  
  
 En el ejemplo siguiente se utiliza la <xref:System.Windows.Media.Animation.HandoffBehavior.SnapshotAndReplace> <xref:System.Windows.Media.Animation.HandoffBehavior> para animar cuando el usuario hace clic y el <xref:System.Windows.Media.Animation.HandoffBehavior.Compose> <xref:System.Windows.Media.Animation.HandoffBehavior> cuando el usuario seleccione.  
  
 [!code-csharp[StoryboardBeginAnimation_procedural_snip#GraphicsMMFrameworkElementStoryboardHandoffBehaviorExample](~/samples/snippets/csharp/VS_Snippets_Wpf/StoryboardBeginAnimation_procedural_snip/CSharp/FrameworkElementStoryboardHandoffBehaviorExample.cs#graphicsmmframeworkelementstoryboardhandoffbehaviorexample)]
 [!code-vb[StoryboardBeginAnimation_procedural_snip#GraphicsMMFrameworkElementStoryboardHandoffBehaviorExample](~/samples/snippets/visualbasic/VS_Snippets_Wpf/StoryboardBeginAnimation_procedural_snip/visualbasic/frameworkelementstoryboardhandoffbehaviorexample.vb#graphicsmmframeworkelementstoryboardhandoffbehaviorexample)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Begin">
      <MemberSignature Language="C#" Value="public void Begin (System.Windows.FrameworkElement containingObject, System.Windows.FrameworkTemplate frameworkTemplate, System.Windows.Media.Animation.HandoffBehavior handoffBehavior, bool isControllable);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Begin(class System.Windows.FrameworkElement containingObject, class System.Windows.FrameworkTemplate frameworkTemplate, valuetype System.Windows.Media.Animation.HandoffBehavior handoffBehavior, bool isControllable) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.Begin(System.Windows.FrameworkElement,System.Windows.FrameworkTemplate,System.Windows.Media.Animation.HandoffBehavior,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Begin(System::Windows::FrameworkElement ^ containingObject, System::Windows::FrameworkTemplate ^ frameworkTemplate, System::Windows::Media::Animation::HandoffBehavior handoffBehavior, bool isControllable);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="containingObject" Type="System.Windows.FrameworkElement" />
        <Parameter Name="frameworkTemplate" Type="System.Windows.FrameworkTemplate" />
        <Parameter Name="handoffBehavior" Type="System.Windows.Media.Animation.HandoffBehavior" />
        <Parameter Name="isControllable" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="containingObject">Objeto al que se ha aplicado el parámetro <c>frameworkTemplate</c> especificado. Las animaciones que no disponen de <see cref="P:System.Windows.Media.Animation.Storyboard.TargetName" /> se aplican a <c>containingObject</c>.</param>
        <param name="frameworkTemplate">Plantilla que se va a animar.</param>
        <param name="handoffBehavior">Comportamiento que la nueva animación debe utilizar para interactuar con las animaciones actuales.</param>
        <param name="isControllable">
          <see langword="true" /> si el guión gráfico debe controlarse de forma interactiva; de lo contrario, <see langword="false" />.</param>
        <summary>Aplica las animaciones asociadas con este objeto <see cref="T:System.Windows.Media.Animation.Storyboard" /> a sus destinos en la plantilla especificada y las inicia.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para controlar este guión gráfico de forma interactiva, debe especificar los mismos `containingObject` al llamar a los métodos interactivos que usó para iniciar el guión gráfico.  
  
 Cuando se llama a este método, <xref:System.Windows.Media.Animation.Clock> se crean objetos para el guión gráfico y las escalas de tiempo contiene. Estos relojes se almacenan con `containingObject`.  
  
 Activa un guión gráfico a partir del <xref:System.Windows.Media.Animation.Timeline.CurrentStateInvalidated> y <xref:System.Windows.Media.Animation.Timeline.CurrentGlobalSpeedInvalidated> eventos.  
  
## <a name="using-the-compose-handoffbehavior"></a>Mediante el campo Compose de HandoffBehavior  
 Al aplicar un <xref:System.Windows.Media.Animation.Storyboard>, <xref:System.Windows.Media.Animation.AnimationTimeline>, o <xref:System.Windows.Media.Animation.AnimationClock> a una propiedad mediante el <xref:System.Windows.Media.Animation.HandoffBehavior.Compose> <xref:System.Windows.Media.Animation.HandoffBehavior>, cualquier <xref:System.Windows.Media.Animation.Clock> objetos asociados anteriormente a esa propiedad siguen consumiendo recursos del sistema; el sistema de temporización no quita estos relojes automáticamente.  
  
 Para evitar problemas de rendimiento cuando se aplica un gran número de relojes con <xref:System.Windows.Media.Animation.HandoffBehavior.Compose>, debe quitar los relojes de composición de la propiedad animada cuando se hayan completado. Hay varias formas de quitar un reloj.  
  
-   Para quitar todos los relojes de una propiedad, utilice la <xref:System.Windows.Media.Animation.Animatable.ApplyAnimationClock%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationClock%29> o <xref:System.Windows.Media.Animation.Animatable.BeginAnimation%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationTimeline%29> método del objeto animado. Especifique la propiedad que se está animada como el primer parámetro, y `null` como el segundo. Esto quita todos los relojes de animación de la propiedad.  
  
-   Para quitar un determinado <xref:System.Windows.Media.Animation.AnimationClock> en una lista de relojes, use la <xref:System.Windows.Media.Animation.Clock.Controller%2A> propiedad de la <xref:System.Windows.Media.Animation.AnimationClock> para recuperar un <xref:System.Windows.Media.Animation.ClockController>, a continuación, llame a la <xref:System.Windows.Media.Animation.ClockController.Remove%2A> método de la <xref:System.Windows.Media.Animation.ClockController>. Esto se hace normalmente en el <xref:System.Windows.Media.Animation.Clock.Completed> controlador de eventos para un reloj. Tenga en cuenta que los relojes de raíz única pueden controlarse mediante una <xref:System.Windows.Media.Animation.ClockController>; el <xref:System.Windows.Media.Animation.Clock.Controller%2A> propiedad de un reloj secundario devuelve `null`. Tenga en cuenta también que la <xref:System.Windows.Media.Animation.Clock.Completed> eventos no se llama si la duración efectiva del reloj es para siempre.  En ese caso, el usuario debe determinar cuándo se debe llamar a <xref:System.Windows.Media.Animation.ClockController.Remove%2A>.  
  
 Este problema se produce principalmente en las animaciones de objetos que tienen un período de duración prolongado.  Si un objeto se han recopilado, sus relojes también se desconectan y el recolector.  
  
 Para obtener más información acerca de los objetos de reloj, consulte [animación y temporización información general del sistema](~/docs/framework/wpf/graphics-multimedia/animation-and-timing-system-overview.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Clone">
      <MemberSignature Language="C#" Value="public System.Windows.Media.Animation.Storyboard Clone ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Media.Animation.Storyboard Clone() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.Clone" />
      <MemberSignature Language="VB.NET" Value="Public Function Clone () As Storyboard" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Media::Animation::Storyboard ^ Clone();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Media.Animation.Storyboard</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Crea un clon modificable de este <see cref="T:System.Windows.Media.Animation.Storyboard" /> y hace copias en profundidad de los valores de este objeto. Cuando se copian propiedades de dependencia, este método copia las referencias de recursos y enlaces de datos (aunque podrían no resolverse), pero no copia las animaciones ni sus valores actuales.</summary>
        <returns>Clon modificable del objeto actual. La propiedad <see cref="P:System.Windows.Freezable.IsFrozen" /> del objeto clonado es <see langword="false" /> aunque la propiedad <see cref="P:System.Windows.Freezable.IsFrozen" /> del origen sea <see langword="true." /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método se usa para generar copias modificables de inmovilizado <xref:System.Windows.Freezable> objetos (o cualquier <xref:System.Windows.Freezable> objeto). Para mayor comodidad, este método prevalece sobre la versión heredada mediante una implementación fuertemente tipada.  
  
 Para obtener más información, vea <xref:System.Windows.Freezable.Clone%2A?displayProperty=nameWithType>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateInstanceCore">
      <MemberSignature Language="C#" Value="protected override System.Windows.Freezable CreateInstanceCore ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance class System.Windows.Freezable CreateInstanceCore() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.CreateInstanceCore" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function CreateInstanceCore () As Freezable" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override System::Windows::Freezable ^ CreateInstanceCore();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Freezable</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Crea una nueva instancia de la clase <see cref="T:System.Windows.Media.Animation.Storyboard" />.</summary>
        <returns>Nueva instancia de <see cref="T:System.Windows.Media.Animation.Storyboard" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se llama internamente a este método <xref:System.Windows.Freezable.CreateInstance%2A> al crear nuevas instancias de la <xref:System.Windows.Media.Animation.Storyboard> clase para los distintos métodos de clonación (como <xref:System.Windows.Freezable.Clone%2A> y <xref:System.Windows.Freezable.CloneCurrentValue%2A>).  
  
   
  
## Examples  
 En el ejemplo siguiente se muestra una implementación típica de <xref:System.Windows.Freezable.CreateInstanceCore%2A>.  
  
 [!code-csharp[freezablesample_procedural#CreateInstanceCoreExample](~/samples/snippets/csharp/VS_Snippets_Wpf/freezablesample_procedural/CSharp/freezablesample.cs#createinstancecoreexample)]
 [!code-vb[freezablesample_procedural#CreateInstanceCoreExample](~/samples/snippets/visualbasic/VS_Snippets_Wpf/freezablesample_procedural/visualbasic/freezablesample.vb#createinstancecoreexample)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Cada <see cref="T:System.Windows.Media.Animation.Storyboard" /> subclase debe implementar este método. Implementación típica consiste simplemente en llamar al constructor de clase predeterminado y devolver el resultado.</para>
        </block>
        <altmember cref="M:System.Windows.Freezable.CreateInstanceCore" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetCurrentGlobalSpeed">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Recupera la propiedad <see cref="P:System.Windows.Media.Animation.Clock.CurrentGlobalSpeed" /> del objeto <see cref="T:System.Windows.Media.Animation.Clock" /> creado para este objeto <see cref="T:System.Windows.Media.Animation.Storyboard" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un reloj <xref:System.Windows.Media.Animation.Clock.CurrentGlobalSpeed%2A> velocidad es la velocidad a la que actualmente está progresando su tiempo, en comparación con el tiempo real.  
  
 Para usar este método para recuperar información sobre el reloj de un guión gráfico, el guión gráfico debe ser controlable. Para realizar un guión gráfico controlable en el código, debe utilizar la sobrecarga adecuada del guión gráfico <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> método y especifique `true` para que sea controlable. Para obtener un ejemplo, vea [Cómo: controlar un guión gráfico después de que se inicia](~/docs/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts.md).  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Media.Animation.Clock.CurrentGlobalSpeed" />
      </Docs>
    </MemberGroup>
    <Member MemberName="GetCurrentGlobalSpeed">
      <MemberSignature Language="C#" Value="public double GetCurrentGlobalSpeed ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance float64 GetCurrentGlobalSpeed() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.GetCurrentGlobalSpeed" />
      <MemberSignature Language="VB.NET" Value="Public Function GetCurrentGlobalSpeed () As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; double GetCurrentGlobalSpeed();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Recupera la propiedad <see cref="P:System.Windows.Media.Animation.Clock.CurrentGlobalSpeed" /> del objeto <see cref="T:System.Windows.Media.Animation.Clock" /> creado para este objeto <see cref="T:System.Windows.Media.Animation.Storyboard" />.</summary>
        <returns>Velocidad global actual ó 0 si se detiene el reloj.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetCurrentGlobalSpeed">
      <MemberSignature Language="C#" Value="public Nullable&lt;double&gt; GetCurrentGlobalSpeed (System.Windows.FrameworkContentElement containingObject);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Nullable`1&lt;float64&gt; GetCurrentGlobalSpeed(class System.Windows.FrameworkContentElement containingObject) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.GetCurrentGlobalSpeed(System.Windows.FrameworkContentElement)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetCurrentGlobalSpeed (containingObject As FrameworkContentElement) As Nullable(Of Double)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Nullable&lt;double&gt; GetCurrentGlobalSpeed(System::Windows::FrameworkContentElement ^ containingObject);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Double&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="containingObject" Type="System.Windows.FrameworkContentElement" />
      </Parameters>
      <Docs>
        <param name="containingObject">Objeto especificado cuando se llamó al método <see cref="M:System.Windows.Media.Animation.Storyboard.Begin(System.Windows.FrameworkContentElement,System.Boolean)" />. Este objeto contiene los objetos <see cref="T:System.Windows.Media.Animation.Clock" /> que se crearon para este guión gráfico y sus elementos secundarios.</param>
        <summary>Recupera la propiedad <see cref="P:System.Windows.Media.Animation.Clock.CurrentGlobalSpeed" /> del objeto <see cref="T:System.Windows.Media.Animation.Clock" /> creado para este objeto <see cref="T:System.Windows.Media.Animation.Storyboard" />.</summary>
        <returns>Velocidad global actual ó <see langword="null" /> si se detiene el reloj.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un reloj <xref:System.Windows.Media.Animation.Clock.CurrentGlobalSpeed%2A> velocidad es la velocidad a la que actualmente está progresando su tiempo, en comparación con el tiempo real.  
  
 Para usar este método para recuperar información sobre el reloj de un guión gráfico, el guión gráfico debe ser controlable. Para realizar un guión gráfico controlable en el código, debe utilizar la sobrecarga adecuada del guión gráfico <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> método y especifique `true` para que sea controlable. Para obtener un ejemplo, vea [Cómo: controlar un guión gráfico después de que se inicia](~/docs/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts.md).  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Media.Animation.Clock.CurrentGlobalSpeed" />
      </Docs>
    </Member>
    <Member MemberName="GetCurrentGlobalSpeed">
      <MemberSignature Language="C#" Value="public Nullable&lt;double&gt; GetCurrentGlobalSpeed (System.Windows.FrameworkElement containingObject);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Nullable`1&lt;float64&gt; GetCurrentGlobalSpeed(class System.Windows.FrameworkElement containingObject) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.GetCurrentGlobalSpeed(System.Windows.FrameworkElement)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetCurrentGlobalSpeed (containingObject As FrameworkElement) As Nullable(Of Double)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Nullable&lt;double&gt; GetCurrentGlobalSpeed(System::Windows::FrameworkElement ^ containingObject);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Double&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="containingObject" Type="System.Windows.FrameworkElement" />
      </Parameters>
      <Docs>
        <param name="containingObject">Objeto especificado cuando se llamó al método <see cref="M:System.Windows.Media.Animation.Storyboard.Begin(System.Windows.FrameworkElement,System.Boolean)" />. Este objeto contiene los objetos <see cref="T:System.Windows.Media.Animation.Clock" /> que se crearon para este guión gráfico y sus elementos secundarios.</param>
        <summary>Recupera la propiedad <see cref="P:System.Windows.Media.Animation.Clock.CurrentGlobalSpeed" /> del objeto <see cref="T:System.Windows.Media.Animation.Clock" /> creado para este objeto <see cref="T:System.Windows.Media.Animation.Storyboard" />.</summary>
        <returns>Velocidad global actual ó <see langword="null" /> si se detiene el reloj.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un reloj <xref:System.Windows.Media.Animation.Clock.CurrentGlobalSpeed%2A> velocidad es la velocidad a la que actualmente está progresando su tiempo, en comparación con el tiempo real.  
  
 Para usar este método para recuperar información sobre el reloj de un guión gráfico, el guión gráfico debe ser controlable. Para realizar un guión gráfico controlable en el código, debe utilizar la sobrecarga adecuada del guión gráfico <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> método y especifique `true` para que sea controlable. Para obtener un ejemplo, vea [Cómo: controlar un guión gráfico después de que se inicia](~/docs/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts.md).  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Media.Animation.Clock.CurrentGlobalSpeed" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetCurrentIteration">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Recupera la propiedad <see cref="P:System.Windows.Media.Animation.Clock.CurrentIteration" /> del objeto <see cref="T:System.Windows.Media.Animation.Clock" /> creado para este objeto <see cref="T:System.Windows.Media.Animation.Storyboard" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetCurrentIteration">
      <MemberSignature Language="C#" Value="public int GetCurrentIteration ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 GetCurrentIteration() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.GetCurrentIteration" />
      <MemberSignature Language="VB.NET" Value="Public Function GetCurrentIteration () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int GetCurrentIteration();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Recupera la propiedad <see cref="P:System.Windows.Media.Animation.Clock.CurrentIteration" /> del objeto <see cref="T:System.Windows.Media.Animation.Clock" /> creado para este objeto <see cref="T:System.Windows.Media.Animation.Storyboard" />.</summary>
        <returns>Iteración actual de este reloj dentro de su período activo actual o <see langword="null" /> si se detiene este reloj.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Primera iteración del reloj tiene un valor de 1.  
  
 Si este guión gráfico tiene una <xref:System.Windows.Media.Animation.Timeline.AutoReverse%2A> de `true`, una iteración completa se compone de un par de avance inverso, no solo uno de estos segmentos.  
  
 Para usar este método para recuperar información sobre el reloj de un guión gráfico, el guión gráfico debe ser controlable. Para realizar un guión gráfico controlable en el código, debe utilizar la sobrecarga adecuada del guión gráfico <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> método y especifique `true` para que sea controlable. Para obtener un ejemplo, vea [Cómo: controlar un guión gráfico después de que se inicia](~/docs/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts.md).  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Media.Animation.Clock.CurrentIteration" />
      </Docs>
    </Member>
    <Member MemberName="GetCurrentIteration">
      <MemberSignature Language="C#" Value="public Nullable&lt;int&gt; GetCurrentIteration (System.Windows.FrameworkContentElement containingObject);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Nullable`1&lt;int32&gt; GetCurrentIteration(class System.Windows.FrameworkContentElement containingObject) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.GetCurrentIteration(System.Windows.FrameworkContentElement)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetCurrentIteration (containingObject As FrameworkContentElement) As Nullable(Of Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Nullable&lt;int&gt; GetCurrentIteration(System::Windows::FrameworkContentElement ^ containingObject);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="containingObject" Type="System.Windows.FrameworkContentElement" />
      </Parameters>
      <Docs>
        <param name="containingObject">Objeto especificado cuando se llamó al método <see cref="M:System.Windows.Media.Animation.Storyboard.Begin(System.Windows.FrameworkContentElement,System.Boolean)" />. Este objeto contiene los objetos <see cref="T:System.Windows.Media.Animation.Clock" /> que se crearon para este guión gráfico y sus elementos secundarios.</param>
        <summary>Recupera la propiedad <see cref="P:System.Windows.Media.Animation.Clock.CurrentIteration" /> del objeto <see cref="T:System.Windows.Media.Animation.Clock" /> creado para este objeto <see cref="T:System.Windows.Media.Animation.Storyboard" />.</summary>
        <returns>Iteración actual de este reloj dentro de su período activo actual o <see langword="null" /> si se detiene este reloj.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Primera iteración del reloj tiene un valor de 1.  
  
 Si este guión gráfico tiene una <xref:System.Windows.Media.Animation.Timeline.AutoReverse%2A> de `true`, una iteración completa se compone de un par de avance inverso, no solo uno de estos segmentos.  
  
 Para usar este método para recuperar información sobre el reloj de un guión gráfico, el guión gráfico debe ser controlable. Para realizar un guión gráfico controlable en el código, debe utilizar la sobrecarga adecuada del guión gráfico <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> método y especifique `true` para que sea controlable. Para obtener un ejemplo, vea [Cómo: controlar un guión gráfico después de que se inicia](~/docs/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts.md).  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Media.Animation.Clock.CurrentIteration" />
      </Docs>
    </Member>
    <Member MemberName="GetCurrentIteration">
      <MemberSignature Language="C#" Value="public Nullable&lt;int&gt; GetCurrentIteration (System.Windows.FrameworkElement containingObject);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Nullable`1&lt;int32&gt; GetCurrentIteration(class System.Windows.FrameworkElement containingObject) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.GetCurrentIteration(System.Windows.FrameworkElement)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetCurrentIteration (containingObject As FrameworkElement) As Nullable(Of Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Nullable&lt;int&gt; GetCurrentIteration(System::Windows::FrameworkElement ^ containingObject);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="containingObject" Type="System.Windows.FrameworkElement" />
      </Parameters>
      <Docs>
        <param name="containingObject">Objeto especificado cuando se llamó al método <see cref="M:System.Windows.Media.Animation.Storyboard.Begin(System.Windows.FrameworkElement,System.Boolean)" />. Este objeto contiene los objetos <see cref="T:System.Windows.Media.Animation.Clock" /> que se crearon para este guión gráfico y sus elementos secundarios.</param>
        <summary>Recupera la propiedad <see cref="P:System.Windows.Media.Animation.Clock.CurrentIteration" /> del objeto <see cref="T:System.Windows.Media.Animation.Clock" /> creado para este objeto <see cref="T:System.Windows.Media.Animation.Storyboard" />.</summary>
        <returns>Iteración actual de este reloj dentro de su período activo actual o <see langword="null" /> si se detiene este reloj.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Primera iteración del reloj tiene un valor de 1.  
  
 Si la escala de tiempo de este reloj tiene una <xref:System.Windows.Media.Animation.Timeline.AutoReverse%2A> de `true`, una iteración completa se compone de un par de avance inverso, no solo uno de estos segmentos.  
  
 Independientemente de la iteración actual, que buscan un reloj de devuelve su iteración actual establecida en 1. Reiniciar un reloj también devuelve su iteración actual en 1.  
  
 Para usar este método para recuperar información sobre el reloj de un guión gráfico, el guión gráfico debe ser controlable. Para realizar un guión gráfico controlable en el código, debe utilizar la sobrecarga adecuada del guión gráfico <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> método y especifique `true` para que sea controlable. Para obtener un ejemplo, vea [Cómo: controlar un guión gráfico después de que se inicia](~/docs/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts.md).  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Media.Animation.Clock.CurrentIteration" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetCurrentProgress">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Recupera la propiedad <see cref="P:System.Windows.Media.Animation.Clock.CurrentProgress" /> del objeto <see cref="T:System.Windows.Media.Animation.Clock" /> creado para este objeto <see cref="T:System.Windows.Media.Animation.Storyboard" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetCurrentProgress">
      <MemberSignature Language="C#" Value="public double GetCurrentProgress ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance float64 GetCurrentProgress() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.GetCurrentProgress" />
      <MemberSignature Language="VB.NET" Value="Public Function GetCurrentProgress () As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; double GetCurrentProgress();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Recupera la propiedad <see cref="P:System.Windows.Media.Animation.Clock.CurrentProgress" /> del objeto <see cref="T:System.Windows.Media.Animation.Clock" /> creado para este objeto <see cref="T:System.Windows.Media.Animation.Storyboard" />.</summary>
        <returns>
          Es <see langword="null" /> si este reloj tiene el estado <see cref="F:System.Windows.Media.Animation.ClockState.Stopped" />, o 0,0 si este reloj está activo y su propiedad <see cref="P:System.Windows.Media.Animation.Clock.Timeline" /> tiene un valor para <see cref="P:System.Windows.Media.Animation.Timeline.Duration" /> de <see cref="P:System.Windows.Duration.Forever" />; de lo contrario, es un valor comprendido entre 0,0 y 1,0, lo que indica el progreso actual de este reloj dentro de su iteración actual. Un valor de 0,0 no indica ningún progreso, mientras que un valor de 1,0 indica que el reloj se encuentra al final de su iteración actual.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para usar este método para recuperar información sobre el reloj de un guión gráfico, el guión gráfico debe ser controlable. Para realizar un guión gráfico controlable en el código, debe utilizar la sobrecarga adecuada del guión gráfico <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> método y especifique `true` para que sea controlable. Para obtener un ejemplo, vea [Cómo: controlar un guión gráfico después de que se inicia](~/docs/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetCurrentProgress">
      <MemberSignature Language="C#" Value="public Nullable&lt;double&gt; GetCurrentProgress (System.Windows.FrameworkContentElement containingObject);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Nullable`1&lt;float64&gt; GetCurrentProgress(class System.Windows.FrameworkContentElement containingObject) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.GetCurrentProgress(System.Windows.FrameworkContentElement)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetCurrentProgress (containingObject As FrameworkContentElement) As Nullable(Of Double)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Nullable&lt;double&gt; GetCurrentProgress(System::Windows::FrameworkContentElement ^ containingObject);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Double&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="containingObject" Type="System.Windows.FrameworkContentElement" />
      </Parameters>
      <Docs>
        <param name="containingObject">Objeto especificado cuando se llamó al método <see cref="M:System.Windows.Media.Animation.Storyboard.Begin(System.Windows.FrameworkContentElement,System.Boolean)" />. Este objeto contiene los objetos <see cref="T:System.Windows.Media.Animation.Clock" /> que se crearon para este guión gráfico y sus elementos secundarios.</param>
        <summary>Recupera la propiedad <see cref="P:System.Windows.Media.Animation.Clock.CurrentProgress" /> del objeto <see cref="T:System.Windows.Media.Animation.Clock" /> creado para este objeto <see cref="T:System.Windows.Media.Animation.Storyboard" />.</summary>
        <returns>
          Es <see langword="null" /> si este reloj tiene el estado <see cref="F:System.Windows.Media.Animation.ClockState.Stopped" />, o 0,0 si este reloj está activo y su propiedad <see cref="P:System.Windows.Media.Animation.Clock.Timeline" /> tiene un valor para <see cref="P:System.Windows.Media.Animation.Timeline.Duration" /> de <see cref="P:System.Windows.Duration.Forever" />; de lo contrario, es un valor comprendido entre 0,0 y 1,0, lo que indica el progreso actual de este reloj dentro de su iteración actual. Un valor de 0,0 no indica ningún progreso, mientras que un valor de 1,0 indica que el reloj se encuentra al final de su iteración actual.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para usar este método para recuperar información sobre el reloj de un guión gráfico, el guión gráfico debe ser controlable. Para realizar un guión gráfico controlable en el código, debe utilizar la sobrecarga adecuada del guión gráfico <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> método y especifique `true` para que sea controlable. Para obtener un ejemplo, vea [Cómo: controlar un guión gráfico después de que se inicia](~/docs/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetCurrentProgress">
      <MemberSignature Language="C#" Value="public Nullable&lt;double&gt; GetCurrentProgress (System.Windows.FrameworkElement containingObject);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Nullable`1&lt;float64&gt; GetCurrentProgress(class System.Windows.FrameworkElement containingObject) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.GetCurrentProgress(System.Windows.FrameworkElement)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetCurrentProgress (containingObject As FrameworkElement) As Nullable(Of Double)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Nullable&lt;double&gt; GetCurrentProgress(System::Windows::FrameworkElement ^ containingObject);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Double&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="containingObject" Type="System.Windows.FrameworkElement" />
      </Parameters>
      <Docs>
        <param name="containingObject">Objeto especificado cuando se llamó al método <see cref="M:System.Windows.Media.Animation.Storyboard.Begin(System.Windows.FrameworkElement,System.Boolean)" />. Este objeto contiene los objetos <see cref="T:System.Windows.Media.Animation.Clock" /> que se crearon para este guión gráfico y sus elementos secundarios.</param>
        <summary>Recupera la propiedad <see cref="P:System.Windows.Media.Animation.Clock.CurrentProgress" /> del objeto <see cref="T:System.Windows.Media.Animation.Clock" /> creado para este objeto <see cref="T:System.Windows.Media.Animation.Storyboard" />.</summary>
        <returns>
          Es <see langword="null" /> si este reloj tiene el estado <see cref="F:System.Windows.Media.Animation.ClockState.Stopped" />, o 0,0 si este reloj está activo y su propiedad <see cref="P:System.Windows.Media.Animation.Clock.Timeline" /> tiene un valor para <see cref="P:System.Windows.Media.Animation.Timeline.Duration" /> de <see cref="P:System.Windows.Duration.Forever" />; de lo contrario, es un valor comprendido entre 0,0 y 1,0, lo que indica el progreso actual de este reloj dentro de su iteración actual. Un valor de 0,0 no indica ningún progreso, mientras que un valor de 1,0 indica que el reloj se encuentra al final de su iteración actual.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para usar este método para recuperar información sobre el reloj de un guión gráfico, el guión gráfico debe ser controlable. Para realizar un guión gráfico controlable en el código, debe utilizar la sobrecarga adecuada del guión gráfico <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> método y especifique `true` para que sea controlable. Para obtener un ejemplo, vea [Cómo: controlar un guión gráfico después de que se inicia](~/docs/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetCurrentState">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Recupera la propiedad <see cref="P:System.Windows.Media.Animation.Clock.CurrentState" /> del objeto <see cref="T:System.Windows.Media.Animation.Clock" /> creado para este objeto <see cref="T:System.Windows.Media.Animation.Storyboard" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetCurrentState">
      <MemberSignature Language="C#" Value="public System.Windows.Media.Animation.ClockState GetCurrentState ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Windows.Media.Animation.ClockState GetCurrentState() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.GetCurrentState" />
      <MemberSignature Language="VB.NET" Value="Public Function GetCurrentState () As ClockState" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Media::Animation::ClockState GetCurrentState();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Media.Animation.ClockState</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Recupera la propiedad <see cref="P:System.Windows.Media.Animation.Clock.CurrentState" /> del objeto <see cref="T:System.Windows.Media.Animation.Clock" /> creado para este objeto <see cref="T:System.Windows.Media.Animation.Storyboard" />.</summary>
        <returns>Estado actual del reloj creado para este guión gráfico: <see cref="F:System.Windows.Media.Animation.ClockState.Active" />, <see cref="F:System.Windows.Media.Animation.ClockState.Filling" /> o <see cref="F:System.Windows.Media.Animation.ClockState.Stopped" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método no indica si un guión gráfico está en pausa. Para determinar si un guión gráfico está en pausa, utilice el <xref:System.Windows.Media.Animation.Storyboard.GetIsPaused%2A> método.  
  
 Para usar este método para recuperar información sobre el reloj de un guión gráfico, el guión gráfico debe ser controlable. Para realizar un guión gráfico controlable en el código, debe utilizar la sobrecarga adecuada del guión gráfico <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> método y especifique `true` para que sea controlable. Para obtener un ejemplo, vea [Cómo: controlar un guión gráfico después de que se inicia](~/docs/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetCurrentState">
      <MemberSignature Language="C#" Value="public System.Windows.Media.Animation.ClockState GetCurrentState (System.Windows.FrameworkContentElement containingObject);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Windows.Media.Animation.ClockState GetCurrentState(class System.Windows.FrameworkContentElement containingObject) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.GetCurrentState(System.Windows.FrameworkContentElement)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetCurrentState (containingObject As FrameworkContentElement) As ClockState" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Media::Animation::ClockState GetCurrentState(System::Windows::FrameworkContentElement ^ containingObject);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Media.Animation.ClockState</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="containingObject" Type="System.Windows.FrameworkContentElement" />
      </Parameters>
      <Docs>
        <param name="containingObject">Objeto especificado cuando se llamó al método <see cref="M:System.Windows.Media.Animation.Storyboard.Begin(System.Windows.FrameworkContentElement,System.Boolean)" />. Este objeto contiene los objetos <see cref="T:System.Windows.Media.Animation.Clock" /> que se crearon para este guión gráfico y sus elementos secundarios.</param>
        <summary>Recupera la propiedad <see cref="P:System.Windows.Media.Animation.Clock.CurrentState" /> del objeto <see cref="T:System.Windows.Media.Animation.Clock" /> creado para este objeto <see cref="T:System.Windows.Media.Animation.Storyboard" />.</summary>
        <returns>Estado actual del reloj creado para este guión gráfico: <see cref="F:System.Windows.Media.Animation.ClockState.Active" />, <see cref="F:System.Windows.Media.Animation.ClockState.Filling" /> o <see cref="F:System.Windows.Media.Animation.ClockState.Stopped" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método no indica si un guión gráfico está en pausa. Para determinar si un guión gráfico está en pausa, utilice el <xref:System.Windows.Media.Animation.Storyboard.GetIsPaused%2A> método.  
  
 Para usar este método para recuperar información sobre el reloj de un guión gráfico, el guión gráfico debe ser controlable. Para realizar un guión gráfico controlable en el código, debe utilizar la sobrecarga adecuada del guión gráfico <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> método y especifique `true` para que sea controlable. Para obtener un ejemplo, vea [Cómo: controlar un guión gráfico después de que se inicia](~/docs/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetCurrentState">
      <MemberSignature Language="C#" Value="public System.Windows.Media.Animation.ClockState GetCurrentState (System.Windows.FrameworkElement containingObject);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Windows.Media.Animation.ClockState GetCurrentState(class System.Windows.FrameworkElement containingObject) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.GetCurrentState(System.Windows.FrameworkElement)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetCurrentState (containingObject As FrameworkElement) As ClockState" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Media::Animation::ClockState GetCurrentState(System::Windows::FrameworkElement ^ containingObject);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Media.Animation.ClockState</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="containingObject" Type="System.Windows.FrameworkElement" />
      </Parameters>
      <Docs>
        <param name="containingObject">Objeto especificado cuando se llamó al método <see cref="M:System.Windows.Media.Animation.Storyboard.Begin(System.Windows.FrameworkElement,System.Boolean)" />. Este objeto contiene los objetos <see cref="T:System.Windows.Media.Animation.Clock" /> que se crearon para este guión gráfico y sus elementos secundarios.</param>
        <summary>Recupera la propiedad <see cref="P:System.Windows.Media.Animation.Clock.CurrentState" /> del objeto <see cref="T:System.Windows.Media.Animation.Clock" /> creado para este objeto <see cref="T:System.Windows.Media.Animation.Storyboard" />.</summary>
        <returns>Estado actual del reloj creado para este guión gráfico: <see cref="F:System.Windows.Media.Animation.ClockState.Active" />, <see cref="F:System.Windows.Media.Animation.ClockState.Filling" /> o <see cref="F:System.Windows.Media.Animation.ClockState.Stopped" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método no indica si un guión gráfico está en pausa. Para determinar si un guión gráfico está en pausa, utilice el <xref:System.Windows.Media.Animation.Storyboard.GetIsPaused%2A> método.  
  
 Para usar este método para recuperar información sobre el reloj de un guión gráfico, el guión gráfico debe ser controlable. Para realizar un guión gráfico controlable en el código, debe utilizar la sobrecarga adecuada del guión gráfico <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> método y especifique `true` para que sea controlable. Para obtener un ejemplo, vea [Cómo: controlar un guión gráfico después de que se inicia](~/docs/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetCurrentTime">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Recupera la propiedad <see cref="P:System.Windows.Media.Animation.Clock.CurrentTime" /> del objeto <see cref="T:System.Windows.Media.Animation.Clock" /> creado para este objeto <see cref="T:System.Windows.Media.Animation.Storyboard" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetCurrentTime">
      <MemberSignature Language="C#" Value="public TimeSpan GetCurrentTime ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.TimeSpan GetCurrentTime() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.GetCurrentTime" />
      <MemberSignature Language="VB.NET" Value="Public Function GetCurrentTime () As TimeSpan" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; TimeSpan GetCurrentTime();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Recupera la propiedad <see cref="P:System.Windows.Media.Animation.Clock.CurrentTime" /> del objeto <see cref="T:System.Windows.Media.Animation.Clock" /> creado para este objeto <see cref="T:System.Windows.Media.Animation.Storyboard" />.</summary>
        <returns>
          <see langword="null" /> si el reloj de este guión gráfico es <see cref="F:System.Windows.Media.Animation.ClockState.Stopped" />; de lo contrario, la hora actual del reloj del guión gráfico.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para usar este método para recuperar información sobre el reloj de un guión gráfico, el guión gráfico debe ser controlable. Para realizar un guión gráfico controlable en el código, debe utilizar la sobrecarga adecuada del guión gráfico <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> método y especifique `true` para que sea controlable. Para obtener un ejemplo, vea [Cómo: controlar un guión gráfico después de que se inicia](~/docs/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts.md).  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Media.Animation.Clock.CurrentTime" />
      </Docs>
    </Member>
    <Member MemberName="GetCurrentTime">
      <MemberSignature Language="C#" Value="public Nullable&lt;TimeSpan&gt; GetCurrentTime (System.Windows.FrameworkContentElement containingObject);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Nullable`1&lt;valuetype System.TimeSpan&gt; GetCurrentTime(class System.Windows.FrameworkContentElement containingObject) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.GetCurrentTime(System.Windows.FrameworkContentElement)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetCurrentTime (containingObject As FrameworkContentElement) As Nullable(Of TimeSpan)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Nullable&lt;TimeSpan&gt; GetCurrentTime(System::Windows::FrameworkContentElement ^ containingObject);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.TimeSpan&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="containingObject" Type="System.Windows.FrameworkContentElement" />
      </Parameters>
      <Docs>
        <param name="containingObject">Objeto especificado cuando se llamó al método <see cref="M:System.Windows.Media.Animation.Storyboard.Begin(System.Windows.FrameworkContentElement,System.Boolean)" />. Este objeto contiene los objetos <see cref="T:System.Windows.Media.Animation.Clock" /> que se crearon para este guión gráfico y sus elementos secundarios.</param>
        <summary>Recupera la propiedad <see cref="P:System.Windows.Media.Animation.Clock.CurrentTime" /> del objeto <see cref="T:System.Windows.Media.Animation.Clock" /> creado para este objeto <see cref="T:System.Windows.Media.Animation.Storyboard" />.</summary>
        <returns>
          <see langword="null" /> si el reloj de este guión gráfico es <see cref="F:System.Windows.Media.Animation.ClockState.Stopped" />; de lo contrario, la hora actual del reloj del guión gráfico.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para usar este método para recuperar información sobre el reloj de un guión gráfico, el guión gráfico debe ser controlable. Para realizar un guión gráfico controlable en el código, debe utilizar la sobrecarga adecuada del guión gráfico <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> método y especifique `true` para que sea controlable. Para obtener un ejemplo, vea [Cómo: controlar un guión gráfico después de que se inicia](~/docs/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts.md).  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Media.Animation.Clock.CurrentTime" />
      </Docs>
    </Member>
    <Member MemberName="GetCurrentTime">
      <MemberSignature Language="C#" Value="public Nullable&lt;TimeSpan&gt; GetCurrentTime (System.Windows.FrameworkElement containingObject);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Nullable`1&lt;valuetype System.TimeSpan&gt; GetCurrentTime(class System.Windows.FrameworkElement containingObject) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.GetCurrentTime(System.Windows.FrameworkElement)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetCurrentTime (containingObject As FrameworkElement) As Nullable(Of TimeSpan)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Nullable&lt;TimeSpan&gt; GetCurrentTime(System::Windows::FrameworkElement ^ containingObject);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.TimeSpan&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="containingObject" Type="System.Windows.FrameworkElement" />
      </Parameters>
      <Docs>
        <param name="containingObject">Objeto especificado cuando se llamó al método <see cref="M:System.Windows.Media.Animation.Storyboard.Begin(System.Windows.FrameworkElement,System.Boolean)" />. Este objeto contiene los objetos <see cref="T:System.Windows.Media.Animation.Clock" /> que se crearon para este guión gráfico y sus elementos secundarios.</param>
        <summary>Recupera la propiedad <see cref="P:System.Windows.Media.Animation.Clock.CurrentTime" /> del objeto <see cref="T:System.Windows.Media.Animation.Clock" /> creado para este objeto <see cref="T:System.Windows.Media.Animation.Storyboard" />.</summary>
        <returns>
          <see langword="null" /> si el reloj de este guión gráfico es <see cref="F:System.Windows.Media.Animation.ClockState.Stopped" />; de lo contrario, la hora actual del reloj del guión gráfico.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para usar este método para recuperar información sobre el reloj de un guión gráfico, el guión gráfico debe ser controlable. Para realizar un guión gráfico controlable en el código, debe utilizar la sobrecarga adecuada del guión gráfico <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> método y especifique `true` para que sea controlable. Para obtener un ejemplo, vea [Cómo: controlar un guión gráfico después de que se inicia](~/docs/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts.md).  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Media.Animation.Clock.CurrentTime" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetIsPaused">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Recupera un valor que indica si el objeto <see cref="T:System.Windows.Media.Animation.Clock" /> creado para este <see cref="T:System.Windows.Media.Animation.Storyboard" /> está en pausa.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetIsPaused">
      <MemberSignature Language="C#" Value="public bool GetIsPaused ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool GetIsPaused() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.GetIsPaused" />
      <MemberSignature Language="VB.NET" Value="Public Function GetIsPaused () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool GetIsPaused();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Recupera un valor que indica si el objeto <see cref="T:System.Windows.Media.Animation.Clock" /> creado para este <see cref="T:System.Windows.Media.Animation.Storyboard" /> está en pausa.</summary>
        <returns>
          <see langword="true" /> si el objeto <see cref="T:System.Windows.Media.Animation.Clock" /> creado para <see cref="T:System.Windows.Media.Animation.Storyboard" /> está en pausa; de lo contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para usar este método para recuperar información sobre el reloj de un guión gráfico, el guión gráfico debe ser controlable. Para realizar un guión gráfico controlable en el código, debe utilizar la sobrecarga adecuada del guión gráfico <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> método y especifique `true` para que sea controlable. Para obtener un ejemplo, vea [Cómo: controlar un guión gráfico después de que se inicia](~/docs/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts.md).  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Media.Animation.Clock.IsPaused" />
      </Docs>
    </Member>
    <Member MemberName="GetIsPaused">
      <MemberSignature Language="C#" Value="public bool GetIsPaused (System.Windows.FrameworkContentElement containingObject);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool GetIsPaused(class System.Windows.FrameworkContentElement containingObject) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.GetIsPaused(System.Windows.FrameworkContentElement)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetIsPaused (containingObject As FrameworkContentElement) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool GetIsPaused(System::Windows::FrameworkContentElement ^ containingObject);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="containingObject" Type="System.Windows.FrameworkContentElement" />
      </Parameters>
      <Docs>
        <param name="containingObject">Objeto especificado cuando se llamó al método <see cref="M:System.Windows.Media.Animation.Storyboard.Begin(System.Windows.FrameworkContentElement,System.Boolean)" />. Este objeto contiene los objetos <see cref="T:System.Windows.Media.Animation.Clock" /> que se crearon para este guión gráfico y sus elementos secundarios.</param>
        <summary>Recupera un valor que indica si el objeto <see cref="T:System.Windows.Media.Animation.Clock" /> creado para este <see cref="T:System.Windows.Media.Animation.Storyboard" /> está en pausa.</summary>
        <returns>
          <see langword="true" /> si el objeto <see cref="T:System.Windows.Media.Animation.Clock" /> creado para <see cref="T:System.Windows.Media.Animation.Storyboard" /> está en pausa; de lo contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para usar este método para recuperar información sobre el reloj de un guión gráfico, el guión gráfico debe ser controlable. Para realizar un guión gráfico controlable en el código, debe utilizar la sobrecarga adecuada del guión gráfico <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> método y especifique `true` para que sea controlable. Para obtener un ejemplo, vea [Cómo: controlar un guión gráfico después de que se inicia](~/docs/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts.md).  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Media.Animation.Clock.IsPaused" />
      </Docs>
    </Member>
    <Member MemberName="GetIsPaused">
      <MemberSignature Language="C#" Value="public bool GetIsPaused (System.Windows.FrameworkElement containingObject);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool GetIsPaused(class System.Windows.FrameworkElement containingObject) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.GetIsPaused(System.Windows.FrameworkElement)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetIsPaused (containingObject As FrameworkElement) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool GetIsPaused(System::Windows::FrameworkElement ^ containingObject);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="containingObject" Type="System.Windows.FrameworkElement" />
      </Parameters>
      <Docs>
        <param name="containingObject">Objeto especificado cuando se llamó al método <see cref="M:System.Windows.Media.Animation.Storyboard.Begin(System.Windows.FrameworkElement,System.Boolean)" />. Este objeto contiene los objetos <see cref="T:System.Windows.Media.Animation.Clock" /> que se crearon para este guión gráfico y sus elementos secundarios.</param>
        <summary>Recupera un valor que indica si el objeto <see cref="T:System.Windows.Media.Animation.Clock" /> creado para este <see cref="T:System.Windows.Media.Animation.Storyboard" /> está en pausa.</summary>
        <returns>
          <see langword="true" /> si el objeto <see cref="T:System.Windows.Media.Animation.Clock" /> creado para <see cref="T:System.Windows.Media.Animation.Storyboard" /> está en pausa; de lo contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para usar este método para recuperar información sobre el reloj de un guión gráfico, el guión gráfico debe ser controlable. Para realizar un guión gráfico controlable en el código, debe utilizar la sobrecarga adecuada del guión gráfico <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> método y especifique `true` para que sea controlable. Para obtener un ejemplo, vea [Cómo: controlar un guión gráfico después de que se inicia](~/docs/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts.md).  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Media.Animation.Clock.IsPaused" />
      </Docs>
    </Member>
    <Member MemberName="GetTarget">
      <MemberSignature Language="C#" Value="public static System.Windows.DependencyObject GetTarget (System.Windows.DependencyObject element);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.DependencyObject GetTarget(class System.Windows.DependencyObject element) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.GetTarget(System.Windows.DependencyObject)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTarget (element As DependencyObject) As DependencyObject" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::DependencyObject ^ GetTarget(System::Windows::DependencyObject ^ element);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyObject</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
      </Parameters>
      <Docs>
        <param name="element">Escala de tiempo de la que se va a recuperar el valor de <see cref="P:System.Windows.Media.Animation.Storyboard.TargetName" />.</param>
        <summary>Recupera el valor de <see cref="P:System.Windows.Media.Animation.Storyboard.Target" /> del objeto <see cref="T:System.Windows.Media.Animation.Timeline" /> especificado.</summary>
        <returns>Objeto de dependencia que es el destino de <paramref name="element" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use la <xref:System.Windows.Media.Animation.Storyboard.Target%2A> propiedad con las escalas de tiempo de animación para indicar que el objeto que se dirigen a adjunta. Para obtener más información acerca de cómo funcionan los destinos de guión gráfico, consulte <xref:System.Windows.Media.Animation.Storyboard.TargetName%2A>. Para obtener más información acerca de cómo funcionan las propiedades adjuntas cómo, consulte [Attached Properties Overview](~/docs/framework/wpf/advanced/attached-properties-overview.md).  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Media.Animation.Storyboard.TargetName" />
      </Docs>
    </Member>
    <Member MemberName="GetTargetName">
      <MemberSignature Language="C#" Value="public static string GetTargetName (System.Windows.DependencyObject element);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetTargetName(class System.Windows.DependencyObject element) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.GetTargetName(System.Windows.DependencyObject)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTargetName (element As DependencyObject) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetTargetName(System::Windows::DependencyObject ^ element);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
      </Parameters>
      <Docs>
        <param name="element">Escala de tiempo de la que se va a recuperar el valor de <see cref="P:System.Windows.Media.Animation.Storyboard.TargetName" />.</param>
        <summary>Recupera el valor de <see cref="P:System.Windows.Media.Animation.Storyboard.TargetName" /> del objeto <see cref="T:System.Windows.Media.Animation.Timeline" /> especificado.</summary>
        <returns>El nombre del objeto de dependencia de destino de <paramref name="element" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método obtiene el <xref:System.Windows.Media.Animation.Storyboard.TargetName%2A> propiedad adjunta en el objeto especificado. Para obtener más información acerca de cómo funcionan los destinos de guión gráfico, consulte <xref:System.Windows.Media.Animation.Storyboard.TargetName%2A>. Para obtener más información acerca de cómo funcionan las propiedades adjuntas cómo, consulte [Attached Properties Overview](~/docs/framework/wpf/advanced/attached-properties-overview.md).  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Media.Animation.Storyboard.TargetName" />
      </Docs>
    </Member>
    <Member MemberName="GetTargetProperty">
      <MemberSignature Language="C#" Value="public static System.Windows.PropertyPath GetTargetProperty (System.Windows.DependencyObject element);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.PropertyPath GetTargetProperty(class System.Windows.DependencyObject element) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.GetTargetProperty(System.Windows.DependencyObject)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTargetProperty (element As DependencyObject) As PropertyPath" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::PropertyPath ^ GetTargetProperty(System::Windows::DependencyObject ^ element);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.PropertyPath</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
      </Parameters>
      <Docs>
        <param name="element">Objeto de dependencia del que se obtiene <see cref="P:System.Windows.Media.Animation.Storyboard.TargetProperty" />.</param>
        <summary>Recupera el valor de <see cref="P:System.Windows.Media.Animation.Storyboard.TargetProperty" /> del objeto <see cref="T:System.Windows.Media.Animation.Timeline" /> especificado.</summary>
        <returns>Propiedad de destino de <paramref name="element" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método obtiene el <xref:System.Windows.Media.Animation.Storyboard.TargetProperty%2A> propiedad adjunta en el objeto especificado. Para obtener más información acerca de cómo funcionan los destinos de guión gráfico, vea <xref:System.Windows.Media.Animation.Storyboard.TargetProperty%2A> propiedad adjunta. Para obtener más información acerca de cómo funcionan las propiedades adjuntas cómo, consulte [Attached Properties Overview](~/docs/framework/wpf/advanced/attached-properties-overview.md).  
  
 Tenga en cuenta que si el <xref:System.Windows.Media.Animation.Storyboard.TargetProperty%2A> se estableció en el marcado, este método devuelve una instancia vacía <xref:System.Windows.PropertyPath> porque la referencia de propiedad se resuelve y se almacena internamente cuando se analiza.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Media.Animation.Storyboard.TargetProperty" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Pause">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Pausa el objeto <see cref="T:System.Windows.Media.Animation.Clock" /> que se creó para este objeto <see cref="T:System.Windows.Media.Animation.Storyboard" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Pause">
      <MemberSignature Language="C#" Value="public void Pause ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Pause() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.Pause" />
      <MemberSignature Language="VB.NET" Value="Public Sub Pause ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Pause();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Pausa el objeto <see cref="T:System.Windows.Media.Animation.Clock" /> que se creó para este objeto <see cref="T:System.Windows.Media.Animation.Storyboard" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método pone en pausa el guión gráfico, pero no tiene ningún efecto discernible si no está activa o en pausa actualmente. Como efecto secundario, todos los elementos secundarios asociados se pausan también.  
  
 Un guión gráfico controlable se puede pausar, reanudar, buscar, detener y se quitan. Para realizar un guión gráfico controlable en el código, debe utilizar la sobrecarga adecuada del guión gráfico <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> método y especifique `true` para que sea controlable. Para obtener un ejemplo, vea [Cómo: controlar un guión gráfico después de que se inicia](~/docs/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts.md).  
  
## <a name="beginning-a-paused-storyboard"></a>A partir un guión gráfico en pausa  
 Cuando se <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> un guión gráfico que estaba en pausa, parece reanudar y reiniciar. Sin embargo, es no lo que sucede realmente. El <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> método reemplaza realmente la pausa <xref:System.Windows.Media.Animation.Storyboard> con una nueva versión de pausa. Cada vez que la <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> se llama al método, se crean objetos de reloj para guión gráfico. Estos relojes se distribuyen a las propiedades que animan. Por lo que, cuando el <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> se llama al método nuevo, no reinicia sus relojes; lo reemplaza con los relojes de nuevo.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Pause">
      <MemberSignature Language="C#" Value="public void Pause (System.Windows.FrameworkContentElement containingObject);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Pause(class System.Windows.FrameworkContentElement containingObject) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.Pause(System.Windows.FrameworkContentElement)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Pause (containingObject As FrameworkContentElement)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Pause(System::Windows::FrameworkContentElement ^ containingObject);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="containingObject" Type="System.Windows.FrameworkContentElement" />
      </Parameters>
      <Docs>
        <param name="containingObject">Objeto especificado cuando se llamó al método <see cref="M:System.Windows.Media.Animation.Storyboard.Begin(System.Windows.FrameworkContentElement,System.Boolean)" />. Este objeto contiene los objetos <see cref="T:System.Windows.Media.Animation.Clock" /> que se crearon para este guión gráfico y sus elementos secundarios.</param>
        <summary>Pausa el <see cref="T:System.Windows.Media.Animation.Clock" /> del <see cref="T:System.Windows.FrameworkContentElement" /> especificado asociado a este <see cref="T:System.Windows.Media.Animation.Storyboard" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método pone en pausa el guión gráfico, pero no tiene ningún efecto discernible si no está activa o en pausa actualmente. Como efecto secundario, todos los elementos secundarios asociados se pausan también.  
  
 Busca un guión gráfico en pausa no reanuda. La única manera de reanudar un guión gráfico pausado consiste en utilizar el <xref:System.Windows.Media.Animation.Storyboard.Resume%2A> método. Llamar a la <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> método nuevo sustituye el guión gráfico pausado por uno nuevo, lo que tiene el aspecto de reanudara.  
  
 Para controlar este guión gráfico de forma interactiva, debe usar el mismo `containingObject` parámetro al llamar a los métodos interactivos que usó para iniciar el guión gráfico. Un guión gráfico controlable se puede pausar, reanudar, buscar, detener y se quitan. Para realizar un guión gráfico controlable en el código, debe utilizar la sobrecarga adecuada del guión gráfico <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> método y especifique `true` para que sea controlable. Para un ejemplo, vea [Cómo: controlar un guión gráfico después de que se inicia](~/docs/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts.md).  
  
 Pausar desencadenadores de reloj de un guión gráfico la <xref:System.Windows.Media.Animation.Timeline.CurrentGlobalSpeedInvalidated> eventos.  
  
## <a name="beginning-a-paused-storyboard"></a>A partir un guión gráfico en pausa  
 Cuando se <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> un guión gráfico que estaba en pausa, parece reanudar y reiniciar. Sin embargo, es no lo que sucede realmente. El <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> método realmente se reemplaza con una versión no está en pausa. Cada vez que la <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> se llama al método, se crean objetos de reloj para guión gráfico. Estos relojes se distribuyen a las propiedades que animan. Por lo que, cuando el <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> se llama al método nuevo, no reinicia sus relojes; lo reemplaza con los relojes de nuevo.  
  
   
  
## Examples  
 En el ejemplo siguiente se utiliza un guión gráfico controlable para animar un <xref:System.Windows.Media.TextEffect>. El <xref:System.Windows.Media.TextEffect> está dentro de un <xref:System.Windows.FrameworkContentElement>del nombre de ámbito.  
  
 [!code-csharp[StoryboardBeginAnimation_procedural_snip#FrameworkContentElementControlStoryboardExampleUsingWholePage](~/samples/snippets/csharp/VS_Snippets_Wpf/StoryboardBeginAnimation_procedural_snip/CSharp/FrameworkContentElementControlStoryboardExample.cs#frameworkcontentelementcontrolstoryboardexampleusingwholepage)]
 [!code-vb[StoryboardBeginAnimation_procedural_snip#FrameworkContentElementControlStoryboardExampleUsingWholePage](~/samples/snippets/visualbasic/VS_Snippets_Wpf/StoryboardBeginAnimation_procedural_snip/visualbasic/frameworkcontentelementcontrolstoryboardexample.vb#frameworkcontentelementcontrolstoryboardexampleusingwholepage)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Media.Animation.Storyboard.Resume(System.Windows.FrameworkContentElement)" />
      </Docs>
    </Member>
    <Member MemberName="Pause">
      <MemberSignature Language="C#" Value="public void Pause (System.Windows.FrameworkElement containingObject);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Pause(class System.Windows.FrameworkElement containingObject) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.Pause(System.Windows.FrameworkElement)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Pause (containingObject As FrameworkElement)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Pause(System::Windows::FrameworkElement ^ containingObject);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="containingObject" Type="System.Windows.FrameworkElement" />
      </Parameters>
      <Docs>
        <param name="containingObject">Objeto especificado cuando se llamó al método <see cref="M:System.Windows.Media.Animation.Storyboard.Begin(System.Windows.FrameworkElement,System.Boolean)" />. Este objeto contiene los objetos <see cref="T:System.Windows.Media.Animation.Clock" /> que se crearon para este guión gráfico y sus elementos secundarios.</param>
        <summary>Pausa el <see cref="T:System.Windows.Media.Animation.Clock" /> del <see cref="T:System.Windows.FrameworkElement" /> especificado asociado a este <see cref="T:System.Windows.Media.Animation.Storyboard" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método pone en pausa el guión gráfico, pero no tiene ningún efecto discernible si no está activa o en pausa actualmente. Como efecto secundario, todos los elementos secundarios asociados se pausan también.  
  
 Busca un guión gráfico en pausa no reanuda. La única manera de reanudar un guión gráfico pausado consiste en utilizar el <xref:System.Windows.Media.Animation.Storyboard.Resume%2A> método. Llamar a la <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> método nuevo sustituye el guión gráfico pausado por uno nuevo, lo que tiene el aspecto de reanudara.  
  
 Para controlar este guión gráfico de forma interactiva, debe usar el mismo `containingObject` parámetro al llamar a los métodos interactivos que usó para iniciar el guión gráfico. Un guión gráfico controlable se puede pausar, reanudar, buscar, detener y se quitan. Para realizar un guión gráfico controlable en el código, debe utilizar la sobrecarga adecuada del guión gráfico <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> método y especifique `true` para que sea controlable. Para obtener un ejemplo, vea [Cómo: controlar un guión gráfico después de que se inicia](~/docs/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts.md).  
  
 Pausar desencadenadores de reloj de un guión gráfico la <xref:System.Windows.Media.Animation.Timeline.CurrentGlobalSpeedInvalidated> eventos.  
  
## <a name="beginning-a-paused-storyboard"></a>A partir un guión gráfico en pausa  
 Cuando se <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> un guión gráfico que estaba en pausa, parece reanudar y reiniciar. Sin embargo, es no lo que sucede realmente. El <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> método realmente se reemplaza con una versión no está en pausa. Cada vez que la <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> se llama al método, se crean objetos de reloj para guión gráfico. Estos relojes se distribuyen a las propiedades que animan. Por lo que, cuando el <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> se llama al método nuevo, no reinicia sus relojes; lo reemplaza con los relojes de nuevo.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Media.Animation.Storyboard.Resume(System.Windows.FrameworkElement)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Remove">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Quita los objetos <see cref="T:System.Windows.Media.Animation.Clock" /> creados para este <see cref="T:System.Windows.Media.Animation.Storyboard" />. Las animaciones que pertenecen a este <see cref="T:System.Windows.Media.Animation.Storyboard" /> ya no afectan a las propiedades que animaban, independientemente del valor de <see cref="P:System.Windows.Media.Animation.Timeline.FillBehavior" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Remove">
      <MemberSignature Language="C#" Value="public void Remove ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Remove() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.Remove" />
      <MemberSignature Language="VB.NET" Value="Public Sub Remove ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Remove();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Quita los objetos <see cref="T:System.Windows.Media.Animation.Clock" /> creados para este <see cref="T:System.Windows.Media.Animation.Storyboard" />. Las animaciones que pertenecen a este <see cref="T:System.Windows.Media.Animation.Storyboard" /> ya no afectan a las propiedades que animaban, independientemente del valor de <see cref="P:System.Windows.Media.Animation.Timeline.FillBehavior" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un guión gráfico controlable se puede pausar, reanudar, buscar, detener y se quitan. Para realizar un guión gráfico controlable en el código, debe utilizar la sobrecarga adecuada del guión gráfico <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> método y especifique `true` para que sea controlable. Para obtener un ejemplo, vea [Cómo: controlar un guión gráfico después de que se inicia](~/docs/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts.md).  
  
 Todas las acciones interactivas tomadas un <xref:System.Windows.Media.Animation.Clock>y, por tanto, también en un <xref:System.Windows.Media.Animation.Storyboard>, se producen en el siguiente paso del motor de tiempo, lo que sucede poco antes de la siguiente representación. Esto significa que el <xref:System.Windows.Media.Animation.Storyboard.Remove%2A> método todavía afecta a las propiedades animadas hasta ese momento. En otras palabras, la próxima vez que se muestra el marco, se quita el guión gráfico. Si necesita desasociar una animación de una propiedad antes de ese momento, use la <xref:System.Windows.UIElement.BeginAnimation%2A> método con un `animation` valor del parámetro de `null`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Remove">
      <MemberSignature Language="C#" Value="public void Remove (System.Windows.FrameworkContentElement containingObject);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Remove(class System.Windows.FrameworkContentElement containingObject) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.Remove(System.Windows.FrameworkContentElement)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Remove (containingObject As FrameworkContentElement)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Remove(System::Windows::FrameworkContentElement ^ containingObject);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="containingObject" Type="System.Windows.FrameworkContentElement" />
      </Parameters>
      <Docs>
        <param name="containingObject">Objeto especificado cuando se llamó al método <see cref="M:System.Windows.Media.Animation.Storyboard.Begin(System.Windows.FrameworkContentElement,System.Boolean)" />. Este objeto contiene los objetos <see cref="T:System.Windows.Media.Animation.Clock" /> que se crearon para este guión gráfico y sus elementos secundarios.</param>
        <summary>Quita los objetos <see cref="T:System.Windows.Media.Animation.Clock" /> creados para este <see cref="T:System.Windows.Media.Animation.Storyboard" />. Las animaciones que pertenecen a este <see cref="T:System.Windows.Media.Animation.Storyboard" /> ya no afectan a las propiedades que animaban, independientemente del valor de <see cref="P:System.Windows.Media.Animation.Timeline.FillBehavior" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para controlar este guión gráfico de forma interactiva, debe usar el mismo `containingObject` parámetro al llamar a los métodos interactivos que usó para iniciar el guión gráfico. Un guión gráfico controlable se puede pausar, reanudar, buscar, detener y se quitan. Para realizar un guión gráfico controlable en el código, debe utilizar la sobrecarga adecuada del guión gráfico <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> método y especifique `true` para que sea controlable. Para obtener un ejemplo, vea [Cómo: controlar un guión gráfico después de que se inicia](~/docs/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts.md).  
  
 Eliminar desencadenadores de reloj de un guión gráfico la <xref:System.Windows.Media.Animation.Timeline.RemoveRequested> eventos.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Remove">
      <MemberSignature Language="C#" Value="public void Remove (System.Windows.FrameworkElement containingObject);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Remove(class System.Windows.FrameworkElement containingObject) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.Remove(System.Windows.FrameworkElement)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Remove (containingObject As FrameworkElement)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Remove(System::Windows::FrameworkElement ^ containingObject);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="containingObject" Type="System.Windows.FrameworkElement" />
      </Parameters>
      <Docs>
        <param name="containingObject">Objeto especificado cuando se llamó al método <see cref="M:System.Windows.Media.Animation.Storyboard.Begin(System.Windows.FrameworkElement,System.Boolean)" />. Este objeto contiene los objetos <see cref="T:System.Windows.Media.Animation.Clock" /> que se crearon para este guión gráfico y sus elementos secundarios.</param>
        <summary>Quita los objetos <see cref="T:System.Windows.Media.Animation.Clock" /> creados para este <see cref="T:System.Windows.Media.Animation.Storyboard" />. Las animaciones que pertenecen a este <see cref="T:System.Windows.Media.Animation.Storyboard" /> ya no afectan a las propiedades que animaban, independientemente del valor de <see cref="P:System.Windows.Media.Animation.Timeline.FillBehavior" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para controlar este guión gráfico de forma interactiva, debe usar el mismo `containingObject` parámetro al llamar a los métodos interactivos que usó para iniciar el guión gráfico. Un guión gráfico controlable se puede pausar, reanudar, buscar, detener y se quitan. Para realizar un guión gráfico controlable en el código, debe utilizar la sobrecarga adecuada del guión gráfico <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> método y especifique `true` para que sea controlable. Para obtener un ejemplo, vea [Cómo: controlar un guión gráfico después de que se inicia](~/docs/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts.md).  
  
 Eliminar desencadenadores de reloj de un guión gráfico la <xref:System.Windows.Media.Animation.Timeline.RemoveRequested> eventos.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Resume">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Reanuda el objeto <see cref="T:System.Windows.Media.Animation.Clock" /> creado para este <see cref="T:System.Windows.Media.Animation.Storyboard" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Resume">
      <MemberSignature Language="C#" Value="public void Resume ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Resume() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.Resume" />
      <MemberSignature Language="VB.NET" Value="Public Sub Resume ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Resume();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Reanuda el objeto <see cref="T:System.Windows.Media.Animation.Clock" /> creado para este <see cref="T:System.Windows.Media.Animation.Storyboard" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un guión gráfico controlable se puede pausar, reanudar, buscar, detener y se quitan. Para realizar un guión gráfico controlable en el código, debe utilizar la sobrecarga adecuada del guión gráfico <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> método y especifique `true` para que sea controlable. Para obtener un ejemplo, vea [Cómo: controlar un guión gráfico después de que se inicia](~/docs/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Resume">
      <MemberSignature Language="C#" Value="public void Resume (System.Windows.FrameworkContentElement containingObject);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Resume(class System.Windows.FrameworkContentElement containingObject) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.Resume(System.Windows.FrameworkContentElement)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Resume (containingObject As FrameworkContentElement)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Resume(System::Windows::FrameworkContentElement ^ containingObject);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="containingObject" Type="System.Windows.FrameworkContentElement" />
      </Parameters>
      <Docs>
        <param name="containingObject">Objeto especificado cuando se llamó al método <see cref="M:System.Windows.Media.Animation.Storyboard.Begin(System.Windows.FrameworkContentElement,System.Boolean)" />. Este objeto contiene los objetos <see cref="T:System.Windows.Media.Animation.Clock" /> que se crearon para este guión gráfico y sus elementos secundarios.</param>
        <summary>Reanuda el objeto <see cref="T:System.Windows.Media.Animation.Clock" /> creado para este <see cref="T:System.Windows.Media.Animation.Storyboard" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Reanudar un guión gráfico que no está en pausa no tiene ningún efecto.  
  
 Para controlar este guión gráfico de forma interactiva, debe usar el mismo `containingObject` parámetro al llamar a los métodos interactivos que usó para iniciar el guión gráfico. Un guión gráfico controlable se puede pausar, reanudar, buscar, detener y se quitan. Para realizar un guión gráfico controlable en el código, debe utilizar la sobrecarga adecuada del guión gráfico <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> método y especifique `true` para que sea controlable. Para obtener un ejemplo, vea [Cómo: controlar un guión gráfico después de que se inicia](~/docs/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts.md).  
  
 Busca un guión gráfico en pausa no reanuda. La única manera de reanudar un guión gráfico pausado consiste en utilizar el <xref:System.Windows.Media.Animation.Storyboard.Resume%2A> método. Llamar a la <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> método después de que se ha iniciado el guión gráfico reemplaza el guión gráfico anterior, que tiene el aspecto de reanudara.  
  
 Reanudar un reloj de un guión gráfico desencadena pausado el <xref:System.Windows.Media.Animation.Timeline.CurrentGlobalSpeedInvalidated> eventos.  
  
   
  
## Examples  
 En el ejemplo siguiente se utiliza un guión gráfico controlable para animar un <xref:System.Windows.Media.TextEffect>. El <xref:System.Windows.Media.TextEffect> está dentro de un <xref:System.Windows.FrameworkContentElement>del nombre de ámbito.  
  
 [!code-csharp[StoryboardBeginAnimation_procedural_snip#FrameworkContentElementControlStoryboardExampleUsingWholePage](~/samples/snippets/csharp/VS_Snippets_Wpf/StoryboardBeginAnimation_procedural_snip/CSharp/FrameworkContentElementControlStoryboardExample.cs#frameworkcontentelementcontrolstoryboardexampleusingwholepage)]
 [!code-vb[StoryboardBeginAnimation_procedural_snip#FrameworkContentElementControlStoryboardExampleUsingWholePage](~/samples/snippets/visualbasic/VS_Snippets_Wpf/StoryboardBeginAnimation_procedural_snip/visualbasic/frameworkcontentelementcontrolstoryboardexample.vb#frameworkcontentelementcontrolstoryboardexampleusingwholepage)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Media.Animation.Storyboard.Pause(System.Windows.FrameworkContentElement)" />
      </Docs>
    </Member>
    <Member MemberName="Resume">
      <MemberSignature Language="C#" Value="public void Resume (System.Windows.FrameworkElement containingObject);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Resume(class System.Windows.FrameworkElement containingObject) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.Resume(System.Windows.FrameworkElement)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Resume (containingObject As FrameworkElement)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Resume(System::Windows::FrameworkElement ^ containingObject);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="containingObject" Type="System.Windows.FrameworkElement" />
      </Parameters>
      <Docs>
        <param name="containingObject">Objeto especificado cuando se llamó al método <see cref="M:System.Windows.Media.Animation.Storyboard.Begin(System.Windows.FrameworkElement,System.Boolean)" />. Este objeto contiene los objetos <see cref="T:System.Windows.Media.Animation.Clock" /> que se crearon para este guión gráfico y sus elementos secundarios.</param>
        <summary>Reanuda el objeto <see cref="T:System.Windows.Media.Animation.Clock" /> creado para este <see cref="T:System.Windows.Media.Animation.Storyboard" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Reanudar un guión gráfico que no está en pausa no tiene ningún efecto.  
  
 Para controlar este guión gráfico de forma interactiva, debe usar el mismo `containingObject` parámetro al llamar a los métodos interactivos que usó para iniciar el guión gráfico. Un guión gráfico controlable se puede pausar, reanudar, buscar, detener y se quitan. Para realizar un guión gráfico controlable en el código, debe utilizar la sobrecarga adecuada del guión gráfico <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> método y especifique `true` para que sea controlable. Para obtener un ejemplo, vea [Cómo: controlar un guión gráfico después de que se inicia](~/docs/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts.md).  
  
 Busca un guión gráfico en pausa no reanuda. La única manera de reanudar un guión gráfico pausado consiste en utilizar el <xref:System.Windows.Media.Animation.Storyboard.Resume%2A> método. Llamar a la <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> método después de que se ha iniciado el guión gráfico reemplaza el guión gráfico anterior, que tiene el aspecto de reanudara.  
  
 Reanudar un reloj de un guión gráfico desencadena pausado el <xref:System.Windows.Media.Animation.Timeline.CurrentGlobalSpeedInvalidated> eventos.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Media.Animation.Storyboard.Pause(System.Windows.FrameworkElement)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Seek">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Busca este objeto <see cref="T:System.Windows.Media.Animation.Storyboard" /> en una nueva posición cuando tiene lugar el siguiente paso del reloj.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Seek">
      <MemberSignature Language="C#" Value="public void Seek (TimeSpan offset);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Seek(valuetype System.TimeSpan offset) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.Seek(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Seek (offset As TimeSpan)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Seek(TimeSpan offset);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="offset" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="offset">Valor positivo o negativo que describe cuánto debe avanzar o retroceder la escala de tiempo.</param>
        <summary>Busca este objeto <see cref="T:System.Windows.Media.Animation.Storyboard" /> en la posición especificada. <see cref="T:System.Windows.Media.Animation.Storyboard" /> realiza la búsqueda solicitada cuando tiene lugar el siguiente paso del reloj.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Tenga en cuenta que las operaciones de búsqueda no hace del guión gráfico <xref:System.Windows.Media.Animation.Timeline.SpeedRatio%2A> o <xref:System.Windows.Media.Animation.ParallelTimeline.SlipBehavior%2A> la configuración de cuenta. El guión gráfico se trata como si tuviese un <xref:System.Windows.Media.Animation.Timeline.SpeedRatio%2A> 1 y n <xref:System.Windows.Media.Animation.ParallelTimeline.SlipBehavior%2A>.  
  
 Para controlar este guión gráfico de forma interactiva, debe usar el mismo `containingObject` parámetro al llamar a los métodos interactivos que usó para iniciar el guión gráfico. Un guión gráfico controlable se puede pausar, reanudar, buscar, detener y se quitan. Para realizar un guión gráfico controlable en el código, debe utilizar la sobrecarga adecuada del guión gráfico <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> método y especifique `true` para que sea controlable. Para obtener un ejemplo, vea [Cómo: controlar un guión gráfico después de que se inicia](~/docs/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Seek">
      <MemberSignature Language="C#" Value="public void Seek (TimeSpan offset, System.Windows.Media.Animation.TimeSeekOrigin origin);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Seek(valuetype System.TimeSpan offset, valuetype System.Windows.Media.Animation.TimeSeekOrigin origin) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.Seek(System.TimeSpan,System.Windows.Media.Animation.TimeSeekOrigin)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Seek (offset As TimeSpan, origin As TimeSeekOrigin)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Seek(TimeSpan offset, System::Windows::Media::Animation::TimeSeekOrigin origin);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="offset" Type="System.TimeSpan" />
        <Parameter Name="origin" Type="System.Windows.Media.Animation.TimeSeekOrigin" />
      </Parameters>
      <Docs>
        <param name="offset">Valor positivo o negativo que describe cuánto debe avanzar o retroceder la escala de tiempo desde el <c>origin</c> especificado.</param>
        <param name="origin">Posición desde la que se aplica <c>offset</c>.</param>
        <summary>Busca este objeto <see cref="T:System.Windows.Media.Animation.Storyboard" /> en la posición especificada. <see cref="T:System.Windows.Media.Animation.Storyboard" /> realiza la búsqueda solicitada cuando tiene lugar el siguiente paso del reloj.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Tenga en cuenta que las operaciones de búsqueda no hace del guión gráfico <xref:System.Windows.Media.Animation.Timeline.SpeedRatio%2A> o <xref:System.Windows.Media.Animation.ParallelTimeline.SlipBehavior%2A> la configuración de cuenta. El guión gráfico se trata como si tuviese un <xref:System.Windows.Media.Animation.Timeline.SpeedRatio%2A> 1 y n <xref:System.Windows.Media.Animation.ParallelTimeline.SlipBehavior%2A>.  
  
 Para controlar este guión gráfico de forma interactiva, debe usar el mismo `containingObject` parámetro al llamar a los métodos interactivos que usó para iniciar el guión gráfico. Un guión gráfico controlable se puede pausar, reanudar, buscar, detener y se quitan. Para realizar un guión gráfico controlable en el código, debe utilizar la sobrecarga adecuada del guión gráfico <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> método y especifique `true` para que sea controlable. Para obtener un ejemplo, vea [Cómo: controlar un guión gráfico después de que se inicia](~/docs/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Seek">
      <MemberSignature Language="C#" Value="public void Seek (System.Windows.FrameworkContentElement containingObject, TimeSpan offset, System.Windows.Media.Animation.TimeSeekOrigin origin);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Seek(class System.Windows.FrameworkContentElement containingObject, valuetype System.TimeSpan offset, valuetype System.Windows.Media.Animation.TimeSeekOrigin origin) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.Seek(System.Windows.FrameworkContentElement,System.TimeSpan,System.Windows.Media.Animation.TimeSeekOrigin)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Seek (containingObject As FrameworkContentElement, offset As TimeSpan, origin As TimeSeekOrigin)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Seek(System::Windows::FrameworkContentElement ^ containingObject, TimeSpan offset, System::Windows::Media::Animation::TimeSeekOrigin origin);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="containingObject" Type="System.Windows.FrameworkContentElement" />
        <Parameter Name="offset" Type="System.TimeSpan" />
        <Parameter Name="origin" Type="System.Windows.Media.Animation.TimeSeekOrigin" />
      </Parameters>
      <Docs>
        <param name="containingObject">Objeto especificado cuando se llamó al método <see cref="M:System.Windows.Media.Animation.Storyboard.Begin(System.Windows.FrameworkContentElement,System.Boolean)" />. Este objeto contiene los objetos <see cref="T:System.Windows.Media.Animation.Clock" /> que se crearon para este guión gráfico y sus elementos secundarios.</param>
        <param name="offset">Valor positivo o negativo que describe cuánto debe avanzar o retroceder la escala de tiempo desde el <c>origin</c> especificado.</param>
        <param name="origin">Posición desde la que se aplica <c>offset</c>.</param>
        <summary>Busca este objeto <see cref="T:System.Windows.Media.Animation.Storyboard" /> en la posición especificada. <see cref="T:System.Windows.Media.Animation.Storyboard" /> realiza la búsqueda solicitada cuando tiene lugar el siguiente paso del reloj.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Tenga en cuenta que las operaciones de búsqueda no hace del guión gráfico <xref:System.Windows.Media.Animation.Timeline.SpeedRatio%2A> o <xref:System.Windows.Media.Animation.ParallelTimeline.SlipBehavior%2A> la configuración de cuenta. El guión gráfico se trata como si tuviese un <xref:System.Windows.Media.Animation.Timeline.SpeedRatio%2A> 1 y n <xref:System.Windows.Media.Animation.ParallelTimeline.SlipBehavior%2A>.  
  
 Este método cambia el reloj de guión gráfico <xref:System.Windows.Media.Animation.Clock.CurrentState%2A> a <xref:System.Windows.Media.Animation.ClockState.Active>. Este método no tiene ningún efecto en el árbol de control de tiempo hasta la próxima vez que se procesa una marca de verificación. Como efecto secundario, los eventos adecuados también no se generan hasta ese momento.  
  
 Para controlar este guión gráfico de forma interactiva, debe usar el mismo `containingObject` parámetro al llamar a los métodos interactivos que usó para iniciar el guión gráfico. Un guión gráfico controlable se puede pausar, reanudar, buscar, detener y se quitan. Para realizar un guión gráfico controlable en el código, debe utilizar la sobrecarga adecuada del guión gráfico <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> método y especifique `true` para que sea controlable. Para obtener un ejemplo, vea [Cómo: controlar un guión gráfico después de que se inicia](~/docs/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts.md).  
  
 Operaciones de búsqueda activa un guión gráfico la <xref:System.Windows.Media.Animation.Timeline.CurrentGlobalSpeedInvalidated> y <xref:System.Windows.Media.Animation.Timeline.CurrentStateInvalidated> eventos.  
  
   
  
## Examples  
 En el ejemplo siguiente se muestra la <xref:System.Windows.Media.Animation.Storyboard.Seek%2A> y <xref:System.Windows.Media.Animation.Storyboard.SeekAlignedToLastTick%2A> métodos.  
  
 [!code-csharp[StoryboardBeginAnimation_procedural_snip#FrameworkContentElementSeekExampleUsingWholePage](~/samples/snippets/csharp/VS_Snippets_Wpf/StoryboardBeginAnimation_procedural_snip/CSharp/FrameworkContentElementSeekExample.cs#frameworkcontentelementseekexampleusingwholepage)]
 [!code-vb[StoryboardBeginAnimation_procedural_snip#FrameworkContentElementSeekExampleUsingWholePage](~/samples/snippets/visualbasic/VS_Snippets_Wpf/StoryboardBeginAnimation_procedural_snip/visualbasic/frameworkcontentelementseekexample.vb#frameworkcontentelementseekexampleusingwholepage)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Seek">
      <MemberSignature Language="C#" Value="public void Seek (System.Windows.FrameworkElement containingObject, TimeSpan offset, System.Windows.Media.Animation.TimeSeekOrigin origin);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Seek(class System.Windows.FrameworkElement containingObject, valuetype System.TimeSpan offset, valuetype System.Windows.Media.Animation.TimeSeekOrigin origin) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.Seek(System.Windows.FrameworkElement,System.TimeSpan,System.Windows.Media.Animation.TimeSeekOrigin)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Seek (containingObject As FrameworkElement, offset As TimeSpan, origin As TimeSeekOrigin)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Seek(System::Windows::FrameworkElement ^ containingObject, TimeSpan offset, System::Windows::Media::Animation::TimeSeekOrigin origin);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="containingObject" Type="System.Windows.FrameworkElement" />
        <Parameter Name="offset" Type="System.TimeSpan" />
        <Parameter Name="origin" Type="System.Windows.Media.Animation.TimeSeekOrigin" />
      </Parameters>
      <Docs>
        <param name="containingObject">Objeto especificado cuando se llamó al método <see cref="M:System.Windows.Media.Animation.Storyboard.Begin(System.Windows.FrameworkElement,System.Boolean)" />. Este objeto contiene los objetos <see cref="T:System.Windows.Media.Animation.Clock" /> que se crearon para este guión gráfico y sus elementos secundarios.</param>
        <param name="offset">Valor positivo o negativo que describe cuánto debe avanzar o retroceder la escala de tiempo desde el <c>origin</c> especificado.</param>
        <param name="origin">Posición desde la que se aplica <c>offset</c>.</param>
        <summary>Busca este objeto <see cref="T:System.Windows.Media.Animation.Storyboard" /> en la posición especificada. <see cref="T:System.Windows.Media.Animation.Storyboard" /> realiza la búsqueda solicitada cuando tiene lugar el siguiente paso del reloj.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Tenga en cuenta que las operaciones de búsqueda no hace del guión gráfico <xref:System.Windows.Media.Animation.Timeline.SpeedRatio%2A> o <xref:System.Windows.Media.Animation.ParallelTimeline.SlipBehavior%2A> la configuración de cuenta. El guión gráfico se trata como si tuviese un <xref:System.Windows.Media.Animation.Timeline.SpeedRatio%2A> 1 y n <xref:System.Windows.Media.Animation.ParallelTimeline.SlipBehavior%2A>.  
  
 Este método cambia el reloj de guión gráfico <xref:System.Windows.Media.Animation.Clock.CurrentState%2A> a <xref:System.Windows.Media.Animation.ClockState.Active>. Este método no tiene ningún efecto en el árbol de control de tiempo hasta la próxima vez que se procesa una marca de verificación. Como efecto secundario, los eventos adecuados también no se generan hasta ese momento.  
  
 Para controlar este guión gráfico de forma interactiva, debe usar el mismo `containingObject` parámetro al llamar a los métodos interactivos que usó para iniciar el guión gráfico. Un guión gráfico controlable se puede pausar, reanudar, buscar, detener y puede quitar si se establece como controlable. Para realizar un guión gráfico controlable en el código, debe utilizar la sobrecarga adecuada del guión gráfico <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> método y especifique `true` para que sea controlable. Para obtener un ejemplo, vea [Cómo: controlar un guión gráfico después de que se inicia](~/docs/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts.md).  
  
 Operaciones de búsqueda activa un guión gráfico la <xref:System.Windows.Media.Animation.Timeline.CurrentGlobalSpeedInvalidated> y <xref:System.Windows.Media.Animation.Timeline.CurrentStateInvalidated> eventos.  
  
   
  
## Examples  
 En el ejemplo siguiente se muestra cómo buscar (omitir) a un segundo después de inicia un guión gráfico.  
  
 [!code-csharp[timingbehaviors_procedural_snip#SeekStoryboardExampleWholePage](~/samples/snippets/csharp/VS_Snippets_Wpf/timingbehaviors_procedural_snip/CSharp/SeekStoryboardExample.cs#seekstoryboardexamplewholepage)]
 [!code-vb[timingbehaviors_procedural_snip#SeekStoryboardExampleWholePage](~/samples/snippets/visualbasic/VS_Snippets_Wpf/timingbehaviors_procedural_snip/visualbasic/seekstoryboardexample.vb#seekstoryboardexamplewholepage)]  
  
 En el ejemplo siguiente se muestra la <xref:System.Windows.Media.Animation.Storyboard.Seek%2A> y <xref:System.Windows.Media.Animation.Storyboard.SeekAlignedToLastTick%2A> métodos.  
  
 [!code-csharp[StoryboardBeginAnimation_procedural_snip#SeekExampleUsingWholePage](~/samples/snippets/csharp/VS_Snippets_Wpf/StoryboardBeginAnimation_procedural_snip/CSharp/SeekExample.cs#seekexampleusingwholepage)]
 [!code-vb[StoryboardBeginAnimation_procedural_snip#SeekExampleUsingWholePage](~/samples/snippets/visualbasic/VS_Snippets_Wpf/StoryboardBeginAnimation_procedural_snip/visualbasic/seekexample.vb#seekexampleusingwholepage)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Media.Animation.Storyboard.SeekAlignedToLastTick(System.Windows.FrameworkElement,System.TimeSpan,System.Windows.Media.Animation.TimeSeekOrigin)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="SeekAlignedToLastTick">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Busca de forma inmediata (sincrónicamente) este objeto <see cref="T:System.Windows.Media.Animation.Storyboard" /> en una nueva posición.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SeekAlignedToLastTick">
      <MemberSignature Language="C#" Value="public void SeekAlignedToLastTick (TimeSpan offset);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SeekAlignedToLastTick(valuetype System.TimeSpan offset) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.SeekAlignedToLastTick(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SeekAlignedToLastTick (offset As TimeSpan)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SeekAlignedToLastTick(TimeSpan offset);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="offset" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="offset">Valor positivo o negativo que describe cuánto debe avanzar o retroceder la escala de tiempo.</param>
        <summary>Busca de forma inmediata (sincrónicamente) este objeto <see cref="T:System.Windows.Media.Animation.Storyboard" /> en una nueva posición.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Media.Animation.Storyboard.SeekAlignedToLastTick%2A> Alinea la hora buscada de la <xref:System.Windows.Media.Animation.Storyboard> con el último ciclo de reloj. Los valores se actualizan inmediatamente para reflejar los cambios debido a <xref:System.Windows.Media.Animation.Storyboard.SeekAlignedToLastTick%2A>, aunque la pantalla no refleja estos cambios hasta que las actualizaciones de la pantalla.  
  
 Tenga en cuenta que las operaciones de búsqueda no hace del guión gráfico <xref:System.Windows.Media.Animation.Timeline.SpeedRatio%2A> o <xref:System.Windows.Media.Animation.ParallelTimeline.SlipBehavior%2A> la configuración de cuenta. El guión gráfico se trata como si tuviese un <xref:System.Windows.Media.Animation.Timeline.SpeedRatio%2A> 1 y n <xref:System.Windows.Media.Animation.ParallelTimeline.SlipBehavior%2A>.  
  
 Para realizar un guión gráfico controlable en el código, debe utilizar la sobrecarga adecuada del guión gráfico <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> método y especifique `true` para que sea controlable. Para obtener un ejemplo, vea [Cómo: controlar un guión gráfico después de que se inicia](~/docs/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SeekAlignedToLastTick">
      <MemberSignature Language="C#" Value="public void SeekAlignedToLastTick (TimeSpan offset, System.Windows.Media.Animation.TimeSeekOrigin origin);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SeekAlignedToLastTick(valuetype System.TimeSpan offset, valuetype System.Windows.Media.Animation.TimeSeekOrigin origin) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.SeekAlignedToLastTick(System.TimeSpan,System.Windows.Media.Animation.TimeSeekOrigin)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SeekAlignedToLastTick (offset As TimeSpan, origin As TimeSeekOrigin)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SeekAlignedToLastTick(TimeSpan offset, System::Windows::Media::Animation::TimeSeekOrigin origin);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="offset" Type="System.TimeSpan" />
        <Parameter Name="origin" Type="System.Windows.Media.Animation.TimeSeekOrigin" />
      </Parameters>
      <Docs>
        <param name="offset">Valor positivo o negativo que describe cuánto debe avanzar o retroceder la escala de tiempo desde el <c>origin</c> especificado.</param>
        <param name="origin">Posición desde la que se aplica <c>offset</c>.</param>
        <summary>Busca de forma inmediata (sincrónicamente) este objeto <see cref="T:System.Windows.Media.Animation.Storyboard" /> en una nueva posición.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Media.Animation.Storyboard.SeekAlignedToLastTick%2A> Alinea la hora buscada de la <xref:System.Windows.Media.Animation.Storyboard> con el último ciclo de reloj. Los valores se actualizan inmediatamente para reflejar los cambios debido a <xref:System.Windows.Media.Animation.Storyboard.SeekAlignedToLastTick%2A>, aunque la pantalla no refleja estos cambios hasta que las actualizaciones de la pantalla.  
  
 Tenga en cuenta que las operaciones de búsqueda no hace del guión gráfico <xref:System.Windows.Media.Animation.Timeline.SpeedRatio%2A> o <xref:System.Windows.Media.Animation.ParallelTimeline.SlipBehavior%2A> la configuración de cuenta. El guión gráfico se trata como si tuviese un <xref:System.Windows.Media.Animation.Timeline.SpeedRatio%2A> 1 y n <xref:System.Windows.Media.Animation.ParallelTimeline.SlipBehavior%2A>.  
  
 Para realizar un guión gráfico controlable en el código, debe utilizar la sobrecarga adecuada del guión gráfico <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> método y especifique `true` para que sea controlable. Para obtener un ejemplo, vea [Cómo: controlar un guión gráfico después de que se inicia](~/docs/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SeekAlignedToLastTick">
      <MemberSignature Language="C#" Value="public void SeekAlignedToLastTick (System.Windows.FrameworkContentElement containingObject, TimeSpan offset, System.Windows.Media.Animation.TimeSeekOrigin origin);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SeekAlignedToLastTick(class System.Windows.FrameworkContentElement containingObject, valuetype System.TimeSpan offset, valuetype System.Windows.Media.Animation.TimeSeekOrigin origin) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.SeekAlignedToLastTick(System.Windows.FrameworkContentElement,System.TimeSpan,System.Windows.Media.Animation.TimeSeekOrigin)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SeekAlignedToLastTick (containingObject As FrameworkContentElement, offset As TimeSpan, origin As TimeSeekOrigin)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SeekAlignedToLastTick(System::Windows::FrameworkContentElement ^ containingObject, TimeSpan offset, System::Windows::Media::Animation::TimeSeekOrigin origin);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="containingObject" Type="System.Windows.FrameworkContentElement" />
        <Parameter Name="offset" Type="System.TimeSpan" />
        <Parameter Name="origin" Type="System.Windows.Media.Animation.TimeSeekOrigin" />
      </Parameters>
      <Docs>
        <param name="containingObject">Objeto especificado cuando se llamó al método <see cref="M:System.Windows.Media.Animation.Storyboard.Begin(System.Windows.FrameworkContentElement,System.Boolean)" />. Este objeto contiene los objetos <see cref="T:System.Windows.Media.Animation.Clock" /> que se crearon para este guión gráfico y sus elementos secundarios.</param>
        <param name="offset">Valor positivo o negativo que describe cuánto debe avanzar o retroceder la escala de tiempo desde el <c>origin</c> especificado.</param>
        <param name="origin">Posición desde la que se aplica <c>offset</c>.</param>
        <summary>Busca de forma inmediata (sincrónicamente) este objeto <see cref="T:System.Windows.Media.Animation.Storyboard" /> en una nueva posición.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Media.Animation.Storyboard.SeekAlignedToLastTick%2A> Alinea la hora buscada de la <xref:System.Windows.Media.Animation.Storyboard> con el último ciclo de reloj. Los valores se actualizan inmediatamente para reflejar los cambios debido a <xref:System.Windows.Media.Animation.Storyboard.SeekAlignedToLastTick%2A>, aunque la pantalla no refleja estos cambios hasta que las actualizaciones de la pantalla.  
  
 Tenga en cuenta que las operaciones de búsqueda no hace del guión gráfico <xref:System.Windows.Media.Animation.Timeline.SpeedRatio%2A> o <xref:System.Windows.Media.Animation.ParallelTimeline.SlipBehavior%2A> la configuración de cuenta. El guión gráfico se trata como si tuviese un <xref:System.Windows.Media.Animation.Timeline.SpeedRatio%2A> 1 y n <xref:System.Windows.Media.Animation.ParallelTimeline.SlipBehavior%2A>.  
  
 Este método cambia el reloj de guión gráfico <xref:System.Windows.Media.Animation.Clock.CurrentState%2A> a  
  
 <xref:System.Windows.Media.Animation.ClockState.Active>.  
  
 Operaciones de búsqueda activa un guión gráfico la <xref:System.Windows.Media.Animation.Timeline.CurrentGlobalSpeedInvalidated> y <xref:System.Windows.Media.Animation.Timeline.CurrentStateInvalidated> eventos.  
  
 Para controlar este guión gráfico de forma interactiva, debe usar el mismo `containingObject` parámetro al llamar a los métodos interactivos que usó para iniciar el guión gráfico. Un guión gráfico controlable se puede pausar, reanudar, buscar, detener y se quitan. Para realizar un guión gráfico controlable en el código, debe utilizar la sobrecarga adecuada del guión gráfico <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> método y especifique `true` para que sea controlable. Para obtener un ejemplo, vea [Cómo: controlar un guión gráfico después de que se inicia](~/docs/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts.md).  
  
   
  
## Examples  
 En el ejemplo siguiente se muestra la <xref:System.Windows.Media.Animation.Storyboard.Seek%2A> y <xref:System.Windows.Media.Animation.Storyboard.SeekAlignedToLastTick%2A> métodos.  
  
 [!code-csharp[StoryboardBeginAnimation_procedural_snip#FrameworkContentElementSeekExampleUsingWholePage](~/samples/snippets/csharp/VS_Snippets_Wpf/StoryboardBeginAnimation_procedural_snip/CSharp/FrameworkContentElementSeekExample.cs#frameworkcontentelementseekexampleusingwholepage)]
 [!code-vb[StoryboardBeginAnimation_procedural_snip#FrameworkContentElementSeekExampleUsingWholePage](~/samples/snippets/visualbasic/VS_Snippets_Wpf/StoryboardBeginAnimation_procedural_snip/visualbasic/frameworkcontentelementseekexample.vb#frameworkcontentelementseekexampleusingwholepage)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SeekAlignedToLastTick">
      <MemberSignature Language="C#" Value="public void SeekAlignedToLastTick (System.Windows.FrameworkElement containingObject, TimeSpan offset, System.Windows.Media.Animation.TimeSeekOrigin origin);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SeekAlignedToLastTick(class System.Windows.FrameworkElement containingObject, valuetype System.TimeSpan offset, valuetype System.Windows.Media.Animation.TimeSeekOrigin origin) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.SeekAlignedToLastTick(System.Windows.FrameworkElement,System.TimeSpan,System.Windows.Media.Animation.TimeSeekOrigin)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SeekAlignedToLastTick (containingObject As FrameworkElement, offset As TimeSpan, origin As TimeSeekOrigin)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SeekAlignedToLastTick(System::Windows::FrameworkElement ^ containingObject, TimeSpan offset, System::Windows::Media::Animation::TimeSeekOrigin origin);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="containingObject" Type="System.Windows.FrameworkElement" />
        <Parameter Name="offset" Type="System.TimeSpan" />
        <Parameter Name="origin" Type="System.Windows.Media.Animation.TimeSeekOrigin" />
      </Parameters>
      <Docs>
        <param name="containingObject">Objeto especificado cuando se llamó al método <see cref="M:System.Windows.Media.Animation.Storyboard.Begin(System.Windows.FrameworkElement,System.Boolean)" />. Este objeto contiene los objetos <see cref="T:System.Windows.Media.Animation.Clock" /> que se crearon para este guión gráfico y sus elementos secundarios.</param>
        <param name="offset">Valor positivo o negativo que describe cuánto debe avanzar o retroceder la escala de tiempo desde el <c>origin</c> especificado.</param>
        <param name="origin">Posición desde la que se aplica <c>offset</c>.</param>
        <summary>Busca de forma inmediata (sincrónicamente) este objeto <see cref="T:System.Windows.Media.Animation.Storyboard" /> en una nueva posición.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Media.Animation.Storyboard.SeekAlignedToLastTick%2A> Alinea la hora buscada de la <xref:System.Windows.Media.Animation.Storyboard> con el último ciclo de reloj. Los valores se actualizan inmediatamente para reflejar los cambios debido a <xref:System.Windows.Media.Animation.Storyboard.SeekAlignedToLastTick%2A>, aunque la pantalla no refleja estos cambios hasta que las actualizaciones de la pantalla.  
  
 Tenga en cuenta que las operaciones de búsqueda no hace del guión gráfico <xref:System.Windows.Media.Animation.Timeline.SpeedRatio%2A> o <xref:System.Windows.Media.Animation.ParallelTimeline.SlipBehavior%2A> la configuración de cuenta. El guión gráfico se trata como si tuviese un <xref:System.Windows.Media.Animation.Timeline.SpeedRatio%2A> 1 y n <xref:System.Windows.Media.Animation.ParallelTimeline.SlipBehavior%2A>.  
  
 Este método cambia el reloj de guión gráfico <xref:System.Windows.Media.Animation.Clock.CurrentState%2A> a  
  
 <xref:System.Windows.Media.Animation.ClockState.Active>.  
  
 Operaciones de búsqueda activa un guión gráfico la <xref:System.Windows.Media.Animation.Timeline.CurrentGlobalSpeedInvalidated> y <xref:System.Windows.Media.Animation.Timeline.CurrentStateInvalidated> eventos.  
  
 Para controlar este guión gráfico de forma interactiva, debe usar el mismo `containingObject` parámetro al llamar a los métodos interactivos que usó para iniciar el guión gráfico. Un guión gráfico controlable se puede pausar, reanudar, buscar, detener y se quitan. Para realizar un guión gráfico controlable en el código, debe utilizar la sobrecarga adecuada del guión gráfico <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> método y especifique `true` para que sea controlable. Para obtener un ejemplo, vea [Cómo: controlar un guión gráfico después de que se inicia](~/docs/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts.md).  
  
   
  
## Examples  
 En el ejemplo siguiente se muestra la <xref:System.Windows.Media.Animation.Storyboard.Seek%2A> y <xref:System.Windows.Media.Animation.Storyboard.SeekAlignedToLastTick%2A> métodos.  
  
 [!code-csharp[StoryboardBeginAnimation_procedural_snip#SeekExampleUsingWholePage](~/samples/snippets/csharp/VS_Snippets_Wpf/StoryboardBeginAnimation_procedural_snip/CSharp/SeekExample.cs#seekexampleusingwholepage)]
 [!code-vb[StoryboardBeginAnimation_procedural_snip#SeekExampleUsingWholePage](~/samples/snippets/visualbasic/VS_Snippets_Wpf/StoryboardBeginAnimation_procedural_snip/visualbasic/seekexample.vb#seekexampleusingwholepage)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="SetSpeedRatio">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Establece la relación de velocidad interactiva del objeto <see cref="T:System.Windows.Media.Animation.Clock" /> que se creó para este objeto <see cref="T:System.Windows.Media.Animation.Storyboard" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SetSpeedRatio">
      <MemberSignature Language="C#" Value="public void SetSpeedRatio (double speedRatio);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetSpeedRatio(float64 speedRatio) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.SetSpeedRatio(System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetSpeedRatio (speedRatio As Double)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetSpeedRatio(double speedRatio);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="speedRatio" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="speedRatio">Valor finito mayor que cero que es la nueva relación de velocidad interactiva del guión gráfico. Este valor se multiplica por el valor de <see cref="P:System.Windows.Media.Animation.Timeline.SpeedRatio" /> del guión gráfico para determinar la velocidad efectiva del guión gráfico. Este valor no sobrescribe la propiedad <see cref="P:System.Windows.Media.Animation.Timeline.SpeedRatio" /> del guión gráfico. Por ejemplo, al llamar a este método y especificar una relación de velocidad interactiva de 3 en un guión gráfico cuya propiedad <see cref="P:System.Windows.Media.Animation.Timeline.SpeedRatio" /> es 0,5, se asigna al guión gráfico una velocidad eficaz de 1,5.</param>
        <summary>Establece la relación de velocidad interactiva del objeto <see cref="T:System.Windows.Media.Animation.Clock" /> que se creó para este objeto <see cref="T:System.Windows.Media.Animation.Storyboard" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un guión gráfico controlable se puede pausar, reanudar, buscar, detener y se quitan. Para realizar un guión gráfico controlable en el código, debe utilizar la sobrecarga adecuada del guión gráfico <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> método y especifique `true` para que sea controlable. Para obtener un ejemplo, vea [Cómo: controlar un guión gráfico después de que se inicia](~/docs/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetSpeedRatio">
      <MemberSignature Language="C#" Value="public void SetSpeedRatio (System.Windows.FrameworkContentElement containingObject, double speedRatio);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetSpeedRatio(class System.Windows.FrameworkContentElement containingObject, float64 speedRatio) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.SetSpeedRatio(System.Windows.FrameworkContentElement,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetSpeedRatio (containingObject As FrameworkContentElement, speedRatio As Double)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetSpeedRatio(System::Windows::FrameworkContentElement ^ containingObject, double speedRatio);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="containingObject" Type="System.Windows.FrameworkContentElement" />
        <Parameter Name="speedRatio" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="containingObject">Objeto especificado cuando se llamó al método <see cref="M:System.Windows.Media.Animation.Storyboard.Begin(System.Windows.FrameworkContentElement,System.Boolean)" />. Este objeto contiene los objetos <see cref="T:System.Windows.Media.Animation.Clock" /> que se crearon para este guión gráfico y sus elementos secundarios.</param>
        <param name="speedRatio">Valor finito mayor que cero que es la nueva relación de velocidad interactiva del guión gráfico. Este valor se multiplica por el valor de <see cref="P:System.Windows.Media.Animation.Timeline.SpeedRatio" /> del guión gráfico para determinar la velocidad efectiva del guión gráfico. Este valor no sobrescribe la propiedad <see cref="P:System.Windows.Media.Animation.Timeline.SpeedRatio" /> del guión gráfico. Por ejemplo, al llamar a este método y especificar una relación de velocidad interactiva de 3 en un guión gráfico cuya propiedad <see cref="P:System.Windows.Media.Animation.Timeline.SpeedRatio" /> es 0,5, se asigna al guión gráfico una velocidad eficaz de 1,5.</param>
        <summary>Establece la relación de velocidad interactiva del objeto <see cref="T:System.Windows.Media.Animation.Clock" /> que se creó para este objeto <see cref="T:System.Windows.Media.Animation.Storyboard" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para controlar este guión gráfico de forma interactiva, debe usar el mismo `containingObject` parámetro al llamar a los métodos interactivos que usó para iniciar el guión gráfico. Un guión gráfico controlable se puede pausar, reanudar, buscar, detener y se quitan. Para realizar un guión gráfico controlable en el código, debe utilizar la sobrecarga adecuada del guión gráfico <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> método y especifique `true` para que sea controlable. Para obtener un ejemplo, vea [Cómo: controlar un guión gráfico después de que se inicia](~/docs/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts.md).  
  
 Llamar a este método desencadena el <xref:System.Windows.Media.Animation.Timeline.CurrentGlobalSpeedInvalidated> eventos.  
  
   
  
## Examples  
 En el ejemplo siguiente se utiliza un guión gráfico controlable para animar un <xref:System.Windows.Media.TextEffect>. El <xref:System.Windows.Media.TextEffect> está dentro de un <xref:System.Windows.FrameworkContentElement>del nombre de ámbito.  
  
 [!code-csharp[StoryboardBeginAnimation_procedural_snip#FrameworkContentElementControlStoryboardExampleUsingWholePage](~/samples/snippets/csharp/VS_Snippets_Wpf/StoryboardBeginAnimation_procedural_snip/CSharp/FrameworkContentElementControlStoryboardExample.cs#frameworkcontentelementcontrolstoryboardexampleusingwholepage)]
 [!code-vb[StoryboardBeginAnimation_procedural_snip#FrameworkContentElementControlStoryboardExampleUsingWholePage](~/samples/snippets/visualbasic/VS_Snippets_Wpf/StoryboardBeginAnimation_procedural_snip/visualbasic/frameworkcontentelementcontrolstoryboardexample.vb#frameworkcontentelementcontrolstoryboardexampleusingwholepage)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetSpeedRatio">
      <MemberSignature Language="C#" Value="public void SetSpeedRatio (System.Windows.FrameworkElement containingObject, double speedRatio);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetSpeedRatio(class System.Windows.FrameworkElement containingObject, float64 speedRatio) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.SetSpeedRatio(System.Windows.FrameworkElement,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetSpeedRatio (containingObject As FrameworkElement, speedRatio As Double)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetSpeedRatio(System::Windows::FrameworkElement ^ containingObject, double speedRatio);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="containingObject" Type="System.Windows.FrameworkElement" />
        <Parameter Name="speedRatio" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="containingObject">Objeto especificado cuando se llamó al método <see cref="M:System.Windows.Media.Animation.Storyboard.Begin(System.Windows.FrameworkElement,System.Boolean)" />. Este objeto contiene los objetos <see cref="T:System.Windows.Media.Animation.Clock" /> que se crearon para este guión gráfico y sus elementos secundarios.</param>
        <param name="speedRatio">Valor finito mayor que cero que es la nueva relación de velocidad interactiva del guión gráfico. Este valor se multiplica por el valor de <see cref="P:System.Windows.Media.Animation.Timeline.SpeedRatio" /> del guión gráfico para determinar la velocidad efectiva del guión gráfico. Este valor no sobrescribe la propiedad <see cref="P:System.Windows.Media.Animation.Timeline.SpeedRatio" /> del guión gráfico. Por ejemplo, al llamar a este método y especificar una relación de velocidad interactiva de 3 en un guión gráfico cuya propiedad <see cref="P:System.Windows.Media.Animation.Timeline.SpeedRatio" /> es 0,5, se asigna al guión gráfico una velocidad eficaz de 1,5.</param>
        <summary>Establece la relación de velocidad interactiva del objeto <see cref="T:System.Windows.Media.Animation.Clock" /> que se creó para este objeto <see cref="T:System.Windows.Media.Animation.Storyboard" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para controlar este guión gráfico de forma interactiva, debe usar el mismo `containingObject` parámetro al llamar a los métodos interactivos que usó para iniciar el guión gráfico. Un guión gráfico controlable se puede pausar, reanudar, buscar, detener y se quitan. Para realizar un guión gráfico controlable en el código, debe utilizar la sobrecarga adecuada del guión gráfico <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> método y especifique `true` para que sea controlable. Para obtener un ejemplo, vea [Cómo: controlar un guión gráfico después de que se inicia](~/docs/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts.md).  
  
 Llamar a este método desencadena el <xref:System.Windows.Media.Animation.Timeline.CurrentGlobalSpeedInvalidated> eventos.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetTarget">
      <MemberSignature Language="C#" Value="public static void SetTarget (System.Windows.DependencyObject element, System.Windows.DependencyObject value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetTarget(class System.Windows.DependencyObject element, class System.Windows.DependencyObject value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.SetTarget(System.Windows.DependencyObject,System.Windows.DependencyObject)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetTarget (element As DependencyObject, value As DependencyObject)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetTarget(System::Windows::DependencyObject ^ element, System::Windows::DependencyObject ^ value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
        <Parameter Name="value" Type="System.Windows.DependencyObject" />
      </Parameters>
      <Docs>
        <param name="element">
          <see cref="T:System.Windows.Media.Animation.Timeline" /> que debería ser el destino del objeto de dependencia especificado.</param>
        <param name="value">Objeto de dependencia de destino.</param>
        <summary>Hace que el objeto <see cref="T:System.Windows.Media.Animation.Timeline" /> especificado tenga como destino el objeto de dependencia.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método establece la <xref:System.Windows.Media.Animation.Storyboard.Target%2A> propiedad adjunta en el objeto especificado. Para obtener más información acerca de cómo funcionan los destinos de guión gráfico, consulte <xref:System.Windows.Media.Animation.Storyboard.TargetName%2A>. Para obtener más información acerca de cómo funcionan las propiedades adjuntas cómo, consulte [Attached Properties Overview](~/docs/framework/wpf/advanced/attached-properties-overview.md).  
  
> [!NOTE]
>  El <xref:System.Windows.Media.Animation.Storyboard.Target%2A> propiedad no es serializable, porque se puede establecer en cualquier <xref:System.Windows.DependencyObject>. No se garantiza que se puede hacer referencia a este objeto correctamente desde XAML.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Media.Animation.Storyboard.TargetName" />
      </Docs>
    </Member>
    <Member MemberName="SetTargetName">
      <MemberSignature Language="C#" Value="public static void SetTargetName (System.Windows.DependencyObject element, string name);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetTargetName(class System.Windows.DependencyObject element, string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.SetTargetName(System.Windows.DependencyObject,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetTargetName (element As DependencyObject, name As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetTargetName(System::Windows::DependencyObject ^ element, System::String ^ name);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="element">
          <see cref="T:System.Windows.Media.Animation.Timeline" /> que debería ser el destino del objeto de dependencia especificado.</param>
        <param name="name">Nombre del objeto de dependencia que se establecerá como destino.</param>
        <summary>Convierte el destino de <see cref="T:System.Windows.Media.Animation.Timeline" /> especificado en el objeto de dependencia con el nombre establecido.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método establece la <xref:System.Windows.Media.Animation.Storyboard.TargetName%2A> propiedad adjunta en el objeto especificado. Para obtener más información acerca de cómo funcionan los destinos de guión gráfico, consulte <xref:System.Windows.Media.Animation.Storyboard.TargetName%2A>. Para obtener más información acerca de cómo funcionan las propiedades adjuntas cómo, consulte [Attached Properties Overview](~/docs/framework/wpf/advanced/attached-properties-overview.md).  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Media.Animation.Storyboard.TargetName" />
      </Docs>
    </Member>
    <Member MemberName="SetTargetProperty">
      <MemberSignature Language="C#" Value="public static void SetTargetProperty (System.Windows.DependencyObject element, System.Windows.PropertyPath path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetTargetProperty(class System.Windows.DependencyObject element, class System.Windows.PropertyPath path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.SetTargetProperty(System.Windows.DependencyObject,System.Windows.PropertyPath)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetTargetProperty (element As DependencyObject, path As PropertyPath)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetTargetProperty(System::Windows::DependencyObject ^ element, System::Windows::PropertyPath ^ path);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
        <Parameter Name="path" Type="System.Windows.PropertyPath" />
      </Parameters>
      <Docs>
        <param name="element">
          <see cref="T:System.Windows.Media.Animation.Timeline" /> con el que se va a asociar la propiedad de dependencia especificada.</param>
        <param name="path">Ruta de acceso que describe la propiedad de dependencia que se va a animar.</param>
        <summary>Convierte el destino de <see cref="T:System.Windows.Media.Animation.Timeline" /> especificado en la propiedad de dependencia establecida.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método establece la <xref:System.Windows.Media.Animation.Storyboard.TargetProperty%2A> propiedad adjunta en el objeto especificado. Para obtener más información acerca de cómo funcionan los destinos de guión gráfico, consulte <xref:System.Windows.Media.Animation.Storyboard.TargetProperty%2A>. Para obtener más información acerca de cómo funcionan las propiedades adjuntas cómo, consulte [Attached Properties Overview](~/docs/framework/wpf/advanced/attached-properties-overview.md).  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Media.Animation.Storyboard.TargetProperty" />
      </Docs>
    </Member>
    <MemberGroup MemberName="SkipToFill">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Adelanta la hora actual del objeto <see cref="T:System.Windows.Media.Animation.Clock" /> de este guión gráfico hasta el final de su período activo.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SkipToFill">
      <MemberSignature Language="C#" Value="public void SkipToFill ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SkipToFill() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.SkipToFill" />
      <MemberSignature Language="VB.NET" Value="Public Sub SkipToFill ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SkipToFill();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Adelanta la hora actual del objeto <see cref="T:System.Windows.Media.Animation.Clock" /> de este guión gráfico hasta el final de su período activo.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un guión gráfico controlable se puede pausar, reanudar, buscar, detener y se quitan. Para realizar un guión gráfico controlable en el código, debe utilizar la sobrecarga adecuada del guión gráfico <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> método y especifique `true` para que sea controlable. Para obtener un ejemplo, vea [Cómo: controlar un guión gráfico después de que se inicia](~/docs/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SkipToFill">
      <MemberSignature Language="C#" Value="public void SkipToFill (System.Windows.FrameworkContentElement containingObject);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SkipToFill(class System.Windows.FrameworkContentElement containingObject) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.SkipToFill(System.Windows.FrameworkContentElement)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SkipToFill (containingObject As FrameworkContentElement)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SkipToFill(System::Windows::FrameworkContentElement ^ containingObject);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="containingObject" Type="System.Windows.FrameworkContentElement" />
      </Parameters>
      <Docs>
        <param name="containingObject">Objeto especificado cuando se llamó al método <see cref="M:System.Windows.Media.Animation.Storyboard.Begin(System.Windows.FrameworkContentElement,System.Boolean)" />. Este objeto contiene los objetos <see cref="T:System.Windows.Media.Animation.Clock" /> que se crearon para este guión gráfico y sus elementos secundarios.</param>
        <summary>Adelanta la hora actual del objeto <see cref="T:System.Windows.Media.Animation.Clock" /> de este guión gráfico hasta el final de su período activo.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método avanza del guión gráfico hora actual hasta el final de su período activo; en este momento, se especifica un comportamiento del guión gráfico por su <xref:System.Windows.Media.Animation.Timeline.FillBehavior%2A> configuración. Si <xref:System.Windows.Media.Animation.Timeline.FillBehavior%2A> está establecido en <xref:System.Windows.Media.Animation.FillBehavior.HoldEnd>, el guión gráfico se rellena; si la propiedad se establece en <xref:System.Windows.Media.Animation.FillBehavior.Stop>, se detiene el guión gráfico.  
  
 Llamar a este método en un guión gráfico con una duración infinita, un número infinito de repeticiones tiene ningún efecto. Al llamar a este método en un guión gráfico inactivo no tiene ningún efecto.  
  
 Avanzar un reloj para su relleno desencadenadores períodos la <xref:System.Windows.Media.Animation.Timeline.CurrentGlobalSpeedInvalidated> y <xref:System.Windows.Media.Animation.Timeline.CurrentStateInvalidated> eventos.  
  
 Para controlar este guión gráfico de forma interactiva, debe usar el mismo `containingObject` parámetro al llamar a los métodos interactivos que usó para iniciar el guión gráfico. Un guión gráfico controlable se puede pausar, reanudar, buscar, detener y se quitan. Para realizar un guión gráfico controlable en el código, debe utilizar la sobrecarga adecuada del guión gráfico <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> método y especifique `true` para que sea controlable. Para obtener un ejemplo, vea [Cómo: controlar un guión gráfico después de que se inicia](~/docs/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts.md).  
  
   
  
## Examples  
 En el ejemplo siguiente se utiliza un guión gráfico controlable para animar un <xref:System.Windows.Media.TextEffect>. El <xref:System.Windows.Media.TextEffect> está dentro de un <xref:System.Windows.FrameworkContentElement>del nombre de ámbito.  
  
 [!code-csharp[StoryboardBeginAnimation_procedural_snip#FrameworkContentElementControlStoryboardExampleUsingWholePage](~/samples/snippets/csharp/VS_Snippets_Wpf/StoryboardBeginAnimation_procedural_snip/CSharp/FrameworkContentElementControlStoryboardExample.cs#frameworkcontentelementcontrolstoryboardexampleusingwholepage)]
 [!code-vb[StoryboardBeginAnimation_procedural_snip#FrameworkContentElementControlStoryboardExampleUsingWholePage](~/samples/snippets/visualbasic/VS_Snippets_Wpf/StoryboardBeginAnimation_procedural_snip/visualbasic/frameworkcontentelementcontrolstoryboardexample.vb#frameworkcontentelementcontrolstoryboardexampleusingwholepage)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SkipToFill">
      <MemberSignature Language="C#" Value="public void SkipToFill (System.Windows.FrameworkElement containingObject);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SkipToFill(class System.Windows.FrameworkElement containingObject) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.SkipToFill(System.Windows.FrameworkElement)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SkipToFill (containingObject As FrameworkElement)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SkipToFill(System::Windows::FrameworkElement ^ containingObject);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="containingObject" Type="System.Windows.FrameworkElement" />
      </Parameters>
      <Docs>
        <param name="containingObject">Objeto especificado cuando se llamó al método <see cref="M:System.Windows.Media.Animation.Storyboard.Begin(System.Windows.FrameworkElement,System.Boolean)" />. Este objeto contiene los objetos <see cref="T:System.Windows.Media.Animation.Clock" /> que se crearon para este guión gráfico y sus elementos secundarios.</param>
        <summary>Adelanta la hora actual del objeto <see cref="T:System.Windows.Media.Animation.Clock" /> de este guión gráfico hasta el final de su período activo.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método avanza del guión gráfico hora actual hasta el final de su período activo; en este momento, se especifica un comportamiento del guión gráfico por su <xref:System.Windows.Media.Animation.Timeline.FillBehavior%2A> configuración. Si <xref:System.Windows.Media.Animation.Timeline.FillBehavior%2A> está establecido en <xref:System.Windows.Media.Animation.FillBehavior.HoldEnd>, el guión gráfico se rellena; si la propiedad se establece en <xref:System.Windows.Media.Animation.FillBehavior.Stop>, se detiene el guión gráfico.  
  
 Llamar a este método en un guión gráfico con una duración infinita, un número infinito de repeticiones tiene ningún efecto. Al llamar a este método en un guión gráfico inactivo no tiene ningún efecto.  
  
 Avanzar un reloj para su relleno desencadenadores períodos la <xref:System.Windows.Media.Animation.Timeline.CurrentGlobalSpeedInvalidated> y <xref:System.Windows.Media.Animation.Timeline.CurrentStateInvalidated> eventos.  
  
 Para controlar este guión gráfico de forma interactiva, debe usar el mismo `containingObject` parámetro al llamar a los métodos interactivos que usó para iniciar el guión gráfico. Un guión gráfico controlable se puede pausar, reanudar, buscar, detener y se quitan. Para realizar un guión gráfico controlable en el código, debe utilizar la sobrecarga adecuada del guión gráfico <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> método y especifique `true` para que sea controlable. Para obtener un ejemplo, vea [Cómo: controlar un guión gráfico después de que se inicia](~/docs/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Stop">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Detiene el objeto <see cref="T:System.Windows.Media.Animation.Clock" /> que se creó para este <see cref="T:System.Windows.Media.Animation.Storyboard" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Stop">
      <MemberSignature Language="C#" Value="public void Stop ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Stop() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.Stop" />
      <MemberSignature Language="VB.NET" Value="Public Sub Stop ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Stop();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Detiene el objeto <see cref="T:System.Windows.Media.Animation.Clock" /> que se creó para este <see cref="T:System.Windows.Media.Animation.Storyboard" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Tenga en cuenta que al detener un guión gráfico, no se activa la <xref:System.Windows.Media.Animation.Timeline.Completed> eventos.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stop">
      <MemberSignature Language="C#" Value="public void Stop (System.Windows.FrameworkContentElement containingObject);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Stop(class System.Windows.FrameworkContentElement containingObject) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.Stop(System.Windows.FrameworkContentElement)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Stop (containingObject As FrameworkContentElement)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Stop(System::Windows::FrameworkContentElement ^ containingObject);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="containingObject" Type="System.Windows.FrameworkContentElement" />
      </Parameters>
      <Docs>
        <param name="containingObject">Objeto especificado cuando se llamó al método <see cref="M:System.Windows.Media.Animation.Storyboard.Begin(System.Windows.FrameworkContentElement,System.Boolean)" />. Este objeto contiene los objetos <see cref="T:System.Windows.Media.Animation.Clock" /> que se crearon para este guión gráfico y sus elementos secundarios.</param>
        <summary>Detiene el objeto <see cref="T:System.Windows.Media.Animation.Clock" /> que se creó para este <see cref="T:System.Windows.Media.Animation.Storyboard" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un <xref:System.Windows.Media.Animation.ClockState.Stopped> guión gráfico ya no afecta a sus propiedades de destino: propiedades que se anima revertirán a sus valores anteriores.  
  
 Detener los desencadenadores de reloj la <xref:System.Windows.Media.Animation.Timeline.CurrentGlobalSpeedInvalidated> y <xref:System.Windows.Media.Animation.Timeline.CurrentStateInvalidated> eventos, pero no el <xref:System.Windows.Media.Animation.Timeline.Completed> eventos.  
  
 Para controlar este guión gráfico de forma interactiva, debe usar el mismo `containingObject` parámetro al llamar a los métodos interactivos que usó para iniciar el guión gráfico. Un guión gráfico controlable se puede pausar, reanudar, buscar, detener y se quitan. Para realizar un guión gráfico controlable en el código, debe utilizar la sobrecarga adecuada del guión gráfico <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> método y especifique `true` para que sea controlable. Para obtener un ejemplo, vea [Cómo: controlar un guión gráfico después de que se inicia](~/docs/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts.md).  
  
   
  
## Examples  
 En el ejemplo siguiente se utiliza un guión gráfico controlable para animar un <xref:System.Windows.Media.TextEffect>. El <xref:System.Windows.Media.TextEffect> está dentro de un <xref:System.Windows.FrameworkContentElement>del nombre de ámbito.  
  
 [!code-csharp[StoryboardBeginAnimation_procedural_snip#FrameworkContentElementControlStoryboardExampleUsingWholePage](~/samples/snippets/csharp/VS_Snippets_Wpf/StoryboardBeginAnimation_procedural_snip/CSharp/FrameworkContentElementControlStoryboardExample.cs#frameworkcontentelementcontrolstoryboardexampleusingwholepage)]
 [!code-vb[StoryboardBeginAnimation_procedural_snip#FrameworkContentElementControlStoryboardExampleUsingWholePage](~/samples/snippets/visualbasic/VS_Snippets_Wpf/StoryboardBeginAnimation_procedural_snip/visualbasic/frameworkcontentelementcontrolstoryboardexample.vb#frameworkcontentelementcontrolstoryboardexampleusingwholepage)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stop">
      <MemberSignature Language="C#" Value="public void Stop (System.Windows.FrameworkElement containingObject);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Stop(class System.Windows.FrameworkElement containingObject) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.Stop(System.Windows.FrameworkElement)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Stop (containingObject As FrameworkElement)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Stop(System::Windows::FrameworkElement ^ containingObject);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="containingObject" Type="System.Windows.FrameworkElement" />
      </Parameters>
      <Docs>
        <param name="containingObject">Objeto especificado cuando se llamó al método <see cref="M:System.Windows.Media.Animation.Storyboard.Begin(System.Windows.FrameworkElement,System.Boolean)" />. Este objeto contiene los objetos <see cref="T:System.Windows.Media.Animation.Clock" /> que se crearon para este guión gráfico y sus elementos secundarios.</param>
        <summary>Detiene el objeto <see cref="T:System.Windows.Media.Animation.Clock" /> que se creó para este <see cref="T:System.Windows.Media.Animation.Storyboard" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un <xref:System.Windows.Media.Animation.ClockState.Stopped> guión gráfico ya no afecta a sus propiedades de destino: propiedades que se anima revertirán a sus valores anteriores.  
  
 Detener los desencadenadores de reloj la <xref:System.Windows.Media.Animation.Timeline.CurrentGlobalSpeedInvalidated> y <xref:System.Windows.Media.Animation.Timeline.CurrentStateInvalidated> eventos, pero no el <xref:System.Windows.Media.Animation.Timeline.Completed> eventos.  
  
 Para controlar este guión gráfico de forma interactiva, debe usar el mismo `containingObject` parámetro al llamar a los métodos interactivos que usó para iniciar el guión gráfico. Un guión gráfico controlable se puede pausar, reanudar, buscar, detener y se quitan. Para realizar un guión gráfico controlable en el código, debe utilizar la sobrecarga adecuada del guión gráfico <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> método y especifique `true` para que sea controlable. Para obtener un ejemplo, vea [Cómo: controlar un guión gráfico después de que se inicia](~/docs/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Target">
      <MemberSignature Language="C#" Value="see GetTarget, and SetTarget" />
      <MemberSignature Language="ILAsm" Value="see GetTarget, and SetTarget" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Media.Animation.Storyboard.Target" />
      <MemberSignature Language="VB.NET" Value="see GetTarget, and SetTarget" />
      <MemberType>AttachedProperty</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TargetName">
      <MemberSignature Language="C#" Value="see GetTargetName, and SetTargetName" />
      <MemberSignature Language="ILAsm" Value="see GetTargetName, and SetTargetName" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Media.Animation.Storyboard.TargetName" />
      <MemberSignature Language="VB.NET" Value="see GetTargetName, and SetTargetName" />
      <MemberType>AttachedProperty</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TargetNameProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty TargetNameProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty TargetNameProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Media.Animation.Storyboard.TargetNameProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly TargetNameProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ TargetNameProperty;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifica la propiedad adjunta <see cref="P:System.Windows.Media.Animation.Storyboard.TargetName" />.</summary>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Windows.Media.Animation.Storyboard.TargetName" />
      </Docs>
    </Member>
    <Member MemberName="TargetProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty TargetProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty TargetProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Media.Animation.Storyboard.TargetProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly TargetProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ TargetProperty;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifica la propiedad adjunta <see cref="P:System.Windows.Media.Animation.Storyboard.Target" />.</summary>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Windows.Media.Animation.Storyboard.TargetName" />
      </Docs>
    </Member>
    <Member MemberName="TargetPropertyProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty TargetPropertyProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty TargetPropertyProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Media.Animation.Storyboard.TargetPropertyProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly TargetPropertyProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ TargetPropertyProperty;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifica la propiedad adjunta <see cref="P:System.Windows.Media.Animation.Storyboard.TargetProperty" />.</summary>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Windows.Media.Animation.Storyboard.TargetProperty" />
      </Docs>
    </Member>
  </Members>
</Type>