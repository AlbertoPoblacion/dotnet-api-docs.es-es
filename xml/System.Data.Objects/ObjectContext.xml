<Type Name="ObjectContext" FullName="System.Data.Objects.ObjectContext">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="0997f3d7974ba6b3999801d158dad1b588eba4c5" />
    <Meta Name="ms.sourcegitcommit" Value="0e1f030650a307c745ee84ed547ef858acaea587" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="es-ES" />
    <Meta Name="ms.lasthandoff" Value="11/29/2018" />
    <Meta Name="ms.locfileid" Value="52598582" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class ObjectContext : IDisposable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit ObjectContext extends System.Object implements class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:System.Data.Objects.ObjectContext" />
  <TypeSignature Language="VB.NET" Value="Public Class ObjectContext&#xA;Implements IDisposable" />
  <TypeSignature Language="C++ CLI" Value="public ref class ObjectContext : IDisposable" />
  <TypeSignature Language="F#" Value="type ObjectContext = class&#xA;    interface IDisposable" />
  <AssemblyInfo>
    <AssemblyName>System.Data.Entity</AssemblyName>
    <AssemblyVersion>3.5.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>Proporciona funciones para consultar y trabajar con datos de entidad como objetos.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  La clase <xref:System.Data.Objects.ObjectContext> no es segura para la ejecución de subprocesos. La integridad de los objetos de datos en un <xref:System.Data.Objects.ObjectContext> no se puede garantizar en escenarios multiproceso.  
  
 La <xref:System.Data.Objects.ObjectContext> clase es la clase principal para interactuar con datos como objetos que son instancias de tipos de entidad que se definen en un modelo conceptual. Una instancia de la clase <xref:System.Data.Objects.ObjectContext> encapsula lo siguiente:  
  
-   Una conexión con la base de datos, en forma de un objeto <xref:System.Data.EntityClient.EntityConnection>.  
  
-   Los metadatos que describen el modelo, en forma de un objeto <xref:System.Data.Metadata.Edm.MetadataWorkspace>.  
  
-   Un objeto <xref:System.Data.Objects.ObjectStateManager> que administra los objetos almacenados en la caché.  
  
 Cuando las herramientas de Entity Data Model generan la capa de objeto que representa un modelo conceptual, la clase que representa el <xref:System.Data.Metadata.Edm.EntityContainer> para el modelo se deriva el <xref:System.Data.Objects.ObjectContext>.  
  
   
  
## Examples  
 En este ejemplo se basa en el [modelo AdventureWorks Sales](https://msdn.microsoft.com/library/f16cd988-673f-4376-b034-129ca93c7832). En el ejemplo se muestra cómo construir un <xref:System.Data.Objects.ObjectContext>.  
  
 [!code-csharp[DP ObjectServices Concepts#ObjectContext](~/samples/snippets/csharp/VS_Snippets_Data/DP ObjectServices Concepts/CS/Source.cs#objectcontext)]
 [!code-vb[DP ObjectServices Concepts#ObjectContext](~/samples/snippets/visualbasic/VS_Snippets_Data/DP ObjectServices Concepts/VB/Source.vb#objectcontext)]  
  
 ]]></format>
    </remarks>
    <related type="Article" href="~/docs/framework/data/adonet/ef/querying-a-conceptual-model.md">Consultar datos como objetos (Entity Framework)</related>
    <related type="Article" href="https://msdn.microsoft.com/library/338d8a55-05cc-46b0-bbb8-1379d77068e9">Trabajar con objetos (Entity Framework)</related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Data.Objects.ObjectContext" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public ObjectContext (System.Data.EntityClient.EntityConnection connection);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Data.EntityClient.EntityConnection connection) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.ObjectContext.#ctor(System.Data.EntityClient.EntityConnection)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (connection As EntityConnection)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; ObjectContext(System::Data::EntityClient::EntityConnection ^ connection);" />
      <MemberSignature Language="F#" Value="new System.Data.Objects.ObjectContext : System.Data.EntityClient.EntityConnection -&gt; System.Data.Objects.ObjectContext" Usage="new System.Data.Objects.ObjectContext connection" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="connection" Type="System.Data.EntityClient.EntityConnection" />
      </Parameters>
      <Docs>
        <param name="connection">
          <see cref="T:System.Data.EntityClient.EntityConnection" /> que contiene referencias al modelo y a la conexión del origen de datos.</param>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Data.Objects.ObjectContext" /> con la conexión especificada. Durante la construcción, el área de trabajo de metadatos se extrae del objeto <see cref="T:System.Data.EntityClient.EntityConnection" />.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">El valor de <paramref name="connection" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="connection" /> no es válido.  
  
O bien 
El área de trabajo de metadatos no es válida.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/338d8a55-05cc-46b0-bbb8-1379d77068e9">Trabajar con objetos (Entity Framework)</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public ObjectContext (string connectionString);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string connectionString) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.ObjectContext.#ctor(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (connectionString As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; ObjectContext(System::String ^ connectionString);" />
      <MemberSignature Language="F#" Value="new System.Data.Objects.ObjectContext : string -&gt; System.Data.Objects.ObjectContext" Usage="new System.Data.Objects.ObjectContext connectionString" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="connectionString" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="connectionString">Cadena de conexión, que también proporciona acceso a la información de metadatos.</param>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Data.Objects.ObjectContext" /> con la cadena de conexión y el nombre de contenedor de entidades predeterminado especificados.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El `connectionString` es una cadena que contiene la información necesaria para tener acceso a un modelo conceptual y conectarse a un origen de datos. La clase <xref:System.Data.EntityClient.EntityConnectionStringBuilder> se puede usar para dar el formato correcto a la cadena.  
  
 El generar una cadena de conexión con nombre que se almacena en el archivo de configuración de la aplicación. Puede proporcionar esta cadena de conexión con nombre en lugar de la `connectionString` parámetro al crear una instancia del <xref:System.Data.Objects.ObjectContext> clase.  
  
   
  
## Examples  
 El ejemplo de este tema se basa en el [modelo AdventureWorks Sales](https://msdn.microsoft.com/library/f16cd988-673f-4376-b034-129ca93c7832). En el ejemplo se muestra cómo construir un <xref:System.Data.Objects.ObjectContext>.  
  
 [!code-csharp[DP ObjectServices Concepts#ObjectContext](~/samples/snippets/csharp/VS_Snippets_Data/DP ObjectServices Concepts/CS/Source.cs#objectcontext)]
 [!code-vb[DP ObjectServices Concepts#ObjectContext](~/samples/snippets/visualbasic/VS_Snippets_Data/DP ObjectServices Concepts/VB/Source.vb#objectcontext)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El valor de <paramref name="connectionString" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="connectionString" /> no es válido.  
  
O bien 
El área de trabajo de metadatos no es válida.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/338d8a55-05cc-46b0-bbb8-1379d77068e9">Trabajar con objetos (Entity Framework)</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected ObjectContext (System.Data.EntityClient.EntityConnection connection, string defaultContainerName);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(class System.Data.EntityClient.EntityConnection connection, string defaultContainerName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.ObjectContext.#ctor(System.Data.EntityClient.EntityConnection,System.String)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New (connection As EntityConnection, defaultContainerName As String)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; ObjectContext(System::Data::EntityClient::EntityConnection ^ connection, System::String ^ defaultContainerName);" />
      <MemberSignature Language="F#" Value="new System.Data.Objects.ObjectContext : System.Data.EntityClient.EntityConnection * string -&gt; System.Data.Objects.ObjectContext" Usage="new System.Data.Objects.ObjectContext (connection, defaultContainerName)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="connection" Type="System.Data.EntityClient.EntityConnection" />
        <Parameter Name="defaultContainerName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="connection">
          <see cref="T:System.Data.EntityClient.EntityConnection" /> que contiene referencias al modelo y a la conexión del origen de datos.</param>
        <param name="defaultContainerName">Nombre del contenedor de entidades predeterminado. Cuando el parámetro <paramref name="defaultContainerName" /> se establece mediante este método, la propiedad se convierte en solo lectura.</param>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Data.Objects.ObjectContext" /> con la conexión y el nombre de contenedor de entidades especificados.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">El valor de <paramref name="connection" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="connection" />, <paramref name="defaultContainerName" /> o el área de trabajo de metadatos no es válida.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/338d8a55-05cc-46b0-bbb8-1379d77068e9">Trabajar con objetos (Entity Framework)</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected ObjectContext (string connectionString, string defaultContainerName);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(string connectionString, string defaultContainerName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.ObjectContext.#ctor(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New (connectionString As String, defaultContainerName As String)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; ObjectContext(System::String ^ connectionString, System::String ^ defaultContainerName);" />
      <MemberSignature Language="F#" Value="new System.Data.Objects.ObjectContext : string * string -&gt; System.Data.Objects.ObjectContext" Usage="new System.Data.Objects.ObjectContext (connectionString, defaultContainerName)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="connectionString" Type="System.String" />
        <Parameter Name="defaultContainerName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="connectionString">Cadena de conexión, que también proporciona acceso a la información de metadatos.</param>
        <param name="defaultContainerName">Nombre del contenedor de entidades predeterminado. Cuando el parámetro <paramref name="defaultContainerName" /> se establece mediante este método, la propiedad se convierte en solo lectura.</param>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Data.Objects.ObjectContext" /> con la cadena de conexión y el nombre de contenedor de entidades especificados.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El `connectionString` es una cadena que contiene la información necesaria para tener acceso a un modelo conceptual y conectarse a un origen de datos. La clase <xref:System.Data.EntityClient.EntityConnectionStringBuilder> se puede usar para dar el formato correcto a la cadena.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El valor de <paramref name="connectionString" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="connectionString" />, <paramref name="defaultContainerName" /> o el área de trabajo de metadatos no es válida.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/338d8a55-05cc-46b0-bbb8-1379d77068e9">Trabajar con objetos (Entity Framework)</related>
      </Docs>
    </Member>
    <Member MemberName="AcceptAllChanges">
      <MemberSignature Language="C#" Value="public void AcceptAllChanges ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AcceptAllChanges() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.ObjectContext.AcceptAllChanges" />
      <MemberSignature Language="VB.NET" Value="Public Sub AcceptAllChanges ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AcceptAllChanges();" />
      <MemberSignature Language="F#" Value="member this.AcceptAllChanges : unit -&gt; unit" Usage="objectContext.AcceptAllChanges " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Acepta todos los cambios realizados en los objetos del contexto del objeto.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Acepta los cambios de todas las entradas asociadas en el <xref:System.Data.Objects.ObjectStateManager> de modo que su estado resultante sea sin cambios o desasociado.  
  
 Este método recorre en iteración todos los objetos <xref:System.Data.Objects.ObjectStateEntry> del <xref:System.Data.Objects.ObjectStateManager> cuyo estado es Agregado o Modificado y, a continuación, establece el estado de la entrada a Sin cambios. Los elementos Eliminados se desasocian.  
  
 Si el <xref:System.Data.Objects.ObjectContext.SaveChanges%2A> se llamó al método y el <xref:System.Data.Objects.SaveOptions.AcceptAllChangesAfterSave> no se especifica, el usuario debe llamar a la <xref:System.Data.Objects.ObjectContext.AcceptAllChanges%2A> método. El método <xref:System.Data.Objects.ObjectContext.AcceptAllChanges%2A> resulta útil cuando se ha producido un error en una transacción y un usuario desea reintentarla.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/338d8a55-05cc-46b0-bbb8-1379d77068e9">Trabajar con objetos (Entity Framework)</related>
      </Docs>
    </Member>
    <Member MemberName="AddObject">
      <MemberSignature Language="C#" Value="public void AddObject (string entitySetName, object entity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddObject(string entitySetName, object entity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.ObjectContext.AddObject(System.String,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddObject (entitySetName As String, entity As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddObject(System::String ^ entitySetName, System::Object ^ entity);" />
      <MemberSignature Language="F#" Value="member this.AddObject : string * obj -&gt; unit" Usage="objectContext.AddObject (entitySetName, entity)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="entitySetName" Type="System.String" />
        <Parameter Name="entity" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="entitySetName">Representa el nombre del conjunto de entidades, que puede estar calificado por el nombre del contenedor de entidades.</param>
        <param name="entity">
          <see cref="T:System.Object" /> que se va a agregar.</param>
        <summary>Agrega un objeto al contexto del objeto.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Llame a <xref:System.Data.Objects.ObjectContext.AddObject%2A> en el <xref:System.Data.Objects.ObjectContext> para agregar el objeto al contexto del objeto. Haga esto cuando el objeto sea nuevo y no exista todavía en el origen de datos. Para obtener más información, consulte [adjuntar y desasociar objetos](https://msdn.microsoft.com/library/41d5c1ef-1b78-4502-aa10-7e1438d62d23).  
  
 Los objetos se agregan al <xref:System.Data.Objects.ObjectStateManager> con el estado <xref:System.Data.EntityState.Detached>, <xref:System.Data.EntityState.Deleted> o <xref:System.Data.EntityState.Added>.  
  
 Al crear un nuevo objeto relacionado con otro objeto del contexto del objeto, agregue el objeto con uno de los métodos siguientes:  
  
-   Llame al método <xref:System.Data.Objects.DataClasses.EntityCollection%601.Add%2A> de la <xref:System.Data.Objects.DataClasses.EntityCollection%601> y especifique el objeto relacionado. Hágalo para relaciones de uno a varios o de varios a varios.  
  
-   Establezca la propiedad <xref:System.Data.Objects.DataClasses.EntityReference%601.Value%2A> de la <xref:System.Data.Objects.DataClasses.EntityReference%601> en el objeto relacionado. Hágalo para relaciones de uno a uno o de varios a uno.  
  
 Para obtener más información, consulte [crear, agregar, modificar y eliminar objetos](https://msdn.microsoft.com/library/f76f1fad-c553-4b59-820b-89b3dec2fad1).  
  
 Si el objeto está en un estado desasociado no debe tener un <xref:System.Data.EntityKey>.  
  
 Las reglas para el `entitySetName` formato son los siguientes:  
  
-   Si el <xref:System.Data.Objects.ObjectContext.DefaultContainerName%2A> propiedad es `null`, el `entitySetName` tiene que ser un nombre completo como en  *\<Entity Container Name >*. *\<Nombre del conjunto de entidades >*.  
  
-   Si <xref:System.Data.Objects.ObjectContext.DefaultContainerName%2A> no `null`, el `entitySetName` puede ser  *\<Entity Container Name >*. *\<Nombre del conjunto de entidades >* o  *\<nombre del conjunto de entidades >*.  
  
 Si el `object` tiene un <xref:System.Data.EntityKey> y `entitySetName` tiene un valor, el <xref:System.Data.Metadata.Edm.EntitySet> de la entidad de clave debe coincidir con el <xref:System.Data.Metadata.Edm.EntitySet> que se encontró basándose en el `entitySetName` y el nombre del contenedor de entidades.  
  
   
  
## Examples  
 En este ejemplo se basa en el [modelo AdventureWorks Sales](https://msdn.microsoft.com/library/f16cd988-673f-4376-b034-129ca93c7832). El ejemplo agrega un nuevo producto y guarda los cambios en la base de datos.  
  
 [!code-csharp[DP ObjectServices Concepts#AddObject](~/samples/snippets/csharp/VS_Snippets_Data/DP ObjectServices Concepts/CS/Source.cs#addobject)]
 [!code-vb[DP ObjectServices Concepts#AddObject](~/samples/snippets/visualbasic/VS_Snippets_Data/DP ObjectServices Concepts/VB/Source.vb#addobject)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El parámetro <paramref name="entity" /> es <see langword="null" />.  
  
O bien 
<paramref name="entitySetName" /> no se califica.</exception>
        <altmember cref="M:System.Data.Objects.ObjectSet`1.AddObject(`0)" />
        <related type="Article" href="https://msdn.microsoft.com/library/338d8a55-05cc-46b0-bbb8-1379d77068e9">Trabajar con objetos (Entity Framework)</related>
      </Docs>
    </Member>
    <Member MemberName="ApplyCurrentValues&lt;TEntity&gt;">
      <MemberSignature Language="C#" Value="public TEntity ApplyCurrentValues&lt;TEntity&gt; (string entitySetName, TEntity currentEntity) where TEntity : class;" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance !!TEntity ApplyCurrentValues&lt;class TEntity&gt;(string entitySetName, !!TEntity currentEntity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.ObjectContext.ApplyCurrentValues``1(System.String,``0)" />
      <MemberSignature Language="VB.NET" Value="Public Function ApplyCurrentValues(Of TEntity As Class) (entitySetName As String, currentEntity As TEntity) As TEntity" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TEntity&gt;&#xA; where TEntity : class TEntity ApplyCurrentValues(System::String ^ entitySetName, TEntity currentEntity);" />
      <MemberSignature Language="F#" Value="member this.ApplyCurrentValues : string * 'Entity -&gt; 'Entity (requires 'Entity : null)" Usage="objectContext.ApplyCurrentValues (entitySetName, currentEntity)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TEntity</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TEntity">
          <Constraints>
            <ParameterAttribute>ReferenceTypeConstraint</ParameterAttribute>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="entitySetName" Type="System.String" />
        <Parameter Name="currentEntity" Type="TEntity" />
      </Parameters>
      <Docs>
        <typeparam name="TEntity">Tipo de entidad del objeto.</typeparam>
        <param name="entitySetName">Nombre del conjunto de entidades al que pertenece el objeto.</param>
        <param name="currentEntity">Objeto desasociado que tiene actualizaciones de propiedades que deben aplicarse al objeto original. La clave de entidad de <paramref name="currentEntity" /> debe coincidir con la propiedad <see cref="P:System.Data.Objects.ObjectStateEntry.EntityKey" /> de una entrada de <see cref="T:System.Data.Objects.ObjectContext" />.</param>
        <summary>Copia los valores escalares del objeto proporcionado al objeto de <see cref="T:System.Data.Objects.ObjectContext" /> que tiene la misma clave.</summary>
        <returns>Objeto actualizado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Data.Objects.ObjectContext.ApplyCurrentValues%2A> método se usa para aplicar los cambios realizados a objetos fuera la <xref:System.Data.Objects.ObjectContext>, por ejemplo, los objetos desasociados recibidos por un servicio Web. El método copia los valores escalares del objeto proporcionado en el objeto en el <xref:System.Data.Objects.ObjectContext> que tiene la misma clave. Puede usar el <xref:System.Data.EntityKey> del objeto desasociado para recuperar una instancia de este objeto desde el origen de datos. Para obtener más información, consulte [Cómo: devolver un objeto concreto usando su clave](https://msdn.microsoft.com/library/2e9902af-29b0-4e5d-92db-03dfe6ec49bd). Los valores que difieran de los valores originales del objeto se marcan como modificada. Tenga en cuenta que el método no se aplican los valores actuales para los objetos relacionados de `currentEntity`.  
  
 Si tiene un gráfico con los valores actuales y desea aplicar los valores originales, llamar a <xref:System.Data.Objects.ObjectContext.ApplyOriginalValues%2A> método.  
  
 También puede usar el <xref:System.Data.Objects.ObjectSet%601.ApplyCurrentValues%2A> de la <xref:System.Data.Objects.ObjectSet%601> o <xref:System.Data.Objects.ObjectStateEntry.ApplyCurrentValues%2A> método de la <xref:System.Data.Objects.ObjectStateEntry>. Para obtener más información, consulte [creación de aplicaciones de N niveles](https://msdn.microsoft.com/library/9439d2ba-6b5f-44e8-be65-8a442d922cbb).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El valor de <paramref name="entitySetName" /> o <paramref name="current" /> es <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="T:System.Data.Metadata.Edm.EntitySet" /> de <paramref name="entitySetName" /> no coincide con <see cref="T:System.Data.Metadata.Edm.EntitySet" /> de <see cref="T:System.Data.EntityKey" /> del objeto.  
  
O bien 
El objeto no está en un estado <see cref="T:System.Data.Objects.ObjectStateManager" /> o está en un estado <see cref="F:System.Data.EntityState.Detached" />.  
  
O bien 
La clave de entidad del objeto proporcionado no es válida.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="entitySetName" /> es una cadena vacía.</exception>
        <altmember cref="M:System.Data.Objects.ObjectSet`1.ApplyCurrentValues(`0)" />
        <altmember cref="M:System.Data.Objects.ObjectStateEntry.ApplyCurrentValues(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="ApplyOriginalValues&lt;TEntity&gt;">
      <MemberSignature Language="C#" Value="public TEntity ApplyOriginalValues&lt;TEntity&gt; (string entitySetName, TEntity originalEntity) where TEntity : class;" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance !!TEntity ApplyOriginalValues&lt;class TEntity&gt;(string entitySetName, !!TEntity originalEntity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.ObjectContext.ApplyOriginalValues``1(System.String,``0)" />
      <MemberSignature Language="VB.NET" Value="Public Function ApplyOriginalValues(Of TEntity As Class) (entitySetName As String, originalEntity As TEntity) As TEntity" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TEntity&gt;&#xA; where TEntity : class TEntity ApplyOriginalValues(System::String ^ entitySetName, TEntity originalEntity);" />
      <MemberSignature Language="F#" Value="member this.ApplyOriginalValues : string * 'Entity -&gt; 'Entity (requires 'Entity : null)" Usage="objectContext.ApplyOriginalValues (entitySetName, originalEntity)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TEntity</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TEntity">
          <Constraints>
            <ParameterAttribute>ReferenceTypeConstraint</ParameterAttribute>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="entitySetName" Type="System.String" />
        <Parameter Name="originalEntity" Type="TEntity" />
      </Parameters>
      <Docs>
        <typeparam name="TEntity">Tipo del objeto entidad.</typeparam>
        <param name="entitySetName">Nombre del conjunto de entidades al que pertenece el objeto.</param>
        <param name="originalEntity">Objeto desasociado que tiene valores originales que deben aplicarse al objeto. La clave de entidad de <paramref name="originalEntity" /> debe coincidir con la propiedad <see cref="P:System.Data.Objects.ObjectStateEntry.EntityKey" /> de una entrada de <see cref="T:System.Data.Objects.ObjectContext" />.</param>
        <summary>Toma los valores escalares del objeto proporcionado y los copia en el conjunto de valores originales para el objeto del <see cref="T:System.Data.Objects.ObjectContext" /> que tiene la misma clave.</summary>
        <returns>Objeto actualizado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Data.Objects.ObjectContext.ApplyOriginalValues%2A> método se usa para aplicar los cambios realizados a objetos fuera la <xref:System.Data.Objects.ObjectContext>, por ejemplo, los objetos desasociados recibidos por un servicio Web. El método copia los valores escalares del objeto proporcionado en el objeto en el <xref:System.Data.Objects.ObjectContext> que tiene la misma clave. Puede usar el <xref:System.Data.EntityKey> del objeto desasociado para recuperar una instancia de este objeto desde el origen de datos. Para obtener más información, consulte [Cómo: devolver un objeto concreto usando su clave](https://msdn.microsoft.com/library/2e9902af-29b0-4e5d-92db-03dfe6ec49bd). Los valores que difieran de los valores actuales del objeto se marcan como modificada. Tenga en cuenta que el método no se aplican los valores actuales para los objetos relacionados de `originalEntity`.  
  
 Si tiene un gráfico con los valores originales y desea aplicar los valores actuales, llame a <xref:System.Data.Objects.ObjectContext.ApplyCurrentValues%2A> método.  
  
 También puede usar el <xref:System.Data.Objects.ObjectSet%601.ApplyOriginalValues%2A> de la <xref:System.Data.Objects.ObjectSet%601> o <xref:System.Data.Objects.ObjectStateEntry.ApplyOriginalValues%2A> método de la <xref:System.Data.Objects.ObjectStateEntry>. Para obtener más información, consulte [creación de aplicaciones de N niveles](https://msdn.microsoft.com/library/9439d2ba-6b5f-44e8-be65-8a442d922cbb).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El valor de <paramref name="entitySetName" /> o <paramref name="original" /> es <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="T:System.Data.Metadata.Edm.EntitySet" /> de <paramref name="entitySetName" /> no coincide con <see cref="T:System.Data.Metadata.Edm.EntitySet" /> de <see cref="T:System.Data.EntityKey" /> del objeto.  
  
O bien 
Un <see cref="T:System.Data.Objects.ObjectStateEntry" /> del objeto no se puede encontrar en en el objeto <see cref="T:System.Data.Objects.ObjectStateManager" />. O bien 
El objeto se encuentra en un estado <see cref="F:System.Data.EntityState.Added" /> o <see cref="F:System.Data.EntityState.Detached" />.  
  
O bien 
La clave de entidad del objeto proporcionado no es válida o tiene cambios de propiedad.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="entitySetName" /> es una cadena vacía.</exception>
        <altmember cref="M:System.Data.Objects.ObjectSet`1.ApplyOriginalValues(`0)" />
        <altmember cref="M:System.Data.Objects.ObjectStateEntry.ApplyOriginalValues(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="ApplyPropertyChanges">
      <MemberSignature Language="C#" Value="public void ApplyPropertyChanges (string entitySetName, object changed);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ApplyPropertyChanges(string entitySetName, object changed) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.ObjectContext.ApplyPropertyChanges(System.String,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ApplyPropertyChanges (entitySetName As String, changed As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ApplyPropertyChanges(System::String ^ entitySetName, System::Object ^ changed);" />
      <MemberSignature Language="F#" Value="member this.ApplyPropertyChanges : string * obj -&gt; unit" Usage="objectContext.ApplyPropertyChanges (entitySetName, changed)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("Use ApplyCurrentValues instead")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="entitySetName" Type="System.String" />
        <Parameter Name="changed" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="entitySetName">Nombre del conjunto de entidades al que pertenece el objeto.</param>
        <param name="changed">Objeto desasociado que tiene actualizaciones de propiedades que deben aplicarse al objeto original.</param>
        <summary>Aplica los cambios de propiedades de un objeto desasociado a un objeto ya asociado al contexto del objeto.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El método <xref:System.Data.Objects.ObjectContext.ApplyCurrentValues%2A> se usa para aplicar los cambios de propiedades de una versión desasociada de un objeto que se ha modificado a la versión original asociada a <xref:System.Data.Objects.ObjectContext>. Esto es compatible con los escenarios, como los servicios Web, donde un objeto entidad se desasocia y se envía a una aplicación remota en que se actualizan propiedades. Este método permite aplicar más fácilmente estos cambios en el objeto original.  
  
 Después de ejecutar <xref:System.Data.Objects.ObjectContext.ApplyCurrentValues%2A>, el objeto se encuentra en el estado <xref:System.Data.EntityState.Modified>. Debe llamar al método <xref:System.Data.Objects.ObjectContext.SaveChanges%2A> para actualizar el origen de datos.  
  
 El objeto original debe existir en el <xref:System.Data.Objects.ObjectStateManager> y tener el estado <xref:System.Data.EntityState.Modified> o <xref:System.Data.EntityState.Unchanged>. Solo se modifica el objeto original si hay propiedades modificadas en el `changed` objeto.  
  
 La propiedad <xref:System.Data.Objects.DataClasses.EntityObject.EntityKey%2A> del objeto proporcionado se debe establecer en un valor de <xref:System.Data.EntityKey> válido.  
  
 <xref:System.Data.Objects.ObjectContext.ApplyCurrentValues%2A> no afecta a las propiedades de navegación ni a los objetos relacionados.  
  
 <xref:System.Data.Objects.ObjectContext.ApplyCurrentValues%2A> solo establece propiedades que existen en los metadatos de entidad para el tipo. Por ejemplo, las propiedades que se agregan en una clase parcial no se incluyen en la operación <xref:System.Data.Objects.ObjectContext.ApplyCurrentValues%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Cuando <paramref name="entitySetName" /> es <see langword="null" /> o una cadena vacía.  
  
O bien 
Cuando <paramref name="changed" /> es <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Cuando <see cref="T:System.Data.Metadata.Edm.EntitySet" /> de <paramref name="entitySetName" /> no coincide con <see cref="T:System.Data.Metadata.Edm.EntitySet" /> de <see cref="T:System.Data.EntityKey" /> del objeto.  
  
O bien 
Cuando la entidad se encuentra en un estado distinto de <see cref="F:System.Data.EntityState.Modified" /> o <see cref="F:System.Data.EntityState.Unchanged" />.  
  
O bien 
El objeto original no está asociado al contexto.</exception>
        <exception cref="T:System.ArgumentException">Cuando el tipo del objeto <paramref name="changed" /> no es el mismo tipo que el objeto original.</exception>
      </Docs>
    </Member>
    <Member MemberName="Attach">
      <MemberSignature Language="C#" Value="public void Attach (System.Data.Objects.DataClasses.IEntityWithKey entity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Attach(class System.Data.Objects.DataClasses.IEntityWithKey entity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.ObjectContext.Attach(System.Data.Objects.DataClasses.IEntityWithKey)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Attach (entity As IEntityWithKey)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Attach(System::Data::Objects::DataClasses::IEntityWithKey ^ entity);" />
      <MemberSignature Language="F#" Value="member this.Attach : System.Data.Objects.DataClasses.IEntityWithKey -&gt; unit" Usage="objectContext.Attach entity" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="entity" Type="System.Data.Objects.DataClasses.IEntityWithKey" />
      </Parameters>
      <Docs>
        <param name="entity">Objeto que se va a asociar.</param>
        <summary>Asocia un objeto o un gráfico de objetos al contexto del objeto cuando el objeto tiene una clave de entidad.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Llame a <xref:System.Data.Objects.ObjectContext.Attach%2A> en el <xref:System.Data.Objects.ObjectContext> para asociar el objeto al contexto del objeto. Hágalo cuando el objeto ya exista en el origen de datos, pero no esté todavía asociado al contexto. Para obtener más información, consulte [personalizar objetos](https://msdn.microsoft.com/library/af6f07ce-2261-4c65-87cf-d018ad082921).  
  
 <xref:System.Data.Objects.ObjectContext.Attach%2A> se usa para asociar un objeto o el objeto de nivel superior de un gráfico de objetos.  
  
 El objeto que se va a asociar debe implementar <xref:System.Data.Objects.DataClasses.IEntityWithKey> para exponer una <xref:System.Data.EntityKey>. Todas las clases de entidad generadas implementan <xref:System.Data.Objects.DataClasses.IEntityWithKey>.  
  
 Al asociar los objetos relacionados, también se debe llamar `Attach` en el <xref:System.Data.Objects.DataClasses.EntityReference%601> o <xref:System.Data.Objects.DataClasses.EntityCollection%601> para definir la relación.  
  
 Este método llama al método <xref:System.Data.Objects.ObjectContext.AttachTo%2A>.  
  
 Al asociar objetos deben tenerse en cuenta las consideraciones siguientes:  
  
-   Si el objeto que se asocia tiene objetos relacionados, esos objetos también se asociarán al contexto del objeto.  
  
-   Los objetos se asocian al contexto del objeto en un estado sin modificar.  
  
-   El objeto que se pasa al método <xref:System.Data.Objects.ObjectContext.Attach%2A> debe tener un valor de <xref:System.Data.Objects.DataClasses.EntityObject.EntityKey%2A> válido. Si el objeto no tiene un valor de <xref:System.Data.Objects.DataClasses.EntityObject.EntityKey%2A> válido, use el método <xref:System.Data.Objects.ObjectContext.AttachTo%2A> para especificar el nombre del conjunto de entidades.  
  
   
  
## Examples  
 El ejemplo de este tema se basa en el [modelo AdventureWorks Sales](https://msdn.microsoft.com/library/f16cd988-673f-4376-b034-129ca93c7832). En este ejemplo, se asocian dos objetos y, a continuación, se define la relación.  
  
 [!code-csharp[DP ObjectServices Concepts#AttachRelatedObjects](~/samples/snippets/csharp/VS_Snippets_Data/DP ObjectServices Concepts/CS/Source.cs#attachrelatedobjects)]
 [!code-vb[DP ObjectServices Concepts#AttachRelatedObjects](~/samples/snippets/visualbasic/VS_Snippets_Data/DP ObjectServices Concepts/VB/Source.vb#attachrelatedobjects)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El valor de <paramref name="entity" /> es <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Clave de entidad no válida.</exception>
        <altmember cref="M:System.Data.Objects.ObjectSet`1.Attach(`0)" />
      </Docs>
    </Member>
    <Member MemberName="AttachTo">
      <MemberSignature Language="C#" Value="public void AttachTo (string entitySetName, object entity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AttachTo(string entitySetName, object entity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.ObjectContext.AttachTo(System.String,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AttachTo (entitySetName As String, entity As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AttachTo(System::String ^ entitySetName, System::Object ^ entity);" />
      <MemberSignature Language="F#" Value="member this.AttachTo : string * obj -&gt; unit" Usage="objectContext.AttachTo (entitySetName, entity)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="entitySetName" Type="System.String" />
        <Parameter Name="entity" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="entitySetName">Representa el nombre del conjunto de entidades, que puede estar calificado por el nombre del contenedor de entidades.</param>
        <param name="entity">
          <see cref="T:System.Object" /> que se va a asociar.</param>
        <summary>Asocia un objeto o un gráfico de objetos al contexto del objeto de un conjunto de entidades determinado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Llame a <xref:System.Data.Objects.ObjectContext.AttachTo%2A> en el <xref:System.Data.Objects.ObjectContext> para asociar el objeto a una entidad específica definida en el contexto del objeto o si el objeto tiene un `null` (`Nothing` en Visual Basic) <xref:System.Data.EntityKey> valor. Para obtener más información, consulte [adjuntar y desasociar objetos](https://msdn.microsoft.com/library/41d5c1ef-1b78-4502-aa10-7e1438d62d23).  
  
 El objeto que se va a asociar puede ser un solo objeto o ser parte del gráfico.  
  
 Las reglas para el `entitySetName` formato son los siguientes:  
  
-   Si el <xref:System.Data.Objects.ObjectContext.DefaultContainerName%2A> propiedad es `null`, el `entitySetName` tiene que ser un nombre completo como en  *\<Entity Container Name >*. *\<Nombre del conjunto de entidades >*.  
  
-   Si el <xref:System.Data.Objects.ObjectContext.DefaultContainerName%2A> no `null`, el `entitySetName` puede ser  *\<Entity Container Name >*. *\<Nombre del conjunto de entidades >* o  *\<nombre del conjunto de entidades >*.  
  
 No es necesario que el objeto que se va a asociar tenga asociada una <xref:System.Data.EntityKey>. Si el objeto no tiene una clave de entidad, a continuación, `entitySetName` no puede ser una cadena vacía.  
  
 Si el objeto que se asocia tiene un <xref:System.Data.EntityKey> y `entitySetName` tiene un valor, el <xref:System.Data.Metadata.Edm.EntitySet> de la entidad de clave debe coincidir con el <xref:System.Data.Metadata.Edm.EntitySet> que se encontró basándose en el `entitySetName` y el nombre del contenedor de entidades.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El valor de <paramref name="entity" /> es <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Conjunto de entidades no válido.  
  
O bien 
El objeto tiene una clave temporal.  
  
O bien 
El objeto tiene una <see cref="T:System.Data.EntityKey" /> y el <see cref="T:System.Data.Metadata.Edm.EntitySet" /> no coincide con el conjunto de entidades pasado como argumento del método.  
  
O bien 
El objeto no tiene una <see cref="T:System.Data.EntityKey" /> y no se proporciona ningún conjunto de entidades.  
  
O bien 
Cualquier objeto del gráfico de objetos tiene una <see cref="T:System.Data.EntityKey" />temporal.  
  
O bien 
Cualquier objeto del gráfico de objetos tiene una <see cref="T:System.Data.EntityKey" /> no válida (por ejemplo, los valores de la clave no coinciden con los valores del objeto).  
  
O bien 
No se encontró el conjunto de entidades a partir del nombre <paramref name="entitySetName" /> y el nombre del contenedor de entidades especificados.  
  
O bien 
Cualquier objeto del gráfico de objetos ya existe en otro administrador de estados.</exception>
        <altmember cref="M:System.Data.Objects.ObjectSet`1.Attach(`0)" />
        <related type="Article" href="https://msdn.microsoft.com/library/338d8a55-05cc-46b0-bbb8-1379d77068e9">Trabajar con objetos (Entity Framework)</related>
      </Docs>
    </Member>
    <Member MemberName="CommandTimeout">
      <MemberSignature Language="C#" Value="public Nullable&lt;int&gt; CommandTimeout { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Nullable`1&lt;int32&gt; CommandTimeout" />
      <MemberSignature Language="DocId" Value="P:System.Data.Objects.ObjectContext.CommandTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Property CommandTimeout As Nullable(Of Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Nullable&lt;int&gt; CommandTimeout { Nullable&lt;int&gt; get(); void set(Nullable&lt;int&gt; value); };" />
      <MemberSignature Language="F#" Value="member this.CommandTimeout : Nullable&lt;int&gt; with get, set" Usage="System.Data.Objects.ObjectContext.CommandTimeout" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece el valor de tiempo de espera, en segundos, para todas las operaciones del contexto del objeto. El valor <see langword="null" /> indica que se usará el valor predeterminado del proveedor subyacente.</summary>
        <value>Valor <see cref="T:System.Int32" /> que es el valor de tiempo de espera, en segundos.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El proveedor de conexiones subyacente define el tiempo de espera predeterminado para las consultas de objeto y la operación <xref:System.Data.Objects.ObjectContext.SaveChanges%2A>. Sin embargo, puede invalidar este valor de tiempo de espera predeterminado con la propiedad <xref:System.Data.Objects.ObjectContext.CommandTimeout%2A> de <xref:System.Data.Objects.ObjectContext>, tal y como se muestra en el ejemplo siguiente.  
  
 [!code-csharp[DP ObjectServices Concepts#QueryTimeout](~/samples/snippets/csharp/VS_Snippets_Data/DP ObjectServices Concepts/CS/Source.cs#querytimeout)]
 [!code-vb[DP ObjectServices Concepts#QueryTimeout](~/samples/snippets/visualbasic/VS_Snippets_Data/DP ObjectServices Concepts/VB/Source.vb#querytimeout)]  
  
 Haga esto cuando tenga una consulta compleja o cuando otros problemas de rendimiento sean la causa de que, con frecuencia, se agote el tiempo de espera de las consultas o de las llamadas a <xref:System.Data.Objects.ObjectContext.SaveChanges%2A>.  
  
   
  
## Examples  
 [Consultas de objeto](https://msdn.microsoft.com/library/0768033c-876f-471d-85d5-264884349276)  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">El valor del tiempo de espera es menor que 0.</exception>
      </Docs>
    </Member>
    <Member MemberName="Connection">
      <MemberSignature Language="C#" Value="public System.Data.Common.DbConnection Connection { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Data.Common.DbConnection Connection" />
      <MemberSignature Language="DocId" Value="P:System.Data.Objects.ObjectContext.Connection" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Connection As DbConnection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Data::Common::DbConnection ^ Connection { System::Data::Common::DbConnection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Connection : System.Data.Common.DbConnection" Usage="System.Data.Objects.ObjectContext.Connection" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Common.DbConnection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene la conexión usada por el contexto del objeto.</summary>
        <value>Objeto <see cref="T:System.Data.Common.DbConnection" /> que es la conexión.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esta propiedad devuelve el objeto de conexión que se pasó al constructor o se creó durante la construcción. Propiedad de la conexión viene determinada por los constructores utilizados.  
  
   
  
## Examples  
 En este ejemplo se crea un objeto <xref:System.Data.EntityClient.EntityConnection> que se pasa al constructor de un <xref:System.Data.Objects.ObjectContext> de larga duración. La conexión se abre manualmente. El objeto <xref:System.Data.EntityClient.EntityConnection> y el objeto <xref:System.Data.Objects.ObjectContext> se eliminan manualmente.  
  
 [!code-csharp[DP ObjectServices Concepts#OpenEntityConnection](~/samples/snippets/csharp/VS_Snippets_Data/DP ObjectServices Concepts/CS/Source.cs#openentityconnection)]
 [!code-vb[DP ObjectServices Concepts#OpenEntityConnection](~/samples/snippets/visualbasic/VS_Snippets_Data/DP ObjectServices Concepts/VB/Source.vb#openentityconnection)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Cuando la instancia <see cref="T:System.Data.Objects.ObjectContext" /> se ha eliminado.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/338d8a55-05cc-46b0-bbb8-1379d77068e9">Trabajar con objetos (Entity Framework)</related>
      </Docs>
    </Member>
    <Member MemberName="ContextOptions">
      <MemberSignature Language="C#" Value="public System.Data.Objects.ObjectContextOptions ContextOptions { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Data.Objects.ObjectContextOptions ContextOptions" />
      <MemberSignature Language="DocId" Value="P:System.Data.Objects.ObjectContext.ContextOptions" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ContextOptions As ObjectContextOptions" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Data::Objects::ObjectContextOptions ^ ContextOptions { System::Data::Objects::ObjectContextOptions ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ContextOptions : System.Data.Objects.ObjectContextOptions" Usage="System.Data.Objects.ObjectContext.ContextOptions" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Data.Objects.ObjectContextOptions</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene la instancia de <see cref="T:System.Data.Objects.ObjectContextOptions" /> que contiene opciones que afectan al comportamiento de <see cref="T:System.Data.Objects.ObjectContext" />.</summary>
        <value>Instancia de <see cref="T:System.Data.Objects.ObjectContextOptions" /> que contiene opciones que afectan al comportamiento de <see cref="T:System.Data.Objects.ObjectContext" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateDatabase">
      <MemberSignature Language="C#" Value="public void CreateDatabase ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CreateDatabase() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.ObjectContext.CreateDatabase" />
      <MemberSignature Language="VB.NET" Value="Public Sub CreateDatabase ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CreateDatabase();" />
      <MemberSignature Language="F#" Value="member this.CreateDatabase : unit -&gt; unit" Usage="objectContext.CreateDatabase " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Crea la base de datos usando la conexión del origen de datos actual y los metadatos de <see cref="T:System.Data.Metadata.Edm.StoreItemCollection" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Llame a <xref:System.Data.Objects.ObjectContext.CreateDatabaseScript%2A> para ver la secuencia de comandos de data definition language (DDL). Llame a <xref:System.Data.Objects.ObjectContext.CreateDatabase%2A> para ejecutar el script.  
  
 La mayoría del trabajo se delegue en el <xref:System.Data.Common.DbProviderServices.CreateDatabase%2A> método.  
  
 Para obtener más información, consulte [trabajar con lenguaje de definición de datos](~/docs/framework/data/adonet/ef/working-with-data-definition-language.md).  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Data.Objects.ObjectContext.CreateDatabaseScript" />
        <altmember cref="M:System.Data.Objects.ObjectContext.DatabaseExists" />
      </Docs>
    </Member>
    <Member MemberName="CreateDatabaseScript">
      <MemberSignature Language="C#" Value="public string CreateDatabaseScript ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string CreateDatabaseScript() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.ObjectContext.CreateDatabaseScript" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateDatabaseScript () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ CreateDatabaseScript();" />
      <MemberSignature Language="F#" Value="member this.CreateDatabaseScript : unit -&gt; string" Usage="objectContext.CreateDatabaseScript " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Genera un script del lenguaje de definición de datos (DDL) que crea objetos de esquema (tablas, claves principales, claves externas) para los metadatos de <see cref="T:System.Data.Metadata.Edm.StoreItemCollection" />. <see cref="T:System.Data.Metadata.Edm.StoreItemCollection" /> carga los metadatos de los archivos del lenguaje de definición de esquemas de almacenamiento (SSDL, Store Schema Definition Language).</summary>
        <returns>Script DDL que crea objetos de esquema para los metadatos de <see cref="T:System.Data.Metadata.Edm.StoreItemCollection" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Llame a <xref:System.Data.Objects.ObjectContext.CreateDatabaseScript%2A> para ver la secuencia de comandos DDL. Llame a <xref:System.Data.Objects.ObjectContext.CreateDatabase%2A> para ejecutar el script.  
  
 La mayoría del trabajo se delegue en el <xref:System.Data.Common.DbProviderServices.CreateDatabase%2A> método.  
  
 Para obtener más información, consulte [trabajar con lenguaje de definición de datos](~/docs/framework/data/adonet/ef/working-with-data-definition-language.md).  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Data.Objects.ObjectContext.CreateDatabase" />
        <altmember cref="M:System.Data.Objects.ObjectContext.DatabaseExists" />
      </Docs>
    </Member>
    <Member MemberName="CreateEntityKey">
      <MemberSignature Language="C#" Value="public System.Data.EntityKey CreateEntityKey (string entitySetName, object entity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.EntityKey CreateEntityKey(string entitySetName, object entity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.ObjectContext.CreateEntityKey(System.String,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateEntityKey (entitySetName As String, entity As Object) As EntityKey" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::EntityKey ^ CreateEntityKey(System::String ^ entitySetName, System::Object ^ entity);" />
      <MemberSignature Language="F#" Value="member this.CreateEntityKey : string * obj -&gt; System.Data.EntityKey" Usage="objectContext.CreateEntityKey (entitySetName, entity)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.EntityKey</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="entitySetName" Type="System.String" />
        <Parameter Name="entity" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="entitySetName">El nombre completo del conjunto de entidades al que pertenece el objeto entidad.</param>
        <param name="entity">Objeto cuya clave de entidad se recupera.</param>
        <summary>Crea la clave de entidad para un objeto determinado o devuelve la clave de entidad si ya existe.</summary>
        <returns>
          <see cref="T:System.Data.EntityKey" /> del objeto.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si un <xref:System.Data.EntityKey> no existe para el `entity`, el <xref:System.Data.Objects.ObjectContext.CreateEntityKey%2A> método crea una nueva clave para ella.  
  
 Este método se usa para determinar si un objeto que tiene la misma <xref:System.Data.EntityKey> ya está asociado al <xref:System.Data.Objects.ObjectContext>. Si un objeto que tiene la misma <xref:System.Data.EntityKey> ya está asociado, se produce una excepción. Use el método <xref:System.Data.Objects.ObjectContext.CreateEntityKey%2A> para intentar recuperar la <xref:System.Data.EntityKey> del objeto desasociado antes llamar al método <xref:System.Data.Objects.ObjectContext.Attach%2A>.  
  
   
  
## Examples  
 El ejemplo de este tema se basa en el [modelo AdventureWorks Sales](https://msdn.microsoft.com/library/f16cd988-673f-4376-b034-129ca93c7832). En este ejemplo, se usa <xref:System.Data.Objects.ObjectContext.CreateEntityKey%2A> para recuperar la clave de entidad de un objeto existente.  
  
 [!code-csharp[DP ObjectServices Concepts#ApplyItemUpdatesGetObject](~/samples/snippets/csharp/VS_Snippets_Data/DP ObjectServices Concepts/CS/Source.cs#applyitemupdatesgetobject)]
 [!code-vb[DP ObjectServices Concepts#ApplyItemUpdatesGetObject](~/samples/snippets/visualbasic/VS_Snippets_Data/DP ObjectServices Concepts/VB/Source.vb#applyitemupdatesgetobject)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Cuando cualquiera de los parámetros es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Cuando <paramref name="entitySetName" /> está vacío.  
  
O bien 
Cuando el tipo del objeto <paramref name="entity" /> no existe en el conjunto de entidades.  
  
O bien 
Cuando <paramref name="entitySetName" /> no es un nombre completo.</exception>
        <exception cref="T:System.InvalidOperationException">Cuando la clave de entidad no se puede construir correctamente basándose en los parámetros proporcionados.</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateObject&lt;T&gt;">
      <MemberSignature Language="C#" Value="public T CreateObject&lt;T&gt; () where T : class;" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance !!T CreateObject&lt;class T&gt;() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.ObjectContext.CreateObject``1" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateObject(Of T As Class) () As T" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : class T CreateObject();" />
      <MemberSignature Language="F#" Value="member this.CreateObject : unit -&gt; 'T (requires 'T : null)" Usage="objectContext.CreateObject " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <ParameterAttribute>ReferenceTypeConstraint</ParameterAttribute>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters />
      <Docs>
        <typeparam name="T">Tipo de objeto que se va a devolver.</typeparam>
        <summary>Crea y devuelve una instancia del tipo solicitado.</summary>
        <returns>Instancia del tipo <paramref name="T" /> solicitado o instancia de un tipo derivado que permite usar <paramref name="T" /> con Entity Framework. El objeto devuelto es una instancia del tipo solicitado o una instancia de un tipo derivado que permite que el tipo solicitado se use con Entity Framework.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Data.Objects.ObjectContext.CreateObject%2A> método se utiliza con clases de datos personalizadas POCO para asegurarse de que se puede administrar correctamente el objeto devuelto por Entity Framework. Para obtener más información, consulte [requisitos para crear objetos proxy POCO](https://msdn.microsoft.com/library/dcdbf982-9b9d-4582-806a-64de4a1c03c8) y [trabajar con entidades POCO](https://msdn.microsoft.com/library/5e0fb82a-b6d1-41a1-b37b-c12db61629d3).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateObjectSet&lt;TEntity&gt;">
      <MemberSignature Language="C#" Value="public System.Data.Objects.ObjectSet&lt;TEntity&gt; CreateObjectSet&lt;TEntity&gt; () where TEntity : class;" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.Objects.ObjectSet`1&lt;!!TEntity&gt; CreateObjectSet&lt;class TEntity&gt;() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.ObjectContext.CreateObjectSet``1" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateObjectSet(Of TEntity As Class) () As ObjectSet(Of TEntity)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TEntity&gt;&#xA; where TEntity : class System::Data::Objects::ObjectSet&lt;TEntity&gt; ^ CreateObjectSet();" />
      <MemberSignature Language="F#" Value="member this.CreateObjectSet : unit -&gt; System.Data.Objects.ObjectSet&lt;'Entity (requires 'Entity : null)&gt; (requires 'Entity : null)" Usage="objectContext.CreateObjectSet " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Objects.ObjectSet&lt;TEntity&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TEntity">
          <Constraints>
            <ParameterAttribute>ReferenceTypeConstraint</ParameterAttribute>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters />
      <Docs>
        <typeparam name="TEntity">Tipo de entidad del objeto <see cref="T:System.Data.Objects.ObjectSet`1" /> solicitado.</typeparam>
        <summary>Crea una nueva instancia de <see cref="T:System.Data.Objects.ObjectSet`1" /> que se usa para consultar, agregar, modificar y eliminar objetos del tipo de entidad especificado.</summary>
        <returns>La nueva instancia de <see cref="T:System.Data.Objects.ObjectSet`1" />.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException">La propiedad <see cref="P:System.Data.Objects.ObjectContext.DefaultContainerName" /> no está establecida en <see cref="T:System.Data.Objects.ObjectContext" />.  
  
O bien 
El tipo especificado pertenece a más de un conjunto de entidades.</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateObjectSet&lt;TEntity&gt;">
      <MemberSignature Language="C#" Value="public System.Data.Objects.ObjectSet&lt;TEntity&gt; CreateObjectSet&lt;TEntity&gt; (string entitySetName) where TEntity : class;" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.Objects.ObjectSet`1&lt;!!TEntity&gt; CreateObjectSet&lt;class TEntity&gt;(string entitySetName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.ObjectContext.CreateObjectSet``1(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateObjectSet(Of TEntity As Class) (entitySetName As String) As ObjectSet(Of TEntity)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TEntity&gt;&#xA; where TEntity : class System::Data::Objects::ObjectSet&lt;TEntity&gt; ^ CreateObjectSet(System::String ^ entitySetName);" />
      <MemberSignature Language="F#" Value="member this.CreateObjectSet : string -&gt; System.Data.Objects.ObjectSet&lt;'Entity (requires 'Entity : null)&gt; (requires 'Entity : null)" Usage="objectContext.CreateObjectSet entitySetName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Objects.ObjectSet&lt;TEntity&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TEntity">
          <Constraints>
            <ParameterAttribute>ReferenceTypeConstraint</ParameterAttribute>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="entitySetName" Type="System.String" />
      </Parameters>
      <Docs>
        <typeparam name="TEntity">Tipo de entidad del objeto <see cref="T:System.Data.Objects.ObjectSet`1" /> solicitado.</typeparam>
        <param name="entitySetName">Nombre del conjunto de entidades para el <see cref="T:System.Data.Objects.ObjectSet`1" /> devuelto. El nombre del contenedor predeterminado debe calificar la cadena si la propiedad <see cref="P:System.Data.Objects.ObjectContext.DefaultContainerName" /> no está establecida en <see cref="T:System.Data.Objects.ObjectContext" />.</param>
        <summary>Crea una nueva instancia de <see cref="T:System.Data.Objects.ObjectSet`1" /> que se usa para consultar, agregar, modificar y eliminar objetos del tipo especificado y con el nombre del conjunto de entidades indicado.</summary>
        <returns>La nueva instancia de <see cref="T:System.Data.Objects.ObjectSet`1" />.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException">
          <see cref="T:System.Data.Metadata.Edm.EntitySet" /> de <paramref name="entitySetName" /> no coincide con <see cref="T:System.Data.Metadata.Edm.EntitySet" /> de <see cref="T:System.Data.EntityKey" /> del objeto.  
  
O bien 
La propiedad <see cref="P:System.Data.Objects.ObjectContext.DefaultContainerName" /> no está establecida en <see cref="T:System.Data.Objects.ObjectContext" /> y el nombre no está calificado como parte del parámetro <paramref name="entitySetName" />.  
  
O bien 
El tipo especificado pertenece a más de un conjunto de entidades.</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateProxyTypes">
      <MemberSignature Language="C#" Value="public void CreateProxyTypes (System.Collections.Generic.IEnumerable&lt;Type&gt; types);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CreateProxyTypes(class System.Collections.Generic.IEnumerable`1&lt;class System.Type&gt; types) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.ObjectContext.CreateProxyTypes(System.Collections.Generic.IEnumerable{System.Type})" />
      <MemberSignature Language="VB.NET" Value="Public Sub CreateProxyTypes (types As IEnumerable(Of Type))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CreateProxyTypes(System::Collections::Generic::IEnumerable&lt;Type ^&gt; ^ types);" />
      <MemberSignature Language="F#" Value="member this.CreateProxyTypes : seq&lt;Type&gt; -&gt; unit" Usage="objectContext.CreateProxyTypes types" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="types" Type="System.Collections.Generic.IEnumerable&lt;System.Type&gt;" />
      </Parameters>
      <Docs>
        <param name="types">Enumeración de objetos <see cref="T:System.Type" /> que representan clases de datos personalizadas que se asignan al modelo conceptual.</param>
        <summary>Genera un tipo equivalente que se puede usar con Entity Framework para cada tipo de la enumeración proporcionada.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Los tipos individuales en el `types` enumeración que no se asignan a un tipo de entidad en el modelo conceptual se omiten.  
  
 Para obtener más información, consulte [requisitos para crear objetos proxy POCO](https://msdn.microsoft.com/library/dcdbf982-9b9d-4582-806a-64de4a1c03c8) y [trabajar con entidades POCO](https://msdn.microsoft.com/library/5e0fb82a-b6d1-41a1-b37b-c12db61629d3).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateQuery&lt;T&gt;">
      <MemberSignature Language="C#" Value="public System.Data.Objects.ObjectQuery&lt;T&gt; CreateQuery&lt;T&gt; (string queryString, params System.Data.Objects.ObjectParameter[] parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.Objects.ObjectQuery`1&lt;!!T&gt; CreateQuery&lt;T&gt;(string queryString, class System.Data.Objects.ObjectParameter[] parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.ObjectContext.CreateQuery``1(System.String,System.Data.Objects.ObjectParameter[])" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateQuery(Of T) (queryString As String, ParamArray parameters As ObjectParameter()) As ObjectQuery(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; System::Data::Objects::ObjectQuery&lt;T&gt; ^ CreateQuery(System::String ^ queryString, ... cli::array &lt;System::Data::Objects::ObjectParameter ^&gt; ^ parameters);" />
      <MemberSignature Language="F#" Value="member this.CreateQuery : string * System.Data.Objects.ObjectParameter[] -&gt; System.Data.Objects.ObjectQuery&lt;'T&gt;" Usage="objectContext.CreateQuery (queryString, parameters)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Objects.ObjectQuery&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="queryString" Type="System.String" />
        <Parameter Name="parameters" Type="System.Data.Objects.ObjectParameter[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">Tipo de entidad del objeto <see cref="T:System.Data.Objects.ObjectQuery`1" /> devuelto.</typeparam>
        <param name="queryString">Cadena de consulta que se va a ejecutar.</param>
        <param name="parameters">Parámetros que hay que pasar a la consulta.</param>
        <summary>Crea una <see cref="T:System.Data.Objects.ObjectQuery`1" /> en el contexto del objeto actual usando la cadena de consulta especificada.</summary>
        <returns>
          <see cref="T:System.Data.Objects.ObjectQuery`1" /> del tipo especificado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use <xref:System.Data.Objects.ObjectContext.CreateQuery%2A> para crear una <xref:System.Data.Objects.ObjectQuery%601> del tipo especificado que pertenece al contexto del objeto actual.  
  
   
  
## Examples  
 En este ejemplo se basa en el [modelo AdventureWorks Sales](https://msdn.microsoft.com/library/f16cd988-673f-4376-b034-129ca93c7832).  
  
 En el ejemplo, se crea una consulta simple y se recorre en iteración la colección de resultados.  
  
 [!code-csharp[DP ObjectServices Concepts#CreateQuery](~/samples/snippets/csharp/VS_Snippets_Data/DP ObjectServices Concepts/CS/Source.cs#createquery)]
 [!code-vb[DP ObjectServices Concepts#CreateQuery](~/samples/snippets/visualbasic/VS_Snippets_Data/DP ObjectServices Concepts/VB/Source.vb#createquery)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El parámetro <paramref name="queryString" /> o <paramref name="parameters" /> es <see langword="null" />.</exception>
        <related type="Article" href="~/docs/framework/data/adonet/ef/querying-a-conceptual-model.md">Consultar un modelo conceptual</related>
      </Docs>
    </Member>
    <Member MemberName="DatabaseExists">
      <MemberSignature Language="C#" Value="public bool DatabaseExists ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool DatabaseExists() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.ObjectContext.DatabaseExists" />
      <MemberSignature Language="VB.NET" Value="Public Function DatabaseExists () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool DatabaseExists();" />
      <MemberSignature Language="F#" Value="member this.DatabaseExists : unit -&gt; bool" Usage="objectContext.DatabaseExists " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Comprueba si la base de datos que se especifica como la base de datos en la conexión del origen de datos actual existe en el origen de datos.</summary>
        <returns>Es <see langword="true" /> si la base de datos existe.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La mayoría del trabajo se delegue en el <xref:System.Data.Common.DbProviderServices.DatabaseExists%2A> método.  
  
 Para obtener más información, consulte [trabajar con lenguaje de definición de datos](~/docs/framework/data/adonet/ef/working-with-data-definition-language.md).  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Data.Objects.ObjectContext.CreateDatabase" />
        <altmember cref="M:System.Data.Objects.ObjectContext.CreateDatabaseScript" />
      </Docs>
    </Member>
    <Member MemberName="DefaultContainerName">
      <MemberSignature Language="C#" Value="public string DefaultContainerName { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string DefaultContainerName" />
      <MemberSignature Language="DocId" Value="P:System.Data.Objects.ObjectContext.DefaultContainerName" />
      <MemberSignature Language="VB.NET" Value="Public Property DefaultContainerName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ DefaultContainerName { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.DefaultContainerName : string with get, set" Usage="System.Data.Objects.ObjectContext.DefaultContainerName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece el nombre del contenedor predeterminado.</summary>
        <value>
          <see cref="T:System.String" /> que es el nombre predeterminado del contenedor.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.Objects.ObjectContext.DefaultContainerName%2A> nunca devuelve `null`; devuelve el valor que se estableció o una cadena vacía. El usuario puede establecer esta propiedad en `null`, pero internamente el nombre se establecerá en una cadena vacía, por lo que el usuario nunca necesite comprobar una cadena vacía y `null`.  
  
 El nombre del contenedor predeterminado también se define como parte de un constructor. Si el nombre del contenedor predeterminado se establece a través del constructor protegido, la propiedad se vuelve de solo lectura.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/338d8a55-05cc-46b0-bbb8-1379d77068e9">Trabajar con objetos (Entity Framework)</related>
      </Docs>
    </Member>
    <Member MemberName="DeleteDatabase">
      <MemberSignature Language="C#" Value="public void DeleteDatabase ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DeleteDatabase() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.ObjectContext.DeleteDatabase" />
      <MemberSignature Language="VB.NET" Value="Public Sub DeleteDatabase ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DeleteDatabase();" />
      <MemberSignature Language="F#" Value="member this.DeleteDatabase : unit -&gt; unit" Usage="objectContext.DeleteDatabase " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Elimina la base de datos que se especifica como base de datos en la conexión del origen de datos actual.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La mayoría del trabajo se delegue en el <xref:System.Data.Common.DbProviderServices.DeleteDatabase%2A> método.  
  
 Para obtener más información, consulte [trabajar con lenguaje de definición de datos](~/docs/framework/data/adonet/ef/working-with-data-definition-language.md).  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Data.Objects.ObjectContext.CreateDatabase" />
        <altmember cref="M:System.Data.Objects.ObjectContext.CreateDatabaseScript" />
        <altmember cref="M:System.Data.Objects.ObjectContext.DatabaseExists" />
      </Docs>
    </Member>
    <Member MemberName="DeleteObject">
      <MemberSignature Language="C#" Value="public void DeleteObject (object entity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DeleteObject(object entity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.ObjectContext.DeleteObject(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub DeleteObject (entity As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DeleteObject(System::Object ^ entity);" />
      <MemberSignature Language="F#" Value="member this.DeleteObject : obj -&gt; unit" Usage="objectContext.DeleteObject entity" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="entity" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="entity">Objeto que especifica la entidad que hay que eliminar. El objeto puede estar en cualquier estado excepto <see cref="F:System.Data.EntityState.Detached" />.</param>
        <summary>Marca un objeto para su eliminación.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Marca un objeto para su eliminación del <xref:System.Data.Objects.ObjectStateManager>. El objeto se elimina del origen de datos cuando se llama al método <xref:System.Data.Objects.ObjectContext.SaveChanges%2A>.  
  
 Al eliminar el objeto primario, también se eliminan todos los objetos secundarios de la relación restringida. Este resultado es el mismo que el de habilitar la propiedad `CascadeDelete` en la asociación para la relación.  
  
 El <xref:System.Data.Objects.ObjectContext.DeleteObject%2A> método puede llamarse en objetos que ya se han eliminado.  
  
   
  
## Examples  
 Estos ejemplos se basan en el [modelo AdventureWorks Sales](https://msdn.microsoft.com/library/f16cd988-673f-4376-b034-129ca93c7832).  
  
 Este ejemplo se construye un <xref:System.Data.EntityKey> con un ProductID concreto, utiliza la clave para recuperar un objeto de producto del origen de datos, elimina el producto y guarda los cambios en la base de datos.  
  
 [!code-csharp[DP ObjectServices Concepts#DeleteObject](~/samples/snippets/csharp/VS_Snippets_Data/DP ObjectServices Concepts/CS/Source.cs#deleteobject)]
 [!code-vb[DP ObjectServices Concepts#DeleteObject](~/samples/snippets/visualbasic/VS_Snippets_Data/DP ObjectServices Concepts/VB/Source.vb#deleteobject)]  
  
 En este ejemplo elimina un elemento de pedido existente, agrega un nuevo elemento y guarda los cambios en la base de datos.  
  
 [!code-csharp[DP ObjectServices Concepts#SaveChanges](~/samples/snippets/csharp/VS_Snippets_Data/DP ObjectServices Concepts/CS/Source.cs#savechanges)]
 [!code-vb[DP ObjectServices Concepts#SaveChanges](~/samples/snippets/visualbasic/VS_Snippets_Data/DP ObjectServices Concepts/VB/Source.vb#savechanges)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El valor de <paramref name="entity" /> es <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="entity" /> no existe.</exception>
        <altmember cref="M:System.Data.Objects.ObjectSet`1.DeleteObject(`0)" />
        <related type="Article" href="https://msdn.microsoft.com/library/338d8a55-05cc-46b0-bbb8-1379d77068e9">Trabajar con objetos (Entity Framework)</related>
      </Docs>
    </Member>
    <Member MemberName="Detach">
      <MemberSignature Language="C#" Value="public void Detach (object entity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Detach(object entity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.ObjectContext.Detach(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Detach (entity As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Detach(System::Object ^ entity);" />
      <MemberSignature Language="F#" Value="member this.Detach : obj -&gt; unit" Usage="objectContext.Detach entity" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="entity" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="entity">Objeto que se va a desasociar. Solamente se quita el objeto <paramref name="entity" />; si hay objetos relacionados de los que el mismo <see cref="T:System.Data.Objects.ObjectStateManager" /> realiza un seguimiento, dichos objetos no se desasociarán automáticamente.</param>
        <summary>Quita el objeto del contexto del objeto.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quita el objeto del <xref:System.Data.Objects.ObjectStateManager>. Esto deshabilita el seguimiento de cambios y la resolución de identidades para ese objeto. Para obtener más información, consulte [adjuntar y desasociar objetos](https://msdn.microsoft.com/library/41d5c1ef-1b78-4502-aa10-7e1438d62d23).  
  
 Después de llamar al método <xref:System.Data.Objects.ObjectContext.Detach%2A>, el sistema dejará de mantener referencias que señalan este objeto y el recolector de elementos no utilizados puede recogerlo.  
  
> [!NOTE]
>  La recolección de elementos no utilizados solo se puede producir si el código de usuario no tiene ninguna referencia al objeto desasociado.  
  
 Al desasociar objetos deben tenerse en cuenta las consideraciones siguientes:  
  
-   <xref:System.Data.Objects.ObjectContext.Detach%2A> solo afecta al objeto específico que se pasa al método. Si el objeto que se desasocia tiene objetos relacionados en el contexto del objeto, esos objetos no se desasocian.  
  
-   La desasociación de objetos no afecta a los datos del origen de datos.  
  
-   Durante una operación de desasociar, no se aplican las directivas de eliminación en cascada ni las restricciones referenciales en cascada.  
  
 Para obtener más información, consulte [adjuntar y desasociar objetos](https://msdn.microsoft.com/library/41d5c1ef-1b78-4502-aa10-7e1438d62d23).  
  
   
  
## Examples  
 [!code-csharp[DP ObjectServices Concepts#DetachObjects](~/samples/snippets/csharp/VS_Snippets_Data/DP ObjectServices Concepts/CS/Source.cs#detachobjects)]
 [!code-vb[DP ObjectServices Concepts#DetachObjects](~/samples/snippets/visualbasic/VS_Snippets_Data/DP ObjectServices Concepts/VB/Source.vb#detachobjects)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El valor de <paramref name="entity" /> es <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="entity" /> no está asociada a este <see cref="T:System.Data.Objects.ObjectContext" /> (por ejemplo, se creó recientemente y todavía no se ha asociado con ningún contexto, se obtuvo a través de algún otro contexto o ya estaba desasociada).</exception>
        <altmember cref="M:System.Data.Objects.ObjectSet`1.Detach(`0)" />
        <related type="Article" href="https://msdn.microsoft.com/library/338d8a55-05cc-46b0-bbb8-1379d77068e9">Trabajar con objetos (Entity Framework)</related>
      </Docs>
    </Member>
    <Member MemberName="DetectChanges">
      <MemberSignature Language="C#" Value="public void DetectChanges ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DetectChanges() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.ObjectContext.DetectChanges" />
      <MemberSignature Language="VB.NET" Value="Public Sub DetectChanges ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DetectChanges();" />
      <MemberSignature Language="F#" Value="member this.DetectChanges : unit -&gt; unit" Usage="objectContext.DetectChanges " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Garantiza que los cambios de <see cref="T:System.Data.Objects.ObjectStateEntry" /> se sincronizan con los cambios en todos los objetos de los que <see cref="T:System.Data.Objects.ObjectStateManager" /> realiza un seguimiento.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Dispose">
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Libera los recursos usados por el contexto del objeto.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.ObjectContext.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberSignature Language="F#" Value="abstract member Dispose : unit -&gt; unit&#xA;override this.Dispose : unit -&gt; unit" Usage="objectContext.Dispose " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Libera los recursos usados por el contexto del objeto.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método cierra la conexión si se abrió por Entity Framework. Después de <xref:System.Data.Objects.ObjectContext.Dispose%2A> se llama, las operaciones que requieren una conexión abierta, como ejecutar una consulta o llamar a la <xref:System.Data.Objects.ObjectQuery.ToTraceString%2A> método, se producirá una excepción. Las operaciones que no requieren una conexión abierta, como crear una consulta o asociar objetos, no producirán una excepción. El <xref:System.Data.Objects.ObjectContext.Dispose%2A> método no cierra cualquier conexión abierta de forma explícita.  
  
 Limitar el ámbito de un <xref:System.Data.Objects.ObjectContext> dentro de un `using` bloque (`Using` en Visual Basic) garantiza que los recursos se eliminan correctamente. Para obtener más información, consulte [administrar conexiones y transacciones](https://msdn.microsoft.com/library/b6659d2a-9a45-4e98-acaa-d7a8029e5b99).  
  
 El <xref:System.Data.Objects.ObjectContext.Dispose> llamadas al método el `virtual` (`Overridable` en Visual Basic) <xref:System.Data.Objects.ObjectContext.Dispose%28System.Boolean%29> método.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/338d8a55-05cc-46b0-bbb8-1379d77068e9">Trabajar con objetos (Entity Framework)</related>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected virtual void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.ObjectContext.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void Dispose(bool disposing);" />
      <MemberSignature Language="F#" Value="abstract member Dispose : bool -&gt; unit&#xA;override this.Dispose : bool -&gt; unit" Usage="objectContext.Dispose disposing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">Es <see langword="true" /> para liberar tanto recursos administrados como no administrados; es <see langword="false" /> para liberar únicamente recursos no administrados.</param>
        <summary>Libera los recursos usados por el contexto del objeto.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método cierra la conexión. Después de <xref:System.Data.Objects.ObjectContext.Dispose%2A> se llama, las operaciones que requieren una conexión abierta, como ejecutar una consulta o llamar a la <xref:System.Data.Objects.ObjectQuery.ToTraceString%2A> método, se producirá una excepción. Las operaciones que no requieren una conexión abierta, como crear una consulta o asociar objetos, no producirán una excepción.  
  
 Limitar el ámbito de un <xref:System.Data.Objects.ObjectContext> dentro de un `using` bloque (`Using` en Visual Basic) garantiza que se eliminen los recursos correctamente. Para obtener más información, consulte [administrar conexiones y transacciones](https://msdn.microsoft.com/library/b6659d2a-9a45-4e98-acaa-d7a8029e5b99).  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/338d8a55-05cc-46b0-bbb8-1379d77068e9">Trabajar con objetos (Entity Framework)</related>
      </Docs>
    </Member>
    <Member MemberName="ExecuteFunction">
      <MemberSignature Language="C#" Value="public int ExecuteFunction (string functionName, params System.Data.Objects.ObjectParameter[] parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ExecuteFunction(string functionName, class System.Data.Objects.ObjectParameter[] parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.ObjectContext.ExecuteFunction(System.String,System.Data.Objects.ObjectParameter[])" />
      <MemberSignature Language="VB.NET" Value="Public Function ExecuteFunction (functionName As String, ParamArray parameters As ObjectParameter()) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int ExecuteFunction(System::String ^ functionName, ... cli::array &lt;System::Data::Objects::ObjectParameter ^&gt; ^ parameters);" />
      <MemberSignature Language="F#" Value="member this.ExecuteFunction : string * System.Data.Objects.ObjectParameter[] -&gt; int" Usage="objectContext.ExecuteFunction (functionName, parameters)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="functionName" Type="System.String" />
        <Parameter Name="parameters" Type="System.Data.Objects.ObjectParameter[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="functionName">Nombre del procedimiento almacenado o de la función. El nombre puede incluir el nombre del contenedor, como <c>&lt;Nombre del contenedor&gt;.&lt;Nombre de la función&gt;</c>. Cuando se conoce el nombre del contenedor predeterminado, solo se requiere el nombre de la función.</param>
        <param name="parameters">Matriz de objetos <see cref="T:System.Data.Objects.ObjectParameter" />.</param>
        <summary>Ejecuta un procedimiento almacenado o una función que se define en el origen de datos y se expresa en el modelo conceptual, descarta cualquier resultado devuelto de la función y devuelve el número de filas afectadas por la ejecución.</summary>
        <returns>El número de filas afectadas.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException">El parámetro <paramref name="function" /> es null o está vacío. 
O bien 
 No se ha encontrado <paramref name="function" />.</exception>
        <exception cref="T:System.InvalidOperationException">El lector de entidades no admite este parámetro <paramref name="function" />.  
  
O bien 
No coinciden los tipos en el lector y el parámetro <paramref name="function" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ExecuteFunction&lt;TElement&gt;">
      <MemberSignature Language="C#" Value="public System.Data.Objects.ObjectResult&lt;TElement&gt; ExecuteFunction&lt;TElement&gt; (string functionName, params System.Data.Objects.ObjectParameter[] parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.Objects.ObjectResult`1&lt;!!TElement&gt; ExecuteFunction&lt;TElement&gt;(string functionName, class System.Data.Objects.ObjectParameter[] parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.ObjectContext.ExecuteFunction``1(System.String,System.Data.Objects.ObjectParameter[])" />
      <MemberSignature Language="VB.NET" Value="Public Function ExecuteFunction(Of TElement) (functionName As String, ParamArray parameters As ObjectParameter()) As ObjectResult(Of TElement)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TElement&gt;&#xA; System::Data::Objects::ObjectResult&lt;TElement&gt; ^ ExecuteFunction(System::String ^ functionName, ... cli::array &lt;System::Data::Objects::ObjectParameter ^&gt; ^ parameters);" />
      <MemberSignature Language="F#" Value="member this.ExecuteFunction : string * System.Data.Objects.ObjectParameter[] -&gt; System.Data.Objects.ObjectResult&lt;'Element&gt;" Usage="objectContext.ExecuteFunction (functionName, parameters)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Data.Objects.ObjectResult&lt;TElement&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TElement" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="functionName" Type="System.String" />
        <Parameter Name="parameters" Type="System.Data.Objects.ObjectParameter[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="TElement">Tipo de entidad del valor <see cref="T:System.Data.Objects.ObjectResult`1" /> devuelto cuando la función se ejecuta en el origen de datos. Este tipo debe implementar <see cref="T:System.Data.Objects.DataClasses.IEntityWithChangeTracker" />.</typeparam>
        <param name="functionName">Nombre del procedimiento almacenado o de la función. El nombre puede incluir el nombre del contenedor, como <c>&lt;Nombre del contenedor&gt;.&lt;Nombre de la función&gt;</c>. Cuando se conoce el nombre del contenedor predeterminado, solo se requiere el nombre de la función.</param>
        <param name="parameters">Matriz de objetos <see cref="T:System.Data.Objects.ObjectParameter" />.</param>
        <summary>Ejecuta un procedimiento almacenado o una función que se define en el origen de datos y se asigna en el modelo conceptual, con los parámetros especificados. Devuelve un objeto <see cref="T:System.Data.Objects.ObjectResult`1" /> con tipo.</summary>
        <returns>
          <see cref="T:System.Data.Objects.ObjectResult`1" /> para los datos devueltos por el procedimiento almacenado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Data.Objects.ObjectContext.ExecuteFunction%2A> método es un método auxiliar que se usa para ejecutar procedimientos almacenados o funciones que se definen en el origen de datos y se expresa en el modelo conceptual. Las herramientas de Entity Data Model generan un método para cada uno en el modelo conceptual. Estos métodos llaman a fuertemente tipadas `ExecuteFunction` para devolver un tipo <xref:System.Data.Objects.ObjectResult%601>. Para obtener más información, consulte [código de la aplicación mediante procedimientos almacenados (marco de entidad)](https://msdn.microsoft.com/library/d13dd33f-fcf9-4e86-bd00-74bc31521536).  
  
 Se requieren todos los parámetros para la función en la matriz de parámetros y todos los tipos se comprueban con los metadatos de la función de importación, incluido el tipo de la propia función. `null` se permiten valores para los tipos de valor CLR. El proveedor realiza la validación de parámetros.  
  
 El <xref:System.Data.Objects.ObjectContext.ExecuteFunction%2A> método usa la <xref:System.Data.Objects.MergeOption> valor <xref:System.Data.Objects.MergeOption.AppendOnly>. Por lo tanto, si ya existe un objeto en el contexto del objeto, no se cargará desde el origen de datos.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">El parámetro <paramref name="function" /> es null o está vacío. 
O bien 
 No se ha encontrado <paramref name="function" />.</exception>
        <exception cref="T:System.InvalidOperationException">El lector de entidades no admite este parámetro <paramref name="function" />.  
  
O bien 
No coinciden los tipos en el lector y el parámetro <paramref name="function" />.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/338d8a55-05cc-46b0-bbb8-1379d77068e9">Trabajar con objetos (Entity Framework)</related>
      </Docs>
    </Member>
    <Member MemberName="ExecuteFunction&lt;TElement&gt;">
      <MemberSignature Language="C#" Value="public System.Data.Objects.ObjectResult&lt;TElement&gt; ExecuteFunction&lt;TElement&gt; (string functionName, System.Data.Objects.MergeOption mergeOption, params System.Data.Objects.ObjectParameter[] parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.Objects.ObjectResult`1&lt;!!TElement&gt; ExecuteFunction&lt;TElement&gt;(string functionName, valuetype System.Data.Objects.MergeOption mergeOption, class System.Data.Objects.ObjectParameter[] parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.ObjectContext.ExecuteFunction``1(System.String,System.Data.Objects.MergeOption,System.Data.Objects.ObjectParameter[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TElement&gt;&#xA; System::Data::Objects::ObjectResult&lt;TElement&gt; ^ ExecuteFunction(System::String ^ functionName, System::Data::Objects::MergeOption mergeOption, ... cli::array &lt;System::Data::Objects::ObjectParameter ^&gt; ^ parameters);" />
      <MemberSignature Language="F#" Value="member this.ExecuteFunction : string * System.Data.Objects.MergeOption * System.Data.Objects.ObjectParameter[] -&gt; System.Data.Objects.ObjectResult&lt;'Element&gt;" Usage="objectContext.ExecuteFunction (functionName, mergeOption, parameters)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Objects.ObjectResult&lt;TElement&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TElement" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="functionName" Type="System.String" />
        <Parameter Name="mergeOption" Type="System.Data.Objects.MergeOption" />
        <Parameter Name="parameters" Type="System.Data.Objects.ObjectParameter[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="TElement">Tipo de entidad del valor <see cref="T:System.Data.Objects.ObjectResult`1" /> devuelto cuando la función se ejecuta en el origen de datos. Este tipo debe implementar <see cref="T:System.Data.Objects.DataClasses.IEntityWithChangeTracker" />.</typeparam>
        <param name="functionName">Nombre del procedimiento almacenado o de la función. El nombre puede incluir el nombre del contenedor, como <c>&lt;Nombre del contenedor&gt;.&lt;Nombre de la función&gt;</c>. Cuando se conoce el nombre del contenedor predeterminado, solo se requiere el nombre de la función.</param>
        <param name="mergeOption">
          <see cref="T:System.Data.Objects.MergeOption" /> que se debe usar al ejecutar la consulta.</param>
        <param name="parameters">Matriz de objetos <see cref="T:System.Data.Objects.ObjectParameter" />.</param>
        <summary>Ejecuta la función o el procedimiento almacenado especificado que se define en el origen de datos y se expresa en el modelo conceptual, con los parámetros y la opción de combinación especificados. Devuelve un objeto <see cref="T:System.Data.Objects.ObjectResult`1" /> con tipo.</summary>
        <returns>
          <see cref="T:System.Data.Objects.ObjectResult`1" /> para los datos devueltos por el procedimiento almacenado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Data.Objects.ObjectContext.ExecuteFunction%2A> método es un método auxiliar que se usa para ejecutar procedimientos almacenados o funciones que se definen en el origen de datos y se expresa en el modelo conceptual. Las herramientas de Entity Data Model generan un método para cada uno en el modelo conceptual. Estos métodos llaman a fuertemente tipadas `ExecuteFunction` para devolver un tipo <xref:System.Data.Objects.ObjectResult%601>. Para obtener más información, consulte [código de la aplicación mediante procedimientos almacenados (marco de entidad)](https://msdn.microsoft.com/library/d13dd33f-fcf9-4e86-bd00-74bc31521536).  
  
 Se requieren todos los parámetros para la función en la matriz de parámetros y todos los tipos se comprueban con los metadatos de la función de importación, incluido el tipo de la propia función. `null` se permiten valores para los tipos de valor CLR. El proveedor realiza la validación de parámetros.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">El parámetro <paramref name="function" /> es null o está vacío. 
O bien 
 No se ha encontrado <paramref name="function" />.</exception>
        <exception cref="T:System.InvalidOperationException">El lector de entidades no admite este parámetro <paramref name="function" />.  
  
O bien 
No coinciden los tipos en el lector y el parámetro <paramref name="function" />.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/338d8a55-05cc-46b0-bbb8-1379d77068e9">Trabajar con objetos (Entity Framework)</related>
      </Docs>
    </Member>
    <Member MemberName="ExecuteStoreCommand">
      <MemberSignature Language="C#" Value="public int ExecuteStoreCommand (string commandText, params object[] parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ExecuteStoreCommand(string commandText, object[] parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.ObjectContext.ExecuteStoreCommand(System.String,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function ExecuteStoreCommand (commandText As String, ParamArray parameters As Object()) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int ExecuteStoreCommand(System::String ^ commandText, ... cli::array &lt;System::Object ^&gt; ^ parameters);" />
      <MemberSignature Language="F#" Value="member this.ExecuteStoreCommand : string * obj[] -&gt; int" Usage="objectContext.ExecuteStoreCommand (commandText, parameters)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="commandText" Type="System.String" />
        <Parameter Name="parameters" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="commandText">Comando que se va a ejecutar, en el lenguaje nativo del origen de datos.</param>
        <param name="parameters">Matriz de parámetros que se van a pasar al comando.</param>
        <summary>Ejecuta un comando arbitrario directamente en el origen de datos usando la conexión existente.</summary>
        <returns>El número de filas afectadas.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La utilización de comandos con parámetros ayuda en la protección contra ataques por inyección de código SQL, en los que un atacante "inyecta" un comando en una instrucción SQL que pone en peligro la seguridad del servidor. Los comandos con parámetros protegen contra un ataque de inyección de SQL por lo que garantiza que los valores recibidos desde un origen externo se pasan como valores solamente y no forma parte de la instrucción SQL. Como resultado, los comandos SQL insertados en un valor no se ejecutan en el origen de datos. En cambio, se evalúan únicamente como un valor de parámetro. Además de las ventajas de seguridad, los comandos con parámetros proporcionan un método práctico para organizar los valores que se pasan con una instrucción SQL o a un procedimiento almacenado.  
  
 El valor `parameters` puede ser una matriz de objetos <xref:System.Data.Common.DbParameter> o una matriz de valores de parámetro. Si solo se proporcionan los valores, una matriz de <xref:System.Data.Common.DbParameter> objetos se crean en función del orden de los valores de la matriz.  
  
 El comando de almacén se ejecuta en el contexto de la transacción actual, si existe una transacción actual.  
  
 Para obtener más información, consulte:  
  
 [Ejecutar directamente comandos Store](https://msdn.microsoft.com/library/5708d0a2-3f76-4825-978a-d06ff5c4bb3d) y  
  
 [Cómo: ejecutar directamente comandos contra el origen de datos](https://msdn.microsoft.com/library/def3cc87-cfff-4dee-83cf-1a40c73a2d01)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ExecuteStoreQuery&lt;TElement&gt;">
      <MemberSignature Language="C#" Value="public System.Data.Objects.ObjectResult&lt;TElement&gt; ExecuteStoreQuery&lt;TElement&gt; (string commandText, params object[] parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.Objects.ObjectResult`1&lt;!!TElement&gt; ExecuteStoreQuery&lt;TElement&gt;(string commandText, object[] parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.ObjectContext.ExecuteStoreQuery``1(System.String,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function ExecuteStoreQuery(Of TElement) (commandText As String, ParamArray parameters As Object()) As ObjectResult(Of TElement)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TElement&gt;&#xA; System::Data::Objects::ObjectResult&lt;TElement&gt; ^ ExecuteStoreQuery(System::String ^ commandText, ... cli::array &lt;System::Object ^&gt; ^ parameters);" />
      <MemberSignature Language="F#" Value="member this.ExecuteStoreQuery : string * obj[] -&gt; System.Data.Objects.ObjectResult&lt;'Element&gt;" Usage="objectContext.ExecuteStoreQuery (commandText, parameters)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Data.Objects.ObjectResult&lt;TElement&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TElement" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="commandText" Type="System.String" />
        <Parameter Name="parameters" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="TElement">To be added.</typeparam>
        <param name="commandText">Comando que se va a ejecutar, en el lenguaje nativo del origen de datos.</param>
        <param name="parameters">Matriz de parámetros que se van a pasar al comando.</param>
        <summary>Ejecuta una consulta directamente con el origen de datos que devuelve una secuencia de resultados con tipo.</summary>
        <returns>Enumeración de objetos de tipo <paramref name="TResult" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Data.Objects.ObjectContext.ExecuteStoreQuery%2A> método usa la conexión existente para ejecutar un comando arbitrario directamente contra el origen de datos. El comando de almacenamiento se ejecuta en el contexto de la transacción actual, si esa transacción existe.  
  
 Llamar al método <xref:System.Data.Objects.ObjectContext.ExecuteStoreQuery%2A> es equivalente a llamar al método <xref:System.Data.Common.DbCommand.ExecuteReader%2A> de la clase <xref:System.Data.Common.DbCommand>, solamente <xref:System.Data.Objects.ObjectContext.ExecuteStoreQuery%2A> devuelve entidades, y el <xref:System.Data.Common.DbCommand.ExecuteReader%2A> devuelve valores de propiedad en el <xref:System.Data.Common.DbDataReader>.  
  
 Llame a la <xref:System.Data.Objects.ObjectContext.ExecuteStoreQuery%2A> con la entidad especificada, establezca nombre, si desea que se realiza un seguimiento de los resultados.  
  
 Llame a la <xref:System.Data.Objects.ObjectContext.Translate%2A> método para traducir un <xref:System.Data.Common.DbDataReader> en los objetos de entidad cuando el lector contiene filas de datos que se asignan al tipo de entidad especificado.  
  
 La utilización de comandos con parámetros ayuda en la protección contra ataques por inyección de código SQL, en los que un atacante "inyecta" un comando en una instrucción SQL que pone en peligro la seguridad del servidor. Los comandos con parámetros protegen contra un ataque de inyección de SQL por lo que garantiza que los valores recibidos desde un origen externo se pasan como valores solamente y no forma parte de la instrucción SQL. Como resultado, los comandos SQL insertados en un valor no se ejecutan en el origen de datos. En cambio, se evalúan únicamente como un valor de parámetro. Además de las ventajas de seguridad, los comandos con parámetros proporcionan un método práctico para organizar los valores que se pasan con una instrucción SQL o a un procedimiento almacenado.  
  
 El valor `parameters` puede ser una matriz de objetos <xref:System.Data.Common.DbParameter> o una matriz de valores de parámetro. Si solo se proporcionan los valores, una matriz de <xref:System.Data.Common.DbParameter> objetos se crean en función del orden de los valores de la matriz.  
  
 Para obtener más información, consulte:  
  
 [Ejecutar directamente comandos Store](https://msdn.microsoft.com/library/5708d0a2-3f76-4825-978a-d06ff5c4bb3d) y  
  
 [Cómo: ejecutar directamente comandos contra el origen de datos](https://msdn.microsoft.com/library/def3cc87-cfff-4dee-83cf-1a40c73a2d01)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ExecuteStoreQuery&lt;TEntity&gt;">
      <MemberSignature Language="C#" Value="public System.Data.Objects.ObjectResult&lt;TEntity&gt; ExecuteStoreQuery&lt;TEntity&gt; (string commandText, string entitySetName, System.Data.Objects.MergeOption mergeOption, params object[] parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.Objects.ObjectResult`1&lt;!!TEntity&gt; ExecuteStoreQuery&lt;TEntity&gt;(string commandText, string entitySetName, valuetype System.Data.Objects.MergeOption mergeOption, object[] parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.ObjectContext.ExecuteStoreQuery``1(System.String,System.String,System.Data.Objects.MergeOption,System.Object[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TEntity&gt;&#xA; System::Data::Objects::ObjectResult&lt;TEntity&gt; ^ ExecuteStoreQuery(System::String ^ commandText, System::String ^ entitySetName, System::Data::Objects::MergeOption mergeOption, ... cli::array &lt;System::Object ^&gt; ^ parameters);" />
      <MemberSignature Language="F#" Value="member this.ExecuteStoreQuery : string * string * System.Data.Objects.MergeOption * obj[] -&gt; System.Data.Objects.ObjectResult&lt;'Entity&gt;" Usage="objectContext.ExecuteStoreQuery (commandText, entitySetName, mergeOption, parameters)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Objects.ObjectResult&lt;TEntity&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TEntity" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="commandText" Type="System.String" />
        <Parameter Name="entitySetName" Type="System.String" />
        <Parameter Name="mergeOption" Type="System.Data.Objects.MergeOption" />
        <Parameter Name="parameters" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="TEntity">To be added.</typeparam>
        <param name="commandText">Comando que se va a ejecutar, en el lenguaje nativo del origen de datos.</param>
        <param name="entitySetName">Conjunto de entidades del tipo <c>TResult</c>. Si no se proporciona un nombre del conjunto de entidades, no se va a hacer un seguimiento de los resultados.</param>
        <param name="mergeOption">
          <see cref="T:System.Data.Objects.MergeOption" /> que se debe usar al ejecutar la consulta. El valor predeterminado es <see cref="F:System.Data.Objects.MergeOption.AppendOnly" />.</param>
        <param name="parameters">Matriz de parámetros que se van a pasar al comando.</param>
        <summary>Ejecuta una consulta directamente con el origen de datos y devuelve una secuencia de resultados con tipo. Especifique el conjunto de entidades y la opción de combinación para que se pueda realizar el seguimiento de los resultados de la consulta como entidades.</summary>
        <returns>Enumeración de objetos de tipo <paramref name="TResult" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Data.Objects.ObjectContext.ExecuteStoreQuery%2A> método usa la conexión existente para ejecutar un comando arbitrario directamente contra el origen de datos. El comando de almacenamiento se ejecuta en el contexto de la transacción actual, si esa transacción existe.  
  
 Llamar al método <xref:System.Data.Objects.ObjectContext.ExecuteStoreQuery%2A> es equivalente a llamar al método <xref:System.Data.Common.DbCommand.ExecuteReader%2A> de la clase <xref:System.Data.Common.DbCommand>, solamente <xref:System.Data.Objects.ObjectContext.ExecuteStoreQuery%2A> devuelve entidades, y el <xref:System.Data.Common.DbCommand.ExecuteReader%2A> devuelve valores de propiedad en el <xref:System.Data.Common.DbDataReader>.  
  
 Especifique el que nombre de conjunto de entidades si desea que los resultados que se realiza un seguimiento de las entidades.  
  
 Llame a <xref:System.Data.Objects.ObjectContext.Translate%2A> método para traducir un <xref:System.Data.Common.DbDataReader> en los objetos de entidad cuando el lector contiene filas de datos que se asignan al tipo de entidad especificado.  
  
 La utilización de comandos con parámetros ayuda en la protección contra ataques por inyección de código SQL, en los que un atacante "inyecta" un comando en una instrucción SQL que pone en peligro la seguridad del servidor. Los comandos con parámetros protegen contra un ataque de inyección de SQL por lo que garantiza que los valores recibidos desde un origen externo se pasan como valores solamente y no forma parte de la instrucción SQL. Como resultado, los comandos SQL insertados en un valor no se ejecutan en el origen de datos. En cambio, se evalúan únicamente como un valor de parámetro. Además de las ventajas de seguridad, los comandos con parámetros proporcionan un método práctico para organizar los valores que se pasan con una instrucción SQL o a un procedimiento almacenado.  
  
 El valor `parameters` puede ser una matriz de objetos <xref:System.Data.Common.DbParameter> o una matriz de valores de parámetro. Si solo se proporcionan los valores, una matriz de <xref:System.Data.Common.DbParameter> objetos se crean en función del orden de los valores de la matriz.  
  
 Para obtener más información, consulte:  
  
 [Ejecutar directamente comandos Store](https://msdn.microsoft.com/library/5708d0a2-3f76-4825-978a-d06ff5c4bb3d) y  
  
 [Cómo: ejecutar directamente comandos contra el origen de datos](https://msdn.microsoft.com/library/def3cc87-cfff-4dee-83cf-1a40c73a2d01)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetKnownProxyTypes">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;Type&gt; GetKnownProxyTypes ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;class System.Type&gt; GetKnownProxyTypes() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.ObjectContext.GetKnownProxyTypes" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetKnownProxyTypes () As IEnumerable(Of Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Collections::Generic::IEnumerable&lt;Type ^&gt; ^ GetKnownProxyTypes();" />
      <MemberSignature Language="F#" Value="static member GetKnownProxyTypes : unit -&gt; seq&lt;Type&gt;" Usage="System.Data.Objects.ObjectContext.GetKnownProxyTypes " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Type&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Devuelve todos los tipos de proxy existentes.</summary>
        <returns>
          <see cref="T:System.Collections.Generic.IEnumerable`1" /> de todos los tipos de proxy existentes.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Data.Objects.ObjectContext.GetKnownProxyTypes%2A> método se utiliza cuando la generación de objetos proxy está habilitada para entidades POCO. Para obtener más información, consulte [requisitos para crear objetos proxy POCO](https://msdn.microsoft.com/library/dcdbf982-9b9d-4582-806a-64de4a1c03c8) y [trabajar con entidades POCO](https://msdn.microsoft.com/library/5e0fb82a-b6d1-41a1-b37b-c12db61629d3).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetObjectByKey">
      <MemberSignature Language="C#" Value="public object GetObjectByKey (System.Data.EntityKey key);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object GetObjectByKey(class System.Data.EntityKey key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.ObjectContext.GetObjectByKey(System.Data.EntityKey)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetObjectByKey (key As EntityKey) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ GetObjectByKey(System::Data::EntityKey ^ key);" />
      <MemberSignature Language="F#" Value="member this.GetObjectByKey : System.Data.EntityKey -&gt; obj" Usage="objectContext.GetObjectByKey key" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.Data.EntityKey" />
      </Parameters>
      <Docs>
        <param name="key">Clave del objeto que se desea encontrar.</param>
        <summary>Devuelve un objeto que tiene la clave de entidad especificada.</summary>
        <returns>Un <see cref="T:System.Object" /> que es una instancia de un tipo de entidad.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.Objects.ObjectContext.GetObjectByKey%2A> intenta recuperar un objeto que tiene la <xref:System.Data.EntityKey> especificada en el <xref:System.Data.Objects.ObjectStateManager>. Si el objeto no está cargado actualmente en el contexto del objeto, se ejecuta una consulta para intentar devolver el objeto desde el origen de datos. Para obtener más información, consulte [las consultas de objeto](https://msdn.microsoft.com/library/0768033c-876f-471d-85d5-264884349276).  
  
 <xref:System.Data.Objects.ObjectContext.GetObjectByKey%2A> inicia una <xref:System.Data.ObjectNotFoundException> cuando no se puede encontrar el objeto. Para no tener que controlar esta excepción, use en su lugar el método <xref:System.Data.Objects.ObjectContext.TryGetObjectByKey%2A>.  
  
 Este método devolverá objetos con el estado <xref:System.Data.EntityState.Deleted>.  
  
 No se puede usar una clave temporal para devolver un objeto desde el origen de datos.  
  
   
  
## Examples  
 En este ejemplo se basa en el [modelo AdventureWorks Sales](https://msdn.microsoft.com/library/f16cd988-673f-4376-b034-129ca93c7832). En el ejemplo, se crea una <xref:System.Data.EntityKey> para una entidad del tipo especificado y, a continuación, se busca una entidad por su clave.  
  
 [!code-csharp[DP ObjectServices Concepts#EntityKeyClass_GetObjectByKey](~/samples/snippets/csharp/VS_Snippets_Data/DP ObjectServices Concepts/CS/Source.cs#entitykeyclass_getobjectbykey)]
 [!code-vb[DP ObjectServices Concepts#EntityKeyClass_GetObjectByKey](~/samples/snippets/visualbasic/VS_Snippets_Data/DP ObjectServices Concepts/VB/Source.vb#entitykeyclass_getobjectbykey)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El parámetro <paramref name="key" /> es <see langword="null" />.</exception>
        <exception cref="T:System.Data.ObjectNotFoundException">El objeto no se encuentra en <see cref="T:System.Data.Objects.ObjectStateManager" /> ni en el origen de datos.</exception>
        <related type="Article" href="~/docs/framework/data/adonet/ef/querying-a-conceptual-model.md">Consultar datos como objetos (Entity Framework)</related>
        <related type="Article" href="https://msdn.microsoft.com/library/338d8a55-05cc-46b0-bbb8-1379d77068e9">Trabajar con objetos (Entity Framework)</related>
      </Docs>
    </Member>
    <Member MemberName="GetObjectType">
      <MemberSignature Language="C#" Value="public static Type GetObjectType (Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetObjectType(class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.ObjectContext.GetObjectType(System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetObjectType(Type ^ type);" />
      <MemberSignature Language="F#" Value="static member GetObjectType : Type -&gt; Type" Usage="System.Data.Objects.ObjectContext.GetObjectType type" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="type">
          <see cref="T:System.Type" /> del objeto proxy.</param>
        <summary>Devuelve el tipo de la entidad POCO asociada a un objeto proxy de un tipo especificado.</summary>
        <returns>
          <see cref="T:System.Type" /> de la entidad POCO asociada.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Data.Objects.ObjectContext.GetObjectType%2A> método se utiliza cuando la generación de objetos proxy está habilitada para entidades POCO. Para obtener más información, consulte [requisitos para crear objetos proxy POCO](https://msdn.microsoft.com/library/dcdbf982-9b9d-4582-806a-64de4a1c03c8) y [trabajar con entidades POCO](https://msdn.microsoft.com/library/5e0fb82a-b6d1-41a1-b37b-c12db61629d3).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="LoadProperty">
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Carga explícitamente un objeto relacionado cuando está usando clases de datos personalizadas POCO.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Al usar clases de datos personalizadas POCO, los objetos relacionados no se puede cargar explícitamente como instancias de tipos de entidad generados por las herramientas de Entity Data Model. Esto es porque las herramientas generan las propiedades de navegación que devuelven un <xref:System.Data.Objects.DataClasses.EntityCollection%601> o <xref:System.Data.Objects.DataClasses.EntityReference%601> de objetos relacionados cuando <xref:System.Data.Objects.DataClasses.RelatedEnd.Load%2A> se llama en un <xref:System.Data.Objects.DataClasses.RelatedEnd>. Todavía se pueden cargar entidades POCO mediante la carga diferida estableciendo la <xref:System.Data.Objects.ObjectContextOptions.LazyLoadingEnabled%2A> propiedad `true` en la instancia de <xref:System.Data.Objects.ObjectContextOptions> devuelta por la <xref:System.Data.Objects.ObjectContext.ContextOptions%2A?displayProperty=nameWithType> propiedad, o mediante el uso de la carga diligente con el <xref:System.Data.Objects.ObjectQuery%601.Include%2A> método en el <xref:System.Data.Objects.ObjectQuery%601>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="LoadProperty">
      <MemberSignature Language="C#" Value="public void LoadProperty (object entity, string navigationProperty);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void LoadProperty(object entity, string navigationProperty) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.ObjectContext.LoadProperty(System.Object,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub LoadProperty (entity As Object, navigationProperty As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void LoadProperty(System::Object ^ entity, System::String ^ navigationProperty);" />
      <MemberSignature Language="F#" Value="member this.LoadProperty : obj * string -&gt; unit" Usage="objectContext.LoadProperty (entity, navigationProperty)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="entity" Type="System.Object" />
        <Parameter Name="navigationProperty" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="entity">Entidad para la que se van a cargar objetos relacionados.</param>
        <param name="navigationProperty">Nombre de la propiedad de navegación que devuelve los objetos relacionados que se van a cargar.</param>
        <summary>Carga explícitamente un objeto relacionado con el objeto proporcionado por la propiedad de navegación especificada y usando la opción de combinación predeterminada.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Data.Objects.ObjectContext.LoadProperty%2A> método debe llamarse para lograr la carga explícita cuando se usa clases de datos personalizadas POCO.  
  
 Después de llamar a <xref:System.Data.Objects.ObjectContext.LoadProperty%2A>, el objeto relacionado que puede obtenerse a través de las propiedades de navegación de la entidad de origen.  
  
 Al usar clases de datos personalizadas POCO, los objetos relacionados no se puede cargar explícitamente como instancias de tipos de entidad generados por las herramientas de Entity Data Model. Esto es porque las herramientas generan las propiedades de navegación que devuelven un <xref:System.Data.Objects.DataClasses.EntityCollection%601> o <xref:System.Data.Objects.DataClasses.EntityReference%601> de objetos relacionados cuando <xref:System.Data.Objects.DataClasses.RelatedEnd.Load%2A> se llama en un <xref:System.Data.Objects.DataClasses.RelatedEnd>. Todavía se pueden cargar entidades POCO mediante la carga diferida estableciendo la <xref:System.Data.Objects.ObjectContextOptions.LazyLoadingEnabled%2A> propiedad `true` en la instancia de <xref:System.Data.Objects.ObjectContextOptions> devuelta por la <xref:System.Data.Objects.ObjectContext.ContextOptions%2A?displayProperty=nameWithType> propiedad, o mediante el uso de la carga diligente con el <xref:System.Data.Objects.ObjectQuery%601.Include%2A> método en el <xref:System.Data.Objects.ObjectQuery%601>.  
  
 Cuando el <xref:System.Data.Objects.ObjectContext.LoadProperty%2A> se llama al método, los objetos se cargan en el <xref:System.Data.Objects.ObjectContext> utilizando el valor predeterminado <xref:System.Data.Objects.MergeOption> valor <xref:System.Data.Objects.MergeOption.AppendOnly>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="entity" /> está en un estado <see cref="F:System.Data.EntityState.Detached" />, <see cref="F:System.Data.EntityState.Added" /> o <see cref="F:System.Data.EntityState.Deleted" />. 
O bien 
<paramref name="entity" /> está asociada a otra instancia de <see cref="T:System.Data.Objects.ObjectContext" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="LoadProperty">
      <MemberSignature Language="C#" Value="public void LoadProperty (object entity, string navigationProperty, System.Data.Objects.MergeOption mergeOption);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void LoadProperty(object entity, string navigationProperty, valuetype System.Data.Objects.MergeOption mergeOption) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.ObjectContext.LoadProperty(System.Object,System.String,System.Data.Objects.MergeOption)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void LoadProperty(System::Object ^ entity, System::String ^ navigationProperty, System::Data::Objects::MergeOption mergeOption);" />
      <MemberSignature Language="F#" Value="member this.LoadProperty : obj * string * System.Data.Objects.MergeOption -&gt; unit" Usage="objectContext.LoadProperty (entity, navigationProperty, mergeOption)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="entity" Type="System.Object" />
        <Parameter Name="navigationProperty" Type="System.String" />
        <Parameter Name="mergeOption" Type="System.Data.Objects.MergeOption" />
      </Parameters>
      <Docs>
        <param name="entity">Entidad para la que se van a cargar objetos relacionados.</param>
        <param name="navigationProperty">Nombre de la propiedad de navegación que devuelve los objetos relacionados que se van a cargar.</param>
        <param name="mergeOption">Valor de <see cref="T:System.Data.Objects.MergeOption" /> que se va a usar al cargar los objetos relacionados.</param>
        <summary>Carga explícitamente un objeto relacionado con el objeto proporcionado por la propiedad de navegación especificada y usando la opción de combinación indicada.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Data.Objects.ObjectContext.LoadProperty%2A> método debe llamarse para lograr la carga explícita cuando se usa clases de datos personalizadas POCO.  
  
 Después de llamar a <xref:System.Data.Objects.ObjectContext.LoadProperty%2A>, el objeto relacionado que puede obtenerse a través de las propiedades de navegación de la entidad de origen.  
  
 Al usar clases de datos personalizadas POCO, los objetos relacionados no se puede cargar explícitamente como instancias de tipos de entidad generados por las herramientas de Entity Data Model. Esto es porque las herramientas generan las propiedades de navegación que devuelven un <xref:System.Data.Objects.DataClasses.EntityCollection%601> o <xref:System.Data.Objects.DataClasses.EntityReference%601> de objetos relacionados cuando <xref:System.Data.Objects.DataClasses.RelatedEnd.Load%2A> se llama en un <xref:System.Data.Objects.DataClasses.RelatedEnd>. Todavía se pueden cargar entidades POCO mediante la carga diferida estableciendo la <xref:System.Data.Objects.ObjectContextOptions.LazyLoadingEnabled%2A> propiedad `true` en la instancia de <xref:System.Data.Objects.ObjectContextOptions> devuelta por la <xref:System.Data.Objects.ObjectContext.ContextOptions%2A?displayProperty=nameWithType> propiedad, o mediante el uso de la carga diligente con el <xref:System.Data.Objects.ObjectQuery%601.Include%2A> método en el <xref:System.Data.Objects.ObjectQuery%601>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="entity" /> está en un estado <see cref="F:System.Data.EntityState.Detached" />, <see cref="F:System.Data.EntityState.Added" /> o <see cref="F:System.Data.EntityState.Deleted" />. 
O bien 
<paramref name="entity" /> está asociada a otra instancia de <see cref="T:System.Data.Objects.ObjectContext" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="LoadProperty&lt;TEntity&gt;">
      <MemberSignature Language="C#" Value="public void LoadProperty&lt;TEntity&gt; (TEntity entity, System.Linq.Expressions.Expression&lt;Func&lt;TEntity,object&gt;&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void LoadProperty&lt;TEntity&gt;(!!TEntity entity, class System.Linq.Expressions.Expression`1&lt;class System.Func`2&lt;!!TEntity, object&gt;&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.ObjectContext.LoadProperty``1(``0,System.Linq.Expressions.Expression{System.Func{``0,System.Object}})" />
      <MemberSignature Language="VB.NET" Value="Public Sub LoadProperty(Of TEntity) (entity As TEntity, selector As Expression(Of Func(Of TEntity, Object)))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TEntity&gt;&#xA; void LoadProperty(TEntity entity, System::Linq::Expressions::Expression&lt;Func&lt;TEntity, System::Object ^&gt; ^&gt; ^ selector);" />
      <MemberSignature Language="F#" Value="member this.LoadProperty : 'Entity * System.Linq.Expressions.Expression&lt;Func&lt;'Entity, obj&gt;&gt; -&gt; unit" Usage="objectContext.LoadProperty (entity, selector)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TEntity" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="entity" Type="TEntity" />
        <Parameter Name="selector" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TEntity,System.Object&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TEntity">To be added.</typeparam>
        <param name="entity">Objeto de origen para el que se van a cargar objetos relacionados.</param>
        <param name="selector">Expresión LINQ que define los objetos relacionados que se van a cargar.</param>
        <summary>Carga explícitamente un objeto relacionado con el objeto proporcionado por la consulta LINQ especificada y usando la opción de combinación predeterminada.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Data.Objects.ObjectContext.LoadProperty%2A> método debe llamarse para lograr la carga explícita cuando se usa clases de datos personalizadas POCO.  
  
 Después de llamar a <xref:System.Data.Objects.ObjectContext.LoadProperty%2A>, el objeto relacionado que puede obtenerse a través de las propiedades de navegación de la entidad de origen.  
  
 La propiedad cargar se especifica mediante una expresión LINQ, que debe tener el formato de un acceso de miembro de propiedad simple, como en `(entity) => entity.PropertyName`, donde *PropertyName* es la propiedad de navegación que devuelve los objetos relacionados que se va a cargar. Si se usan otras formas de la expresión LINQ, se producirá una excepción.  
  
 Al usar clases de datos personalizadas POCO, los objetos relacionados no se puede cargar explícitamente como instancias de tipos de entidad generados por las herramientas de Entity Data Model. Esto es porque las herramientas generan las propiedades de navegación que devuelven un <xref:System.Data.Objects.DataClasses.EntityCollection%601> o <xref:System.Data.Objects.DataClasses.EntityReference%601> de objetos relacionados cuando <xref:System.Data.Objects.DataClasses.RelatedEnd.Load%2A> se llama en un <xref:System.Data.Objects.DataClasses.RelatedEnd>. Todavía se pueden cargar entidades POCO mediante la carga diferida estableciendo la <xref:System.Data.Objects.ObjectContextOptions.LazyLoadingEnabled%2A> propiedad `true` en la instancia de <xref:System.Data.Objects.ObjectContextOptions> devuelta por la <xref:System.Data.Objects.ObjectContext.ContextOptions%2A?displayProperty=nameWithType> propiedad, o mediante el uso de la carga diligente con el <xref:System.Data.Objects.ObjectQuery%601.Include%2A> método en el <xref:System.Data.Objects.ObjectQuery%601>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="selector" /> no proporciona un parámetro de entrada válido.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="selector" /> es null.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="entity" /> está en un estado <see cref="F:System.Data.EntityState.Detached" />, <see cref="F:System.Data.EntityState.Added" /> o <see cref="F:System.Data.EntityState.Deleted" />. 
O bien 
<paramref name="entity" /> está asociada a otra instancia de <see cref="T:System.Data.Objects.ObjectContext" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="LoadProperty&lt;TEntity&gt;">
      <MemberSignature Language="C#" Value="public void LoadProperty&lt;TEntity&gt; (TEntity entity, System.Linq.Expressions.Expression&lt;Func&lt;TEntity,object&gt;&gt; selector, System.Data.Objects.MergeOption mergeOption);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void LoadProperty&lt;TEntity&gt;(!!TEntity entity, class System.Linq.Expressions.Expression`1&lt;class System.Func`2&lt;!!TEntity, object&gt;&gt; selector, valuetype System.Data.Objects.MergeOption mergeOption) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.ObjectContext.LoadProperty``1(``0,System.Linq.Expressions.Expression{System.Func{``0,System.Object}},System.Data.Objects.MergeOption)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TEntity&gt;&#xA; void LoadProperty(TEntity entity, System::Linq::Expressions::Expression&lt;Func&lt;TEntity, System::Object ^&gt; ^&gt; ^ selector, System::Data::Objects::MergeOption mergeOption);" />
      <MemberSignature Language="F#" Value="member this.LoadProperty : 'Entity * System.Linq.Expressions.Expression&lt;Func&lt;'Entity, obj&gt;&gt; * System.Data.Objects.MergeOption -&gt; unit" Usage="objectContext.LoadProperty (entity, selector, mergeOption)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TEntity" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="entity" Type="TEntity" />
        <Parameter Name="selector" Type="System.Linq.Expressions.Expression&lt;System.Func&lt;TEntity,System.Object&gt;&gt;" />
        <Parameter Name="mergeOption" Type="System.Data.Objects.MergeOption" />
      </Parameters>
      <Docs>
        <typeparam name="TEntity">To be added.</typeparam>
        <param name="entity">Objeto de origen para el que se van a cargar objetos relacionados.</param>
        <param name="selector">Expresión LINQ que define los objetos relacionados que se van a cargar.</param>
        <param name="mergeOption">Valor de <see cref="T:System.Data.Objects.MergeOption" /> que se va a usar al cargar los objetos relacionados.</param>
        <summary>Carga explícitamente un objeto relacionado con el objeto proporcionado por la consulta LINQ especificada y usando la opción de combinación indicada.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Data.Objects.ObjectContext.LoadProperty%2A> método debe llamarse para lograr la carga explícita cuando se usa clases de datos personalizadas POCO.  
  
 Después de llamar a <xref:System.Data.Objects.ObjectContext.LoadProperty%2A>, el objeto relacionado que puede obtenerse a través de las propiedades de navegación de la entidad de origen.  
  
 La propiedad cargar se especifica mediante una expresión LINQ, que debe tener el formato de un acceso de miembro de propiedad simple, como en `(entity) => entity.PropertyName` donde *PropertyName* es la propiedad de navegación que devuelve los objetos relacionados que se va a cargar. Si se usan otras formas de la expresión LINQ, se producirá una excepción.  
  
 Al usar clases de datos personalizadas POCO, los objetos relacionados no se puede cargar explícitamente como instancias de tipos de entidad generados por las herramientas de Entity Data Model. Esto es porque las herramientas generan las propiedades de navegación que devuelven un <xref:System.Data.Objects.DataClasses.EntityCollection%601> o <xref:System.Data.Objects.DataClasses.EntityReference%601> de objetos relacionados cuando <xref:System.Data.Objects.DataClasses.RelatedEnd.Load%2A> se llama en un <xref:System.Data.Objects.DataClasses.RelatedEnd>. Todavía se pueden cargar entidades POCO mediante la carga diferida estableciendo la <xref:System.Data.Objects.ObjectContextOptions.LazyLoadingEnabled%2A> propiedad `true` en la instancia de <xref:System.Data.Objects.ObjectContextOptions> devuelta por la <xref:System.Data.Objects.ObjectContext.ContextOptions%2A?displayProperty=nameWithType> propiedad, o mediante el uso de la carga diligente con el <xref:System.Data.Objects.ObjectQuery%601.Include%2A> método en el <xref:System.Data.Objects.ObjectQuery%601>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="selector" /> no proporciona un parámetro de entrada válido.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="selector" /> es null.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="entity" /> está en un estado <see cref="F:System.Data.EntityState.Detached" />, <see cref="F:System.Data.EntityState.Added" /> o <see cref="F:System.Data.EntityState.Deleted" />. 
O bien 
<paramref name="entity" /> está asociada a otra instancia de <see cref="T:System.Data.Objects.ObjectContext" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="MetadataWorkspace">
      <MemberSignature Language="C#" Value="public System.Data.Metadata.Edm.MetadataWorkspace MetadataWorkspace { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Data.Metadata.Edm.MetadataWorkspace MetadataWorkspace" />
      <MemberSignature Language="DocId" Value="P:System.Data.Objects.ObjectContext.MetadataWorkspace" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property MetadataWorkspace As MetadataWorkspace" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Data::Metadata::Edm::MetadataWorkspace ^ MetadataWorkspace { System::Data::Metadata::Edm::MetadataWorkspace ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.MetadataWorkspace : System.Data.Metadata.Edm.MetadataWorkspace" Usage="System.Data.Objects.ObjectContext.MetadataWorkspace" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Data.Metadata.Edm.MetadataWorkspace</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene el área de trabajo de metadatos usada por el contexto del objeto.</summary>
        <value>Objeto <see cref="T:System.Data.Metadata.Edm.MetadataWorkspace" /> que está asociado con este <see cref="T:System.Data.Objects.ObjectContext" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La clase <xref:System.Data.Metadata.Edm.MetadataWorkspace> es una API de tiempo de ejecución central que se puede usar para interactuar con los metadatos de Entity Data Model (EDM) en el contexto de una aplicación. Para obtener más información, consulte [área de trabajo de metadatos](https://msdn.microsoft.com/library/601aee56-3eda-4caa-9082-a01df76c5e84).  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/338d8a55-05cc-46b0-bbb8-1379d77068e9">Trabajar con objetos (Entity Framework)</related>
      </Docs>
    </Member>
    <Member MemberName="ObjectMaterialized">
      <MemberSignature Language="C#" Value="public event System.Data.Objects.ObjectMaterializedEventHandler ObjectMaterialized;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Data.Objects.ObjectMaterializedEventHandler ObjectMaterialized" />
      <MemberSignature Language="DocId" Value="E:System.Data.Objects.ObjectContext.ObjectMaterialized" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ObjectMaterialized As ObjectMaterializedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Data::Objects::ObjectMaterializedEventHandler ^ ObjectMaterialized;" />
      <MemberSignature Language="F#" Value="member this.ObjectMaterialized : System.Data.Objects.ObjectMaterializedEventHandler " Usage="member this.ObjectMaterialized : System.Data.Objects.ObjectMaterializedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Objects.ObjectMaterializedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produce cuando se crea un nuevo objeto entidad a partir de datos del origen de datos como parte de una operación de consulta o de carga.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este evento se desencadena después de todos los escalares, complejas y se han establecido las propiedades de referencia en un objeto, pero antes de que se carguen las colecciones. Si un objeto con el mismo valor de clave existe en el contexto del objeto, Entity Framework no se volverá a crear el objeto y no se provoca este evento.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ObjectStateManager">
      <MemberSignature Language="C#" Value="public System.Data.Objects.ObjectStateManager ObjectStateManager { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Data.Objects.ObjectStateManager ObjectStateManager" />
      <MemberSignature Language="DocId" Value="P:System.Data.Objects.ObjectContext.ObjectStateManager" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ObjectStateManager As ObjectStateManager" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Data::Objects::ObjectStateManager ^ ObjectStateManager { System::Data::Objects::ObjectStateManager ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ObjectStateManager : System.Data.Objects.ObjectStateManager" Usage="System.Data.Objects.ObjectContext.ObjectStateManager" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Objects.ObjectStateManager</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene el administrador de estados de objetos usado por el contexto del objeto para realizar el seguimiento de los cambios en los objetos.</summary>
        <value>
          <see cref="T:System.Data.Objects.ObjectStateManager" /> usado por este <see cref="T:System.Data.Objects.ObjectContext" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Estos ejemplos se basan en el [modelo AdventureWorks Sales](https://msdn.microsoft.com/library/f16cd988-673f-4376-b034-129ca93c7832). En este ejemplo, se obtiene el <xref:System.Data.Objects.ObjectStateManager> del <xref:System.Data.Objects.ObjectContext> y se usa el administrador de estados para tener acceso a un objeto del contexto.  
  
 [!code-csharp[DP ObjectServices Concepts#ObjectStateManager](~/samples/snippets/csharp/VS_Snippets_Data/DP ObjectServices Concepts/CS/Source.cs#objectstatemanager)]
 [!code-vb[DP ObjectServices Concepts#ObjectStateManager](~/samples/snippets/visualbasic/VS_Snippets_Data/DP ObjectServices Concepts/VB/Source.vb#objectstatemanager)]  
  
 En este ejemplo, se usa el método <xref:System.Data.Objects.ObjectStateManager.TryGetObjectStateEntry%2A> en el <xref:System.Data.Objects.ObjectStateManager> devuelto para obtener un objeto basado en su clave de entidad.  
  
 [!code-csharp[DP ObjectServices Concepts#ApplyItemUpdates](~/samples/snippets/csharp/VS_Snippets_Data/DP ObjectServices Concepts/CS/Source.cs#applyitemupdates)]
 [!code-vb[DP ObjectServices Concepts#ApplyItemUpdates](~/samples/snippets/visualbasic/VS_Snippets_Data/DP ObjectServices Concepts/VB/Source.vb#applyitemupdates)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/338d8a55-05cc-46b0-bbb8-1379d77068e9">Trabajar con objetos (Entity Framework)</related>
      </Docs>
    </Member>
    <Member MemberName="QueryProvider">
      <MemberSignature Language="C#" Value="protected internal System.Linq.IQueryProvider QueryProvider { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Linq.IQueryProvider QueryProvider" />
      <MemberSignature Language="DocId" Value="P:System.Data.Objects.ObjectContext.QueryProvider" />
      <MemberSignature Language="VB.NET" Value="Protected Friend ReadOnly Property QueryProvider As IQueryProvider" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; property System::Linq::IQueryProvider ^ QueryProvider { System::Linq::IQueryProvider ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.QueryProvider : System.Linq.IQueryProvider" Usage="System.Data.Objects.ObjectContext.QueryProvider" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.IQueryProvider</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene el proveedor de consultas LINQ asociado a este contexto del objeto.</summary>
        <value>Instancia de <see cref="T:System.Linq.IQueryProvider" /> usada por este contexto de objeto.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Refresh">
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Actualiza objetos concretos en el contexto del objeto con datos procedentes del origen de datos.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El orden en que se actualizan los objetos es no determinista.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Refresh">
      <MemberSignature Language="C#" Value="public void Refresh (System.Data.Objects.RefreshMode refreshMode, System.Collections.IEnumerable collection);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Refresh(valuetype System.Data.Objects.RefreshMode refreshMode, class System.Collections.IEnumerable collection) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.ObjectContext.Refresh(System.Data.Objects.RefreshMode,System.Collections.IEnumerable)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Refresh(System::Data::Objects::RefreshMode refreshMode, System::Collections::IEnumerable ^ collection);" />
      <MemberSignature Language="F#" Value="member this.Refresh : System.Data.Objects.RefreshMode * System.Collections.IEnumerable -&gt; unit" Usage="objectContext.Refresh (refreshMode, collection)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="refreshMode" Type="System.Data.Objects.RefreshMode" />
        <Parameter Name="collection" Type="System.Collections.IEnumerable" />
      </Parameters>
      <Docs>
        <param name="refreshMode">Valor de <see cref="T:System.Data.Objects.RefreshMode" /> que indica si los cambios de las propiedades en el contexto del objeto se sobrescriben con los valores de las propiedades procedentes del origen de datos.</param>
        <param name="collection">Colección <see cref="T:System.Collections.IEnumerable" /> de objetos que hay que actualizar.</param>
        <summary>Actualiza una colección de objetos en el contexto del objeto con datos procedentes del origen de datos.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método tiene el doble propósito de permitir que los objetos del contexto del objeto se actualicen con datos procedentes del origen de datos y de ser el mecanismo que permite resolver los conflictos. Para obtener más información, consulte [guardar los cambios y administración de la simultaneidad](https://msdn.microsoft.com/library/b8378601-4f26-4a05-a24a-f50aeb68610e).  
  
 El orden en que se actualizan los objetos es no determinista.  
  
 Después de <xref:System.Data.Objects.ObjectContext.Refresh%2A> se denomina el objeto siempre se actualizarán los valores originales con el valor de origen de datos, pero los valores actuales pueden o no actualizarse con el valor de origen de datos. Esto depende del valor de <xref:System.Data.Objects.RefreshMode>. El <xref:System.Data.Objects.RefreshMode.StoreWins> modo significa que los objetos de la colección deben actualizarse para que coincida con los valores del origen de datos. <xref:System.Data.Objects.RefreshMode.ClientWins> significa que solo los cambios en el contexto del objeto se conservarán, aunque ha habido otros cambios en el origen de datos.  
  
 Para asegurarse de que los objetos se han actualizado según la lógica del origen de datos, puede llamar al método <xref:System.Data.Objects.ObjectContext.Refresh%2A> con el valor de <xref:System.Data.Objects.RefreshMode.StoreWins> después de llamar al método <xref:System.Data.Objects.ObjectContext.SaveChanges%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El valor de <paramref name="collection" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="refreshMode" /> no es válido.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="collection" /> está vacía.  
  
O bien 
Un objeto no está asociado al contexto.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/338d8a55-05cc-46b0-bbb8-1379d77068e9">Trabajar con objetos (Entity Framework)</related>
      </Docs>
    </Member>
    <Member MemberName="Refresh">
      <MemberSignature Language="C#" Value="public void Refresh (System.Data.Objects.RefreshMode refreshMode, object entity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Refresh(valuetype System.Data.Objects.RefreshMode refreshMode, object entity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.ObjectContext.Refresh(System.Data.Objects.RefreshMode,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Refresh(System::Data::Objects::RefreshMode refreshMode, System::Object ^ entity);" />
      <MemberSignature Language="F#" Value="member this.Refresh : System.Data.Objects.RefreshMode * obj -&gt; unit" Usage="objectContext.Refresh (refreshMode, entity)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="refreshMode" Type="System.Data.Objects.RefreshMode" />
        <Parameter Name="entity" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="refreshMode">Uno de los valores de <see cref="T:System.Data.Objects.RefreshMode" /> que especifica qué modo se debe usar para actualizar el <see cref="T:System.Data.Objects.ObjectStateManager" />.</param>
        <param name="entity">Objeto que se va a actualizar.</param>
        <summary>Actualiza un objeto en el contexto del objeto con datos procedentes del origen de datos.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.Objects.ObjectContext.Refresh%2A> tiene el doble propósito de permitir que se actualice un objeto con datos procedentes del origen de datos y de ser el mecanismo que permite resolver los conflictos. Para obtener más información, consulte [guardar los cambios y administración de la simultaneidad](https://msdn.microsoft.com/library/b8378601-4f26-4a05-a24a-f50aeb68610e).  
  
 El orden en que se actualizan los objetos es no determinista.  
  
 Después de la <xref:System.Data.Objects.ObjectContext.Refresh%2A> se llama al método, los valores del objeto original siempre se actualizará con el valor de origen de datos, pero los valores actuales pueden o no actualizarse con el valor de origen de datos. Esto depende de <xref:System.Data.Objects.RefreshMode>. El modo <xref:System.Data.Objects.RefreshMode.StoreWins> significa que el objeto debería actualizarse para que coincida con los valores del origen de datos. El valor de <xref:System.Data.Objects.RefreshMode.ClientWins> significa que solo se conservarán los cambios en el contexto del objeto, aunque se hayan producido otros cambios en el origen de datos.  
  
 Para asegurarse de que un objeto se ha actualizado según la lógica del origen de datos, puede llamar al método <xref:System.Data.Objects.ObjectContext.Refresh%2A> con el valor de <xref:System.Data.Objects.RefreshMode.StoreWins> después de llamar al método <xref:System.Data.Objects.ObjectContext.SaveChanges%2A>.  
  
   
  
## Examples  
 En este ejemplo se basa en el [modelo AdventureWorks Sales](https://msdn.microsoft.com/library/f16cd988-673f-4376-b034-129ca93c7832). En este ejemplo, se intenta guardar los cambios, lo que puede producir un conflicto de simultaneidad. A continuación, muestra cómo resolver el conflicto de simultaneidad actualizando el contexto del objeto antes de volver a guardar los cambios.  
  
 [!code-csharp[DP ObjectServices Concepts#Concurrency](~/samples/snippets/csharp/VS_Snippets_Data/DP ObjectServices Concepts/CS/Source.cs#concurrency)]
 [!code-vb[DP ObjectServices Concepts#Concurrency](~/samples/snippets/visualbasic/VS_Snippets_Data/DP ObjectServices Concepts/VB/Source.vb#concurrency)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El valor de <paramref name="collection" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="refreshMode" /> no es válido.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="collection" /> está vacía.  
  
O bien 
Un objeto no está asociado al contexto.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/338d8a55-05cc-46b0-bbb8-1379d77068e9">Trabajar con objetos (Entity Framework)</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="SaveChanges">
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Conserva todas las actualizaciones en el origen de datos.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SaveChanges">
      <MemberSignature Language="C#" Value="public int SaveChanges ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 SaveChanges() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.ObjectContext.SaveChanges" />
      <MemberSignature Language="VB.NET" Value="Public Function SaveChanges () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int SaveChanges();" />
      <MemberSignature Language="F#" Value="member this.SaveChanges : unit -&gt; int" Usage="objectContext.SaveChanges " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Conserva todas las actualizaciones en el origen de datos y restablece el seguimiento de cambios en el contexto del objeto.</summary>
        <returns>Número de objetos que tenían el estado <see cref="F:System.Data.EntityState.Added" />, <see cref="F:System.Data.EntityState.Modified" /> o <see cref="F:System.Data.EntityState.Deleted" /> cuando se llamó al método <see cref="M:System.Data.Objects.ObjectContext.SaveChanges" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para asegurarse de que los objetos del cliente se han actualizado según la lógica del origen de datos, puede llamar al método <xref:System.Data.Objects.ObjectContext.Refresh%2A> con el valor de <xref:System.Data.Objects.RefreshMode.StoreWins> después de llamar al método <xref:System.Data.Objects.ObjectContext.SaveChanges%2A>. Para obtener más información, consulte [guardar los cambios y administración de la simultaneidad](https://msdn.microsoft.com/library/b8378601-4f26-4a05-a24a-f50aeb68610e).  
  
 <xref:System.Data.Objects.ObjectContext.SaveChanges%2A> funciona dentro de una transacción. <xref:System.Data.Objects.ObjectContext.SaveChanges%2A> se revertirá esa transacción e inicia una excepción si alguno de los datos sucios <xref:System.Data.Objects.ObjectStateEntry> objetos no pueden ser persistente.  
  
 Si se ha producido una infracción de simultaneidad optimista, se genera una <xref:System.Data.OptimisticConcurrencyException>. Puede resolver una infracción de simultaneidad optimista detectándola, llamando al método <xref:System.Data.Objects.ObjectContext.Refresh%2A> con el valor <xref:System.Data.Objects.RefreshMode.StoreWins> o <xref:System.Data.Objects.RefreshMode.ClientWins> y, a continuación, llamando de nuevo al método <xref:System.Data.Objects.ObjectContext.SaveChanges%2A>. Para obtener más información, consulte [Cómo: administrar la simultaneidad de datos en el contexto del objeto](https://msdn.microsoft.com/library/25ffe70d-ce97-4f0a-8ae0-22b7c40f748a).  
  
   
  
## Examples  
 En este ejemplo se basa en el [modelo AdventureWorks Sales](https://msdn.microsoft.com/library/f16cd988-673f-4376-b034-129ca93c7832). En este ejemplo, se intenta guardar los cambios, lo que puede producir un conflicto de simultaneidad. A continuación, muestra cómo resolver el conflicto de simultaneidad actualizando el contexto del objeto antes de volver a guardar los cambios.  
  
 [!code-csharp[DP ObjectServices Concepts#Concurrency](~/samples/snippets/csharp/VS_Snippets_Data/DP ObjectServices Concepts/CS/Source.cs#concurrency)]
 [!code-vb[DP ObjectServices Concepts#Concurrency](~/samples/snippets/visualbasic/VS_Snippets_Data/DP ObjectServices Concepts/VB/Source.vb#concurrency)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Data.OptimisticConcurrencyException">Se ha producido una infracción de simultaneidad optimista en el origen de datos.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/338d8a55-05cc-46b0-bbb8-1379d77068e9">Trabajar con objetos (Entity Framework)</related>
      </Docs>
    </Member>
    <Member MemberName="SaveChanges">
      <MemberSignature Language="C#" Value="public int SaveChanges (bool acceptChangesDuringSave);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 SaveChanges(bool acceptChangesDuringSave) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.ObjectContext.SaveChanges(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function SaveChanges (acceptChangesDuringSave As Boolean) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int SaveChanges(bool acceptChangesDuringSave);" />
      <MemberSignature Language="F#" Value="member this.SaveChanges : bool -&gt; int" Usage="objectContext.SaveChanges acceptChangesDuringSave" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("Use SaveChanges(SaveOptions options) instead.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="acceptChangesDuringSave" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="acceptChangesDuringSave">Este parámetro es necesario para la compatibilidad con transacciones en el cliente. Si es <see langword="true" />, se restablece el seguimiento de cambios en todos los objetos después de que finalice <see cref="M:System.Data.Objects.ObjectContext.SaveChanges(System.Boolean)" />. Si es <see langword="false" />, debe llamar al método <see cref="M:System.Data.Objects.ObjectContext.AcceptAllChanges" /> después de <see cref="M:System.Data.Objects.ObjectContext.SaveChanges(System.Boolean)" />.</param>
        <summary>Conserva todas las actualizaciones en el origen de datos y, opcionalmente, restablece el seguimiento de cambios en el contexto del objeto.</summary>
        <returns>Número de objetos que tenían el estado <see cref="F:System.Data.EntityState.Added" />, <see cref="F:System.Data.EntityState.Modified" /> o <see cref="F:System.Data.EntityState.Deleted" /> cuando se llamó al método <see cref="M:System.Data.Objects.ObjectContext.SaveChanges" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Llame a la <xref:System.Data.Objects.ObjectContext.SaveChanges%28System.Data.Objects.SaveOptions%29> método en su lugar.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Data.OptimisticConcurrencyException">Se ha producido una infracción de simultaneidad optimista.</exception>
      </Docs>
    </Member>
    <Member MemberName="SaveChanges">
      <MemberSignature Language="C#" Value="public virtual int SaveChanges (System.Data.Objects.SaveOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 SaveChanges(valuetype System.Data.Objects.SaveOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.ObjectContext.SaveChanges(System.Data.Objects.SaveOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function SaveChanges (options As SaveOptions) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int SaveChanges(System::Data::Objects::SaveOptions options);" />
      <MemberSignature Language="F#" Value="abstract member SaveChanges : System.Data.Objects.SaveOptions -&gt; int&#xA;override this.SaveChanges : System.Data.Objects.SaveOptions -&gt; int" Usage="objectContext.SaveChanges options" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="options" Type="System.Data.Objects.SaveOptions" />
      </Parameters>
      <Docs>
        <param name="options">Valor de <see cref="T:System.Data.Objects.SaveOptions" /> que determina el comportamiento de la operación.</param>
        <summary>Conserva todas las actualizaciones al origen de datos con el <see cref="T:System.Data.Objects.SaveOptions" /> especificado.</summary>
        <returns>Número de objetos que tenían el estado <see cref="F:System.Data.EntityState.Added" />, <see cref="F:System.Data.EntityState.Modified" /> o <see cref="F:System.Data.EntityState.Deleted" /> cuando se llamó al método <see cref="M:System.Data.Objects.ObjectContext.SaveChanges" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilice esta sobrecarga específica de <xref:System.Data.Objects.ObjectContext.SaveChanges%2A> para asegurarse de que <xref:System.Data.Objects.ObjectContext.DetectChanges%2A> se llama antes de guardar los cambios en el origen de datos o que <xref:System.Data.Objects.ObjectContext.AcceptAllChanges%2A> se llama después de guardar los cambios en el origen de datos.  
  
 Esta enumeración tiene un <xref:System.FlagsAttribute> que permite una combinación bit a bit de sus valores de miembro.  
  
 Para asegurarse de que los objetos en el cliente se han actualizado según la lógica del origen de datos, puede llamar a la <xref:System.Data.Objects.ObjectContext.Refresh%2A> método con el <xref:System.Data.Objects.RefreshMode.StoreWins> valor después de llamar a <xref:System.Data.Objects.ObjectContext.SaveChanges%2A>. El <xref:System.Data.Objects.ObjectContext.SaveChanges%2A> método funciona en una transacción. <xref:System.Data.Objects.ObjectContext.SaveChanges%2A> se revertirá esa transacción e inicia una excepción si uno de los datos sucios <xref:System.Data.Objects.ObjectStateEntry> objetos no pueden ser persistente.  
  
 Si se ha producido una infracción de simultaneidad optimista, se genera una <xref:System.Data.OptimisticConcurrencyException>. Puede resolver una infracción de simultaneidad optimista detectándola, llamando al método <xref:System.Data.Objects.ObjectContext.Refresh%2A> con el valor <xref:System.Data.Objects.RefreshMode.StoreWins> o <xref:System.Data.Objects.RefreshMode.ClientWins> y, a continuación, llamando de nuevo al método <xref:System.Data.Objects.ObjectContext.SaveChanges%2A>. Para obtener más información, consulte [Cómo: administrar la simultaneidad de datos en el contexto del objeto](https://msdn.microsoft.com/library/25ffe70d-ce97-4f0a-8ae0-22b7c40f748a).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Data.OptimisticConcurrencyException">Se ha producido una infracción de simultaneidad optimista.</exception>
      </Docs>
    </Member>
    <Member MemberName="SavingChanges">
      <MemberSignature Language="C#" Value="public event EventHandler SavingChanges;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler SavingChanges" />
      <MemberSignature Language="DocId" Value="E:System.Data.Objects.ObjectContext.SavingChanges" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event SavingChanges As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ SavingChanges;" />
      <MemberSignature Language="F#" Value="member this.SavingChanges : EventHandler " Usage="member this.SavingChanges : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produce cuando se guardan cambios en el origen de datos.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El evento <xref:System.Data.Objects.ObjectContext.SavingChanges> se genera al principio de una operación <xref:System.Data.Objects.ObjectContext.SaveChanges%2A> en un <xref:System.Data.Objects.ObjectContext>. Este evento normalmente se usa para validar los objetos modificados antes de que los nuevos valores se escriban en la base de datos.  
  
   
  
## Examples  
 En este ejemplo se basa en el [modelo AdventureWorks Sales](https://msdn.microsoft.com/library/f16cd988-673f-4376-b034-129ca93c7832). Registra un controlador para el evento <xref:System.Data.Objects.ObjectContext.SavingChanges> que realiza la validación de estados de la entidad.  
  
 [!code-csharp[DP ObjectServices Concepts#SavingChanges](~/samples/snippets/csharp/VS_Snippets_Data/DP ObjectServices Concepts/CS/Source.cs#savingchanges)]
 [!code-vb[DP ObjectServices Concepts#SavingChanges](~/samples/snippets/visualbasic/VS_Snippets_Data/DP ObjectServices Concepts/VB/Source.vb#savingchanges)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/338d8a55-05cc-46b0-bbb8-1379d77068e9">Trabajar con objetos (Entity Framework)</related>
      </Docs>
    </Member>
    <Member MemberName="Translate&lt;TElement&gt;">
      <MemberSignature Language="C#" Value="public System.Data.Objects.ObjectResult&lt;TElement&gt; Translate&lt;TElement&gt; (System.Data.Common.DbDataReader reader);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.Objects.ObjectResult`1&lt;!!TElement&gt; Translate&lt;TElement&gt;(class System.Data.Common.DbDataReader reader) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.ObjectContext.Translate``1(System.Data.Common.DbDataReader)" />
      <MemberSignature Language="VB.NET" Value="Public Function Translate(Of TElement) (reader As DbDataReader) As ObjectResult(Of TElement)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TElement&gt;&#xA; System::Data::Objects::ObjectResult&lt;TElement&gt; ^ Translate(System::Data::Common::DbDataReader ^ reader);" />
      <MemberSignature Language="F#" Value="member this.Translate : System.Data.Common.DbDataReader -&gt; System.Data.Objects.ObjectResult&lt;'Element&gt;" Usage="objectContext.Translate reader" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Objects.ObjectResult&lt;TElement&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TElement" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="reader" Type="System.Data.Common.DbDataReader" />
      </Parameters>
      <Docs>
        <typeparam name="TElement">To be added.</typeparam>
        <param name="reader">
          <see cref="T:System.Data.Common.DbDataReader" /> que contiene los datos de entidad que se van a convertir en objetos entidad.</param>
        <summary>Convierte un objeto <see cref="T:System.Data.Common.DbDataReader" /> que contiene filas de datos de entidad en objetos del tipo de entidad solicitado.</summary>
        <returns>Enumeración de objetos de tipo <paramref name="TResult" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Data.Objects.ObjectContext.Translate%2A> método se usa para traducir los datos de la entidad de un <xref:System.Data.Common.DbDataReader> en objetos del tipo solicitado. Este proceso se realiza automáticamente cuando un <xref:System.Data.Objects.ObjectQuery%601> se ejecuta para devolver datos de la entidad. El <xref:System.Data.Objects.ObjectContext.Translate%2A> método le permite ejecutar una consulta ADO.NET estándar en un origen de datos y traducir las filas de datos devueltos en los objetos de entidad.  
  
 Suministrado <xref:System.Data.Common.DbDataReader> debe contener datos que se asigna al tipo de entidad solicitado.  
  
 Para obtener más información, consulte:  
  
 [Ejecutar directamente comandos Store](https://msdn.microsoft.com/library/5708d0a2-3f76-4825-978a-d06ff5c4bb3d) y  
  
 [Cómo: ejecutar directamente comandos contra el origen de datos](https://msdn.microsoft.com/library/def3cc87-cfff-4dee-83cf-1a40c73a2d01)  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Cuando <paramref name="reader" /> es <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Translate&lt;TEntity&gt;">
      <MemberSignature Language="C#" Value="public System.Data.Objects.ObjectResult&lt;TEntity&gt; Translate&lt;TEntity&gt; (System.Data.Common.DbDataReader reader, string entitySetName, System.Data.Objects.MergeOption mergeOption);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.Objects.ObjectResult`1&lt;!!TEntity&gt; Translate&lt;TEntity&gt;(class System.Data.Common.DbDataReader reader, string entitySetName, valuetype System.Data.Objects.MergeOption mergeOption) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.ObjectContext.Translate``1(System.Data.Common.DbDataReader,System.String,System.Data.Objects.MergeOption)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TEntity&gt;&#xA; System::Data::Objects::ObjectResult&lt;TEntity&gt; ^ Translate(System::Data::Common::DbDataReader ^ reader, System::String ^ entitySetName, System::Data::Objects::MergeOption mergeOption);" />
      <MemberSignature Language="F#" Value="member this.Translate : System.Data.Common.DbDataReader * string * System.Data.Objects.MergeOption -&gt; System.Data.Objects.ObjectResult&lt;'Entity&gt;" Usage="objectContext.Translate (reader, entitySetName, mergeOption)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Objects.ObjectResult&lt;TEntity&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TEntity" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="reader" Type="System.Data.Common.DbDataReader" />
        <Parameter Name="entitySetName" Type="System.String" />
        <Parameter Name="mergeOption" Type="System.Data.Objects.MergeOption" />
      </Parameters>
      <Docs>
        <typeparam name="TEntity">To be added.</typeparam>
        <param name="reader">
          <see cref="T:System.Data.Common.DbDataReader" /> que contiene los datos de entidad que se van a convertir en objetos entidad.</param>
        <param name="entitySetName">Conjunto de entidades del tipo <c>TResult</c>.</param>
        <param name="mergeOption">
          <see cref="T:System.Data.Objects.MergeOption" /> que se va a usar cuando se agreguen objetos convertidos al contexto del objeto. El valor predeterminado es <see cref="F:System.Data.Objects.MergeOption.AppendOnly" />.</param>
        <summary>Convierte un <see cref="T:System.Data.Common.DbDataReader" /> que contiene filas de datos de entidad en objetos del tipo de entidad solicitado, en un conjunto de entidades concreto, y con la opción de combinación especificada.</summary>
        <returns>Enumeración de objetos de tipo <paramref name="TResult" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Data.Objects.ObjectContext.Translate%2A> método se usa para traducir los datos de la entidad de un <xref:System.Data.Common.DbDataReader> en objetos del tipo solicitado. Este proceso se realiza automáticamente cuando un <xref:System.Data.Objects.ObjectQuery%601> se ejecuta para devolver datos de la entidad. El <xref:System.Data.Objects.ObjectContext.Translate%2A> método le permite ejecutar una consulta ADO.NET estándar en un origen de datos y traducir las filas de datos devueltos en los objetos de entidad.  
  
 Suministrado <xref:System.Data.Common.DbDataReader> debe contener datos que se asigna al tipo de entidad solicitado.  
  
 Para obtener más información, consulte:  
  
 [Ejecutar directamente comandos Store](https://msdn.microsoft.com/library/5708d0a2-3f76-4825-978a-d06ff5c4bb3d) y  
  
 [Cómo: ejecutar directamente comandos contra el origen de datos](https://msdn.microsoft.com/library/def3cc87-cfff-4dee-83cf-1a40c73a2d01)  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Cuando <paramref name="reader" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Cuando el valor <paramref name="mergeOption" /> proporcionado no es un valor <see cref="T:System.Data.Objects.MergeOption" /> válido.</exception>
        <exception cref="T:System.InvalidOperationException">Cuando la entidad <paramref name="entitySetName" /> proporcionada no es una entidad válida para el tipo <paramref name="TResult" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="TryGetObjectByKey">
      <MemberSignature Language="C#" Value="public bool TryGetObjectByKey (System.Data.EntityKey key, out object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryGetObjectByKey(class System.Data.EntityKey key, [out] object&amp; value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.ObjectContext.TryGetObjectByKey(System.Data.EntityKey,System.Object@)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryGetObjectByKey (key As EntityKey, ByRef value As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryGetObjectByKey(System::Data::EntityKey ^ key, [Runtime::InteropServices::Out] System::Object ^ % value);" />
      <MemberSignature Language="F#" Value="member this.TryGetObjectByKey : System.Data.EntityKey *  -&gt; bool" Usage="objectContext.TryGetObjectByKey (key, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.Data.EntityKey" />
        <Parameter Name="value" Type="System.Object" RefType="out" />
      </Parameters>
      <Docs>
        <param name="key">Clave del objeto que se desea encontrar.</param>
        <param name="value">Cuando vuelve este método, contiene el objeto.</param>
        <summary>Devuelve un objeto que tiene la clave de entidad especificada.</summary>
        <returns>Es <see langword="true" /> si el objeto se recuperó correctamente. Es <see langword="false" /> si <paramref name="key" /> es temporal, la conexión es <see langword="null" /> o <paramref name="value" /> es <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.Objects.ObjectContext.TryGetObjectByKey%2A> intenta recuperar un objeto que tiene la <xref:System.Data.EntityKey> especificada en el <xref:System.Data.Objects.ObjectStateManager>. Si el objeto no está cargado actualmente en el contexto del objeto, se ejecuta una consulta para intentar devolver el objeto desde el origen de datos. Para obtener más información, consulte [las consultas de objeto](https://msdn.microsoft.com/library/0768033c-876f-471d-85d5-264884349276).  
  
 Use el método <xref:System.Data.Objects.ObjectContext.TryGetObjectByKey%2A> para no tener que controlar la excepción <xref:System.Data.ObjectNotFoundException> producida por <xref:System.Data.Objects.ObjectContext.GetObjectByKey%2A> cuando no se puede encontrar el objeto.  
  
 Este método devolverá objetos con el estado <xref:System.Data.EntityState.Deleted>.  
  
 No se puede usar una clave temporal para devolver un objeto desde el origen de datos.  
  
 El <xref:System.Data.Objects.ObjectContext.TryGetObjectByKey%2A> método aplica a .NET standard `TryParse` patrón para el <xref:System.Data.Objects.ObjectContext.GetObjectByKey%2A> método, que devuelve `false` cuando el <xref:System.Data.ObjectNotFoundException> se detecta.  
  
   
  
## Examples  
 El ejemplo de este tema se basa en el [modelo AdventureWorks Sales](https://msdn.microsoft.com/library/f16cd988-673f-4376-b034-129ca93c7832). En el ejemplo, se crea una <xref:System.Data.EntityKey> para una entidad del tipo especificado y, a continuación, se intenta recuperar una entidad por su clave.  
  
 [!code-csharp[DP ObjectServices Concepts#EntityKeyClass_TryGetObjectByKey](~/samples/snippets/csharp/VS_Snippets_Data/DP ObjectServices Concepts/CS/Source.cs#entitykeyclass_trygetobjectbykey)]
 [!code-vb[DP ObjectServices Concepts#EntityKeyClass_TryGetObjectByKey](~/samples/snippets/visualbasic/VS_Snippets_Data/DP ObjectServices Concepts/VB/Source.vb#entitykeyclass_trygetobjectbykey)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Metadatos incompatibles para <paramref name="key" />.</exception>
        <exception cref="T:System.ArgumentNullException">El valor de <paramref name="key" /> es <see langword="null" />.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/338d8a55-05cc-46b0-bbb8-1379d77068e9">Trabajar con objetos (Entity Framework)</related>
      </Docs>
    </Member>
  </Members>
</Type>