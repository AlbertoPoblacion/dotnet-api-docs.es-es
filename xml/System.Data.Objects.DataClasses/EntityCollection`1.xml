<Type Name="EntityCollection&lt;TEntity&gt;" FullName="System.Data.Objects.DataClasses.EntityCollection&lt;TEntity&gt;">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="0b0c327f80ebb24249a08632fb7b9434dee34d84" />
    <Meta Name="ms.sourcegitcommit" Value="16d2d159872fd213cae4b8f371d7ae9c8b027c89" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="es-ES" />
    <Meta Name="ms.lasthandoff" Value="11/17/2018" />
    <Meta Name="ms.locfileid" Value="51939491" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class EntityCollection&lt;TEntity&gt; : System.Data.Objects.DataClasses.RelatedEnd, System.Collections.Generic.ICollection&lt;TEntity&gt;, System.Collections.Generic.IEnumerable&lt;TEntity&gt;, System.ComponentModel.IListSource where TEntity : class" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable sealed beforefieldinit EntityCollection`1&lt;class TEntity&gt; extends System.Data.Objects.DataClasses.RelatedEnd implements class System.Collections.Generic.ICollection`1&lt;!TEntity&gt;, class System.Collections.Generic.IEnumerable`1&lt;!TEntity&gt;, class System.Collections.IEnumerable, class System.ComponentModel.IListSource" />
  <TypeSignature Language="DocId" Value="T:System.Data.Objects.DataClasses.EntityCollection`1" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class EntityCollection(Of TEntity)&#xA;Inherits RelatedEnd&#xA;Implements ICollection(Of TEntity), IEnumerable(Of TEntity), IListSource" />
  <TypeSignature Language="C++ CLI" Value="generic &lt;typename TEntity&gt;&#xA; where TEntity : classpublic ref class EntityCollection sealed : System::Data::Objects::DataClasses::RelatedEnd, System::Collections::Generic::ICollection&lt;TEntity&gt;, System::Collections::Generic::IEnumerable&lt;TEntity&gt;, System::ComponentModel::IListSource" />
  <TypeSignature Language="F#" Value="type EntityCollection&lt;'Entity (requires 'Entity : null)&gt; = class&#xA;    inherit RelatedEnd&#xA;    interface ICollection&lt;'Entity (requires 'Entity : null)&gt;&#xA;    interface seq&lt;'Entity (requires 'Entity : null)&gt;&#xA;    interface IEnumerable&#xA;    interface IListSource" />
  <AssemblyInfo>
    <AssemblyName>System.Data.Entity</AssemblyName>
    <AssemblyVersion>3.5.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <TypeParameters>
    <TypeParameter Name="TEntity">
      <Constraints>
        <ParameterAttribute>ReferenceTypeConstraint</ParameterAttribute>
      </Constraints>
    </TypeParameter>
  </TypeParameters>
  <Base>
    <BaseTypeName>System.Data.Objects.DataClasses.RelatedEnd</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Collections.Generic.ICollection&lt;TEntity&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.Generic.IEnumerable&lt;T&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.Generic.IEnumerable&lt;TEntity&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.IEnumerable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.ComponentModel.IListSource</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
      <AttributeName>Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <typeparam name="TEntity">Tipo de entidad de la colección.</typeparam>
    <summary>Representa una colección de objetos en el extremo "varios" de una relación.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.Objects.DataClasses.EntityCollection%601> es una colección de objetos de un tipo de entidad concreto que representa el extremo "varios" de una relación de uno a varios o de una relación de varios a varios.  
  
 Una propiedad de navegación devuelve una <xref:System.Data.Objects.DataClasses.EntityCollection%601>. Use el método <xref:System.Data.Objects.DataClasses.EntityCollection%601.Load%2A> para cargar objetos relacionados en una <xref:System.Data.Objects.DataClasses.EntityCollection%601>. Para almacenar una colección de objetos no relacionados de un tipo de entidad concreto, como el resultado de una <xref:System.Data.Objects.ObjectQuery%601>, use una instancia de la clase <xref:System.Collections.Generic.List%601>.  
  
 Una <xref:System.Data.Objects.DataClasses.EntityCollection%601> puede tener su correspondiente <xref:System.Data.Objects.DataClasses.EntityReference%601>. Cuando un modelo <xref:System.Data.Objects.DataClasses.EntityCollection%601> y un modelo <xref:System.Data.Objects.DataClasses.EntityReference%601> son extremos opuestos de la misma relación, la integridad de la relación se mantiene en el nivel de objeto. Las dos clases se sincronizan automáticamente.  
  
 Esta clase no puede heredarse.  
  
   
  
## Examples  
 En este ejemplo se basa en el. Para ejecutar el código de este ejemplo, debe haber agregado ya el modelo AdventureWorks Sales al proyecto y haber configurado el proyecto para que use Entity Framework. Para ello, complete los procedimientos de [Cómo: configurar manualmente un proyecto de Entity Framework](https://msdn.microsoft.com/library/73f6ae1d-b3b2-4577-aebd-ad5a75954e9e) y [Cómo: definir manualmente los archivos de asignación y modelo](https://msdn.microsoft.com/library/d4fd6864-f2a1-48f0-aa32-1e318775a99a).  
  
 En el ejemplo, se realizan las tareas siguientes:  
  
1.  Se crean dos nuevas entidades `SalesOrderHeader` y se agregan a la entidad `Contact`.  
  
2.  Se obtienen todos los puntos de conexión relacionados del <xref:System.Data.Objects.DataClasses.RelationshipManager> que está asociado a la entidad `Contact`.  
  
3.  Se recorre en iteración la colección de <xref:System.Data.Objects.DataClasses.IRelatedEnd>.  
  
4.  Se obtiene la <xref:System.Data.Objects.DataClasses.EntityCollection%601> para cada extremo relacionado.  
  
5.  Se usa el método <xref:System.Data.Objects.DataClasses.EntityCollection%601.Remove%2A> para quitar una entidad de la colección.  
  
6.  Se llama al método <xref:System.Data.Objects.DataClasses.EntityCollection%601.Contains%2A> para determinar si se ha quitado el objeto de la colección.  
  
7.  Se usa el método <xref:System.Data.Objects.DataClasses.EntityCollection%601.Add%2A> para volver a agregar la entidad.  
  
 [!code-csharp[DP ObjectServices Concepts#IRelatedEnd_Add](~/samples/snippets/csharp/VS_Snippets_Data/DP ObjectServices Concepts/CS/Source.cs#irelatedend_add)]
 [!code-vb[DP ObjectServices Concepts#IRelatedEnd_Add](~/samples/snippets/visualbasic/VS_Snippets_Data/DP ObjectServices Concepts/VB/Source.vb#irelatedend_add)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public EntityCollection ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.DataClasses.EntityCollection`1.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; EntityCollection();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Data.Objects.DataClasses.EntityCollection`1" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este constructor público para <xref:System.Data.Objects.DataClasses.EntityCollection%601> está diseñado para que lo utilice Servicios de objeto al deserializar los gráficos de objetos. No debe usar este constructor para tener acceso a una instancia de <xref:System.Data.Objects.DataClasses.EntityCollection%601>; hágalo desde una propiedad de navegación.  
  
 Para almacenar una colección de objetos no relacionados de un tipo de entidad concreto, como el resultado de una <xref:System.Data.Objects.ObjectQuery%601>, use una instancia de <xref:System.Collections.Generic.List%601>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public void Add (TEntity entity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Add(!TEntity entity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.DataClasses.EntityCollection`1.Add(`0)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Add (entity As TEntity)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Add(TEntity entity);" />
      <MemberSignature Language="F#" Value="override this.Add : 'Entity -&gt; unit" Usage="entityCollection.Add entity" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.ICollection`1.Add(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="entity" Type="TEntity" />
      </Parameters>
      <Docs>
        <param name="entity">Objeto que se va a agregar a la colección. <c>entity</c> debe implementar <see cref="T:System.Data.Objects.DataClasses.IEntityWithRelationships" />.</param>
        <summary>Agrega un objeto a la colección.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El método <xref:System.Data.Objects.DataClasses.EntityCollection%601.Add%2A> agrega un objeto a una <xref:System.Data.Objects.DataClasses.EntityCollection%601> y crea una relación entre los dos objetos. Cuando se asocia el objeto de origen a una instancia de <xref:System.Data.Objects.ObjectContext>, el método <xref:System.Data.Objects.DataClasses.EntityCollection%601.Add%2A> también agrega el objeto al <xref:System.Data.Objects.ObjectContext>. Esta operación se convierte en una operación de inserción en el origen de datos cuando se llama a <xref:System.Data.Objects.ObjectContext.SaveChanges%2A>. Para obtener más información, consulte [crear, agregar, modificar y eliminar objetos](https://msdn.microsoft.com/library/f76f1fad-c553-4b59-820b-89b3dec2fad1).  
  
 Se puede llamar al método <xref:System.Data.Objects.DataClasses.EntityCollection%601.Add%2A> varias veces en la misma instancia de objeto.  
  
   
  
## Examples  
 En este ejemplo se basa en el. Para ejecutar el código de este ejemplo, debe haber agregado ya el modelo AdventureWorks Sales al proyecto y haber configurado el proyecto para que use Entity Framework. Para ello, complete los procedimientos de [Cómo: configurar manualmente un proyecto de Entity Framework](https://msdn.microsoft.com/library/73f6ae1d-b3b2-4577-aebd-ad5a75954e9e) y [Cómo: definir manualmente los archivos de asignación y modelo](https://msdn.microsoft.com/library/d4fd6864-f2a1-48f0-aa32-1e318775a99a).  
  
 En este ejemplo se crean dos nuevas entidades `SalesOrderHeader`, se agregan a la entidad `Contact` y, después de quitar un objeto, se usa el método <xref:System.Data.Objects.DataClasses.EntityCollection%601.Add%2A> para volver a agregar el objeto a la colección.  
  
 [!code-csharp[DP ObjectServices Concepts#IRelatedEnd_Add](~/samples/snippets/csharp/VS_Snippets_Data/DP ObjectServices Concepts/CS/Source.cs#irelatedend_add)]
 [!code-vb[DP ObjectServices Concepts#IRelatedEnd_Add](~/samples/snippets/visualbasic/VS_Snippets_Data/DP ObjectServices Concepts/VB/Source.vb#irelatedend_add)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El valor de <paramref name="entity" /> es <see langword="null" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Attach">
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Define una relación entre dos objetos asociados del contexto del objeto.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Attach">
      <MemberSignature Language="C#" Value="public void Attach (System.Collections.Generic.IEnumerable&lt;TEntity&gt; entities);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Attach(class System.Collections.Generic.IEnumerable`1&lt;!TEntity&gt; entities) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.DataClasses.EntityCollection`1.Attach(System.Collections.Generic.IEnumerable{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Sub Attach (entities As IEnumerable(Of TEntity))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Attach(System::Collections::Generic::IEnumerable&lt;TEntity&gt; ^ entities);" />
      <MemberSignature Language="F#" Value="override this.Attach : seq&lt;'Entity (requires 'Entity : null)&gt; -&gt; unit" Usage="entityCollection.Attach entities" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="entities" Type="System.Collections.Generic.IEnumerable&lt;TEntity&gt;" />
      </Parameters>
      <Docs>
        <param name="entities">Colección de objetos del contexto del objeto que están relacionados con el objeto de origen.</param>
        <summary>Define las relaciones entre un objeto y una colección de objetos relacionados en un contexto del objeto.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El método <xref:System.Data.Objects.ObjectContext.Attach%2A> se usa para definir las relaciones entre un objeto y una colección de objetos relacionados cuando tanto el objeto de origen como la colección de objetos relacionados ya existen en el contexto del objeto. Para asociar un objeto o un gráfico de objetos donde las relaciones ya están definidas, llame al método <xref:System.Data.Objects.ObjectContext.Attach%2A> del <xref:System.Data.Objects.ObjectContext>. Para crear un nuevo objeto relacionado con el objeto de origen, llame al método <xref:System.Data.Objects.DataClasses.EntityCollection%601.Add%2A> de la <xref:System.Data.Objects.DataClasses.EntityCollection%601>. Para obtener más información, consulte [adjuntar y desasociar objetos](https://msdn.microsoft.com/library/41d5c1ef-1b78-4502-aa10-7e1438d62d23).  
  
 Si la colección ya está rellena o parcialmente rellena, el método <xref:System.Data.Objects.DataClasses.EntityCollection%601.Attach%2A> combina las entidades existentes con las entidades especificadas. No se da por hecho que las entidades especificadas sean conjuntos completos de entidades relacionadas.  
  
 Todas las entidades pasadas deben estar en el estado <xref:System.Data.EntityState.Unchanged> o <xref:System.Data.EntityState.Modified>. Solo se permiten los objetos que están en el estado <xref:System.Data.EntityState.Deleted> si el administrador de estados ya está realizando un seguimiento de la instancia de la relación.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">La colección <paramref name="entities" /> es <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">El objeto de origen o un objeto de la colección <paramref name="entities" /> es <see langword="null" /> o no está en un estado <see cref="F:System.Data.EntityState.Unchanged" /> ni <see cref="F:System.Data.EntityState.Modified" />.  
  
O bien 
La relación no se puede definir en función de los metadatos de EDM. Esto puede ocurrir cuando la asociación del esquema conceptual no admite una relación entre los dos tipos.</exception>
      </Docs>
    </Member>
    <Member MemberName="Attach">
      <MemberSignature Language="C#" Value="public void Attach (TEntity entity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Attach(!TEntity entity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.DataClasses.EntityCollection`1.Attach(`0)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Attach (entity As TEntity)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Attach(TEntity entity);" />
      <MemberSignature Language="F#" Value="override this.Attach : 'Entity -&gt; unit" Usage="entityCollection.Attach entity" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="entity" Type="TEntity" />
      </Parameters>
      <Docs>
        <param name="entity">Objeto que se va a asociar.</param>
        <summary>Define una relación entre dos objetos asociados del contexto del objeto.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El método <xref:System.Data.Objects.DataClasses.EntityCollection%601.Attach%2A> se usa para definir las relaciones entre dos objetos cuando ambos ya existen en el contexto del objeto. Para asociar un objeto o un gráfico de objetos donde las relaciones ya están definidas, llame al método <xref:System.Data.Objects.ObjectContext.Attach%2A> del <xref:System.Data.Objects.ObjectContext>. Para crear un nuevo objeto relacionado con el objeto de origen, llame al método <xref:System.Data.Objects.DataClasses.EntityCollection%601.Add%2A> de la <xref:System.Data.Objects.DataClasses.EntityCollection%601>. Para obtener más información, consulte [adjuntar y desasociar objetos](https://msdn.microsoft.com/library/41d5c1ef-1b78-4502-aa10-7e1438d62d23).  
  
 Si <xref:System.Data.Objects.DataClasses.EntityCollection%601> ya ha cargado objetos, el método <xref:System.Data.Objects.DataClasses.EntityCollection%601.Attach%2A> combina el objeto con los objetos existentes en <xref:System.Data.Objects.DataClasses.EntityCollection%601>.  
  
 No se da por hecho que el objeto asociado sea el conjunto completo de objetos entidad relacionados.  
  
 Tanto el objeto asociado a esta <xref:System.Data.Objects.DataClasses.EntityCollection%601> como todos los objetos que se van a asociar a él deben estar en un estado <xref:System.Data.EntityState.Unchanged> o <xref:System.Data.EntityState.Modified>.  
  
 Los objetos en el estado <xref:System.Data.EntityState.Deleted> solo pueden asociarse si el <xref:System.Data.Objects.ObjectStateManager> ya está realizando el seguimiento de la instancia de la relación.  
  
   
  
## Examples  
 En este ejemplo se basa en el. Para ejecutar el código de este ejemplo, debe haber agregado ya el modelo AdventureWorks Sales al proyecto y haber configurado el proyecto para que use Entity Framework. Para ello, complete los procedimientos de [Cómo: configurar manualmente un proyecto de Entity Framework](https://msdn.microsoft.com/library/73f6ae1d-b3b2-4577-aebd-ad5a75954e9e) y [Cómo: definir manualmente los archivos de asignación y modelo](https://msdn.microsoft.com/library/d4fd6864-f2a1-48f0-aa32-1e318775a99a).  
  
 En este ejemplo se asocia una colección de desasociado `SalesOrderDetail` objetos desasociados y un `SalesOrderHeader` objeto a un contexto del objeto y, a continuación, define las relaciones entre la `SalesOrderHeader` y cada uno `SalesOrderDetail` objeto.  
  
 [!code-csharp[DP ObjectServices Concepts#AttachRelatedObjects](~/samples/snippets/csharp/VS_Snippets_Data/DP ObjectServices Concepts/CS/Source.cs#attachrelatedobjects)]
 [!code-vb[DP ObjectServices Concepts#AttachRelatedObjects](~/samples/snippets/visualbasic/VS_Snippets_Data/DP ObjectServices Concepts/VB/Source.vb#attachrelatedobjects)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Cuando <paramref name="entity" /> es <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Cuando <paramref name="entity" /> no se puede relacionar con el objeto de origen. Esto puede ocurrir cuando la asociación del esquema conceptual no admite una relación entre los dos tipos.  
  
O bien 
Cuando un objeto es <see langword="null" /> o no está en un estado <see cref="F:System.Data.EntityState.Unchanged" /> ni <see cref="F:System.Data.EntityState.Modified" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Clear">
      <MemberSignature Language="C#" Value="public void Clear ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Clear() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.DataClasses.EntityCollection`1.Clear" />
      <MemberSignature Language="VB.NET" Value="Public Sub Clear ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Clear();" />
      <MemberSignature Language="F#" Value="override this.Clear : unit -&gt; unit" Usage="entityCollection.Clear " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.ICollection`1.Clear</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Quita todas las entidades de la colección.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.Objects.DataClasses.EntityCollection%601.Clear%2A> hace lo siguiente:  
  
-   Establece el <xref:System.Data.Objects.DataClasses.RelatedEnd.IsLoaded%2A> marca `false`.  
  
-   Quita todas las entidades de la colección.  
  
-   Desasocia las relaciones entre las entidades quitadas y el propietario de la <xref:System.Data.Objects.DataClasses.EntityCollection%601> desde el <xref:System.Data.Objects.ObjectStateManager>.  
  
-   Quita el propietario de la <xref:System.Data.Objects.DataClasses.EntityCollection%601> de las entidades relacionadas.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Contains">
      <MemberSignature Language="C#" Value="public bool Contains (TEntity entity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Contains(!TEntity entity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.DataClasses.EntityCollection`1.Contains(`0)" />
      <MemberSignature Language="VB.NET" Value="Public Function Contains (entity As TEntity) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Contains(TEntity entity);" />
      <MemberSignature Language="F#" Value="abstract member Contains : 'Entity -&gt; bool&#xA;override this.Contains : 'Entity -&gt; bool" Usage="entityCollection.Contains entity" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.ICollection`1.Contains(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="entity" Type="TEntity" />
      </Parameters>
      <Docs>
        <param name="entity">Objeto que se va a buscar en <see cref="T:System.Data.Objects.DataClasses.EntityCollection`1" />.</param>
        <summary>Determina si un objeto concreto existe en la colección.</summary>
        <returns>
          <see langword="true" /> si el objeto se encuentra en <see cref="T:System.Data.Objects.DataClasses.EntityCollection`1" />; en caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Usa el método <xref:System.Object.Equals%2A?displayProperty=nameWithType> para comparar el objeto especificado con los objetos que ya se encuentran en la colección.  
  
   
  
## Examples  
 En este ejemplo se basa en el. Para ejecutar el código de este ejemplo, debe haber agregado ya el modelo AdventureWorks Sales al proyecto y haber configurado el proyecto para que use Entity Framework. Para ello, complete los procedimientos de [Cómo: configurar manualmente un proyecto de Entity Framework](https://msdn.microsoft.com/library/73f6ae1d-b3b2-4577-aebd-ad5a75954e9e) y [Cómo: definir manualmente los archivos de asignación y modelo](https://msdn.microsoft.com/library/d4fd6864-f2a1-48f0-aa32-1e318775a99a).  
  
 En el ejemplo, se realizan las tareas siguientes:  
  
1.  Se crean dos nuevas entidades `SalesOrderHeader` y se agregan a la entidad `Contact`.  
  
2.  Se obtienen todos los extremos relacionados del <xref:System.Data.Objects.DataClasses.RelationshipManager> que está asociado a la entidad Contact.  
  
3.  Se recorre en iteración la colección de <xref:System.Data.Objects.DataClasses.IRelatedEnd>.  
  
4.  Se obtiene la <xref:System.Data.Objects.DataClasses.EntityCollection%601> para cada extremo relacionado.  
  
5.  Se usa el método <xref:System.Data.Objects.DataClasses.EntityCollection%601.Remove%2A> para quitar una entidad de la colección.  
  
6.  Se llama al método <xref:System.Data.Objects.DataClasses.EntityCollection%601.Contains%2A> para determinar si se ha quitado el objeto de la colección.  
  
7.  Se usa el método <xref:System.Data.Objects.DataClasses.EntityCollection%601.Add%2A> para volver a agregar la entidad.  
  
 [!code-csharp[DP ObjectServices Concepts#IRelatedEnd_Add](~/samples/snippets/csharp/VS_Snippets_Data/DP ObjectServices Concepts/CS/Source.cs#irelatedend_add)]
 [!code-vb[DP ObjectServices Concepts#IRelatedEnd_Add](~/samples/snippets/visualbasic/VS_Snippets_Data/DP ObjectServices Concepts/VB/Source.vb#irelatedend_add)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public void CopyTo (TEntity[] array, int arrayIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void CopyTo(!TEntity[] array, int32 arrayIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.DataClasses.EntityCollection`1.CopyTo(`0[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub CopyTo (array As TEntity(), arrayIndex As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void CopyTo(cli::array &lt;TEntity&gt; ^ array, int arrayIndex);" />
      <MemberSignature Language="F#" Value="abstract member CopyTo : 'Entity[] * int -&gt; unit&#xA;override this.CopyTo : 'Entity[] * int -&gt; unit" Usage="entityCollection.CopyTo (array, arrayIndex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="TEntity[]" />
        <Parameter Name="arrayIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">Matriz en la que se va a copiar.</param>
        <param name="arrayIndex">Índice de base cero de la matriz donde comienza la copia.</param>
        <summary>Copia todo el contenido de la colección en una matriz, empezando en el índice especificado de la matriz de destino.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Count">
      <MemberSignature Language="C#" Value="public int Count { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Count" />
      <MemberSignature Language="DocId" Value="P:System.Data.Objects.DataClasses.EntityCollection`1.Count" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Count As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Count { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Count : int" Usage="System.Data.Objects.DataClasses.EntityCollection&lt;'Entity (requires 'Entity : null)&gt;.Count" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.Generic.ICollection`1.Count</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene el número de objetos existentes en la colección.</summary>
        <value>Número de elementos existentes en la <see cref="T:System.Data.Objects.DataClasses.EntityCollection`1" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La propiedad <xref:System.Data.Objects.DataClasses.EntityCollection%601.Count%2A> obtiene el número de entidades existentes en la colección local, pero no refleja el tamaño de la colección en el origen de datos. Un recuento de cero no indica necesariamente que la colección relacionada esté vacía. Para determinar el tamaño de la colección en el origen de datos, llame al método <xref:System.Data.Objects.DataClasses.EntityCollection%601.Load%2A> o incluya el objeto relacionado en la ruta de la consulta. Para obtener más información, consulte [cargar objetos relacionados](https://msdn.microsoft.com/library/452347d2-7b3b-44cd-9001-231299a28cb1).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateSourceQuery">
      <MemberSignature Language="C#" Value="public System.Data.Objects.ObjectQuery&lt;TEntity&gt; CreateSourceQuery ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.Objects.ObjectQuery`1&lt;!TEntity&gt; CreateSourceQuery() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.DataClasses.EntityCollection`1.CreateSourceQuery" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateSourceQuery () As ObjectQuery(Of TEntity)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::Objects::ObjectQuery&lt;TEntity&gt; ^ CreateSourceQuery();" />
      <MemberSignature Language="F#" Value="override this.CreateSourceQuery : unit -&gt; System.Data.Objects.ObjectQuery&lt;'Entity (requires 'Entity : null)&gt;" Usage="entityCollection.CreateSourceQuery " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Objects.ObjectQuery&lt;TEntity&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Devuelve una consulta de objeto que, cuando se ejecuta, devuelve el mismo conjunto de objetos que existe en la colección actual.</summary>
        <returns>
          <see cref="T:System.Data.Objects.ObjectQuery`1" /> que representa la colección de entidades.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esta propiedad se usa para obtener una nueva instancia de <xref:System.Data.Objects.ObjectQuery%601> que devuelva el mismo conjunto de objetos. Esto resulta útil como punto de inicio de una combinación, unión o consulta filtrada más compleja, o para devolver los mismos objetos en un estado desasociado mediante la opción <xref:System.Data.Objects.MergeOption.NoTracking>.  
  
 <xref:System.Data.Objects.DataClasses.EntityCollection%601.CreateSourceQuery%2A> se utiliza para filtrar los objetos en un <xref:System.Data.Objects.DataClasses.EntityCollection%601> para que pueda enlazar sólo los objetos de un tipo específico. Para obtener más información, consulte [enlazar objetos a controles](https://msdn.microsoft.com/library/2fd34855-929b-4303-a91e-4bb69d958f2b).  
  
   
  
## Examples  
 En este ejemplo se basa en una versión modificada de la. Esta versión admite la herencia de tabla por tipo con `Course` como un tipo abstracto. Completar el tutorial para modificar el modelo School para admitir el ejemplo de herencia de tabla por tipo usado en este tema.  
  
 En este ejemplo se muestra cómo usar <xref:System.Data.Objects.DataClasses.EntityCollection%601.CreateSourceQuery%2A> filtrar objetos en un <xref:System.Data.Objects.DataClasses.EntityCollection%601> y enlazar sólo con objetos de un tipo específico. Para obtener una versión completa de este ejemplo, vea [Cómo: enlazar controles a tipos derivados](https://msdn.microsoft.com/library/09730c14-3b7b-4563-af4a-7ecfa4e34bd5).  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Cuando el objeto se encuentra en un estado <see cref="F:System.Data.EntityState.Added" />.  
  
O bien 
Cuando el objeto se encuentra en un estado <see cref="F:System.Data.EntityState.Detached" /> con una <see cref="T:System.Data.Objects.MergeOption" /> distinta de <see cref="F:System.Data.Objects.MergeOption.NoTracking" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetEnumerator">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerator&lt;TEntity&gt; GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.Generic.IEnumerator`1&lt;!TEntity&gt; GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.DataClasses.EntityCollection`1.GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Public Function GetEnumerator () As IEnumerator(Of TEntity)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Collections::Generic::IEnumerator&lt;TEntity&gt; ^ GetEnumerator();" />
      <MemberSignature Language="F#" Value="override this.GetEnumerator : unit -&gt; System.Collections.Generic.IEnumerator&lt;'Entity (requires 'Entity : null)&gt;" Usage="entityCollection.GetEnumerator " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.IEnumerable`1.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerator&lt;TEntity&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Devuelve un enumerador que se usa para recorrer en iteración los objetos de la colección.</summary>
        <returns>
          <see cref="T:System.Collections.IEnumerator" /> que recorre en iteración el conjunto de valores que <see cref="T:System.Data.Objects.DataClasses.EntityCollection`1" /> ha almacenado en caché.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsReadOnly">
      <MemberSignature Language="C#" Value="public bool IsReadOnly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsReadOnly" />
      <MemberSignature Language="DocId" Value="P:System.Data.Objects.DataClasses.EntityCollection`1.IsReadOnly" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsReadOnly As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsReadOnly { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsReadOnly : bool" Usage="System.Data.Objects.DataClasses.EntityCollection&lt;'Entity (requires 'Entity : null)&gt;.IsReadOnly" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.Generic.ICollection`1.IsReadOnly</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene un valor que indica si <see cref="T:System.Data.Objects.DataClasses.EntityCollection`1" /> es de solo lectura.</summary>
        <value>Siempre devuelve <see langword="false" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public override void Load (System.Data.Objects.MergeOption mergeOption);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Load(valuetype System.Data.Objects.MergeOption mergeOption) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.DataClasses.EntityCollection`1.Load(System.Data.Objects.MergeOption)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void Load(System::Data::Objects::MergeOption mergeOption);" />
      <MemberSignature Language="F#" Value="override this.Load : System.Data.Objects.MergeOption -&gt; unit" Usage="entityCollection.Load mergeOption" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="mergeOption" Type="System.Data.Objects.MergeOption" />
      </Parameters>
      <Docs>
        <param name="mergeOption">Especifica cómo se deben combinar los objetos de esta colección con los objetos devueltos de consultas anteriores realizadas en el mismo <see cref="T:System.Data.Objects.ObjectContext" />.</param>
        <summary>Carga los objetos relacionados en la colección con la opción de fusión mediante combinación especificada.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
Este método llama a interno `RelatedEnd.ValidateLoad` método antes de cargar la colección, que valida que una llamada a <xref:System.Data.Objects.DataClasses.RelatedEnd.Load%2A> tiene las condiciones correctas. El `RelatedEnd.ValidateLoad` método comprueba que:

* Válido <xref:System.Data.Objects.ObjectContext> existe.
* No se encuentra la entidad en un <xref:System.Data.EntityState.Deleted> estado.
* <xref:System.Data.Objects.MergeOption> para <xref:System.Data.Objects.DataClasses.RelatedEnd.Load%2A> debe ser <xref:System.Data.Objects.MergeOption.NoTracking> solo si la entidad de origen era <xref:System.Data.Objects.MergeOption.NoTracking>. Si la entidad de origen se ha recuperado con cualquier otro <xref:System.Data.Objects.MergeOption>, el <xref:System.Data.Objects.DataClasses.RelatedEnd.Load%2A> <xref:System.Data.Objects.MergeOption> puede ser cualquier cosa menos <xref:System.Data.Objects.MergeOption.NoTracking> (por ejemplo, la entidad podría se han cargado con <xref:System.Data.Objects.MergeOption.OverwriteChanges> y <xref:System.Data.Objects.DataClasses.RelatedEnd.Load%2A> opción puede ser <xref:System.Data.Objects.MergeOption.AppendOnly>).
* Si `mergeOption` es <xref:System.Data.Objects.MergeOption.NoTracking>, <xref:System.Data.Objects.DataClasses.RelatedEnd.Load%2A> no se llama en una entidad ya cargada y <xref:System.Data.Objects.DataClasses.RelatedEnd.Load%2A> no se llama en un vacío, no se hace un seguimiento <xref:System.Data.Objects.DataClasses.RelatedEnd>.
  
 Cuando los objetos de la colección ya están cargados en el <xref:System.Data.Objects.ObjectContext>, el <xref:System.Data.Objects.DataClasses.EntityCollection%601.Load%2A> método impone la <xref:System.Data.Objects.MergeOption> especificado por el `mergeOption` parámetro. Para obtener más información, consulte [resolución de identidades, administración de Estados y seguimiento de cambios](https://msdn.microsoft.com/library/3bd49311-0e72-4ea4-8355-38fe57036ba0).  
  
 Para cargar explícitamente objetos relacionados, debe llamar a la `Load` método en el extremo relacionado devuelto por la propiedad de navegación. Una relación uno a varios, llame el <xref:System.Data.Objects.DataClasses.EntityCollection%601.Load%2A> método <xref:System.Data.Objects.DataClasses.EntityCollection%601>. Una relación uno a uno, llame el <xref:System.Data.Objects.DataClasses.EntityReference%601.Load%2A> en <xref:System.Data.Objects.DataClasses.EntityReference%601>. Esto carga los datos de objetos relacionados en el contexto del objeto. Puede enumerar la colección de resultados devueltos mediante un `foreach` bucle (`For Each...Next` en Visual Basic) y llamar condicionalmente el `Load` método <xref:System.Data.Objects.DataClasses.EntityReference%601> y <xref:System.Data.Objects.DataClasses.EntityCollection%601> propiedades para cada entidad en los resultados.  
  
 El <xref:System.Data.Objects.DataClasses.EntityCollection%601.Load%2A> método carga los objetos relacionados del origen de datos o no <xref:System.Data.Objects.DataClasses.RelatedEnd.IsLoaded%2A> es `true`.  
  
> [!NOTE]
>  Cuando se llama al método <xref:System.Data.Objects.DataClasses.EntityCollection%601.Load%2A> durante una enumeración `foreach` (C#) o `For Each` (Visual Basic), Servicios de objeto intenta abrir un nuevo lector de datos. Si no ha especificado `multipleactiveresultsets=true` en la cadena de conexión para habilitar varios conjuntos de resultados activos, se producirá un error durante esta operación. También puede cargar el resultado de la consulta en una colección <xref:System.Collections.Generic.List%601>. Esto cierra el lector de datos y permite llevar a cabo la enumeración en la colección para cargar los objetos a los que se hace referencia.  
  
 El método <xref:System.Data.Objects.DataClasses.EntityCollection%601.Load%2A?displayProperty=nameWithType> se sincroniza con el método <xref:System.Data.Objects.DataClasses.EntityReference%601.Load%2A?displayProperty=nameWithType>.  
  
   
  
## Examples  
 En este ejemplo se basa en el. Para ejecutar el código de este ejemplo, debe haber agregado ya el modelo AdventureWorks Sales al proyecto y haber configurado el proyecto para que use Entity Framework. Para ello, complete los procedimientos de [Cómo: configurar manualmente un proyecto de Entity Framework](https://msdn.microsoft.com/library/73f6ae1d-b3b2-4577-aebd-ad5a75954e9e) y [Cómo: definir manualmente los archivos de asignación y modelo](https://msdn.microsoft.com/library/d4fd6864-f2a1-48f0-aa32-1e318775a99a).  
  
 En este ejemplo, se cargan los objetos `SalesOrderHeader` relacionados para la entidad `Contact`.  
  
 [!code-csharp[DP ObjectServices Concepts#QueryWithLoad](~/samples/snippets/csharp/VS_Snippets_Data/DP ObjectServices Concepts/CS/Source.cs#querywithload)]
 [!code-vb[DP ObjectServices Concepts#QueryWithLoad](~/samples/snippets/visualbasic/VS_Snippets_Data/DP ObjectServices Concepts/VB/Source.vb#querywithload)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnCollectionDeserialized">
      <MemberSignature Language="C#" Value="public void OnCollectionDeserialized (System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void OnCollectionDeserialized(valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.DataClasses.EntityCollection`1.OnCollectionDeserialized(System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="VB.NET" Value="Public Sub OnCollectionDeserialized (context As StreamingContext)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void OnCollectionDeserialized(System::Runtime::Serialization::StreamingContext context);" />
      <MemberSignature Language="F#" Value="member this.OnCollectionDeserialized : System.Runtime.Serialization.StreamingContext -&gt; unit" Usage="entityCollection.OnCollectionDeserialized context" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Runtime.Serialization.OnDeserialized</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" />
      </Parameters>
      <Docs>
        <param name="context">Contexto de transmisión por secuencias.</param>
        <summary>Se usa internamente para deserializar los objetos entidad.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnSerializing">
      <MemberSignature Language="C#" Value="public void OnSerializing (System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void OnSerializing(valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.DataClasses.EntityCollection`1.OnSerializing(System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="VB.NET" Value="Public Sub OnSerializing (context As StreamingContext)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void OnSerializing(System::Runtime::Serialization::StreamingContext context);" />
      <MemberSignature Language="F#" Value="member this.OnSerializing : System.Runtime.Serialization.StreamingContext -&gt; unit" Usage="entityCollection.OnSerializing context" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Runtime.Serialization.OnSerializing</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" />
      </Parameters>
      <Docs>
        <param name="context">Contexto de transmisión por secuencias.</param>
        <summary>Se usa internamente para serializar los objetos entidad.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Remove">
      <MemberSignature Language="C#" Value="public bool Remove (TEntity entity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Remove(!TEntity entity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.DataClasses.EntityCollection`1.Remove(`0)" />
      <MemberSignature Language="VB.NET" Value="Public Function Remove (entity As TEntity) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Remove(TEntity entity);" />
      <MemberSignature Language="F#" Value="override this.Remove : 'Entity -&gt; bool" Usage="entityCollection.Remove entity" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.ICollection`1.Remove(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="entity" Type="TEntity" />
      </Parameters>
      <Docs>
        <param name="entity">Objeto que se quitará de la colección.</param>
        <summary>Quita un objeto de la colección y marca la relación para eliminación.</summary>
        <returns>Es <see langword="true" /> si el elemento se quitó correctamente; de lo contrario, es <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El método <xref:System.Data.Objects.DataClasses.EntityCollection%601.Remove%2A> también elimina la relación entre el objeto de origen y el objeto que se va a quitar de la colección. Si la relación tiene una restricción de integridad referencial, al llamar al método <xref:System.Data.Objects.DataClasses.EntityCollection%601.Remove%2A> en un objeto dependiente, se marcan para eliminación tanto la relación como el objeto dependiente. Esto ocurre porque la restricción indica que el objeto dependiente no puede existir sin una relación con el objeto primario. Para obtener más información, consulte [elemento ReferentialConstraint (CSDL)](https://msdn.microsoft.com/library/24f96a80-85b5-4f2e-a14c-0e3eb6796fa0).  
  
 <xref:System.Data.Objects.DataClasses.EntityCollection%601.Remove%2A> Devuelve `false` cuando el objeto especificado no está en la colección.  
  
   
  
## Examples  
 En este ejemplo se basa en el. Para ejecutar el código de este ejemplo, debe haber agregado ya el modelo AdventureWorks Sales al proyecto y haber configurado el proyecto para que use Entity Framework. Para ello, complete los procedimientos de [Cómo: configurar manualmente un proyecto de Entity Framework](https://msdn.microsoft.com/library/73f6ae1d-b3b2-4577-aebd-ad5a75954e9e) y [Cómo: definir manualmente los archivos de asignación y modelo](https://msdn.microsoft.com/library/d4fd6864-f2a1-48f0-aa32-1e318775a99a).  
  
 En este ejemplo, se usa el método <xref:System.Data.Objects.DataClasses.EntityCollection%601.Remove%2A> para quitar una de las entidades de la colección y, a continuación, llama al método <xref:System.Data.Objects.DataClasses.EntityCollection%601.Contains%2A> para determinar si el objeto se ha quitado de la colección.  
  
 [!code-csharp[DP ObjectServices Concepts#IRelatedEnd_Add](~/samples/snippets/csharp/VS_Snippets_Data/DP ObjectServices Concepts/CS/Source.cs#irelatedend_add)]
 [!code-vb[DP ObjectServices Concepts#IRelatedEnd_Add](~/samples/snippets/visualbasic/VS_Snippets_Data/DP ObjectServices Concepts/VB/Source.vb#irelatedend_add)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El objeto <paramref name="entity" /> es <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">El objeto <paramref name="entity" /> no está asociado al mismo contexto del objeto.  
  
O bien 
El objeto <paramref name="entity" /> no tiene un administrador de relaciones válido.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IEnumerable.GetEnumerator">
      <MemberSignature Language="C#" Value="System.Collections.IEnumerator IEnumerable.GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.DataClasses.EntityCollection`1.System#Collections#IEnumerable#GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Function GetEnumerator () As IEnumerator Implements IEnumerable.GetEnumerator" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Collections::IEnumerator ^ System.Collections.IEnumerable.GetEnumerator() = System::Collections::IEnumerable::GetEnumerator;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IEnumerable.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Devuelve un enumerador que se usa para recorrer en iteración el conjunto de valores que <see cref="T:System.Data.Objects.DataClasses.EntityCollection`1" /> ha almacenado en caché.</summary>
        <returns>
          <see cref="T:System.Collections.IEnumerator" /> que recorre en iteración el conjunto de valores que <see cref="T:System.Data.Objects.DataClasses.EntityCollection`1" /> ha almacenado en caché.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.ComponentModel.IListSource.ContainsListCollection">
      <MemberSignature Language="C#" Value="bool System.ComponentModel.IListSource.ContainsListCollection { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.ComponentModel.IListSource.ContainsListCollection" />
      <MemberSignature Language="DocId" Value="P:System.Data.Objects.DataClasses.EntityCollection`1.System#ComponentModel#IListSource#ContainsListCollection" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property ContainsListCollection As Boolean Implements IListSource.ContainsListCollection" />
      <MemberSignature Language="C++ CLI" Value="property bool System::ComponentModel::IListSource::ContainsListCollection { bool get(); };" />
      <MemberSignature Language="F#" Usage="System.ComponentModel.IListSource.ContainsListCollection" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene un valor que indica si la colección de entidades relacionadas está compuesta de objetos de colección.</summary>
        <value>Esta propiedad siempre devuelve <see langword="false" /> porque el objeto <see cref="T:System.Data.Objects.DataClasses.EntityCollection`1" /> contiene objetos y no colecciones.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este miembro es una implementación explícita de un miembro de interfaz. Solo se puede utilizar cuando la instancia de <xref:System.Data.Objects.DataClasses.EntityCollection%601> se convierte en una interfaz <xref:System.ComponentModel.IListSource>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.ComponentModel.IListSource.GetList">
      <MemberSignature Language="C#" Value="System.Collections.IList IListSource.GetList ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.IList System.ComponentModel.IListSource.GetList() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Objects.DataClasses.EntityCollection`1.System#ComponentModel#IListSource#GetList" />
      <MemberSignature Language="VB.NET" Value="Function GetList () As IList Implements IListSource.GetList" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Collections::IList ^ System.ComponentModel.IListSource.GetList() = System::ComponentModel::IListSource::GetList;" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IList</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Devuelve la colección como una <see cref="T:System.Collections.IList" /> usada para el enlace de datos.</summary>
        <returns>
          <see cref="T:System.Collections.IList" /> de objetos entidad.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este miembro es una implementación explícita de un miembro de interfaz. Solo se puede utilizar cuando la instancia de <xref:System.Data.Objects.DataClasses.EntityCollection%601> se convierte en una interfaz <xref:System.ComponentModel.IListSource>.  
  
 Este método habilita el enlace de datos a una <xref:System.Data.Objects.DataClasses.EntityCollection%601>. El control enlazado a la colección llama al método. Para obtener más información, consulte [enlazar objetos a controles](https://msdn.microsoft.com/library/2fd34855-929b-4303-a91e-4bb69d958f2b).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>