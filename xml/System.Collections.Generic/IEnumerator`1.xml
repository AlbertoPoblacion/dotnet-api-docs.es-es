<Type Name="IEnumerator&lt;T&gt;" FullName="System.Collections.Generic.IEnumerator&lt;T&gt;">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="2b1382b0eba1aeb51c1b6bf143660c27af38a65c" />
    <Meta Name="ms.sourcegitcommit" Value="6a0b904069161bbaec4ffd02aa7d9cf38c61e72e" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="es-ES" />
    <Meta Name="ms.lasthandoff" Value="06/24/2018" />
    <Meta Name="ms.locfileid" Value="36713005" />
  </Metadata>
  <TypeSignature Language="C#" Value="public interface IEnumerator&lt;out T&gt; : IDisposable, System.Collections.IEnumerator" />
  <TypeSignature Language="ILAsm" Value=".class public interface auto ansi abstract IEnumerator`1&lt;+ T&gt; implements class System.Collections.IEnumerator, class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:System.Collections.Generic.IEnumerator`1" />
  <TypeSignature Language="VB.NET" Value="Public Interface IEnumerator(Of Out T)&#xA;Implements IDisposable, IEnumerator" />
  <TypeSignature Language="C++ CLI" Value="generic &lt;typename T&gt;&#xA;public interface class IEnumerator : IDisposable, System::Collections::IEnumerator" />
  <TypeSignature Language="F#" Value="type IEnumerator&lt;'T&gt; = interface&#xA;    interface IDisposable&#xA;    interface IEnumerator" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <TypeParameters>
    <TypeParameter Name="T">
      <Constraints>
        <ParameterAttribute>Covariant</ParameterAttribute>
      </Constraints>
    </TypeParameter>
  </TypeParameters>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Collections.IEnumerator</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <typeparam name="T">Tipo de los objetos que se van a enumerar.</typeparam>
    <summary>Admite una iteración simple en una colección genérica.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.Generic.IEnumerator%601> es la interfaz base para todos los enumeradores genéricos.  
  
 El `foreach` instrucción del lenguaje C# (`for each` en C++, `For Each` en Visual Basic) oculta la complejidad de los enumeradores.  Por lo tanto, se recomienda el uso de `foreach`, en lugar de manipular directamente el enumerador.  
  
 Los enumeradores pueden usarse para leer los datos de la colección, pero no para modificar la colección subyacente.  
  
 En principio, el enumerador se coloca antes del primer elemento de la colección. En esta posición, el valor de propiedad <xref:System.Collections.Generic.IEnumerator%601.Current%2A> está sin definir. Por lo tanto, debe llamar a <xref:System.Collections.IEnumerator.MoveNext%2A> para adelantar el enumerador hasta el primer elemento de la colección antes de leer el valor de <xref:System.Collections.Generic.IEnumerator%601.Current%2A>.  
  
 <xref:System.Collections.Generic.IEnumerator%601.Current%2A> devuelve el mismo objeto hasta que se llama a <xref:System.Collections.IEnumerator.MoveNext%2A>. <xref:System.Collections.IEnumerator.MoveNext%2A> establece <xref:System.Collections.Generic.IEnumerator%601.Current%2A> en el siguiente elemento.  
  
 Si <xref:System.Collections.IEnumerator.MoveNext%2A> pasa el final de la colección, el enumerador se coloca después del último elemento de la colección y <xref:System.Collections.IEnumerator.MoveNext%2A> devuelve `false`. Mientras el enumerador permanezca en esta posición, las llamadas subsiguientes a <xref:System.Collections.IEnumerator.MoveNext%2A> también devolver `false`. Si la última llamada a <xref:System.Collections.IEnumerator.MoveNext%2A> devuelve `false`, <xref:System.Collections.Generic.IEnumerator%601.Current%2A> no está definido. No puede volver a establecer la propiedad <xref:System.Collections.Generic.IEnumerator%601.Current%2A> en el primer elemento de la colección, sino que debe crear una nueva instancia del enumerador.  
  
 El <xref:System.Collections.IEnumerator.Reset%2A> método se proporciona para la interoperabilidad COM. Es necesario para que se implementen; en su lugar, el implementador puede producir un <xref:System.NotSupportedException>. Sin embargo, si decide hacerlo, debe asegurarse de que ningún llamadores están confiando en la <xref:System.Collections.IEnumerator.Reset%2A> funcionalidad.  
  
 Si se realizan cambios en la colección, como agregar, modificar o eliminar elementos, el comportamiento del enumerador es indefinido.  
  
 El enumerador no tiene acceso exclusivo a la colección y, por tanto, la enumeración en una colección no es intrínsicamente un procedimiento seguro para subprocesos. A fin de garantizar la seguridad de los subprocesos, se puede bloquear la colección durante toda la enumeración. Para permitir que varios subprocesos obtengan acceso de lectura y escritura a la colección, debe implementar su propia sincronización.  
  
 Las implementaciones predeterminadas de las colecciones del espacio de nombres <xref:System.Collections.Generic?displayProperty=nameWithType> no están sincronizadas.  
  
   
  
## Examples  
 En el ejemplo siguiente se muestra una implementación de la <xref:System.Collections.Generic.IEnumerator%601> interfaz para una clase de colección de objetos personalizados. El objeto personalizado es una instancia del tipo `Box`, y es la clase de colección `BoxCollection`. Este ejemplo de código forma parte de un ejemplo más extenso de la <xref:System.Collections.Generic.ICollection%601> interfaz.  
  
 [!code-csharp[System.Collections.Generic.BoxExamples#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.collections.generic.boxexamples/cs/program.cs#3)]
 [!code-vb[System.Collections.Generic.BoxExamples#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.collections.generic.boxexamples/vb/program.vb#3)]  
  
 ]]></format>
    </remarks>
    <block subset="none" type="overrides">
      <para>Al implementar esta interfaz requiere la implementación de la interfaz no genérica <see cref="T:System.Collections.IEnumerator" /> interfaz. El <see cref="M:System.Collections.IEnumerator.MoveNext" /> y <see cref="M:System.Collections.IEnumerator.Reset" /> métodos no dependen de <typeparamref name="T" />y solo aparecen en la interfaz no genérica. El <see cref="P:System.Collections.Generic.IEnumerator`1.Current" /> propiedad aparece en ambas interfaces y tiene diferentes tipos de valor devuelto. Implementar la interfaz no genérica <see cref="P:System.Collections.IEnumerator.Current" /> propiedad como una implementación de interfaz explícita. Esto permite que cualquier consumidor de la interfaz no genérica usar la interfaz genérica.  Además, <see cref="T:System.Collections.Generic.IEnumerator`1" /> implementa <see cref="T:System.IDisposable" />, que exige que implemente el <see cref="M:System.IDisposable.Dispose" /> método. Esto le permite cerrar las conexiones de base de datos o liberar identificadores de archivos u operaciones similares cuando se utiliza otros recursos. Si no hay recursos adicionales para desechar, proporcionar vacío <see cref="M:System.IDisposable.Dispose" /> implementación.</para>
    </block>
    <altmember cref="T:System.Collections.Generic.IEnumerable`1" />
    <altmember cref="T:System.Collections.Generic.ICollection`1" />
    <altmember cref="N:System.Collections" />
  </Docs>
  <Members>
    <Member MemberName="Current">
      <MemberSignature Language="C#" Value="public T Current { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance !T Current" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.IEnumerator`1.Current" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Current As T" />
      <MemberSignature Language="F#" Value="member this.Current : 'T" Usage="System.Collections.Generic.IEnumerator&lt;'T&gt;.Current" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene el elemento de la colección situado en la posición actual del enumerador.</summary>
        <value>Elemento de la colección en la posición actual del enumerador.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.Generic.IEnumerator%601.Current%2A> no está definida en cualquiera de las condiciones siguientes:  
  
-   El enumerador se coloca antes del primer elemento de la colección, inmediatamente después de crear el enumerador.   <xref:System.Collections.IEnumerator.MoveNext%2A> se debe llamar para adelantar el enumerador hasta el primer elemento de la colección antes de leer el valor de <xref:System.Collections.Generic.IEnumerator%601.Current%2A>.  
  
-   La última llamada a <xref:System.Collections.IEnumerator.MoveNext%2A> devuelve `false`, lo que indica el final de la colección.  
  
-   El enumerador queda invalidado debido a los cambios realizados en la colección, como agregar, modificar o eliminar elementos.  
  
 <xref:System.Collections.Generic.IEnumerator%601.Current%2A> devuelve el mismo objeto hasta que se llama a <xref:System.Collections.IEnumerator.MoveNext%2A>. <xref:System.Collections.IEnumerator.MoveNext%2A> establece <xref:System.Collections.Generic.IEnumerator%601.Current%2A> en el siguiente elemento.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Al implementar esta interfaz requiere la implementación de la interfaz no genérica <see cref="T:System.Collections.IEnumerator" /> interfaz. El <see cref="P:System.Collections.Generic.IEnumerator`1.Current" /> propiedad aparece en ambas interfaces y tiene diferentes tipos de valor devuelto. Implementar la interfaz no genérica <see cref="P:System.Collections.IEnumerator.Current" /> propiedad como una implementación de interfaz explícita. Esto permite que cualquier consumidor de la interfaz no genérica usar la interfaz genérica.</para>
        </block>
        <altmember cref="P:System.Collections.IEnumerator.Current" />
        <altmember cref="M:System.Collections.IEnumerator.MoveNext" />
      </Docs>
    </Member>
  </Members>
</Type>