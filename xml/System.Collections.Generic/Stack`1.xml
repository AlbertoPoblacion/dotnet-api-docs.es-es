<Type Name="Stack&lt;T&gt;" FullName="System.Collections.Generic.Stack&lt;T&gt;">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="bef3e4457f28b6b4377c155c43554858ac8d8a8e" />
    <Meta Name="ms.sourcegitcommit" Value="434f60616a9793fa8436744549fc856e94f7a648" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="es-ES" />
    <Meta Name="ms.lasthandoff" Value="08/25/2018" />
    <Meta Name="ms.locfileid" Value="39773157" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class Stack&lt;T&gt; : System.Collections.Generic.IEnumerable&lt;T&gt;, System.Collections.Generic.IReadOnlyCollection&lt;T&gt;, System.Collections.ICollection" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable beforefieldinit Stack`1&lt;T&gt; extends System.Object implements class System.Collections.Generic.IEnumerable`1&lt;!T&gt;, class System.Collections.Generic.IReadOnlyCollection`1&lt;!T&gt;, class System.Collections.ICollection, class System.Collections.IEnumerable" />
  <TypeSignature Language="DocId" Value="T:System.Collections.Generic.Stack`1" />
  <TypeSignature Language="VB.NET" Value="Public Class Stack(Of T)&#xA;Implements ICollection, IEnumerable(Of T), IReadOnlyCollection(Of T)" />
  <TypeSignature Language="C++ CLI" Value="generic &lt;typename T&gt;&#xA;public ref class Stack : System::Collections::Generic::IEnumerable&lt;T&gt;, System::Collections::Generic::IReadOnlyCollection&lt;T&gt;, System::Collections::ICollection" />
  <TypeSignature Language="F#" Value="type Stack&lt;'T&gt; = class&#xA;    interface seq&lt;'T&gt;&#xA;    interface ICollection&#xA;    interface IReadOnlyCollection&lt;'T&gt;&#xA;    interface IEnumerable" />
  <AssemblyInfo>
    <AssemblyName>System.Collections</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <TypeParameters>
    <TypeParameter Name="T" />
  </TypeParameters>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Collections.Generic.IEnumerable&lt;T&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.Generic.IReadOnlyCollection&lt;T&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.ICollection</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Diagnostics.DebuggerDisplay("Count = {Count}")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Diagnostics.DebuggerTypeProxy(typeof(System.Collections.Generic.System_StackDebugView`1))</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <typeparam name="T">Especifica el tipo de elementos de la pila.</typeparam>
    <summary>Representa una colección último en entrar, primero en salir (LIFO) de tamaño variable con instancias del mismo tipo especificado.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.Generic.Stack%601> se implementa como una matriz.  
  
 Las pilas y las colas son útiles cuando se necesita almacenamiento temporal de información; es decir, cuando desee descartar un elemento después de recuperar su valor. Use <xref:System.Collections.Generic.Queue%601> si necesita acceder a la información en el mismo orden que se almacena en la colección. Use <xref:System.Collections.Generic.Stack%601?displayProperty=nameWithType> si necesita acceder a la información en orden inverso.  
  
 Use la <xref:System.Collections.Concurrent.ConcurrentStack%601?displayProperty=nameWithType> y <xref:System.Collections.Concurrent.ConcurrentQueue%601?displayProperty=nameWithType> tipos cuando necesite tener acceso a la colección desde varios subprocesos simultáneamente.  
  
 Un uso común para <xref:System.Collections.Generic.Stack%601?displayProperty=nameWithType> consiste en conservar los Estados de las variables durante las llamadas a otros procedimientos.  
  
 Se pueden realizar tres operaciones principales en un <xref:System.Collections.Generic.Stack%601?displayProperty=nameWithType> y sus elementos:  
  
-   <xref:System.Collections.Generic.Stack%601.Push%2A> Inserta un elemento en la parte superior de la <xref:System.Collections.Stack>.  
  
-   <xref:System.Collections.Generic.Stack%601.Pop%2A> Quita un elemento de la parte superior de la <xref:System.Collections.Generic.Stack%601>.  
  
-   <xref:System.Collections.Generic.Stack%601.Peek%2A> Devuelve un elemento que se encuentra en la parte superior de la <xref:System.Collections.Generic.Stack%601> pero no se quita de la <xref:System.Collections.Generic.Stack%601>.  
  
 La capacidad de un <xref:System.Collections.Generic.Stack%601> es el número de elementos de la <xref:System.Collections.Generic.Stack%601> puede contener. Cuando se agregan elementos a un <xref:System.Collections.Generic.Stack%601>, automáticamente se aumenta la capacidad según sea necesario mediante la reasignación de la matriz interna. La capacidad puede reducirse mediante una llamada a <xref:System.Collections.Generic.Stack%601.TrimExcess%2A>.  
  
 Si <xref:System.Collections.Generic.Stack%601.Count%2A> es menor que la capacidad de la pila, <xref:System.Collections.Generic.Stack%601.Push%2A> es una operación o (1). Si la capacidad debe aumentarse para alojar el nuevo elemento, <xref:System.Collections.Generic.Stack%601.Push%2A> se convierte en una O (`n`) operación, donde `n` es <xref:System.Collections.Generic.Stack%601.Count%2A>. <xref:System.Collections.Generic.Stack%601.Pop%2A> es una operación o (1).  
  
 <xref:System.Collections.Generic.Stack%601> acepta `null` como un valor válido para la referencia de tipos y permite elementos duplicados.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra varios métodos de la <xref:System.Collections.Generic.Stack%601> clase genérica. El ejemplo de código crea una pila de cadenas con capacidad predeterminada y usa el <xref:System.Collections.Generic.Stack%601.Push%2A> método para insertar cinco cadenas en la pila. Se enumeran los elementos de la pila, que no cambia el estado de la pila. El <xref:System.Collections.Generic.Stack%601.Pop%2A> método se usa para extraer la primera cadena de la pila. El <xref:System.Collections.Generic.Stack%601.Peek%2A> método se utiliza para buscar el siguiente elemento en la pila y, a continuación, el <xref:System.Collections.Generic.Stack%601.Pop%2A> método se utiliza para introducirla.  
  
 El <xref:System.Collections.Generic.Stack%601.ToArray%2A> método se utiliza para crear una matriz y copiar los elementos de la pila en él y, después, la matriz se pasa a la <xref:System.Collections.Generic.Stack%601.%23ctor%2A> constructor que toma <xref:System.Collections.Generic.IEnumerable%601>, crear una copia de la pila con el orden de los elementos invertidos. Se muestran los elementos de la copia.  
  
 Dos veces el tamaño de la pila se crea una matriz y el <xref:System.Collections.Generic.Stack%601.CopyTo%2A> método se usa para copiar los elementos de matriz, empezando por el centro de la matriz. El <xref:System.Collections.Generic.Stack%601.%23ctor%2A> constructor se utiliza de nuevo para crear una copia de la pila con el orden de los elementos invertidos; por tanto, son los tres elementos null al final.  
  
 El <xref:System.Collections.Generic.Stack%601.Contains%2A> método se usa para mostrar que la cadena "4" está en la primera copia de la pila, tras el cual el <xref:System.Collections.Generic.Stack%601.Clear%2A> método borra la copia y el <xref:System.Collections.Generic.Stack%601.Count%2A> propiedad muestra que la pila está vacía.  
  
 [!code-csharp[Generic.Stack#1](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.Stack/cs/source.cs#1)]
 [!code-vb[Generic.Stack#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.Stack/vb/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <threadsafe>Estáticos públicos (<see langword="Shared" /> en Visual Basic) los miembros de este tipo son seguros para subprocesos. No se garantiza que los miembros de instancias sean seguros para la ejecución de subprocesos.  
  
Un <see cref="T:System.Collections.Generic.Stack`1" /> puede admitir varios lectores simultáneamente, siempre y cuando no se modifica la colección.  Aun así, enumerar una colección no es un procedimiento seguro para subprocesos.  A fin de garantizar la seguridad de los subprocesos, se puede bloquear la colección durante toda la enumeración.  Para permitir que varios subprocesos obtengan acceso de lectura y escritura a la colección, debe implementar su propia sincronización.</threadsafe>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Collections.Generic.Stack`1" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Stack ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.Stack`1.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Stack();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Collections.Generic.Stack`1" /> que está vacía y tiene la capacidad inicial predeterminada.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La capacidad de un <xref:System.Collections.Generic.Stack%601> es el número de elementos que la <xref:System.Collections.Generic.Stack%601> puede contener. Cuando se agregan elementos a un <xref:System.Collections.Generic.Stack%601>, automáticamente se aumenta la capacidad según sea necesario mediante la reasignación de la matriz interna.  
  
 Si se puede estimar el tamaño de la colección, al especificar la capacidad inicial elimina la necesidad de realizar una serie de operaciones de cambio de tamaño al agregar elementos a la <xref:System.Collections.Generic.Stack%601>.  
  
 La capacidad puede reducirse mediante una llamada a <xref:System.Collections.Generic.Stack%601.TrimExcess%2A>.  
  
 Este constructor es una operación o (1).  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra este constructor y varios métodos de la <xref:System.Collections.Generic.Stack%601> clase genérica.  
  
 El ejemplo de código crea una pila de cadenas con capacidad predeterminada y usa el <xref:System.Collections.Generic.Stack%601.Push%2A> método para insertar cinco cadenas en la pila. Se enumeran los elementos de la pila, que no cambia el estado de la pila. El <xref:System.Collections.Generic.Stack%601.Pop%2A> método se usa para extraer la primera cadena de la pila. El <xref:System.Collections.Generic.Stack%601.Peek%2A> método se utiliza para buscar el siguiente elemento en la pila y, a continuación, el <xref:System.Collections.Generic.Stack%601.Pop%2A> método se utiliza para introducirla.  
  
 El <xref:System.Collections.Generic.Stack%601.ToArray%2A> método se utiliza para crear una matriz y copiar los elementos de la pila en él y, después, la matriz se pasa a la <xref:System.Collections.Generic.Stack%601.%23ctor%2A> constructor que toma <xref:System.Collections.Generic.IEnumerable%601>, crear una copia de la pila con el orden de los elementos invertidos. Se muestran los elementos de la copia.  
  
 Dos veces el tamaño de la pila se crea una matriz y el <xref:System.Collections.Generic.Stack%601.CopyTo%2A> método se usa para copiar los elementos de matriz, empezando por el centro de la matriz. El <xref:System.Collections.Generic.Stack%601.%23ctor%2A> constructor se utiliza de nuevo para crear una copia de la pila con el orden de los elementos invertidos; por tanto, son los tres elementos null al final.  
  
 El <xref:System.Collections.Generic.Stack%601.Contains%2A> método se usa para mostrar que la cadena "4" está en la primera copia de la pila, tras el cual el <xref:System.Collections.Generic.Stack%601.Clear%2A> método borra la copia y el <xref:System.Collections.Generic.Stack%601.Count%2A> propiedad muestra que la pila está vacía.  
  
 [!code-csharp[Generic.Stack#1](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.Stack/cs/source.cs#1)]
 [!code-vb[Generic.Stack#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.Stack/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Stack (System.Collections.Generic.IEnumerable&lt;T&gt; collection);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Collections.Generic.IEnumerable`1&lt;!T&gt; collection) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.Stack`1.#ctor(System.Collections.Generic.IEnumerable{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (collection As IEnumerable(Of T))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Stack(System::Collections::Generic::IEnumerable&lt;T&gt; ^ collection);" />
      <MemberSignature Language="F#" Value="new System.Collections.Generic.Stack&lt;'T&gt; : seq&lt;'T&gt; -&gt; System.Collections.Generic.Stack&lt;'T&gt;" Usage="new System.Collections.Generic.Stack&lt;'T&gt; collection" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="collection" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="collection">Colección de la que se van a copiar los elementos.</param>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Collections.Generic.Stack`1" /> que contiene elementos copiados de la colección especificada y tiene una capacidad suficiente para aceptar el número de elementos copiados.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La capacidad de un <xref:System.Collections.Generic.Stack%601> es el número de elementos que la <xref:System.Collections.Generic.Stack%601> puede contener. Cuando se agregan elementos a un <xref:System.Collections.Generic.Stack%601>, automáticamente se aumenta la capacidad según sea necesario mediante la reasignación de la matriz interna.  
  
 Si se puede estimar el tamaño de la colección, al especificar la capacidad inicial elimina la necesidad de realizar una serie de operaciones de cambio de tamaño al agregar elementos a la <xref:System.Collections.Generic.Stack%601>.  
  
 La capacidad puede reducirse mediante una llamada a <xref:System.Collections.Generic.Stack%601.TrimExcess%2A>.  
  
 Los elementos se copian en el <xref:System.Collections.Generic.Stack%601> en el mismo orden que los lee el <xref:System.Collections.Generic.IEnumerator%601> de la colección.  
  
 Este constructor es O (`n`) operación, donde `n` es el número de elementos de `collection`.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra este constructor y varios métodos de la <xref:System.Collections.Generic.Stack%601> clase genérica.  
  
 El ejemplo de código crea una pila de cadenas con capacidad predeterminada y usa el <xref:System.Collections.Generic.Stack%601.Push%2A> método para insertar cinco cadenas en la pila. Se enumeran los elementos de la pila, que no cambia el estado de la pila. El <xref:System.Collections.Generic.Stack%601.Pop%2A> método se usa para extraer la primera cadena de la pila. El <xref:System.Collections.Generic.Stack%601.Peek%2A> método se utiliza para buscar el siguiente elemento en la pila y, a continuación, el <xref:System.Collections.Generic.Stack%601.Pop%2A> método se utiliza para introducirla.  
  
 El <xref:System.Collections.Generic.Stack%601.ToArray%2A> método se utiliza para crear una matriz y copiar los elementos de la pila en él y, después, la matriz se pasa a la <xref:System.Collections.Generic.Stack%601.%23ctor%2A> constructor que toma <xref:System.Collections.Generic.IEnumerable%601>, crear una copia de la pila con el orden de los elementos invertidos. Se muestran los elementos de la copia.  
  
 Dos veces el tamaño de la pila se crea una matriz y el <xref:System.Collections.Generic.Stack%601.CopyTo%2A> método se usa para copiar los elementos de matriz, empezando por el centro de la matriz. El <xref:System.Collections.Generic.Stack%601.%23ctor%2A> constructor se utiliza de nuevo para crear una copia de la pila con el orden de los elementos invertidos; por tanto, son los tres elementos null al final.  
  
 El <xref:System.Collections.Generic.Stack%601.Contains%2A> método se usa para mostrar que la cadena "4" está en la primera copia de la pila, tras el cual el <xref:System.Collections.Generic.Stack%601.Clear%2A> método borra la copia y el <xref:System.Collections.Generic.Stack%601.Count%2A> propiedad muestra que la pila está vacía.  
  
 [!code-csharp[Generic.Stack#1](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.Stack/cs/source.cs#1)]
 [!code-vb[Generic.Stack#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.Stack/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="collection" /> es <see langword="null" />.</exception>
        <altmember cref="T:System.Collections.Generic.ICollection`1" />
        <altmember cref="T:System.Collections.Generic.IEnumerator`1" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Stack (int capacity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 capacity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.Stack`1.#ctor(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (capacity As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Stack(int capacity);" />
      <MemberSignature Language="F#" Value="new System.Collections.Generic.Stack&lt;'T&gt; : int -&gt; System.Collections.Generic.Stack&lt;'T&gt;" Usage="new System.Collections.Generic.Stack&lt;'T&gt; capacity" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="capacity" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="capacity">Número inicial de elementos que puede contener la colección <see cref="T:System.Collections.Generic.Stack`1" />.</param>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Collections.Generic.Stack`1" /> que está vacía y tiene la capacidad inicial especificada o la capacidad inicial predeterminada, la que sea mayor.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La capacidad de un <xref:System.Collections.Generic.Stack%601> es el número de elementos que la <xref:System.Collections.Generic.Stack%601> puede contener. Cuando se agregan elementos a un <xref:System.Collections.Generic.Stack%601>, automáticamente se aumenta la capacidad según sea necesario mediante la reasignación de la matriz interna.  
  
 Si se puede estimar el tamaño de la colección, al especificar la capacidad inicial elimina la necesidad de realizar una serie de operaciones de cambio de tamaño al agregar elementos a la <xref:System.Collections.Generic.Stack%601>.  
  
 La capacidad puede reducirse mediante una llamada a <xref:System.Collections.Generic.Stack%601.TrimExcess%2A>.  
  
 Este constructor es O (`n`) operación, donde `n` es `capacity`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="capacity" /> es menor que cero.</exception>
      </Docs>
    </Member>
    <Member MemberName="Clear">
      <MemberSignature Language="C#" Value="public void Clear ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Clear() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.Stack`1.Clear" />
      <MemberSignature Language="VB.NET" Value="Public Sub Clear ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Clear();" />
      <MemberSignature Language="F#" Value="member this.Clear : unit -&gt; unit" Usage="stack.Clear " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Quita todos los objetos de la colección <see cref="T:System.Collections.Generic.Stack`1" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.Generic.Stack%601.Count%2A> está establecido en cero y también se liberan las referencias a otros objetos de elementos de la colección.  
  
 La capacidad permanece sin cambios. Para restablecer la capacidad de la <xref:System.Collections.Generic.Stack%601>, llame a <xref:System.Collections.Generic.Stack%601.TrimExcess%2A>. Recorte vacío <xref:System.Collections.Generic.Stack%601> establece la capacidad de la <xref:System.Collections.Generic.Stack%601> a la capacidad predeterminada.  
  
 Este método es O (`n`) operación, donde `n` es <xref:System.Collections.Generic.Stack%601.Count%2A>.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra varios métodos de la <xref:System.Collections.Generic.Stack%601> clase genérica, incluido el <xref:System.Collections.Generic.Stack%601.Clear%2A> método.  
  
 El ejemplo de código crea una pila de cadenas con capacidad predeterminada y usa el <xref:System.Collections.Generic.Stack%601.Push%2A> método para insertar cinco cadenas en la pila. Se enumeran los elementos de la pila, que no cambia el estado de la pila. El <xref:System.Collections.Generic.Stack%601.Pop%2A> método se usa para extraer la primera cadena de la pila. El <xref:System.Collections.Generic.Stack%601.Peek%2A> método se utiliza para buscar el siguiente elemento en la pila y, a continuación, el <xref:System.Collections.Generic.Stack%601.Pop%2A> método se utiliza para introducirla.  
  
 El <xref:System.Collections.Generic.Stack%601.ToArray%2A> método se utiliza para crear una matriz y copiar los elementos de la pila en él y, después, la matriz se pasa a la <xref:System.Collections.Generic.Stack%601.%23ctor%2A> constructor que toma <xref:System.Collections.Generic.IEnumerable%601>, crear una copia de la pila con el orden de los elementos invertidos. Se muestran los elementos de la copia.  
  
 Dos veces el tamaño de la pila se crea una matriz y el <xref:System.Collections.Generic.Stack%601.CopyTo%2A> método se usa para copiar los elementos de matriz, empezando por el centro de la matriz. El <xref:System.Collections.Generic.Stack%601.%23ctor%2A> constructor se utiliza de nuevo para crear una copia de la pila con el orden de los elementos invertidos; por tanto, son los tres elementos null al final.  
  
 El <xref:System.Collections.Generic.Stack%601.Contains%2A> método se usa para mostrar que la cadena "4" está en la primera copia de la pila, tras el cual el <xref:System.Collections.Generic.Stack%601.Clear%2A> método borra la copia y el <xref:System.Collections.Generic.Stack%601.Count%2A> propiedad muestra que la pila está vacía.  
  
 [!code-csharp[Generic.Stack#1](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.Stack/cs/source.cs#1)]
 [!code-vb[Generic.Stack#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.Stack/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Contains">
      <MemberSignature Language="C#" Value="public bool Contains (T item);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Contains(!T item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.Stack`1.Contains(`0)" />
      <MemberSignature Language="VB.NET" Value="Public Function Contains (item As T) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Contains(T item);" />
      <MemberSignature Language="F#" Value="member this.Contains : 'T -&gt; bool" Usage="stack.Contains item" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="T" />
      </Parameters>
      <Docs>
        <param name="item">Objeto que se va a buscar en <see cref="T:System.Collections.Generic.Stack`1" />. El valor puede ser <see langword="null" /> para los tipos de referencia.</param>
        <summary>Determina si un elemento se encuentra en <see cref="T:System.Collections.Generic.Stack`1" />.</summary>
        <returns>
          <see langword="true" /> si <paramref name="item" /> se encuentra en la matriz <see cref="T:System.Collections.Generic.Stack`1" />; en caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método determina la igualdad utilizando el comparador de igualdad predeterminado <xref:System.Collections.Generic.EqualityComparer%601.Default%2A?displayProperty=nameWithType> para `T`, el tipo de valores en la lista.  
  
 Este método realiza una búsqueda lineal; por lo tanto, este método es O (`n`) operación, donde `n` es <xref:System.Collections.Generic.Stack%601.Count%2A>.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra varios métodos de la <xref:System.Collections.Generic.Stack%601> clase genérica, incluido el <xref:System.Collections.Generic.Stack%601.Contains%2A> método.  
  
 El ejemplo de código crea una pila de cadenas con capacidad predeterminada y usa el <xref:System.Collections.Generic.Stack%601.Push%2A> método para insertar cinco cadenas en la pila. Se enumeran los elementos de la pila, que no cambia el estado de la pila. El <xref:System.Collections.Generic.Stack%601.Pop%2A> método se usa para extraer la primera cadena de la pila. El <xref:System.Collections.Generic.Stack%601.Peek%2A> método se utiliza para buscar el siguiente elemento en la pila y, a continuación, el <xref:System.Collections.Generic.Stack%601.Pop%2A> método se utiliza para introducirla.  
  
 El <xref:System.Collections.Generic.Stack%601.ToArray%2A> método se utiliza para crear una matriz y copiar los elementos de la pila en él y, después, la matriz se pasa a la <xref:System.Collections.Generic.Stack%601.%23ctor%2A> constructor que toma <xref:System.Collections.Generic.IEnumerable%601>, crear una copia de la pila con el orden de los elementos invertidos. Se muestran los elementos de la copia.  
  
 Dos veces el tamaño de la pila se crea una matriz y el <xref:System.Collections.Generic.Stack%601.CopyTo%2A> método se usa para copiar los elementos de matriz, empezando por el centro de la matriz. El <xref:System.Collections.Generic.Stack%601.%23ctor%2A> constructor se utiliza de nuevo para crear una copia de la pila con el orden de los elementos invertidos; por tanto, son los tres elementos null al final.  
  
 El <xref:System.Collections.Generic.Stack%601.Contains%2A> método se usa para mostrar que la cadena "4" está en la primera copia de la pila, tras el cual el <xref:System.Collections.Generic.Stack%601.Clear%2A> método borra la copia y el <xref:System.Collections.Generic.Stack%601.Count%2A> propiedad muestra que la pila está vacía.  
  
 [!code-csharp[Generic.Stack#1](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.Stack/cs/source.cs#1)]
 [!code-vb[Generic.Stack#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.Stack/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public void CopyTo (T[] array, int arrayIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CopyTo(!T[] array, int32 arrayIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.Stack`1.CopyTo(`0[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub CopyTo (array As T(), arrayIndex As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CopyTo(cli::array &lt;T&gt; ^ array, int arrayIndex);" />
      <MemberSignature Language="F#" Value="member this.CopyTo : 'T[] * int -&gt; unit" Usage="stack.CopyTo (array, arrayIndex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="arrayIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">
          <see cref="T:System.Array" /> unidimensional que constituye el destino de los elementos copiados de <see cref="T:System.Collections.Generic.Stack`1" />. <see cref="T:System.Array" /> debe tener una indización de base cero.</param>
        <param name="arrayIndex">Índice de base cero de <c>array</c> donde comienza la copia.</param>
        <summary>Copia <see cref="T:System.Collections.Generic.Stack`1" /> en una <see cref="T:System.Array" /> unidimensional existente, a partir del índice especificado de la matriz.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Los elementos se copian en la matriz en orden de último en el primero en salir (LIFO), similar al orden de los elementos devueltos por una serie de llamadas a <xref:System.Collections.Generic.Stack%601.Pop%2A>.  
  
 Este método es O (`n`) operación, donde `n` es <xref:System.Collections.Generic.Stack%601.Count%2A>.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra varios métodos de la <xref:System.Collections.Generic.Stack%601> clase genérica, incluido el <xref:System.Collections.Generic.Stack%601.CopyTo%2A> método.  
  
 El ejemplo de código crea una pila de cadenas con capacidad predeterminada y usa el <xref:System.Collections.Generic.Stack%601.Push%2A> método para insertar cinco cadenas en la pila. Se enumeran los elementos de la pila, que no cambia el estado de la pila. El <xref:System.Collections.Generic.Stack%601.Pop%2A> método se usa para extraer la primera cadena de la pila. El <xref:System.Collections.Generic.Stack%601.Peek%2A> método se utiliza para buscar el siguiente elemento en la pila y, a continuación, el <xref:System.Collections.Generic.Stack%601.Pop%2A> método se utiliza para introducirla.  
  
 El <xref:System.Collections.Generic.Stack%601.ToArray%2A> método se utiliza para crear una matriz y copiar los elementos de la pila en él y, después, la matriz se pasa a la <xref:System.Collections.Generic.Stack%601.%23ctor%2A> constructor que toma <xref:System.Collections.Generic.IEnumerable%601>, crear una copia de la pila con el orden de los elementos invertidos. Se muestran los elementos de la copia.  
  
 Dos veces el tamaño de la pila se crea una matriz y el <xref:System.Collections.Generic.Stack%601.CopyTo%2A> método se usa para copiar los elementos de matriz, empezando por el centro de la matriz. El <xref:System.Collections.Generic.Stack%601.%23ctor%2A> constructor se utiliza de nuevo para crear una copia de la pila con el orden de los elementos invertidos; por tanto, son los tres elementos null al final.  
  
 El <xref:System.Collections.Generic.Stack%601.Contains%2A> método se usa para mostrar que la cadena "4" está en la primera copia de la pila, tras el cual el <xref:System.Collections.Generic.Stack%601.Clear%2A> método borra la copia y el <xref:System.Collections.Generic.Stack%601.Count%2A> propiedad muestra que la pila está vacía.  
  
 [!code-csharp[Generic.Stack#1](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.Stack/cs/source.cs#1)]
 [!code-vb[Generic.Stack#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.Stack/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="arrayIndex" /> es menor que cero.</exception>
        <exception cref="T:System.ArgumentException">El número de elementos de la <see cref="T:System.Collections.Generic.Stack`1" /> de origen es mayor que el espacio disponible desde <paramref name="arrayIndex" /> hasta el final de la <paramref name="array" /> de destino.</exception>
        <altmember cref="M:System.Collections.Generic.Stack`1.ToArray" />
      </Docs>
    </Member>
    <Member MemberName="Count">
      <MemberSignature Language="C#" Value="public int Count { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Count" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.Stack`1.Count" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Count As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Count { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Count : int" Usage="System.Collections.Generic.Stack&lt;'T&gt;.Count" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.Count</InterfaceMember>
        <InterfaceMember>P:System.Collections.Generic.IReadOnlyCollection`1.Count</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene el número de elementos incluidos en <see cref="T:System.Collections.Generic.Stack`1" />.</summary>
        <value>Número de elementos contenidos en <see cref="T:System.Collections.Generic.Stack`1" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La capacidad de la <xref:System.Collections.Generic.Stack%601> es el número de elementos que la <xref:System.Collections.Generic.Stack%601> puede almacenar. <xref:System.Collections.Generic.Stack%601.Count%2A> es el número de elementos que son en realidad el <xref:System.Collections.Generic.Stack%601>.  
  
 La capacidad siempre es mayor o igual que <xref:System.Collections.Generic.Stack%601.Count%2A>. Si <xref:System.Collections.Generic.Stack%601.Count%2A> supera la capacidad al agregar elementos, se aumenta la capacidad mediante la reasignación automática de la matriz interna antes de copiar los elementos antiguos y agregar los nuevos elementos.  
  
 La recuperación del valor de esta propiedad es una operación O(1).  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra varias propiedades y métodos de la <xref:System.Collections.Generic.Stack%601> clase genérica, incluido el <xref:System.Collections.Generic.Stack%601.Count%2A> propiedad.  
  
 El ejemplo de código crea una pila de cadenas con capacidad predeterminada y usa el <xref:System.Collections.Generic.Stack%601.Push%2A> método para insertar cinco cadenas en la pila. Se enumeran los elementos de la pila, que no cambia el estado de la pila. El <xref:System.Collections.Generic.Stack%601.Pop%2A> método se usa para extraer la primera cadena de la pila. El <xref:System.Collections.Generic.Stack%601.Peek%2A> método se utiliza para buscar el siguiente elemento en la pila y, a continuación, el <xref:System.Collections.Generic.Stack%601.Pop%2A> método se utiliza para introducirla.  
  
 El <xref:System.Collections.Generic.Stack%601.ToArray%2A> método se utiliza para crear una matriz y copiar los elementos de la pila en él y, después, la matriz se pasa a la <xref:System.Collections.Generic.Stack%601.%23ctor%2A> constructor que toma <xref:System.Collections.Generic.IEnumerable%601>, crear una copia de la pila con el orden de los elementos invertidos. Se muestran los elementos de la copia.  
  
 Dos veces el tamaño de la pila se crea una matriz y el <xref:System.Collections.Generic.Stack%601.CopyTo%2A> método se usa para copiar los elementos de matriz, empezando por el centro de la matriz. El <xref:System.Collections.Generic.Stack%601.%23ctor%2A> constructor se utiliza de nuevo para crear una copia de la pila con el orden de los elementos invertidos; por tanto, son los tres elementos null al final.  
  
 El <xref:System.Collections.Generic.Stack%601.Contains%2A> método se usa para mostrar que la cadena "4" está en la primera copia de la pila, tras el cual el <xref:System.Collections.Generic.Stack%601.Clear%2A> método borra la copia y el <xref:System.Collections.Generic.Stack%601.Count%2A> propiedad muestra que la pila está vacía.  
  
 [!code-csharp[Generic.Stack#1](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.Stack/cs/source.cs#1)]
 [!code-vb[Generic.Stack#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.Stack/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetEnumerator">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.Stack&lt;T&gt;.Enumerator GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Collections.Generic.Stack`1/Enumerator&lt;!T&gt; GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.Stack`1.GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Public Function GetEnumerator () As Stack(Of T).Enumerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::Stack&lt;T&gt;::Enumerator GetEnumerator();" />
      <MemberSignature Language="F#" Value="member this.GetEnumerator : unit -&gt; System.Collections.Generic.Stack&lt;'T&gt;.Enumerator" Usage="stack.GetEnumerator " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.Stack&lt;T&gt;+Enumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Devuelve un enumerador para la colección <see cref="T:System.Collections.Generic.Stack`1" />.</summary>
        <returns>Estructura <see cref="T:System.Collections.Generic.Stack`1.Enumerator" /> para la colección <see cref="T:System.Collections.Generic.Stack`1" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El `foreach` instrucción del lenguaje C# (`for each` en C++, `For Each` en Visual Basic) oculta la complejidad de los enumeradores. Por lo tanto, se recomienda el uso de `foreach`, en lugar de manipular directamente el enumerador.  
  
 Los enumeradores pueden usarse para leer los datos de la colección, pero no para modificar la colección subyacente.  
  
 En principio, el enumerador se coloca antes del primer elemento de la colección. En esta posición, el valor de propiedad <xref:System.Collections.Generic.Stack%601.Enumerator.Current%2A> está sin definir. Por lo tanto, debe llamar a <xref:System.Collections.Generic.Stack%601.Enumerator.MoveNext%2A> para adelantar el enumerador hasta el primer elemento de la colección antes de leer el valor de <xref:System.Collections.Generic.Stack%601.Enumerator.Current%2A>.  
  
 <xref:System.Collections.Generic.Stack%601.Enumerator.Current%2A> devuelve el mismo objeto hasta que se llama a <xref:System.Collections.Generic.Stack%601.Enumerator.MoveNext%2A>. <xref:System.Collections.Generic.Stack%601.Enumerator.MoveNext%2A> establece <xref:System.Collections.Generic.Stack%601.Enumerator.Current%2A> en el siguiente elemento.  
  
 Si <xref:System.Collections.Generic.Stack%601.Enumerator.MoveNext%2A> pasa el final de la colección, el enumerador se coloca después del último elemento de la colección y <xref:System.Collections.Generic.Stack%601.Enumerator.MoveNext%2A> devuelve `false`. Cuando el enumerador está en esta posición, las llamadas subsiguientes a <xref:System.Collections.Generic.Stack%601.Enumerator.MoveNext%2A> también devolver `false`. Si la última llamada a <xref:System.Collections.Generic.Stack%601.Enumerator.MoveNext%2A> devuelve `false`, <xref:System.Collections.Generic.Stack%601.Enumerator.Current%2A> es indefinido. No puede volver a establecer la propiedad <xref:System.Collections.Generic.Stack%601.Enumerator.Current%2A> en el primer elemento de la colección, sino que debe crear una nueva instancia del enumerador.  
  
 Un enumerador es válido mientras la colección no cambie. Si se realizan cambios en la colección, como agregar, modificar, o eliminar elementos, el enumerador queda invalida invalidado y la siguiente llamada a <xref:System.Collections.Generic.Stack%601.Enumerator.MoveNext%2A> o <xref:System.Collections.Generic.Stack%601.Enumerator.System%23Collections%23IEnumerator%23Reset%2A> produce una <xref:System.InvalidOperationException>.  
  
 El enumerador no tiene acceso exclusivo a la colección y, por tanto, la enumeración en una colección no es intrínsicamente un procedimiento seguro para subprocesos. A fin de garantizar la seguridad de los subprocesos, se puede bloquear la colección durante toda la enumeración.  Para permitir que varios subprocesos obtengan acceso de lectura y escritura a la colección, debe implementar su propia sincronización.  
  
 Las implementaciones de colecciones en predeterminadas <xref:System.Collections.Generic?displayProperty=nameWithType> no están sincronizadas.  
  
 Este método es una operación o (1).  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra que el <xref:System.Collections.Generic.Stack%601> clase genérica es enumerable. El `foreach` instrucción (`For Each` en Visual Basic, `for each` en C++) se utiliza para enumerar la cola.  
  
 El ejemplo de código crea una pila de cadenas con capacidad predeterminada y usa el <xref:System.Collections.Generic.Stack%601.Push%2A> método para insertar cinco cadenas en la pila. Se enumeran los elementos de la pila, que no cambia el estado de la pila. El <xref:System.Collections.Generic.Stack%601.Pop%2A> método se usa para extraer la primera cadena de la pila. El <xref:System.Collections.Generic.Stack%601.Peek%2A> método se utiliza para buscar el siguiente elemento en la pila y, a continuación, el <xref:System.Collections.Generic.Stack%601.Pop%2A> método se utiliza para introducirla.  
  
 El <xref:System.Collections.Generic.Stack%601.ToArray%2A> método se utiliza para crear una matriz y copiar los elementos de la pila en él y, después, la matriz se pasa a la <xref:System.Collections.Generic.Stack%601.%23ctor%2A> constructor que toma <xref:System.Collections.Generic.IEnumerable%601>, crear una copia de la pila con el orden de los elementos invertidos. Se muestran los elementos de la copia.  
  
 Dos veces el tamaño de la pila se crea una matriz y el <xref:System.Collections.Generic.Stack%601.CopyTo%2A> método se usa para copiar los elementos de matriz, empezando por el centro de la matriz. El <xref:System.Collections.Generic.Stack%601.%23ctor%2A> constructor se utiliza de nuevo para crear una copia de la pila con el orden de los elementos invertidos; por tanto, son los tres elementos null al final.  
  
 El <xref:System.Collections.Generic.Stack%601.Contains%2A> método se usa para mostrar que la cadena "4" está en la primera copia de la pila, tras el cual el <xref:System.Collections.Generic.Stack%601.Clear%2A> método borra la copia y el <xref:System.Collections.Generic.Stack%601.Count%2A> propiedad muestra que la pila está vacía.  
  
 [!code-csharp[Generic.Stack#1](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.Stack/cs/source.cs#1)]
 [!code-vb[Generic.Stack#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.Stack/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.Generic.Stack`1.Enumerator" />
        <altmember cref="T:System.Collections.Generic.IEnumerator`1" />
      </Docs>
    </Member>
    <Member MemberName="Peek">
      <MemberSignature Language="C#" Value="public T Peek ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance !T Peek() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.Stack`1.Peek" />
      <MemberSignature Language="VB.NET" Value="Public Function Peek () As T" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; T Peek();" />
      <MemberSignature Language="F#" Value="member this.Peek : unit -&gt; 'T" Usage="stack.Peek " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Devuelve el objeto situado al principio de <see cref="T:System.Collections.Generic.Stack`1" /> sin eliminarlo.</summary>
        <returns>Objeto situado al principio de la colección <see cref="T:System.Collections.Generic.Stack`1" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método es similar al método <xref:System.Collections.Generic.Stack%601.Pop%2A>, pero <xref:System.Collections.Generic.Stack%601.Peek%2A> no modifica la colección <xref:System.Collections.Generic.Stack%601>.  
  
 Si tipo `T` es un tipo de referencia, `null` puede forzarse la <xref:System.Collections.Generic.Stack%601> como marcador de posición, si es necesario.  
  
 Este método es una operación o (1).  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra varios métodos de la <xref:System.Collections.Generic.Stack%601> clase genérica, incluido el <xref:System.Collections.Generic.Stack%601.Peek%2A> método.  
  
 El ejemplo de código crea una pila de cadenas con capacidad predeterminada y usa el <xref:System.Collections.Generic.Stack%601.Push%2A> método para insertar cinco cadenas en la pila. Se enumeran los elementos de la pila, que no cambia el estado de la pila. El <xref:System.Collections.Generic.Stack%601.Pop%2A> método se usa para extraer la primera cadena de la pila. El <xref:System.Collections.Generic.Stack%601.Peek%2A> método se utiliza para buscar el siguiente elemento en la pila y, a continuación, el <xref:System.Collections.Generic.Stack%601.Pop%2A> método se utiliza para introducirla.  
  
 El <xref:System.Collections.Generic.Stack%601.ToArray%2A> método se utiliza para crear una matriz y copiar los elementos de la pila en él y, después, la matriz se pasa a la <xref:System.Collections.Generic.Stack%601.%23ctor%2A> constructor que toma <xref:System.Collections.Generic.IEnumerable%601>, crear una copia de la pila con el orden de los elementos invertidos. Se muestran los elementos de la copia.  
  
 Dos veces el tamaño de la pila se crea una matriz y el <xref:System.Collections.Generic.Stack%601.CopyTo%2A> método se usa para copiar los elementos de matriz, empezando por el centro de la matriz. El <xref:System.Collections.Generic.Stack%601.%23ctor%2A> constructor se utiliza de nuevo para crear una copia de la pila con el orden de los elementos invertidos; por tanto, son los tres elementos null al final.  
  
 El <xref:System.Collections.Generic.Stack%601.Contains%2A> método se usa para mostrar que la cadena "4" está en la primera copia de la pila, tras el cual el <xref:System.Collections.Generic.Stack%601.Clear%2A> método borra la copia y el <xref:System.Collections.Generic.Stack%601.Count%2A> propiedad muestra que la pila está vacía.  
  
 [!code-csharp[Generic.Stack#1](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.Stack/cs/source.cs#1)]
 [!code-vb[Generic.Stack#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.Stack/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">La colección <see cref="T:System.Collections.Generic.Stack`1" /> está vacía.</exception>
        <altmember cref="M:System.Collections.Generic.Stack`1.Pop" />
        <altmember cref="M:System.Collections.Generic.Stack`1.Push(`0)" />
      </Docs>
    </Member>
    <Member MemberName="Pop">
      <MemberSignature Language="C#" Value="public T Pop ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance !T Pop() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.Stack`1.Pop" />
      <MemberSignature Language="VB.NET" Value="Public Function Pop () As T" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; T Pop();" />
      <MemberSignature Language="F#" Value="member this.Pop : unit -&gt; 'T" Usage="stack.Pop " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Quita y devuelve el objeto situado al principio de <see cref="T:System.Collections.Generic.Stack`1" />.</summary>
        <returns>Objeto eliminado del principio de la colección <see cref="T:System.Collections.Generic.Stack`1" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método es similar al método <xref:System.Collections.Generic.Stack%601.Peek%2A>, pero <xref:System.Collections.Generic.Stack%601.Peek%2A> no modifica la colección <xref:System.Collections.Generic.Stack%601>.  
  
 Si tipo `T` es un tipo de referencia, `null` puede forzarse la <xref:System.Collections.Generic.Stack%601> como marcador de posición, si es necesario.  
  
 <xref:System.Collections.Generic.Stack%601> se implementa como una matriz. Este método es una operación o (1).  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra varios métodos de la <xref:System.Collections.Generic.Stack%601> clase genérica, incluido el <xref:System.Collections.Generic.Stack%601.Pop%2A> método.  
  
 El ejemplo de código crea una pila de cadenas con capacidad predeterminada y usa el <xref:System.Collections.Generic.Stack%601.Push%2A> método para insertar cinco cadenas en la pila. Se enumeran los elementos de la pila, que no cambia el estado de la pila. El <xref:System.Collections.Generic.Stack%601.Pop%2A> método se usa para extraer la primera cadena de la pila. El <xref:System.Collections.Generic.Stack%601.Peek%2A> método se utiliza para buscar el siguiente elemento en la pila y, a continuación, el <xref:System.Collections.Generic.Stack%601.Pop%2A> método se utiliza para introducirla.  
  
 El <xref:System.Collections.Generic.Stack%601.ToArray%2A> método se utiliza para crear una matriz y copiar los elementos de la pila en él y, después, la matriz se pasa a la <xref:System.Collections.Generic.Stack%601.%23ctor%2A> constructor que toma <xref:System.Collections.Generic.IEnumerable%601>, crear una copia de la pila con el orden de los elementos invertidos. Se muestran los elementos de la copia.  
  
 Dos veces el tamaño de la pila se crea una matriz y el <xref:System.Collections.Generic.Stack%601.CopyTo%2A> método se usa para copiar los elementos de matriz, empezando por el centro de la matriz. El <xref:System.Collections.Generic.Stack%601.%23ctor%2A> constructor se utiliza de nuevo para crear una copia de la pila con el orden de los elementos invertidos; por tanto, son los tres elementos null al final.  
  
 El <xref:System.Collections.Generic.Stack%601.Contains%2A> método se usa para mostrar que la cadena "4" está en la primera copia de la pila, tras el cual el <xref:System.Collections.Generic.Stack%601.Clear%2A> método borra la copia y el <xref:System.Collections.Generic.Stack%601.Count%2A> propiedad muestra que la pila está vacía.  
  
 [!code-csharp[Generic.Stack#1](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.Stack/cs/source.cs#1)]
 [!code-vb[Generic.Stack#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.Stack/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">La colección <see cref="T:System.Collections.Generic.Stack`1" /> está vacía.</exception>
        <altmember cref="M:System.Collections.Generic.Stack`1.Peek" />
        <altmember cref="M:System.Collections.Generic.Stack`1.Push(`0)" />
      </Docs>
    </Member>
    <Member MemberName="Push">
      <MemberSignature Language="C#" Value="public void Push (T item);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Push(!T item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.Stack`1.Push(`0)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Push (item As T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Push(T item);" />
      <MemberSignature Language="F#" Value="member this.Push : 'T -&gt; unit" Usage="stack.Push item" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="T" />
      </Parameters>
      <Docs>
        <param name="item">Objeto que se va a insertar en la colección <see cref="T:System.Collections.Generic.Stack`1" />. El valor puede ser <see langword="null" /> para los tipos de referencia.</param>
        <summary>Inserta un objeto al principio de <see cref="T:System.Collections.Generic.Stack`1" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.Generic.Stack%601> se implementa como una matriz.  
  
 Si <xref:System.Collections.Generic.Stack%601.Count%2A> ya es igual a la capacidad, la capacidad de la <xref:System.Collections.Generic.Stack%601> incrementando reasignación automática de la matriz interna, y se copian los elementos existentes en la nueva matriz antes de agrega el nuevo elemento.  
  
 Si tipo `T` es un tipo de referencia, `null` puede forzarse la <xref:System.Collections.Generic.Stack%601> como marcador de posición, si es necesario. Ocupa una posición en la pila y se tratan como cualquier objeto.  
  
 Si <xref:System.Collections.Generic.Stack%601.Count%2A> es menor que la capacidad de la pila, <xref:System.Collections.Generic.Stack%601.Push%2A> es una operación o (1). Si la capacidad debe aumentarse para alojar el nuevo elemento, <xref:System.Collections.Generic.Stack%601.Push%2A> se convierte en una O (`n`) operación, donde `n` es <xref:System.Collections.Generic.Stack%601.Count%2A>.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra varios métodos de la <xref:System.Collections.Generic.Stack%601> clase genérica, incluido el <xref:System.Collections.Generic.Stack%601.Push%2A> método.  
  
 El ejemplo de código crea una pila de cadenas con capacidad predeterminada y usa el <xref:System.Collections.Generic.Stack%601.Push%2A> método para insertar cinco cadenas en la pila. Se enumeran los elementos de la pila, que no cambia el estado de la pila. El <xref:System.Collections.Generic.Stack%601.Pop%2A> método se usa para extraer la primera cadena de la pila. El <xref:System.Collections.Generic.Stack%601.Peek%2A> método se utiliza para buscar el siguiente elemento en la pila y, a continuación, el <xref:System.Collections.Generic.Stack%601.Pop%2A> método se utiliza para introducirla.  
  
 El <xref:System.Collections.Generic.Stack%601.ToArray%2A> método se utiliza para crear una matriz y copiar los elementos de la pila en él y, después, la matriz se pasa a la <xref:System.Collections.Generic.Stack%601.%23ctor%2A> constructor que toma <xref:System.Collections.Generic.IEnumerable%601>, crear una copia de la pila con el orden de los elementos invertidos. Se muestran los elementos de la copia.  
  
 Dos veces el tamaño de la pila se crea una matriz y el <xref:System.Collections.Generic.Stack%601.CopyTo%2A> método se usa para copiar los elementos de matriz, empezando por el centro de la matriz. El <xref:System.Collections.Generic.Stack%601.%23ctor%2A> constructor se utiliza de nuevo para crear una copia de la pila con el orden de los elementos invertidos; por tanto, son los tres elementos null al final.  
  
 El <xref:System.Collections.Generic.Stack%601.Contains%2A> método se usa para mostrar que la cadena "4" está en la primera copia de la pila, tras el cual el <xref:System.Collections.Generic.Stack%601.Clear%2A> método borra la copia y el <xref:System.Collections.Generic.Stack%601.Count%2A> propiedad muestra que la pila está vacía.  
  
 [!code-csharp[Generic.Stack#1](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.Stack/cs/source.cs#1)]
 [!code-vb[Generic.Stack#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.Stack/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Collections.Generic.Stack`1.Peek" />
        <altmember cref="M:System.Collections.Generic.Stack`1.Pop" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Generic.IEnumerable&lt;T&gt;.GetEnumerator">
      <MemberSignature Language="C#" Value="System.Collections.Generic.IEnumerator&lt;T&gt; IEnumerable&lt;T&gt;.GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.Generic.IEnumerator`1&lt;!T&gt; System.Collections.Generic.IEnumerable&lt;T&gt;.GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.Stack`1.System#Collections#Generic#IEnumerable&lt;T&gt;#GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Function GetEnumerator () As IEnumerator(Of T) Implements IEnumerable(Of T).GetEnumerator" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Collections::Generic::IEnumerator&lt;T&gt; ^ System.Collections.Generic.IEnumerable&lt;T&gt;.GetEnumerator() = System::Collections::Generic::IEnumerable&lt;T&gt;::GetEnumerator;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.IEnumerable`1.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerator&lt;T&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Devuelve un enumerador que procesa una iteración en la colección.</summary>
        <returns>
          <see cref="T:System.Collections.Generic.IEnumerator`1" /> que se puede utilizar para recorrer en iteración la colección.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El `foreach` instrucción del lenguaje C# (`for each` en C++, `For Each` en Visual Basic) oculta la complejidad de los enumeradores. Por lo tanto, se recomienda el uso de `foreach`, en lugar de manipular directamente el enumerador.  
  
 Los enumeradores pueden usarse para leer los datos de la colección, pero no para modificar la colección subyacente.  
  
 En principio, el enumerador se coloca antes del primer elemento de la colección. En esta posición, el valor de propiedad <xref:System.Collections.Generic.IEnumerator%601.Current%2A> está sin definir. Por lo tanto, debe llamar a <xref:System.Collections.IEnumerator.MoveNext%2A> para adelantar el enumerador hasta el primer elemento de la colección antes de leer el valor de <xref:System.Collections.Generic.IEnumerator%601.Current%2A>.  
  
 <xref:System.Collections.Generic.IEnumerator%601.Current%2A> devuelve el mismo objeto hasta que se llama a <xref:System.Collections.IEnumerator.MoveNext%2A>. <xref:System.Collections.IEnumerator.MoveNext%2A> establece <xref:System.Collections.Generic.IEnumerator%601.Current%2A> en el siguiente elemento.  
  
 Si <xref:System.Collections.IEnumerator.MoveNext%2A> pasa el final de la colección, el enumerador se coloca después del último elemento de la colección y <xref:System.Collections.IEnumerator.MoveNext%2A> devuelve `false`. Cuando el enumerador está en esta posición, las llamadas subsiguientes a <xref:System.Collections.IEnumerator.MoveNext%2A> también devolver `false`. Si la última llamada a <xref:System.Collections.IEnumerator.MoveNext%2A> devuelve `false`, <xref:System.Collections.Generic.IEnumerator%601.Current%2A> es indefinido. No puede volver a establecer la propiedad <xref:System.Collections.Generic.IEnumerator%601.Current%2A> en el primer elemento de la colección, sino que debe crear una nueva instancia del enumerador.  
  
 Un enumerador es válido mientras la colección no cambie. Si se realizan cambios en la colección, como agregar, modificar, o eliminar elementos, el enumerador queda invalida invalidado y la siguiente llamada a <xref:System.Collections.IEnumerator.MoveNext%2A> o <xref:System.Collections.IEnumerator.Reset%2A> produce una <xref:System.InvalidOperationException>.  
  
 El enumerador no tiene acceso exclusivo a la colección y, por tanto, la enumeración en una colección no es intrínsicamente un procedimiento seguro para subprocesos. A fin de garantizar la seguridad de los subprocesos, se puede bloquear la colección durante toda la enumeración.  Para permitir que varios subprocesos obtengan acceso de lectura y escritura a la colección, debe implementar su propia sincronización.  
  
 Las implementaciones de colecciones en predeterminadas <xref:System.Collections.Generic?displayProperty=nameWithType> no están sincronizadas.  
  
 Este método es una operación o (1).  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.Generic.IEnumerator`1" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.ICollection.CopyTo">
      <MemberSignature Language="C#" Value="void ICollection.CopyTo (Array array, int arrayIndex);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Collections.ICollection.CopyTo(class System.Array array, int32 arrayIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.Stack`1.System#Collections#ICollection#CopyTo(System.Array,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Collections.ICollection.CopyTo(Array ^ array, int arrayIndex) = System::Collections::ICollection::CopyTo;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.ICollection.CopyTo(System.Array,System.Int32)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="arrayIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">
          <see cref="T:System.Array" /> unidimensional que constituye el destino de los elementos copiados de <see cref="T:System.Collections.ICollection" />. <see cref="T:System.Array" /> debe tener una indización de base cero.</param>
        <param name="arrayIndex">Índice de base cero de <c>array</c> donde comienza la copia.</param>
        <summary>Copia los elementos de <see cref="T:System.Collections.ICollection" /> en <see cref="T:System.Array" />, empezando por un índice determinado de <see cref="T:System.Array" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Si el tipo del origen de <xref:System.Collections.ICollection> no puede convertirse automáticamente al tipo del destino `array`, las implementaciones no genérica de <xref:System.Collections.ICollection.CopyTo%2A?displayProperty=nameWithType> throw <xref:System.InvalidCastException>, mientras que las implementaciones genéricas inician <xref:System.ArgumentException>.  
  
 Este método es O (`n`) operación, donde `n` es <xref:System.Collections.Generic.Stack%601.Count%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="arrayIndex" /> es menor que cero.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="array" /> es multidimensional.  
  
O bien 
 <paramref name="array" /> no tiene índices de base cero.  
  
O bien 
El número de elementos de la <see cref="T:System.Collections.ICollection" /> de origen es mayor que el espacio disponible desde <paramref name="arrayIndex" /> hasta el final de la <paramref name="array" /> de destino.  
  
O bien 
El tipo de la <see cref="T:System.Collections.ICollection" /> de origen no puede convertirse automáticamente al tipo de la <paramref name="array" /> de destino.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.ICollection.IsSynchronized">
      <MemberSignature Language="C#" Value="bool System.Collections.ICollection.IsSynchronized { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Collections.ICollection.IsSynchronized" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.Stack`1.System#Collections#ICollection#IsSynchronized" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsSynchronized As Boolean Implements ICollection.IsSynchronized" />
      <MemberSignature Language="C++ CLI" Value="property bool System::Collections::ICollection::IsSynchronized { bool get(); };" />
      <MemberSignature Language="F#" Usage="System.Collections.ICollection.IsSynchronized" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.IsSynchronized</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene un valor que indica si el acceso a la interfaz <see cref="T:System.Collections.ICollection" /> está sincronizado (es seguro para subprocesos).</summary>
        <value>Es <see langword="true" /> si el acceso a <see cref="T:System.Collections.ICollection" /> está sincronizado (es seguro para subprocesos); de lo contrario, es <see langword="false" />.  En la implementación predeterminada de <see cref="T:System.Collections.Generic.Stack`1" />, esta propiedad siempre devuelve <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Las implementaciones de colecciones en predeterminadas <xref:System.Collections.Generic?displayProperty=nameWithType> no están sincronizadas.  
  
 Enumerar una colección no es intrínsecamente un procedimiento seguro para subprocesos.  En el caso excepcional donde enumeraciones compitan con accesos de escritura, se debe bloquear la colección durante toda la enumeración.  Para permitir que varios subprocesos obtengan acceso de lectura y escritura a la colección, debe implementar su propia sincronización.  
  
 <xref:System.Collections.ICollection.SyncRoot%2A> Devuelve un objeto que puede utilizarse para sincronizar el acceso a la <xref:System.Collections.ICollection>. La sincronización es eficaz solo si todos los subprocesos bloquean este objeto antes de acceder a la colección.  
  
 La recuperación del valor de esta propiedad es una operación O(1).  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Collections.ICollection.SyncRoot" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.ICollection.SyncRoot">
      <MemberSignature Language="C#" Value="object System.Collections.ICollection.SyncRoot { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object System.Collections.ICollection.SyncRoot" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.Stack`1.System#Collections#ICollection#SyncRoot" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property SyncRoot As Object Implements ICollection.SyncRoot" />
      <MemberSignature Language="C++ CLI" Value="property System::Object ^ System::Collections::ICollection::SyncRoot { System::Object ^ get(); };" />
      <MemberSignature Language="F#" Usage="System.Collections.ICollection.SyncRoot" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.SyncRoot</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene un objeto que se puede usar para sincronizar el acceso a <see cref="T:System.Collections.ICollection" />.</summary>
        <value>Objeto que se puede usar para sincronizar el acceso a <see cref="T:System.Collections.ICollection" />.  En la implementación predeterminada de <see cref="T:System.Collections.Generic.Stack`1" />, esta propiedad siempre devuelve la instancia actual.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Las implementaciones de colecciones en predeterminadas <xref:System.Collections.Generic?displayProperty=nameWithType> no están sincronizadas.  
  
 Enumerar una colección no es intrínsecamente un procedimiento seguro para subprocesos.  A fin de garantizar la seguridad de los subprocesos, se puede bloquear la colección durante toda la enumeración.  Para permitir que varios subprocesos obtengan acceso de lectura y escritura a la colección, debe implementar su propia sincronización.  
  
 <xref:System.Collections.ICollection.SyncRoot%2A> Devuelve un objeto que puede utilizarse para sincronizar el acceso a la <xref:System.Collections.ICollection>. La sincronización es eficaz solo si todos los subprocesos bloquean este objeto antes de acceder a la colección. El código siguiente muestra el uso de la <xref:System.Collections.ICollection.SyncRoot%2A> propiedad para C#, C++ y Visual Basic.  
  
```csharp  
ICollection ic = ...;  
lock (ic.SyncRoot) {  
   // Access the collection.  
}  
```  
  
```vb  
Dim ic As ICollection = ...  
SyncLock ic.SyncRoot  
   ' Access the collection.  
End SyncLock  
```  
  
```cpp#  
ICollection^ ic = ...;  
try {  
   Monitor::Enter(ic->SyncRoot);  
   // Access the collection.  
}  
finally {  
   Monitor::Exit(ic->SyncRoot);  
}  
```  
  
 La recuperación del valor de esta propiedad es una operación O(1).  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Collections.ICollection.IsSynchronized" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IEnumerable.GetEnumerator">
      <MemberSignature Language="C#" Value="System.Collections.IEnumerator IEnumerable.GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.Stack`1.System#Collections#IEnumerable#GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Function GetEnumerator () As IEnumerator Implements IEnumerable.GetEnumerator" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Collections::IEnumerator ^ System.Collections.IEnumerable.GetEnumerator() = System::Collections::IEnumerable::GetEnumerator;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IEnumerable.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Devuelve un enumerador que recorre en iteración una colección.</summary>
        <returns>
          <see cref="T:System.Collections.IEnumerator" /> que se puede utilizar para recorrer en iteración la colección.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El `foreach` instrucción del lenguaje C# (`for each` en C++, `For Each` en Visual Basic) oculta la complejidad de los enumeradores. Por lo tanto, se recomienda el uso de `foreach`, en lugar de manipular directamente el enumerador.  
  
 Los enumeradores pueden usarse para leer los datos de la colección, pero no para modificar la colección subyacente.  
  
 En principio, el enumerador se coloca antes del primer elemento de la colección. <xref:System.Collections.IEnumerator.Reset%2A> también devuelve el enumerador a esta posición.  En esta posición, el valor de propiedad <xref:System.Collections.IEnumerator.Current%2A> está sin definir. Por lo tanto, debe llamar a <xref:System.Collections.IEnumerator.MoveNext%2A> para adelantar el enumerador hasta el primer elemento de la colección antes de leer el valor de <xref:System.Collections.IEnumerator.Current%2A>.  
  
 <xref:System.Collections.IEnumerator.Current%2A> devuelve el mismo objeto hasta que se llama a <xref:System.Collections.IEnumerator.MoveNext%2A> o a <xref:System.Collections.IEnumerator.Reset%2A>. <xref:System.Collections.IEnumerator.MoveNext%2A> establece <xref:System.Collections.IEnumerator.Current%2A> en el siguiente elemento.  
  
 Si <xref:System.Collections.IEnumerator.MoveNext%2A> pasa el final de la colección, el enumerador se coloca después del último elemento de la colección y <xref:System.Collections.IEnumerator.MoveNext%2A> devuelve `false`. Cuando el enumerador está en esta posición, las llamadas subsiguientes a <xref:System.Collections.IEnumerator.MoveNext%2A> también devolver `false`. Si la última llamada a <xref:System.Collections.IEnumerator.MoveNext%2A> devuelve `false`, <xref:System.Collections.IEnumerator.Current%2A> es indefinido. Para volver a establecer el valor de <xref:System.Collections.IEnumerator.Current%2A> en el primer elemento de la colección, se puede llamar primero a <xref:System.Collections.IEnumerator.Reset%2A> y después a <xref:System.Collections.IEnumerator.MoveNext%2A>.  
  
 Un enumerador es válido mientras la colección no cambie. Si se realizan cambios en la colección, como agregar, modificar, o eliminar elementos, el enumerador queda invalida invalidado y la siguiente llamada a <xref:System.Collections.IEnumerator.MoveNext%2A> o <xref:System.Collections.IEnumerator.Reset%2A> produce una <xref:System.InvalidOperationException>.  
  
 El enumerador no tiene acceso exclusivo a la colección y, por tanto, la enumeración en una colección no es intrínsicamente un procedimiento seguro para subprocesos.  A fin de garantizar la seguridad de los subprocesos, se puede bloquear la colección durante toda la enumeración.  Para permitir que varios subprocesos obtengan acceso de lectura y escritura a la colección, debe implementar su propia sincronización.  
  
 Las implementaciones de colecciones en predeterminadas <xref:System.Collections.Generic?displayProperty=nameWithType> no están sincronizadas.  
  
 Este método es una operación o (1).  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Collections.Generic.Stack`1.GetEnumerator" />
        <altmember cref="M:System.Collections.Generic.IEnumerable`1.GetEnumerator" />
        <altmember cref="T:System.Collections.IEnumerator" />
      </Docs>
    </Member>
    <Member MemberName="ToArray">
      <MemberSignature Language="C#" Value="public T[] ToArray ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance !T[] ToArray() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.Stack`1.ToArray" />
      <MemberSignature Language="VB.NET" Value="Public Function ToArray () As T()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;T&gt; ^ ToArray();" />
      <MemberSignature Language="F#" Value="member this.ToArray : unit -&gt; 'T[]" Usage="stack.ToArray " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Copia <see cref="T:System.Collections.Generic.Stack`1" /> en una nueva matriz.</summary>
        <returns>Nueva matriz que contiene copias de los elementos de <see cref="T:System.Collections.Generic.Stack`1" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Los elementos se copian en la matriz en orden de último en el primero en salir (LIFO), similar al orden de los elementos devueltos por una serie de llamadas a <xref:System.Collections.Generic.Stack%601.Pop%2A>.  
  
 Este método es O (`n`) operación, donde `n` es <xref:System.Collections.Generic.Stack%601.Count%2A>.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra varios métodos de la <xref:System.Collections.Generic.Stack%601> clase genérica, incluido el <xref:System.Collections.Generic.Stack%601.ToArray%2A> método.  
  
 El ejemplo de código crea una pila de cadenas con capacidad predeterminada y usa el <xref:System.Collections.Generic.Stack%601.Push%2A> método para insertar cinco cadenas en la pila. Se enumeran los elementos de la pila, que no cambia el estado de la pila. El <xref:System.Collections.Generic.Stack%601.Pop%2A> método se usa para extraer la primera cadena de la pila. El <xref:System.Collections.Generic.Stack%601.Peek%2A> método se utiliza para buscar el siguiente elemento en la pila y, a continuación, el <xref:System.Collections.Generic.Stack%601.Pop%2A> método se utiliza para introducirla.  
  
 El <xref:System.Collections.Generic.Stack%601.ToArray%2A> método se utiliza para crear una matriz y copiar los elementos de la pila en él y, después, la matriz se pasa a la <xref:System.Collections.Generic.Stack%601.%23ctor%2A> constructor que toma <xref:System.Collections.Generic.IEnumerable%601>, crear una copia de la pila con el orden de los elementos invertidos. Se muestran los elementos de la copia.  
  
 Dos veces el tamaño de la pila se crea una matriz y el <xref:System.Collections.Generic.Stack%601.CopyTo%2A> método se usa para copiar los elementos de matriz, empezando por el centro de la matriz. El <xref:System.Collections.Generic.Stack%601.%23ctor%2A> constructor se utiliza de nuevo para crear una copia de la pila con el orden de los elementos invertidos; por tanto, son los tres elementos null al final.  
  
 El <xref:System.Collections.Generic.Stack%601.Contains%2A> método se usa para mostrar que la cadena "4" está en la primera copia de la pila, tras el cual el <xref:System.Collections.Generic.Stack%601.Clear%2A> método borra la copia y el <xref:System.Collections.Generic.Stack%601.Count%2A> propiedad muestra que la pila está vacía.  
  
 [!code-csharp[Generic.Stack#1](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.Stack/cs/source.cs#1)]
 [!code-vb[Generic.Stack#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.Stack/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Collections.Generic.Stack`1.CopyTo(`0[],System.Int32)" />
        <altmember cref="M:System.Collections.Generic.Stack`1.Pop" />
      </Docs>
    </Member>
    <Member MemberName="TrimExcess">
      <MemberSignature Language="C#" Value="public void TrimExcess ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void TrimExcess() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.Stack`1.TrimExcess" />
      <MemberSignature Language="VB.NET" Value="Public Sub TrimExcess ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void TrimExcess();" />
      <MemberSignature Language="F#" Value="member this.TrimExcess : unit -&gt; unit" Usage="stack.TrimExcess " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Establece la capacidad en el número real de elementos en la colección <see cref="T:System.Collections.Generic.Stack`1" />, si este número supone menos del 90 por ciento de la capacidad actual.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método puede utilizarse para minimizar la sobrecarga de memoria de una colección si ningún elemento nuevo se agregará a la colección. El costo de reasignar y copiar una gran <xref:System.Collections.Generic.Stack%601> puede ser considerable, sin embargo, por lo que el <xref:System.Collections.Generic.Stack%601.TrimExcess%2A> método no hace nada si la lista está en más del 90 por ciento de capacidad. Esto evita incurrir en un gran costo de reasignación para lograr una mejora relativamente pequeña.  
  
 Este método es O (`n`) operación, donde `n` es <xref:System.Collections.Generic.Stack%601.Count%2A>.  
  
 Para restablecer un <xref:System.Collections.Generic.Stack%601> a su estado inicial, llame a la <xref:System.Collections.Generic.Stack%601.Clear%2A> método antes de llamar a <xref:System.Collections.Generic.Stack%601.TrimExcess%2A> método. Recorte vacío <xref:System.Collections.Generic.Stack%601> establece la capacidad de la <xref:System.Collections.Generic.Stack%601> a la capacidad predeterminada.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Collections.Generic.Stack`1.Clear" />
        <altmember cref="P:System.Collections.Generic.Stack`1.Count" />
      </Docs>
    </Member>
    <Member MemberName="TryPeek">
      <MemberSignature Language="C#" Value="public bool TryPeek (out T result);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryPeek([out] !T&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.Stack`1.TryPeek(`0@)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryPeek (ByRef result As T) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryPeek([Runtime::InteropServices::Out] T % result);" />
      <MemberSignature Language="F#" Value="member this.TryPeek :  -&gt; bool" Usage="stack.TryPeek result" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="result" Type="T" RefType="out" />
      </Parameters>
      <Docs>
        <param name="result">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryPop">
      <MemberSignature Language="C#" Value="public bool TryPop (out T result);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryPop([out] !T&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.Stack`1.TryPop(`0@)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryPop (ByRef result As T) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryPop([Runtime::InteropServices::Out] T % result);" />
      <MemberSignature Language="F#" Value="member this.TryPop :  -&gt; bool" Usage="stack.TryPop result" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="result" Type="T" RefType="out" />
      </Parameters>
      <Docs>
        <param name="result">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>