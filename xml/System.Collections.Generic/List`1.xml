<Type Name="List&lt;T&gt;" FullName="System.Collections.Generic.List&lt;T&gt;">
  <Metadata><Meta Name="ms.openlocfilehash" Value="d2cd21c473d2a8e7d15784e964161e6a1da7bcfa" /><Meta Name="ms.sourcegitcommit" Value="954560a1b131dce1872e29ce5c01cd9f2c927f11" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="es-ES" /><Meta Name="ms.lasthandoff" Value="01/11/2019" /><Meta Name="ms.locfileid" Value="54235143" /></Metadata><TypeSignature Language="C#" Value="public class List&lt;T&gt; : System.Collections.Generic.ICollection&lt;T&gt;, System.Collections.Generic.IEnumerable&lt;T&gt;, System.Collections.Generic.IList&lt;T&gt;, System.Collections.Generic.IReadOnlyCollection&lt;T&gt;, System.Collections.Generic.IReadOnlyList&lt;T&gt;, System.Collections.IList" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable beforefieldinit List`1&lt;T&gt; extends System.Object implements class System.Collections.Generic.ICollection`1&lt;!T&gt;, class System.Collections.Generic.IEnumerable`1&lt;!T&gt;, class System.Collections.Generic.IList`1&lt;!T&gt;, class System.Collections.Generic.IReadOnlyCollection`1&lt;!T&gt;, class System.Collections.Generic.IReadOnlyList`1&lt;!T&gt;, class System.Collections.ICollection, class System.Collections.IEnumerable, class System.Collections.IList" />
  <TypeSignature Language="DocId" Value="T:System.Collections.Generic.List`1" />
  <TypeSignature Language="VB.NET" Value="Public Class List(Of T)&#xA;Implements ICollection(Of T), IEnumerable(Of T), IList, IList(Of T), IReadOnlyCollection(Of T), IReadOnlyList(Of T)" />
  <TypeSignature Language="C++ CLI" Value="generic &lt;typename T&gt;&#xA;public ref class List : System::Collections::Generic::ICollection&lt;T&gt;, System::Collections::Generic::IEnumerable&lt;T&gt;, System::Collections::Generic::IList&lt;T&gt;, System::Collections::Generic::IReadOnlyCollection&lt;T&gt;, System::Collections::Generic::IReadOnlyList&lt;T&gt;, System::Collections::IList" />
  <TypeSignature Language="F#" Value="type List&lt;'T&gt; = class&#xA;    interface IList&lt;'T&gt;&#xA;    interface IList&#xA;    interface IReadOnlyList&lt;'T&gt;&#xA;    interface ICollection&lt;'T&gt;&#xA;    interface seq&lt;'T&gt;&#xA;    interface IEnumerable&#xA;    interface ICollection&#xA;    interface IReadOnlyCollection&lt;'T&gt;" />
  <AssemblyInfo>
    <AssemblyName>System.Collections</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <TypeParameters>
    <TypeParameter Name="T" />
  </TypeParameters>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Collections.Generic.ICollection&lt;T&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.Generic.IEnumerable&lt;T&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.Generic.IList&lt;T&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.Generic.IReadOnlyCollection&lt;T&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.Generic.IReadOnlyList&lt;T&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.ICollection</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.IEnumerable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.IList</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Diagnostics.DebuggerDisplay("Count = {Count}")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Diagnostics.DebuggerTypeProxy(typeof(System.Collections.Generic.Mscorlib_CollectionDebugView`1))</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <typeparam name="T">Tipo de elementos en la lista.</typeparam>
    <summary>Representa una lista de objetos fuertemente tipados a la que se puede obtener acceso por índice. Proporciona métodos para buscar, ordenar y manipular listas.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Collections.Generic.List%601> clase es el equivalente genérico de la <xref:System.Collections.ArrayList> clase. Implementa el <xref:System.Collections.Generic.IList%601> interfaz genérica utilizando una matriz cuyo tamaño aumenta dinámicamente cuando es necesario.  
  
 Puede agregar elementos a un <xref:System.Collections.Generic.List%601> utilizando el <xref:System.Collections.Generic.List%601.Add%2A> o <xref:System.Collections.Generic.List%601.AddRange%2A> métodos.  
  
 La <xref:System.Collections.Generic.List%601> clase usa un comparador de igualdad y un comparador de orden.  
  
-   Los métodos como <xref:System.Collections.Generic.List%601.Contains%2A>, <xref:System.Collections.Generic.List%601.IndexOf%2A>, <xref:System.Collections.Generic.List%601.LastIndexOf%2A>, y <xref:System.Collections.Generic.Dictionary%602.Remove%2A> utilizan un comparador de igualdad para los elementos de lista. El comparador de igualdad predeterminado para el tipo `T` se determina como sigue. Si tipo `T` implementa el <xref:System.IEquatable%601> interfaz genérica, el comparador de igualdad es el <xref:System.IEquatable%601.Equals%28%600%29> método de dicha interfaz; en caso contrario, es el comparador de igualdad predeterminado <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType>.  
  
-   Los métodos como <xref:System.Collections.Generic.List%601.BinarySearch%2A> y <xref:System.Collections.Generic.List%601.Sort%2A> utilizan un comparador de ordenación para los elementos de lista. El comparador predeterminado para el tipo `T` se determina como sigue.  Si tipo `T` implementa el <xref:System.IComparable%601> interfaz genérica, el comparador predeterminado es el <xref:System.IComparable%601.CompareTo%28%600%29> método de dicha interfaz; de lo contrario, si tipo `T` implementa la interfaz no genérica <xref:System.IComparable> interfaz y, a continuación, el valor predeterminado comparador es el <xref:System.IComparable.CompareTo%28System.Object%29> método de dicha interfaz. Si tipo `T` no implementa ninguna interfaz, entonces no hay ningún comparador predeterminado y se debe proporcionar explícitamente un delegado de comparación o comparador.  
  
 El <xref:System.Collections.Generic.List%601> no se garantiza que se va a ordenar.  Se debe ordenar el <xref:System.Collections.Generic.List%601> antes de realizar operaciones (como <xref:System.Collections.Generic.List%601.BinarySearch%2A>) que requieren el <xref:System.Collections.Generic.List%601> esté ordenada.  
  
 Elementos de esta colección se pueden acceder mediante un índice entero.  Los índices de esta colección son de base cero.  
  
 **Solo para .NET framework:** Para gran <xref:System.Collections.Generic.List%601> objetos, puede aumentar la capacidad máxima de 2 millones de elementos en un sistema de 64 bits mediante el establecimiento la `enabled` atributo de la [ `<gcAllowVeryLargeObjects>` ](~/docs/framework/configure-apps/file-schema/runtime/gcallowverylargeobjects-element.md) elemento de configuración a `true` en el entorno de tiempo de ejecución.  
  
 <xref:System.Collections.Generic.List%601> acepta `null` como un valor válido para la referencia de tipos y permite elementos duplicados.  
  
 Para obtener una versión inmutable de la <xref:System.Collections.Generic.List%601> de clases, vea <xref:System.Collections.Immutable.ImmutableList%601>.  
  
## <a name="performance-considerations"></a>Consideraciones sobre el rendimiento  
 Hora de decidir si se debe usar el <xref:System.Collections.Generic.List%601> o <xref:System.Collections.ArrayList> (clase), los cuales tienen una funcionalidad similar, recuerde que el <xref:System.Collections.Generic.List%601> clase funcione mejor en la mayoría de los casos y tiene seguridad de tipos. Si se usa un tipo de referencia de tipo `T` de la <xref:System.Collections.Generic.List%601> (clase), el comportamiento de las dos clases es idéntico. Sin embargo, si se usa un tipo de valor de tipo `T`, deberá tener en cuenta los problemas de implementación y la conversión boxing.  
  
 Si se usa un tipo de valor de tipo `T`, el compilador genera una implementación de la <xref:System.Collections.Generic.List%601> clase específicamente para ese tipo de valor. Esto significa que un elemento de lista de un <xref:System.Collections.Generic.List%601> objeto no tiene que realizar la conversión boxing antes de que se puede usar el elemento y, después de unos 500 elementos de lista se crean la memoria que se guarda no conversión boxing de los elementos de lista es mayor que la memoria utilizada para generar la implementación de la clase.  
  
 Compruebe el tipo de valor utilizado para el tipo `T` implementa el <xref:System.IEquatable%601> interfaz genérica. Si no, los métodos como <xref:System.Collections.Generic.List%601.Contains%2A> debe llamar a la <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> método, que los cuadros del elemento de lista afectado. Si el tipo de valor implementa la <xref:System.IComparable> interfaz y posee el código fuente, también se implementan el <xref:System.IComparable%601> interfaz genérica para evitar que el <xref:System.Collections.Generic.List%601.BinarySearch%2A> y <xref:System.Collections.Generic.List%601.Sort%2A> métodos de conversión boxing de los elementos de lista. Si no dispone del código fuente, pasar un <xref:System.Collections.Generic.IComparer%601> de objeto para el <xref:System.Collections.Generic.List%601.BinarySearch%2A> y <xref:System.Collections.Generic.List%601.Sort%2A> métodos  
  
 Es la ventaja de usar la implementación específica del tipo de la <xref:System.Collections.Generic.List%601> clase en lugar de usar el <xref:System.Collections.ArrayList> clase o la escritura de una colección de contenedor fuertemente tipado usted mismo. El motivo es su implementación debe hacer lo que .NET Framework ya hace por usted, y common language runtime puede compartir código de lenguaje intermedio de Microsoft y los metadatos, que no puede ser de su implementación.  
  
## <a name="f-considerations"></a>F#Consideraciones  
 El <xref:System.Collections.Generic.List%601> clase se usa con poca frecuencia en F# código. En su lugar, [enumera](https://msdn.microsoft.com/library/83102799-f251-42e1-93ef-64232e8c5b1d), que son listas inmutables vinculadas individualmente, son normalmente preferido. Un F# lista proporciona una serie ordenada e inmutable de valores y se puede usar en el desarrollo de estilo funcional. Cuando se utiliza desde F#, el <xref:System.Collections.Generic.List%601> clase normalmente se conoce por el [ResizeArray\<' t >](https://msdn.microsoft.com/library/ee353447.aspx) escriba abreviatura para evitar conflictos de nomenclatura con F# listas  
  
   
  
## Examples  
 En el ejemplo siguiente se muestra cómo agregar, quitar e insertar un objeto comercial simple en un <xref:System.Collections.Generic.List%601>.  
  
 [!code-csharp[System.Collections.Generic.List.AddRemoveInsert#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.collections.generic.list.addremoveinsert/cs/program.cs#1)]
 [!code-vb[System.Collections.Generic.List.AddRemoveInsert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.collections.generic.list.addremoveinsert/vb/module1.vb#1)]  
 [!code-fsharp[System.Collections.Generic.List.AddRemoveInsert#1](~/samples/snippets/fsharp/VS_Snippets_CLR_System/system.collections.generic.list.addremoveinsert/fs/addremoveinsert.fs#1)]
  
 El ejemplo siguiente muestra varias propiedades y métodos de la <xref:System.Collections.Generic.List%601> clase genérica de tipo cadena. (Para obtener un ejemplo de un <xref:System.Collections.Generic.List%601> de tipos complejos, vea el <xref:System.Collections.Generic.List%601.Contains%2A> método.)  
  
 El constructor predeterminado se usa para crear una lista de cadenas con la capacidad predeterminada. El <xref:System.Collections.Generic.List%601.Capacity%2A> se muestra la propiedad y, a continuación, el <xref:System.Collections.Generic.List%601.Add%2A> método se utiliza para agregar varios elementos. Se muestran los elementos y el <xref:System.Collections.Generic.List%601.Capacity%2A> propiedad se muestra de nuevo, junto con el <xref:System.Collections.Generic.List%601.Count%2A> propiedad para mostrar que ha aumentado la capacidad según sea necesario.  
  
 El <xref:System.Collections.Generic.List%601.Contains%2A> método se utiliza para comprobar la presencia de un elemento en la lista, el <xref:System.Collections.Generic.List%601.Insert%2A> método se utiliza para insertar un nuevo elemento en el medio de la lista y se volverá a mostrar el contenido de la lista.  
  
 El valor predeterminado <xref:System.Collections.Generic.List%601.Item%2A> propiedad (el indizador en C#) se usa para recuperar un elemento, el <xref:System.Collections.Generic.List%601.Remove%2A> método se usa para quitar la primera instancia del elemento duplicado agregado anteriormente y se volverá a mostrar el contenido. El <xref:System.Collections.Generic.List%601.Remove%2A> método siempre quita la primera instancia que encuentra.  
  
 El <xref:System.Collections.Generic.List%601.TrimExcess%2A> método se usa para reducir la capacidad para que coincida con el recuento y el <xref:System.Collections.Generic.List%601.Capacity%2A> y <xref:System.Collections.Generic.List%601.Count%2A> se muestran las propiedades. Si la capacidad no utilizada hubiera sido inferior a 10 por ciento de la capacidad total, la lista no habría tamaño ha cambiado.  
  
 Por último, el <xref:System.Collections.Generic.List%601.Clear%2A> método se usa para quitar todos los elementos de la lista y el <xref:System.Collections.Generic.List%601.Capacity%2A> y <xref:System.Collections.Generic.List%601.Count%2A> se muestran las propiedades.  
  
 [!code-cpp[List\`1_Class#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_Class/cpp/source.cpp#1)]
 [!code-csharp[List\`1_Class#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_Class/cs/source.cs#1)]
 [!code-vb[List\`1_Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_Class/vb/source.vb#1)]  
 [!code-fsharp[List\`1_Class#1](~/samples/snippets/fsharp/VS_Snippets_CLR/List`1_Class/fs/listclass.fs#1)]
  
 ]]></format>
    </remarks>
    <threadsafe>Estáticos públicos (<see langword="Shared" /> en Visual Basic) los miembros de este tipo son seguros para subprocesos. No se garantiza que los miembros de instancias sean seguros para la ejecución de subprocesos.  
  
Es seguro realizar varias operaciones de lectura en un <see cref="T:System.Collections.Generic.List`1" />, pero pueden producirse problemas si se modifica la colección mientras se está leyendo. Para garantizar la seguridad para subprocesos, bloquear la colección durante una lectura o la operación de escritura. Para habilitar una colección tener acceso varios subprocesos para leer y escribir, debe implementar su propia sincronización. Para las colecciones con sincronización integrada, vea las clases en el <see cref="N:System.Collections.Concurrent" /> espacio de nombres. Para conocer una alternativa intrínsecamente seguras para subprocesos, vea el <see cref="T:System.Collections.Immutable.ImmutableList`1" /> clase.</threadsafe>
    <altmember cref="T:System.Collections.IList" />
    <altmember cref="T:System.Collections.Immutable.ImmutableList`1" />
    <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-collections.md">Realizar operaciones de cadenas que no tienen en cuenta las referencias culturales en colecciones</related>
    <related type="Article" href="https://msdn.microsoft.com/library/f45331db-d595-46ec-9142-551d3d1eb1a7">Iteradores (C# y Visual Basic)</related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Collections.Generic.List`1" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public List ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; List();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Collections.Generic.List`1" /> que está vacía y tiene la capacidad inicial predeterminada.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La capacidad de un <xref:System.Collections.Generic.List%601> es el número de elementos que la <xref:System.Collections.Generic.List%601> puede contener. Cuando se agregan elementos a un <xref:System.Collections.Generic.List%601>, automáticamente se aumenta la capacidad según sea necesario mediante la reasignación de la matriz interna.  
  
 Si se puede estimar el tamaño de la colección, utilizando el <xref:System.Collections.Generic.List%601.%23ctor%28System.Int32%29> constructor y especificar la capacidad inicial elimina la necesidad de realizar una serie de operaciones de cambio de tamaño al agregar elementos a la <xref:System.Collections.Generic.List%601>.  
  
 La capacidad puede reducirse mediante una llamada a la <xref:System.Collections.Generic.List%601.TrimExcess%2A> método o estableciendo la <xref:System.Collections.Generic.List%601.Capacity%2A> propiedad explícitamente. Al disminuir la capacidad se reasigna memoria y copia todos los elementos en el <xref:System.Collections.Generic.List%601>.  
  
 Este constructor es una operación o (1).  
  
   
  
## Examples  
 En el ejemplo siguiente se muestra el constructor predeterminado de la <xref:System.Collections.Generic.List%601> clase genérica. El constructor predeterminado crea una lista con la capacidad predeterminada, como se muestra al mostrar el <xref:System.Collections.Generic.List%601.Capacity%2A> propiedad.  
  
 El ejemplo se agrega, se inserta y quita elementos, que muestra cómo cambia la capacidad ya que estos métodos se usan.  
  
 [!code-cpp[List\`1_Class#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_Class/cpp/source.cpp#1)]
 [!code-csharp[List\`1_Class#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_Class/cs/source.cs#1)]
 [!code-vb[List\`1_Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_Class/vb/source.vb#1)]  
 [!code-fsharp[List\`1_Class#1](~/samples/snippets/fsharp/VS_Snippets_CLR/List`1_Class/fs/listclass.fs#1)]
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public List (System.Collections.Generic.IEnumerable&lt;T&gt; collection);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Collections.Generic.IEnumerable`1&lt;!T&gt; collection) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.#ctor(System.Collections.Generic.IEnumerable{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (collection As IEnumerable(Of T))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; List(System::Collections::Generic::IEnumerable&lt;T&gt; ^ collection);" />
      <MemberSignature Language="F#" Value="new System.Collections.Generic.List&lt;'T&gt; : seq&lt;'T&gt; -&gt; System.Collections.Generic.List&lt;'T&gt;" Usage="new System.Collections.Generic.List&lt;'T&gt; collection" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="collection" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="collection">Colección cuyos elementos se copian en la nueva lista.</param>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Collections.Generic.List`1" /> que contiene elementos copiados de la colección especificada y tiene una capacidad suficiente para aceptar el número de elementos copiados.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Los elementos se copian en el <xref:System.Collections.Generic.List%601> en el mismo orden que se leen el enumerador de la colección.  
  
 Este constructor es O (*n*) operación, donde *n* es el número de elementos de `collection`.  
  
   
  
## Examples  
 En el ejemplo siguiente se muestra el <xref:System.Collections.Generic.List%601.%23ctor%2A> constructor y varios métodos de la <xref:System.Collections.Generic.List%601> clases que actúan en intervalos. Una matriz de cadenas se crea y se pasa al constructor, rellenar la lista con los elementos de la matriz. El <xref:System.Collections.Generic.List%601.Capacity%2A> , a continuación, se muestra la propiedad, para mostrar que la capacidad inicial es exactamente lo que se necesita para contener los elementos de entrada.  
  
 [!code-cpp[List\`1_Ranges#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_Ranges/cpp/source.cpp#1)]
 [!code-csharp[List\`1_Ranges#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_Ranges/cs/source.cs#1)]
 [!code-vb[List\`1_Ranges#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_Ranges/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="collection" /> es <see langword="null" />.</exception>
        <altmember cref="T:System.Collections.Generic.IEnumerable`1" />
        <altmember cref="P:System.Collections.Generic.List`1.Capacity" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public List (int capacity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 capacity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.#ctor(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (capacity As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; List(int capacity);" />
      <MemberSignature Language="F#" Value="new System.Collections.Generic.List&lt;'T&gt; : int -&gt; System.Collections.Generic.List&lt;'T&gt;" Usage="new System.Collections.Generic.List&lt;'T&gt; capacity" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="capacity" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="capacity">Número de elementos que puede almacenar inicialmente la lista nueva.</param>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Collections.Generic.List`1" /> que está vacía y tiene la capacidad inicial especificada.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La capacidad de un <xref:System.Collections.Generic.List%601> es el número de elementos que la <xref:System.Collections.Generic.List%601> puede contener. Cuando se agregan elementos a un <xref:System.Collections.Generic.List%601>, automáticamente se aumenta la capacidad según sea necesario mediante la reasignación de la matriz interna.  
  
 Si se puede estimar el tamaño de la colección, al especificar la capacidad inicial elimina la necesidad de realizar una serie de operaciones de cambio de tamaño al agregar elementos a la <xref:System.Collections.Generic.List%601>.  
  
 La capacidad puede reducirse mediante una llamada a la <xref:System.Collections.Generic.List%601.TrimExcess%2A> método o estableciendo la <xref:System.Collections.Generic.List%601.Capacity%2A> propiedad explícitamente. Al disminuir la capacidad se reasigna memoria y copia todos los elementos en el <xref:System.Collections.Generic.List%601>.  
  
 Este constructor es O (*n*) operación, donde *n* es `capacity`.  
  
   
  
## Examples  
 En el ejemplo siguiente se muestra el <xref:System.Collections.Generic.List%601.%23ctor%28System.Int32%29> constructor. Un <xref:System.Collections.Generic.List%601> de cadenas con una capacidad de 4 se crea, ya que se conoce el tamaño final de la lista sea exactamente 4. La lista se rellena con cuatro cadenas, y se crea una copia de solo lectura mediante el uso de la <xref:System.Collections.Generic.List%601.AsReadOnly%2A> método.  
  
 [!code-cpp[List\`1_AsReadOnly#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_AsReadOnly/cpp/source.cpp#1)]
 [!code-csharp[List\`1_AsReadOnly#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_AsReadOnly/cs/source.cs#1)]
 [!code-vb[List\`1_AsReadOnly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_AsReadOnly/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="capacity" /> es menor que 0.</exception>
        <altmember cref="P:System.Collections.Generic.List`1.Capacity" />
      </Docs>
    </Member>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public void Add (T item);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Add(!T item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.Add(`0)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Add (item As T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Add(T item);" />
      <MemberSignature Language="F#" Value="abstract member Add : 'T -&gt; unit&#xA;override this.Add : 'T -&gt; unit" Usage="list.Add item" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.ICollection`1.Add(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="T" />
      </Parameters>
      <Docs>
        <param name="item">Objeto que se va a agregar al final de <see cref="T:System.Collections.Generic.List`1" />. El valor puede ser <see langword="null" /> para los tipos de referencia.</param>
        <summary>Agrega un objeto al final de <see cref="T:System.Collections.Generic.List`1" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.Generic.List%601> acepta `null` como un valor válido para la referencia de tipos y permite elementos duplicados.  
  
 Si <xref:System.Collections.Generic.List%601.Count%2A> ya es igual a <xref:System.Collections.Generic.List%601.Capacity%2A>, la capacidad de la <xref:System.Collections.Generic.List%601> incrementando reasignación automática de la matriz interna, y se copian los elementos existentes en la nueva matriz antes de agrega el nuevo elemento.  
  
 Si <xref:System.Collections.Generic.List%601.Count%2A> es menor que <xref:System.Collections.Generic.List%601.Capacity%2A>, este método es una operación o (1). Si la capacidad debe aumentarse para alojar el nuevo elemento, este método se convierte en una O (*n*) operación, donde *n* es <xref:System.Collections.Generic.List%601.Count%2A>.  
  
   
  
## Examples  
 En el ejemplo siguiente se muestra cómo agregar, quitar e insertar un objeto comercial simple en un <xref:System.Collections.Generic.List%601>.  
  
 [!code-csharp[System.Collections.Generic.List.AddRemoveInsert#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.collections.generic.list.addremoveinsert/cs/program.cs#1)]
 [!code-vb[System.Collections.Generic.List.AddRemoveInsert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.collections.generic.list.addremoveinsert/vb/module1.vb#1)]  
 [!code-fsharp[System.Collections.Generic.List.AddRemoveInsert#1](~/samples/snippets/fsharp/VS_Snippets_CLR_System/system.collections.generic.list.addremoveinsert/fs/addremoveinsert.fs#1)]
  
 El ejemplo siguiente muestra varias propiedades y métodos de la <xref:System.Collections.Generic.List%601> clase genérica, incluido el <xref:System.Collections.Generic.List%601.Add%2A> método. El constructor predeterminado se utiliza para crear una lista de cadenas con una capacidad de 0. El <xref:System.Collections.Generic.List%601.Capacity%2A> se muestra la propiedad y, a continuación, el <xref:System.Collections.Generic.List%601.Add%2A> método se utiliza para agregar varios elementos. Se muestran los elementos y el <xref:System.Collections.Generic.List%601.Capacity%2A> propiedad se muestra de nuevo, junto con el <xref:System.Collections.Generic.List%601.Count%2A> propiedad para mostrar que ha aumentado la capacidad según sea necesario.  
  
 Otras propiedades y métodos se usan para buscar, insertar y quitar elementos de la lista y, finalmente, debe borrar la lista.  
  
 [!code-cpp[List\`1_Class#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_Class/cpp/source.cpp#1)]
 [!code-csharp[List\`1_Class#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_Class/cs/source.cs#1)]
 [!code-vb[List\`1_Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_Class/vb/source.vb#1)]  
 [!code-fsharp[List\`1_Class#1](~/samples/snippets/fsharp/VS_Snippets_CLR/List`1_Class/fs/listclass.fs#1)]
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Collections.Generic.List`1.AddRange(System.Collections.Generic.IEnumerable{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.Insert(System.Int32,`0)" />
        <altmember cref="M:System.Collections.Generic.List`1.Remove(`0)" />
        <altmember cref="P:System.Collections.Generic.List`1.Count" />
      </Docs>
    </Member>
    <Member MemberName="AddRange">
      <MemberSignature Language="C#" Value="public void AddRange (System.Collections.Generic.IEnumerable&lt;T&gt; collection);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddRange(class System.Collections.Generic.IEnumerable`1&lt;!T&gt; collection) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.AddRange(System.Collections.Generic.IEnumerable{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddRange (collection As IEnumerable(Of T))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddRange(System::Collections::Generic::IEnumerable&lt;T&gt; ^ collection);" />
      <MemberSignature Language="F#" Value="member this.AddRange : seq&lt;'T&gt; -&gt; unit" Usage="list.AddRange collection" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="collection" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="collection">Colección cuyos elementos deben agregarse al final de <see cref="T:System.Collections.Generic.List`1" />. La propia colección no puede ser <see langword="null" />, pero puede contener elementos que sean <see langword="null" /> si el tipo <paramref name="T" /> es un tipo de referencia.</param>
        <summary>Agrega los elementos de la colección especificada al final de <see cref="T:System.Collections.Generic.List`1" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se conserva el orden de los elementos de la colección en el <xref:System.Collections.Generic.List%601>.  
  
 Si el nuevo <xref:System.Collections.Generic.List%601.Count%2A> (actual <xref:System.Collections.Generic.List%601.Count%2A> más el tamaño de la colección) será mayor que <xref:System.Collections.Generic.List%601.Capacity%2A>, la capacidad de la <xref:System.Collections.Generic.List%601> incrementando reasignación automática de la matriz interna para dar cabida a los nuevos elementos y la los elementos existentes se copian en la nueva matriz antes de que se agregan los nuevos elementos.  
  
 Si el <xref:System.Collections.Generic.List%601> puede alojar los nuevos elementos sin aumentar la <xref:System.Collections.Generic.List%601.Capacity%2A>, este método es O (*n*) operación, donde *n* es el número de elementos que se agregarán. Si la capacidad debe aumentarse para alojar los nuevos elementos, este método se convierte en una O (*n* + *m*) operación, donde *n* es el número de elementos va a agregar y *m* es <xref:System.Collections.Generic.List%601.Count%2A>.  
  
   
  
## Examples  
 En el ejemplo siguiente se muestra el <xref:System.Collections.Generic.List%601.AddRange%2A> método y otros métodos de la <xref:System.Collections.Generic.List%601> clases que actúan en intervalos. Una matriz de cadenas se crea y se pasa al constructor, rellenar la lista con los elementos de la matriz. El <xref:System.Collections.Generic.List%601.AddRange%2A> método se llama, con la lista como argumento. El resultado es que los elementos de la lista actuales se agregan al final de la lista, duplicar todos los elementos.  
  
 [!code-cpp[List\`1_Ranges#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_Ranges/cpp/source.cpp#1)]
 [!code-csharp[List\`1_Ranges#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_Ranges/cs/source.cs#1)]
 [!code-vb[List\`1_Ranges#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_Ranges/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="collection" /> es <see langword="null" />.</exception>
        <altmember cref="T:System.Collections.Generic.IEnumerable`1" />
        <altmember cref="P:System.Collections.Generic.List`1.Capacity" />
        <altmember cref="P:System.Collections.Generic.List`1.Count" />
        <altmember cref="M:System.Collections.Generic.List`1.Add(`0)" />
        <altmember cref="M:System.Collections.Generic.List`1.InsertRange(System.Int32,System.Collections.Generic.IEnumerable{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.RemoveRange(System.Int32,System.Int32)" />
        <altmember cref="M:System.Collections.Generic.List`1.GetRange(System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="AsReadOnly">
      <MemberSignature Language="C#" Value="public System.Collections.ObjectModel.ReadOnlyCollection&lt;T&gt; AsReadOnly ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.ObjectModel.ReadOnlyCollection`1&lt;!T&gt; AsReadOnly() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.AsReadOnly" />
      <MemberSignature Language="VB.NET" Value="Public Function AsReadOnly () As ReadOnlyCollection(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::ObjectModel::ReadOnlyCollection&lt;T&gt; ^ AsReadOnly();" />
      <MemberSignature Language="F#" Value="member this.AsReadOnly : unit -&gt; System.Collections.ObjectModel.ReadOnlyCollection&lt;'T&gt;" Usage="list.AsReadOnly " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ObjectModel.ReadOnlyCollection&lt;T&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Devuelve un contenedor de <see cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" /> de solo lectura para la colección actual.</summary>
        <returns>Objeto que actúa como contenedor de solo lectura para la <see cref="T:System.Collections.Generic.List`1" /> actual.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para evitar modificaciones en el <xref:System.Collections.Generic.List%601> de objetos, se exponen solo a través de este contenedor. Un <xref:System.Collections.ObjectModel.ReadOnlyCollection%601> objeto no expone los métodos que modifican la colección. Sin embargo, si se realizan cambios subyacente <xref:System.Collections.Generic.List%601> objeto, la colección de solo lectura refleja estos cambios.  
  
 Este método es una operación o (1).  
  
   
  
## Examples  
 En el ejemplo siguiente se muestra el <xref:System.Collections.Generic.List%601.AsReadOnly%2A> método. Un <xref:System.Collections.Generic.List%601> de cadenas con una capacidad de 4 se crea, ya que se conoce el tamaño final de la lista sea exactamente 4. La lista se rellena con cuatro cadenas y el <xref:System.Collections.Generic.List%601.AsReadOnly%2A> método se utiliza para obtener sólo lectura <xref:System.Collections.Generic.IList%601> implementación de interfaz genérica que ajusta la lista original.  
  
 Un elemento de la lista original se establece en "Coelophysis" mediante la <xref:System.Collections.Generic.List%601.Item%2A> propiedad (el indizador en C#) y el contenido de la lista de solo lectura se volverá a mostrar para demostrar que es simplemente un contenedor para la lista original.  
  
 [!code-cpp[List\`1_AsReadOnly#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_AsReadOnly/cpp/source.cpp#1)]
 [!code-csharp[List\`1_AsReadOnly#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_AsReadOnly/cs/source.cs#1)]
 [!code-vb[List\`1_AsReadOnly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_AsReadOnly/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="BinarySearch">
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Utiliza un algoritmo de búsqueda binaria para localizar un elemento concreto en la <see cref="T:System.Collections.Generic.List`1" /> ordenada o en una parte de ella.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BinarySearch">
      <MemberSignature Language="C#" Value="public int BinarySearch (T item);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 BinarySearch(!T item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.BinarySearch(`0)" />
      <MemberSignature Language="VB.NET" Value="Public Function BinarySearch (item As T) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int BinarySearch(T item);" />
      <MemberSignature Language="F#" Value="member this.BinarySearch : 'T -&gt; int" Usage="list.BinarySearch item" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="T" />
      </Parameters>
      <Docs>
        <param name="item">Objeto que se va a buscar. El valor puede ser <see langword="null" /> para los tipos de referencia.</param>
        <summary>Busca la <see cref="T:System.Collections.Generic.List`1" /> completa ordenada para un elemento usando el comparador predeterminado y devuelve el índice de base cero del elemento.</summary>
        <returns>Índice de base cero de <paramref name="item" /> en la <see cref="T:System.Collections.Generic.List`1" /> ordenada, si es que se encuentra <paramref name="item" />; en caso contrario, número negativo que es el complemento bit a bit del índice del siguiente elemento mayor que <paramref name="item" /> o, si no hay ningún elemento mayor, el complemento bit a bit de <see cref="P:System.Collections.Generic.List`1.Count" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método utiliza el comparador predeterminado <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType> para el tipo `T` para determinar el orden de los elementos de lista. El <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType> propiedad comprueba si tipo `T` implementa el <xref:System.IComparable%601> interfaz genérica y utiliza esa implementación, si está disponible.  Si no es así, <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType> comprueba si tipo `T` implementa el <xref:System.IComparable> interfaz.  Si tipo `T` no implementa ninguna de estas interfaces, <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType> produce una <xref:System.InvalidOperationException>.  
  
 El <xref:System.Collections.Generic.List%601> ya debe estar ordenado según la implementación del comparador; de lo contrario, el resultado es incorrecto.  
  
 Comparar `null` con cualquier referencia de tipo está permitido y no genera una excepción cuando se usa el <xref:System.IComparable%601> interfaz genérica. Al ordenar, `null` se considera menor que cualquier otro objeto.  
  
 Si el <xref:System.Collections.Generic.List%601> contiene más de un elemento con el mismo valor, el método devuelve solo una de las apariciones y, puede devolver cualquiera de ellas, pero no necesariamente la primera de ellas.  
  
 Si el <xref:System.Collections.Generic.List%601> no contiene el valor especificado, el método devuelve un entero negativo. Puede aplicar la operación de complemento bit a bit (~) a este entero negativo para obtener el índice del primer elemento que es mayor que el valor de búsqueda. Cuando se inserta el valor en el <xref:System.Collections.Generic.List%601>, este índice se debe usar como punto de inserción para mantener el criterio de ordenación.  
  
 Este método es O (log *n*) operación, donde *n* es el número de elementos del intervalo.  
  
   
  
## Examples  
 En el ejemplo siguiente se muestra el <xref:System.Collections.Generic.List%601.Sort> sobrecarga del método y el <xref:System.Collections.Generic.List%601.BinarySearch%28%600%29> sobrecarga del método. Un <xref:System.Collections.Generic.List%601> de cadenas se crean y rellenan con cuatro cadenas, sin ningún orden determinado. La lista se muestran, ordenan y volverá a mostrar.  
  
 El <xref:System.Collections.Generic.List%601.BinarySearch%28%600%29> sobrecarga del método, a continuación, se usa para buscar dos cadenas que no están en la lista, y el <xref:System.Collections.Generic.List%601.Insert%2A> método se utiliza para insertarlos. El valor devuelto de la <xref:System.Collections.Generic.List%601.BinarySearch%28%600%29> método es negativo en cada caso, porque las cadenas no están en la lista. Tomando el complemento bit a bit (el ~ operador en C# y Visual C++, `Xor` -1 en Visual Basic) de este número negativo se produce el índice del primer elemento en la lista que es mayor que la cadena de búsqueda e inserción en esta ubicación conserva la ordenación orden. La segunda cadena de búsqueda es mayor que cualquier elemento en la lista, por lo que es la posición de inserción al final de la lista.  
  
 [!code-cpp[List\`1_SortSearch#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_SortSearch/cpp/source.cpp#1)]
 [!code-csharp[List\`1_SortSearch#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_SortSearch/cs/source.cs#1)]
 [!code-vb[List\`1_SortSearch#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_SortSearch/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">El comparador predeterminado <see cref="P:System.Collections.Generic.Comparer`1.Default" /> no puede encontrar una implementación de la interfaz genérica <see cref="T:System.IComparable`1" /> o la interfaz <see cref="T:System.IComparable" /> del tipo <paramref name="T" />.</exception>
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-collections.md">Realizar operaciones de cadenas que no tienen en cuenta las referencias culturales en colecciones</related>
      </Docs>
    </Member>
    <Member MemberName="BinarySearch">
      <MemberSignature Language="C#" Value="public int BinarySearch (T item, System.Collections.Generic.IComparer&lt;T&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 BinarySearch(!T item, class System.Collections.Generic.IComparer`1&lt;!T&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.BinarySearch(`0,System.Collections.Generic.IComparer{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Function BinarySearch (item As T, comparer As IComparer(Of T)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int BinarySearch(T item, System::Collections::Generic::IComparer&lt;T&gt; ^ comparer);" />
      <MemberSignature Language="F#" Value="member this.BinarySearch : 'T * System.Collections.Generic.IComparer&lt;'T&gt; -&gt; int" Usage="list.BinarySearch (item, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="T" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IComparer&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="item">Objeto que se va a buscar. El valor puede ser <see langword="null" /> para los tipos de referencia.</param>
        <param name="comparer">Implementación de <see cref="T:System.Collections.Generic.IComparer`1" /> que se va a usar al comparar elementos.  
  
O bien 
 <see langword="null" /> para utilizar el comparador predeterminado <see cref="P:System.Collections.Generic.Comparer`1.Default" />.</param>
        <summary>Busca la <see cref="T:System.Collections.Generic.List`1" /> completa ordenada para un elemento usando el comparador especificado y devuelve el índice de base cero del elemento.</summary>
        <returns>Índice de base cero de <paramref name="item" /> en la <see cref="T:System.Collections.Generic.List`1" /> ordenada, si es que se encuentra <paramref name="item" />; en caso contrario, número negativo que es el complemento bit a bit del índice del siguiente elemento mayor que <paramref name="item" /> o, si no hay ningún elemento mayor, el complemento bit a bit de <see cref="P:System.Collections.Generic.List`1.Count" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El comparador personaliza cómo se comparan los elementos. Por ejemplo, puede usar un <xref:System.Collections.CaseInsensitiveComparer> instancia como comparador para realizar búsquedas de cadenas entre mayúsculas y minúsculas.  
  
 Si `comparer` se proporciona, los elementos de la <xref:System.Collections.Generic.List%601> se comparan con el valor especificado mediante especificado <xref:System.Collections.Generic.IComparer%601> implementación.  
  
 Si `comparer` es `null`, el comparador predeterminado <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType> comprueba si tipo `T` implementa el <xref:System.IComparable%601> interfaz genérica y utiliza esa implementación, si está disponible.  Si no es así, <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType> comprueba si tipo `T` implementa el <xref:System.IComparable> interfaz.  Si tipo `T` no implementa ninguna de estas interfaces, <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType> produce <xref:System.InvalidOperationException>.  
  
 El <xref:System.Collections.Generic.List%601> ya debe estar ordenado según la implementación del comparador; de lo contrario, el resultado es incorrecto.  
  
 Comparar `null` con cualquier referencia de tipo está permitido y no genera una excepción cuando se usa el <xref:System.IComparable%601> interfaz genérica. Al ordenar, `null` se considera menor que cualquier otro objeto.  
  
 Si el <xref:System.Collections.Generic.List%601> contiene más de un elemento con el mismo valor, el método devuelve solo una de las apariciones y, puede devolver cualquiera de ellas, pero no necesariamente la primera de ellas.  
  
 Si el <xref:System.Collections.Generic.List%601> no contiene el valor especificado, el método devuelve un entero negativo. Puede aplicar la operación de complemento bit a bit (~) a este entero negativo para obtener el índice del primer elemento que es mayor que el valor de búsqueda. Cuando se inserta el valor en el <xref:System.Collections.Generic.List%601>, este índice se debe usar como punto de inserción para mantener el criterio de ordenación.  
  
 Este método es O (log *n*) operación, donde *n* es el número de elementos del intervalo.  
  
   
  
## Examples  
 En el ejemplo siguiente se muestra el <xref:System.Collections.Generic.List%601.Sort%28System.Collections.Generic.IComparer%7B%600%7D%29> sobrecarga del método y el <xref:System.Collections.Generic.List%601.BinarySearch%28%600%2CSystem.Collections.Generic.IComparer%7B%600%7D%29> sobrecarga del método.  
  
 El ejemplo define un comparador alternativo para las cadenas denominado DinoCompare, que implementa el `IComparer<string>` (`IComparer(Of String)` en Visual Basic, `IComparer<String^>` en Visual C++) interfaz genérica. El comparador funciona del siguiente modo: En primer lugar, se comprueba si la comparación `null`, y una referencia nula se considera menor que un valor no null. En segundo lugar, se comparan las longitudes de cadena, y se considera que la cadena más larga para que sea mayor. En tercer lugar, si las longitudes son iguales, se usa la comparación de cadenas normales.  
  
 Un <xref:System.Collections.Generic.List%601> de cadenas se crean y rellenan con cuatro cadenas, sin ningún orden determinado. Se muestra la lista, ordenada, utilizando al comparador alternativo y se muestran nuevamente.  
  
 El <xref:System.Collections.Generic.List%601.BinarySearch%28%600%2CSystem.Collections.Generic.IComparer%7B%600%7D%29> sobrecarga del método, a continuación, se usa para buscar varias cadenas que no en la lista, debe emplear el comparador alternativo. El <xref:System.Collections.Generic.List%601.Insert%2A> método se utiliza para insertar las cadenas. Estos dos métodos se encuentran en la función denominada `SearchAndInsert`, junto con el código para aprovechar el complemento bit a bit (el ~ operador en C# y Visual C++, `Xor` -1 en Visual Basic) del número negativo devuelto por <xref:System.Collections.Generic.List%601.BinarySearch%28%600%2CSystem.Collections.Generic.IComparer%7B%600%7D%29> y usarlo como un índice para Insertar la nueva cadena.  
  
 [!code-cpp[List\`1_SortSearchComparer#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_SortSearchComparer/cpp/source.cpp#1)]
 [!code-csharp[List\`1_SortSearchComparer#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_SortSearchComparer/cs/source.cs#1)]
 [!code-vb[List\`1_SortSearchComparer#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_SortSearchComparer/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><paramref name="comparer" /> es <see langword="null" />, y el comparador predeterminado <see cref="P:System.Collections.Generic.Comparer`1.Default" /> no puede encontrar una implementación de la interfaz genérica <see cref="T:System.IComparable`1" /> o la interfaz <see cref="T:System.IComparable" /> del tipo <paramref name="T" />.</exception>
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-collections.md">Realizar operaciones de cadenas que no tienen en cuenta las referencias culturales en colecciones</related>
      </Docs>
    </Member>
    <Member MemberName="BinarySearch">
      <MemberSignature Language="C#" Value="public int BinarySearch (int index, int count, T item, System.Collections.Generic.IComparer&lt;T&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 BinarySearch(int32 index, int32 count, !T item, class System.Collections.Generic.IComparer`1&lt;!T&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.BinarySearch(System.Int32,System.Int32,`0,System.Collections.Generic.IComparer{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Function BinarySearch (index As Integer, count As Integer, item As T, comparer As IComparer(Of T)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int BinarySearch(int index, int count, T item, System::Collections::Generic::IComparer&lt;T&gt; ^ comparer);" />
      <MemberSignature Language="F#" Value="member this.BinarySearch : int * int * 'T * System.Collections.Generic.IComparer&lt;'T&gt; -&gt; int" Usage="list.BinarySearch (index, count, item, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="item" Type="T" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IComparer&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="index">Índice inicial de base cero del intervalo que se va a buscar.</param>
        <param name="count">Longitud del intervalo en el que se va a buscar.</param>
        <param name="item">Objeto que se va a buscar. El valor puede ser <see langword="null" /> para los tipos de referencia.</param>
        <param name="comparer">Implementación de <see cref="T:System.Collections.Generic.IComparer`1" /> que se va a utilizar al comparar elementos, o <see langword="null" /> para utilizar el comparador predeterminado <see cref="P:System.Collections.Generic.Comparer`1.Default" />.</param>
        <summary>Busca un elemento en un intervalo de elementos del objeto <see cref="T:System.Collections.Generic.List`1" /> ordenado usando el comparador especificado y devuelve el índice de base cero del elemento.</summary>
        <returns>Índice de base cero de <paramref name="item" /> en la <see cref="T:System.Collections.Generic.List`1" /> ordenada, si es que se encuentra <paramref name="item" />; en caso contrario, número negativo que es el complemento bit a bit del índice del siguiente elemento mayor que <paramref name="item" /> o, si no hay ningún elemento mayor, el complemento bit a bit de <see cref="P:System.Collections.Generic.List`1.Count" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El comparador personaliza cómo se comparan los elementos. Por ejemplo, puede usar un <xref:System.Collections.CaseInsensitiveComparer> instancia como comparador para realizar búsquedas de cadenas entre mayúsculas y minúsculas.  
  
 Si `comparer` se proporciona, los elementos de la <xref:System.Collections.Generic.List%601> se comparan con el valor especificado mediante especificado <xref:System.Collections.Generic.IComparer%601> implementación.  
  
 Si `comparer` es `null`, el comparador predeterminado <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType> comprueba si tipo `T` implementa el <xref:System.IComparable%601> interfaz genérica y utiliza esa implementación, si está disponible.  Si no es así, <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType> comprueba si tipo `T` implementa el <xref:System.IComparable> interfaz.  Si tipo `T` no implementa ninguna de estas interfaces, <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType> produce <xref:System.InvalidOperationException>.  
  
 El <xref:System.Collections.Generic.List%601> ya debe estar ordenado según la implementación del comparador; de lo contrario, el resultado es incorrecto.  
  
 Comparar `null` con cualquier referencia de tipo está permitido y no genera una excepción cuando se usa el <xref:System.IComparable%601> interfaz genérica. Al ordenar, `null` se considera menor que cualquier otro objeto.  
  
 Si el <xref:System.Collections.Generic.List%601> contiene más de un elemento con el mismo valor, el método devuelve solo una de las apariciones y, puede devolver cualquiera de ellas, pero no necesariamente la primera de ellas.  
  
 Si el <xref:System.Collections.Generic.List%601> no contiene el valor especificado, el método devuelve un entero negativo. Puede aplicar la operación de complemento bit a bit (~) a este entero negativo para obtener el índice del primer elemento que es mayor que el valor de búsqueda. Cuando se inserta el valor en el <xref:System.Collections.Generic.List%601>, este índice se debe usar como punto de inserción para mantener el criterio de ordenación.  
  
 Este método es O (log *n*) operación, donde *n* es el número de elementos del intervalo.  
  
   
  
## Examples  
 En el ejemplo siguiente se muestra el <xref:System.Collections.Generic.List%601.Sort%28System.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%600%7D%29> sobrecarga del método y el <xref:System.Collections.Generic.List%601.BinarySearch%28System.Int32%2CSystem.Int32%2C%600%2CSystem.Collections.Generic.IComparer%7B%600%7D%29> sobrecarga del método.  
  
 El ejemplo define un comparador alternativo para las cadenas denominado DinoCompare, que implementa el `IComparer<string>` (`IComparer(Of String)` en Visual Basic, `IComparer<String^>` en Visual C++) interfaz genérica. El comparador funciona del siguiente modo: En primer lugar, se comprueba si la comparación `null`, y una referencia nula se considera menor que un valor no null. En segundo lugar, se comparan las longitudes de cadena, y se considera que la cadena más larga para que sea mayor. En tercer lugar, si las longitudes son iguales, se usa la comparación de cadenas normales.  
  
 Un <xref:System.Collections.Generic.List%601> de cadenas se crean y rellenan con los nombres de cinco dinosaurios herbívoros y tres dinosaurios carnívoros. Dentro de cada uno de los dos grupos, los nombres no están en ningún orden determinado. Se muestra la lista, el intervalo de herbívoros se ordena usando al comparador alternativo y volverá a aparecer la lista.  
  
 El <xref:System.Collections.Generic.List%601.BinarySearch%28System.Int32%2CSystem.Int32%2C%600%2CSystem.Collections.Generic.IComparer%7B%600%7D%29> sobrecarga del método, a continuación, se usa para buscar solo en el intervalo de herbívoros "Brachiosaurus". No se encuentra la cadena y el complemento bit a bit (el ~ operador en C# y Visual C++, `Xor` -1 en Visual Basic) del número negativo devuelto por la <xref:System.Collections.Generic.List%601.BinarySearch%28System.Int32%2CSystem.Int32%2C%600%2CSystem.Collections.Generic.IComparer%7B%600%7D%29> método se usa como índice para insertar la nueva cadena.  
  
 [!code-cpp[List\`1_SortSearchComparerRange#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_SortSearchComparerRange/cpp/source.cpp#1)]
 [!code-csharp[List\`1_SortSearchComparerRange#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_SortSearchComparerRange/cs/source.cs#1)]
 [!code-vb[List\`1_SortSearchComparerRange#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_SortSearchComparerRange/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> es menor que 0.  
  
O bien 
 <paramref name="count" /> es menor que 0.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="index" /> y <paramref name="count" /> no denotan un intervalo válido en <see cref="T:System.Collections.Generic.List`1" />.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="comparer" /> es <see langword="null" />, y el comparador predeterminado <see cref="P:System.Collections.Generic.Comparer`1.Default" /> no puede encontrar una implementación de la interfaz genérica <see cref="T:System.IComparable`1" /> o la interfaz <see cref="T:System.IComparable" /> del tipo <paramref name="T" />.</exception>
        <altmember cref="T:System.Collections.Generic.IComparer`1" />
        <altmember cref="T:System.IComparable`1" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-collections.md">Realizar operaciones de cadenas que no tienen en cuenta las referencias culturales en colecciones</related>
      </Docs>
    </Member>
    <Member MemberName="Capacity">
      <MemberSignature Language="C#" Value="public int Capacity { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Capacity" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.List`1.Capacity" />
      <MemberSignature Language="VB.NET" Value="Public Property Capacity As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Capacity { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.Capacity : int with get, set" Usage="System.Collections.Generic.List&lt;'T&gt;.Capacity" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece el número total de elementos que puede contener la estructura de datos interna sin cambiar el tamaño.</summary>
        <value>Número de elementos que puede contener <see cref="T:System.Collections.Generic.List`1" /> antes de que sea necesario cambiar el tamaño.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.Generic.List%601.Capacity%2A> es el número de elementos que la <xref:System.Collections.Generic.List%601> puede almacenar antes de cambiar el tamaño es necesario, mientras que <xref:System.Collections.Generic.List%601.Count%2A> es el número de elementos que son en realidad el <xref:System.Collections.Generic.List%601>.  
  
 <xref:System.Collections.Generic.List%601.Capacity%2A> es siempre mayor o igual que <xref:System.Collections.Generic.List%601.Count%2A>. Si <xref:System.Collections.Generic.List%601.Count%2A> supera <xref:System.Collections.Generic.List%601.Capacity%2A> al agregar elementos, se aumenta la capacidad mediante la reasignación automática de la matriz interna antes de copiar los elementos antiguos y agregar los nuevos elementos.  
  
 Si la capacidad es significativamente mayor que el recuento y desea reducir la memoria utilizada por el <xref:System.Collections.Generic.List%601>, puede disminuir la capacidad mediante una llamada a la <xref:System.Collections.Generic.List%601.TrimExcess%2A> método o estableciendo la <xref:System.Collections.Generic.List%601.Capacity%2A> propiedad explícitamente en un valor inferior. Cuando el valor de <xref:System.Collections.Generic.List%601.Capacity%2A> se establece explícitamente, la matriz interna se reasigna para dar cabida a la capacidad especificada y se copian todos los elementos.  
  
 Recuperar el valor de esta propiedad es una operación o (1); establecer la propiedad es O (*n*) operación, donde *n* es la nueva capacidad.  
  
   
  
## Examples  
 En el ejemplo siguiente se muestra cómo comprobar la capacidad y el recuento de un <xref:System.Collections.Generic.List%601> que contiene un objeto comercial simple y se muestra cómo utilizar el <xref:System.Collections.Generic.List%601.TrimExcess%2A> método para quitar la capacidad adicional.  
  
 [!code-csharp[System.Collections.Generic.List.CapacityCount#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.collections.generic.list.capacitycount/cs/program.cs#1)]
 [!code-vb[System.Collections.Generic.List.CapacityCount#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.collections.generic.list.capacitycount/vb/module1.vb#1)]  
  
 El ejemplo siguiente se muestra el <xref:System.Collections.Generic.List%601.Capacity%2A> propiedad en varios puntos en la vida de una lista. El constructor predeterminado se usa para crear una lista de cadenas con una capacidad de 0 y el <xref:System.Collections.Generic.List%601.Capacity%2A> propiedad se muestra para demostrar esto. Después de la <xref:System.Collections.Generic.List%601.Add%2A> se ha usado el método para agregar varios elementos, se muestran los elementos y, a continuación, el <xref:System.Collections.Generic.List%601.Capacity%2A> propiedad se muestra de nuevo, junto con el <xref:System.Collections.Generic.List%601.Count%2A> propiedad para mostrar que ha aumentado la capacidad según sea necesario.  
  
 El <xref:System.Collections.Generic.List%601.Capacity%2A> propiedad se muestra después de volver a la <xref:System.Collections.Generic.List%601.TrimExcess%2A> método se usa para reducir la capacidad para que coincida con el recuento. Por último, el <xref:System.Collections.Generic.List%601.Clear%2A> método se usa para quitar todos los elementos de la lista y el <xref:System.Collections.Generic.List%601.Capacity%2A> y <xref:System.Collections.Generic.List%601.Count%2A> se muestran las propiedades de nuevo.  
  
 [!code-cpp[List\`1_Class#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_Class/cpp/source.cpp#1)]
 [!code-csharp[List\`1_Class#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_Class/cs/source.cs#1)]
 [!code-vb[List\`1_Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_Class/vb/source.vb#1)]  
 [!code-fsharp[List\`1_Class#1](~/samples/snippets/fsharp/VS_Snippets_CLR/List`1_Class/fs/listclass.fs#1)]
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><see cref="P:System.Collections.Generic.List`1.Capacity" /> se establece en un valor que es menor que <see cref="P:System.Collections.Generic.List`1.Count" />.</exception>
        <exception cref="T:System.OutOfMemoryException">No hay memoria suficiente en el sistema.</exception>
        <altmember cref="P:System.Collections.Generic.List`1.Count" />
      </Docs>
    </Member>
    <Member MemberName="Clear">
      <MemberSignature Language="C#" Value="public void Clear ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Clear() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.Clear" />
      <MemberSignature Language="VB.NET" Value="Public Sub Clear ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Clear();" />
      <MemberSignature Language="F#" Value="abstract member Clear : unit -&gt; unit&#xA;override this.Clear : unit -&gt; unit" Usage="list.Clear " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IList.Clear</InterfaceMember>
        <InterfaceMember>M:System.Collections.Generic.ICollection`1.Clear</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Quita todos los elementos de <see cref="T:System.Collections.Generic.List`1" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.Generic.List%601.Count%2A> se establece en 0, y también se liberan las referencias a otros objetos de elementos de la colección.  
  
 <xref:System.Collections.Generic.List%601.Capacity%2A> permanece sin cambios. Para restablecer la capacidad de la <xref:System.Collections.Generic.List%601>, llame a la <xref:System.Collections.Generic.List%601.TrimExcess%2A> método o un conjunto el <xref:System.Collections.Generic.List%601.Capacity%2A> propiedad directamente. Al disminuir la capacidad se reasigna memoria y copia todos los elementos en el <xref:System.Collections.Generic.List%601>. Recorte vacío <xref:System.Collections.Generic.List%601> establece la capacidad de la <xref:System.Collections.Generic.List%601> a la capacidad predeterminada.  
  
 Este método es O (*n*) operación, donde *n* es <xref:System.Collections.Generic.List%601.Count%2A>.  
  
   
  
## Examples  
 En el ejemplo siguiente se muestra el <xref:System.Collections.Generic.List%601.Clear%2A> método y varias otras propiedades y métodos de la <xref:System.Collections.Generic.List%601> clase genérica. El <xref:System.Collections.Generic.List%601.Clear%2A> método se usa al final del programa, para quitar todos los elementos de la lista y el <xref:System.Collections.Generic.List%601.Capacity%2A> y <xref:System.Collections.Generic.List%601.Count%2A> , a continuación, se muestran las propiedades.  
  
 [!code-cpp[List\`1_Class#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_Class/cpp/source.cpp#1)]
 [!code-csharp[List\`1_Class#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_Class/cs/source.cs#1)]
 [!code-vb[List\`1_Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_Class/vb/source.vb#1)]  
 [!code-fsharp[List\`1_Class#1](~/samples/snippets/fsharp/VS_Snippets_CLR/List`1_Class/fs/listclass.fs#1)]
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Collections.Generic.List`1.TrimExcess" />
        <altmember cref="P:System.Collections.Generic.List`1.Capacity" />
        <altmember cref="P:System.Collections.Generic.List`1.Count" />
      </Docs>
    </Member>
    <Member MemberName="Contains">
      <MemberSignature Language="C#" Value="public bool Contains (T item);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Contains(!T item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.Contains(`0)" />
      <MemberSignature Language="VB.NET" Value="Public Function Contains (item As T) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Contains(T item);" />
      <MemberSignature Language="F#" Value="abstract member Contains : 'T -&gt; bool&#xA;override this.Contains : 'T -&gt; bool" Usage="list.Contains item" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.ICollection`1.Contains(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="T" />
      </Parameters>
      <Docs>
        <param name="item">Objeto que se va a buscar en <see cref="T:System.Collections.Generic.List`1" />. El valor puede ser <see langword="null" /> para los tipos de referencia.</param>
        <summary>Determina si un elemento se encuentra en <see cref="T:System.Collections.Generic.List`1" />.</summary>
        <returns><see langword="true" /> si <paramref name="item" /> se encuentra en la matriz <see cref="T:System.Collections.Generic.List`1" />; en caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método determina la igualdad utilizando el comparador de igualdad predeterminado, como se define en la implementación del objeto de la <xref:System.IEquatable%601.Equals%2A?displayProperty=nameWithType> método para `T` (el tipo de valores de la lista).  
  
 Este método realiza una búsqueda lineal; por lo tanto, este método es O (*n*) operación, donde *n* es <xref:System.Collections.Generic.List%601.Count%2A>.  
  
   
  
## Examples  
 En el ejemplo siguiente se muestra el <xref:System.Collections.Generic.List%601.Contains%2A> y <xref:System.Collections.Generic.List%601.Exists%2A> métodos en un <xref:System.Collections.Generic.List%601> que contiene un objeto comercial simple que implementa <xref:System.IEquatable%601.Equals%2A>.  
  
 [!code-csharp[System.Collections.Generic.List.ContainsExists#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.collections.generic.list.containsexists/cs/program.cs#1)]
 [!code-vb[System.Collections.Generic.List.ContainsExists#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.collections.generic.list.containsexists/vb/module1.vb#1)]  
  
 El ejemplo siguiente contiene una lista de objetos complejos del tipo `Cube`. El `Cube` la clase implementa la <xref:System.IEquatable%601.Equals%2A?displayProperty=nameWithType> método para que los dos cubos se consideran iguales si sus dimensiones son iguales. En este ejemplo, el <xref:System.Collections.Generic.List%601.Contains%2A> devuelve del método `true`, ya que un cubo que tiene las dimensiones especificadas ya está en la colección.  
  
 [!code-csharp[System.Collections.Generic.List.Contains#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.collections.generic.list.contains/cs/program.cs#1)]
 [!code-vb[System.Collections.Generic.List.Contains#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.collections.generic.list.contains/vb/program.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Collections.Generic.List`1.IndexOf(`0)" />
        <altmember cref="M:System.Collections.Generic.List`1.LastIndexOf(`0)" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-collections.md">Realizar operaciones de cadenas que no tienen en cuenta las referencias culturales en colecciones</related>
      </Docs>
    </Member>
    <Member MemberName="ConvertAll&lt;TOutput&gt;">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.List&lt;TOutput&gt; ConvertAll&lt;TOutput&gt; (Converter&lt;T,TOutput&gt; converter);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.List`1&lt;!!TOutput&gt; ConvertAll&lt;TOutput&gt;(class System.Converter`2&lt;!T, !!TOutput&gt; converter) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.ConvertAll``1(System.Converter{`0,``0})" />
      <MemberSignature Language="VB.NET" Value="Public Function ConvertAll(Of TOutput) (converter As Converter(Of T, TOutput)) As List(Of TOutput)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TOutput&gt;&#xA; System::Collections::Generic::List&lt;TOutput&gt; ^ ConvertAll(Converter&lt;T, TOutput&gt; ^ converter);" />
      <MemberSignature Language="F#" Value="member this.ConvertAll : Converter&lt;'T, 'Output&gt; -&gt; System.Collections.Generic.List&lt;'Output&gt;" Usage="list.ConvertAll converter" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.List&lt;TOutput&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TOutput" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="converter" Type="System.Converter&lt;T,TOutput&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TOutput">Tipo de los elementos de la matriz de destino.</typeparam>
        <param name="converter">Delegado <see cref="T:System.Converter`2" /> que convierte cada elemento de un tipo en otro tipo.</param>
        <summary>Convierte en otro tipo los elementos incluidos en la <see cref="T:System.Collections.Generic.List`1" /> actual y devuelve una lista que contiene los elementos convertidos.</summary>
        <returns><see cref="T:System.Collections.Generic.List`1" /> del tipo de destino que contiene los elementos convertidos de la <see cref="T:System.Collections.Generic.List`1" /> actual.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Converter%602> es un delegado a un método que convierte un objeto en el tipo de destino.  Los elementos del elemento actual <xref:System.Collections.Generic.List%601> individualmente se pasan a la <xref:System.Converter%602> delegado y los elementos convertidos se guardan en el nuevo <xref:System.Collections.Generic.List%601>.  
  
 Actual <xref:System.Collections.Generic.List%601> permanece sin cambios.  
  
 Este método es O (*n*) operación, donde *n* es <xref:System.Collections.Generic.List%601.Count%2A>.  
  
   
  
## Examples  
 En el ejemplo siguiente se define un método denominado `PointFToPoint` que convierte un <xref:System.Drawing.PointF> estructura a un <xref:System.Drawing.Point> estructura. El ejemplo, a continuación, se crea un <xref:System.Collections.Generic.List%601> de <xref:System.Drawing.PointF> estructuras, crea un `Converter\<PointF, Point>` delegar (`Converter(Of PointF, Point)` en Visual Basic) para representar el `PointFToPoint` método y pasa el delegado para el <xref:System.Collections.Generic.List%601.ConvertAll%2A> método. El <xref:System.Collections.Generic.List%601.ConvertAll%2A> método pasa cada elemento de la lista de entrada para el `PointFToPoint` método y coloca los elementos convertidos en una nueva lista de <xref:System.Drawing.Point> estructuras. Se muestran ambas listas.  
  
 [!code-cpp[List\`1_ConvertAll#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_ConvertAll/cpp/source.cpp#1)]
 [!code-csharp[List\`1_ConvertAll#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_ConvertAll/cs/source.cs#1)]
 [!code-vb[List\`1_ConvertAll#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_ConvertAll/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="converter" /> es <see langword="null" />.</exception>
        <altmember cref="T:System.Converter`2" />
      </Docs>
    </Member>
    <MemberGroup MemberName="CopyTo">
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Copia la totalidad de <see cref="T:System.Collections.Generic.List`1" /> o una parte en una matriz.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public void CopyTo (T[] array);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CopyTo(!T[] array) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.CopyTo(`0[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub CopyTo (array As T())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CopyTo(cli::array &lt;T&gt; ^ array);" />
      <MemberSignature Language="F#" Value="member this.CopyTo : 'T[] -&gt; unit" Usage="list.CopyTo array" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
      </Parameters>
      <Docs>
        <param name="array"><see cref="T:System.Array" /> unidimensional que constituye el destino de los elementos copiados de <see cref="T:System.Collections.Generic.List`1" />. <see cref="T:System.Array" /> debe tener una indización de base cero.</param>
        <summary>Copia toda la <see cref="T:System.Collections.Generic.List`1" /> en una matriz unidimensional compatible, empezando en el principio de la matriz de destino.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método usa <xref:System.Array.Copy%2A?displayProperty=nameWithType> para copiar los elementos.  
  
 Los elementos se copian en el <xref:System.Array> en el mismo orden en que el enumerador recorre el <xref:System.Collections.Generic.List%601>.  
  
 Este método es O (*n*) operación, donde *n* es <xref:System.Collections.Generic.List%601.Count%2A>.  
  
   
  
## Examples  
 El ejemplo siguiente muestra las tres sobrecargas de los <xref:System.Collections.Generic.List%601.CopyTo%2A> método. Un <xref:System.Collections.Generic.List%601> de cadenas se crean y rellenan con 5 cadenas. Se crea una matriz de cadena vacía de 15 elementos y el <xref:System.Collections.Generic.List%601.CopyTo%28%600%5B%5D%29> sobrecarga del método se usa para copiar todos los elementos de la lista en la matriz, empezando en el primer elemento de la matriz. El <xref:System.Collections.Generic.List%601.CopyTo%28%600%5B%5D%2CSystem.Int32%29> sobrecarga del método se usa para copiar todos los elementos de la lista en la matriz, empezando en el índice de matriz 6 (dejando vacío el índice 5). Por último, el <xref:System.Collections.Generic.List%601.CopyTo%28System.Int32%2C%600%5B%5D%2CSystem.Int32%2CSystem.Int32%29> sobrecarga del método se usa para copiar 3 elementos de la lista, empezando con el índice 2, en la matriz, empezando en la matriz de índice 12 (lo que deja vacío el índice 11). A continuación, se muestra el contenido de la matriz.  
  
 [!code-cpp[List\`1_CopyTo#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_CopyTo/cpp/source.cpp#1)]
 [!code-csharp[List\`1_CopyTo#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_CopyTo/cs/source.cs#1)]
 [!code-vb[List\`1_CopyTo#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_CopyTo/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">El número de elementos del <see cref="T:System.Collections.Generic.List`1" /> de origen es mayor que el número de elementos que puede contener el <paramref name="array" /> de destino.</exception>
      </Docs>
    </Member>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public void CopyTo (T[] array, int arrayIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void CopyTo(!T[] array, int32 arrayIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.CopyTo(`0[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub CopyTo (array As T(), arrayIndex As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void CopyTo(cli::array &lt;T&gt; ^ array, int arrayIndex);" />
      <MemberSignature Language="F#" Value="abstract member CopyTo : 'T[] * int -&gt; unit&#xA;override this.CopyTo : 'T[] * int -&gt; unit" Usage="list.CopyTo (array, arrayIndex)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.ICollection`1.CopyTo(`0[],System.Int32)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="arrayIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array"><see cref="T:System.Array" /> unidimensional que constituye el destino de los elementos copiados de <see cref="T:System.Collections.Generic.List`1" />. La matriz <see cref="T:System.Array" /> debe tener una indización de base cero.</param>
        <param name="arrayIndex">Índice de base cero en la <paramref name="array" /> donde comienza la copia.</param>
        <summary>Copia la totalidad de <see cref="T:System.Collections.Generic.List`1" /> en una matriz unidimensional compatible, empezando por el índice especificado de la matriz de destino.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método usa <xref:System.Array.Copy%2A?displayProperty=nameWithType> para copiar los elementos.  
  
 Los elementos se copian en el <xref:System.Array> en el mismo orden en que el enumerador recorre el <xref:System.Collections.Generic.List%601>.  
  
 Este método es O (*n*) operación, donde *n* es <xref:System.Collections.Generic.List%601.Count%2A>.  
  
   
  
## Examples  
 El ejemplo siguiente muestra las tres sobrecargas de los <xref:System.Collections.Generic.List%601.CopyTo%2A> método. Un <xref:System.Collections.Generic.List%601> de cadenas se crean y rellenan con 5 cadenas. Se crea una matriz de cadena vacía de 15 elementos y el <xref:System.Collections.Generic.List%601.CopyTo%28%600%5B%5D%29> sobrecarga del método se usa para copiar todos los elementos de la lista en la matriz, empezando en el primer elemento de la matriz. El <xref:System.Collections.Generic.List%601.CopyTo%28%600%5B%5D%2CSystem.Int32%29> sobrecarga del método se usa para copiar todos los elementos de la lista en la matriz, empezando en el índice de matriz 6 (dejando vacío el índice 5). Por último, el <xref:System.Collections.Generic.List%601.CopyTo%28System.Int32%2C%600%5B%5D%2CSystem.Int32%2CSystem.Int32%29> sobrecarga del método se usa para copiar 3 elementos de la lista, empezando con el índice 2, en la matriz, empezando en la matriz de índice 12 (lo que deja vacío el índice 11). A continuación, se muestra el contenido de la matriz.  
  
 [!code-cpp[List\`1_CopyTo#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_CopyTo/cpp/source.cpp#1)]
 [!code-csharp[List\`1_CopyTo#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_CopyTo/cs/source.cs#1)]
 [!code-vb[List\`1_CopyTo#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_CopyTo/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="arrayIndex" /> es menor que 0.</exception>
        <exception cref="T:System.ArgumentException">El número de elementos de la <see cref="T:System.Collections.Generic.List`1" /> de origen es mayor que el espacio disponible desde <paramref name="arrayIndex" /> hasta el final de la <paramref name="array" /> de destino.</exception>
      </Docs>
    </Member>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public void CopyTo (int index, T[] array, int arrayIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CopyTo(int32 index, !T[] array, int32 arrayIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.CopyTo(System.Int32,`0[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub CopyTo (index As Integer, array As T(), arrayIndex As Integer, count As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CopyTo(int index, cli::array &lt;T&gt; ^ array, int arrayIndex, int count);" />
      <MemberSignature Language="F#" Value="member this.CopyTo : int * 'T[] * int * int -&gt; unit" Usage="list.CopyTo (index, array, arrayIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="arrayIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">Índice de base cero de la <see cref="T:System.Collections.Generic.List`1" /> de origen donde comienza la copia.</param>
        <param name="array"><see cref="T:System.Array" /> unidimensional que constituye el destino de los elementos copiados de <see cref="T:System.Collections.Generic.List`1" />. La matriz <see cref="T:System.Array" /> debe tener una indización de base cero.</param>
        <param name="arrayIndex">Índice de base cero en la <paramref name="array" /> donde comienza la copia.</param>
        <param name="count">Número de elementos que se van a copiar.</param>
        <summary>Copia un intervalo de elementos de <see cref="T:System.Collections.Generic.List`1" /> en una matriz unidimensional compatible, empezando en el índice especificado de la matriz de destino.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método usa <xref:System.Array.Copy%2A?displayProperty=nameWithType> para copiar los elementos.  
  
 Los elementos se copian en el <xref:System.Array> en el mismo orden en que el enumerador recorre el <xref:System.Collections.Generic.List%601>.  
  
 Este método es O (*n*) operación, donde *n* es `count`.  
  
   
  
## Examples  
 El ejemplo siguiente muestra las tres sobrecargas de los <xref:System.Collections.Generic.List%601.CopyTo%2A> método. Un <xref:System.Collections.Generic.List%601> de cadenas se crean y rellenan con 5 cadenas. Se crea una matriz de cadena vacía de 15 elementos y el <xref:System.Collections.Generic.List%601.CopyTo%28%600%5B%5D%29> sobrecarga del método se usa para copiar todos los elementos de la lista en la matriz, empezando en el primer elemento de la matriz. El <xref:System.Collections.Generic.List%601.CopyTo%28%600%5B%5D%2CSystem.Int32%29> sobrecarga del método se usa para copiar todos los elementos de la lista en la matriz, empezando en el índice de matriz 6 (dejando vacío el índice 5). Por último, el <xref:System.Collections.Generic.List%601.CopyTo%28System.Int32%2C%600%5B%5D%2CSystem.Int32%2CSystem.Int32%29> sobrecarga del método se usa para copiar 3 elementos de la lista, empezando con el índice 2, en la matriz, empezando en la matriz de índice 12 (lo que deja vacío el índice 11). A continuación, se muestra el contenido de la matriz.  
  
 [!code-cpp[List\`1_CopyTo#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_CopyTo/cpp/source.cpp#1)]
 [!code-csharp[List\`1_CopyTo#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_CopyTo/cs/source.cs#1)]
 [!code-vb[List\`1_CopyTo#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_CopyTo/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> es menor que 0.  
  
O bien 
 <paramref name="arrayIndex" /> es menor que 0.  
  
O bien 
 <paramref name="count" /> es menor que 0.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="index" /> es igual o mayor que el valor de <see cref="P:System.Collections.Generic.List`1.Count" /> del elemento <see cref="T:System.Collections.Generic.List`1" /> de origen.  
  
O bien 
El número de elementos de <paramref name="index" /> hasta el final de <see cref="T:System.Collections.Generic.List`1" /> de origen es mayor que el espacio disponible desde <paramref name="arrayIndex" /> hasta el final de <paramref name="array" /> de destino.</exception>
      </Docs>
    </Member>
    <Member MemberName="Count">
      <MemberSignature Language="C#" Value="public int Count { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Count" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.List`1.Count" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Count As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Count { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Count : int" Usage="System.Collections.Generic.List&lt;'T&gt;.Count" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.Generic.ICollection`1.Count</InterfaceMember>
        <InterfaceMember>P:System.Collections.Generic.IReadOnlyCollection`1.Count</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene el número de elementos incluidos en <see cref="T:System.Collections.Generic.List`1" />.</summary>
        <value>Número de elementos contenidos en <see cref="T:System.Collections.Generic.List`1" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.Generic.List%601.Capacity%2A> es el número de elementos que la <xref:System.Collections.Generic.List%601> puede almacenar antes de solicitar el cambio de tamaño. <xref:System.Collections.Generic.List%601.Count%2A> es el número de elementos que son en realidad el <xref:System.Collections.Generic.List%601>.  
  
 <xref:System.Collections.Generic.List%601.Capacity%2A> es siempre mayor o igual que <xref:System.Collections.Generic.List%601.Count%2A>. Si <xref:System.Collections.Generic.List%601.Count%2A> supera <xref:System.Collections.Generic.List%601.Capacity%2A> al agregar elementos, se aumenta la capacidad mediante la reasignación automática de la matriz interna antes de copiar los elementos antiguos y agregar los nuevos elementos.  
  
 La recuperación del valor de esta propiedad es una operación O(1).  
  
   
  
## Examples  
 En el ejemplo siguiente se muestra cómo comprobar la capacidad y el recuento de un <xref:System.Collections.Generic.List%601> que contiene un objeto comercial simple y se muestra cómo utilizar el <xref:System.Collections.Generic.List%601.TrimExcess%2A> método para quitar la capacidad adicional.  
  
 [!code-csharp[System.Collections.Generic.List.CapacityCount#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.collections.generic.list.capacitycount/cs/program.cs#1)]
 [!code-vb[System.Collections.Generic.List.CapacityCount#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.collections.generic.list.capacitycount/vb/module1.vb#1)]  
  
 El ejemplo siguiente muestra el valor de la <xref:System.Collections.Generic.List%601.Count%2A> propiedad en varios puntos en la vida de una lista. Una vez creada y rellena la lista y muestran sus elementos, el <xref:System.Collections.Generic.List%601.Capacity%2A> y <xref:System.Collections.Generic.List%601.Count%2A> se muestran las propiedades. Estas propiedades se muestran después de volver a la <xref:System.Collections.Generic.List%601.TrimExcess%2A> ha sido el método llamado así como después el contenido de la lista se borra.  
  
 [!code-cpp[List\`1_Class#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_Class/cpp/source.cpp#1)]
 [!code-csharp[List\`1_Class#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_Class/cs/source.cs#1)]
 [!code-vb[List\`1_Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_Class/vb/source.vb#1)]  
 [!code-fsharp[List\`1_Class#1](~/samples/snippets/fsharp/VS_Snippets_CLR/List`1_Class/fs/listclass.fs#1)]
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Collections.Generic.List`1.Capacity" />
      </Docs>
    </Member>
    <Member MemberName="Exists">
      <MemberSignature Language="C#" Value="public bool Exists (Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Exists(class System.Predicate`1&lt;!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.Exists(System.Predicate{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Function Exists (match As Predicate(Of T)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Exists(Predicate&lt;T&gt; ^ match);" />
      <MemberSignature Language="F#" Value="member this.Exists : Predicate&lt;'T&gt; -&gt; bool" Usage="list.Exists match" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="match">Delegado <see cref="T:System.Predicate`1" /> que define las condiciones de los elementos que se van a buscar.</param>
        <summary>Determina si <see cref="T:System.Collections.Generic.List`1" /> contiene elementos que cumplen las condiciones definidas por el predicado especificado.</summary>
        <returns>Es <see langword="true" /> si <see cref="T:System.Collections.Generic.List`1" /> contiene uno o varios elementos que cumplen las condiciones definidas por el predicado especificado; en caso contrario, es <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Predicate%601> es un delegado a un método que devuelve `true` si el objeto pasado a coincide con las condiciones definidas en el delegado.  Los elementos del elemento actual <xref:System.Collections.Generic.List%601> individualmente se pasan a la <xref:System.Predicate%601> delegado y el procesamiento se detiene cuando encuentra una coincidencia.  
  
 Este método realiza una búsqueda lineal; por lo tanto, este método es O (*n*) operación, donde *n* es <xref:System.Collections.Generic.List%601.Count%2A>.  
  
   
  
## Examples  
 En el ejemplo siguiente se muestra el <xref:System.Collections.Generic.List%601.Contains%2A> y <xref:System.Collections.Generic.List%601.Exists%2A> métodos en un <xref:System.Collections.Generic.List%601> que contiene un objeto comercial simple que implementa <xref:System.IEquatable%601.Equals%2A>.  
  
 [!code-csharp[System.Collections.Generic.List.ContainsExists#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.collections.generic.list.containsexists/cs/program.cs#1)]
 [!code-vb[System.Collections.Generic.List.ContainsExists#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.collections.generic.list.containsexists/vb/module1.vb#1)]  
  
 En el ejemplo siguiente se muestra el <xref:System.Collections.Generic.List%601.Exists%2A> método y muchos otros métodos que utilizan el <xref:System.Predicate%601> delegado genérico.  
  
 Un <xref:System.Collections.Generic.List%601> de cadenas se crea, que contiene 8 nombres de dinosaurios, dos de los cuales (en las posiciones 1 y 5) terminan en "saurus". El ejemplo también define un método de predicado de búsqueda denominado `EndsWithSaurus`, que acepta un parámetro de cadena y devuelve un valor booleano que indica si la cadena de entrada termina en "saurus".  
  
 El <xref:System.Collections.Generic.List%601.Find%2A>, <xref:System.Collections.Generic.List%601.FindLast%2A>, y <xref:System.Collections.Generic.List%601.FindAll%2A> métodos se usan para buscar en la lista con el método de predicado de búsqueda y, a continuación, el <xref:System.Collections.Generic.List%601.RemoveAll%2A> método se usa para quitar todas las entradas que terminan con "saurus".  
  
 Por último, el <xref:System.Collections.Generic.List%601.Exists%2A> se llama al método. Recorre la lista desde el principio, pasando cada elemento a su vez a la `EndsWithSaurus` método. La búsqueda se detiene y devuelve el método `true` si el `EndsWithSaurus` devuelve del método `true` para cualquier elemento. El <xref:System.Collections.Generic.List%601.Exists%2A> devuelve del método `false` porque se han quitado todos estos elementos.  
  
> [!NOTE]
>  En C# y Visual Basic, no es necesario crear la `Predicate<string>` delegar (`Predicate(Of String)` en Visual Basic) explícitamente. Estos lenguajes deducen al delegado correcto del contexto y lo crean automáticamente.  
  
 [!code-cpp[List\`1_FindEtAl#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_FindEtAl/cpp/source.cpp#1)]
 [!code-csharp[List\`1_FindEtAl#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_FindEtAl/cs/source.cs#1)]
 [!code-vb[List\`1_FindEtAl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_FindEtAl/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="match" /> es <see langword="null" />.</exception>
        <altmember cref="M:System.Collections.Generic.List`1.Find(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.FindLast(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.FindAll(System.Predicate{`0})" />
        <altmember cref="Overload:System.Collections.Generic.List`1.FindIndex" />
        <altmember cref="Overload:System.Collections.Generic.List`1.FindLastIndex" />
        <altmember cref="Overload:System.Collections.Generic.List`1.BinarySearch" />
        <altmember cref="Overload:System.Collections.Generic.List`1.IndexOf" />
        <altmember cref="Overload:System.Collections.Generic.List`1.LastIndexOf" />
        <altmember cref="M:System.Collections.Generic.List`1.TrueForAll(System.Predicate{`0})" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
    <Member MemberName="Find">
      <MemberSignature Language="C#" Value="public T Find (Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance !T Find(class System.Predicate`1&lt;!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.Find(System.Predicate{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Function Find (match As Predicate(Of T)) As T" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; T Find(Predicate&lt;T&gt; ^ match);" />
      <MemberSignature Language="F#" Value="member this.Find : Predicate&lt;'T&gt; -&gt; 'T" Usage="list.Find match" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="match">Delegado <see cref="T:System.Predicate`1" /> que define las condiciones del elemento que se va a buscar.</param>
        <summary>Busca un elemento que coincida con las condiciones definidas por el predicado especificado y devuelve la primera aparición en toda la matriz <see cref="T:System.Collections.Generic.List`1" />.</summary>
        <returns>Primer elemento que coincide con las condiciones definidas por el predicado especificado, si se encuentra; de lo contrario, valor predeterminado para el tipo <paramref name="T" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Predicate%601> es un delegado a un método que devuelve `true` si el objeto pasado a coincide con las condiciones definidas en el delegado.  Los elementos del elemento actual <xref:System.Collections.Generic.List%601> individualmente se pasan a la <xref:System.Predicate%601> delegado, más adelante el <xref:System.Collections.Generic.List%601>, empezando por el primer elemento y terminando con el último elemento.  El procesamiento se detiene cuando encuentra una coincidencia.  
  
> [!IMPORTANT]
>  Al buscar una lista que contiene los tipos de valor, asegúrese de que el valor predeterminado para el tipo no cumple el predicado de búsqueda. En caso contrario, no hay ninguna manera de distinguir entre un elemento de lista que tenga el valor predeterminado para el tipo y un valor predeterminado que indica que se encuentra ninguna coincidencia. Si el valor predeterminado satisface el predicado de búsqueda, utilice el <xref:System.Collections.Generic.List%601.FindIndex%2A> método en su lugar.  
  
 Este método realiza una búsqueda lineal; por lo tanto, este método es O (*n*) operación, donde *n* es <xref:System.Collections.Generic.List%601.Count%2A>.  
  
   
  
## Examples  
 En el ejemplo siguiente se muestra el <xref:System.Collections.Generic.List%601.Find%2A> método en un <xref:System.Collections.Generic.List%601> que contiene un objeto complejo simple.  
  
 [!code-csharp[System.Collections.Generic.List.ContainsExists#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.collections.generic.list.containsexists/cs/program.cs#1)]
 [!code-vb[System.Collections.Generic.List.ContainsExists#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.collections.generic.list.containsexists/vb/module1.vb#1)]  
  
 El ejemplo siguiente muestra los métodos de búsqueda para el <xref:System.Collections.Generic.List%601> clase. El ejemplo de la <xref:System.Collections.Generic.List%601> contiene la clase `book` objetos de clase `Book`, utilizando los datos de la [archivo XML de ejemplo: Libros (LINQ to XML)](https://msdn.microsoft.com/library/94252daf-6097-4625-afc2-0eb778958d4f). El `FillList` método en el ejemplo usa [LINQ to XML](https://msdn.microsoft.com/library/f0fe21e9-ee43-4a55-b91a-0800e5782c13) para analizar los valores del archivo XML para los valores de propiedad de la `book` objetos.  
  
 En la tabla siguiente se describe los ejemplos proporcionados para los métodos find.  
  
|Método|Ejemplo|  
|------------|-------------|  
|<xref:System.Collections.Generic.List%601.Find%28System.Predicate%7B%600%7D%29>|Busca un libro usando un Id. del `IDToFind` delegado de predicado.<br /><br /> Ejemplo de C# usa a un delegado anónimo.|  
|<xref:System.Collections.Generic.List%601.FindAll%28System.Predicate%7B%600%7D%29>|Buscar todos los libros en pantalla que cuya `Genre` propiedad es "Equipo" mediante la `FindComputer` delegado de predicado.|  
|<xref:System.Collections.Generic.List%601.FindLast%28System.Predicate%7B%600%7D%29>|Busca el último libro en la colección que tiene una fecha de publicación antes de 2001, utilizando el `PubBefore2001` delegado de predicado.<br /><br /> Ejemplo de C# usa a un delegado anónimo.|  
|<xref:System.Collections.Generic.List%601.FindIndex%28System.Predicate%7B%600%7D%29>|Busca el índice del primer libro de equipo mediante el `FindComputer` delegado de predicado.|  
|<xref:System.Collections.Generic.List%601.FindLastIndex%28System.Predicate%7B%600%7D%29>|Busca el índice del último libro equipo mediante el `FindComputer` delegado de predicado.|  
|<xref:System.Collections.Generic.List%601.FindIndex%28System.Int32%2CSystem.Int32%2CSystem.Predicate%7B%600%7D%29>|Busca el índice del primer libro del equipo en la segunda mitad de la colección, utilizando el `FindComputer` delegado de predicado.|  
|<xref:System.Collections.Generic.List%601.FindLastIndex%28System.Int32%2CSystem.Int32%2CSystem.Predicate%7B%600%7D%29>|Busca el índice del último libro sobre informática en la segunda mitad de la colección, utilizando el `FindComputer` delegado de predicado.|  
  
 [!code-csharp[List\`1_Find_Methods#1](~/samples/snippets/csharp/VS_Snippets_CLR/list`1_find_methods/cs/program.cs#1)]
 [!code-vb[List\`1_Find_Methods#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/list`1_find_methods/vb/module1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="match" /> es <see langword="null" />.</exception>
        <altmember cref="M:System.Collections.Generic.List`1.Exists(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.FindLast(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.FindAll(System.Predicate{`0})" />
        <altmember cref="Overload:System.Collections.Generic.List`1.FindIndex" />
        <altmember cref="Overload:System.Collections.Generic.List`1.FindLastIndex" />
        <altmember cref="Overload:System.Collections.Generic.List`1.BinarySearch" />
        <altmember cref="Overload:System.Collections.Generic.List`1.IndexOf" />
        <altmember cref="Overload:System.Collections.Generic.List`1.LastIndexOf" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
    <Member MemberName="FindAll">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.List&lt;T&gt; FindAll (Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.List`1&lt;!T&gt; FindAll(class System.Predicate`1&lt;!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.FindAll(System.Predicate{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Function FindAll (match As Predicate(Of T)) As List(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::List&lt;T&gt; ^ FindAll(Predicate&lt;T&gt; ^ match);" />
      <MemberSignature Language="F#" Value="member this.FindAll : Predicate&lt;'T&gt; -&gt; System.Collections.Generic.List&lt;'T&gt;" Usage="list.FindAll match" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.List&lt;T&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="match">Delegado <see cref="T:System.Predicate`1" /> que define las condiciones de los elementos que se van a buscar.</param>
        <summary>Recupera todos los elementos que coinciden con las condiciones definidas por el predicado especificado.</summary>
        <returns><see cref="T:System.Collections.Generic.List`1" /> que contiene todos los elementos que cumplen las condiciones definidas por el predicado especificado, si se encuentran; en caso contrario, devuelve una <see cref="T:System.Collections.Generic.List`1" /> vacía.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Predicate%601> es un delegado a un método que devuelve `true` si el objeto pasado a coincide con las condiciones definidas en el delegado.  Los elementos del elemento actual <xref:System.Collections.Generic.List%601> individualmente se pasan a la <xref:System.Predicate%601> delegado y los elementos que cumplen las condiciones se guardan en el valor devuelto <xref:System.Collections.Generic.List%601>.  
  
 Este método realiza una búsqueda lineal; por lo tanto, este método es O (*n*) operación, donde *n* es <xref:System.Collections.Generic.List%601.Count%2A>.  
  
   
  
## Examples  
 El ejemplo siguiente muestra los métodos de búsqueda para el <xref:System.Collections.Generic.List%601> clase. El ejemplo de la <xref:System.Collections.Generic.List%601> contiene la clase `book` objetos de clase `Book`, utilizando los datos de la [archivo XML de ejemplo: Libros (LINQ to XML)](https://msdn.microsoft.com/library/94252daf-6097-4625-afc2-0eb778958d4f). El `FillList` método en el ejemplo usa [LINQ to XML](https://msdn.microsoft.com/library/f0fe21e9-ee43-4a55-b91a-0800e5782c13) para analizar los valores del archivo XML para los valores de propiedad de la `book` objetos.  
  
 En la tabla siguiente se describe los ejemplos proporcionados para los métodos find.  
  
|Método|Ejemplo|  
|------------|-------------|  
|<xref:System.Collections.Generic.List%601.Find%28System.Predicate%7B%600%7D%29>|Busca un libro usando un Id. del `IDToFind` delegado de predicado.<br /><br /> Ejemplo de C# usa a un delegado anónimo.|  
|<xref:System.Collections.Generic.List%601.FindAll%28System.Predicate%7B%600%7D%29>|Buscar todos los libros en pantalla que cuya `Genre` propiedad es "Equipo" mediante la `FindComputer` delegado de predicado.|  
|<xref:System.Collections.Generic.List%601.FindLast%28System.Predicate%7B%600%7D%29>|Busca el último libro en la colección que tiene una fecha de publicación antes de 2001, utilizando el `PubBefore2001` delegado de predicado.<br /><br /> Ejemplo de C# usa a un delegado anónimo.|  
|<xref:System.Collections.Generic.List%601.FindIndex%28System.Predicate%7B%600%7D%29>|Busca el índice del primer libro de equipo mediante el `FindComputer` delegado de predicado.|  
|<xref:System.Collections.Generic.List%601.FindLastIndex%28System.Predicate%7B%600%7D%29>|Busca el índice del último libro equipo mediante el `FindComputer` delegado de predicado.|  
|<xref:System.Collections.Generic.List%601.FindIndex%28System.Int32%2CSystem.Int32%2CSystem.Predicate%7B%600%7D%29>|Busca el índice del primer libro del equipo en la segunda mitad de la colección, utilizando el `FindComputer` delegado de predicado.|  
|<xref:System.Collections.Generic.List%601.FindLastIndex%28System.Int32%2CSystem.Int32%2CSystem.Predicate%7B%600%7D%29>|Busca el índice del último libro sobre informática en la segunda mitad de la colección, utilizando el `FindComputer` delegado de predicado.|  
  
 [!code-csharp[List\`1_Find_Methods#1](~/samples/snippets/csharp/VS_Snippets_CLR/list`1_find_methods/cs/program.cs#1)]
 [!code-vb[List\`1_Find_Methods#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/list`1_find_methods/vb/module1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="match" /> es <see langword="null" />.</exception>
        <altmember cref="M:System.Collections.Generic.List`1.Exists(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.Find(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.FindLast(System.Predicate{`0})" />
        <altmember cref="Overload:System.Collections.Generic.List`1.FindIndex" />
        <altmember cref="Overload:System.Collections.Generic.List`1.FindLastIndex" />
        <altmember cref="Overload:System.Collections.Generic.List`1.BinarySearch" />
        <altmember cref="Overload:System.Collections.Generic.List`1.IndexOf" />
        <altmember cref="Overload:System.Collections.Generic.List`1.LastIndexOf" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
    <MemberGroup MemberName="FindIndex">
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Busca un elemento que cumpla las condiciones definidas por el predicado especificado y devuelve el índice de base cero de la primera aparición en <see cref="T:System.Collections.Generic.List`1" /> o en una parte. Este método devuelve -1 si no se encuentra un elemento que cumpla las condiciones.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="FindIndex">
      <MemberSignature Language="C#" Value="public int FindIndex (Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 FindIndex(class System.Predicate`1&lt;!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.FindIndex(System.Predicate{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Function FindIndex (match As Predicate(Of T)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int FindIndex(Predicate&lt;T&gt; ^ match);" />
      <MemberSignature Language="F#" Value="member this.FindIndex : Predicate&lt;'T&gt; -&gt; int" Usage="list.FindIndex match" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="match">Delegado <see cref="T:System.Predicate`1" /> que define las condiciones del elemento que se va a buscar.</param>
        <summary>Busca un elemento que coincida con las condiciones definidas por el predicado especificado y devuelve el índice de base cero de la primera aparición en toda la matriz <see cref="T:System.Collections.Generic.List`1" />.</summary>
        <returns>Índice de base cero de la primera aparición de un elemento que coincide con las condiciones definidas por <paramref name="match" />, si se encuentra; en caso contrario, -1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Collections.Generic.List%601> se buscará hacia delante a partir del primer elemento y terminando en el último elemento.  
  
 El <xref:System.Predicate%601> es un delegado a un método que devuelve `true` si el objeto pasado a coincide con las condiciones definidas en el delegado.  Los elementos del elemento actual <xref:System.Collections.Generic.List%601> individualmente se pasan a la <xref:System.Predicate%601> delegar. El delegado tiene la firma:  
  
```csharp  
public bool methodName(T obj)  
```  
  
```vb  
Public Function methodName(obj As T) As Boolean  
```  
  
 Este método realiza una búsqueda lineal; por lo tanto, este método es O (*n*) operación, donde *n* es <xref:System.Collections.Generic.List%601.Count%2A>.  
  
   
  
## Examples  
 En el ejemplo siguiente se define un `Employee` clase con dos campos, `Name` y `Id`. También define un `EmployeeSearch` clase con un único método, `StartsWith`, que indica si el `Employee.Name` campo comienza con una subcadena especificada que se proporciona a los `EmployeeSearch` constructor de clase. Tenga en cuenta la firma de este método  
  
```csharp  
public bool StartsWith(Employee e)  
```  
  
```vb  
Public Function StartsWith(e As Employee) As Boolean  
```  
  
 corresponde a la firma del delegado que se puede pasar a la <xref:System.Collections.Generic.List%601.FindIndex%2A> método. En el ejemplo se crea una instancia un `List<Employee>` de objetos, se agrega un número de `Employee` objetos y, a continuación, llama a la <xref:System.Collections.Generic.List%601.FindIndex%28System.Int32%2CSystem.Int32%2CSystem.Predicate%7B%600%7D%29> método dos veces para buscar toda la colección, la primera vez para el primer `Employee` cuyo `Name` comienza el campo con "J" y la segunda vez para el primer `Employee` cuyo `Name` campo comienza con "Ju".  
  
 [!code-csharp[System.Collections.Generic.List.FindIndex#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Collections.Generic.List.FindIndex/cs/FindIndex2.cs#2)]
 [!code-vb[System.Collections.Generic.List.FindIndex#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Collections.Generic.List.FindIndex/vb/FindIndex2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="match" /> es <see langword="null" />.</exception>
        <altmember cref="M:System.Collections.Generic.List`1.Exists(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.Find(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.FindLast(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.FindAll(System.Predicate{`0})" />
        <altmember cref="Overload:System.Collections.Generic.List`1.FindLastIndex" />
        <altmember cref="Overload:System.Collections.Generic.List`1.BinarySearch" />
        <altmember cref="Overload:System.Collections.Generic.List`1.IndexOf" />
        <altmember cref="Overload:System.Collections.Generic.List`1.LastIndexOf" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
    <Member MemberName="FindIndex">
      <MemberSignature Language="C#" Value="public int FindIndex (int startIndex, Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 FindIndex(int32 startIndex, class System.Predicate`1&lt;!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.FindIndex(System.Int32,System.Predicate{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Function FindIndex (startIndex As Integer, match As Predicate(Of T)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int FindIndex(int startIndex, Predicate&lt;T&gt; ^ match);" />
      <MemberSignature Language="F#" Value="member this.FindIndex : int * Predicate&lt;'T&gt; -&gt; int" Usage="list.FindIndex (startIndex, match)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="startIndex">Índice inicial de base cero de la búsqueda.</param>
        <param name="match">Delegado <see cref="T:System.Predicate`1" /> que define las condiciones del elemento que se va a buscar.</param>
        <summary>Busca un elemento que coincida con las condiciones definidas por el predicado especificado y devuelve el índice de base cero de la primera aparición en el intervalo de elementos de la matriz <see cref="T:System.Collections.Generic.List`1" /> que va desde el índice especificado hasta el último elemento.</summary>
        <returns>Índice de base cero de la primera aparición de un elemento que coincide con las condiciones definidas por <paramref name="match" />, si se encuentra; en caso contrario, -1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Collections.Generic.List%601> se buscará hacia delante, empezando en `startIndex` y terminando en el último elemento.  
  
 El <xref:System.Predicate%601> es un delegado a un método que devuelve `true` si el objeto pasado a coincide con las condiciones definidas en el delegado.  Los elementos del elemento actual <xref:System.Collections.Generic.List%601> individualmente se pasan a la <xref:System.Predicate%601> delegar. El delegado tiene la firma:  
  
```csharp  
public bool methodName(T obj)  
```  
  
```vb  
Public Function methodName(obj As T) As Boolean  
```  
  
 Este método realiza una búsqueda lineal; por lo tanto, este método es O (*n*) operación, donde *n* es el número de elementos de `startIndex` al final de la <xref:System.Collections.Generic.List%601>.  
  
   
  
## Examples  
 En el ejemplo siguiente se define un `Employee` clase con dos campos, `Name` y `Id`. También define un `EmployeeSearch` clase con un único método, `StartsWith`, que indica si el `Employee.Name` campo comienza con una subcadena especificada que se proporciona a los `EmployeeSearch` constructor de clase. Tenga en cuenta la firma de este método  
  
```csharp  
public bool StartsWith(Employee e)  
```  
  
```vb  
Public Function StartsWith(e As Employee) As Boolean  
```  
  
 corresponde a la firma del delegado que se puede pasar a la <xref:System.Collections.Generic.List%601.FindIndex%2A> método. El ejemplo crea un `List<Employee>` de objetos, se agrega un número de `Employee` objetos y, a continuación, llama a la <xref:System.Collections.Generic.List%601.FindIndex%28System.Int32%2CSystem.Int32%2CSystem.Predicate%7B%600%7D%29> método dos veces para buscar en la colección a partir de su miembro quinto (es decir, el miembro en el índice 4). La primera vez, busca la primera `Employee` cuyo `Name` campo comienza con "J"; la segunda vez, busca la primera `Employee` cuyo `Name` campo comienza con "Ju".  
  
 [!code-csharp[System.Collections.Generic.List.FindIndex#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Collections.Generic.List.FindIndex/cs/FindIndex3.cs#3)]
 [!code-vb[System.Collections.Generic.List.FindIndex#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Collections.Generic.List.FindIndex/vb/FindIndex3.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="match" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startIndex" /> está fuera del intervalo de índices válidos para <see cref="T:System.Collections.Generic.List`1" />.</exception>
        <altmember cref="M:System.Collections.Generic.List`1.Exists(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.Find(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.FindLast(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.FindAll(System.Predicate{`0})" />
        <altmember cref="Overload:System.Collections.Generic.List`1.FindLastIndex" />
        <altmember cref="Overload:System.Collections.Generic.List`1.BinarySearch" />
        <altmember cref="Overload:System.Collections.Generic.List`1.IndexOf" />
        <altmember cref="Overload:System.Collections.Generic.List`1.LastIndexOf" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
    <Member MemberName="FindIndex">
      <MemberSignature Language="C#" Value="public int FindIndex (int startIndex, int count, Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 FindIndex(int32 startIndex, int32 count, class System.Predicate`1&lt;!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.FindIndex(System.Int32,System.Int32,System.Predicate{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Function FindIndex (startIndex As Integer, count As Integer, match As Predicate(Of T)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int FindIndex(int startIndex, int count, Predicate&lt;T&gt; ^ match);" />
      <MemberSignature Language="F#" Value="member this.FindIndex : int * int * Predicate&lt;'T&gt; -&gt; int" Usage="list.FindIndex (startIndex, count, match)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="startIndex">Índice inicial de base cero de la búsqueda.</param>
        <param name="count">Número de elementos de la sección en la que se va a realizar la búsqueda.</param>
        <param name="match">Delegado <see cref="T:System.Predicate`1" /> que define las condiciones del elemento que se va a buscar.</param>
        <summary>Busca un elemento que coincida con las condiciones definidas por el predicado especificado y devuelve el índice de base cero de la primera aparición en el intervalo de elementos de la matriz <see cref="T:System.Collections.Generic.List`1" /> que comienza en el índice especificado y contiene el número especificado de elementos.</summary>
        <returns>Índice de base cero de la primera aparición de un elemento que coincide con las condiciones definidas por <paramref name="match" />, si se encuentra; en caso contrario, -1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Collections.Generic.List%601> se buscará hacia delante, empezando en `startIndex` hasta `startIndex` plus `count` menos 1, si `count` es mayor que 0.  
  
 El <xref:System.Predicate%601> es un delegado a un método que devuelve `true` si el objeto pasado a coincide con las condiciones definidas en el delegado.  Los elementos del elemento actual <xref:System.Collections.Generic.List%601> individualmente se pasan a la <xref:System.Predicate%601> delegar. El delegado tiene la firma:  
  
```csharp  
public bool methodName(T obj)  
```  
  
```vb  
Public Function methodName(obj As T) As Boolean  
```  
  
 Este método realiza una búsqueda lineal; por lo tanto, este método es O (*n*) operación, donde *n* es `count`.  
  
   
  
## Examples  
 En el ejemplo siguiente se define un `Employee` clase con dos campos, `Name` y `Id`. También define un `EmployeeSearch` clase con un único método, `StartsWith`, que indica si el `Employee.Name` campo comienza con una subcadena especificada que se proporciona a los `EmployeeSearch` constructor de clase. Tenga en cuenta la firma de este método  
  
```csharp  
public bool StartsWith(Employee e)  
```  
  
```vb  
Public Function StartsWith(e As Employee) As Boolean  
```  
  
 corresponde a la firma del delegado que se puede pasar a la <xref:System.Collections.Generic.List%601.FindIndex%2A> método. En el ejemplo se crea una instancia de un `List<Employee>` de objetos, se agrega un número de `Employee` objetos y, a continuación, llama a la <xref:System.Collections.Generic.List%601.FindIndex%28System.Int32%2CSystem.Int32%2CSystem.Predicate%7B%600%7D%29> método dos veces para buscar toda la colección (es decir, los miembros desde el índice 0 al índice <xref:System.Collections.Generic.List%601.Count%2A> - 1). La primera vez, busca la primera `Employee` cuyo `Name` campo comienza con "J"; la segunda vez, busca la primera `Employee` cuyo `Name` campo comienza con "Ju".  
  
 [!code-csharp[System.Collections.Generic.List.FindIndex#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Collections.Generic.List.FindIndex/cs/FindIndex1.cs#1)]
 [!code-vb[System.Collections.Generic.List.FindIndex#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Collections.Generic.List.FindIndex/vb/FindIndex1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="match" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startIndex" /> está fuera del intervalo de índices válidos para <see cref="T:System.Collections.Generic.List`1" />.  
  
O bien 
 <paramref name="count" /> es menor que 0.  
  
O bien 
 <paramref name="startIndex" /> y <paramref name="count" /> no especifican una sección válida en <see cref="T:System.Collections.Generic.List`1" />.</exception>
        <altmember cref="M:System.Collections.Generic.List`1.Exists(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.Find(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.FindLast(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.FindAll(System.Predicate{`0})" />
        <altmember cref="Overload:System.Collections.Generic.List`1.FindLastIndex" />
        <altmember cref="Overload:System.Collections.Generic.List`1.BinarySearch" />
        <altmember cref="Overload:System.Collections.Generic.List`1.IndexOf" />
        <altmember cref="Overload:System.Collections.Generic.List`1.LastIndexOf" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
    <Member MemberName="FindLast">
      <MemberSignature Language="C#" Value="public T FindLast (Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance !T FindLast(class System.Predicate`1&lt;!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.FindLast(System.Predicate{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Function FindLast (match As Predicate(Of T)) As T" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; T FindLast(Predicate&lt;T&gt; ^ match);" />
      <MemberSignature Language="F#" Value="member this.FindLast : Predicate&lt;'T&gt; -&gt; 'T" Usage="list.FindLast match" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="match">Delegado <see cref="T:System.Predicate`1" /> que define las condiciones del elemento que se va a buscar.</param>
        <summary>Busca un elemento que coincida con las condiciones definidas por el predicado especificado y devuelve la última aparición en toda la matriz <see cref="T:System.Collections.Generic.List`1" />.</summary>
        <returns>Último elemento que coincide con las condiciones definidas por el predicado especificado, si se encuentra; de lo contrario, valor predeterminado para el tipo <paramref name="T" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Predicate%601> es un delegado a un método que devuelve `true` si el objeto pasado a coincide con las condiciones definidas en el delegado.  Los elementos del elemento actual <xref:System.Collections.Generic.List%601> individualmente se pasan a la <xref:System.Predicate%601> delegado, mover hacia atrás el <xref:System.Collections.Generic.List%601>, empezando por el último elemento y terminando por el primer elemento.  El procesamiento se detiene cuando encuentra una coincidencia.  
  
> [!IMPORTANT]
>  Al buscar una lista que contiene los tipos de valor, asegúrese de que el valor predeterminado para el tipo no cumple el predicado de búsqueda. En caso contrario, no hay ninguna manera de distinguir entre un elemento de lista que tenga el valor predeterminado para el tipo y un valor predeterminado que indica que se encuentra ninguna coincidencia. Si el valor predeterminado satisface el predicado de búsqueda, utilice el <xref:System.Collections.Generic.List%601.FindLastIndex%2A> método en su lugar.  
  
 Este método realiza una búsqueda lineal; por lo tanto, este método es O (*n*) operación, donde *n* es <xref:System.Collections.Generic.List%601.Count%2A>.  
  
   
  
## Examples  
 El ejemplo siguiente muestra los métodos de búsqueda para el <xref:System.Collections.Generic.List%601> clase. El ejemplo de la <xref:System.Collections.Generic.List%601> contiene la clase `book` objetos de clase `Book`, utilizando los datos de la [archivo XML de ejemplo: Libros (LINQ to XML)](https://msdn.microsoft.com/library/94252daf-6097-4625-afc2-0eb778958d4f). El `FillList` método en el ejemplo usa [LINQ to XML](https://msdn.microsoft.com/library/f0fe21e9-ee43-4a55-b91a-0800e5782c13) para analizar los valores del archivo XML para los valores de propiedad de la `book` objetos.  
  
 En la tabla siguiente se describe los ejemplos proporcionados para los métodos find.  
  
|Método|Ejemplo|  
|------------|-------------|  
|<xref:System.Collections.Generic.List%601.Find%28System.Predicate%7B%600%7D%29>|Busca un libro usando un Id. del `IDToFind` delegado de predicado.<br /><br /> Ejemplo de C# usa a un delegado anónimo.|  
|<xref:System.Collections.Generic.List%601.FindAll%28System.Predicate%7B%600%7D%29>|Buscar todos los libros en pantalla que cuya `Genre` propiedad es "Equipo" mediante la `FindComputer` delegado de predicado.|  
|<xref:System.Collections.Generic.List%601.FindLast%28System.Predicate%7B%600%7D%29>|Busca el último libro en la colección que tiene una fecha de publicación antes de 2001, utilizando el `PubBefore2001` delegado de predicado.<br /><br /> Ejemplo de C# usa a un delegado anónimo.|  
|<xref:System.Collections.Generic.List%601.FindIndex%28System.Predicate%7B%600%7D%29>|Busca el índice del primer libro de equipo mediante el `FindComputer` delegado de predicado.|  
|<xref:System.Collections.Generic.List%601.FindLastIndex%28System.Predicate%7B%600%7D%29>|Busca el índice del último libro equipo mediante el `FindComputer` delegado de predicado.|  
|<xref:System.Collections.Generic.List%601.FindIndex%28System.Int32%2CSystem.Int32%2CSystem.Predicate%7B%600%7D%29>|Busca el índice del primer libro del equipo en la segunda mitad de la colección, utilizando el `FindComputer` delegado de predicado.|  
|<xref:System.Collections.Generic.List%601.FindLastIndex%28System.Int32%2CSystem.Int32%2CSystem.Predicate%7B%600%7D%29>|Busca el índice del último libro sobre informática en la segunda mitad de la colección, utilizando el `FindComputer` delegado de predicado.|  
  
 [!code-csharp[List\`1_Find_Methods#1](~/samples/snippets/csharp/VS_Snippets_CLR/list`1_find_methods/cs/program.cs#1)]
 [!code-vb[List\`1_Find_Methods#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/list`1_find_methods/vb/module1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="match" /> es <see langword="null" />.</exception>
        <altmember cref="M:System.Collections.Generic.List`1.Exists(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.Find(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.FindAll(System.Predicate{`0})" />
        <altmember cref="Overload:System.Collections.Generic.List`1.FindIndex" />
        <altmember cref="Overload:System.Collections.Generic.List`1.FindLastIndex" />
        <altmember cref="Overload:System.Collections.Generic.List`1.BinarySearch" />
        <altmember cref="Overload:System.Collections.Generic.List`1.IndexOf" />
        <altmember cref="Overload:System.Collections.Generic.List`1.LastIndexOf" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
    <MemberGroup MemberName="FindLastIndex">
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Busca un elemento que cumpla las condiciones definidas por el predicado especificado y devuelve el índice de base cero de la última aparición en <see cref="T:System.Collections.Generic.List`1" /> o en una parte.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="FindLastIndex">
      <MemberSignature Language="C#" Value="public int FindLastIndex (Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 FindLastIndex(class System.Predicate`1&lt;!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.FindLastIndex(System.Predicate{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Function FindLastIndex (match As Predicate(Of T)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int FindLastIndex(Predicate&lt;T&gt; ^ match);" />
      <MemberSignature Language="F#" Value="member this.FindLastIndex : Predicate&lt;'T&gt; -&gt; int" Usage="list.FindLastIndex match" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="match">Delegado <see cref="T:System.Predicate`1" /> que define las condiciones del elemento que se va a buscar.</param>
        <summary>Busca un elemento que coincida con las condiciones definidas por el predicado especificado y devuelve el índice de base cero de la última aparición en toda la matriz <see cref="T:System.Collections.Generic.List`1" />.</summary>
        <returns>Índice de base cero de la última aparición de un elemento que coincide con las condiciones definidas por <paramref name="match" />, si se encuentra; en caso contrario, -1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Collections.Generic.List%601> se realiza hacia atrás a partir del último elemento y terminando en el primer elemento.  
  
 El <xref:System.Predicate%601> es un delegado a un método que devuelve `true` si el objeto pasado a coincide con las condiciones definidas en el delegado.  Los elementos del elemento actual <xref:System.Collections.Generic.List%601> individualmente se pasan a la <xref:System.Predicate%601> delegar.  
  
 Este método realiza una búsqueda lineal; por lo tanto, este método es O (*n*) operación, donde *n* es <xref:System.Collections.Generic.List%601.Count%2A>.  
  
   
  
## Examples  
 El ejemplo siguiente muestra los métodos de búsqueda para el <xref:System.Collections.Generic.List%601> clase. El ejemplo de la <xref:System.Collections.Generic.List%601> contiene la clase `book` objetos de clase `Book`, utilizando los datos de la [archivo XML de ejemplo: Libros (LINQ to XML)](https://msdn.microsoft.com/library/94252daf-6097-4625-afc2-0eb778958d4f). El `FillList` método en el ejemplo usa [LINQ to XML](https://msdn.microsoft.com/library/f0fe21e9-ee43-4a55-b91a-0800e5782c13) para analizar los valores del archivo XML para los valores de propiedad de la `book` objetos.  
  
 En la tabla siguiente se describe los ejemplos proporcionados para los métodos find.  
  
|Método|Ejemplo|  
|------------|-------------|  
|<xref:System.Collections.Generic.List%601.Find%28System.Predicate%7B%600%7D%29>|Busca un libro usando un Id. del `IDToFind` delegado de predicado.<br /><br /> Ejemplo de C# usa a un delegado anónimo.|  
|<xref:System.Collections.Generic.List%601.FindAll%28System.Predicate%7B%600%7D%29>|Buscar todos los libros en pantalla que cuya `Genre` propiedad es "Equipo" mediante la `FindComputer` delegado de predicado.|  
|<xref:System.Collections.Generic.List%601.FindLast%28System.Predicate%7B%600%7D%29>|Busca el último libro en la colección que tiene una fecha de publicación antes de 2001, utilizando el `PubBefore2001` delegado de predicado.<br /><br /> Ejemplo de C# usa a un delegado anónimo.|  
|<xref:System.Collections.Generic.List%601.FindIndex%28System.Predicate%7B%600%7D%29>|Busca el índice del primer libro de equipo mediante el `FindComputer` delegado de predicado.|  
|<xref:System.Collections.Generic.List%601.FindLastIndex%28System.Predicate%7B%600%7D%29>|Busca el índice del último libro equipo mediante el `FindComputer` delegado de predicado.|  
|<xref:System.Collections.Generic.List%601.FindIndex%28System.Int32%2CSystem.Int32%2CSystem.Predicate%7B%600%7D%29>|Busca el índice del primer libro del equipo en la segunda mitad de la colección, utilizando el `FindComputer` delegado de predicado.|  
|<xref:System.Collections.Generic.List%601.FindLastIndex%28System.Int32%2CSystem.Int32%2CSystem.Predicate%7B%600%7D%29>|Busca el índice del último libro sobre informática en la segunda mitad de la colección, utilizando el `FindComputer` delegado de predicado.|  
  
 [!code-csharp[List\`1_Find_Methods#1](~/samples/snippets/csharp/VS_Snippets_CLR/list`1_find_methods/cs/program.cs#1)]
 [!code-vb[List\`1_Find_Methods#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/list`1_find_methods/vb/module1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="match" /> es <see langword="null" />.</exception>
        <altmember cref="M:System.Collections.Generic.List`1.Exists(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.Find(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.FindLast(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.FindAll(System.Predicate{`0})" />
        <altmember cref="Overload:System.Collections.Generic.List`1.FindIndex" />
        <altmember cref="Overload:System.Collections.Generic.List`1.BinarySearch" />
        <altmember cref="Overload:System.Collections.Generic.List`1.IndexOf" />
        <altmember cref="Overload:System.Collections.Generic.List`1.LastIndexOf" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
    <Member MemberName="FindLastIndex">
      <MemberSignature Language="C#" Value="public int FindLastIndex (int startIndex, Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 FindLastIndex(int32 startIndex, class System.Predicate`1&lt;!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.FindLastIndex(System.Int32,System.Predicate{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Function FindLastIndex (startIndex As Integer, match As Predicate(Of T)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int FindLastIndex(int startIndex, Predicate&lt;T&gt; ^ match);" />
      <MemberSignature Language="F#" Value="member this.FindLastIndex : int * Predicate&lt;'T&gt; -&gt; int" Usage="list.FindLastIndex (startIndex, match)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="startIndex">Índice inicial de base cero de la búsqueda hacia atrás.</param>
        <param name="match">Delegado <see cref="T:System.Predicate`1" /> que define las condiciones del elemento que se va a buscar.</param>
        <summary>Busca un elemento que coincida con las condiciones definidas por el predicado especificado y devuelve el índice de base cero de la última aparición en el intervalo de elementos de la matriz <see cref="T:System.Collections.Generic.List`1" /> que va desde el primer elemento hasta el índice especificado.</summary>
        <returns>Índice de base cero de la última aparición de un elemento que coincide con las condiciones definidas por <paramref name="match" />, si se encuentra; en caso contrario, -1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Collections.Generic.List%601> es la búsqueda hacia atrás, empezando en `startIndex` y terminando en el primer elemento.  
  
 El <xref:System.Predicate%601> es un delegado a un método que devuelve `true` si el objeto pasado a coincide con las condiciones definidas en el delegado.  Los elementos del elemento actual <xref:System.Collections.Generic.List%601> individualmente se pasan a la <xref:System.Predicate%601> delegar.  
  
 Este método realiza una búsqueda lineal; por lo tanto, este método es O (*n*) operación, donde *n* es el número de elementos desde el principio de la <xref:System.Collections.Generic.List%601> a `startIndex`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="match" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startIndex" /> está fuera del intervalo de índices válidos para <see cref="T:System.Collections.Generic.List`1" />.</exception>
        <altmember cref="M:System.Collections.Generic.List`1.Exists(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.Find(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.FindLast(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.FindAll(System.Predicate{`0})" />
        <altmember cref="Overload:System.Collections.Generic.List`1.FindIndex" />
        <altmember cref="Overload:System.Collections.Generic.List`1.BinarySearch" />
        <altmember cref="Overload:System.Collections.Generic.List`1.IndexOf" />
        <altmember cref="Overload:System.Collections.Generic.List`1.LastIndexOf" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
    <Member MemberName="FindLastIndex">
      <MemberSignature Language="C#" Value="public int FindLastIndex (int startIndex, int count, Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 FindLastIndex(int32 startIndex, int32 count, class System.Predicate`1&lt;!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.FindLastIndex(System.Int32,System.Int32,System.Predicate{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Function FindLastIndex (startIndex As Integer, count As Integer, match As Predicate(Of T)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int FindLastIndex(int startIndex, int count, Predicate&lt;T&gt; ^ match);" />
      <MemberSignature Language="F#" Value="member this.FindLastIndex : int * int * Predicate&lt;'T&gt; -&gt; int" Usage="list.FindLastIndex (startIndex, count, match)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="startIndex">Índice inicial de base cero de la búsqueda hacia atrás.</param>
        <param name="count">Número de elementos de la sección en la que se va a realizar la búsqueda.</param>
        <param name="match">Delegado <see cref="T:System.Predicate`1" /> que define las condiciones del elemento que se va a buscar.</param>
        <summary>Busca un elemento que coincida con las condiciones definidas por el predicado especificado y devuelve el índice de base cero de la última aparición en el intervalo de elementos de la matriz <see cref="T:System.Collections.Generic.List`1" /> que contiene el número especificado de elementos y termina en el índice especificado.</summary>
        <returns>Índice de base cero de la última aparición de un elemento que coincide con las condiciones definidas por <paramref name="match" />, si se encuentra; en caso contrario, -1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Collections.Generic.List%601> es la búsqueda hacia atrás, empezando en `startIndex` hasta `startIndex` menos `count` más 1, si `count` es mayor que 0.  
  
 El <xref:System.Predicate%601> es un delegado a un método que devuelve `true` si el objeto pasado a coincide con las condiciones definidas en el delegado.  Los elementos del elemento actual <xref:System.Collections.Generic.List%601> individualmente se pasan a la <xref:System.Predicate%601> delegar.  
  
 Este método realiza una búsqueda lineal; por lo tanto, este método es O (*n*) operación, donde *n* es `count`.  
  
   
  
## Examples  
 El ejemplo siguiente muestra los métodos de búsqueda para el <xref:System.Collections.Generic.List%601> clase. El ejemplo de la <xref:System.Collections.Generic.List%601> contiene la clase `book` objetos de clase `Book`, utilizando los datos de la [archivo XML de ejemplo: Libros (LINQ to XML)](https://msdn.microsoft.com/library/94252daf-6097-4625-afc2-0eb778958d4f). El `FillList` método en el ejemplo usa [LINQ to XML](https://msdn.microsoft.com/library/f0fe21e9-ee43-4a55-b91a-0800e5782c13) para analizar los valores del archivo XML para los valores de propiedad de la `book` objetos.  
  
 En la tabla siguiente se describe los ejemplos proporcionados para los métodos find.  
  
|Método|Ejemplo|  
|------------|-------------|  
|<xref:System.Collections.Generic.List%601.Find%28System.Predicate%7B%600%7D%29>|Busca un libro usando un Id. del `IDToFind` delegado de predicado.<br /><br /> Ejemplo de C# usa a un delegado anónimo.|  
|<xref:System.Collections.Generic.List%601.FindAll%28System.Predicate%7B%600%7D%29>|Buscar todos los libros en pantalla que cuya `Genre` propiedad es "Equipo" mediante la `FindComputer` delegado de predicado.|  
|<xref:System.Collections.Generic.List%601.FindLast%28System.Predicate%7B%600%7D%29>|Busca el último libro en la colección que tiene una fecha de publicación antes de 2001, utilizando el `PubBefore2001` delegado de predicado.<br /><br /> Ejemplo de C# usa a un delegado anónimo.|  
|<xref:System.Collections.Generic.List%601.FindIndex%28System.Predicate%7B%600%7D%29>|Busca el índice del primer libro de equipo mediante el `FindComputer` delegado de predicado.|  
|<xref:System.Collections.Generic.List%601.FindLastIndex%28System.Predicate%7B%600%7D%29>|Busca el índice del último libro equipo mediante el `FindComputer` delegado de predicado.|  
|<xref:System.Collections.Generic.List%601.FindIndex%28System.Int32%2CSystem.Int32%2CSystem.Predicate%7B%600%7D%29>|Busca el índice del primer libro del equipo en la segunda mitad de la colección, utilizando el `FindComputer` delegado de predicado.|  
|<xref:System.Collections.Generic.List%601.FindLastIndex%28System.Int32%2CSystem.Int32%2CSystem.Predicate%7B%600%7D%29>|Busca el índice del último libro sobre informática en la segunda mitad de la colección, utilizando el `FindComputer` delegado de predicado.|  
  
 [!code-csharp[List\`1_Find_Methods#1](~/samples/snippets/csharp/VS_Snippets_CLR/list`1_find_methods/cs/program.cs#1)]
 [!code-vb[List\`1_Find_Methods#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/list`1_find_methods/vb/module1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="match" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startIndex" /> está fuera del intervalo de índices válidos para <see cref="T:System.Collections.Generic.List`1" />.  
  
O bien 
 <paramref name="count" /> es menor que 0.  
  
O bien 
 <paramref name="startIndex" /> y <paramref name="count" /> no especifican una sección válida en <see cref="T:System.Collections.Generic.List`1" />.</exception>
        <altmember cref="M:System.Collections.Generic.List`1.Exists(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.Find(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.FindLast(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.FindAll(System.Predicate{`0})" />
        <altmember cref="Overload:System.Collections.Generic.List`1.FindIndex" />
        <altmember cref="Overload:System.Collections.Generic.List`1.BinarySearch" />
        <altmember cref="Overload:System.Collections.Generic.List`1.IndexOf" />
        <altmember cref="Overload:System.Collections.Generic.List`1.LastIndexOf" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
    <Member MemberName="ForEach">
      <MemberSignature Language="C#" Value="public void ForEach (Action&lt;T&gt; action);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ForEach(class System.Action`1&lt;!T&gt; action) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.ForEach(System.Action{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Sub ForEach (action As Action(Of T))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ForEach(Action&lt;T&gt; ^ action);" />
      <MemberSignature Language="F#" Value="member this.ForEach : Action&lt;'T&gt; -&gt; unit" Usage="list.ForEach action" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="action" Type="System.Action&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="action">Delegado <see cref="T:System.Action`1" /> para realizar la acción en cada elemento de <see cref="T:System.Collections.Generic.List`1" />.</param>
        <summary>Realiza la acción especificada en cada elemento de <see cref="T:System.Collections.Generic.List`1" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Action%601> se pasa un delegado a un método que realiza una acción en el objeto.  Los elementos del elemento actual <xref:System.Collections.Generic.List%601> individualmente se pasan a la <xref:System.Action%601> delegar.  
  
 Este método es O (*n*) operación, donde *n* es <xref:System.Collections.Generic.List%601.Count%2A>.  
  
 Modificar la colección subyacente en el cuerpo de la <xref:System.Action%601> delegado no se admite y produce un comportamiento indefinido.  
  
   
  
## Examples  
 En el ejemplo siguiente se muestra el uso de la <xref:System.Action%601> delegado para imprimir el contenido de un <xref:System.Collections.Generic.List%601> objeto. En este ejemplo el `Print` método se usa para mostrar el contenido de la lista en la consola.  
  
> [!NOTE]
>  Además de mostrar el contenido mediante el `Print` método, el ejemplo C# muestra el uso de para mostrar los resultados en la consola.  
  
 [!code-csharp[System.Action_PrintExample#01](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Action_PrintExample/cs/action.cs#01)]
 [!code-vb[System.Action_PrintExample#01](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Action_PrintExample/vb/action.vb#01)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="action" /> es <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Se ha modificado un elemento de la colección.</exception>
        <altmember cref="T:System.Action`1" />
      </Docs>
    </Member>
    <Member MemberName="GetEnumerator">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.List&lt;T&gt;.Enumerator GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Collections.Generic.List`1/Enumerator&lt;!T&gt; GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Public Function GetEnumerator () As List(Of T).Enumerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::List&lt;T&gt;::Enumerator GetEnumerator();" />
      <MemberSignature Language="F#" Value="member this.GetEnumerator : unit -&gt; System.Collections.Generic.List&lt;'T&gt;.Enumerator" Usage="list.GetEnumerator " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.List&lt;T&gt;+Enumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Devuelve un enumerador que recorre en iteración la colección <see cref="T:System.Collections.Generic.List`1" />.</summary>
        <returns>Estructura <see cref="T:System.Collections.Generic.List`1.Enumerator" /> para la colección <see cref="T:System.Collections.Generic.List`1" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El `foreach` instrucción del lenguaje C# (`for each` en C++, `For Each` en Visual Basic) oculta la complejidad de los enumeradores. Por lo tanto, se recomienda el uso de `foreach`, en lugar de manipular directamente el enumerador.  
  
 Los enumeradores pueden usarse para leer los datos de la colección, pero no para modificar la colección subyacente.  
  
 En principio, el enumerador se coloca antes del primer elemento de la colección. En esta posición, el <xref:System.Collections.Generic.List%601.Enumerator.Current%2A> propiedad no está definida. Por lo tanto, debe llamar a la <xref:System.Collections.Generic.List%601.Enumerator.MoveNext%2A> método para hacer avanzar el enumerador hasta el primer elemento de la colección antes de leer el valor de <xref:System.Collections.Generic.List%601.Enumerator.Current%2A>.  
  
 El <xref:System.Collections.Generic.List%601.Enumerator.Current%2A> propiedad devuelve el mismo objeto hasta que <xref:System.Collections.Generic.List%601.Enumerator.MoveNext%2A> se llama. <xref:System.Collections.Generic.List%601.Enumerator.MoveNext%2A> establece <xref:System.Collections.Generic.List%601.Enumerator.Current%2A> en el siguiente elemento.  
  
 Si <xref:System.Collections.Generic.List%601.Enumerator.MoveNext%2A> pasa el final de la colección, el enumerador se coloca después del último elemento de la colección y <xref:System.Collections.Generic.List%601.Enumerator.MoveNext%2A> devuelve `false`. Cuando el enumerador está en esta posición, las llamadas subsiguientes a <xref:System.Collections.Generic.List%601.Enumerator.MoveNext%2A> también devolver `false`. Si la última llamada a <xref:System.Collections.Generic.List%601.Enumerator.MoveNext%2A> devuelve `false`, <xref:System.Collections.Generic.List%601.Enumerator.Current%2A> es indefinido. No puede volver a establecer la propiedad <xref:System.Collections.Generic.List%601.Enumerator.Current%2A> en el primer elemento de la colección, sino que debe crear una nueva instancia del enumerador.  
  
 Un enumerador es válido mientras la colección no cambie. Si se realizan cambios en la colección, como agregar, modificar, o eliminar elementos, el enumerador queda invalida invalidado y la siguiente llamada a <xref:System.Collections.Generic.List%601.Enumerator.MoveNext%2A> o <xref:System.Collections.Generic.List%601.Enumerator.System%23Collections%23IEnumerator%23Reset%2A> produce una <xref:System.InvalidOperationException>.  
  
 El enumerador no tiene acceso exclusivo a la colección y, por tanto, la enumeración en una colección no es intrínsicamente un procedimiento seguro para subprocesos. A fin de garantizar la seguridad de los subprocesos, se puede bloquear la colección durante toda la enumeración.  Para permitir que varios subprocesos obtengan acceso de lectura y escritura a la colección, debe implementar su propia sincronización.  
  
 Las implementaciones predeterminadas de las colecciones del espacio de nombres <xref:System.Collections.Generic?displayProperty=nameWithType> no están sincronizadas.  
  
 Este método es una operación o (1).  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.Generic.List`1.Enumerator" />
        <altmember cref="T:System.Collections.Generic.IEnumerator`1" />
      </Docs>
    </Member>
    <Member MemberName="GetRange">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.List&lt;T&gt; GetRange (int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.List`1&lt;!T&gt; GetRange(int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.GetRange(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetRange (index As Integer, count As Integer) As List(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::List&lt;T&gt; ^ GetRange(int index, int count);" />
      <MemberSignature Language="F#" Value="member this.GetRange : int * int -&gt; System.Collections.Generic.List&lt;'T&gt;" Usage="list.GetRange (index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.List&lt;T&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">Índice de <see cref="T:System.Collections.Generic.List`1" /> de base cero en el que empieza el intervalo.</param>
        <param name="count">Número de elementos del intervalo.</param>
        <summary>Crea una copia superficial de un intervalo de elementos en la <see cref="T:System.Collections.Generic.List`1" /> de origen.</summary>
        <returns>Copia superficial de un intervalo de elementos en la <see cref="T:System.Collections.Generic.List`1" /> de origen.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Una copia superficial de una colección de tipos de referencia, o un subconjunto de dicha colección, contiene solo las referencias a los elementos de la colección. No se copian los propios objetos. Las referencias en la nueva lista apuntan a los mismos objetos que las referencias en la lista original.  
  
 Una copia superficial de una colección de tipos de valor o un subconjunto de dicha colección, contiene los elementos de la colección. Sin embargo, si los elementos de la colección contienen referencias a otros objetos, esos objetos no se copian. Las referencias de los elementos de la nueva colección apuntan a los mismos objetos que las referencias de los elementos de la colección original.  
  
 En cambio, una copia en profundidad de una colección copia los elementos y todo lo que hacen referencia directa o indirectamente los elementos.  
  
 Este método es O (*n*) operación, donde *n* es `count`.  
  
   
  
## Examples  
 En el ejemplo siguiente se muestra el <xref:System.Collections.Generic.List%601.GetRange%2A> método y otros métodos de la <xref:System.Collections.Generic.List%601> clases que actúan en intervalos. Al final del ejemplo, el <xref:System.Collections.Generic.List%601.GetRange%2A> método se usa para obtener tres elementos de la lista, empezando por la posición de índice 2. El <xref:System.Collections.Generic.List%601.ToArray%2A> se llama al método en resultante <xref:System.Collections.Generic.List%601>, creación de una matriz de tres elementos. Se muestran los elementos de la matriz.  
  
 [!code-cpp[List\`1_Ranges#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_Ranges/cpp/source.cpp#1)]
 [!code-csharp[List\`1_Ranges#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_Ranges/cs/source.cs#1)]
 [!code-vb[List\`1_Ranges#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_Ranges/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> es menor que 0.  
  
O bien 
 <paramref name="count" /> es menor que 0.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="index" /> y <paramref name="count" /> no denotan un intervalo válido de elementos en la <see cref="T:System.Collections.Generic.List`1" />.</exception>
        <altmember cref="M:System.Collections.Generic.List`1.RemoveRange(System.Int32,System.Int32)" />
        <altmember cref="M:System.Collections.Generic.List`1.AddRange(System.Collections.Generic.IEnumerable{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.InsertRange(System.Int32,System.Collections.Generic.IEnumerable{`0})" />
      </Docs>
    </Member>
    <MemberGroup MemberName="IndexOf">
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Devuelve el índice de base cero de la primera aparición de un valor en <see cref="T:System.Collections.Generic.List`1" /> o en una parte.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public int IndexOf (T item);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 IndexOf(!T item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.IndexOf(`0)" />
      <MemberSignature Language="VB.NET" Value="Public Function IndexOf (item As T) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int IndexOf(T item);" />
      <MemberSignature Language="F#" Value="abstract member IndexOf : 'T -&gt; int&#xA;override this.IndexOf : 'T -&gt; int" Usage="list.IndexOf item" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.IList`1.IndexOf(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="T" />
      </Parameters>
      <Docs>
        <param name="item">Objeto que se va a buscar en <see cref="T:System.Collections.Generic.List`1" />. El valor puede ser <see langword="null" /> para los tipos de referencia.</param>
        <summary>Busca el objeto especificado y devuelve el índice de base cero de la primera aparición en todo el objeto <see cref="T:System.Collections.Generic.List`1" />.</summary>
        <returns>Índice de base cero de la primera aparición de <paramref name="item" /> en la totalidad de <see cref="T:System.Collections.Generic.List`1" />, si se encuentra; en caso contrario, -1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Collections.Generic.List%601> se buscará hacia delante a partir del primer elemento y terminando en el último elemento.  
  
 Este método determina la igualdad utilizando el comparador de igualdad predeterminado <xref:System.Collections.Generic.EqualityComparer%601.Default%2A?displayProperty=nameWithType> para `T`, el tipo de valores en la lista.  
  
 Este método realiza una búsqueda lineal; por lo tanto, este método es O (*n*) operación, donde *n* es <xref:System.Collections.Generic.List%601.Count%2A>.  
  
   
  
## Examples  
 El ejemplo siguiente muestra las tres sobrecargas de los <xref:System.Collections.Generic.List%601.IndexOf%2A> método. Un <xref:System.Collections.Generic.List%601> de cadenas se crea con una entrada que aparece dos veces, en la ubicación de índice 0 y la ubicación de índice 5. El <xref:System.Collections.Generic.List%601.IndexOf%28%600%29> sobrecarga del método busca en la lista desde el principio y busca la primera aparición de la cadena. El <xref:System.Collections.Generic.List%601.IndexOf%28%600%2CSystem.Int32%29> sobrecarga del método se utiliza para buscar la lista comenzando en la posición de índice 3 y continuando hasta el final de la lista y encuentra la segunda aparición de la cadena. Por último, el <xref:System.Collections.Generic.List%601.IndexOf%28%600%2CSystem.Int32%2CSystem.Int32%29> sobrecarga del método se utiliza para buscar un intervalo de dos entradas, comenzando en la posición de índice dos; devuelve -1 porque no hay ninguna instancia de la cadena de búsqueda en ese intervalo.  
  
 [!code-cpp[List\`1_IndexOf#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_IndexOf/cpp/source.cpp#1)]
 [!code-csharp[List\`1_IndexOf#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_IndexOf/cs/source.cs#1)]
 [!code-vb[List\`1_IndexOf#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_IndexOf/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Collections.Generic.List`1.LastIndexOf(`0)" />
        <altmember cref="M:System.Collections.Generic.List`1.Contains(`0)" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-collections.md">Realizar operaciones de cadenas que no tienen en cuenta las referencias culturales en colecciones</related>
      </Docs>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public int IndexOf (T item, int index);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOf(!T item, int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.IndexOf(`0,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function IndexOf (item As T, index As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IndexOf(T item, int index);" />
      <MemberSignature Language="F#" Value="member this.IndexOf : 'T * int -&gt; int" Usage="list.IndexOf (item, index)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="T" />
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="item">Objeto que se va a buscar en <see cref="T:System.Collections.Generic.List`1" />. El valor puede ser <see langword="null" /> para los tipos de referencia.</param>
        <param name="index">Índice inicial de base cero de la búsqueda. 0 (cero) es válido en una lista vacía.</param>
        <summary>Busca el objeto especificado y devuelve el índice de base cero de la primera aparición dentro del intervalo de elementos de <see cref="T:System.Collections.Generic.List`1" /> que abarca desde el índice especificado hasta el último elemento.</summary>
        <returns>Índice de base cero de la primera aparición de <paramref name="item" /> dentro del intervalo de elementos de <see cref="T:System.Collections.Generic.List`1" /> que abarca desde <paramref name="index" /> hasta el último elemento, si se encuentra; de lo contrario, -1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Collections.Generic.List%601> se buscará hacia delante, empezando en `index` y terminando en el último elemento.  
  
 Este método determina la igualdad utilizando el comparador de igualdad predeterminado <xref:System.Collections.Generic.EqualityComparer%601.Default%2A?displayProperty=nameWithType> para `T`, el tipo de valores en la lista.  
  
 Este método realiza una búsqueda lineal; por lo tanto, este método es O (*n*) operación, donde *n* es el número de elementos de `index` al final de la <xref:System.Collections.Generic.List%601>.  
  
   
  
## Examples  
 El ejemplo siguiente muestra las tres sobrecargas de los <xref:System.Collections.Generic.List%601.IndexOf%2A> método. Un <xref:System.Collections.Generic.List%601> de cadenas se crea con una entrada que aparece dos veces, en la ubicación de índice 0 y la ubicación de índice 5. El <xref:System.Collections.Generic.List%601.IndexOf%28%600%29> sobrecarga del método busca en la lista desde el principio y busca la primera aparición de la cadena. El <xref:System.Collections.Generic.List%601.IndexOf%28%600%2CSystem.Int32%29> sobrecarga del método se utiliza para buscar la lista comenzando en la posición de índice 3 y continuando hasta el final de la lista y encuentra la segunda aparición de la cadena. Por último, el <xref:System.Collections.Generic.List%601.IndexOf%28%600%2CSystem.Int32%2CSystem.Int32%29> sobrecarga del método se utiliza para buscar un intervalo de dos entradas, comenzando en la posición de índice dos; devuelve -1 porque no hay ninguna instancia de la cadena de búsqueda en ese intervalo.  
  
 [!code-cpp[List\`1_IndexOf#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_IndexOf/cpp/source.cpp#1)]
 [!code-csharp[List\`1_IndexOf#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_IndexOf/cs/source.cs#1)]
 [!code-vb[List\`1_IndexOf#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_IndexOf/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> está fuera del intervalo de índices válidos para <see cref="T:System.Collections.Generic.List`1" />.</exception>
        <altmember cref="M:System.Collections.Generic.List`1.LastIndexOf(`0)" />
        <altmember cref="M:System.Collections.Generic.List`1.Contains(`0)" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-collections.md">Realizar operaciones de cadenas que no tienen en cuenta las referencias culturales en colecciones</related>
      </Docs>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public int IndexOf (T item, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOf(!T item, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.IndexOf(`0,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function IndexOf (item As T, index As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IndexOf(T item, int index, int count);" />
      <MemberSignature Language="F#" Value="member this.IndexOf : 'T * int * int -&gt; int" Usage="list.IndexOf (item, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="T" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="item">Objeto que se va a buscar en <see cref="T:System.Collections.Generic.List`1" />. El valor puede ser <see langword="null" /> para los tipos de referencia.</param>
        <param name="index">Índice inicial de base cero de la búsqueda. 0 (cero) es válido en una lista vacía.</param>
        <param name="count">Número de elementos de la sección en la que se va a realizar la búsqueda.</param>
        <summary>Busca el objeto especificado y devuelve el índice de base cero de la primera aparición dentro del intervalo de elementos de <see cref="T:System.Collections.Generic.List`1" /> que comienza en el índice especificado y contiene el número especificado de elementos.</summary>
        <returns>Índice de base cero de la primera aparición de <paramref name="item" /> dentro del intervalo de elementos de <see cref="T:System.Collections.Generic.List`1" /> que comienza en <paramref name="index" /> y contiene el número de elementos de <paramref name="count" />, si se encuentra; de lo contrario, -1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Collections.Generic.List%601> se buscará hacia delante, empezando en `index` hasta `index` plus `count` menos 1, si `count` es mayor que 0.  
  
 Este método determina la igualdad utilizando el comparador de igualdad predeterminado <xref:System.Collections.Generic.EqualityComparer%601.Default%2A?displayProperty=nameWithType> para `T`, el tipo de valores en la lista.  
  
 Este método realiza una búsqueda lineal; por lo tanto, este método es O (*n*) operación, donde *n* es `count`.  
  
   
  
## Examples  
 El ejemplo siguiente muestra las tres sobrecargas de los <xref:System.Collections.Generic.List%601.IndexOf%2A> método. Un <xref:System.Collections.Generic.List%601> de cadenas se crea con una entrada que aparece dos veces, en la ubicación de índice 0 y la ubicación de índice 5. El <xref:System.Collections.Generic.List%601.IndexOf%28%600%29> sobrecarga del método busca en la lista desde el principio y busca la primera aparición de la cadena. El <xref:System.Collections.Generic.List%601.IndexOf%28%600%2CSystem.Int32%29> sobrecarga del método se utiliza para buscar la lista comenzando en la posición de índice 3 y continuando hasta el final de la lista y encuentra la segunda aparición de la cadena. Por último, el <xref:System.Collections.Generic.List%601.IndexOf%28%600%2CSystem.Int32%2CSystem.Int32%29> sobrecarga del método se utiliza para buscar un intervalo de dos entradas, comenzando en la posición de índice dos; devuelve -1 porque no hay ninguna instancia de la cadena de búsqueda en ese intervalo.  
  
 [!code-cpp[List\`1_IndexOf#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_IndexOf/cpp/source.cpp#1)]
 [!code-csharp[List\`1_IndexOf#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_IndexOf/cs/source.cs#1)]
 [!code-vb[List\`1_IndexOf#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_IndexOf/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> está fuera del intervalo de índices válidos para <see cref="T:System.Collections.Generic.List`1" />.  
  
O bien 
 <paramref name="count" /> es menor que 0.  
  
O bien 
 <paramref name="index" /> y <paramref name="count" /> no especifican una sección válida en <see cref="T:System.Collections.Generic.List`1" />.</exception>
        <altmember cref="M:System.Collections.Generic.List`1.LastIndexOf(`0)" />
        <altmember cref="M:System.Collections.Generic.List`1.Contains(`0)" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-collections.md">Realizar operaciones de cadenas que no tienen en cuenta las referencias culturales en colecciones</related>
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public void Insert (int index, T item);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Insert(int32 index, !T item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.Insert(System.Int32,`0)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Insert (index As Integer, item As T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Insert(int index, T item);" />
      <MemberSignature Language="F#" Value="abstract member Insert : int * 'T -&gt; unit&#xA;override this.Insert : int * 'T -&gt; unit" Usage="list.Insert (index, item)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.IList`1.Insert(System.Int32,`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="item" Type="T" />
      </Parameters>
      <Docs>
        <param name="index">Índice basado en cero en el que debe insertarse <paramref name="item" />.</param>
        <param name="item">Objeto que se va a insertar. El valor puede ser <see langword="null" /> para los tipos de referencia.</param>
        <summary>Inserta un elemento en <see cref="T:System.Collections.Generic.List`1" />, en el índice especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.Generic.List%601> acepta `null` como un valor válido para la referencia de tipos y permite elementos duplicados.  
  
 Si <xref:System.Collections.Generic.List%601.Count%2A> ya es igual a <xref:System.Collections.Generic.List%601.Capacity%2A>, la capacidad de la <xref:System.Collections.Generic.List%601> incrementando reasignación automática de la matriz interna, y se copian los elementos existentes en la nueva matriz antes de agrega el nuevo elemento.  
  
 Si `index` es igual a <xref:System.Collections.Generic.List%601.Count%2A>, `item` se agrega al final de <xref:System.Collections.Generic.List%601>.  
  
 Este método es O (*n*) operación, donde *n* es <xref:System.Collections.Generic.List%601.Count%2A>.  
  
   
  
## Examples  
 En el ejemplo siguiente se muestra cómo agregar, quitar e insertar un objeto comercial simple en un <xref:System.Collections.Generic.List%601>.  
  
 [!code-csharp[System.Collections.Generic.List.AddRemoveInsert#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.collections.generic.list.addremoveinsert/cs/program.cs#1)]
 [!code-vb[System.Collections.Generic.List.AddRemoveInsert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.collections.generic.list.addremoveinsert/vb/module1.vb#1)]  
 [!code-fsharp[System.Collections.Generic.List.AddRemoveInsert#1](~/samples/snippets/fsharp/VS_Snippets_CLR_System/system.collections.generic.list.addremoveinsert/fs/addremoveinsert.fs#1)]
  
 En el ejemplo siguiente se muestra el <xref:System.Collections.Generic.List%601.Insert%2A> método, junto con otras propiedades y métodos de la <xref:System.Collections.Generic.List%601> clase genérica. Una vez creada la lista, se agregan elementos. El <xref:System.Collections.Generic.List%601.Insert%2A> método se utiliza para insertar un elemento en la mitad de la lista. El elemento insertado es un duplicado, que se quita más tarde mediante el <xref:System.Collections.Generic.List%601.Remove%2A> método.  
  
 [!code-cpp[List\`1_Class#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_Class/cpp/source.cpp#1)]
 [!code-csharp[List\`1_Class#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_Class/cs/source.cs#1)]
 [!code-vb[List\`1_Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_Class/vb/source.vb#1)]  
 [!code-fsharp[List\`1_Class#1](~/samples/snippets/fsharp/VS_Snippets_CLR/List`1_Class/fs/listclass.fs#1)]
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> es menor que 0.  
  
O bien 
 <paramref name="index" /> es mayor que <see cref="P:System.Collections.Generic.List`1.Count" />.</exception>
        <altmember cref="M:System.Collections.Generic.List`1.InsertRange(System.Int32,System.Collections.Generic.IEnumerable{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.Add(`0)" />
        <altmember cref="M:System.Collections.Generic.List`1.Remove(`0)" />
      </Docs>
    </Member>
    <Member MemberName="InsertRange">
      <MemberSignature Language="C#" Value="public void InsertRange (int index, System.Collections.Generic.IEnumerable&lt;T&gt; collection);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void InsertRange(int32 index, class System.Collections.Generic.IEnumerable`1&lt;!T&gt; collection) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.InsertRange(System.Int32,System.Collections.Generic.IEnumerable{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Sub InsertRange (index As Integer, collection As IEnumerable(Of T))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void InsertRange(int index, System::Collections::Generic::IEnumerable&lt;T&gt; ^ collection);" />
      <MemberSignature Language="F#" Value="member this.InsertRange : int * seq&lt;'T&gt; -&gt; unit" Usage="list.InsertRange (index, collection)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="collection" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="index">Índice de base cero donde se deben insertar los nuevos elementos.</param>
        <param name="collection">Colección cuyos elementos se deben insertar en <see cref="T:System.Collections.Generic.List`1" />. La propia colección no puede ser <see langword="null" />, pero puede contener elementos que sean <see langword="null" /> si el tipo <paramref name="T" /> es un tipo de referencia.</param>
        <summary>Inserta los elementos de una colección en <see cref="T:System.Collections.Generic.List`1" /> en el índice especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.Generic.List%601> acepta `null` como un valor válido para la referencia de tipos y permite elementos duplicados.  
  
 Si el nuevo <xref:System.Collections.Generic.List%601.Count%2A> (actual <xref:System.Collections.Generic.List%601.Count%2A> más el tamaño de la colección) será mayor que <xref:System.Collections.Generic.List%601.Capacity%2A>, la capacidad de la <xref:System.Collections.Generic.List%601> incrementando reasignación automática de la matriz interna para dar cabida a los nuevos elementos y la los elementos existentes se copian en la nueva matriz antes de que se agregan los nuevos elementos.  
  
 Si `index` es igual a <xref:System.Collections.Generic.List%601.Count%2A>, los elementos se agregan al final de <xref:System.Collections.Generic.List%601>.  
  
 Se conserva el orden de los elementos de la colección en el <xref:System.Collections.Generic.List%601>.  
  
 Este método es O (*n* * *m*) operación, donde *n* es el número de elementos que se agregarán y *m* es <xref:System.Collections.Generic.List%601.Count%2A>.  
  
   
  
## Examples  
 En el ejemplo siguiente se muestra <xref:System.Collections.Generic.List%601.InsertRange%2A> método y otros métodos de la <xref:System.Collections.Generic.List%601> clases que actúan en intervalos. Después de haber creado y rellenado con los nombres de varios pacíficas comer de planta dinosaurios, la lista el <xref:System.Collections.Generic.List%601.InsertRange%2A> método se utiliza para insertar una matriz de tres dinosaurios feroces comer de carne en la lista, comenzando en la posición de índice 3.  
  
 [!code-cpp[List\`1_Ranges#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_Ranges/cpp/source.cpp#1)]
 [!code-csharp[List\`1_Ranges#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_Ranges/cs/source.cs#1)]
 [!code-vb[List\`1_Ranges#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_Ranges/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="collection" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> es menor que 0.  
  
O bien 
 <paramref name="index" /> es mayor que <see cref="P:System.Collections.Generic.List`1.Count" />.</exception>
        <altmember cref="M:System.Collections.Generic.List`1.Insert(System.Int32,`0)" />
        <altmember cref="M:System.Collections.Generic.List`1.AddRange(System.Collections.Generic.IEnumerable{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.GetRange(System.Int32,System.Int32)" />
        <altmember cref="M:System.Collections.Generic.List`1.RemoveRange(System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Item">
      <MemberSignature Language="C#" Value="public T this[int index] { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance !T Item(int32)" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.List`1.Item(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Default Public Property Item(index As Integer) As T" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property T default[int] { T get(int index); void set(int index, T value); };" />
      <MemberSignature Language="F#" Value="member this.Item(int) : 'T with get, set" Usage="System.Collections.Generic.List&lt;'T&gt;.Item" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.Generic.IList`1.Item(System.Int32)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">Índice de base cero del elemento que se va a obtener o establecer.</param>
        <summary>Obtiene o establece el elemento en el índice especificado.</summary>
        <value>Elemento en el índice especificado.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.Generic.List%601> acepta `null` como un valor válido para la referencia de tipos y permite elementos duplicados.  
  
 Esta propiedad permite obtener acceso a un elemento específico de la colección utilizando la sintaxis siguiente: `myCollection[index]`.  
  
 Recuperar el valor de esta propiedad es una operación o (1); establecer la propiedad también es una operación o (1).  
  
   
  
## Examples  
 El ejemplo de esta sección se muestra el <xref:System.Collections.Generic.List%601.Item%2A> propiedad (el indizador en C#) y varias otras propiedades y métodos de la <xref:System.Collections.Generic.List%601> clase genérica. Después de la lista crean y rellenan con el <xref:System.Collections.Generic.List%601.Add%2A> método, un elemento se recupera y muestra el uso de la <xref:System.Collections.Generic.List%601.Item%2A> propiedad. (Para obtener un ejemplo que usa el <xref:System.Collections.Generic.List%601.Item%2A> propiedad para establecer el valor de un elemento de lista, consulte <xref:System.Collections.Generic.List%601.AsReadOnly%2A>.)  
  
> [!NOTE]
>  Visual Basic, C# y C++ todas tienen la sintaxis para tener acceso a la <xref:System.Collections.Generic.List%601.Item%2A> propiedad sin utilizar su nombre. En su lugar, la variable que contiene el <xref:System.Collections.Generic.List%601> se usa como si fuera una matriz.  
  
 El C# lenguaje usa el [ `this` ](~/docs/csharp/language-reference/keywords/this.md) palabra clave para definir los indizadores en lugar de implementar la <xref:System.Collections.Generic.List%601.Item%2A> propiedad. Visual Basic implementa <xref:System.Collections.Generic.List%601.Item%2A> como propiedad predeterminada, lo que proporciona la misma funcionalidad de indización.  
  
 [!code-csharp[List`1_Class#2](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_Class/cs/source.cs#2)]
 [!code-vb[List`1_Class#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_Class/vb/source.vb#2)]  
[!code-csharp[List`1_Class#3](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_Class/cs/source.cs#3)]
[!code-vb[List`1_Class#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_Class/vb/source.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> es menor que 0.  
  
O bien 
 <paramref name="index" /> es igual o mayor que <see cref="P:System.Collections.Generic.List`1.Count" />.</exception>
        <altmember cref="P:System.Collections.Generic.List`1.Count" />
      </Docs>
    </Member>
    <MemberGroup MemberName="LastIndexOf">
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Devuelve el índice de base cero de la última aparición de un valor en la <see cref="T:System.Collections.Generic.List`1" /> o en una parte de ella.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public int LastIndexOf (T item);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LastIndexOf(!T item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.LastIndexOf(`0)" />
      <MemberSignature Language="VB.NET" Value="Public Function LastIndexOf (item As T) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int LastIndexOf(T item);" />
      <MemberSignature Language="F#" Value="member this.LastIndexOf : 'T -&gt; int" Usage="list.LastIndexOf item" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="T" />
      </Parameters>
      <Docs>
        <param name="item">Objeto que se va a buscar en <see cref="T:System.Collections.Generic.List`1" />. El valor puede ser <see langword="null" /> para los tipos de referencia.</param>
        <summary>Busca el objeto especificado y devuelve el índice de base cero de la última aparición en toda la <see cref="T:System.Collections.Generic.List`1" />.</summary>
        <returns>Índice de base cero de la última aparición de <paramref name="item" /> en todo el objeto <see cref="T:System.Collections.Generic.List`1" />, si se encuentra; en caso contrario, -1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Collections.Generic.List%601> se realiza hacia atrás a partir del último elemento y terminando en el primer elemento.  
  
 Este método determina la igualdad utilizando el comparador de igualdad predeterminado <xref:System.Collections.Generic.EqualityComparer%601.Default%2A?displayProperty=nameWithType> para `T`, el tipo de valores en la lista.  
  
 Este método realiza una búsqueda lineal; por lo tanto, este método es O (*n*) operación, donde *n* es <xref:System.Collections.Generic.List%601.Count%2A>.  
  
   
  
## Examples  
 El ejemplo siguiente muestra las tres sobrecargas de los <xref:System.Collections.Generic.List%601.LastIndexOf%2A> método. Un <xref:System.Collections.Generic.List%601> de cadenas se crea con una entrada que aparece dos veces, en la ubicación de índice 0 y la ubicación de índice 5. El <xref:System.Collections.Generic.List%601.LastIndexOf%28%600%29> sobrecarga del método busca en toda la lista desde el final y encuentra la segunda aparición de la cadena. El <xref:System.Collections.Generic.List%601.LastIndexOf%28%600%2CSystem.Int32%29> sobrecarga del método se usa para buscar la lista hacia atrás, empezando por la posición de índice 3 y continuando hasta el principio de la lista, por lo que busca la primera aparición de la cadena en la lista. Por último, el <xref:System.Collections.Generic.List%601.LastIndexOf%28%600%2CSystem.Int32%2CSystem.Int32%29> sobrecarga del método se utiliza para buscar un intervalo de cuatro entradas, comenzando en la posición de índice 4 y avanzando hacia atrás (es decir, busca los elementos en ubicaciones 1, 2, 3 y 4); esta búsqueda devuelve -1 porque no hay ninguna instancia de la búsqueda cadena en ese intervalo.  
  
 [!code-cpp[List\`1_LastIndexOf#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_LastIndexOf/cpp/source.cpp#1)]
 [!code-csharp[List\`1_LastIndexOf#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_LastIndexOf/cs/source.cs#1)]
 [!code-vb[List\`1_LastIndexOf#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_LastIndexOf/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Collections.Generic.List`1.IndexOf(`0)" />
        <altmember cref="M:System.Collections.Generic.List`1.Contains(`0)" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-collections.md">Realizar operaciones de cadenas que no tienen en cuenta las referencias culturales en colecciones</related>
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public int LastIndexOf (T item, int index);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LastIndexOf(!T item, int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.LastIndexOf(`0,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function LastIndexOf (item As T, index As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int LastIndexOf(T item, int index);" />
      <MemberSignature Language="F#" Value="member this.LastIndexOf : 'T * int -&gt; int" Usage="list.LastIndexOf (item, index)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="T" />
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="item">Objeto que se va a buscar en <see cref="T:System.Collections.Generic.List`1" />. El valor puede ser <see langword="null" /> para los tipos de referencia.</param>
        <param name="index">Índice inicial de base cero de la búsqueda hacia atrás.</param>
        <summary>Busca el objeto especificado y devuelve el índice de base cero de la última aparición dentro del intervalo de elementos de <see cref="T:System.Collections.Generic.List`1" /> que abarca desde el primer elemento hasta el último índice especificado.</summary>
        <returns>Índice de base cero de la última aparición de <paramref name="item" /> dentro del intervalo de elementos de <see cref="T:System.Collections.Generic.List`1" /> que abarca desde el primer elemento hasta <paramref name="index" />, si se encuentra; de lo contrario, -1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Collections.Generic.List%601> es la búsqueda hacia atrás, empezando en `index` y terminando en el primer elemento.  
  
 Este método determina la igualdad utilizando el comparador de igualdad predeterminado <xref:System.Collections.Generic.EqualityComparer%601.Default%2A?displayProperty=nameWithType> para `T`, el tipo de valores en la lista.  
  
 Este método realiza una búsqueda lineal; por lo tanto, este método es O (*n*) operación, donde *n* es el número de elementos desde el principio de la <xref:System.Collections.Generic.List%601> a `index`.  
  
   
  
## Examples  
 El ejemplo siguiente muestra las tres sobrecargas de los <xref:System.Collections.Generic.List%601.LastIndexOf%2A> método. Un <xref:System.Collections.Generic.List%601> de cadenas se crea con una entrada que aparece dos veces, en la ubicación de índice 0 y la ubicación de índice 5. El <xref:System.Collections.Generic.List%601.LastIndexOf%28%600%29> sobrecarga del método busca en toda la lista desde el final y encuentra la segunda aparición de la cadena. El <xref:System.Collections.Generic.List%601.LastIndexOf%28%600%2CSystem.Int32%29> sobrecarga del método se usa para buscar la lista hacia atrás, empezando por la posición de índice 3 y continuando hasta el principio de la lista, por lo que busca la primera aparición de la cadena en la lista. Por último, el <xref:System.Collections.Generic.List%601.LastIndexOf%28%600%2CSystem.Int32%2CSystem.Int32%29> sobrecarga del método se utiliza para buscar un intervalo de cuatro entradas, comenzando en la posición de índice 4 y avanzando hacia atrás (es decir, busca los elementos en ubicaciones 1, 2, 3 y 4); esta búsqueda devuelve -1 porque no hay ninguna instancia de la búsqueda cadena en ese intervalo.  
  
 [!code-cpp[List\`1_LastIndexOf#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_LastIndexOf/cpp/source.cpp#1)]
 [!code-csharp[List\`1_LastIndexOf#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_LastIndexOf/cs/source.cs#1)]
 [!code-vb[List\`1_LastIndexOf#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_LastIndexOf/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> está fuera del intervalo de índices válidos para <see cref="T:System.Collections.Generic.List`1" />.</exception>
        <altmember cref="M:System.Collections.Generic.List`1.IndexOf(`0)" />
        <altmember cref="M:System.Collections.Generic.List`1.Contains(`0)" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-collections.md">Realizar operaciones de cadenas que no tienen en cuenta las referencias culturales en colecciones</related>
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public int LastIndexOf (T item, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LastIndexOf(!T item, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.LastIndexOf(`0,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function LastIndexOf (item As T, index As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int LastIndexOf(T item, int index, int count);" />
      <MemberSignature Language="F#" Value="member this.LastIndexOf : 'T * int * int -&gt; int" Usage="list.LastIndexOf (item, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="T" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="item">Objeto que se va a buscar en <see cref="T:System.Collections.Generic.List`1" />. El valor puede ser <see langword="null" /> para los tipos de referencia.</param>
        <param name="index">Índice inicial de base cero de la búsqueda hacia atrás.</param>
        <param name="count">Número de elementos de la sección en la que se va a realizar la búsqueda.</param>
        <summary>Busca el objeto especificado y devuelve el índice de base cero de la última aparición dentro del intervalo de elementos de <see cref="T:System.Collections.Generic.List`1" /> que contiene el número de elementos especificado y termina en el índice determinado.</summary>
        <returns>Índice de base cero de la última aparición de <paramref name="item" /> dentro del intervalo de elementos de <see cref="T:System.Collections.Generic.List`1" /> que contiene el número de elementos de <paramref name="count" /> y termina en <paramref name="index" />, si se encuentra; de lo contrario, -1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Collections.Generic.List%601> es la búsqueda hacia atrás, empezando en `index` hasta `index` menos `count` más 1, si `count` es mayor que 0.  
  
 Este método determina la igualdad utilizando el comparador de igualdad predeterminado <xref:System.Collections.Generic.EqualityComparer%601.Default%2A?displayProperty=nameWithType> para `T`, el tipo de valores en la lista.  
  
 Este método realiza una búsqueda lineal; por lo tanto, este método es O (*n*) operación, donde *n* es `count`.  
  
   
  
## Examples  
 El ejemplo siguiente muestra las tres sobrecargas de los <xref:System.Collections.Generic.List%601.LastIndexOf%2A> método. Un <xref:System.Collections.Generic.List%601> de cadenas se crea con una entrada que aparece dos veces, en la ubicación de índice 0 y la ubicación de índice 5. El <xref:System.Collections.Generic.List%601.LastIndexOf%28%600%29> sobrecarga del método busca en toda la lista desde el final y encuentra la segunda aparición de la cadena. El <xref:System.Collections.Generic.List%601.LastIndexOf%28%600%2CSystem.Int32%29> sobrecarga del método se usa para buscar la lista hacia atrás, empezando por la posición de índice 3 y continuando hasta el principio de la lista, por lo que busca la primera aparición de la cadena en la lista. Por último, el <xref:System.Collections.Generic.List%601.LastIndexOf%28%600%2CSystem.Int32%2CSystem.Int32%29> sobrecarga del método se utiliza para buscar un intervalo de 4 entradas, comenzando en la posición de índice 4 y avanzando hacia atrás (es decir, busca los elementos en ubicaciones 1, 2, 3 y 4); esta búsqueda devuelve -1 porque no hay ninguna instancia de la búsqueda cadena en ese intervalo.  
  
 [!code-cpp[List\`1_LastIndexOf#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_LastIndexOf/cpp/source.cpp#1)]
 [!code-csharp[List\`1_LastIndexOf#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_LastIndexOf/cs/source.cs#1)]
 [!code-vb[List\`1_LastIndexOf#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_LastIndexOf/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> está fuera del intervalo de índices válidos para <see cref="T:System.Collections.Generic.List`1" />.  
  
O bien 
 <paramref name="count" /> es menor que 0.  
  
O bien 
 <paramref name="index" /> y <paramref name="count" /> no especifican una sección válida en <see cref="T:System.Collections.Generic.List`1" />.</exception>
        <altmember cref="M:System.Collections.Generic.List`1.IndexOf(`0)" />
        <altmember cref="M:System.Collections.Generic.List`1.Contains(`0)" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-collections.md">Realizar operaciones de cadenas que no tienen en cuenta las referencias culturales en colecciones</related>
      </Docs>
    </Member>
    <Member MemberName="Remove">
      <MemberSignature Language="C#" Value="public bool Remove (T item);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Remove(!T item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.Remove(`0)" />
      <MemberSignature Language="VB.NET" Value="Public Function Remove (item As T) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Remove(T item);" />
      <MemberSignature Language="F#" Value="abstract member Remove : 'T -&gt; bool&#xA;override this.Remove : 'T -&gt; bool" Usage="list.Remove item" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.ICollection`1.Remove(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="T" />
      </Parameters>
      <Docs>
        <param name="item">Objeto que se va a quitar de <see cref="T:System.Collections.Generic.List`1" />. El valor puede ser <see langword="null" /> para los tipos de referencia.</param>
        <summary>Quita la primera aparición de un objeto específico de la interfaz <see cref="T:System.Collections.Generic.List`1" />.</summary>
        <returns>Es <see langword="true" /> si <paramref name="item" /> se quita correctamente; en caso contrario, es <see langword="false" />.  Este método también devuelve <see langword="false" /> si no se encuentra <paramref name="item" /> en <see cref="T:System.Collections.Generic.List`1" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si tipo `T` implementa el <xref:System.IEquatable%601> interfaz genérica, el comparador de igualdad es el <xref:System.IEquatable%601.Equals%2A> método de dicha interfaz; en caso contrario, es el comparador de igualdad predeterminado <xref:System.Object.Equals%2A?displayProperty=nameWithType>.  
  
 Este método realiza una búsqueda lineal; por lo tanto, este método es O (*n*) operación, donde *n* es <xref:System.Collections.Generic.List%601.Count%2A>.  
  
   
  
## Examples  
 En el ejemplo siguiente se muestra cómo agregar, quitar e insertar un objeto comercial simple en un <xref:System.Collections.Generic.List%601>.  
  
 [!code-csharp[System.Collections.Generic.List.AddRemoveInsert#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.collections.generic.list.addremoveinsert/cs/program.cs#1)]
 [!code-vb[System.Collections.Generic.List.AddRemoveInsert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.collections.generic.list.addremoveinsert/vb/module1.vb#1)]  
 [!code-fsharp[System.Collections.Generic.List.AddRemoveInsert#1](~/samples/snippets/fsharp/VS_Snippets_CLR_System/system.collections.generic.list.addremoveinsert/fs/addremoveinsert.fs#1)]
  
 En el ejemplo siguiente se muestra <xref:System.Collections.Generic.List%601.Remove%2A> método. Varias propiedades y métodos de la <xref:System.Collections.Generic.List%601> clase genérica que se usan para agregar, insertar y buscar en la lista. Después de estas operaciones, la lista contiene un duplicado. El <xref:System.Collections.Generic.List%601.Remove%2A> método se usa para quitar la primera instancia del elemento duplicado y se muestra el contenido. El <xref:System.Collections.Generic.List%601.Remove%2A> método siempre quita la primera instancia que encuentra.  
  
 [!code-cpp[List\`1_Class#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_Class/cpp/source.cpp#1)]
 [!code-csharp[List\`1_Class#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_Class/cs/source.cs#1)]
 [!code-vb[List\`1_Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_Class/vb/source.vb#1)]  
 [!code-fsharp[List\`1_Class#1](~/samples/snippets/fsharp/VS_Snippets_CLR/List`1_Class/fs/listclass.fs#1)]
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Collections.Generic.List`1.RemoveAt(System.Int32)" />
        <altmember cref="M:System.Collections.Generic.List`1.RemoveRange(System.Int32,System.Int32)" />
        <altmember cref="M:System.Collections.Generic.List`1.Add(`0)" />
        <altmember cref="M:System.Collections.Generic.List`1.Insert(System.Int32,`0)" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-collections.md">Realizar operaciones de cadenas que no tienen en cuenta las referencias culturales en colecciones</related>
      </Docs>
    </Member>
    <Member MemberName="RemoveAll">
      <MemberSignature Language="C#" Value="public int RemoveAll (Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 RemoveAll(class System.Predicate`1&lt;!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.RemoveAll(System.Predicate{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Function RemoveAll (match As Predicate(Of T)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int RemoveAll(Predicate&lt;T&gt; ^ match);" />
      <MemberSignature Language="F#" Value="member this.RemoveAll : Predicate&lt;'T&gt; -&gt; int" Usage="list.RemoveAll match" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="match">Delegado <see cref="T:System.Predicate`1" /> que define las condiciones de los elementos que se van a quitar.</param>
        <summary>Quita todos los elementos que cumplen las condiciones definidas por el predicado especificado.</summary>
        <returns>Número de elementos que se han quitado de <see cref="T:System.Collections.Generic.List`1" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Predicate%601> es un delegado a un método que devuelve `true` si el objeto pasado a coincide con las condiciones definidas en el delegado.  Los elementos del elemento actual <xref:System.Collections.Generic.List%601> individualmente se pasan a la <xref:System.Predicate%601> delegado y los elementos que cumplen las condiciones se quitan de la <xref:System.Collections.Generic.List%601>.  
  
 Este método realiza una búsqueda lineal; por lo tanto, este método es O (*n*) operación, donde *n* es <xref:System.Collections.Generic.List%601.Count%2A>.  
  
   
  
## Examples  
 En el ejemplo siguiente se muestra el <xref:System.Collections.Generic.List%601.RemoveAll%2A> método y muchos otros métodos que utilizan el <xref:System.Predicate%601> delegado genérico.  
  
 Un <xref:System.Collections.Generic.List%601> de cadenas se crea, que contiene 8 nombres de dinosaurios, dos de los cuales (en las posiciones 1 y 5) terminan en "saurus". El ejemplo también define un método de predicado de búsqueda denominado `EndsWithSaurus`, que acepta un parámetro de cadena y devuelve un valor booleano que indica si la cadena de entrada termina en "saurus".  
  
 El <xref:System.Collections.Generic.List%601.Find%2A>, <xref:System.Collections.Generic.List%601.FindLast%2A>, y <xref:System.Collections.Generic.List%601.FindAll%2A> métodos se usan para buscar en la lista con el método de predicado de búsqueda.  
  
 El <xref:System.Collections.Generic.List%601.RemoveAll%2A> método se usa para quitar todas las entradas que terminan con "saurus". Recorre la lista desde el principio, pasando cada elemento a su vez a la `EndsWithSaurus` método. El elemento se quita si el `EndsWithSaurus` devuelve del método `true`.  
  
> [!NOTE]
>  En C# y Visual Basic, no es necesario crear la `Predicate<string>` delegar (`Predicate(Of String)` en Visual Basic) explícitamente. Estos lenguajes deducen al delegado correcto del contexto y lo creación automáticamente.  
  
 Por último, el <xref:System.Collections.Generic.List%601.Exists%2A> método verifica que no hay ninguna cadena de la lista que terminan en "saurus".  
  
 [!code-cpp[List\`1_FindEtAl#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_FindEtAl/cpp/source.cpp#1)]
 [!code-csharp[List\`1_FindEtAl#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_FindEtAl/cs/source.cs#1)]
 [!code-vb[List\`1_FindEtAl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_FindEtAl/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="match" /> es <see langword="null" />.</exception>
        <altmember cref="M:System.Collections.Generic.List`1.FindAll(System.Predicate{`0})" />
        <altmember cref="T:System.Predicate`1" />
        <altmember cref="M:System.Collections.Generic.List`1.Remove(`0)" />
        <altmember cref="M:System.Collections.Generic.List`1.RemoveAt(System.Int32)" />
        <altmember cref="M:System.Collections.Generic.List`1.RemoveRange(System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="RemoveAt">
      <MemberSignature Language="C#" Value="public void RemoveAt (int index);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void RemoveAt(int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.RemoveAt(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RemoveAt (index As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void RemoveAt(int index);" />
      <MemberSignature Language="F#" Value="abstract member RemoveAt : int -&gt; unit&#xA;override this.RemoveAt : int -&gt; unit" Usage="list.RemoveAt index" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.IList`1.RemoveAt(System.Int32)</InterfaceMember>
        <InterfaceMember>M:System.Collections.IList.RemoveAt(System.Int32)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">Índice de base cero del elemento que se va a quitar.</param>
        <summary>Quita el elemento situado en el índice especificado de <see cref="T:System.Collections.Generic.List`1" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cuando se llama a <xref:System.Collections.Generic.List%601.RemoveAt%2A> para quitar un elemento, se vuelven a numerar los elementos restantes en la lista para reemplazar el elemento quitado. Por ejemplo, si quita el elemento en el índice 3, el elemento situado en índice 4 se mueve a la posición 3. Además, el número de elementos de la lista (tal como está representada por el <xref:System.Collections.Generic.List%601.Count%2A> propiedad) se reduce en 1.  
  
 Este método es O (*n*) operación, donde *n* es (<xref:System.Collections.Generic.List%601.Count%2A> - `index`).  
  
   
  
## Examples  
 En el ejemplo siguiente se muestra cómo agregar, quitar e insertar un objeto comercial simple en un <xref:System.Collections.Generic.List%601>.  
  
 [!code-csharp[System.Collections.Generic.List.AddRemoveInsert#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.collections.generic.list.addremoveinsert/cs/program.cs#1)]
 [!code-vb[System.Collections.Generic.List.AddRemoveInsert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.collections.generic.list.addremoveinsert/vb/module1.vb#1)]  
 [!code-fsharp[System.Collections.Generic.List.AddRemoveInsert#1](~/samples/snippets/fsharp/VS_Snippets_CLR_System/system.collections.generic.list.addremoveinsert/fs/addremoveinsert.fs#1)]
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> es menor que 0.  
  
O bien 
 <paramref name="index" /> es igual o mayor que <see cref="P:System.Collections.Generic.List`1.Count" />.</exception>
        <altmember cref="M:System.Collections.Generic.List`1.Remove(`0)" />
        <altmember cref="M:System.Collections.Generic.List`1.RemoveRange(System.Int32,System.Int32)" />
        <altmember cref="M:System.Collections.Generic.List`1.Add(`0)" />
        <altmember cref="M:System.Collections.Generic.List`1.Insert(System.Int32,`0)" />
      </Docs>
    </Member>
    <Member MemberName="RemoveRange">
      <MemberSignature Language="C#" Value="public void RemoveRange (int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RemoveRange(int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.RemoveRange(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RemoveRange (index As Integer, count As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RemoveRange(int index, int count);" />
      <MemberSignature Language="F#" Value="member this.RemoveRange : int * int -&gt; unit" Usage="list.RemoveRange (index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">Índice inicial de base cero del intervalo de elementos que se va a quitar.</param>
        <param name="count">Número de elementos que se va a quitar.</param>
        <summary>Quita todos los elementos de <see cref="T:System.Collections.Generic.List`1" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se quitan los elementos y todos los elementos siguientes en el <xref:System.Collections.Generic.List%601> tienen sus índices reducidos en `count`.  
  
 Este método es O (*n*) operación, donde *n* es <xref:System.Collections.Generic.List%601.Count%2A>.  
  
   
  
## Examples  
 En el ejemplo siguiente se muestra el <xref:System.Collections.Generic.List%601.RemoveRange%2A> método y otros métodos de la <xref:System.Collections.Generic.List%601> clases que actúan en intervalos. Después de haber creado y modificado, la lista el <xref:System.Collections.Generic.List%601.RemoveRange%2A> método se usa para quitar dos elementos de la lista, comenzando en la posición de índice 2.  
  
 [!code-cpp[List\`1_Ranges#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_Ranges/cpp/source.cpp#1)]
 [!code-csharp[List\`1_Ranges#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_Ranges/cs/source.cs#1)]
 [!code-vb[List\`1_Ranges#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_Ranges/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> es menor que 0.  
  
O bien 
 <paramref name="count" /> es menor que 0.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="index" /> y <paramref name="count" /> no denotan un intervalo válido de elementos en la <see cref="T:System.Collections.Generic.List`1" />.</exception>
        <altmember cref="M:System.Collections.Generic.List`1.Remove(`0)" />
        <altmember cref="M:System.Collections.Generic.List`1.RemoveAt(System.Int32)" />
        <altmember cref="M:System.Collections.Generic.List`1.GetRange(System.Int32,System.Int32)" />
        <altmember cref="M:System.Collections.Generic.List`1.AddRange(System.Collections.Generic.IEnumerable{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.InsertRange(System.Int32,System.Collections.Generic.IEnumerable{`0})" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Reverse">
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Invierte el orden de los elementos en la <see cref="T:System.Collections.Generic.List`1" /> o en una parte de ella.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Reverse">
      <MemberSignature Language="C#" Value="public void Reverse ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Reverse() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.Reverse" />
      <MemberSignature Language="VB.NET" Value="Public Sub Reverse ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Reverse();" />
      <MemberSignature Language="F#" Value="member this.Reverse : unit -&gt; unit" Usage="list.Reverse " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Invierte el orden de los elementos en la <see cref="T:System.Collections.Generic.List`1" /> completa.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método usa <xref:System.Array.Reverse%2A?displayProperty=nameWithType> para invertir el orden de los elementos.  
  
 Este método es O (*n*) operación, donde *n* es <xref:System.Collections.Generic.List%601.Count%2A>.  
  
   
  
## Examples  
 El ejemplo siguiente muestra ambas sobrecargas de los <xref:System.Collections.Generic.List%601.Reverse%2A> método. El ejemplo se crea un <xref:System.Collections.Generic.List%601> de cadenas y agrega seis cadenas. El <xref:System.Collections.Generic.List%601.Reverse> sobrecarga del método se utiliza para invertir la lista y, a continuación, el <xref:System.Collections.Generic.List%601.Reverse%28System.Int32%2CSystem.Int32%29> sobrecarga del método se utiliza para invertir la mitad de la lista, empezando por el elemento 1 y que abarca cuatro elementos.  
  
 [!code-cpp[List\`1_Reverse#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_Reverse/cpp/source.cpp#1)]
 [!code-csharp[List\`1_Reverse#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_Reverse/cs/source.cs#1)]
 [!code-vb[List\`1_Reverse#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_Reverse/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Reverse">
      <MemberSignature Language="C#" Value="public void Reverse (int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Reverse(int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.Reverse(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Reverse (index As Integer, count As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Reverse(int index, int count);" />
      <MemberSignature Language="F#" Value="member this.Reverse : int * int -&gt; unit" Usage="list.Reverse (index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">Índice inicial de base cero del intervalo que se va a invertir.</param>
        <param name="count">Número de elementos del intervalo que se va a invertir.</param>
        <summary>Invierte el orden de los elementos en el intervalo especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método usa <xref:System.Array.Reverse%2A?displayProperty=nameWithType> para invertir el orden de los elementos.  
  
 Este método es O (*n*) operación, donde *n* es <xref:System.Collections.Generic.List%601.Count%2A>.  
  
   
  
## Examples  
 El ejemplo siguiente muestra ambas sobrecargas de los <xref:System.Collections.Generic.List%601.Reverse%2A> método. El ejemplo se crea un <xref:System.Collections.Generic.List%601> de cadenas y agrega seis cadenas. El <xref:System.Collections.Generic.List%601.Reverse> sobrecarga del método se utiliza para invertir la lista y, a continuación, el <xref:System.Collections.Generic.List%601.Reverse%28System.Int32%2CSystem.Int32%29> sobrecarga del método se utiliza para invertir la mitad de la lista, empezando por el elemento 1 y que abarca cuatro elementos.  
  
 [!code-cpp[List\`1_Reverse#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_Reverse/cpp/source.cpp#1)]
 [!code-csharp[List\`1_Reverse#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_Reverse/cs/source.cs#1)]
 [!code-vb[List\`1_Reverse#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_Reverse/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> es menor que 0.  
  
O bien 
 <paramref name="count" /> es menor que 0.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="index" /> y <paramref name="count" /> no denotan un intervalo válido de elementos en la <see cref="T:System.Collections.Generic.List`1" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Sort">
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Ordena los elementos o una parte de los elementos de <see cref="T:System.Collections.Generic.List`1" /> mediante la implementación de <see cref="T:System.Collections.Generic.IComparer`1" /> especificada o predeterminada o un delegado de <see cref="T:System.Comparison`1" /> proporcionado para comparar elementos de lista.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Sort">
      <MemberSignature Language="C#" Value="public void Sort ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Sort() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.Sort" />
      <MemberSignature Language="VB.NET" Value="Public Sub Sort ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Sort();" />
      <MemberSignature Language="F#" Value="member this.Sort : unit -&gt; unit" Usage="list.Sort " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ordena los elementos de toda la <see cref="T:System.Collections.Generic.List`1" /> utilizando el comparador predeterminado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método utiliza el comparador predeterminado <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType> para el tipo `T` para determinar el orden de los elementos de lista. El <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType> propiedad comprueba si tipo `T` implementa el <xref:System.IComparable%601> interfaz genérica y utiliza esa implementación, si está disponible.  Si no es así, <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType> comprueba si tipo `T` implementa el <xref:System.IComparable> interfaz.  Si tipo `T` no implementa ninguna de estas interfaces, <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType> produce una <xref:System.InvalidOperationException>.  
  
 Este método usa la <xref:System.Array.Sort%2A?displayProperty=nameWithType> método, que se aplica la ordenación introspectiva como sigue:  
  
-   Si el tamaño de partición es menos de 16 elementos, utiliza un algoritmo de ordenación de inserción.  
  
-   Si el número de particiones es superior a 2 registro *n*, donde *n* es el intervalo de la matriz de entrada utiliza un algoritmo Heapsort.  
  
-   En caso contrario, utiliza un algoritmo Quicksort.  
  
 Esta implementación realiza a una ordenación inestable; es decir, si dos elementos son iguales, es posible que no se conserve su orden. En cambio, una ordenación estable conserva el orden de los elementos que son iguales.  
  
 En promedio, este método es O (*n* registro *n*) operación, donde *n* es <xref:System.Collections.Generic.List%601.Count%2A>; en el peor de los casos, es una O (*n* <sup>2</sup>) operación.  
  
   
  
## Examples  
 En el ejemplo siguiente se agrega algunos nombres para un `List<String>` object, muestra la lista sin ordenar, llama a la <xref:System.Collections.Generic.List%601.Sort%2A> método y, a continuación, muestra la lista ordenada.  
  
 [!code-csharp[System.Collections.Generic.List.Sort#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.collections.generic.list.sort/cs/Sort1.cs#2)]
 [!code-vb[System.Collections.Generic.List.Sort#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.collections.generic.list.sort/vb/Sort1.vb#2)]  
  
 El código siguiente muestra el <xref:System.Collections.Generic.List%601.Sort> y <xref:System.Collections.Generic.List%601.Sort%28System.Comparison%7B%600%7D%29> sobrecargas del método en un objeto comercial simple. Una llamada a la <xref:System.Collections.Generic.List%601.Sort> método implica el uso del comparador predeterminado para el tipo de elemento y el <xref:System.Collections.Generic.List%601.Sort%28System.Comparison%7B%600%7D%29> método se implementa mediante el uso de un método anónimo.  
  
 [!code-csharp[System.Collections.Generic.List.Sort#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.collections.generic.list.sort/cs/program.cs#1)]
 [!code-vb[System.Collections.Generic.List.Sort#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.collections.generic.list.sort/vb/module1.vb#1)]  
  
 En el ejemplo siguiente se muestra el <xref:System.Collections.Generic.List%601.Sort> sobrecarga del método y el <xref:System.Collections.Generic.List%601.BinarySearch%28%600%29> sobrecarga del método. Un <xref:System.Collections.Generic.List%601> de cadenas se crean y rellenan con cuatro cadenas, sin ningún orden determinado. La lista se muestran, ordenan y volverá a mostrar.  
  
 El <xref:System.Collections.Generic.List%601.BinarySearch%28%600%29> sobrecarga del método, a continuación, se usa para buscar dos cadenas que no están en la lista, y el <xref:System.Collections.Generic.List%601.Insert%2A> método se utiliza para insertarlos. El valor devuelto de la <xref:System.Collections.Generic.List%601.BinarySearch%2A> método es negativo en cada caso, porque las cadenas no están en la lista. Tomando el complemento bit a bit (el ~ operador en C# y Visual C++, `Xor` -1 en Visual Basic) de este número negativo se produce el índice del primer elemento en la lista que es mayor que la cadena de búsqueda e inserción en esta ubicación conserva la ordenación orden. La segunda cadena de búsqueda es mayor que cualquier elemento en la lista, por lo que es la posición de inserción al final de la lista.  
  
 [!code-cpp[List\`1_SortSearch#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_SortSearch/cpp/source.cpp#1)]
 [!code-csharp[List\`1_SortSearch#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_SortSearch/cs/source.cs#1)]
 [!code-vb[List\`1_SortSearch#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_SortSearch/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">El comparador predeterminado <see cref="P:System.Collections.Generic.Comparer`1.Default" /> no puede encontrar una implementación de la interfaz genérica <see cref="T:System.IComparable`1" /> o la interfaz <see cref="T:System.IComparable" /> del tipo <paramref name="T" />.</exception>
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-collections.md">Realizar operaciones de cadenas que no tienen en cuenta las referencias culturales en colecciones</related>
      </Docs>
    </Member>
    <Member MemberName="Sort">
      <MemberSignature Language="C#" Value="public void Sort (System.Collections.Generic.IComparer&lt;T&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Sort(class System.Collections.Generic.IComparer`1&lt;!T&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.Sort(System.Collections.Generic.IComparer{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Sub Sort (comparer As IComparer(Of T))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Sort(System::Collections::Generic::IComparer&lt;T&gt; ^ comparer);" />
      <MemberSignature Language="F#" Value="member this.Sort : System.Collections.Generic.IComparer&lt;'T&gt; -&gt; unit" Usage="list.Sort comparer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="comparer" Type="System.Collections.Generic.IComparer&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="comparer">Implementación de <see cref="T:System.Collections.Generic.IComparer`1" /> que se va a utilizar al comparar elementos, o <see langword="null" /> para utilizar el comparador predeterminado <see cref="P:System.Collections.Generic.Comparer`1.Default" />.</param>
        <summary>Ordena los elementos en la <see cref="T:System.Collections.Generic.List`1" /> completa usando el comparador especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si `comparer` se proporciona, los elementos de la <xref:System.Collections.Generic.List%601> se ordenan mediante especificado <xref:System.Collections.Generic.IComparer%601> implementación.  
  
 Si `comparer` es `null`, el comparador predeterminado <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType> comprueba si tipo `T` implementa el <xref:System.IComparable%601> interfaz genérica y utiliza esa implementación, si está disponible.  Si no es así, <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType> comprueba si tipo `T` implementa el <xref:System.IComparable> interfaz.  Si tipo `T` no implementa ninguna de estas interfaces, <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType> produce una <xref:System.InvalidOperationException>.  
  
 Este método usa la <xref:System.Array.Sort%2A?displayProperty=nameWithType> método, que se aplica la ordenación introspectiva como sigue:  
  
-   Si el tamaño de partición es menos de 16 elementos, utiliza un algoritmo de ordenación de inserción.  
  
-   Si el número de particiones es superior a 2 registro *n*, donde *n* es el intervalo de la matriz de entrada utiliza un algoritmo Heapsort.  
  
-   En caso contrario, utiliza un algoritmo Quicksort.  
  
 Esta implementación realiza a una ordenación inestable; es decir, si dos elementos son iguales, es posible que no se conserve su orden. En cambio, una ordenación estable conserva el orden de los elementos que son iguales.  
  
 En promedio, este método es O (*n* registro *n*) operación, donde *n* es <xref:System.Collections.Generic.List%601.Count%2A>; en el peor de los casos, es una O (*n* <sup>2</sup>) operación.  
  
   
  
## Examples  
 En el ejemplo siguiente se muestra el <xref:System.Collections.Generic.List%601.Sort%28System.Collections.Generic.IComparer%7B%600%7D%29> sobrecarga del método y el <xref:System.Collections.Generic.List%601.BinarySearch%28%600%2CSystem.Collections.Generic.IComparer%7B%600%7D%29> sobrecarga del método.  
  
 El ejemplo define un comparador alternativo para las cadenas denominado DinoCompare, que implementa el `IComparer<string>` (`IComparer(Of String)` en Visual Basic, `IComparer<String^>` en Visual C++) interfaz genérica. El comparador funciona del siguiente modo: En primer lugar, se comprueba si la comparación `null`, y una referencia nula se considera menor que un valor no null. En segundo lugar, se comparan las longitudes de cadena, y se considera que la cadena más larga para que sea mayor. En tercer lugar, si las longitudes son iguales, se usa la comparación de cadenas normales.  
  
 Un <xref:System.Collections.Generic.List%601> de cadenas se crean y rellenan con cuatro cadenas, sin ningún orden determinado. Se muestra la lista, ordenada, utilizando al comparador alternativo y se muestran nuevamente.  
  
 El <xref:System.Collections.Generic.List%601.BinarySearch%28%600%2CSystem.Collections.Generic.IComparer%7B%600%7D%29> sobrecarga del método, a continuación, se usa para buscar varias cadenas que no en la lista, debe emplear el comparador alternativo. El <xref:System.Collections.Generic.List%601.Insert%2A> método se utiliza para insertar las cadenas. Estos dos métodos se encuentran en la función denominada `SearchAndInsert`, junto con el código para aprovechar el complemento bit a bit (el ~ operador en C# y Visual C++, `Xor` -1 en Visual Basic) del número negativo devuelto por <xref:System.Collections.Generic.List%601.BinarySearch%28%600%2CSystem.Collections.Generic.IComparer%7B%600%7D%29> y usarlo como un índice para Insertar la nueva cadena.  
  
 [!code-cpp[List\`1_SortSearchComparer#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_SortSearchComparer/cpp/source.cpp#1)]
 [!code-csharp[List\`1_SortSearchComparer#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_SortSearchComparer/cs/source.cs#1)]
 [!code-vb[List\`1_SortSearchComparer#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_SortSearchComparer/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><paramref name="comparer" /> es <see langword="null" />, y el comparador predeterminado <see cref="P:System.Collections.Generic.Comparer`1.Default" /> no puede encontrar una implementación de la interfaz genérica <see cref="T:System.IComparable`1" /> o la interfaz <see cref="T:System.IComparable" /> del tipo <paramref name="T" />.</exception>
        <exception cref="T:System.ArgumentException">La implementación de <paramref name="comparer" /> produjo un error durante la ordenación. Por ejemplo, es posible que <paramref name="comparer" /> no devuelva 0 al comparar un elemento consigo mismo.</exception>
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-collections.md">Realizar operaciones de cadenas que no tienen en cuenta las referencias culturales en colecciones</related>
      </Docs>
    </Member>
    <Member MemberName="Sort">
      <MemberSignature Language="C#" Value="public void Sort (Comparison&lt;T&gt; comparison);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Sort(class System.Comparison`1&lt;!T&gt; comparison) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.Sort(System.Comparison{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Sub Sort (comparison As Comparison(Of T))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Sort(Comparison&lt;T&gt; ^ comparison);" />
      <MemberSignature Language="F#" Value="member this.Sort : Comparison&lt;'T&gt; -&gt; unit" Usage="list.Sort comparison" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="comparison" Type="System.Comparison&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="comparison"><see cref="T:System.Comparison`1" /> que se va a utilizar al comparar elementos.</param>
        <summary>Ordena los elementos de toda la <see cref="T:System.Collections.Generic.List`1" /> utilizando el <see cref="T:System.Comparison`1" /> especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si `comparison` se proporciona, los elementos de la <xref:System.Collections.Generic.List%601> se ordenan mediante el método representado por el delegado.  
  
 Si `comparison` es `null`, un <xref:System.ArgumentNullException> se produce.  
  
 Este método usa <xref:System.Array.Sort%2A?displayProperty=nameWithType>, que aplica la ordenación introspectiva como sigue:  
  
-   Si el tamaño de partición es menos de 16 elementos, utiliza un algoritmo de ordenación de inserción  
  
-   Si el número de particiones es superior a 2 registro *n*, donde *n* es el intervalo de la matriz de entrada, usa un [Heapsort](https://en.wikipedia.org/wiki/Heapsort) algoritmo.  
  
-   En caso contrario, utiliza un algoritmo Quicksort.  
  
 Esta implementación realiza a una ordenación inestable; es decir, si dos elementos son iguales, es posible que no se conserve su orden. En cambio, una ordenación estable conserva el orden de los elementos que son iguales.  
  
 En promedio, este método es O (*n* registro *n*) operación, donde *n* es <xref:System.Collections.Generic.List%601.Count%2A>; en el peor de los casos, es una O (*n* <sup>2</sup>) operación.  
  
   
  
## Examples  
 El código siguiente muestra el <xref:System.Collections.Generic.List%601.Sort%2A> y <xref:System.Collections.Generic.List%601.Sort%2A> sobrecargas del método en un objeto comercial simple. Una llamada a la <xref:System.Collections.Generic.List%601.Sort%2A> método implica el uso del comparador predeterminado para el tipo de elemento y el <xref:System.Collections.Generic.List%601.Sort%2A> método se implementa mediante un método anónimo.  
  
 [!code-csharp[System.Collections.Generic.List.Sort#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.collections.generic.list.sort/cs/program.cs#1)]
 [!code-vb[System.Collections.Generic.List.Sort#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.collections.generic.list.sort/vb/module1.vb#1)]  
  
 En el ejemplo siguiente se muestra el <xref:System.Collections.Generic.List%601.Sort%28System.Comparison%7B%600%7D%29> sobrecarga del método.  
  
 El ejemplo define un método de comparación alternativo para las cadenas, denominado `CompareDinosByLength`. Este método funciona del siguiente modo: En primer lugar, se comprueba si la comparación `null`, y una referencia nula se considera menor que un valor no null. En segundo lugar, se comparan las longitudes de cadena, y se considera que la cadena más larga para que sea mayor. En tercer lugar, si las longitudes son iguales, se usa la comparación de cadenas normales.  
  
 Un <xref:System.Collections.Generic.List%601> de cadenas se crean y rellenan con cuatro cadenas, sin ningún orden determinado. La lista también incluye una cadena vacía y una referencia nula. Se muestra la lista, se ordena usando un <xref:System.Comparison%601> delegado genérico que representa el `CompareDinosByLength` método y volverá a mostrar.  
  
 [!code-cpp[List\`1_SortComparison#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_SortComparison/cpp/source.cpp#1)]
 [!code-csharp[List\`1_SortComparison#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_SortComparison/cs/source.cs#1)]
 [!code-vb[List\`1_SortComparison#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_SortComparison/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="comparison" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">La implementación de <paramref name="comparison" /> ha producido un error durante la ordenación. Por ejemplo, es posible que <paramref name="comparison" /> no devuelva 0 al comparar un elemento consigo mismo.</exception>
        <altmember cref="T:System.Comparison`1" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-collections.md">Realizar operaciones de cadenas que no tienen en cuenta las referencias culturales en colecciones</related>
      </Docs>
    </Member>
    <Member MemberName="Sort">
      <MemberSignature Language="C#" Value="public void Sort (int index, int count, System.Collections.Generic.IComparer&lt;T&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Sort(int32 index, int32 count, class System.Collections.Generic.IComparer`1&lt;!T&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.Sort(System.Int32,System.Int32,System.Collections.Generic.IComparer{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Sub Sort (index As Integer, count As Integer, comparer As IComparer(Of T))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Sort(int index, int count, System::Collections::Generic::IComparer&lt;T&gt; ^ comparer);" />
      <MemberSignature Language="F#" Value="member this.Sort : int * int * System.Collections.Generic.IComparer&lt;'T&gt; -&gt; unit" Usage="list.Sort (index, count, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IComparer&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="index">Índice inicial de base cero del intervalo que se va a ordenar.</param>
        <param name="count">Longitud del intervalo que se va a ordenar.</param>
        <param name="comparer">Implementación de <see cref="T:System.Collections.Generic.IComparer`1" /> que se va a utilizar al comparar elementos, o <see langword="null" /> para utilizar el comparador predeterminado <see cref="P:System.Collections.Generic.Comparer`1.Default" />.</param>
        <summary>Ordena los elementos en un intervalo de elementos de la matriz <see cref="T:System.Collections.Generic.List`1" /> usando el comparador especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si `comparer` se proporciona, los elementos de la <xref:System.Collections.Generic.List%601> se ordenan mediante especificado <xref:System.Collections.Generic.IComparer%601> implementación.  
  
 Si `comparer` es `null`, el comparador predeterminado <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType> comprueba si tipo `T` implementa el <xref:System.IComparable%601> interfaz genérica y utiliza esa implementación, si está disponible.  Si no es así, <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType> comprueba si tipo `T` implementa el <xref:System.IComparable> interfaz.  Si tipo `T` no implementa ninguna de estas interfaces, <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType> produce una <xref:System.InvalidOperationException>.  
  
 Este método usa <xref:System.Array.Sort%2A?displayProperty=nameWithType>, que aplica la ordenación introspectiva como sigue:  
  
-   Si el tamaño de partición es menos de 16 elementos, utiliza un algoritmo de ordenación de inserción  
  
-   Si el número de particiones es superior a 2 registro *n*, donde *n* es el intervalo de la matriz de entrada, usa un [Heapsort](https://en.wikipedia.org/wiki/Heapsort) algoritmo.  
  
-   En caso contrario, utiliza un algoritmo Quicksort.  
  
 Esta implementación realiza a una ordenación inestable; es decir, si dos elementos son iguales, es posible que no se conserve su orden. En cambio, una ordenación estable conserva el orden de los elementos que son iguales.  
  
 En promedio, este método es O (*n* registro *n*) operación, donde *n* es <xref:System.Collections.Generic.List%601.Count%2A>; en el peor de los casos, es una O (*n* <sup>2</sup>) operación.  
  
   
  
## Examples  
 En el ejemplo siguiente se muestra el <xref:System.Collections.Generic.List%601.Sort%28System.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%600%7D%29> sobrecarga del método y el <xref:System.Collections.Generic.List%601.BinarySearch%28System.Int32%2CSystem.Int32%2C%600%2CSystem.Collections.Generic.IComparer%7B%600%7D%29> sobrecarga del método.  
  
 El ejemplo define un comparador alternativo para las cadenas denominado DinoCompare, que implementa el `IComparer<string>` (`IComparer(Of String)` en Visual Basic, `IComparer<String^>` en Visual C++) interfaz genérica. El comparador funciona del siguiente modo: En primer lugar, se comprueba si la comparación `null`, y una referencia nula se considera menor que un valor no null. En segundo lugar, se comparan las longitudes de cadena, y se considera que la cadena más larga para que sea mayor. En tercer lugar, si las longitudes son iguales, se usa la comparación de cadenas normales.  
  
 Un <xref:System.Collections.Generic.List%601> de cadenas se crean y rellenan con los nombres de cinco dinosaurios herbívoros y tres dinosaurios carnívoros. Dentro de cada uno de los dos grupos, los nombres no están en ningún orden determinado. Se muestra la lista, el intervalo de herbívoros se ordena usando al comparador alternativo y volverá a aparecer la lista.  
  
 El <xref:System.Collections.Generic.List%601.BinarySearch%28System.Int32%2CSystem.Int32%2C%600%2CSystem.Collections.Generic.IComparer%7B%600%7D%29> sobrecarga del método, a continuación, se usa para buscar solo en el intervalo de herbívoros "Brachiosaurus". No se encuentra la cadena y el complemento bit a bit (el ~ operador en C# y Visual C++, `Xor` -1 en Visual Basic) del número negativo devuelto por la <xref:System.Collections.Generic.List%601.BinarySearch%28System.Int32%2CSystem.Int32%2C%600%2CSystem.Collections.Generic.IComparer%7B%600%7D%29> método se usa como índice para insertar la nueva cadena.  
  
 [!code-cpp[List\`1_SortSearchComparerRange#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_SortSearchComparerRange/cpp/source.cpp#1)]
 [!code-csharp[List\`1_SortSearchComparerRange#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_SortSearchComparerRange/cs/source.cs#1)]
 [!code-vb[List\`1_SortSearchComparerRange#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_SortSearchComparerRange/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> es menor que 0.  
  
O bien 
 <paramref name="count" /> es menor que 0.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="index" /> y <paramref name="count" /> no especifican un intervalo válido en <see cref="T:System.Collections.Generic.List`1" />.  
  
O bien 
La implementación de <paramref name="comparer" /> produjo un error durante la ordenación. Por ejemplo, es posible que <paramref name="comparer" /> no devuelva 0 al comparar un elemento consigo mismo.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="comparer" /> es <see langword="null" />, y el comparador predeterminado <see cref="P:System.Collections.Generic.Comparer`1.Default" /> no puede encontrar una implementación de la interfaz genérica <see cref="T:System.IComparable`1" /> o la interfaz <see cref="T:System.IComparable" /> del tipo <paramref name="T" />.</exception>
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-collections.md">Realizar operaciones de cadenas que no tienen en cuenta las referencias culturales en colecciones</related>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Generic.ICollection&lt;T&gt;.IsReadOnly">
      <MemberSignature Language="C#" Value="bool System.Collections.Generic.ICollection&lt;T&gt;.IsReadOnly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Collections.Generic.ICollection&lt;T&gt;.IsReadOnly" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.List`1.System#Collections#Generic#ICollection&lt;T&gt;#IsReadOnly" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsReadOnly As Boolean Implements ICollection(Of T).IsReadOnly" />
      <MemberSignature Language="C++ CLI" Value="property bool System::Collections::Generic::ICollection&lt;T&gt;::IsReadOnly { bool get(); };" />
      <MemberSignature Language="F#" Usage="System.Collections.Generic.ICollection&lt;T&gt;.IsReadOnly" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.Generic.ICollection`1.IsReadOnly</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene un valor que indica si <see cref="T:System.Collections.Generic.ICollection`1" /> es de solo lectura.</summary>
        <value>Es <see langword="true" /> si la interfaz <see cref="T:System.Collections.Generic.ICollection`1" /> es de solo lectura; de lo contrario, es <see langword="false" />.  En la implementación predeterminada de <see cref="T:System.Collections.Generic.List`1" />, esta propiedad siempre devuelve <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Una colección de solo lectura no permite que se agreguen, quiten o modifiquen elementos una vez que se ha creado.  
  
 Una colección es de solo lectura es simplemente una colección con un contenedor que evita la modificación de la colección; por lo tanto, si se realizan cambios en la colección subyacente, la colección de solo lectura refleja los cambios.  
  
 La recuperación del valor de esta propiedad es una operación O(1).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Generic.IEnumerable&lt;T&gt;.GetEnumerator">
      <MemberSignature Language="C#" Value="System.Collections.Generic.IEnumerator&lt;T&gt; IEnumerable&lt;T&gt;.GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.Generic.IEnumerator`1&lt;!T&gt; System.Collections.Generic.IEnumerable&lt;T&gt;.GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.System#Collections#Generic#IEnumerable&lt;T&gt;#GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Function GetEnumerator () As IEnumerator(Of T) Implements IEnumerable(Of T).GetEnumerator" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Collections::Generic::IEnumerator&lt;T&gt; ^ System.Collections.Generic.IEnumerable&lt;T&gt;.GetEnumerator() = System::Collections::Generic::IEnumerable&lt;T&gt;::GetEnumerator;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.IEnumerable`1.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerator&lt;T&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Devuelve un enumerador que recorre en iteración una colección.</summary>
        <returns><see cref="T:System.Collections.Generic.IEnumerator`1" /> que se puede utilizar para recorrer en iteración la colección.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El `foreach` instrucción del lenguaje C# (`for each` en C++, `For Each` en Visual Basic) oculta la complejidad de los enumeradores. Por lo tanto, se recomienda el uso de `foreach`, en lugar de manipular directamente el enumerador.  
  
 Los enumeradores pueden usarse para leer los datos de la colección, pero no para modificar la colección subyacente.  
  
 En principio, el enumerador se coloca antes del primer elemento de la colección. En esta posición, el <xref:System.Collections.Generic.IEnumerator%601.Current%2A> propiedad no está definida. Por lo tanto, debe llamar a la <xref:System.Collections.IEnumerator.MoveNext%2A> método para hacer avanzar el enumerador hasta el primer elemento de la colección antes de leer el valor de <xref:System.Collections.Generic.IEnumerator%601.Current%2A>.  
  
 El <xref:System.Collections.Generic.IEnumerator%601.Current%2A> propiedad devuelve el mismo objeto hasta que <xref:System.Collections.IEnumerator.MoveNext%2A> se llama. <xref:System.Collections.IEnumerator.MoveNext%2A> establece <xref:System.Collections.Generic.IEnumerator%601.Current%2A> en el siguiente elemento.  
  
 Si <xref:System.Collections.IEnumerator.MoveNext%2A> pasa el final de la colección, el enumerador se coloca después del último elemento de la colección y <xref:System.Collections.IEnumerator.MoveNext%2A> devuelve `false`. Cuando el enumerador está en esta posición, las llamadas subsiguientes a <xref:System.Collections.IEnumerator.MoveNext%2A> también devolver `false`. Si la última llamada a <xref:System.Collections.IEnumerator.MoveNext%2A> devuelve `false`, <xref:System.Collections.Generic.IEnumerator%601.Current%2A> es indefinido. No puede volver a establecer la propiedad <xref:System.Collections.Generic.IEnumerator%601.Current%2A> en el primer elemento de la colección, sino que debe crear una nueva instancia del enumerador.  
  
 Un enumerador es válido mientras la colección no cambie. Si se realizan cambios en la colección, como agregar, modificar, o eliminar elementos, el enumerador queda invalida invalidado y la siguiente llamada a <xref:System.Collections.IEnumerator.MoveNext%2A> o <xref:System.Collections.IEnumerator.Reset%2A> produce una <xref:System.InvalidOperationException>.  
  
 El enumerador no tiene acceso exclusivo a la colección y, por tanto, la enumeración en una colección no es intrínsicamente un procedimiento seguro para subprocesos. A fin de garantizar la seguridad de los subprocesos, se puede bloquear la colección durante toda la enumeración.  Para permitir que varios subprocesos obtengan acceso de lectura y escritura a la colección, debe implementar su propia sincronización.  
  
 Las implementaciones predeterminadas de las colecciones del espacio de nombres <xref:System.Collections.Generic?displayProperty=nameWithType> no están sincronizadas.  
  
 Este método es una operación o (1).  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.Generic.IEnumerator`1" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.ICollection.CopyTo">
      <MemberSignature Language="C#" Value="void ICollection.CopyTo (Array array, int arrayIndex);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Collections.ICollection.CopyTo(class System.Array array, int32 arrayIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.System#Collections#ICollection#CopyTo(System.Array,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Collections.ICollection.CopyTo(Array ^ array, int arrayIndex) = System::Collections::ICollection::CopyTo;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.ICollection.CopyTo(System.Array,System.Int32)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="arrayIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array"><see cref="T:System.Array" /> unidimensional que constituye el destino de los elementos copiados de <see cref="T:System.Collections.ICollection" />. La matriz <see cref="T:System.Array" /> debe tener una indización de base cero.</param>
        <param name="arrayIndex">Índice de base cero en la <paramref name="array" /> donde comienza la copia.</param>
        <summary>Copia los elementos de <see cref="T:System.Collections.ICollection" /> en <see cref="T:System.Array" />, empezando por un índice determinado de <see cref="T:System.Array" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Si el tipo del origen de <xref:System.Collections.ICollection> no puede convertirse automáticamente al tipo del destino `array`, las implementaciones no genéricas de <xref:System.Collections.ICollection.CopyTo%2A?displayProperty=nameWithType> throw <xref:System.InvalidCastException>, mientras que las implementaciones genéricas inician <xref:System.ArgumentException>.  
  
 Este método es O (*n*) operación, donde *n* es <xref:System.Collections.Generic.List%601.Count%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="arrayIndex" /> es menor que 0.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="array" /> es multidimensional.  
  
O bien 
 <paramref name="array" /> no tiene una indización de base cero.  
  
O bien 
El número de elementos de la <see cref="T:System.Collections.ICollection" /> de origen es mayor que el espacio disponible desde <paramref name="arrayIndex" /> hasta el final de la <paramref name="array" /> de destino.  
  
O bien 
El tipo de la <see cref="T:System.Collections.ICollection" /> de origen no puede convertirse automáticamente al tipo de la <paramref name="array" /> de destino.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.ICollection.IsSynchronized">
      <MemberSignature Language="C#" Value="bool System.Collections.ICollection.IsSynchronized { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Collections.ICollection.IsSynchronized" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.List`1.System#Collections#ICollection#IsSynchronized" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsSynchronized As Boolean Implements ICollection.IsSynchronized" />
      <MemberSignature Language="C++ CLI" Value="property bool System::Collections::ICollection::IsSynchronized { bool get(); };" />
      <MemberSignature Language="F#" Usage="System.Collections.ICollection.IsSynchronized" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.IsSynchronized</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene un valor que indica si el acceso a la interfaz <see cref="T:System.Collections.ICollection" /> está sincronizado (es seguro para subprocesos).</summary>
        <value>Es <see langword="true" /> si el acceso a <see cref="T:System.Collections.ICollection" /> está sincronizado (es seguro para subprocesos); de lo contrario, es <see langword="false" />.  En la implementación predeterminada de <see cref="T:System.Collections.Generic.List`1" />, esta propiedad siempre devuelve <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Las implementaciones predeterminadas de las colecciones del espacio de nombres <xref:System.Collections.Generic?displayProperty=nameWithType> no están sincronizadas.  
  
 Enumerar una colección no es intrínsecamente un procedimiento seguro para subprocesos.  En el caso excepcional donde enumeración tiene que enfrentarse con accesos de escritura, puede bloquear la colección durante toda la enumeración.  Para permitir que varios subprocesos obtengan acceso de lectura y escritura a la colección, debe implementar su propia sincronización.  
  
 <xref:System.Collections.ICollection.SyncRoot%2A> Devuelve un objeto que puede utilizarse para sincronizar el acceso a la <xref:System.Collections.ICollection>. La sincronización es eficaz solo si todos los subprocesos bloquean este objeto antes de acceder a la colección.  
  
 La recuperación del valor de esta propiedad es una operación O(1).  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Collections.Generic.List`1.System#Collections#ICollection#SyncRoot" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.ICollection.SyncRoot">
      <MemberSignature Language="C#" Value="object System.Collections.ICollection.SyncRoot { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object System.Collections.ICollection.SyncRoot" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.List`1.System#Collections#ICollection#SyncRoot" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property SyncRoot As Object Implements ICollection.SyncRoot" />
      <MemberSignature Language="C++ CLI" Value="property System::Object ^ System::Collections::ICollection::SyncRoot { System::Object ^ get(); };" />
      <MemberSignature Language="F#" Usage="System.Collections.ICollection.SyncRoot" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.SyncRoot</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene un objeto que se puede usar para sincronizar el acceso a <see cref="T:System.Collections.ICollection" />.</summary>
        <value>Objeto que se puede usar para sincronizar el acceso a <see cref="T:System.Collections.ICollection" />.  En la implementación predeterminada de <see cref="T:System.Collections.Generic.List`1" />, esta propiedad siempre devuelve la instancia actual.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Las implementaciones predeterminadas de las colecciones del espacio de nombres <xref:System.Collections.Generic?displayProperty=nameWithType> no están sincronizadas.  
  
 Enumerar una colección no es intrínsecamente un procedimiento seguro para subprocesos.  A fin de garantizar la seguridad de los subprocesos, se puede bloquear la colección durante toda la enumeración.  Para permitir que varios subprocesos obtengan acceso de lectura y escritura a la colección, debe implementar su propia sincronización.  
  
 <xref:System.Collections.ICollection.SyncRoot%2A> Devuelve un objeto que puede utilizarse para sincronizar el acceso a la <xref:System.Collections.ICollection>. La sincronización es eficaz solo si todos los subprocesos bloquean este objeto antes de acceder a la colección. El código siguiente muestra el uso de la <xref:System.Collections.ICollection.SyncRoot%2A> propiedad para C#, C++ y Visual Basic.  
  
```csharp  
ICollection ic = ...;  
lock (ic.SyncRoot)   
{  
    // Access the collection.  
}  
```  
  
```vb  
Dim ic As ICollection = ...  
SyncLock ic.SyncRoot  
    ' Access the collection.  
End SyncLock  
```  
  
```cpp#  
ICollection^ ic = ...;  
try   
{  
    Monitor::Enter(ic->SyncRoot);  
    // Access the collection.  
}  
finally   
{  
    Monitor::Exit(ic->SyncRoot);  
}  
```  
  
 La recuperación del valor de esta propiedad es una operación O(1).  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Collections.Generic.List`1.System#Collections#ICollection#IsSynchronized" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IEnumerable.GetEnumerator">
      <MemberSignature Language="C#" Value="System.Collections.IEnumerator IEnumerable.GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.System#Collections#IEnumerable#GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Function GetEnumerator () As IEnumerator Implements IEnumerable.GetEnumerator" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Collections::IEnumerator ^ System.Collections.IEnumerable.GetEnumerator() = System::Collections::IEnumerable::GetEnumerator;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IEnumerable.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Devuelve un enumerador que recorre en iteración una colección.</summary>
        <returns><see cref="T:System.Collections.IEnumerator" /> que se puede utilizar para recorrer en iteración la colección.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El `foreach` instrucción del lenguaje C# (`for each` en C++, `For Each` en Visual Basic) oculta la complejidad de los enumeradores. Por lo tanto, se recomienda el uso de `foreach`, en lugar de manipular directamente el enumerador.  
  
 Los enumeradores pueden usarse para leer los datos de la colección, pero no para modificar la colección subyacente.  
  
 En principio, el enumerador se coloca antes del primer elemento de la colección. <xref:System.Collections.IEnumerator.Reset%2A> también devuelve el enumerador a esta posición.  En esta posición, el <xref:System.Collections.IEnumerator.Current%2A> propiedad no está definida. Por lo tanto, debe llamar a la <xref:System.Collections.IEnumerator.MoveNext%2A> método para hacer avanzar el enumerador hasta el primer elemento de la colección antes de leer el valor de <xref:System.Collections.IEnumerator.Current%2A>.  
  
 El <xref:System.Collections.IEnumerator.Current%2A> propiedad devuelve el mismo objeto hasta que <xref:System.Collections.IEnumerator.MoveNext%2A> o <xref:System.Collections.IEnumerator.Reset%2A> se llama. <xref:System.Collections.IEnumerator.MoveNext%2A> establece <xref:System.Collections.IEnumerator.Current%2A> en el siguiente elemento.  
  
 Si <xref:System.Collections.IEnumerator.MoveNext%2A> pasa el final de la colección, el enumerador se coloca después del último elemento de la colección y <xref:System.Collections.IEnumerator.MoveNext%2A> devuelve `false`. Cuando el enumerador está en esta posición, las llamadas subsiguientes a <xref:System.Collections.IEnumerator.MoveNext%2A> también devolver `false`. Si la última llamada a <xref:System.Collections.IEnumerator.MoveNext%2A> devuelve `false`, <xref:System.Collections.IEnumerator.Current%2A> es indefinido. Para volver a establecer el valor de <xref:System.Collections.IEnumerator.Current%2A> en el primer elemento de la colección, se puede llamar primero a <xref:System.Collections.IEnumerator.Reset%2A> y después a <xref:System.Collections.IEnumerator.MoveNext%2A>.  
  
 Un enumerador es válido mientras la colección no cambie. Si se realizan cambios en la colección, como agregar, modificar, o eliminar elementos, el enumerador queda invalida invalidado y la siguiente llamada a <xref:System.Collections.IEnumerator.MoveNext%2A> o <xref:System.Collections.IEnumerator.Reset%2A> produce una <xref:System.InvalidOperationException>.  
  
 El enumerador no tiene acceso exclusivo a la colección y, por tanto, la enumeración en una colección no es intrínsicamente un procedimiento seguro para subprocesos.  A fin de garantizar la seguridad de los subprocesos, se puede bloquear la colección durante toda la enumeración.  Para permitir que varios subprocesos obtengan acceso de lectura y escritura a la colección, debe implementar su propia sincronización.  
  
 Las implementaciones predeterminadas de las colecciones del espacio de nombres <xref:System.Collections.Generic?displayProperty=nameWithType> no están sincronizadas.  
  
 Este método es una operación o (1).  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.IEnumerator" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.Add">
      <MemberSignature Language="C#" Value="int IList.Add (object item);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int32 System.Collections.IList.Add(object item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.System#Collections#IList#Add(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Function Add (item As Object) As Integer Implements IList.Add" />
      <MemberSignature Language="C++ CLI" Value=" virtual int System.Collections.IList.Add(System::Object ^ item) = System::Collections::IList::Add;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IList.Add(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="item"><see cref="T:System.Object" /> que se va a agregar a <see cref="T:System.Collections.IList" />.</param>
        <summary>Agrega un elemento a <see cref="T:System.Collections.IList" />.</summary>
        <returns>Posición en la que se insertó el nuevo elemento.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si <xref:System.Collections.Generic.List%601.Count%2A> es menor que <xref:System.Collections.Generic.List%601.Capacity%2A>, este método es una operación o (1). Si la capacidad debe aumentarse para alojar el nuevo elemento, este método se convierte en una O (*n*) operación, donde *n* es <xref:System.Collections.Generic.List%601.Count%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="item" /> es de un tipo que no se puede asignar a <see cref="T:System.Collections.IList" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.Contains">
      <MemberSignature Language="C#" Value="bool IList.Contains (object item);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool System.Collections.IList.Contains(object item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.System#Collections#IList#Contains(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Function Contains (item As Object) As Boolean Implements IList.Contains" />
      <MemberSignature Language="C++ CLI" Value=" virtual bool System.Collections.IList.Contains(System::Object ^ item) = System::Collections::IList::Contains;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IList.Contains(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="item">Objeto <see cref="T:System.Object" /> que se va a buscar en la interfaz <see cref="T:System.Collections.IList" />.</param>
        <summary>Determina si <see cref="T:System.Collections.IList" /> contiene un valor específico.</summary>
        <returns><see langword="true" /> si <paramref name="item" /> se encuentra en la matriz <see cref="T:System.Collections.IList" />; en caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método determina la igualdad utilizando el comparador de igualdad predeterminado <xref:System.Collections.Generic.EqualityComparer%601.Default%2A?displayProperty=nameWithType> para `T`, el tipo de valores en la lista.  
  
 Este método realiza una búsqueda lineal; por lo tanto, este método es O (*n*) operación, donde *n* es <xref:System.Collections.Generic.List%601.Count%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.IndexOf">
      <MemberSignature Language="C#" Value="int IList.IndexOf (object item);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int32 System.Collections.IList.IndexOf(object item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.System#Collections#IList#IndexOf(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Function IndexOf (item As Object) As Integer Implements IList.IndexOf" />
      <MemberSignature Language="C++ CLI" Value=" virtual int System.Collections.IList.IndexOf(System::Object ^ item) = System::Collections::IList::IndexOf;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IList.IndexOf(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="item">Objeto que se va a buscar en <see cref="T:System.Collections.IList" />.</param>
        <summary>Determina el índice de un elemento específico de <see cref="T:System.Collections.IList" />.</summary>
        <returns>Devuelve el índice de <paramref name="item" /> si se encuentra en la lista; de lo contrario, devuelve -1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método determina la igualdad utilizando el comparador de igualdad predeterminado <xref:System.Collections.Generic.EqualityComparer%601.Default%2A?displayProperty=nameWithType> para `T`, el tipo de valores en la lista.  
  
 Este método realiza una búsqueda lineal; por lo tanto, este método es O (*n*) operación, donde *n* es <xref:System.Collections.Generic.List%601.Count%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="item" /> es de un tipo que no se puede asignar a <see cref="T:System.Collections.IList" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.Insert">
      <MemberSignature Language="C#" Value="void IList.Insert (int index, object item);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Collections.IList.Insert(int32 index, object item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.System#Collections#IList#Insert(System.Int32,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Sub Insert (index As Integer, item As Object) Implements IList.Insert" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Collections.IList.Insert(int index, System::Object ^ item) = System::Collections::IList::Insert;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IList.Insert(System.Int32,System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="item" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="index">Índice basado en cero en el que debe insertarse <paramref name="item" />.</param>
        <param name="item">Objeto que se va a insertar en <see cref="T:System.Collections.IList" />.</param>
        <summary>Inserta un elemento en la interfaz <see cref="T:System.Collections.IList" />, en el índice especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si `index` es igual al número de elementos de <xref:System.Collections.IList>, entonces `item` se agrega al final.  
  
 Este método es O (*n*) operación, donde *n* es <xref:System.Collections.Generic.List%601.Count%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> no es un índice válido para <see cref="T:System.Collections.IList" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="item" /> es de un tipo que no se puede asignar a <see cref="T:System.Collections.IList" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.IsFixedSize">
      <MemberSignature Language="C#" Value="bool System.Collections.IList.IsFixedSize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Collections.IList.IsFixedSize" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.List`1.System#Collections#IList#IsFixedSize" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsFixedSize As Boolean Implements IList.IsFixedSize" />
      <MemberSignature Language="C++ CLI" Value="property bool System::Collections::IList::IsFixedSize { bool get(); };" />
      <MemberSignature Language="F#" Usage="System.Collections.IList.IsFixedSize" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.IList.IsFixedSize</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene un valor que indica si la interfaz <see cref="T:System.Collections.IList" /> tiene un tamaño fijo.</summary>
        <value>Es <see langword="true" /> si la interfaz <see cref="T:System.Collections.IList" /> tiene un tamaño fijo; de lo contrario, es <see langword="false" />.  En la implementación predeterminada de <see cref="T:System.Collections.Generic.List`1" />, esta propiedad siempre devuelve <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Una colección de tamaño fijo no permite agregar o quitar elementos una vez que se ha creado, pero sí permite modificar los elementos existentes.  
  
 Una colección con un tamaño fijo es simplemente una colección con un contenedor que impide agregar y quitar elementos; por lo tanto, si se realizan cambios en la colección subyacente, incluida la adición o eliminación de elementos, la colección de tamaño fijo refleja los cambios.  
  
 La recuperación del valor de esta propiedad es una operación O(1).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.IsReadOnly">
      <MemberSignature Language="C#" Value="bool System.Collections.IList.IsReadOnly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Collections.IList.IsReadOnly" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.List`1.System#Collections#IList#IsReadOnly" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsReadOnly As Boolean Implements IList.IsReadOnly" />
      <MemberSignature Language="C++ CLI" Value="property bool System::Collections::IList::IsReadOnly { bool get(); };" />
      <MemberSignature Language="F#" Usage="System.Collections.IList.IsReadOnly" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.IList.IsReadOnly</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene un valor que indica si <see cref="T:System.Collections.IList" /> es de solo lectura.</summary>
        <value>Es <see langword="true" /> si la interfaz <see cref="T:System.Collections.IList" /> es de solo lectura; de lo contrario, es <see langword="false" />.  En la implementación predeterminada de <see cref="T:System.Collections.Generic.List`1" />, esta propiedad siempre devuelve <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Una colección de solo lectura no permite que se agreguen, quiten o modifiquen elementos una vez que se ha creado.  
  
 Una colección es de solo lectura es simplemente una colección con un contenedor que evita la modificación de la colección; por lo tanto, si se realizan cambios en la colección subyacente, la colección de solo lectura refleja los cambios.  
  
 La recuperación del valor de esta propiedad es una operación O(1).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.Item">
      <MemberSignature Language="C#" Value="object System.Collections.IList.Item[int index] { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object System.Collections.IList.Item(int32)" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.List`1.System#Collections#IList#Item(System.Int32)" />
      <MemberSignature Language="VB.NET" Value=" Property Item(index As Integer) As Object Implements IList.Item" />
      <MemberSignature Language="C++ CLI" Value="property System::Object ^ System::Collections::IList::Item[int] { System::Object ^ get(int index); void set(int index, System::Object ^ value); };" />
      <MemberSignature Language="F#" Usage="System.Collections.IList.Item" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.IList.Item(System.Int32)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">Índice de base cero del elemento que se va a obtener o establecer.</param>
        <summary>Obtiene o establece el elemento en el índice especificado.</summary>
        <value>Elemento en el índice especificado.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El lenguaje C# utiliza la [esto](~/docs/csharp/language-reference/keywords/this.md) palabra clave para definir los indizadores en lugar de implementar el <xref:System.Collections.Generic.List%601.System%23Collections%23IList%23Item%2A> propiedad. Visual Basic implementa <xref:System.Collections.Generic.List%601.System%23Collections%23IList%23Item%2A> como propiedad predeterminada, lo que proporciona la misma funcionalidad de indización.  
  
 Recuperar el valor de esta propiedad es una operación o (1); establecer la propiedad también es una operación o (1).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> no es un índice válido para <see cref="T:System.Collections.IList" />.</exception>
        <exception cref="T:System.ArgumentException">La propiedad ya está establecida y el tipo de <paramref name="value" /> no se puede asignar a la interfaz <see cref="T:System.Collections.IList" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.Remove">
      <MemberSignature Language="C#" Value="void IList.Remove (object item);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Collections.IList.Remove(object item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.System#Collections#IList#Remove(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Sub Remove (item As Object) Implements IList.Remove" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Collections.IList.Remove(System::Object ^ item) = System::Collections::IList::Remove;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IList.Remove(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="item">Objeto que se va a quitar de <see cref="T:System.Collections.IList" />.</param>
        <summary>Quita la primera aparición de un objeto específico de la interfaz <see cref="T:System.Collections.IList" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método determina la igualdad utilizando el comparador de igualdad predeterminado <xref:System.Collections.Generic.EqualityComparer%601.Default%2A?displayProperty=nameWithType> para `T`, el tipo de valores en la lista.  
  
 Este método realiza una búsqueda lineal; por lo tanto, este método es O (*n*) operación, donde *n* es <xref:System.Collections.Generic.List%601.Count%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="item" /> es de un tipo que no se puede asignar a <see cref="T:System.Collections.IList" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ToArray">
      <MemberSignature Language="C#" Value="public T[] ToArray ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance !T[] ToArray() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.ToArray" />
      <MemberSignature Language="VB.NET" Value="Public Function ToArray () As T()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;T&gt; ^ ToArray();" />
      <MemberSignature Language="F#" Value="member this.ToArray : unit -&gt; 'T[]" Usage="list.ToArray " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Copia los elementos de <see cref="T:System.Collections.Generic.List`1" /> en una nueva matriz.</summary>
        <returns>Matriz que contiene copias de los elementos de <see cref="T:System.Collections.Generic.List`1" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Los elementos se copian con <xref:System.Array.Copy%2A?displayProperty=nameWithType>, que es O (*n*) operación, donde *n* es <xref:System.Collections.Generic.List%601.Count%2A>.  
  
 Este método es O (*n*) operación, donde *n* es <xref:System.Collections.Generic.List%601.Count%2A>.  
  
   
  
## Examples  
 En el ejemplo siguiente se muestra el <xref:System.Collections.Generic.List%601.ToArray%2A> método y otros métodos de la <xref:System.Collections.Generic.List%601> clases que actúan en intervalos. Al final del ejemplo, el <xref:System.Collections.Generic.List%601.GetRange%2A> método se usa para obtener tres elementos de la lista, empezando por la posición de índice 2. El <xref:System.Collections.Generic.List%601.ToArray%2A> se llama al método en resultante <xref:System.Collections.Generic.List%601>, creación de una matriz de tres elementos. Se muestran los elementos de la matriz.  
  
 [!code-cpp[List\`1_Ranges#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_Ranges/cpp/source.cpp#1)]
 [!code-csharp[List\`1_Ranges#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_Ranges/cs/source.cs#1)]
 [!code-vb[List\`1_Ranges#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_Ranges/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TrimExcess">
      <MemberSignature Language="C#" Value="public void TrimExcess ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void TrimExcess() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.TrimExcess" />
      <MemberSignature Language="VB.NET" Value="Public Sub TrimExcess ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void TrimExcess();" />
      <MemberSignature Language="F#" Value="member this.TrimExcess : unit -&gt; unit" Usage="list.TrimExcess " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Establece la capacidad en el número real de elementos que hay en <see cref="T:System.Collections.Generic.List`1" />, si dicho número es inferior a un valor umbral.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método puede utilizarse para minimizar la sobrecarga de memoria de una colección si ningún elemento nuevo se agregará a la colección. El costo de reasignar y copiar una gran <xref:System.Collections.Generic.List%601> puede ser considerable, sin embargo, por lo que el <xref:System.Collections.Generic.List%601.TrimExcess%2A> método no hace nada si la lista está en más del 90 por ciento de capacidad. Esto evita incurrir en un gran costo de reasignación para lograr una mejora relativamente pequeña.  
  
> [!NOTE]
>  Umbral actual del 90 por ciento puede cambiar en futuras versiones.  
  
 Este método es O (*n*) operación, donde *n* es <xref:System.Collections.Generic.List%601.Count%2A>.  
  
 Para restablecer un <xref:System.Collections.Generic.List%601> a su estado inicial, llame a la <xref:System.Collections.Generic.List%601.Clear%2A> método antes de llamar a la <xref:System.Collections.Generic.List%601.TrimExcess%2A> método. Recorte vacío <xref:System.Collections.Generic.List%601> establece la capacidad de la <xref:System.Collections.Generic.List%601> a la capacidad predeterminada.  
  
 También se puede establecer la capacidad mediante la <xref:System.Collections.Generic.List%601.Capacity%2A> propiedad.  
  
   
  
## Examples  
 En el ejemplo siguiente se muestra cómo comprobar la capacidad y el recuento de un <xref:System.Collections.Generic.List%601> que contiene un objeto comercial simple y se muestra cómo utilizar el <xref:System.Collections.Generic.List%601.TrimExcess%2A> método para quitar la capacidad adicional.  
  
 [!code-csharp[System.Collections.Generic.List.CapacityCount#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.collections.generic.list.capacitycount/cs/program.cs#1)]
 [!code-vb[System.Collections.Generic.List.CapacityCount#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.collections.generic.list.capacitycount/vb/module1.vb#1)]  
  
 En el ejemplo siguiente se muestra el <xref:System.Collections.Generic.List%601.TrimExcess%2A> método. Varias propiedades y métodos de la <xref:System.Collections.Generic.List%601> clase se utilizan para agregar, insertar y quitar elementos de una lista de cadenas. El <xref:System.Collections.Generic.List%601.TrimExcess%2A> método se usa para reducir la capacidad para que coincida con el recuento y el <xref:System.Collections.Generic.List%601.Capacity%2A> y <xref:System.Collections.Generic.List%601.Count%2A> se muestran las propiedades. Si la capacidad no utilizada hubiera sido inferior a 10 por ciento de la capacidad total, la lista no habría tamaño ha cambiado. Por último, se borra el contenido de la lista.  
  
 [!code-cpp[List\`1_Class#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_Class/cpp/source.cpp#1)]
 [!code-csharp[List\`1_Class#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_Class/cs/source.cs#1)]
 [!code-vb[List\`1_Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_Class/vb/source.vb#1)]  
 [!code-fsharp[List\`1_Class#1](~/samples/snippets/fsharp/VS_Snippets_CLR/List`1_Class/fs/listclass.fs#1)]
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Collections.Generic.List`1.Clear" />
        <altmember cref="P:System.Collections.Generic.List`1.Capacity" />
        <altmember cref="P:System.Collections.Generic.List`1.Count" />
      </Docs>
    </Member>
    <Member MemberName="TrueForAll">
      <MemberSignature Language="C#" Value="public bool TrueForAll (Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TrueForAll(class System.Predicate`1&lt;!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.TrueForAll(System.Predicate{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Function TrueForAll (match As Predicate(Of T)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TrueForAll(Predicate&lt;T&gt; ^ match);" />
      <MemberSignature Language="F#" Value="member this.TrueForAll : Predicate&lt;'T&gt; -&gt; bool" Usage="list.TrueForAll match" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="match">Delegado <see cref="T:System.Predicate`1" /> que define las condiciones que los elementos deben cumplir.</param>
        <summary>Determina si cada elemento de <see cref="T:System.Collections.Generic.List`1" /> cumple las condiciones que define el predicado especificado.</summary>
        <returns>Es <see langword="true" /> si cada elemento de <see cref="T:System.Collections.Generic.List`1" /> cumple las condiciones definidas por el predicado especificado; en caso contrario, es <see langword="false" />. Si la lista no tiene ningún elemento, el valor devuelto es <see langword="true" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Predicate%601> es un delegado a un método que devuelve `true` si el objeto pasado a coincide con las condiciones definidas en el delegado.  Los elementos del elemento actual <xref:System.Collections.Generic.List%601> individualmente se pasan a la <xref:System.Predicate%601> delegado y el procesamiento se detiene cuando se devuelve el delegado `false` para cualquier elemento. Los elementos se procesan en orden y todas las llamadas se realizan en un único subproceso.  
  
 Este método es O (*n*) operación, donde *n* es <xref:System.Collections.Generic.List%601.Count%2A>.  
  
   
  
## Examples  
 En el ejemplo siguiente se muestra el <xref:System.Collections.Generic.List%601.TrueForAll%2A> método y muchos otros métodos que usan <xref:System.Predicate%601> delegado genérico.  
  
 Un <xref:System.Collections.Generic.List%601> de cadenas se crea, que contiene 8 nombres de dinosaurios, dos de los cuales (en las posiciones 1 y 5) terminan en "saurus". El ejemplo también define un método de predicado de búsqueda denominado `EndsWithSaurus`, que acepta un parámetro de cadena y devuelve un valor booleano que indica si la cadena de entrada termina en "saurus".  
  
 El <xref:System.Collections.Generic.List%601.TrueForAll%2A> método recorre la lista desde el principio, pasando cada elemento a su vez a la `EndsWithSaurus` método. La búsqueda detiene cuando la `EndsWithSaurus` devuelve del método `false`.  
  
> [!NOTE]
>  En C# y Visual Basic, no es necesario crear la `Predicate<string>` delegar (`Predicate(Of String)` en Visual Basic) explícitamente. Estos lenguajes deducen al delegado correcto del contexto y lo crean automáticamente.  
  
 [!code-cpp[List\`1_FindEtAl#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_FindEtAl/cpp/source.cpp#1)]
 [!code-csharp[List\`1_FindEtAl#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_FindEtAl/cs/source.cs#1)]
 [!code-vb[List\`1_FindEtAl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_FindEtAl/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="match" /> es <see langword="null" />.</exception>
        <altmember cref="M:System.Collections.Generic.List`1.Exists(System.Predicate{`0})" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
  </Members>
</Type>