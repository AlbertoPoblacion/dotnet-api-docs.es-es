<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="List`1.xml" source-language="en-US" target-language="es-ES">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-efd8310" tool-company="Microsoft" />
      <xliffext:skl_file_name xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">5e05b5b2-d481-4262-b7b7-7de7ac2afe07649dc28c23dbde95771a5a23c8feb6e1086637c4.skl</xliffext:skl_file_name>
      <xliffext:version xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">1.2</xliffext:version>
      <xliffext:ms.openlocfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">649dc28c23dbde95771a5a23c8feb6e1086637c4</xliffext:ms.openlocfilehash>
      <xliffext:ms.sourcegitcommit xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">df6cf590aa3087f6c7c202712eee781c6a3c8f96</xliffext:ms.sourcegitcommit>
      <xliffext:ms.lasthandoff xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">05/07/2018</xliffext:ms.lasthandoff>
      <xliffext:moniker_ids xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">netcore-1.0,netcore-1.1,netcore-2.0,netcore-2.1,netframework-4.5.1,netframework-4.5.2,netframework-4.5,netframework-4.6.1,netframework-4.6.2,netframework-4.6,netframework-4.7.1,netframework-4.7.2,netframework-4.7,netstandard-1.0,netstandard-1.1,netstandard-1.2,netstandard-1.3,netstandard-1.4,netstandard-1.6,netstandard-2.0,xamarinandroid-7.1,xamarinios-10.8,xamarinmac-3.0</xliffext:moniker_ids>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.Generic.List`1">
          <source>The type of elements in the list.</source>
          <target state="translated">Tipo de elementos en la lista.</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve" uid="T:System.Collections.Generic.List`1">
          <source>Represents a strongly typed list of objects that can be accessed by index.</source>
          <target state="translated">Representa una lista de objetos fuertemente tipados a la que se puede obtener acceso por índice.</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve" uid="T:System.Collections.Generic.List`1">
          <source>Provides methods to search, sort, and manipulate lists.</source>
          <target state="translated">Proporciona métodos para buscar, ordenar y manipular listas.</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.Generic.List`1">
          <source>The <ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph> class is the generic equivalent of the <ph id="ph2">&lt;xref:System.Collections.ArrayList&gt;</ph> class.</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph> clase es el equivalente genérico de la <ph id="ph2">&lt;xref:System.Collections.ArrayList&gt;</ph> clase.</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.Generic.List`1">
          <source>It implements the <ph id="ph1">&lt;xref:System.Collections.Generic.IList%601&gt;</ph> generic interface by using an array whose size is dynamically increased as required.</source>
          <target state="translated">Implementa el <ph id="ph1">&lt;xref:System.Collections.Generic.IList%601&gt;</ph> interfaz genérico mediante una matriz cuyo tamaño aumenta dinámicamente cuando es necesario.</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.Generic.List`1">
          <source>You can add items to a <ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph> by using the <ph id="ph2">&lt;xref:System.Collections.Generic.List%601.Add%2A&gt;</ph> or <ph id="ph3">&lt;xref:System.Collections.Generic.List%601.AddRange%2A&gt;</ph> methods.</source>
          <target state="translated">Puede agregar elementos a un <ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph> mediante el uso de la <ph id="ph2">&lt;xref:System.Collections.Generic.List%601.Add%2A&gt;</ph> o <ph id="ph3">&lt;xref:System.Collections.Generic.List%601.AddRange%2A&gt;</ph> métodos.</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.Generic.List`1">
          <source>The <ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph> class uses both an equality comparer and an ordering comparer.</source>
          <target state="translated">La <ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph> clase usa un comparador de igualdad y un comparador de orden.</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.Generic.List`1">
          <source>Methods such as <ph id="ph1">&lt;xref:System.Collections.Generic.List%601.Contains%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Collections.Generic.List%601.IndexOf%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.Collections.Generic.List%601.LastIndexOf%2A&gt;</ph>, and <ph id="ph4">&lt;xref:System.Collections.Generic.Dictionary%602.Remove%2A&gt;</ph> use an equality comparer for the list elements.</source>
          <target state="translated">Métodos como <ph id="ph1">&lt;xref:System.Collections.Generic.List%601.Contains%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Collections.Generic.List%601.IndexOf%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.Collections.Generic.List%601.LastIndexOf%2A&gt;</ph>, y <ph id="ph4">&lt;xref:System.Collections.Generic.Dictionary%602.Remove%2A&gt;</ph> utilizan un comparador de igualdad para los elementos de lista.</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.Generic.List`1">
          <source>The default equality comparer for type <ph id="ph1">`T`</ph> is determined as follows.</source>
          <target state="translated">El comparador de igualdad predeterminado para el tipo <ph id="ph1">`T`</ph> se determina como sigue.</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.Generic.List`1">
          <source>If type <ph id="ph1">`T`</ph> implements the <ph id="ph2">&lt;xref:System.IEquatable%601&gt;</ph> generic interface, then the equality comparer is the <ph id="ph3">&lt;xref:System.IEquatable%601.Equals%28%600%29&gt;</ph> method of that interface; otherwise, the default equality comparer is <ph id="ph4">&lt;xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Si tipo <ph id="ph1">`T`</ph> implementa la <ph id="ph2">&lt;xref:System.IEquatable%601&gt;</ph> interfaz genérica, el comparador de igualdad es el <ph id="ph3">&lt;xref:System.IEquatable%601.Equals%28%600%29&gt;</ph> método de dicha interfaz; en caso contrario, el comparador de igualdad predeterminado es <ph id="ph4">&lt;xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.Generic.List`1">
          <source>Methods such as <ph id="ph1">&lt;xref:System.Collections.Generic.List%601.BinarySearch%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Collections.Generic.List%601.Sort%2A&gt;</ph> use an ordering comparer for the list elements.</source>
          <target state="translated">Métodos como <ph id="ph1">&lt;xref:System.Collections.Generic.List%601.BinarySearch%2A&gt;</ph> y <ph id="ph2">&lt;xref:System.Collections.Generic.List%601.Sort%2A&gt;</ph> utilizan un comparador de orden para los elementos de lista.</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.Generic.List`1">
          <source>The default comparer for type <ph id="ph1">`T`</ph> is determined as follows.</source>
          <target state="translated">El comparador predeterminado para el tipo <ph id="ph1">`T`</ph> se determina como sigue.</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.Generic.List`1">
          <source>If type <ph id="ph1">`T`</ph> implements the <ph id="ph2">&lt;xref:System.IComparable%601&gt;</ph> generic interface, then the default comparer is the <ph id="ph3">&lt;xref:System.IComparable%601.CompareTo%28%600%29&gt;</ph> method of that interface; otherwise, if type <ph id="ph4">`T`</ph> implements the nongeneric <ph id="ph5">&lt;xref:System.IComparable&gt;</ph> interface, then the default comparer is the <ph id="ph6">&lt;xref:System.IComparable.CompareTo%28System.Object%29&gt;</ph> method of that interface.</source>
          <target state="translated">Si tipo <ph id="ph1">`T`</ph> implementa la <ph id="ph2">&lt;xref:System.IComparable%601&gt;</ph> interfaz genérica, el comparador predeterminado es la <ph id="ph3">&lt;xref:System.IComparable%601.CompareTo%28%600%29&gt;</ph> método de dicha interfaz; en caso contrario, si tipo <ph id="ph4">`T`</ph> implementa la interfaz no genérica <ph id="ph5">&lt;xref:System.IComparable&gt;</ph> interfaz, el comparador predeterminado es la <ph id="ph6">&lt;xref:System.IComparable.CompareTo%28System.Object%29&gt;</ph> método de dicha interfaz.</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.Generic.List`1">
          <source>If type <ph id="ph1">`T`</ph> implements neither interface, then there is no default comparer, and a comparer or comparison delegate must be provided explicitly.</source>
          <target state="translated">Si tipo <ph id="ph1">`T`</ph> implementa ninguna de estas interfaces, no hay ningún comparador predeterminado y se debe proporcionar explícitamente un delegado de comparación o comparador.</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.Generic.List`1">
          <source>The <ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph> is not guaranteed to be sorted.</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph> no se garantiza que se ordenen.</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.Generic.List`1">
          <source>You must sort the <ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph> before performing operations (such as <ph id="ph2">&lt;xref:System.Collections.Generic.List%601.BinarySearch%2A&gt;</ph>) that require the <ph id="ph3">&lt;xref:System.Collections.Generic.List%601&gt;</ph> to be sorted.</source>
          <target state="translated">Se debe ordenar el <ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph> antes de realizar operaciones (como <ph id="ph2">&lt;xref:System.Collections.Generic.List%601.BinarySearch%2A&gt;</ph>) que requieren el <ph id="ph3">&lt;xref:System.Collections.Generic.List%601&gt;</ph> se ordenen.</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.Generic.List`1">
          <source>Elements in this collection can be accessed using an integer index.</source>
          <target state="translated">Pueden tener acceso a los elementos de esta colección utilizando un índice entero.</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.Generic.List`1">
          <source>Indexes in this collection are zero-based.</source>
          <target state="translated">Índices de esta colección son de base cero.</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.Generic.List`1">
          <source>For very large <ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph> objects, you can increase the maximum capacity to 2 billion elements on a 64-bit system by setting the <ph id="ph2">`enabled`</ph> attribute of the  configuration element to <ph id="ph3">`true`</ph> in the run-time environment.</source>
          <target state="translated">Para un gran <ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph> objetos, puede aumentar la capacidad máxima de 2 millones de elementos en un sistema de 64 bits estableciendo la <ph id="ph2">`enabled`</ph> atributo del elemento de configuración para <ph id="ph3">`true`</ph> en el entorno de tiempo de ejecución.</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.Generic.List`1">
          <source><ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph> accepts <ph id="ph2">`null`</ph> as a valid value for reference types and allows duplicate elements.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph> acepta <ph id="ph2">`null`</ph> como un valor válido para la referencia de tipos y permite a los elementos duplicados.</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.Generic.List`1">
          <source>For an immutable version of the <ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph> class, see <ph id="ph2">&lt;xref:System.Collections.Immutable.ImmutableList%601&gt;</ph>.</source>
          <target state="translated">Para obtener una versión inmutable de la <ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph> de clases, consulte <ph id="ph2">&lt;xref:System.Collections.Immutable.ImmutableList%601&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.Generic.List`1">
          <source>Performance Considerations</source>
          <target state="translated">Consideraciones sobre el rendimiento</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.Generic.List`1">
          <source>In deciding whether to use the <ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph> or <ph id="ph2">&lt;xref:System.Collections.ArrayList&gt;</ph> class, both of which have similar functionality, remember that the <ph id="ph3">&lt;xref:System.Collections.Generic.List%601&gt;</ph> class performs better in most cases and is type safe.</source>
          <target state="translated">Hora de decidir si desea utilizar el <ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph> o <ph id="ph2">&lt;xref:System.Collections.ArrayList&gt;</ph> (clase), ambos de los cuales tienen una funcionalidad similar, recuerde que la <ph id="ph3">&lt;xref:System.Collections.Generic.List%601&gt;</ph> clase funciona mejor en la mayoría de los casos y tiene seguridad de tipos.</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.Generic.List`1">
          <source>If a reference type is used for type <ph id="ph1">`T`</ph> of the <ph id="ph2">&lt;xref:System.Collections.Generic.List%601&gt;</ph> class, the behavior of the two classes is identical.</source>
          <target state="translated">Si se usa un tipo de referencia de tipo <ph id="ph1">`T`</ph> de la <ph id="ph2">&lt;xref:System.Collections.Generic.List%601&gt;</ph> (clase), el comportamiento de las dos clases es idéntico.</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.Generic.List`1">
          <source>However, if a value type is used for type <ph id="ph1">`T`</ph>, you need to consider implementation and boxing issues.</source>
          <target state="translated">Sin embargo, si se usa un tipo de valor de tipo <ph id="ph1">`T`</ph>, debe tener en cuenta los problemas de implementación y conversión boxing.</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.Generic.List`1">
          <source>If a value type is used for type <ph id="ph1">`T`</ph>, the compiler generates an implementation of the <ph id="ph2">&lt;xref:System.Collections.Generic.List%601&gt;</ph> class specifically for that value type.</source>
          <target state="translated">Si se usa un tipo de valor de tipo <ph id="ph1">`T`</ph>, el compilador genera una implementación de la <ph id="ph2">&lt;xref:System.Collections.Generic.List%601&gt;</ph> clase específicamente para ese tipo de valor.</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.Generic.List`1">
          <source>That means a list element of a <ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph> object does not have to be boxed before the element can be used, and after about 500 list elements are created the memory saved not boxing list elements is greater than the memory used to generate the class implementation.</source>
          <target state="translated">Es decir, un elemento de lista de un <ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph> objeto no tiene que aplicar la conversión boxing antes de que el elemento se puede usar y, después de unos 500 elementos de lista se crean la memoria ahorrada no conversión boxing de los elementos de lista es mayor que la memoria utilizada para generar la implementación de la clase.</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.Generic.List`1">
          <source>Make certain the value type used for type <ph id="ph1">`T`</ph> implements the <ph id="ph2">&lt;xref:System.IEquatable%601&gt;</ph> generic interface.</source>
          <target state="translated">Compruebe el tipo de valor utilizado para el tipo <ph id="ph1">`T`</ph> implementa el <ph id="ph2">&lt;xref:System.IEquatable%601&gt;</ph> interfaz genérica.</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.Generic.List`1">
          <source>If not, methods such as <ph id="ph1">&lt;xref:System.Collections.Generic.List%601.Contains%2A&gt;</ph> must call the <ph id="ph2">&lt;xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType&gt;</ph> method, which boxes the affected list element.</source>
          <target state="translated">Si no es así, los métodos como <ph id="ph1">&lt;xref:System.Collections.Generic.List%601.Contains%2A&gt;</ph> debe llamar a la <ph id="ph2">&lt;xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType&gt;</ph> método, que el elemento de lista afectado los cuadros.</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.Generic.List`1">
          <source>If the value type implements the <ph id="ph1">&lt;xref:System.IComparable&gt;</ph> interface and you own the source code, also implement the <ph id="ph2">&lt;xref:System.IComparable%601&gt;</ph> generic interface to prevent the <ph id="ph3">&lt;xref:System.Collections.Generic.List%601.BinarySearch%2A&gt;</ph> and <ph id="ph4">&lt;xref:System.Collections.Generic.List%601.Sort%2A&gt;</ph> methods from boxing list elements.</source>
          <target state="translated">Si el tipo de valor implementa la <ph id="ph1">&lt;xref:System.IComparable&gt;</ph> interfaz y posee el código fuente, también se implemente el <ph id="ph2">&lt;xref:System.IComparable%601&gt;</ph> interfaz genérica para evitar la <ph id="ph3">&lt;xref:System.Collections.Generic.List%601.BinarySearch%2A&gt;</ph> y <ph id="ph4">&lt;xref:System.Collections.Generic.List%601.Sort%2A&gt;</ph> métodos de conversión boxing de los elementos de lista.</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.Generic.List`1">
          <source>If you do not own the source code, pass an <ph id="ph1">&lt;xref:System.Collections.Generic.IComparer%601&gt;</ph> object to the <ph id="ph2">&lt;xref:System.Collections.Generic.List%601.BinarySearch%2A&gt;</ph> and <ph id="ph3">&lt;xref:System.Collections.Generic.List%601.Sort%2A&gt;</ph> methods</source>
          <target state="translated">Si no dispone del código fuente, pase una <ph id="ph1">&lt;xref:System.Collections.Generic.IComparer%601&gt;</ph> el objeto a la <ph id="ph2">&lt;xref:System.Collections.Generic.List%601.BinarySearch%2A&gt;</ph> y <ph id="ph3">&lt;xref:System.Collections.Generic.List%601.Sort%2A&gt;</ph> métodos</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.Generic.List`1">
          <source>It is to your advantage to use the type-specific implementation of the <ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph> class instead of using the <ph id="ph2">&lt;xref:System.Collections.ArrayList&gt;</ph> class or writing a strongly typed wrapper collection yourself.</source>
          <target state="translated">Es una ventaja de usar la implementación específica del tipo de la <ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph> clase en lugar de usar la <ph id="ph2">&lt;xref:System.Collections.ArrayList&gt;</ph> clase o escribir una colección de contenedor fuertemente tipado usted mismo.</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.Generic.List`1">
          <source>The reason is your implementation must do what the .NET Framework does for you already, and the common language runtime can share Microsoft intermediate language code and metadata, which your implementation cannot.</source>
          <target state="translated">La razón es que la propia implementación debe hacer lo que .NET Framework ya realiza automáticamente, y common language runtime puede compartir código de lenguaje intermedio de Microsoft y los metadatos, que la implementación no puede hacer.</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.Generic.List`1">
          <source>F# Considerations</source>
          <target state="translated">Consideraciones de F #</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.Generic.List`1">
          <source>The <ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph> class is used infrequently in F# code.</source>
          <target state="translated">La <ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph> clase se utiliza con poca frecuencia en el código de F #.</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.Generic.List`1">
          <source>Instead, <bpt id="p1">[</bpt>Lists<ept id="p1">](http://msdn.microsoft.com/library/83102799-f251-42e1-93ef-64232e8c5b1d)</ept>, which are immutable, singly-linked lists, are typically preferred.</source>
          <target state="translated">En su lugar, <bpt id="p1">[</bpt>enumera<ept id="p1">](http://msdn.microsoft.com/library/83102799-f251-42e1-93ef-64232e8c5b1d)</ept>, que son listas inmutable, vinculada individualmente, se suele ser el preferido.</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.Generic.List`1">
          <source>An F# List provides an ordered, immutable series of values, and is supported for use in functional-style development.</source>
          <target state="translated">Una lista de F # proporciona una serie ordenada e inmutable de valores y se puede usar en el desarrollo de estilo funcional.</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.Generic.List`1">
          <source>When used from F#, the <ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph> class is typically referred to by the  <bpt id="p1">[</bpt>ResizeArray<ph id="ph2">\&lt;</ph>'T&gt;<ept id="p1">](https://msdn.microsoft.com/library/ee353447.aspx)</ept> type abbreviation to avoid naming conflicts with F# Lists</source>
          <target state="translated">Cuando se utiliza en F #, la <ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph> clase normalmente se conoce por el <bpt id="p1">[</bpt>ResizeArray<ph id="ph2">\&lt;</ph>' t &gt;<ept id="p1">](https://msdn.microsoft.com/library/ee353447.aspx)</ept> escriba abreviatura para evitar conflictos con listas de F #</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.Generic.List`1">
          <source>The following example demonstrates how to add, remove, and insert a simple business object in a <ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph>.</source>
          <target state="translated">En el ejemplo siguiente se muestra cómo agregar, quitar e insertar un objeto comercial simple en una <ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.Generic.List`1">
          <source>The following example demonstrates several properties and methods of the <ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph> generic class of type string.</source>
          <target state="translated">En el ejemplo siguiente se muestra varias propiedades y métodos de la <ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph> clase genérica de tipo cadena.</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.Generic.List`1">
          <source>(For an example of a <ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph> of complex types, see the <ph id="ph2">&lt;xref:System.Collections.Generic.List%601.Contains%2A&gt;</ph> method.)</source>
          <target state="translated">(Para obtener un ejemplo de un <ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph> de tipos complejos, vea la <ph id="ph2">&lt;xref:System.Collections.Generic.List%601.Contains%2A&gt;</ph> método.)</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.Generic.List`1">
          <source>The default constructor is used to create a list of strings with the default capacity.</source>
          <target state="translated">El constructor predeterminado se utiliza para crear una lista de cadenas con la capacidad predeterminada.</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.Generic.List`1">
          <source>The <ph id="ph1">&lt;xref:System.Collections.Generic.List%601.Capacity%2A&gt;</ph> property is displayed and then the <ph id="ph2">&lt;xref:System.Collections.Generic.List%601.Add%2A&gt;</ph> method is used to add several items.</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.Collections.Generic.List%601.Capacity%2A&gt;</ph> propiedad se muestra y, a continuación, el <ph id="ph2">&lt;xref:System.Collections.Generic.List%601.Add%2A&gt;</ph> método se usa para agregar varios elementos.</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.Generic.List`1">
          <source>The items are listed, and the <ph id="ph1">&lt;xref:System.Collections.Generic.List%601.Capacity%2A&gt;</ph> property is displayed again, along with the <ph id="ph2">&lt;xref:System.Collections.Generic.List%601.Count%2A&gt;</ph> property, to show that the capacity has been increased as needed.</source>
          <target state="translated">Se enumeran los elementos y la <ph id="ph1">&lt;xref:System.Collections.Generic.List%601.Capacity%2A&gt;</ph> propiedad se muestra una vez más, junto con el <ph id="ph2">&lt;xref:System.Collections.Generic.List%601.Count%2A&gt;</ph> propiedad, para mostrar que se ha aumentado la capacidad según sea necesario.</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.Generic.List`1">
          <source>The <ph id="ph1">&lt;xref:System.Collections.Generic.List%601.Contains%2A&gt;</ph> method is used to test for the presence of an item in the list, the <ph id="ph2">&lt;xref:System.Collections.Generic.List%601.Insert%2A&gt;</ph> method is used to insert a new item in the middle of the list, and the contents of the list are displayed again.</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.Collections.Generic.List%601.Contains%2A&gt;</ph> método se usa para comprobar la presencia de un elemento en la lista, el <ph id="ph2">&lt;xref:System.Collections.Generic.List%601.Insert%2A&gt;</ph> método se utiliza para insertar un nuevo elemento en el medio de la lista y se muestra el contenido de la lista de nuevo.</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.Generic.List`1">
          <source>The default <ph id="ph1">&lt;xref:System.Collections.Generic.List%601.Item%2A&gt;</ph> property (the indexer in C#) is used to retrieve an item, the <ph id="ph2">&lt;xref:System.Collections.Generic.List%601.Remove%2A&gt;</ph> method is used to remove the first instance of the duplicate item added earlier, and the contents are displayed again.</source>
          <target state="translated">El valor predeterminado <ph id="ph1">&lt;xref:System.Collections.Generic.List%601.Item%2A&gt;</ph> propiedad (el indizador en C#) se utiliza para recuperar un elemento, el <ph id="ph2">&lt;xref:System.Collections.Generic.List%601.Remove%2A&gt;</ph> método se utiliza para quitar la primera instancia del elemento duplicado agregado anteriormente y se muestra el contenido nuevo.</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.Generic.List`1">
          <source>The <ph id="ph1">&lt;xref:System.Collections.Generic.List%601.Remove%2A&gt;</ph> method always removes the first instance it encounters.</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.Collections.Generic.List%601.Remove%2A&gt;</ph> método siempre quita la primera instancia que encuentra.</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.Generic.List`1">
          <source>The <ph id="ph1">&lt;xref:System.Collections.Generic.List%601.TrimExcess%2A&gt;</ph> method is used to reduce the capacity to match the count, and the <ph id="ph2">&lt;xref:System.Collections.Generic.List%601.Capacity%2A&gt;</ph> and <ph id="ph3">&lt;xref:System.Collections.Generic.List%601.Count%2A&gt;</ph> properties are displayed.</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.Collections.Generic.List%601.TrimExcess%2A&gt;</ph> método se usa para reducir la capacidad para que coincida con el recuento y el <ph id="ph2">&lt;xref:System.Collections.Generic.List%601.Capacity%2A&gt;</ph> y <ph id="ph3">&lt;xref:System.Collections.Generic.List%601.Count%2A&gt;</ph> se muestran las propiedades.</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.Generic.List`1">
          <source>If the unused capacity had been less than 10 percent of total capacity, the list would not have been resized.</source>
          <target state="translated">Si la capacidad no utilizada hubiera sido menor que el 10 por ciento de la capacidad total, la lista no habría cambió de tamaño.</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.Generic.List`1">
          <source>Finally, the <ph id="ph1">&lt;xref:System.Collections.Generic.List%601.Clear%2A&gt;</ph> method is used to remove all items from the list, and the <ph id="ph2">&lt;xref:System.Collections.Generic.List%601.Capacity%2A&gt;</ph> and <ph id="ph3">&lt;xref:System.Collections.Generic.List%601.Count%2A&gt;</ph> properties are displayed.</source>
          <target state="translated">Por último, el <ph id="ph1">&lt;xref:System.Collections.Generic.List%601.Clear%2A&gt;</ph> método se utiliza para quitar todos los elementos de la lista y el <ph id="ph2">&lt;xref:System.Collections.Generic.List%601.Capacity%2A&gt;</ph> y <ph id="ph3">&lt;xref:System.Collections.Generic.List%601.Count%2A&gt;</ph> se muestran las propiedades.</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.Generic.List`1">
          <source>Public static (<ph id="ph1">&lt;see langword="Shared" /&gt;</ph> in Visual Basic) members of this type are thread safe.</source>
          <target state="translated">Estático público (<ph id="ph1">&lt;see langword="Shared" /&gt;</ph> en Visual Basic) miembros de este tipo son seguros para subprocesos.</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.Generic.List`1">
          <source>Any instance members are not guaranteed to be thread safe.</source>
          <target state="translated">No se garantiza que los miembros de instancias sean seguros para la ejecución de subprocesos.</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.Generic.List`1">
          <source>It is safe to perform multiple read operations on a <ph id="ph1">&lt;see cref="T:System.Collections.Generic.List`1" /&gt;</ph>, but issues can occur if the collection is modified while it’s being read.</source>
          <target state="translated">Es seguro realizar varias operaciones de lectura en un <ph id="ph1">&lt;see cref="T:System.Collections.Generic.List`1" /&gt;</ph>, pero pueden producirse problemas si se modifica la colección mientras se está leyendo.</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.Generic.List`1">
          <source>To ensure thread safety, lock the collection during a read or write operation.</source>
          <target state="translated">Para garantizar la seguridad para subprocesos, bloquear la colección durante una lectura o la operación de escritura.</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.Generic.List`1">
          <source>To enable a collection to be accessed by multiple threads for reading and writing, you must implement your own synchronization.</source>
          <target state="translated">Para habilitar obtengan acceso varios subprocesos de lectura y escritura a una colección, debe implementar su propia sincronización.</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.Generic.List`1">
          <source>For collections with built-in synchronization, see the classes in the <ph id="ph1">&lt;see cref="N:System.Collections.Concurrent" /&gt;</ph> namespace.</source>
          <target state="translated">Para las colecciones con la sincronización integrada, vea las clases en el <ph id="ph1">&lt;see cref="N:System.Collections.Concurrent" /&gt;</ph> espacio de nombres.</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.Generic.List`1">
          <source>For an inherently thread–safe alternative, see the <ph id="ph1">&lt;see cref="T:System.Collections.Immutable.ImmutableList`1" /&gt;</ph> class.</source>
          <target state="translated">Para una alternativa de forma inherente: seguridad de subprocesos, vea la <ph id="ph1">&lt;see cref="T:System.Collections.Immutable.ImmutableList`1" /&gt;</ph> clase.</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve" uid="T:System.Collections.Generic.List`1">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Collections.Generic.List`1" /&gt;</ph> class.</source>
          <target state="translated">Inicializa una nueva instancia de la clase <ph id="ph1">&lt;see cref="T:System.Collections.Generic.List`1" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.List`1.#ctor">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Collections.Generic.List`1" /&gt;</ph> class that is empty and has the default initial capacity.</source>
          <target state="translated">Inicializa una nueva instancia de la clase <ph id="ph1">&lt;see cref="T:System.Collections.Generic.List`1" /&gt;</ph> que está vacía y tiene la capacidad inicial predeterminada.</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.#ctor">
          <source>The capacity of a <ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph> is the number of elements that the <ph id="ph2">&lt;xref:System.Collections.Generic.List%601&gt;</ph> can hold.</source>
          <target state="translated">La capacidad de un <ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph> es el número de elementos que la <ph id="ph2">&lt;xref:System.Collections.Generic.List%601&gt;</ph> puede contener.</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.#ctor">
          <source>As elements are added to a <ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph>, the capacity is automatically increased as required by reallocating the internal array.</source>
          <target state="translated">Cuando se agregan elementos a un <ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph>, la capacidad aumenta automáticamente según sea necesario mediante la reasignación de la matriz interna.</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.#ctor">
          <source>If the size of the collection can be estimated, using the <ph id="ph1">&lt;xref:System.Collections.Generic.List%601.%23ctor%28System.Int32%29&gt;</ph> constructor and specifying the initial capacity eliminates the need to perform a number of resizing operations while adding elements to the <ph id="ph2">&lt;xref:System.Collections.Generic.List%601&gt;</ph>.</source>
          <target state="translated">Si se puede estimar el tamaño de la colección, usando la <ph id="ph1">&lt;xref:System.Collections.Generic.List%601.%23ctor%28System.Int32%29&gt;</ph> constructor y especificar la capacidad inicial elimina la necesidad de realizar una serie de operaciones de cambio de tamaño al agregar elementos a la <ph id="ph2">&lt;xref:System.Collections.Generic.List%601&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.#ctor">
          <source>The capacity can be decreased by calling the <ph id="ph1">&lt;xref:System.Collections.Generic.List%601.TrimExcess%2A&gt;</ph> method or by setting the <ph id="ph2">&lt;xref:System.Collections.Generic.List%601.Capacity%2A&gt;</ph> property explicitly.</source>
          <target state="translated">La capacidad puede reducirse mediante una llamada a la <ph id="ph1">&lt;xref:System.Collections.Generic.List%601.TrimExcess%2A&gt;</ph> método o estableciendo la <ph id="ph2">&lt;xref:System.Collections.Generic.List%601.Capacity%2A&gt;</ph> propiedad explícitamente.</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.#ctor">
          <source>Decreasing the capacity reallocates memory and copies all the elements in the <ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph>.</source>
          <target state="translated">Al disminuir la capacidad se reasigna memoria y copia todos los elementos en el <ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.#ctor">
          <source>This constructor is an O(1) operation.</source>
          <target state="translated">Este constructor es una operación o (1).</target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.#ctor">
          <source>The following example demonstrates the default constructor of the <ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph> generic class.</source>
          <target state="translated">En el ejemplo siguiente se muestra el constructor predeterminado de la <ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph> clase genérica.</target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.#ctor">
          <source>The default constructor creates a list with the default capacity, as demonstrated by displaying the <ph id="ph1">&lt;xref:System.Collections.Generic.List%601.Capacity%2A&gt;</ph> property.</source>
          <target state="translated">El constructor predeterminado crea una lista con la capacidad predeterminada, como se muestra, mostrando la <ph id="ph1">&lt;xref:System.Collections.Generic.List%601.Capacity%2A&gt;</ph> propiedad.</target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.#ctor">
          <source>The example adds, inserts, and removes items, showing how the capacity changes as these methods are used.</source>
          <target state="translated">En el ejemplo se agrega, se inserta y se quita elementos, mostrando cómo cambia la capacidad ya que estos métodos se usan.</target>       </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.List`1.#ctor(System.Collections.Generic.IEnumerable{`0})">
          <source>The collection whose elements are copied to the new list.</source>
          <target state="translated">Colección cuyos elementos se copian en la nueva lista.</target>       </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.List`1.#ctor(System.Collections.Generic.IEnumerable{`0})">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Collections.Generic.List`1" /&gt;</ph> class that contains elements copied from the specified collection and has sufficient capacity to accommodate the number of elements copied.</source>
          <target state="translated">Inicializa una nueva instancia de la clase <ph id="ph1">&lt;see cref="T:System.Collections.Generic.List`1" /&gt;</ph> que contiene elementos copiados de la colección especificada y tiene una capacidad suficiente para aceptar el número de elementos copiados.</target>       </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.#ctor(System.Collections.Generic.IEnumerable{`0})">
          <source>The elements are copied onto the <ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph> in the same order they are read by the enumerator of the collection.</source>
          <target state="translated">Los elementos se copian en el <ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph> en el mismo orden que los lee el enumerador de la colección.</target>       </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.#ctor(System.Collections.Generic.IEnumerable{`0})">
          <source>This constructor is an O(<bpt id="p1">*</bpt>n<ept id="p1">*</ept>) operation, where <bpt id="p2">*</bpt>n<ept id="p2">*</ept> is the number of elements in <ph id="ph1">`collection`</ph>.</source>
          <target state="translated">Este constructor es una O (<bpt id="p1">*</bpt>n<ept id="p1">*</ept>) operación, donde <bpt id="p2">*</bpt>n<ept id="p2">*</ept> es el número de elementos de <ph id="ph1">`collection`</ph>.</target>       </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.#ctor(System.Collections.Generic.IEnumerable{`0})">
          <source>The following example demonstrates the <ph id="ph1">&lt;xref:System.Collections.Generic.List%601.%23ctor%2A&gt;</ph> constructor and various methods of the <ph id="ph2">&lt;xref:System.Collections.Generic.List%601&gt;</ph> class that act on ranges.</source>
          <target state="translated">En el ejemplo siguiente se muestra la <ph id="ph1">&lt;xref:System.Collections.Generic.List%601.%23ctor%2A&gt;</ph> constructor y varios métodos de la <ph id="ph2">&lt;xref:System.Collections.Generic.List%601&gt;</ph> clase que operan en intervalos.</target>       </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.#ctor(System.Collections.Generic.IEnumerable{`0})">
          <source>An array of strings is created and passed to the constructor, populating the list with the elements of the array.</source>
          <target state="translated">Se crea una matriz de cadenas y se pasa al constructor, rellenar la lista con los elementos de la matriz.</target>       </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.#ctor(System.Collections.Generic.IEnumerable{`0})">
          <source>The <ph id="ph1">&lt;xref:System.Collections.Generic.List%601.Capacity%2A&gt;</ph> property is then displayed, to show that the initial capacity is exactly what is required to hold the input elements.</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.Collections.Generic.List%601.Capacity%2A&gt;</ph> , a continuación, se muestra la propiedad, para mostrar que la capacidad inicial es exactamente lo que se requiere para contener los elementos de entrada.</target>       </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.List`1.#ctor(System.Collections.Generic.IEnumerable{`0})">
          <source><ph id="ph1">&lt;paramref name="collection" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="collection" /&gt;</ph> es <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.List`1.#ctor(System.Int32)">
          <source>The number of elements that the new list can initially store.</source>
          <target state="translated">Número de elementos que puede almacenar inicialmente la lista nueva.</target>       </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.List`1.#ctor(System.Int32)">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Collections.Generic.List`1" /&gt;</ph> class that is empty and has the specified initial capacity.</source>
          <target state="translated">Inicializa una nueva instancia de la clase <ph id="ph1">&lt;see cref="T:System.Collections.Generic.List`1" /&gt;</ph> que está vacía y tiene la capacidad inicial especificada.</target>       </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.#ctor(System.Int32)">
          <source>The capacity of a <ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph> is the number of elements that the <ph id="ph2">&lt;xref:System.Collections.Generic.List%601&gt;</ph> can hold.</source>
          <target state="translated">La capacidad de un <ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph> es el número de elementos que la <ph id="ph2">&lt;xref:System.Collections.Generic.List%601&gt;</ph> puede contener.</target>       </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.#ctor(System.Int32)">
          <source>As elements are added to a <ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph>, the capacity is automatically increased as required by reallocating the internal array.</source>
          <target state="translated">Cuando se agregan elementos a un <ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph>, la capacidad aumenta automáticamente según sea necesario mediante la reasignación de la matriz interna.</target>       </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.#ctor(System.Int32)">
          <source>If the size of the collection can be estimated, specifying the initial capacity eliminates the need to perform a number of resizing operations while adding elements to the <ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph>.</source>
          <target state="translated">Si se puede estimar el tamaño de la colección, al especificar la capacidad inicial elimina la necesidad de realizar una serie de operaciones de cambio de tamaño al agregar elementos a la <ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.#ctor(System.Int32)">
          <source>The capacity can be decreased by calling the <ph id="ph1">&lt;xref:System.Collections.Generic.List%601.TrimExcess%2A&gt;</ph> method or by setting the <ph id="ph2">&lt;xref:System.Collections.Generic.List%601.Capacity%2A&gt;</ph> property explicitly.</source>
          <target state="translated">La capacidad puede reducirse mediante una llamada a la <ph id="ph1">&lt;xref:System.Collections.Generic.List%601.TrimExcess%2A&gt;</ph> método o estableciendo la <ph id="ph2">&lt;xref:System.Collections.Generic.List%601.Capacity%2A&gt;</ph> propiedad explícitamente.</target>       </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.#ctor(System.Int32)">
          <source>Decreasing the capacity reallocates memory and copies all the elements in the <ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph>.</source>
          <target state="translated">Al disminuir la capacidad se reasigna memoria y copia todos los elementos en el <ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.#ctor(System.Int32)">
          <source>This constructor is an O(<bpt id="p1">*</bpt>n<ept id="p1">*</ept>) operation, where <bpt id="p2">*</bpt>n<ept id="p2">*</ept> is <ph id="ph1">`capacity`</ph>.</source>
          <target state="translated">Este constructor es una O (<bpt id="p1">*</bpt>n<ept id="p1">*</ept>) operación, donde <bpt id="p2">*</bpt>n<ept id="p2">*</ept> es <ph id="ph1">`capacity`</ph>.</target>       </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.#ctor(System.Int32)">
          <source>The following example demonstrates the <ph id="ph1">&lt;xref:System.Collections.Generic.List%601.%23ctor%28System.Int32%29&gt;</ph> constructor.</source>
          <target state="translated">En el ejemplo siguiente se muestra el <ph id="ph1">&lt;xref:System.Collections.Generic.List%601.%23ctor%28System.Int32%29&gt;</ph> constructor.</target>       </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.#ctor(System.Int32)">
          <source>A <ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph> of strings with a capacity of 4 is created, because the ultimate size of the list is known to be exactly 4.</source>
          <target state="translated">Un <ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph> de cadenas con una capacidad de 4 se crea, dado que se conoce el tamaño final de la lista será exactamente 4.</target>       </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.#ctor(System.Int32)">
          <source>The list is populated with four strings, and a read-only copy is created by using the <ph id="ph1">&lt;xref:System.Collections.Generic.List%601.AsReadOnly%2A&gt;</ph> method.</source>
          <target state="translated">La lista se rellena con cuatro cadenas y se crea una copia de solo lectura mediante el <ph id="ph1">&lt;xref:System.Collections.Generic.List%601.AsReadOnly%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.List`1.#ctor(System.Int32)">
          <source><ph id="ph1">&lt;paramref name="capacity" /&gt;</ph> is less than 0.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="capacity" /&gt;</ph> es menor que 0.</target>       </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.List`1.Add(`0)">
          <source>The object to be added to the end of the <ph id="ph1">&lt;see cref="T:System.Collections.Generic.List`1" /&gt;</ph>.</source>
          <target state="translated">Objeto que se va a agregar al final de <ph id="ph1">&lt;see cref="T:System.Collections.Generic.List`1" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.List`1.Add(`0)">
          <source>The value can be <ph id="ph1">&lt;see langword="null" /&gt;</ph> for reference types.</source>
          <target state="translated">El valor puede ser <ph id="ph1">&lt;see langword="null" /&gt;</ph> para los tipos de referencia.</target>       </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.List`1.Add(`0)">
          <source>Adds an object to the end of the <ph id="ph1">&lt;see cref="T:System.Collections.Generic.List`1" /&gt;</ph>.</source>
          <target state="translated">Agrega un objeto al final de <ph id="ph1">&lt;see cref="T:System.Collections.Generic.List`1" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.Add(`0)">
          <source><ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph> accepts <ph id="ph2">`null`</ph> as a valid value for reference types and allows duplicate elements.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph> acepta <ph id="ph2">`null`</ph> como un valor válido para la referencia de tipos y permite a los elementos duplicados.</target>       </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.Add(`0)">
          <source>If <ph id="ph1">&lt;xref:System.Collections.Generic.List%601.Count%2A&gt;</ph> already equals <ph id="ph2">&lt;xref:System.Collections.Generic.List%601.Capacity%2A&gt;</ph>, the capacity of the <ph id="ph3">&lt;xref:System.Collections.Generic.List%601&gt;</ph> is increased by automatically reallocating the internal array, and the existing elements are copied to the new array before the new element is added.</source>
          <target state="translated">Si <ph id="ph1">&lt;xref:System.Collections.Generic.List%601.Count%2A&gt;</ph> ya es igual a <ph id="ph2">&lt;xref:System.Collections.Generic.List%601.Capacity%2A&gt;</ph>, la capacidad de la <ph id="ph3">&lt;xref:System.Collections.Generic.List%601&gt;</ph> se incrementa mediante la reasignación automática de la matriz interna, y se copian los elementos existentes en la nueva matriz antes de agrega el nuevo elemento.</target>       </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.Add(`0)">
          <source>If <ph id="ph1">&lt;xref:System.Collections.Generic.List%601.Count%2A&gt;</ph> is less than <ph id="ph2">&lt;xref:System.Collections.Generic.List%601.Capacity%2A&gt;</ph>, this method is an O(1) operation.</source>
          <target state="translated">Si <ph id="ph1">&lt;xref:System.Collections.Generic.List%601.Count%2A&gt;</ph> es menor que <ph id="ph2">&lt;xref:System.Collections.Generic.List%601.Capacity%2A&gt;</ph>, este método es una operación o (1).</target>       </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.Add(`0)">
          <source>If the capacity needs to be increased to accommodate the new element, this method becomes an O(<bpt id="p1">*</bpt>n<ept id="p1">*</ept>) operation, where <bpt id="p2">*</bpt>n<ept id="p2">*</ept> is <ph id="ph1">&lt;xref:System.Collections.Generic.List%601.Count%2A&gt;</ph>.</source>
          <target state="translated">Si la capacidad debe aumentarse para alojar el nuevo elemento, este método se convierte en una O (<bpt id="p1">*</bpt>n<ept id="p1">*</ept>) operación, donde <bpt id="p2">*</bpt>n<ept id="p2">*</ept> es <ph id="ph1">&lt;xref:System.Collections.Generic.List%601.Count%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.Add(`0)">
          <source>The following example demonstrates how to add, remove, and insert a simple business object in a <ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph>.</source>
          <target state="translated">En el ejemplo siguiente se muestra cómo agregar, quitar e insertar un objeto comercial simple en una <ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.Add(`0)">
          <source>The following example demonstrates several properties and methods of the <ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph> generic class, including the <ph id="ph2">&lt;xref:System.Collections.Generic.List%601.Add%2A&gt;</ph> method.</source>
          <target state="translated">En el ejemplo siguiente se muestra varias propiedades y métodos de la <ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph> clase genérica, incluida la <ph id="ph2">&lt;xref:System.Collections.Generic.List%601.Add%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.Add(`0)">
          <source>The default constructor is used to create a list of strings with a capacity of 0.</source>
          <target state="translated">El constructor predeterminado se utiliza para crear una lista de cadenas con una capacidad de 0.</target>       </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.Add(`0)">
          <source>The <ph id="ph1">&lt;xref:System.Collections.Generic.List%601.Capacity%2A&gt;</ph> property is displayed, and then the <ph id="ph2">&lt;xref:System.Collections.Generic.List%601.Add%2A&gt;</ph> method is used to add several items.</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.Collections.Generic.List%601.Capacity%2A&gt;</ph> propiedad se muestra y, a continuación, el <ph id="ph2">&lt;xref:System.Collections.Generic.List%601.Add%2A&gt;</ph> método se usa para agregar varios elementos.</target>       </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.Add(`0)">
          <source>The items are listed, and the <ph id="ph1">&lt;xref:System.Collections.Generic.List%601.Capacity%2A&gt;</ph> property is displayed again, along with the <ph id="ph2">&lt;xref:System.Collections.Generic.List%601.Count%2A&gt;</ph> property, to show that the capacity has been increased as needed.</source>
          <target state="translated">Se enumeran los elementos y la <ph id="ph1">&lt;xref:System.Collections.Generic.List%601.Capacity%2A&gt;</ph> propiedad se muestra una vez más, junto con el <ph id="ph2">&lt;xref:System.Collections.Generic.List%601.Count%2A&gt;</ph> propiedad, para mostrar que se ha aumentado la capacidad según sea necesario.</target>       </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.Add(`0)">
          <source>Other properties and methods are used to search for, insert, and remove elements from the list, and finally to clear the list.</source>
          <target state="translated">Otras propiedades y métodos se usan para buscar, insertar y quitar elementos de la lista y, finalmente, para borrar la lista.</target>       </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.List`1.AddRange(System.Collections.Generic.IEnumerable{`0})">
          <source>The collection whose elements should be added to the end of the <ph id="ph1">&lt;see cref="T:System.Collections.Generic.List`1" /&gt;</ph>.</source>
          <target state="translated">Colección cuyos elementos deben agregarse al final de <ph id="ph1">&lt;see cref="T:System.Collections.Generic.List`1" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.List`1.AddRange(System.Collections.Generic.IEnumerable{`0})">
          <source>The collection itself cannot be <ph id="ph1">&lt;see langword="null" /&gt;</ph>, but it can contain elements that are <ph id="ph2">&lt;see langword="null" /&gt;</ph>, if type <bpt id="p1">&lt;c&gt;</bpt>T<ept id="p1">&lt;/c&gt;</ept> is a reference type.</source>
          <target state="translated">La propia colección no puede ser <ph id="ph1">&lt;see langword="null" /&gt;</ph>, pero puede contener elementos que sean <ph id="ph2">&lt;see langword="null" /&gt;</ph> si el tipo <bpt id="p1">&lt;c&gt;</bpt>T<ept id="p1">&lt;/c&gt;</ept> es un tipo de referencia.</target>       </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.List`1.AddRange(System.Collections.Generic.IEnumerable{`0})">
          <source>Adds the elements of the specified collection to the end of the <ph id="ph1">&lt;see cref="T:System.Collections.Generic.List`1" /&gt;</ph>.</source>
          <target state="translated">Agrega los elementos de la colección especificada al final de <ph id="ph1">&lt;see cref="T:System.Collections.Generic.List`1" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.AddRange(System.Collections.Generic.IEnumerable{`0})">
          <source>The order of the elements in the collection is preserved in the <ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph>.</source>
          <target state="translated">Se conserva el orden de los elementos de la colección en el <ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.AddRange(System.Collections.Generic.IEnumerable{`0})">
          <source>If the new <ph id="ph1">&lt;xref:System.Collections.Generic.List%601.Count%2A&gt;</ph> (the current <ph id="ph2">&lt;xref:System.Collections.Generic.List%601.Count%2A&gt;</ph> plus the size of the collection) will be greater than <ph id="ph3">&lt;xref:System.Collections.Generic.List%601.Capacity%2A&gt;</ph>, the capacity of the <ph id="ph4">&lt;xref:System.Collections.Generic.List%601&gt;</ph> is increased by automatically reallocating the internal array to accommodate the new elements, and the existing elements are copied to the new array before the new elements are added.</source>
          <target state="translated">Si el nuevo <ph id="ph1">&lt;xref:System.Collections.Generic.List%601.Count%2A&gt;</ph> (actual <ph id="ph2">&lt;xref:System.Collections.Generic.List%601.Count%2A&gt;</ph> más el tamaño de la colección) será mayor que <ph id="ph3">&lt;xref:System.Collections.Generic.List%601.Capacity%2A&gt;</ph>, la capacidad de la <ph id="ph4">&lt;xref:System.Collections.Generic.List%601&gt;</ph> se incrementa mediante la reasignación automática de la matriz interna para dar cabida a los nuevos elementos, y se copian los elementos existentes en la nueva matriz antes de que se agregan los nuevos elementos.</target>       </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.AddRange(System.Collections.Generic.IEnumerable{`0})">
          <source>If the <ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph> can accommodate the new elements without increasing the <ph id="ph2">&lt;xref:System.Collections.Generic.List%601.Capacity%2A&gt;</ph>, this method is an O(<bpt id="p1">*</bpt>n<ept id="p1">*</ept>) operation, where <bpt id="p2">*</bpt>n<ept id="p2">*</ept> is the number of elements to be added.</source>
          <target state="translated">Si el <ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph> puede dar cabida a los nuevos elementos sin aumentar la <ph id="ph2">&lt;xref:System.Collections.Generic.List%601.Capacity%2A&gt;</ph>, este método es una O (<bpt id="p1">*</bpt>n<ept id="p1">*</ept>) operación, donde <bpt id="p2">*</bpt>n<ept id="p2">*</ept> es el número de elementos que se va a agregar.</target>       </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.AddRange(System.Collections.Generic.IEnumerable{`0})">
          <source>If the capacity needs to be increased to accommodate the new elements, this method becomes an O(<bpt id="p1">*</bpt>n<ept id="p1">*</ept><ph id="ph1"> + </ph><bpt id="p2">*</bpt>m<ept id="p2">*</ept>) operation, where <bpt id="p3">*</bpt>n<ept id="p3">*</ept> is the number of elements to be added and <bpt id="p4">*</bpt>m<ept id="p4">*</ept> is <ph id="ph2">&lt;xref:System.Collections.Generic.List%601.Count%2A&gt;</ph>.</source>
          <target state="translated">Si la capacidad debe aumentarse para dar cabida a los nuevos elementos, este método se convierte en una O (<bpt id="p1">*</bpt>n<ept id="p1">*</ept><ph id="ph1"> + </ph><bpt id="p2">*</bpt>m<ept id="p2">*</ept>) operación, donde <bpt id="p3">*</bpt>n<ept id="p3">*</ept> es el número de elementos va a agregar y <bpt id="p4">*</bpt>m<ept id="p4">*</ept> es <ph id="ph2">&lt;xref:System.Collections.Generic.List%601.Count%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.AddRange(System.Collections.Generic.IEnumerable{`0})">
          <source>The following example demonstrates the <ph id="ph1">&lt;xref:System.Collections.Generic.List%601.AddRange%2A&gt;</ph> method and various other methods of the <ph id="ph2">&lt;xref:System.Collections.Generic.List%601&gt;</ph> class that act on ranges.</source>
          <target state="translated">En el ejemplo siguiente se muestra la <ph id="ph1">&lt;xref:System.Collections.Generic.List%601.AddRange%2A&gt;</ph> método y otros métodos de la <ph id="ph2">&lt;xref:System.Collections.Generic.List%601&gt;</ph> clase que operan en intervalos.</target>       </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.AddRange(System.Collections.Generic.IEnumerable{`0})">
          <source>An array of strings is created and passed to the constructor, populating the list with the elements of the array.</source>
          <target state="translated">Se crea una matriz de cadenas y se pasa al constructor, rellenar la lista con los elementos de la matriz.</target>       </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.AddRange(System.Collections.Generic.IEnumerable{`0})">
          <source>The <ph id="ph1">&lt;xref:System.Collections.Generic.List%601.AddRange%2A&gt;</ph> method is called, with the list as its argument.</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.Collections.Generic.List%601.AddRange%2A&gt;</ph> se llama el método, con la lista como su argumento.</target>       </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.AddRange(System.Collections.Generic.IEnumerable{`0})">
          <source>The result is that the current elements of the list are added to the end of the list, duplicating all the elements.</source>
          <target state="translated">El resultado es que los elementos actuales de la lista se agregan al final de la lista, duplicación de todos los elementos.</target>       </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.List`1.AddRange(System.Collections.Generic.IEnumerable{`0})">
          <source><ph id="ph1">&lt;paramref name="collection" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="collection" /&gt;</ph> es <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.List`1.AsReadOnly">
          <source>Returns a read-only <ph id="ph1">&lt;see cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" /&gt;</ph> wrapper for the current collection.</source>
          <target state="translated">Devuelve un contenedor de <ph id="ph1">&lt;see cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" /&gt;</ph> de solo lectura para la colección actual.</target>       </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.List`1.AsReadOnly">
          <source>An object that acts as a read-only wrapper around the current <ph id="ph1">&lt;see cref="T:System.Collections.Generic.List`1" /&gt;</ph>.</source>
          <target state="translated">Objeto que actúa como contenedor de solo lectura para la <ph id="ph1">&lt;see cref="T:System.Collections.Generic.List`1" /&gt;</ph> actual.</target>       </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.AsReadOnly">
          <source>To prevent any modifications to the <ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph> object, expose it only through this wrapper.</source>
          <target state="translated">Para evitar que las modificaciones a la <ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph> de objetos, exponer sólo a través de este contenedor.</target>       </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.AsReadOnly">
          <source>A  <ph id="ph1">&lt;xref:System.Collections.ObjectModel.ReadOnlyCollection%601&gt;</ph> object does not expose methods that modify the collection.</source>
          <target state="translated">Un <ph id="ph1">&lt;xref:System.Collections.ObjectModel.ReadOnlyCollection%601&gt;</ph> objeto no expone métodos que modifican la colección.</target>       </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.AsReadOnly">
          <source>However, if changes are made to the underlying <ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph> object, the read-only collection reflects those changes.</source>
          <target state="translated">Sin embargo, si se realizan cambios en subyacente <ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph> de objetos, la colección de solo lectura refleja esos cambios.</target>       </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.AsReadOnly">
          <source>This method is an O(1) operation.</source>
          <target state="translated">Este método es una operación o (1).</target>       </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.AsReadOnly">
          <source>The following example demonstrates the <ph id="ph1">&lt;xref:System.Collections.Generic.List%601.AsReadOnly%2A&gt;</ph> method.</source>
          <target state="translated">En el ejemplo siguiente se muestra el <ph id="ph1">&lt;xref:System.Collections.Generic.List%601.AsReadOnly%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.AsReadOnly">
          <source>A <ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph> of strings with a capacity of 4 is created, because the ultimate size of the list is known to be exactly 4.</source>
          <target state="translated">Un <ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph> de cadenas con una capacidad de 4 se crea, dado que se conoce el tamaño final de la lista será exactamente 4.</target>       </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.AsReadOnly">
          <source>The list is populated with four strings, and the <ph id="ph1">&lt;xref:System.Collections.Generic.List%601.AsReadOnly%2A&gt;</ph> method is used to get a read-only <ph id="ph2">&lt;xref:System.Collections.Generic.IList%601&gt;</ph> generic interface implementation that wraps the original list.</source>
          <target state="translated">La lista se rellena con cuatro cadenas y el <ph id="ph1">&lt;xref:System.Collections.Generic.List%601.AsReadOnly%2A&gt;</ph> método se utiliza para obtener solo lectura <ph id="ph2">&lt;xref:System.Collections.Generic.IList%601&gt;</ph> implementación de interfaz genérica que ajusta la lista original.</target>       </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.AsReadOnly">
          <source>An element of the original list is set to "Coelophysis" using the <ph id="ph1">&lt;xref:System.Collections.Generic.List%601.Item%2A&gt;</ph> property (the indexer in C#), and the contents of the read-only list are displayed again to demonstrate that it is just a wrapper for the original list.</source>
          <target state="translated">Un elemento de la lista original se establece en "Coelophysis" utilizando el <ph id="ph1">&lt;xref:System.Collections.Generic.List%601.Item%2A&gt;</ph> propiedad (el indizador en C#) y el contenido de la lista de solo lectura se muestra de nuevo para demostrar que es simplemente un contenedor de la lista original.</target>       </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve" uid="T:System.Collections.Generic.List`1">
          <source>Uses a binary search algorithm to locate a specific element in the sorted <ph id="ph1">&lt;see cref="T:System.Collections.Generic.List`1" /&gt;</ph> or a portion of it.</source>
          <target state="translated">Utiliza un algoritmo de búsqueda binaria para localizar un elemento concreto en la <ph id="ph1">&lt;see cref="T:System.Collections.Generic.List`1" /&gt;</ph> ordenada o en una parte de ella.</target>       </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.List`1.BinarySearch(`0)">
          <source>The object to locate.</source>
          <target state="translated">Objeto que se va a buscar.</target>       </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.List`1.BinarySearch(`0)">
          <source>The value can be <ph id="ph1">&lt;see langword="null" /&gt;</ph> for reference types.</source>
          <target state="translated">El valor puede ser <ph id="ph1">&lt;see langword="null" /&gt;</ph> para los tipos de referencia.</target>       </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.List`1.BinarySearch(`0)">
          <source>Searches the entire sorted <ph id="ph1">&lt;see cref="T:System.Collections.Generic.List`1" /&gt;</ph> for an element using the default comparer and returns the zero-based index of the element.</source>
          <target state="translated">Busca la <ph id="ph1">&lt;see cref="T:System.Collections.Generic.List`1" /&gt;</ph> completa ordenada para un elemento usando el comparador predeterminado y devuelve el índice de base cero del elemento.</target>       </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.List`1.BinarySearch(`0)">
          <source>The zero-based index of <ph id="ph1">&lt;paramref name="item" /&gt;</ph> in the sorted <ph id="ph2">&lt;see cref="T:System.Collections.Generic.List`1" /&gt;</ph>, if <ph id="ph3">&lt;paramref name="item" /&gt;</ph> is found; otherwise, a negative number that is the bitwise complement of the index of the next element that is larger than <ph id="ph4">&lt;paramref name="item" /&gt;</ph> or, if there is no larger element, the bitwise complement of <ph id="ph5">&lt;see cref="P:System.Collections.Generic.List`1.Count" /&gt;</ph>.</source>
          <target state="translated">Índice de base cero de <ph id="ph1">&lt;paramref name="item" /&gt;</ph> en la <ph id="ph2">&lt;see cref="T:System.Collections.Generic.List`1" /&gt;</ph> ordenada, si es que se encuentra <ph id="ph3">&lt;paramref name="item" /&gt;</ph>; en caso contrario, número negativo que es el complemento bit a bit del índice del siguiente elemento mayor que <ph id="ph4">&lt;paramref name="item" /&gt;</ph> o, si no hay ningún elemento mayor, el complemento bit a bit de <ph id="ph5">&lt;see cref="P:System.Collections.Generic.List`1.Count" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.BinarySearch(`0)">
          <source>This method uses the default comparer <ph id="ph1">&lt;xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType&gt;</ph> for type <ph id="ph2">`T`</ph> to determine the order of list elements.</source>
          <target state="translated">Este método utiliza el comparador predeterminado <ph id="ph1">&lt;xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType&gt;</ph> para el tipo <ph id="ph2">`T`</ph> para determinar el orden de los elementos de lista.</target>       </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.BinarySearch(`0)">
          <source>The <ph id="ph1">&lt;xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType&gt;</ph> property checks whether type <ph id="ph2">`T`</ph> implements the <ph id="ph3">&lt;xref:System.IComparable%601&gt;</ph> generic interface and uses that implementation, if available.</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType&gt;</ph> propiedad comprueba si tipo <ph id="ph2">`T`</ph> implementa el <ph id="ph3">&lt;xref:System.IComparable%601&gt;</ph> interfaz genérica y utiliza esa implementación, si está disponible.</target>       </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.BinarySearch(`0)">
          <source>If not, <ph id="ph1">&lt;xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType&gt;</ph> checks whether type <ph id="ph2">`T`</ph> implements the <ph id="ph3">&lt;xref:System.IComparable&gt;</ph> interface.</source>
          <target state="translated">Si no es así, <ph id="ph1">&lt;xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType&gt;</ph> comprueba si tipo <ph id="ph2">`T`</ph> implementa el <ph id="ph3">&lt;xref:System.IComparable&gt;</ph> interfaz.</target>       </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.BinarySearch(`0)">
          <source>If type <ph id="ph1">`T`</ph> does not implement either interface, <ph id="ph2">&lt;xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType&gt;</ph> throws an <ph id="ph3">&lt;xref:System.InvalidOperationException&gt;</ph>.</source>
          <target state="translated">Si tipo <ph id="ph1">`T`</ph> no implementa ninguna de estas interfaces, <ph id="ph2">&lt;xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType&gt;</ph> produce una <ph id="ph3">&lt;xref:System.InvalidOperationException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.BinarySearch(`0)">
          <source>The <ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph> must already be sorted according to the comparer implementation; otherwise, the result is incorrect.</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph> ya deben estar ordenados según la implementación del comparador; en caso contrario, el resultado es incorrecto.</target>       </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.BinarySearch(`0)">
          <source>Comparing <ph id="ph1">`null`</ph> with any reference type is allowed and does not generate an exception when using the <ph id="ph2">&lt;xref:System.IComparable%601&gt;</ph> generic interface.</source>
          <target state="translated">Comparar <ph id="ph1">`null`</ph> con cualquier referencia de tipo, se permite y no genera una excepción cuando se usa el <ph id="ph2">&lt;xref:System.IComparable%601&gt;</ph> interfaz genérica.</target>       </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.BinarySearch(`0)">
          <source>When sorting, <ph id="ph1">`null`</ph> is considered to be less than any other object.</source>
          <target state="translated">Al ordenar, <ph id="ph1">`null`</ph> se considera menor que cualquier otro objeto.</target>       </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.BinarySearch(`0)">
          <source>If the <ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph> contains more than one element with the same value, the method returns only one of the occurrences, and it might return any one of the occurrences, not necessarily the first one.</source>
          <target state="translated">Si el <ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph> contiene más de un elemento con el mismo valor, el método devuelve solo una de las apariciones y puede devolver cualquiera de ellas, pero no necesariamente la primera de ellas.</target>       </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.BinarySearch(`0)">
          <source>If the <ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph> does not contain the specified value, the method returns a negative integer.</source>
          <target state="translated">Si el <ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph> no contiene el valor especificado, el método devuelve un entero negativo.</target>       </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.BinarySearch(`0)">
          <source>You can apply the bitwise complement operation (~) to this negative integer to get the index of the first element that is larger than the search value.</source>
          <target state="translated">Puede aplicar la operación de complemento bit a bit (~) a este entero negativo para obtener el índice del primer elemento que es mayor que el valor de búsqueda.</target>       </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.BinarySearch(`0)">
          <source>When inserting the value into the <ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph>, this index should be used as the insertion point to maintain the sort order.</source>
          <target state="translated">Cuando se inserta el valor en el <ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph>, este índice se debe utilizar como punto de inserción para mantener el criterio de ordenación.</target>       </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.BinarySearch(`0)">
          <source>This method is an O(log <bpt id="p1">*</bpt>n<ept id="p1">*</ept>) operation, where <bpt id="p2">*</bpt>n<ept id="p2">*</ept> is the number of elements in the range.</source>
          <target state="translated">Este método es una O (registro <bpt id="p1">*</bpt>n<ept id="p1">*</ept>) operación, donde <bpt id="p2">*</bpt>n<ept id="p2">*</ept> es el número de elementos del intervalo.</target>       </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.BinarySearch(`0)">
          <source>The following example demonstrates the <ph id="ph1">&lt;xref:System.Collections.Generic.List%601.Sort&gt;</ph> method overload and the <ph id="ph2">&lt;xref:System.Collections.Generic.List%601.BinarySearch%28%600%29&gt;</ph> method overload.</source>
          <target state="translated">En el ejemplo siguiente se muestra la <ph id="ph1">&lt;xref:System.Collections.Generic.List%601.Sort&gt;</ph> sobrecarga del método y el <ph id="ph2">&lt;xref:System.Collections.Generic.List%601.BinarySearch%28%600%29&gt;</ph> sobrecarga del método.</target>       </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.BinarySearch(`0)">
          <source>A <ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph> of strings is created and populated with four strings, in no particular order.</source>
          <target state="translated">Un <ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph> de cadenas se crean y rellenan con cuatro cadenas, sin ningún orden determinado.</target>       </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.BinarySearch(`0)">
          <source>The list is displayed, sorted, and displayed again.</source>
          <target state="translated">La lista se muestran, ordenada y vuelve a aparecer.</target>       </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.BinarySearch(`0)">
          <source>The <ph id="ph1">&lt;xref:System.Collections.Generic.List%601.BinarySearch%28%600%29&gt;</ph> method overload is then used to search for two strings that are not in the list, and the <ph id="ph2">&lt;xref:System.Collections.Generic.List%601.Insert%2A&gt;</ph> method is used to insert them.</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.Collections.Generic.List%601.BinarySearch%28%600%29&gt;</ph> sobrecarga del método, a continuación, se usa para buscar dos cadenas que no están en la lista, y el <ph id="ph2">&lt;xref:System.Collections.Generic.List%601.Insert%2A&gt;</ph> método se usa para insertarlos.</target>       </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.BinarySearch(`0)">
          <source>The return value of the <ph id="ph1">&lt;xref:System.Collections.Generic.List%601.BinarySearch%28%600%29&gt;</ph> method is negative in each case, because the strings are not in the list.</source>
          <target state="translated">El valor devuelto de la <ph id="ph1">&lt;xref:System.Collections.Generic.List%601.BinarySearch%28%600%29&gt;</ph> método es negativo en cada caso, dado que las cadenas no están en la lista.</target>       </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.BinarySearch(`0)">
          <source>Taking the bitwise complement (the ~ operator in C# and Visual C++, <ph id="ph1">`Xor`</ph> -1 in Visual Basic) of this negative number produces the index of the first element in the list that is larger than the search string, and inserting at this location preserves the sort order.</source>
          <target state="translated">Tomar el complemento bit a bit (el ~ operador en C# y Visual C++, <ph id="ph1">`Xor`</ph> -1 en Visual Basic) de este número negativo se produce el índice del primer elemento de la lista que es mayor que la cadena de búsqueda y, a continuación, insertar en esta ubicación conserva la ordenación orden.</target>       </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.BinarySearch(`0)">
          <source>The second search string is larger than any element in the list, so the insertion position is at the end of the list.</source>
          <target state="translated">La segunda cadena de búsqueda es mayor que cualquier elemento de la lista, por lo que es la posición de inserción al final de la lista.</target>       </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.List`1.BinarySearch(`0)">
          <source>The default comparer <ph id="ph1">&lt;see cref="P:System.Collections.Generic.Comparer`1.Default" /&gt;</ph> cannot find an implementation of the <ph id="ph2">&lt;see cref="T:System.IComparable`1" /&gt;</ph> generic interface or the <ph id="ph3">&lt;see cref="T:System.IComparable" /&gt;</ph> interface for type <ph id="ph4">&lt;paramref name="T" /&gt;</ph>.</source>
          <target state="translated">El comparador predeterminado <ph id="ph1">&lt;see cref="P:System.Collections.Generic.Comparer`1.Default" /&gt;</ph> no puede encontrar una implementación de la interfaz genérica <ph id="ph2">&lt;see cref="T:System.IComparable`1" /&gt;</ph> o de la interfaz <ph id="ph3">&lt;see cref="T:System.IComparable" /&gt;</ph> para el tipo <ph id="ph4">&lt;paramref name="T" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.List`1.BinarySearch(`0,System.Collections.Generic.IComparer{`0})">
          <source>The object to locate.</source>
          <target state="translated">Objeto que se va a buscar.</target>       </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.List`1.BinarySearch(`0,System.Collections.Generic.IComparer{`0})">
          <source>The value can be <ph id="ph1">&lt;see langword="null" /&gt;</ph> for reference types.</source>
          <target state="translated">El valor puede ser <ph id="ph1">&lt;see langword="null" /&gt;</ph> para los tipos de referencia.</target>       </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.List`1.BinarySearch(`0,System.Collections.Generic.IComparer{`0})">
          <source>The <ph id="ph1">&lt;see cref="T:System.Collections.Generic.IComparer`1" /&gt;</ph> implementation to use when comparing elements.</source>
          <target state="translated">Implementación de <ph id="ph1">&lt;see cref="T:System.Collections.Generic.IComparer`1" /&gt;</ph> que se va a usar al comparar elementos.</target>       </trans-unit>
        <trans-unit id="252" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.List`1.BinarySearch(`0,System.Collections.Generic.IComparer{`0})">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="253" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.List`1.BinarySearch(`0,System.Collections.Generic.IComparer{`0})">
          <source><ph id="ph1">&lt;see langword="null" /&gt;</ph> to use the default comparer <ph id="ph2">&lt;see cref="P:System.Collections.Generic.Comparer`1.Default" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="null" /&gt;</ph> para utilizar el comparador predeterminado <ph id="ph2">&lt;see cref="P:System.Collections.Generic.Comparer`1.Default" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="254" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.List`1.BinarySearch(`0,System.Collections.Generic.IComparer{`0})">
          <source>Searches the entire sorted <ph id="ph1">&lt;see cref="T:System.Collections.Generic.List`1" /&gt;</ph> for an element using the specified comparer and returns the zero-based index of the element.</source>
          <target state="translated">Busca la <ph id="ph1">&lt;see cref="T:System.Collections.Generic.List`1" /&gt;</ph> completa ordenada para un elemento usando el comparador especificado y devuelve el índice de base cero del elemento.</target>       </trans-unit>
        <trans-unit id="255" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.List`1.BinarySearch(`0,System.Collections.Generic.IComparer{`0})">
          <source>The zero-based index of <ph id="ph1">&lt;paramref name="item" /&gt;</ph> in the sorted <ph id="ph2">&lt;see cref="T:System.Collections.Generic.List`1" /&gt;</ph>, if <ph id="ph3">&lt;paramref name="item" /&gt;</ph> is found; otherwise, a negative number that is the bitwise complement of the index of the next element that is larger than <ph id="ph4">&lt;paramref name="item" /&gt;</ph> or, if there is no larger element, the bitwise complement of <ph id="ph5">&lt;see cref="P:System.Collections.Generic.List`1.Count" /&gt;</ph>.</source>
          <target state="translated">Índice de base cero de <ph id="ph1">&lt;paramref name="item" /&gt;</ph> en la <ph id="ph2">&lt;see cref="T:System.Collections.Generic.List`1" /&gt;</ph> ordenada, si es que se encuentra <ph id="ph3">&lt;paramref name="item" /&gt;</ph>; en caso contrario, número negativo que es el complemento bit a bit del índice del siguiente elemento mayor que <ph id="ph4">&lt;paramref name="item" /&gt;</ph> o, si no hay ningún elemento mayor, el complemento bit a bit de <ph id="ph5">&lt;see cref="P:System.Collections.Generic.List`1.Count" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="256" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.BinarySearch(`0,System.Collections.Generic.IComparer{`0})">
          <source>The comparer customizes how the elements are compared.</source>
          <target state="translated">El comparador personaliza cómo se comparan los elementos.</target>       </trans-unit>
        <trans-unit id="257" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.BinarySearch(`0,System.Collections.Generic.IComparer{`0})">
          <source>For example, you can use a <ph id="ph1">&lt;xref:System.Collections.CaseInsensitiveComparer&gt;</ph> instance as the comparer to perform case-insensitive string searches.</source>
          <target state="translated">Por ejemplo, puede usar un <ph id="ph1">&lt;xref:System.Collections.CaseInsensitiveComparer&gt;</ph> instancia como comparador para realizar búsquedas de cadenas entre mayúsculas y minúsculas.</target>       </trans-unit>
        <trans-unit id="258" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.BinarySearch(`0,System.Collections.Generic.IComparer{`0})">
          <source>If <ph id="ph1">`comparer`</ph> is provided, the elements of the <ph id="ph2">&lt;xref:System.Collections.Generic.List%601&gt;</ph> are compared to the specified value using the specified <ph id="ph3">&lt;xref:System.Collections.Generic.IComparer%601&gt;</ph> implementation.</source>
          <target state="translated">Si <ph id="ph1">`comparer`</ph> se proporciona, los elementos de la <ph id="ph2">&lt;xref:System.Collections.Generic.List%601&gt;</ph> se comparan con el valor especificado utilizando el parámetro <ph id="ph3">&lt;xref:System.Collections.Generic.IComparer%601&gt;</ph> implementación.</target>       </trans-unit>
        <trans-unit id="259" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.BinarySearch(`0,System.Collections.Generic.IComparer{`0})">
          <source>If <ph id="ph1">`comparer`</ph> is <ph id="ph2">`null`</ph>, the default comparer <ph id="ph3">&lt;xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType&gt;</ph> checks whether type <ph id="ph4">`T`</ph> implements the <ph id="ph5">&lt;xref:System.IComparable%601&gt;</ph> generic interface and uses that implementation, if available.</source>
          <target state="translated">Si <ph id="ph1">`comparer`</ph> es <ph id="ph2">`null`</ph>, el comparador predeterminado <ph id="ph3">&lt;xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType&gt;</ph> comprueba si tipo <ph id="ph4">`T`</ph> implementa el <ph id="ph5">&lt;xref:System.IComparable%601&gt;</ph> interfaz genérica y utiliza esa implementación, si está disponible.</target>       </trans-unit>
        <trans-unit id="260" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.BinarySearch(`0,System.Collections.Generic.IComparer{`0})">
          <source>If not, <ph id="ph1">&lt;xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType&gt;</ph> checks whether type <ph id="ph2">`T`</ph> implements the <ph id="ph3">&lt;xref:System.IComparable&gt;</ph> interface.</source>
          <target state="translated">Si no es así, <ph id="ph1">&lt;xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType&gt;</ph> comprueba si tipo <ph id="ph2">`T`</ph> implementa el <ph id="ph3">&lt;xref:System.IComparable&gt;</ph> interfaz.</target>       </trans-unit>
        <trans-unit id="261" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.BinarySearch(`0,System.Collections.Generic.IComparer{`0})">
          <source>If type <ph id="ph1">`T`</ph> does not implement either interface, <ph id="ph2">&lt;xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType&gt;</ph> throws <ph id="ph3">&lt;xref:System.InvalidOperationException&gt;</ph>.</source>
          <target state="translated">Si tipo <ph id="ph1">`T`</ph> no implementa ninguna de estas interfaces, <ph id="ph2">&lt;xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType&gt;</ph> produce <ph id="ph3">&lt;xref:System.InvalidOperationException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="262" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.BinarySearch(`0,System.Collections.Generic.IComparer{`0})">
          <source>The <ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph> must already be sorted according to the comparer implementation; otherwise, the result is incorrect.</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph> ya deben estar ordenados según la implementación del comparador; en caso contrario, el resultado es incorrecto.</target>       </trans-unit>
        <trans-unit id="263" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.BinarySearch(`0,System.Collections.Generic.IComparer{`0})">
          <source>Comparing <ph id="ph1">`null`</ph> with any reference type is allowed and does not generate an exception when using the <ph id="ph2">&lt;xref:System.IComparable%601&gt;</ph> generic interface.</source>
          <target state="translated">Comparar <ph id="ph1">`null`</ph> con cualquier referencia de tipo, se permite y no genera una excepción cuando se usa el <ph id="ph2">&lt;xref:System.IComparable%601&gt;</ph> interfaz genérica.</target>       </trans-unit>
        <trans-unit id="264" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.BinarySearch(`0,System.Collections.Generic.IComparer{`0})">
          <source>When sorting, <ph id="ph1">`null`</ph> is considered to be less than any other object.</source>
          <target state="translated">Al ordenar, <ph id="ph1">`null`</ph> se considera menor que cualquier otro objeto.</target>       </trans-unit>
        <trans-unit id="265" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.BinarySearch(`0,System.Collections.Generic.IComparer{`0})">
          <source>If the <ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph> contains more than one element with the same value, the method returns only one of the occurrences, and it might return any one of the occurrences, not necessarily the first one.</source>
          <target state="translated">Si el <ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph> contiene más de un elemento con el mismo valor, el método devuelve solo una de las apariciones y puede devolver cualquiera de ellas, pero no necesariamente la primera de ellas.</target>       </trans-unit>
        <trans-unit id="266" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.BinarySearch(`0,System.Collections.Generic.IComparer{`0})">
          <source>If the <ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph> does not contain the specified value, the method returns a negative integer.</source>
          <target state="translated">Si el <ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph> no contiene el valor especificado, el método devuelve un entero negativo.</target>       </trans-unit>
        <trans-unit id="267" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.BinarySearch(`0,System.Collections.Generic.IComparer{`0})">
          <source>You can apply the bitwise complement operation (~) to this negative integer to get the index of the first element that is larger than the search value.</source>
          <target state="translated">Puede aplicar la operación de complemento bit a bit (~) a este entero negativo para obtener el índice del primer elemento que es mayor que el valor de búsqueda.</target>       </trans-unit>
        <trans-unit id="268" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.BinarySearch(`0,System.Collections.Generic.IComparer{`0})">
          <source>When inserting the value into the <ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph>, this index should be used as the insertion point to maintain the sort order.</source>
          <target state="translated">Cuando se inserta el valor en el <ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph>, este índice se debe utilizar como punto de inserción para mantener el criterio de ordenación.</target>       </trans-unit>
        <trans-unit id="269" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.BinarySearch(`0,System.Collections.Generic.IComparer{`0})">
          <source>This method is an O(log <bpt id="p1">*</bpt>n<ept id="p1">*</ept>) operation, where <bpt id="p2">*</bpt>n<ept id="p2">*</ept> is the number of elements in the range.</source>
          <target state="translated">Este método es una O (registro <bpt id="p1">*</bpt>n<ept id="p1">*</ept>) operación, donde <bpt id="p2">*</bpt>n<ept id="p2">*</ept> es el número de elementos del intervalo.</target>       </trans-unit>
        <trans-unit id="270" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.BinarySearch(`0,System.Collections.Generic.IComparer{`0})">
          <source>The following example demonstrates the <ph id="ph1">&lt;xref:System.Collections.Generic.List%601.Sort%28System.Collections.Generic.IComparer%7B%600%7D%29&gt;</ph> method overload and the <ph id="ph2">&lt;xref:System.Collections.Generic.List%601.BinarySearch%28%600%2CSystem.Collections.Generic.IComparer%7B%600%7D%29&gt;</ph> method overload.</source>
          <target state="translated">En el ejemplo siguiente se muestra la <ph id="ph1">&lt;xref:System.Collections.Generic.List%601.Sort%28System.Collections.Generic.IComparer%7B%600%7D%29&gt;</ph> sobrecarga del método y el <ph id="ph2">&lt;xref:System.Collections.Generic.List%601.BinarySearch%28%600%2CSystem.Collections.Generic.IComparer%7B%600%7D%29&gt;</ph> sobrecarga del método.</target>       </trans-unit>
        <trans-unit id="271" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.BinarySearch(`0,System.Collections.Generic.IComparer{`0})">
          <source>The example defines an alternative comparer for strings named DinoCompare, which implements the <ph id="ph1">`IComparer&lt;string&gt;`</ph> (<ph id="ph2">`IComparer(Of String)`</ph> in Visual Basic, <ph id="ph3">`IComparer&lt;String^&gt;`</ph> in Visual C++) generic interface.</source>
          <target state="translated">En el ejemplo se define un comparador alternativo para las cadenas denominado DinoCompare, que implementa el <ph id="ph1">`IComparer&lt;string&gt;`</ph> (<ph id="ph2">`IComparer(Of String)`</ph> en Visual Basic, <ph id="ph3">`IComparer&lt;String^&gt;`</ph> en Visual C++) interfaz genérica.</target>       </trans-unit>
        <trans-unit id="272" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.BinarySearch(`0,System.Collections.Generic.IComparer{`0})">
          <source>The comparer works as follows: First, the comparands are tested for <ph id="ph1">`null`</ph>, and a null reference is treated as less than a non-null.</source>
          <target state="translated">El comparador funciona del siguiente modo: en primer lugar, la comparación se comprueba si hay <ph id="ph1">`null`</ph>, y una referencia nula es tratada como menor que un valor no nulo.</target>       </trans-unit>
        <trans-unit id="273" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.BinarySearch(`0,System.Collections.Generic.IComparer{`0})">
          <source>Second, the string lengths are compared, and the longer string is deemed to be greater.</source>
          <target state="translated">En segundo lugar, se comparan las longitudes de cadena y la cadena más larga se considera mayor.</target>       </trans-unit>
        <trans-unit id="274" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.BinarySearch(`0,System.Collections.Generic.IComparer{`0})">
          <source>Third, if the lengths are equal, ordinary string comparison is used.</source>
          <target state="translated">En tercer lugar, si las longitudes son iguales, se usa la comparación de cadenas normales.</target>       </trans-unit>
        <trans-unit id="275" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.BinarySearch(`0,System.Collections.Generic.IComparer{`0})">
          <source>A <ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph> of strings is created and populated with four strings, in no particular order.</source>
          <target state="translated">Un <ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph> de cadenas se crean y rellenan con cuatro cadenas, sin ningún orden determinado.</target>       </trans-unit>
        <trans-unit id="276" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.BinarySearch(`0,System.Collections.Generic.IComparer{`0})">
          <source>The list is displayed, sorted using the alternate comparer, and displayed again.</source>
          <target state="translated">Muestra la lista se ordena utilizando al comparador alternativo y se muestran nuevo.</target>       </trans-unit>
        <trans-unit id="277" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.BinarySearch(`0,System.Collections.Generic.IComparer{`0})">
          <source>The <ph id="ph1">&lt;xref:System.Collections.Generic.List%601.BinarySearch%28%600%2CSystem.Collections.Generic.IComparer%7B%600%7D%29&gt;</ph> method overload is then used to search for several strings that are not in the list, employing the alternate comparer.</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.Collections.Generic.List%601.BinarySearch%28%600%2CSystem.Collections.Generic.IComparer%7B%600%7D%29&gt;</ph> , a continuación, se utiliza la sobrecarga del método para buscar varias cadenas que no se en la lista, empleando el comparador alternativo.</target>       </trans-unit>
        <trans-unit id="278" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.BinarySearch(`0,System.Collections.Generic.IComparer{`0})">
          <source>The <ph id="ph1">&lt;xref:System.Collections.Generic.List%601.Insert%2A&gt;</ph> method is used to insert the strings.</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.Collections.Generic.List%601.Insert%2A&gt;</ph> método se utiliza para insertar las cadenas.</target>       </trans-unit>
        <trans-unit id="279" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.BinarySearch(`0,System.Collections.Generic.IComparer{`0})">
          <source>These two methods are located in the function named <ph id="ph1">`SearchAndInsert`</ph>, along with code to take the bitwise complement (the ~ operator in C# and Visual C++, <ph id="ph2">`Xor`</ph> -1 in Visual Basic) of the negative number returned by <ph id="ph3">&lt;xref:System.Collections.Generic.List%601.BinarySearch%28%600%2CSystem.Collections.Generic.IComparer%7B%600%7D%29&gt;</ph> and use it as an index for inserting the new string.</source>
          <target state="translated">Estos dos métodos se encuentran en la función denominada <ph id="ph1">`SearchAndInsert`</ph>, junto con el código para tomar el complemento bit a bit (el ~ operador en C# y Visual C++, <ph id="ph2">`Xor`</ph> -1 en Visual Basic) del número negativo devuelto por <ph id="ph3">&lt;xref:System.Collections.Generic.List%601.BinarySearch%28%600%2CSystem.Collections.Generic.IComparer%7B%600%7D%29&gt;</ph> y usarlo como un índice para Insertar la nueva cadena.</target>       </trans-unit>
        <trans-unit id="280" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.List`1.BinarySearch(`0,System.Collections.Generic.IComparer{`0})">
          <source><ph id="ph1">&lt;paramref name="comparer" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>, and the default comparer <ph id="ph3">&lt;see cref="P:System.Collections.Generic.Comparer`1.Default" /&gt;</ph> cannot find an implementation of the <ph id="ph4">&lt;see cref="T:System.IComparable`1" /&gt;</ph> generic interface or the <ph id="ph5">&lt;see cref="T:System.IComparable" /&gt;</ph> interface for type <ph id="ph6">&lt;paramref name="T" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="comparer" /&gt;</ph> es <ph id="ph2">&lt;see langword="null" /&gt;</ph>, y el comparador predeterminado <ph id="ph3">&lt;see cref="P:System.Collections.Generic.Comparer`1.Default" /&gt;</ph> no puede encontrar una implementación de la interfaz genérica <ph id="ph4">&lt;see cref="T:System.IComparable`1" /&gt;</ph> o la interfaz <ph id="ph5">&lt;see cref="T:System.IComparable" /&gt;</ph> del tipo <ph id="ph6">&lt;paramref name="T" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="281" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.List`1.BinarySearch(System.Int32,System.Int32,`0,System.Collections.Generic.IComparer{`0})">
          <source>The zero-based starting index of the range to search.</source>
          <target state="translated">Índice inicial de base cero del intervalo que se va a buscar.</target>       </trans-unit>
        <trans-unit id="282" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.List`1.BinarySearch(System.Int32,System.Int32,`0,System.Collections.Generic.IComparer{`0})">
          <source>The length of the range to search.</source>
          <target state="translated">Longitud del intervalo en el que se va a buscar.</target>       </trans-unit>
        <trans-unit id="283" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.List`1.BinarySearch(System.Int32,System.Int32,`0,System.Collections.Generic.IComparer{`0})">
          <source>The object to locate.</source>
          <target state="translated">Objeto que se va a buscar.</target>       </trans-unit>
        <trans-unit id="284" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.List`1.BinarySearch(System.Int32,System.Int32,`0,System.Collections.Generic.IComparer{`0})">
          <source>The value can be <ph id="ph1">&lt;see langword="null" /&gt;</ph> for reference types.</source>
          <target state="translated">El valor puede ser <ph id="ph1">&lt;see langword="null" /&gt;</ph> para los tipos de referencia.</target>       </trans-unit>
        <trans-unit id="285" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.List`1.BinarySearch(System.Int32,System.Int32,`0,System.Collections.Generic.IComparer{`0})">
          <source>The <ph id="ph1">&lt;see cref="T:System.Collections.Generic.IComparer`1" /&gt;</ph> implementation to use when comparing elements, or <ph id="ph2">&lt;see langword="null" /&gt;</ph> to use the default comparer <ph id="ph3">&lt;see cref="P:System.Collections.Generic.Comparer`1.Default" /&gt;</ph>.</source>
          <target state="translated">Implementación de <ph id="ph1">&lt;see cref="T:System.Collections.Generic.IComparer`1" /&gt;</ph> que se va a utilizar al comparar elementos, o <ph id="ph2">&lt;see langword="null" /&gt;</ph> para utilizar el comparador predeterminado <ph id="ph3">&lt;see cref="P:System.Collections.Generic.Comparer`1.Default" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="286" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.List`1.BinarySearch(System.Int32,System.Int32,`0,System.Collections.Generic.IComparer{`0})">
          <source>Searches a range of elements in the sorted <ph id="ph1">&lt;see cref="T:System.Collections.Generic.List`1" /&gt;</ph> for an element using the specified comparer and returns the zero-based index of the element.</source>
          <target state="translated">Busca un elemento en un intervalo de elementos del objeto <ph id="ph1">&lt;see cref="T:System.Collections.Generic.List`1" /&gt;</ph> ordenado usando el comparador especificado y devuelve el índice de base cero del elemento.</target>       </trans-unit>
        <trans-unit id="287" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.List`1.BinarySearch(System.Int32,System.Int32,`0,System.Collections.Generic.IComparer{`0})">
          <source>The zero-based index of <ph id="ph1">&lt;paramref name="item" /&gt;</ph> in the sorted <ph id="ph2">&lt;see cref="T:System.Collections.Generic.List`1" /&gt;</ph>, if <ph id="ph3">&lt;paramref name="item" /&gt;</ph> is found; otherwise, a negative number that is the bitwise complement of the index of the next element that is larger than <ph id="ph4">&lt;paramref name="item" /&gt;</ph> or, if there is no larger element, the bitwise complement of <ph id="ph5">&lt;see cref="P:System.Collections.Generic.List`1.Count" /&gt;</ph>.</source>
          <target state="translated">Índice de base cero de <ph id="ph1">&lt;paramref name="item" /&gt;</ph> en la <ph id="ph2">&lt;see cref="T:System.Collections.Generic.List`1" /&gt;</ph> ordenada, si es que se encuentra <ph id="ph3">&lt;paramref name="item" /&gt;</ph>; en caso contrario, número negativo que es el complemento bit a bit del índice del siguiente elemento mayor que <ph id="ph4">&lt;paramref name="item" /&gt;</ph> o, si no hay ningún elemento mayor, el complemento bit a bit de <ph id="ph5">&lt;see cref="P:System.Collections.Generic.List`1.Count" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="288" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.BinarySearch(System.Int32,System.Int32,`0,System.Collections.Generic.IComparer{`0})">
          <source>The comparer customizes how the elements are compared.</source>
          <target state="translated">El comparador personaliza cómo se comparan los elementos.</target>       </trans-unit>
        <trans-unit id="289" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.BinarySearch(System.Int32,System.Int32,`0,System.Collections.Generic.IComparer{`0})">
          <source>For example, you can use a <ph id="ph1">&lt;xref:System.Collections.CaseInsensitiveComparer&gt;</ph> instance as the comparer to perform case-insensitive string searches.</source>
          <target state="translated">Por ejemplo, puede usar un <ph id="ph1">&lt;xref:System.Collections.CaseInsensitiveComparer&gt;</ph> instancia como comparador para realizar búsquedas de cadenas entre mayúsculas y minúsculas.</target>       </trans-unit>
        <trans-unit id="290" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.BinarySearch(System.Int32,System.Int32,`0,System.Collections.Generic.IComparer{`0})">
          <source>If <ph id="ph1">`comparer`</ph> is provided, the elements of the <ph id="ph2">&lt;xref:System.Collections.Generic.List%601&gt;</ph> are compared to the specified value using the specified <ph id="ph3">&lt;xref:System.Collections.Generic.IComparer%601&gt;</ph> implementation.</source>
          <target state="translated">Si <ph id="ph1">`comparer`</ph> se proporciona, los elementos de la <ph id="ph2">&lt;xref:System.Collections.Generic.List%601&gt;</ph> se comparan con el valor especificado utilizando el parámetro <ph id="ph3">&lt;xref:System.Collections.Generic.IComparer%601&gt;</ph> implementación.</target>       </trans-unit>
        <trans-unit id="291" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.BinarySearch(System.Int32,System.Int32,`0,System.Collections.Generic.IComparer{`0})">
          <source>If <ph id="ph1">`comparer`</ph> is <ph id="ph2">`null`</ph>, the default comparer <ph id="ph3">&lt;xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType&gt;</ph> checks whether type <ph id="ph4">`T`</ph> implements the <ph id="ph5">&lt;xref:System.IComparable%601&gt;</ph> generic interface and uses that implementation, if available.</source>
          <target state="translated">Si <ph id="ph1">`comparer`</ph> es <ph id="ph2">`null`</ph>, el comparador predeterminado <ph id="ph3">&lt;xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType&gt;</ph> comprueba si tipo <ph id="ph4">`T`</ph> implementa el <ph id="ph5">&lt;xref:System.IComparable%601&gt;</ph> interfaz genérica y utiliza esa implementación, si está disponible.</target>       </trans-unit>
        <trans-unit id="292" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.BinarySearch(System.Int32,System.Int32,`0,System.Collections.Generic.IComparer{`0})">
          <source>If not, <ph id="ph1">&lt;xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType&gt;</ph> checks whether type <ph id="ph2">`T`</ph> implements the <ph id="ph3">&lt;xref:System.IComparable&gt;</ph> interface.</source>
          <target state="translated">Si no es así, <ph id="ph1">&lt;xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType&gt;</ph> comprueba si tipo <ph id="ph2">`T`</ph> implementa el <ph id="ph3">&lt;xref:System.IComparable&gt;</ph> interfaz.</target>       </trans-unit>
        <trans-unit id="293" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.BinarySearch(System.Int32,System.Int32,`0,System.Collections.Generic.IComparer{`0})">
          <source>If type <ph id="ph1">`T`</ph> does not implement either interface, <ph id="ph2">&lt;xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType&gt;</ph> throws <ph id="ph3">&lt;xref:System.InvalidOperationException&gt;</ph>.</source>
          <target state="translated">Si tipo <ph id="ph1">`T`</ph> no implementa ninguna de estas interfaces, <ph id="ph2">&lt;xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType&gt;</ph> produce <ph id="ph3">&lt;xref:System.InvalidOperationException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="294" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.BinarySearch(System.Int32,System.Int32,`0,System.Collections.Generic.IComparer{`0})">
          <source>The <ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph> must already be sorted according to the comparer implementation; otherwise, the result is incorrect.</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph> ya deben estar ordenados según la implementación del comparador; en caso contrario, el resultado es incorrecto.</target>       </trans-unit>
        <trans-unit id="295" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.BinarySearch(System.Int32,System.Int32,`0,System.Collections.Generic.IComparer{`0})">
          <source>Comparing <ph id="ph1">`null`</ph> with any reference type is allowed and does not generate an exception when using the <ph id="ph2">&lt;xref:System.IComparable%601&gt;</ph> generic interface.</source>
          <target state="translated">Comparar <ph id="ph1">`null`</ph> con cualquier referencia de tipo, se permite y no genera una excepción cuando se usa el <ph id="ph2">&lt;xref:System.IComparable%601&gt;</ph> interfaz genérica.</target>       </trans-unit>
        <trans-unit id="296" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.BinarySearch(System.Int32,System.Int32,`0,System.Collections.Generic.IComparer{`0})">
          <source>When sorting, <ph id="ph1">`null`</ph> is considered to be less than any other object.</source>
          <target state="translated">Al ordenar, <ph id="ph1">`null`</ph> se considera menor que cualquier otro objeto.</target>       </trans-unit>
        <trans-unit id="297" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.BinarySearch(System.Int32,System.Int32,`0,System.Collections.Generic.IComparer{`0})">
          <source>If the <ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph> contains more than one element with the same value, the method returns only one of the occurrences, and it might return any one of the occurrences, not necessarily the first one.</source>
          <target state="translated">Si el <ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph> contiene más de un elemento con el mismo valor, el método devuelve solo una de las apariciones y puede devolver cualquiera de ellas, pero no necesariamente la primera de ellas.</target>       </trans-unit>
        <trans-unit id="298" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.BinarySearch(System.Int32,System.Int32,`0,System.Collections.Generic.IComparer{`0})">
          <source>If the <ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph> does not contain the specified value, the method returns a negative integer.</source>
          <target state="translated">Si el <ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph> no contiene el valor especificado, el método devuelve un entero negativo.</target>       </trans-unit>
        <trans-unit id="299" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.BinarySearch(System.Int32,System.Int32,`0,System.Collections.Generic.IComparer{`0})">
          <source>You can apply the bitwise complement operation (~) to this negative integer to get the index of the first element that is larger than the search value.</source>
          <target state="translated">Puede aplicar la operación de complemento bit a bit (~) a este entero negativo para obtener el índice del primer elemento que es mayor que el valor de búsqueda.</target>       </trans-unit>
        <trans-unit id="300" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.BinarySearch(System.Int32,System.Int32,`0,System.Collections.Generic.IComparer{`0})">
          <source>When inserting the value into the <ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph>, this index should be used as the insertion point to maintain the sort order.</source>
          <target state="translated">Cuando se inserta el valor en el <ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph>, este índice se debe utilizar como punto de inserción para mantener el criterio de ordenación.</target>       </trans-unit>
        <trans-unit id="301" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.BinarySearch(System.Int32,System.Int32,`0,System.Collections.Generic.IComparer{`0})">
          <source>This method is an O(log <bpt id="p1">*</bpt>n<ept id="p1">*</ept>) operation, where <bpt id="p2">*</bpt>n<ept id="p2">*</ept> is the number of elements in the range.</source>
          <target state="translated">Este método es una O (registro <bpt id="p1">*</bpt>n<ept id="p1">*</ept>) operación, donde <bpt id="p2">*</bpt>n<ept id="p2">*</ept> es el número de elementos del intervalo.</target>       </trans-unit>
        <trans-unit id="302" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.BinarySearch(System.Int32,System.Int32,`0,System.Collections.Generic.IComparer{`0})">
          <source>The following example demonstrates the <ph id="ph1">&lt;xref:System.Collections.Generic.List%601.Sort%28System.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%600%7D%29&gt;</ph> method overload and the <ph id="ph2">&lt;xref:System.Collections.Generic.List%601.BinarySearch%28System.Int32%2CSystem.Int32%2C%600%2CSystem.Collections.Generic.IComparer%7B%600%7D%29&gt;</ph> method overload.</source>
          <target state="translated">En el ejemplo siguiente se muestra la <ph id="ph1">&lt;xref:System.Collections.Generic.List%601.Sort%28System.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%600%7D%29&gt;</ph> sobrecarga del método y el <ph id="ph2">&lt;xref:System.Collections.Generic.List%601.BinarySearch%28System.Int32%2CSystem.Int32%2C%600%2CSystem.Collections.Generic.IComparer%7B%600%7D%29&gt;</ph> sobrecarga del método.</target>       </trans-unit>
        <trans-unit id="303" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.BinarySearch(System.Int32,System.Int32,`0,System.Collections.Generic.IComparer{`0})">
          <source>The example defines an alternative comparer for strings named DinoCompare, which implements the <ph id="ph1">`IComparer&lt;string&gt;`</ph> (<ph id="ph2">`IComparer(Of String)`</ph> in Visual Basic, <ph id="ph3">`IComparer&lt;String^&gt;`</ph> in Visual C++) generic interface.</source>
          <target state="translated">En el ejemplo se define un comparador alternativo para las cadenas denominado DinoCompare, que implementa el <ph id="ph1">`IComparer&lt;string&gt;`</ph> (<ph id="ph2">`IComparer(Of String)`</ph> en Visual Basic, <ph id="ph3">`IComparer&lt;String^&gt;`</ph> en Visual C++) interfaz genérica.</target>       </trans-unit>
        <trans-unit id="304" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.BinarySearch(System.Int32,System.Int32,`0,System.Collections.Generic.IComparer{`0})">
          <source>The comparer works as follows: First, the comparands are tested for <ph id="ph1">`null`</ph>, and a null reference is treated as less than a non-null.</source>
          <target state="translated">El comparador funciona del siguiente modo: en primer lugar, la comparación se comprueba si hay <ph id="ph1">`null`</ph>, y una referencia nula es tratada como menor que un valor no nulo.</target>       </trans-unit>
        <trans-unit id="305" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.BinarySearch(System.Int32,System.Int32,`0,System.Collections.Generic.IComparer{`0})">
          <source>Second, the string lengths are compared, and the longer string is deemed to be greater.</source>
          <target state="translated">En segundo lugar, se comparan las longitudes de cadena y la cadena más larga se considera mayor.</target>       </trans-unit>
        <trans-unit id="306" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.BinarySearch(System.Int32,System.Int32,`0,System.Collections.Generic.IComparer{`0})">
          <source>Third, if the lengths are equal, ordinary string comparison is used.</source>
          <target state="translated">En tercer lugar, si las longitudes son iguales, se usa la comparación de cadenas normales.</target>       </trans-unit>
        <trans-unit id="307" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.BinarySearch(System.Int32,System.Int32,`0,System.Collections.Generic.IComparer{`0})">
          <source>A <ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph> of strings is created and populated with the names of five herbivorous dinosaurs and three carnivorous dinosaurs.</source>
          <target state="translated">Un <ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph> de cadenas se crean y rellenan con los nombres de cinco dinosaurios herbívoros y tres dinosaurios carnívoros.</target>       </trans-unit>
        <trans-unit id="308" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.BinarySearch(System.Int32,System.Int32,`0,System.Collections.Generic.IComparer{`0})">
          <source>Within each of the two groups, the names are not in any particular sort order.</source>
          <target state="translated">Dentro de cada uno de los dos grupos, los nombres no están en ningún orden determinado.</target>       </trans-unit>
        <trans-unit id="309" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.BinarySearch(System.Int32,System.Int32,`0,System.Collections.Generic.IComparer{`0})">
          <source>The list is displayed, the range of herbivores is sorted using the alternate comparer, and the list is displayed again.</source>
          <target state="translated">Se muestra la lista, se ordena el intervalo de herbívoros utilizando al comparador alternativo y se muestra la lista de nuevo.</target>       </trans-unit>
        <trans-unit id="310" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.BinarySearch(System.Int32,System.Int32,`0,System.Collections.Generic.IComparer{`0})">
          <source>The <ph id="ph1">&lt;xref:System.Collections.Generic.List%601.BinarySearch%28System.Int32%2CSystem.Int32%2C%600%2CSystem.Collections.Generic.IComparer%7B%600%7D%29&gt;</ph> method overload is then used to search only the range of herbivores for "Brachiosaurus".</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.Collections.Generic.List%601.BinarySearch%28System.Int32%2CSystem.Int32%2C%600%2CSystem.Collections.Generic.IComparer%7B%600%7D%29&gt;</ph> , a continuación, se utiliza la sobrecarga del método para buscar sólo el intervalo de herbívoros "Brachiosaurus".</target>       </trans-unit>
        <trans-unit id="311" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.BinarySearch(System.Int32,System.Int32,`0,System.Collections.Generic.IComparer{`0})">
          <source>The string is not found, and the bitwise complement (the ~ operator in C# and Visual C++, <ph id="ph1">`Xor`</ph> -1 in Visual Basic) of the negative number returned by the <ph id="ph2">&lt;xref:System.Collections.Generic.List%601.BinarySearch%28System.Int32%2CSystem.Int32%2C%600%2CSystem.Collections.Generic.IComparer%7B%600%7D%29&gt;</ph> method is used as an index for inserting the new string.</source>
          <target state="translated">No se encuentra la cadena y el complemento bit a bit (el ~ operador en C# y Visual C++, <ph id="ph1">`Xor`</ph> -1 en Visual Basic) del número negativo devuelto por la <ph id="ph2">&lt;xref:System.Collections.Generic.List%601.BinarySearch%28System.Int32%2CSystem.Int32%2C%600%2CSystem.Collections.Generic.IComparer%7B%600%7D%29&gt;</ph> método se utiliza como un índice para insertar la nueva cadena.</target>       </trans-unit>
        <trans-unit id="312" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.List`1.BinarySearch(System.Int32,System.Int32,`0,System.Collections.Generic.IComparer{`0})">
          <source><ph id="ph1">&lt;paramref name="index" /&gt;</ph> is less than 0.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="index" /&gt;</ph> es menor que 0.</target>       </trans-unit>
        <trans-unit id="313" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.List`1.BinarySearch(System.Int32,System.Int32,`0,System.Collections.Generic.IComparer{`0})">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="314" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.List`1.BinarySearch(System.Int32,System.Int32,`0,System.Collections.Generic.IComparer{`0})">
          <source><ph id="ph1">&lt;paramref name="count" /&gt;</ph> is less than 0.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="count" /&gt;</ph> es menor que 0.</target>       </trans-unit>
        <trans-unit id="315" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.List`1.BinarySearch(System.Int32,System.Int32,`0,System.Collections.Generic.IComparer{`0})">
          <source><ph id="ph1">&lt;paramref name="index" /&gt;</ph> and <ph id="ph2">&lt;paramref name="count" /&gt;</ph> do not denote a valid range in the <ph id="ph3">&lt;see cref="T:System.Collections.Generic.List`1" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="index" /&gt;</ph> y <ph id="ph2">&lt;paramref name="count" /&gt;</ph> no denotan un intervalo válido en <ph id="ph3">&lt;see cref="T:System.Collections.Generic.List`1" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="316" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.List`1.BinarySearch(System.Int32,System.Int32,`0,System.Collections.Generic.IComparer{`0})">
          <source><ph id="ph1">&lt;paramref name="comparer" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>, and the default comparer <ph id="ph3">&lt;see cref="P:System.Collections.Generic.Comparer`1.Default" /&gt;</ph> cannot find an implementation of the <ph id="ph4">&lt;see cref="T:System.IComparable`1" /&gt;</ph> generic interface or the <ph id="ph5">&lt;see cref="T:System.IComparable" /&gt;</ph> interface for type <ph id="ph6">&lt;paramref name="T" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="comparer" /&gt;</ph> es <ph id="ph2">&lt;see langword="null" /&gt;</ph>, y el comparador predeterminado <ph id="ph3">&lt;see cref="P:System.Collections.Generic.Comparer`1.Default" /&gt;</ph> no puede encontrar una implementación de la interfaz genérica <ph id="ph4">&lt;see cref="T:System.IComparable`1" /&gt;</ph> o la interfaz <ph id="ph5">&lt;see cref="T:System.IComparable" /&gt;</ph> del tipo <ph id="ph6">&lt;paramref name="T" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="317" translate="yes" xml:space="preserve" uid="P:System.Collections.Generic.List`1.Capacity">
          <source>Gets or sets the total number of elements the internal data structure can hold without resizing.</source>
          <target state="translated">Obtiene o establece el número total de elementos que puede contener la estructura de datos interna sin cambiar el tamaño.</target>       </trans-unit>
        <trans-unit id="318" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.Generic.List`1.Capacity">
          <source>The number of elements that the <ph id="ph1">&lt;see cref="T:System.Collections.Generic.List`1" /&gt;</ph> can contain before resizing is required.</source>
          <target state="translated">Número de elementos que puede contener <ph id="ph1">&lt;see cref="T:System.Collections.Generic.List`1" /&gt;</ph> antes de que sea necesario cambiar el tamaño.</target>       </trans-unit>
        <trans-unit id="319" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.Generic.List`1.Capacity">
          <source><ph id="ph1">&lt;xref:System.Collections.Generic.List%601.Capacity%2A&gt;</ph> is the number of elements that the <ph id="ph2">&lt;xref:System.Collections.Generic.List%601&gt;</ph> can store before resizing is required, whereas <ph id="ph3">&lt;xref:System.Collections.Generic.List%601.Count%2A&gt;</ph> is the number of elements that are actually in the <ph id="ph4">&lt;xref:System.Collections.Generic.List%601&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Collections.Generic.List%601.Capacity%2A&gt;</ph> es el número de elementos que el <ph id="ph2">&lt;xref:System.Collections.Generic.List%601&gt;</ph> pueden almacenar antes de que sea necesario, cambiar el tamaño, mientras que <ph id="ph3">&lt;xref:System.Collections.Generic.List%601.Count%2A&gt;</ph> es el número de elementos que están realmente en la <ph id="ph4">&lt;xref:System.Collections.Generic.List%601&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="320" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.Generic.List`1.Capacity">
          <source><ph id="ph1">&lt;xref:System.Collections.Generic.List%601.Capacity%2A&gt;</ph> is always greater than or equal to <ph id="ph2">&lt;xref:System.Collections.Generic.List%601.Count%2A&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Collections.Generic.List%601.Capacity%2A&gt;</ph> es siempre mayor o igual que <ph id="ph2">&lt;xref:System.Collections.Generic.List%601.Count%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="321" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.Generic.List`1.Capacity">
          <source>If <ph id="ph1">&lt;xref:System.Collections.Generic.List%601.Count%2A&gt;</ph> exceeds <ph id="ph2">&lt;xref:System.Collections.Generic.List%601.Capacity%2A&gt;</ph> while adding elements, the capacity is increased by automatically reallocating the internal array before copying the old elements and adding the new elements.</source>
          <target state="translated">Si <ph id="ph1">&lt;xref:System.Collections.Generic.List%601.Count%2A&gt;</ph> supera <ph id="ph2">&lt;xref:System.Collections.Generic.List%601.Capacity%2A&gt;</ph> al agregar elementos, se aumenta la capacidad reasignando automáticamente la matriz interna antes de copiar los elementos antiguos y agregar los nuevos elementos.</target>       </trans-unit>
        <trans-unit id="322" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.Generic.List`1.Capacity">
          <source>If the capacity is significantly larger than the count and you want to reduce the memory used by the <ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph>,  you can  decrease capacity by calling the <ph id="ph2">&lt;xref:System.Collections.Generic.List%601.TrimExcess%2A&gt;</ph> method or by setting the <ph id="ph3">&lt;xref:System.Collections.Generic.List%601.Capacity%2A&gt;</ph> property explicitly to a lower value.</source>
          <target state="translated">Si la capacidad es significativamente mayor que el recuento y desea reducir la memoria utilizada por el <ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph>, puede reducir la capacidad mediante una llamada a la <ph id="ph2">&lt;xref:System.Collections.Generic.List%601.TrimExcess%2A&gt;</ph> método o estableciendo la <ph id="ph3">&lt;xref:System.Collections.Generic.List%601.Capacity%2A&gt;</ph> propiedad explícitamente a un valor inferior.</target>       </trans-unit>
        <trans-unit id="323" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.Generic.List`1.Capacity">
          <source>When the value of <ph id="ph1">&lt;xref:System.Collections.Generic.List%601.Capacity%2A&gt;</ph> is set explicitly, the internal array is also reallocated to accommodate the specified capacity, and all the elements are copied.</source>
          <target state="translated">Cuando el valor de <ph id="ph1">&lt;xref:System.Collections.Generic.List%601.Capacity%2A&gt;</ph> se establece explícitamente, la matriz interna también se reasigna para alojar la capacidad especificada y se copian todos los elementos.</target>       </trans-unit>
        <trans-unit id="324" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.Generic.List`1.Capacity">
          <source>Retrieving the value of this property is an O(1) operation; setting the property is an O(<bpt id="p1">*</bpt>n<ept id="p1">*</ept>) operation, where <bpt id="p2">*</bpt>n<ept id="p2">*</ept> is the new capacity.</source>
          <target state="translated">La recuperación del valor de esta propiedad es una operación o (1); establecer la propiedad es una O (<bpt id="p1">*</bpt>n<ept id="p1">*</ept>) operación, donde <bpt id="p2">*</bpt>n<ept id="p2">*</ept> es la capacidad de nuevo.</target>       </trans-unit>
        <trans-unit id="325" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.Generic.List`1.Capacity">
          <source>The following example demonstrates how to check the capacity and count of a <ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph> that contains a simple business object, and illustrates using the <ph id="ph2">&lt;xref:System.Collections.Generic.List%601.TrimExcess%2A&gt;</ph> method to remove extra capacity.</source>
          <target state="translated">En el ejemplo siguiente se muestra cómo comprobar la capacidad y el recuento de un <ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph> que contiene un objeto comercial simple y se muestra cómo utilizar el <ph id="ph2">&lt;xref:System.Collections.Generic.List%601.TrimExcess%2A&gt;</ph> método para quitar una capacidad adicional.</target>       </trans-unit>
        <trans-unit id="326" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.Generic.List`1.Capacity">
          <source>The following example shows the <ph id="ph1">&lt;xref:System.Collections.Generic.List%601.Capacity%2A&gt;</ph> property at several points in the life of a list.</source>
          <target state="translated">El siguiente ejemplo se muestra la <ph id="ph1">&lt;xref:System.Collections.Generic.List%601.Capacity%2A&gt;</ph> propiedad en varios puntos en la vida de una lista.</target>       </trans-unit>
        <trans-unit id="327" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.Generic.List`1.Capacity">
          <source>The default constructor is used to create a list of strings with a capacity of 0, and the <ph id="ph1">&lt;xref:System.Collections.Generic.List%601.Capacity%2A&gt;</ph> property is displayed to demonstrate this.</source>
          <target state="translated">El constructor predeterminado se utiliza para crear una lista de cadenas con una capacidad de 0 y el <ph id="ph1">&lt;xref:System.Collections.Generic.List%601.Capacity%2A&gt;</ph> propiedad se muestra para demostrar esto.</target>       </trans-unit>
        <trans-unit id="328" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.Generic.List`1.Capacity">
          <source>After the <ph id="ph1">&lt;xref:System.Collections.Generic.List%601.Add%2A&gt;</ph> method has been used to add several items, the items are listed, and then the <ph id="ph2">&lt;xref:System.Collections.Generic.List%601.Capacity%2A&gt;</ph> property is displayed again, along with the <ph id="ph3">&lt;xref:System.Collections.Generic.List%601.Count%2A&gt;</ph> property, to show that the capacity has been increased as needed.</source>
          <target state="translated">Después de la <ph id="ph1">&lt;xref:System.Collections.Generic.List%601.Add%2A&gt;</ph> método se ha utilizado para agregar varios elementos, se enumeran los elementos y, a continuación, el <ph id="ph2">&lt;xref:System.Collections.Generic.List%601.Capacity%2A&gt;</ph> propiedad se muestra de nuevo, junto con el <ph id="ph3">&lt;xref:System.Collections.Generic.List%601.Count%2A&gt;</ph> propiedad, para mostrar que se ha aumentado la capacidad según sea necesario.</target>       </trans-unit>
        <trans-unit id="329" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.Generic.List`1.Capacity">
          <source>The <ph id="ph1">&lt;xref:System.Collections.Generic.List%601.Capacity%2A&gt;</ph> property is displayed again after the <ph id="ph2">&lt;xref:System.Collections.Generic.List%601.TrimExcess%2A&gt;</ph> method is used to reduce the capacity to match the count.</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.Collections.Generic.List%601.Capacity%2A&gt;</ph> propiedad se muestra después de nuevo el <ph id="ph2">&lt;xref:System.Collections.Generic.List%601.TrimExcess%2A&gt;</ph> método se usa para reducir la capacidad para que coincida con el recuento.</target>       </trans-unit>
        <trans-unit id="330" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.Generic.List`1.Capacity">
          <source>Finally, the <ph id="ph1">&lt;xref:System.Collections.Generic.List%601.Clear%2A&gt;</ph> method is used to remove all items from the list, and the <ph id="ph2">&lt;xref:System.Collections.Generic.List%601.Capacity%2A&gt;</ph> and <ph id="ph3">&lt;xref:System.Collections.Generic.List%601.Count%2A&gt;</ph> properties are displayed again.</source>
          <target state="translated">Por último, el <ph id="ph1">&lt;xref:System.Collections.Generic.List%601.Clear%2A&gt;</ph> método se utiliza para quitar todos los elementos de la lista y el <ph id="ph2">&lt;xref:System.Collections.Generic.List%601.Capacity%2A&gt;</ph> y <ph id="ph3">&lt;xref:System.Collections.Generic.List%601.Count%2A&gt;</ph> propiedades se muestran de nuevo.</target>       </trans-unit>
        <trans-unit id="331" translate="yes" xml:space="preserve" uid="P:System.Collections.Generic.List`1.Capacity">
          <source><ph id="ph1">&lt;see cref="P:System.Collections.Generic.List`1.Capacity" /&gt;</ph> is set to a value that is less than <ph id="ph2">&lt;see cref="P:System.Collections.Generic.List`1.Count" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="P:System.Collections.Generic.List`1.Capacity" /&gt;</ph> se establece en un valor que es menor que <ph id="ph2">&lt;see cref="P:System.Collections.Generic.List`1.Count" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="332" translate="yes" xml:space="preserve" uid="P:System.Collections.Generic.List`1.Capacity">
          <source>There is not enough memory available on the system.</source>
          <target state="translated">No hay memoria suficiente en el sistema.</target>       </trans-unit>
        <trans-unit id="333" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.List`1.Clear">
          <source>Removes all elements from the <ph id="ph1">&lt;see cref="T:System.Collections.Generic.List`1" /&gt;</ph>.</source>
          <target state="translated">Quita todos los elementos de <ph id="ph1">&lt;see cref="T:System.Collections.Generic.List`1" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="334" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.Clear">
          <source><ph id="ph1">&lt;xref:System.Collections.Generic.List%601.Count%2A&gt;</ph> is set to 0, and references to other objects from elements of the collection are also released.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Collections.Generic.List%601.Count%2A&gt;</ph> se establece en 0, y también se liberan las referencias a otros objetos desde los elementos de la colección.</target>       </trans-unit>
        <trans-unit id="335" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.Clear">
          <source><ph id="ph1">&lt;xref:System.Collections.Generic.List%601.Capacity%2A&gt;</ph> remains unchanged.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Collections.Generic.List%601.Capacity%2A&gt;</ph> No cambie.</target>       </trans-unit>
        <trans-unit id="336" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.Clear">
          <source>To reset the capacity of the <ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph>, call the <ph id="ph2">&lt;xref:System.Collections.Generic.List%601.TrimExcess%2A&gt;</ph> method or set the <ph id="ph3">&lt;xref:System.Collections.Generic.List%601.Capacity%2A&gt;</ph> property directly.</source>
          <target state="translated">Para restablecer la capacidad de la <ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph>, llame a la <ph id="ph2">&lt;xref:System.Collections.Generic.List%601.TrimExcess%2A&gt;</ph> método o un conjunto el <ph id="ph3">&lt;xref:System.Collections.Generic.List%601.Capacity%2A&gt;</ph> propiedad directamente.</target>       </trans-unit>
        <trans-unit id="337" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.Clear">
          <source>Decreasing the capacity reallocates memory and copies all the elements in the <ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph>.</source>
          <target state="translated">Al disminuir la capacidad se reasigna memoria y copia todos los elementos en el <ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="338" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.Clear">
          <source>Trimming an empty <ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph> sets the capacity of the <ph id="ph2">&lt;xref:System.Collections.Generic.List%601&gt;</ph> to the default capacity.</source>
          <target state="translated">Recortar vacío <ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph> establece la capacidad de la <ph id="ph2">&lt;xref:System.Collections.Generic.List%601&gt;</ph> en la capacidad predeterminada.</target>       </trans-unit>
        <trans-unit id="339" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.Clear">
          <source>This method is an O(<bpt id="p1">*</bpt>n<ept id="p1">*</ept>) operation, where <bpt id="p2">*</bpt>n<ept id="p2">*</ept> is <ph id="ph1">&lt;xref:System.Collections.Generic.List%601.Count%2A&gt;</ph>.</source>
          <target state="translated">Este método es una O (<bpt id="p1">*</bpt>n<ept id="p1">*</ept>) operación, donde <bpt id="p2">*</bpt>n<ept id="p2">*</ept> es <ph id="ph1">&lt;xref:System.Collections.Generic.List%601.Count%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="340" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.Clear">
          <source>The following example demonstrates the <ph id="ph1">&lt;xref:System.Collections.Generic.List%601.Clear%2A&gt;</ph> method and various other properties and methods of the <ph id="ph2">&lt;xref:System.Collections.Generic.List%601&gt;</ph> generic class.</source>
          <target state="translated">En el ejemplo siguiente se muestra la <ph id="ph1">&lt;xref:System.Collections.Generic.List%601.Clear%2A&gt;</ph> método y varias otras propiedades y métodos de la <ph id="ph2">&lt;xref:System.Collections.Generic.List%601&gt;</ph> clase genérica.</target>       </trans-unit>
        <trans-unit id="341" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.Clear">
          <source>The <ph id="ph1">&lt;xref:System.Collections.Generic.List%601.Clear%2A&gt;</ph> method is used at the end of the program, to remove all items from the list, and the <ph id="ph2">&lt;xref:System.Collections.Generic.List%601.Capacity%2A&gt;</ph> and <ph id="ph3">&lt;xref:System.Collections.Generic.List%601.Count%2A&gt;</ph> properties are then displayed.</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.Collections.Generic.List%601.Clear%2A&gt;</ph> método se usa al final del programa, para quitar todos los elementos de la lista y el <ph id="ph2">&lt;xref:System.Collections.Generic.List%601.Capacity%2A&gt;</ph> y <ph id="ph3">&lt;xref:System.Collections.Generic.List%601.Count%2A&gt;</ph> , a continuación, se muestran las propiedades.</target>       </trans-unit>
        <trans-unit id="342" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.List`1.Contains(`0)">
          <source>The object to locate in the <ph id="ph1">&lt;see cref="T:System.Collections.Generic.List`1" /&gt;</ph>.</source>
          <target state="translated">Objeto que se va a buscar en <ph id="ph1">&lt;see cref="T:System.Collections.Generic.List`1" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="343" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.List`1.Contains(`0)">
          <source>The value can be <ph id="ph1">&lt;see langword="null" /&gt;</ph> for reference types.</source>
          <target state="translated">El valor puede ser <ph id="ph1">&lt;see langword="null" /&gt;</ph> para los tipos de referencia.</target>       </trans-unit>
        <trans-unit id="344" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.List`1.Contains(`0)">
          <source>Determines whether an element is in the <ph id="ph1">&lt;see cref="T:System.Collections.Generic.List`1" /&gt;</ph>.</source>
          <target state="translated">Determina si un elemento se encuentra en <ph id="ph1">&lt;see cref="T:System.Collections.Generic.List`1" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="345" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.List`1.Contains(`0)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if <ph id="ph2">&lt;paramref name="item" /&gt;</ph> is found in the <ph id="ph3">&lt;see cref="T:System.Collections.Generic.List`1" /&gt;</ph>; otherwise, <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> si <ph id="ph2">&lt;paramref name="item" /&gt;</ph> se encuentra en la matriz <ph id="ph3">&lt;see cref="T:System.Collections.Generic.List`1" /&gt;</ph>; en caso contrario, <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="346" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.Contains(`0)">
          <source>This method determines equality by using the default equality comparer, as defined by the object's implementation of the <ph id="ph1">&lt;xref:System.IEquatable%601.Equals%2A?displayProperty=nameWithType&gt;</ph> method for <ph id="ph2">`T`</ph> (the type of values in the list).</source>
          <target state="translated">Este método determina la igualdad utilizando el comparador de igualdad predeterminado, tal como se define por la implementación del objeto de la <ph id="ph1">&lt;xref:System.IEquatable%601.Equals%2A?displayProperty=nameWithType&gt;</ph> método para <ph id="ph2">`T`</ph> (el tipo de valores de la lista).</target>       </trans-unit>
        <trans-unit id="347" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.Contains(`0)">
          <source>This method performs a linear search; therefore, this method is an O(<bpt id="p1">*</bpt>n<ept id="p1">*</ept>) operation, where <bpt id="p2">*</bpt>n<ept id="p2">*</ept> is <ph id="ph1">&lt;xref:System.Collections.Generic.List%601.Count%2A&gt;</ph>.</source>
          <target state="translated">Este método realiza una búsqueda lineal; por lo tanto, este método es una O (<bpt id="p1">*</bpt>n<ept id="p1">*</ept>) operación, donde <bpt id="p2">*</bpt>n<ept id="p2">*</ept> es <ph id="ph1">&lt;xref:System.Collections.Generic.List%601.Count%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="348" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.Contains(`0)">
          <source>The following example demonstrates the <ph id="ph1">&lt;xref:System.Collections.Generic.List%601.Contains%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Collections.Generic.List%601.Exists%2A&gt;</ph> methods on a <ph id="ph3">&lt;xref:System.Collections.Generic.List%601&gt;</ph> that contains a simple business object that implements <ph id="ph4">&lt;xref:System.IEquatable%601.Equals%2A&gt;</ph>.</source>
          <target state="translated">En el ejemplo siguiente se muestra la <ph id="ph1">&lt;xref:System.Collections.Generic.List%601.Contains%2A&gt;</ph> y <ph id="ph2">&lt;xref:System.Collections.Generic.List%601.Exists%2A&gt;</ph> métodos en un <ph id="ph3">&lt;xref:System.Collections.Generic.List%601&gt;</ph> que contiene un objeto comercial simple que implementa <ph id="ph4">&lt;xref:System.IEquatable%601.Equals%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="349" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.Contains(`0)">
          <source>The following example contains a list of complex objects of type <ph id="ph1">`Cube`</ph>.</source>
          <target state="translated">El ejemplo siguiente contiene una lista de objetos complejos de tipo <ph id="ph1">`Cube`</ph>.</target>       </trans-unit>
        <trans-unit id="350" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.Contains(`0)">
          <source>The <ph id="ph1">`Cube`</ph> class implements the <ph id="ph2">&lt;xref:System.IEquatable%601.Equals%2A?displayProperty=nameWithType&gt;</ph> method so that two cubes are considered equal if their dimensions are the same.</source>
          <target state="translated">El <ph id="ph1">`Cube`</ph> la clase implementa la <ph id="ph2">&lt;xref:System.IEquatable%601.Equals%2A?displayProperty=nameWithType&gt;</ph> método para que dos cubos se consideran iguales si sus dimensiones son iguales.</target>       </trans-unit>
        <trans-unit id="351" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.Contains(`0)">
          <source>In this example, the <ph id="ph1">&lt;xref:System.Collections.Generic.List%601.Contains%2A&gt;</ph> method returns <ph id="ph2">`true`</ph>, because a cube that has the specified dimensions is already in the collection.</source>
          <target state="translated">En este ejemplo, el <ph id="ph1">&lt;xref:System.Collections.Generic.List%601.Contains%2A&gt;</ph> método <ph id="ph2">`true`</ph>, ya que un cubo con las dimensiones especificadas ya está en la colección.</target>       </trans-unit>
        <trans-unit id="352" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.ConvertAll``1(System.Converter{`0,``0})">
          <source>The type of the elements of the target array.</source>
          <target state="translated">Tipo de los elementos de la matriz de destino.</target>       </trans-unit>
        <trans-unit id="353" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.List`1.ConvertAll``1(System.Converter{`0,``0})">
          <source>A <ph id="ph1">&lt;see cref="T:System.Converter`2" /&gt;</ph> delegate that converts each element from one type to another type.</source>
          <target state="translated">Delegado <ph id="ph1">&lt;see cref="T:System.Converter`2" /&gt;</ph> que convierte cada elemento de un tipo en otro tipo.</target>       </trans-unit>
        <trans-unit id="354" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.List`1.ConvertAll``1(System.Converter{`0,``0})">
          <source>Converts the elements in the current <ph id="ph1">&lt;see cref="T:System.Collections.Generic.List`1" /&gt;</ph> to another type, and returns a list containing the converted elements.</source>
          <target state="translated">Convierte en otro tipo los elementos incluidos en la <ph id="ph1">&lt;see cref="T:System.Collections.Generic.List`1" /&gt;</ph> actual y devuelve una lista que contiene los elementos convertidos.</target>       </trans-unit>
        <trans-unit id="355" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.List`1.ConvertAll``1(System.Converter{`0,``0})">
          <source>A <ph id="ph1">&lt;see cref="T:System.Collections.Generic.List`1" /&gt;</ph> of the target type containing the converted elements from the current <ph id="ph2">&lt;see cref="T:System.Collections.Generic.List`1" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Collections.Generic.List`1" /&gt;</ph> del tipo de destino que contiene los elementos convertidos de la <ph id="ph2">&lt;see cref="T:System.Collections.Generic.List`1" /&gt;</ph> actual.</target>       </trans-unit>
        <trans-unit id="356" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.ConvertAll``1(System.Converter{`0,``0})">
          <source>The <ph id="ph1">&lt;xref:System.Converter%602&gt;</ph> is a delegate to a method that converts an object to the target type.</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.Converter%602&gt;</ph> es un delegado a un método que convierte un objeto en el tipo de destino.</target>       </trans-unit>
        <trans-unit id="357" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.ConvertAll``1(System.Converter{`0,``0})">
          <source>The elements of the current <ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph> are individually passed to the <ph id="ph2">&lt;xref:System.Converter%602&gt;</ph> delegate, and the converted elements are saved in the new <ph id="ph3">&lt;xref:System.Collections.Generic.List%601&gt;</ph>.</source>
          <target state="translated">Los elementos del elemento actual <ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph> se pasan individualmente a la <ph id="ph2">&lt;xref:System.Converter%602&gt;</ph> delegado y los elementos convertidos se guardan en el nuevo <ph id="ph3">&lt;xref:System.Collections.Generic.List%601&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="358" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.ConvertAll``1(System.Converter{`0,``0})">
          <source>The current <ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph> remains unchanged.</source>
          <target state="translated">Actual <ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph> permanece sin cambios.</target>       </trans-unit>
        <trans-unit id="359" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.ConvertAll``1(System.Converter{`0,``0})">
          <source>This method is an O(<bpt id="p1">*</bpt>n<ept id="p1">*</ept>) operation, where <bpt id="p2">*</bpt>n<ept id="p2">*</ept> is <ph id="ph1">&lt;xref:System.Collections.Generic.List%601.Count%2A&gt;</ph>.</source>
          <target state="translated">Este método es una O (<bpt id="p1">*</bpt>n<ept id="p1">*</ept>) operación, donde <bpt id="p2">*</bpt>n<ept id="p2">*</ept> es <ph id="ph1">&lt;xref:System.Collections.Generic.List%601.Count%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="360" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.ConvertAll``1(System.Converter{`0,``0})">
          <source>The following example defines a method named <ph id="ph1">`PointFToPoint`</ph> that converts a <ph id="ph2">&lt;xref:System.Drawing.PointF&gt;</ph> structure to a <ph id="ph3">&lt;xref:System.Drawing.Point&gt;</ph> structure.</source>
          <target state="translated">En el ejemplo siguiente se define un método denominado <ph id="ph1">`PointFToPoint`</ph> que convierte un <ph id="ph2">&lt;xref:System.Drawing.PointF&gt;</ph> estructura a un <ph id="ph3">&lt;xref:System.Drawing.Point&gt;</ph> estructura.</target>       </trans-unit>
        <trans-unit id="361" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.ConvertAll``1(System.Converter{`0,``0})">
          <source>The example then creates a <ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph> of <ph id="ph2">&lt;xref:System.Drawing.PointF&gt;</ph> structures, creates a <ph id="ph3">`Converter\&lt;PointF, Point&gt;`</ph> delegate (<ph id="ph4">`Converter(Of PointF, Point)`</ph> in Visual Basic) to represent the <ph id="ph5">`PointFToPoint`</ph> method, and passes the delegate to the <ph id="ph6">&lt;xref:System.Collections.Generic.List%601.ConvertAll%2A&gt;</ph> method.</source>
          <target state="translated">El ejemplo crea un <ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph> de <ph id="ph2">&lt;xref:System.Drawing.PointF&gt;</ph> estructuras, crea un <ph id="ph3">`Converter\&lt;PointF, Point&gt;`</ph> delegar (<ph id="ph4">`Converter(Of PointF, Point)`</ph> en Visual Basic) para representar el <ph id="ph5">`PointFToPoint`</ph> método y pasa el delegado a la <ph id="ph6">&lt;xref:System.Collections.Generic.List%601.ConvertAll%2A&gt;</ph> (método).</target>       </trans-unit>
        <trans-unit id="362" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.ConvertAll``1(System.Converter{`0,``0})">
          <source>The <ph id="ph1">&lt;xref:System.Collections.Generic.List%601.ConvertAll%2A&gt;</ph> method passes each element of the input list to the <ph id="ph2">`PointFToPoint`</ph> method and puts the converted elements into a new list of <ph id="ph3">&lt;xref:System.Drawing.Point&gt;</ph> structures.</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.Collections.Generic.List%601.ConvertAll%2A&gt;</ph> método pasa cada elemento de la lista de entrada a la <ph id="ph2">`PointFToPoint`</ph> método y coloca los elementos convertidos en una nueva lista de <ph id="ph3">&lt;xref:System.Drawing.Point&gt;</ph> estructuras.</target>       </trans-unit>
        <trans-unit id="363" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.ConvertAll``1(System.Converter{`0,``0})">
          <source>Both lists are displayed.</source>
          <target state="translated">Se muestran ambas listas.</target>       </trans-unit>
        <trans-unit id="364" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.List`1.ConvertAll``1(System.Converter{`0,``0})">
          <source><ph id="ph1">&lt;paramref name="converter" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="converter" /&gt;</ph> es <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="365" translate="yes" xml:space="preserve" uid="T:System.Collections.Generic.List`1">
          <source>Copies the <ph id="ph1">&lt;see cref="T:System.Collections.Generic.List`1" /&gt;</ph> or a portion of it to an array.</source>
          <target state="translated">Copia la totalidad de <ph id="ph1">&lt;see cref="T:System.Collections.Generic.List`1" /&gt;</ph> o una parte en una matriz.</target>       </trans-unit>
        <trans-unit id="366" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.List`1.CopyTo(`0[])">
          <source>The one-dimensional <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> that is the destination of the elements copied from <ph id="ph2">&lt;see cref="T:System.Collections.Generic.List`1" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> unidimensional que constituye el destino de los elementos copiados de <ph id="ph2">&lt;see cref="T:System.Collections.Generic.List`1" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="367" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.List`1.CopyTo(`0[])">
          <source>The <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> must have zero-based indexing.</source>
          <target state="translated">La matriz <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> debe tener una indización de base cero.</target>       </trans-unit>
        <trans-unit id="368" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.List`1.CopyTo(`0[])">
          <source>Copies the entire <ph id="ph1">&lt;see cref="T:System.Collections.Generic.List`1" /&gt;</ph> to a compatible one-dimensional array, starting at the beginning of the target array.</source>
          <target state="translated">Copia toda la <ph id="ph1">&lt;see cref="T:System.Collections.Generic.List`1" /&gt;</ph> en una matriz unidimensional compatible, empezando en el principio de la matriz de destino.</target>       </trans-unit>
        <trans-unit id="369" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.CopyTo(`0[])">
          <source>This method uses <ph id="ph1">&lt;xref:System.Array.Copy%2A?displayProperty=nameWithType&gt;</ph> to copy the elements.</source>
          <target state="translated">Este método usa <ph id="ph1">&lt;xref:System.Array.Copy%2A?displayProperty=nameWithType&gt;</ph> para copiar los elementos.</target>       </trans-unit>
        <trans-unit id="370" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.CopyTo(`0[])">
          <source>The elements are copied to the <ph id="ph1">&lt;xref:System.Array&gt;</ph> in the same order in which the enumerator iterates through the <ph id="ph2">&lt;xref:System.Collections.Generic.List%601&gt;</ph>.</source>
          <target state="translated">Los elementos se copian en el <ph id="ph1">&lt;xref:System.Array&gt;</ph> en el mismo orden en el que el enumerador recorre en iteración la <ph id="ph2">&lt;xref:System.Collections.Generic.List%601&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="371" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.CopyTo(`0[])">
          <source>This method is an O(<bpt id="p1">*</bpt>n<ept id="p1">*</ept>) operation, where <bpt id="p2">*</bpt>n<ept id="p2">*</ept> is <ph id="ph1">&lt;xref:System.Collections.Generic.List%601.Count%2A&gt;</ph>.</source>
          <target state="translated">Este método es una O (<bpt id="p1">*</bpt>n<ept id="p1">*</ept>) operación, donde <bpt id="p2">*</bpt>n<ept id="p2">*</ept> es <ph id="ph1">&lt;xref:System.Collections.Generic.List%601.Count%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="372" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.CopyTo(`0[])">
          <source>The following example demonstrates all three overloads of the <ph id="ph1">&lt;xref:System.Collections.Generic.List%601.CopyTo%2A&gt;</ph> method.</source>
          <target state="translated">En el ejemplo siguiente se muestra las tres sobrecargas de la <ph id="ph1">&lt;xref:System.Collections.Generic.List%601.CopyTo%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="373" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.CopyTo(`0[])">
          <source>A <ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph> of strings is created and populated with 5 strings.</source>
          <target state="translated">Un <ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph> de cadenas se crean y rellenan con 5 cadenas.</target>       </trans-unit>
        <trans-unit id="374" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.CopyTo(`0[])">
          <source>An empty string array of 15 elements is created, and the <ph id="ph1">&lt;xref:System.Collections.Generic.List%601.CopyTo%28%600%5B%5D%29&gt;</ph> method overload is used to copy all the elements of the list to the array beginning at the first element of the array.</source>
          <target state="translated">Se crea una matriz de cadena vacía de 15 elementos y la <ph id="ph1">&lt;xref:System.Collections.Generic.List%601.CopyTo%28%600%5B%5D%29&gt;</ph> sobrecarga del método se usa para copiar todos los elementos de la lista en la matriz, empezando en el primer elemento de la matriz.</target>       </trans-unit>
        <trans-unit id="375" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.CopyTo(`0[])">
          <source>The <ph id="ph1">&lt;xref:System.Collections.Generic.List%601.CopyTo%28%600%5B%5D%2CSystem.Int32%29&gt;</ph> method overload is used to copy all the elements of the list to the array beginning at array index 6 (leaving index 5 empty).</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.Collections.Generic.List%601.CopyTo%28%600%5B%5D%2CSystem.Int32%29&gt;</ph> sobrecarga del método se usa para copiar todos los elementos de la lista en la matriz, empezando en el índice de matriz 6 (dejando vacío el índice 5).</target>       </trans-unit>
        <trans-unit id="376" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.CopyTo(`0[])">
          <source>Finally, the <ph id="ph1">&lt;xref:System.Collections.Generic.List%601.CopyTo%28System.Int32%2C%600%5B%5D%2CSystem.Int32%2CSystem.Int32%29&gt;</ph> method overload is used to copy 3 elements from the list, beginning with index 2, to the array beginning at array index 12 (leaving index 11 empty).</source>
          <target state="translated">Por último, el <ph id="ph1">&lt;xref:System.Collections.Generic.List%601.CopyTo%28System.Int32%2C%600%5B%5D%2CSystem.Int32%2CSystem.Int32%29&gt;</ph> sobrecarga del método se usa para copiar 3 elementos de la lista, empezando con el índice 2, en la matriz, empezando en la matriz de índice 12 (dejando vacío el índice 11).</target>       </trans-unit>
        <trans-unit id="377" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.CopyTo(`0[])">
          <source>The contents of the array are then displayed.</source>
          <target state="translated">A continuación, se muestra el contenido de la matriz.</target>       </trans-unit>
        <trans-unit id="378" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.List`1.CopyTo(`0[])">
          <source><ph id="ph1">&lt;paramref name="array" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="array" /&gt;</ph> es <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="379" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.List`1.CopyTo(`0[])">
          <source>The number of elements in the source <ph id="ph1">&lt;see cref="T:System.Collections.Generic.List`1" /&gt;</ph> is greater than the number of elements that the destination <ph id="ph2">&lt;paramref name="array" /&gt;</ph> can contain.</source>
          <target state="translated">El número de elementos del <ph id="ph1">&lt;see cref="T:System.Collections.Generic.List`1" /&gt;</ph> de origen es mayor que el número de elementos que puede contener el <ph id="ph2">&lt;paramref name="array" /&gt;</ph> de destino.</target>       </trans-unit>
        <trans-unit id="380" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.List`1.CopyTo(`0[],System.Int32)">
          <source>The one-dimensional <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> that is the destination of the elements copied from <ph id="ph2">&lt;see cref="T:System.Collections.Generic.List`1" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> unidimensional que constituye el destino de los elementos copiados de <ph id="ph2">&lt;see cref="T:System.Collections.Generic.List`1" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="381" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.List`1.CopyTo(`0[],System.Int32)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> must have zero-based indexing.</source>
          <target state="translated">La matriz <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> debe tener una indización de base cero.</target>       </trans-unit>
        <trans-unit id="382" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.List`1.CopyTo(`0[],System.Int32)">
          <source>The zero-based index in <bpt id="p1">&lt;c&gt;</bpt>array<ept id="p1">&lt;/c&gt;</ept> at which copying begins.</source>
          <target state="translated">Índice de base cero de <bpt id="p1">&lt;c&gt;</bpt>array<ept id="p1">&lt;/c&gt;</ept> donde comienza la copia.</target>       </trans-unit>
        <trans-unit id="383" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.List`1.CopyTo(`0[],System.Int32)">
          <source>Copies the entire <ph id="ph1">&lt;see cref="T:System.Collections.Generic.List`1" /&gt;</ph> to a compatible one-dimensional array, starting at the specified index of the target array.</source>
          <target state="translated">Copia la totalidad de <ph id="ph1">&lt;see cref="T:System.Collections.Generic.List`1" /&gt;</ph> en una matriz unidimensional compatible, empezando por el índice especificado de la matriz de destino.</target>       </trans-unit>
        <trans-unit id="384" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.CopyTo(`0[],System.Int32)">
          <source>This method uses <ph id="ph1">&lt;xref:System.Array.Copy%2A?displayProperty=nameWithType&gt;</ph> to copy the elements.</source>
          <target state="translated">Este método usa <ph id="ph1">&lt;xref:System.Array.Copy%2A?displayProperty=nameWithType&gt;</ph> para copiar los elementos.</target>       </trans-unit>
        <trans-unit id="385" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.CopyTo(`0[],System.Int32)">
          <source>The elements are copied to the <ph id="ph1">&lt;xref:System.Array&gt;</ph> in the same order in which the enumerator iterates through the <ph id="ph2">&lt;xref:System.Collections.Generic.List%601&gt;</ph>.</source>
          <target state="translated">Los elementos se copian en el <ph id="ph1">&lt;xref:System.Array&gt;</ph> en el mismo orden en el que el enumerador recorre en iteración la <ph id="ph2">&lt;xref:System.Collections.Generic.List%601&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="386" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.CopyTo(`0[],System.Int32)">
          <source>This method is an O(<bpt id="p1">*</bpt>n<ept id="p1">*</ept>) operation, where <bpt id="p2">*</bpt>n<ept id="p2">*</ept> is <ph id="ph1">&lt;xref:System.Collections.Generic.List%601.Count%2A&gt;</ph>.</source>
          <target state="translated">Este método es una O (<bpt id="p1">*</bpt>n<ept id="p1">*</ept>) operación, donde <bpt id="p2">*</bpt>n<ept id="p2">*</ept> es <ph id="ph1">&lt;xref:System.Collections.Generic.List%601.Count%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="387" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.CopyTo(`0[],System.Int32)">
          <source>The following example demonstrates all three overloads of the <ph id="ph1">&lt;xref:System.Collections.Generic.List%601.CopyTo%2A&gt;</ph> method.</source>
          <target state="translated">En el ejemplo siguiente se muestra las tres sobrecargas de la <ph id="ph1">&lt;xref:System.Collections.Generic.List%601.CopyTo%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="388" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.CopyTo(`0[],System.Int32)">
          <source>A <ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph> of strings is created and populated with 5 strings.</source>
          <target state="translated">Un <ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph> de cadenas se crean y rellenan con 5 cadenas.</target>       </trans-unit>
        <trans-unit id="389" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.CopyTo(`0[],System.Int32)">
          <source>An empty string array of 15 elements is created, and the <ph id="ph1">&lt;xref:System.Collections.Generic.List%601.CopyTo%28%600%5B%5D%29&gt;</ph> method overload is used to copy all the elements of the list to the array beginning at the first element of the array.</source>
          <target state="translated">Se crea una matriz de cadena vacía de 15 elementos y la <ph id="ph1">&lt;xref:System.Collections.Generic.List%601.CopyTo%28%600%5B%5D%29&gt;</ph> sobrecarga del método se usa para copiar todos los elementos de la lista en la matriz, empezando en el primer elemento de la matriz.</target>       </trans-unit>
        <trans-unit id="390" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.CopyTo(`0[],System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.Collections.Generic.List%601.CopyTo%28%600%5B%5D%2CSystem.Int32%29&gt;</ph> method overload is used to copy all the elements of the list to the array beginning at array index 6 (leaving index 5 empty).</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.Collections.Generic.List%601.CopyTo%28%600%5B%5D%2CSystem.Int32%29&gt;</ph> sobrecarga del método se usa para copiar todos los elementos de la lista en la matriz, empezando en el índice de matriz 6 (dejando vacío el índice 5).</target>       </trans-unit>
        <trans-unit id="391" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.CopyTo(`0[],System.Int32)">
          <source>Finally, the <ph id="ph1">&lt;xref:System.Collections.Generic.List%601.CopyTo%28System.Int32%2C%600%5B%5D%2CSystem.Int32%2CSystem.Int32%29&gt;</ph> method overload is used to copy 3 elements from the list, beginning with index 2, to the array beginning at array index 12 (leaving index 11 empty).</source>
          <target state="translated">Por último, el <ph id="ph1">&lt;xref:System.Collections.Generic.List%601.CopyTo%28System.Int32%2C%600%5B%5D%2CSystem.Int32%2CSystem.Int32%29&gt;</ph> sobrecarga del método se usa para copiar 3 elementos de la lista, empezando con el índice 2, en la matriz, empezando en la matriz de índice 12 (dejando vacío el índice 11).</target>       </trans-unit>
        <trans-unit id="392" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.CopyTo(`0[],System.Int32)">
          <source>The contents of the array are then displayed.</source>
          <target state="translated">A continuación, se muestra el contenido de la matriz.</target>       </trans-unit>
        <trans-unit id="393" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.List`1.CopyTo(`0[],System.Int32)">
          <source><ph id="ph1">&lt;paramref name="array" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="array" /&gt;</ph> es <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="394" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.List`1.CopyTo(`0[],System.Int32)">
          <source><ph id="ph1">&lt;paramref name="arrayIndex" /&gt;</ph> is less than 0.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="arrayIndex" /&gt;</ph> es menor que 0.</target>       </trans-unit>
        <trans-unit id="395" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.List`1.CopyTo(`0[],System.Int32)">
          <source>The number of elements in the source <ph id="ph1">&lt;see cref="T:System.Collections.Generic.List`1" /&gt;</ph> is greater than the available space from <ph id="ph2">&lt;paramref name="arrayIndex" /&gt;</ph> to the end of the destination <ph id="ph3">&lt;paramref name="array" /&gt;</ph>.</source>
          <target state="translated">El número de elementos de la <ph id="ph1">&lt;see cref="T:System.Collections.Generic.List`1" /&gt;</ph> de origen es mayor que el espacio disponible desde <ph id="ph2">&lt;paramref name="arrayIndex" /&gt;</ph> hasta el final de la <ph id="ph3">&lt;paramref name="array" /&gt;</ph> de destino.</target>       </trans-unit>
        <trans-unit id="396" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.List`1.CopyTo(System.Int32,`0[],System.Int32,System.Int32)">
          <source>The zero-based index in the source <ph id="ph1">&lt;see cref="T:System.Collections.Generic.List`1" /&gt;</ph> at which copying begins.</source>
          <target state="translated">Índice de base cero de la <ph id="ph1">&lt;see cref="T:System.Collections.Generic.List`1" /&gt;</ph> de origen donde comienza la copia.</target>       </trans-unit>
        <trans-unit id="397" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.List`1.CopyTo(System.Int32,`0[],System.Int32,System.Int32)">
          <source>The one-dimensional <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> that is the destination of the elements copied from <ph id="ph2">&lt;see cref="T:System.Collections.Generic.List`1" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> unidimensional que constituye el destino de los elementos copiados de <ph id="ph2">&lt;see cref="T:System.Collections.Generic.List`1" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="398" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.List`1.CopyTo(System.Int32,`0[],System.Int32,System.Int32)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> must have zero-based indexing.</source>
          <target state="translated">La matriz <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> debe tener una indización de base cero.</target>       </trans-unit>
        <trans-unit id="399" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.List`1.CopyTo(System.Int32,`0[],System.Int32,System.Int32)">
          <source>The zero-based index in <bpt id="p1">&lt;c&gt;</bpt>array<ept id="p1">&lt;/c&gt;</ept> at which copying begins.</source>
          <target state="translated">Índice de base cero de <bpt id="p1">&lt;c&gt;</bpt>array<ept id="p1">&lt;/c&gt;</ept> donde comienza la copia.</target>       </trans-unit>
        <trans-unit id="400" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.List`1.CopyTo(System.Int32,`0[],System.Int32,System.Int32)">
          <source>The number of elements to copy.</source>
          <target state="translated">Número de elementos que se van a copiar.</target>       </trans-unit>
        <trans-unit id="401" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.List`1.CopyTo(System.Int32,`0[],System.Int32,System.Int32)">
          <source>Copies a range of elements from the <ph id="ph1">&lt;see cref="T:System.Collections.Generic.List`1" /&gt;</ph> to a compatible one-dimensional array, starting at the specified index of the target array.</source>
          <target state="translated">Copia un intervalo de elementos de <ph id="ph1">&lt;see cref="T:System.Collections.Generic.List`1" /&gt;</ph> en una matriz unidimensional compatible, empezando en el índice especificado de la matriz de destino.</target>       </trans-unit>
        <trans-unit id="402" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.CopyTo(System.Int32,`0[],System.Int32,System.Int32)">
          <source>This method uses <ph id="ph1">&lt;xref:System.Array.Copy%2A?displayProperty=nameWithType&gt;</ph> to copy the elements.</source>
          <target state="translated">Este método usa <ph id="ph1">&lt;xref:System.Array.Copy%2A?displayProperty=nameWithType&gt;</ph> para copiar los elementos.</target>       </trans-unit>
        <trans-unit id="403" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.CopyTo(System.Int32,`0[],System.Int32,System.Int32)">
          <source>The elements are copied to the <ph id="ph1">&lt;xref:System.Array&gt;</ph> in the same order in which the enumerator iterates through the <ph id="ph2">&lt;xref:System.Collections.Generic.List%601&gt;</ph>.</source>
          <target state="translated">Los elementos se copian en el <ph id="ph1">&lt;xref:System.Array&gt;</ph> en el mismo orden en el que el enumerador recorre en iteración la <ph id="ph2">&lt;xref:System.Collections.Generic.List%601&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="404" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.CopyTo(System.Int32,`0[],System.Int32,System.Int32)">
          <source>This method is an O(<bpt id="p1">*</bpt>n<ept id="p1">*</ept>) operation, where <bpt id="p2">*</bpt>n<ept id="p2">*</ept> is <ph id="ph1">`count`</ph>.</source>
          <target state="translated">Este método es una O (<bpt id="p1">*</bpt>n<ept id="p1">*</ept>) operación, donde <bpt id="p2">*</bpt>n<ept id="p2">*</ept> es <ph id="ph1">`count`</ph>.</target>       </trans-unit>
        <trans-unit id="405" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.CopyTo(System.Int32,`0[],System.Int32,System.Int32)">
          <source>The following example demonstrates all three overloads of the <ph id="ph1">&lt;xref:System.Collections.Generic.List%601.CopyTo%2A&gt;</ph> method.</source>
          <target state="translated">En el ejemplo siguiente se muestra las tres sobrecargas de la <ph id="ph1">&lt;xref:System.Collections.Generic.List%601.CopyTo%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="406" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.CopyTo(System.Int32,`0[],System.Int32,System.Int32)">
          <source>A <ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph> of strings is created and populated with 5 strings.</source>
          <target state="translated">Un <ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph> de cadenas se crean y rellenan con 5 cadenas.</target>       </trans-unit>
        <trans-unit id="407" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.CopyTo(System.Int32,`0[],System.Int32,System.Int32)">
          <source>An empty string array of 15 elements is created, and the <ph id="ph1">&lt;xref:System.Collections.Generic.List%601.CopyTo%28%600%5B%5D%29&gt;</ph> method overload is used to copy all the elements of the list to the array beginning at the first element of the array.</source>
          <target state="translated">Se crea una matriz de cadena vacía de 15 elementos y la <ph id="ph1">&lt;xref:System.Collections.Generic.List%601.CopyTo%28%600%5B%5D%29&gt;</ph> sobrecarga del método se usa para copiar todos los elementos de la lista en la matriz, empezando en el primer elemento de la matriz.</target>       </trans-unit>
        <trans-unit id="408" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.CopyTo(System.Int32,`0[],System.Int32,System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.Collections.Generic.List%601.CopyTo%28%600%5B%5D%2CSystem.Int32%29&gt;</ph> method overload is used to copy all the elements of the list to the array beginning at array index 6 (leaving index 5 empty).</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.Collections.Generic.List%601.CopyTo%28%600%5B%5D%2CSystem.Int32%29&gt;</ph> sobrecarga del método se usa para copiar todos los elementos de la lista en la matriz, empezando en el índice de matriz 6 (dejando vacío el índice 5).</target>       </trans-unit>
        <trans-unit id="409" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.CopyTo(System.Int32,`0[],System.Int32,System.Int32)">
          <source>Finally, the <ph id="ph1">&lt;xref:System.Collections.Generic.List%601.CopyTo%28System.Int32%2C%600%5B%5D%2CSystem.Int32%2CSystem.Int32%29&gt;</ph> method overload is used to copy 3 elements from the list, beginning with index 2, to the array beginning at array index 12 (leaving index 11 empty).</source>
          <target state="translated">Por último, el <ph id="ph1">&lt;xref:System.Collections.Generic.List%601.CopyTo%28System.Int32%2C%600%5B%5D%2CSystem.Int32%2CSystem.Int32%29&gt;</ph> sobrecarga del método se usa para copiar 3 elementos de la lista, empezando con el índice 2, en la matriz, empezando en la matriz de índice 12 (dejando vacío el índice 11).</target>       </trans-unit>
        <trans-unit id="410" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.CopyTo(System.Int32,`0[],System.Int32,System.Int32)">
          <source>The contents of the array are then displayed.</source>
          <target state="translated">A continuación, se muestra el contenido de la matriz.</target>       </trans-unit>
        <trans-unit id="411" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.List`1.CopyTo(System.Int32,`0[],System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="array" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="array" /&gt;</ph> es <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="412" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.List`1.CopyTo(System.Int32,`0[],System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="index" /&gt;</ph> is less than 0.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="index" /&gt;</ph> es menor que 0.</target>       </trans-unit>
        <trans-unit id="413" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.List`1.CopyTo(System.Int32,`0[],System.Int32,System.Int32)">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="414" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.List`1.CopyTo(System.Int32,`0[],System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="arrayIndex" /&gt;</ph> is less than 0.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="arrayIndex" /&gt;</ph> es menor que 0.</target>       </trans-unit>
        <trans-unit id="415" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.List`1.CopyTo(System.Int32,`0[],System.Int32,System.Int32)">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="416" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.List`1.CopyTo(System.Int32,`0[],System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="count" /&gt;</ph> is less than 0.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="count" /&gt;</ph> es menor que 0.</target>       </trans-unit>
        <trans-unit id="417" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.List`1.CopyTo(System.Int32,`0[],System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="index" /&gt;</ph> is equal to or greater than the <ph id="ph2">&lt;see cref="P:System.Collections.Generic.List`1.Count" /&gt;</ph> of the source <ph id="ph3">&lt;see cref="T:System.Collections.Generic.List`1" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="index" /&gt;</ph> es mayor o igual que el valor de <ph id="ph2">&lt;see cref="P:System.Collections.Generic.List`1.Count" /&gt;</ph> de la <ph id="ph3">&lt;see cref="T:System.Collections.Generic.List`1" /&gt;</ph> de origen.</target>       </trans-unit>
        <trans-unit id="418" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.List`1.CopyTo(System.Int32,`0[],System.Int32,System.Int32)">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="419" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.List`1.CopyTo(System.Int32,`0[],System.Int32,System.Int32)">
          <source>The number of elements from <ph id="ph1">&lt;paramref name="index" /&gt;</ph> to the end of the source <ph id="ph2">&lt;see cref="T:System.Collections.Generic.List`1" /&gt;</ph> is greater than the available space from <ph id="ph3">&lt;paramref name="arrayIndex" /&gt;</ph> to the end of the destination <ph id="ph4">&lt;paramref name="array" /&gt;</ph>.</source>
          <target state="translated">El número de elementos de <ph id="ph1">&lt;paramref name="index" /&gt;</ph> hasta el final de <ph id="ph2">&lt;see cref="T:System.Collections.Generic.List`1" /&gt;</ph> de origen es mayor que el espacio disponible desde <ph id="ph3">&lt;paramref name="arrayIndex" /&gt;</ph> hasta el final de <ph id="ph4">&lt;paramref name="array" /&gt;</ph> de destino.</target>       </trans-unit>
        <trans-unit id="420" translate="yes" xml:space="preserve" uid="P:System.Collections.Generic.List`1.Count">
          <source>Gets the number of elements contained in the <ph id="ph1">&lt;see cref="T:System.Collections.Generic.List`1" /&gt;</ph>.</source>
          <target state="translated">Obtiene el número de elementos incluidos en <ph id="ph1">&lt;see cref="T:System.Collections.Generic.List`1" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="421" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.Generic.List`1.Count">
          <source>The number of elements contained in the <ph id="ph1">&lt;see cref="T:System.Collections.Generic.List`1" /&gt;</ph>.</source>
          <target state="translated">Número de elementos contenidos en <ph id="ph1">&lt;see cref="T:System.Collections.Generic.List`1" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="422" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.Generic.List`1.Count">
          <source><ph id="ph1">&lt;xref:System.Collections.Generic.List%601.Capacity%2A&gt;</ph> is the number of elements that the <ph id="ph2">&lt;xref:System.Collections.Generic.List%601&gt;</ph> can store before resizing is required.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Collections.Generic.List%601.Capacity%2A&gt;</ph> es el número de elementos que el <ph id="ph2">&lt;xref:System.Collections.Generic.List%601&gt;</ph> pueden almacenar antes de que sea necesario cambiar el tamaño.</target>       </trans-unit>
        <trans-unit id="423" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.Generic.List`1.Count">
          <source><ph id="ph1">&lt;xref:System.Collections.Generic.List%601.Count%2A&gt;</ph> is the number of elements that are actually in the <ph id="ph2">&lt;xref:System.Collections.Generic.List%601&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Collections.Generic.List%601.Count%2A&gt;</ph> es el número de elementos que están realmente en la <ph id="ph2">&lt;xref:System.Collections.Generic.List%601&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="424" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.Generic.List`1.Count">
          <source><ph id="ph1">&lt;xref:System.Collections.Generic.List%601.Capacity%2A&gt;</ph> is always greater than or equal to <ph id="ph2">&lt;xref:System.Collections.Generic.List%601.Count%2A&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Collections.Generic.List%601.Capacity%2A&gt;</ph> es siempre mayor o igual que <ph id="ph2">&lt;xref:System.Collections.Generic.List%601.Count%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="425" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.Generic.List`1.Count">
          <source>If <ph id="ph1">&lt;xref:System.Collections.Generic.List%601.Count%2A&gt;</ph> exceeds <ph id="ph2">&lt;xref:System.Collections.Generic.List%601.Capacity%2A&gt;</ph> while adding elements, the capacity is increased by automatically reallocating the internal array before copying the old elements and adding the new elements.</source>
          <target state="translated">Si <ph id="ph1">&lt;xref:System.Collections.Generic.List%601.Count%2A&gt;</ph> supera <ph id="ph2">&lt;xref:System.Collections.Generic.List%601.Capacity%2A&gt;</ph> al agregar elementos, se aumenta la capacidad reasignando automáticamente la matriz interna antes de copiar los elementos antiguos y agregar los nuevos elementos.</target>       </trans-unit>
        <trans-unit id="426" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.Generic.List`1.Count">
          <source>Retrieving the value of this property is an O(1) operation.</source>
          <target state="translated">La recuperación del valor de esta propiedad es una operación O(1).</target>       </trans-unit>
        <trans-unit id="427" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.Generic.List`1.Count">
          <source>The following example demonstrates how to check the capacity and count of a  <ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph> that contains a simple business object, and illustrates using the <ph id="ph2">&lt;xref:System.Collections.Generic.List%601.TrimExcess%2A&gt;</ph> method to remove extra capacity.</source>
          <target state="translated">En el ejemplo siguiente se muestra cómo comprobar la capacidad y el recuento de un <ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph> que contiene un objeto comercial simple y se muestra cómo utilizar el <ph id="ph2">&lt;xref:System.Collections.Generic.List%601.TrimExcess%2A&gt;</ph> método para quitar una capacidad adicional.</target>       </trans-unit>
        <trans-unit id="428" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.Generic.List`1.Count">
          <source>The following example shows the value of the <ph id="ph1">&lt;xref:System.Collections.Generic.List%601.Count%2A&gt;</ph> property at various points in the life of a list.</source>
          <target state="translated">En el ejemplo siguiente se muestra el valor de la <ph id="ph1">&lt;xref:System.Collections.Generic.List%601.Count%2A&gt;</ph> propiedad en varios puntos en la vida de una lista.</target>       </trans-unit>
        <trans-unit id="429" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.Generic.List`1.Count">
          <source>After the list has been created and populated and its elements displayed, the <ph id="ph1">&lt;xref:System.Collections.Generic.List%601.Capacity%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Collections.Generic.List%601.Count%2A&gt;</ph> properties are displayed.</source>
          <target state="translated">Una vez creada y rellena la lista y muestran sus elementos, el <ph id="ph1">&lt;xref:System.Collections.Generic.List%601.Capacity%2A&gt;</ph> y <ph id="ph2">&lt;xref:System.Collections.Generic.List%601.Count%2A&gt;</ph> se muestran las propiedades.</target>       </trans-unit>
        <trans-unit id="430" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.Generic.List`1.Count">
          <source>These properties are displayed again after the <ph id="ph1">&lt;xref:System.Collections.Generic.List%601.TrimExcess%2A&gt;</ph> method has been called, and again after the contents of the list are cleared.</source>
          <target state="translated">Estas propiedades se muestran después de volver a la <ph id="ph1">&lt;xref:System.Collections.Generic.List%601.TrimExcess%2A&gt;</ph> ha sido método llamado así como después el contenido de la lista se borra.</target>       </trans-unit>
        <trans-unit id="431" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.List`1.Exists(System.Predicate{`0})">
          <source>The <ph id="ph1">&lt;see cref="T:System.Predicate`1" /&gt;</ph> delegate that defines the conditions of the elements to search for.</source>
          <target state="translated">Delegado <ph id="ph1">&lt;see cref="T:System.Predicate`1" /&gt;</ph> que define las condiciones de los elementos que se van a buscar.</target>       </trans-unit>
        <trans-unit id="432" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.List`1.Exists(System.Predicate{`0})">
          <source>Determines whether the <ph id="ph1">&lt;see cref="T:System.Collections.Generic.List`1" /&gt;</ph> contains elements that match the conditions defined by the specified predicate.</source>
          <target state="translated">Determina si <ph id="ph1">&lt;see cref="T:System.Collections.Generic.List`1" /&gt;</ph> contiene elementos que cumplen las condiciones definidas por el predicado especificado.</target>       </trans-unit>
        <trans-unit id="433" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.List`1.Exists(System.Predicate{`0})">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the <ph id="ph2">&lt;see cref="T:System.Collections.Generic.List`1" /&gt;</ph> contains one or more elements that match the conditions defined by the specified predicate; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">Es <ph id="ph1">&lt;see langword="true" /&gt;</ph> si <ph id="ph2">&lt;see cref="T:System.Collections.Generic.List`1" /&gt;</ph> contiene uno o varios elementos que cumplen las condiciones definidas por el predicado especificado; en caso contrario, es <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="434" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.Exists(System.Predicate{`0})">
          <source>The <ph id="ph1">&lt;xref:System.Predicate%601&gt;</ph> is a delegate to a method that returns <ph id="ph2">`true`</ph> if the object passed to it matches the conditions defined in the delegate.</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.Predicate%601&gt;</ph> es un delegado a un método que devuelve <ph id="ph2">`true`</ph> si el objeto pasado a coincide con las condiciones definidas en el delegado.</target>       </trans-unit>
        <trans-unit id="435" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.Exists(System.Predicate{`0})">
          <source>The elements of the current <ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph> are individually passed to the <ph id="ph2">&lt;xref:System.Predicate%601&gt;</ph> delegate, and processing is stopped when a match is found.</source>
          <target state="translated">Los elementos del elemento actual <ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph> se pasan individualmente a la <ph id="ph2">&lt;xref:System.Predicate%601&gt;</ph> delegado y el procesamiento se detiene cuando se encuentra una coincidencia.</target>       </trans-unit>
        <trans-unit id="436" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.Exists(System.Predicate{`0})">
          <source>This method performs a linear search; therefore, this method is an O(<bpt id="p1">*</bpt>n<ept id="p1">*</ept>) operation, where <bpt id="p2">*</bpt>n<ept id="p2">*</ept> is <ph id="ph1">&lt;xref:System.Collections.Generic.List%601.Count%2A&gt;</ph>.</source>
          <target state="translated">Este método realiza una búsqueda lineal; por lo tanto, este método es una O (<bpt id="p1">*</bpt>n<ept id="p1">*</ept>) operación, donde <bpt id="p2">*</bpt>n<ept id="p2">*</ept> es <ph id="ph1">&lt;xref:System.Collections.Generic.List%601.Count%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="437" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.Exists(System.Predicate{`0})">
          <source>The following example demonstrates the <ph id="ph1">&lt;xref:System.Collections.Generic.List%601.Contains%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Collections.Generic.List%601.Exists%2A&gt;</ph> methods on a <ph id="ph3">&lt;xref:System.Collections.Generic.List%601&gt;</ph> that contains a simple business object that implements <ph id="ph4">&lt;xref:System.IEquatable%601.Equals%2A&gt;</ph>.</source>
          <target state="translated">En el ejemplo siguiente se muestra la <ph id="ph1">&lt;xref:System.Collections.Generic.List%601.Contains%2A&gt;</ph> y <ph id="ph2">&lt;xref:System.Collections.Generic.List%601.Exists%2A&gt;</ph> métodos en un <ph id="ph3">&lt;xref:System.Collections.Generic.List%601&gt;</ph> que contiene un objeto comercial simple que implementa <ph id="ph4">&lt;xref:System.IEquatable%601.Equals%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="438" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.Exists(System.Predicate{`0})">
          <source>The following example demonstrates the <ph id="ph1">&lt;xref:System.Collections.Generic.List%601.Exists%2A&gt;</ph> method and several other methods that use the <ph id="ph2">&lt;xref:System.Predicate%601&gt;</ph> generic delegate.</source>
          <target state="translated">En el ejemplo siguiente se muestra la <ph id="ph1">&lt;xref:System.Collections.Generic.List%601.Exists%2A&gt;</ph> (método) y otros métodos que utilizan el <ph id="ph2">&lt;xref:System.Predicate%601&gt;</ph> delegado genérico.</target>       </trans-unit>
        <trans-unit id="439" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.Exists(System.Predicate{`0})">
          <source>A <ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph> of strings is created, containing 8 dinosaur names, two of which (at positions 1 and 5) end with "saurus".</source>
          <target state="translated">Un <ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph> de cadenas se crea, que contiene 8 nombres de dinosaurio, dos de los cuales (en las posiciones 1 y 5) terminan en "saurus".</target>       </trans-unit>
        <trans-unit id="440" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.Exists(System.Predicate{`0})">
          <source>The example also defines a search predicate method named <ph id="ph1">`EndsWithSaurus`</ph>, which accepts a string parameter and returns a Boolean value indicating whether the input string ends in "saurus".</source>
          <target state="translated">El ejemplo también define un método de predicado de búsqueda denominado <ph id="ph1">`EndsWithSaurus`</ph>, que acepta un parámetro de cadena y devuelve un valor booleano de valor que indica si la cadena de entrada termina en "saurus".</target>       </trans-unit>
        <trans-unit id="441" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.Exists(System.Predicate{`0})">
          <source>The <ph id="ph1">&lt;xref:System.Collections.Generic.List%601.Find%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Collections.Generic.List%601.FindLast%2A&gt;</ph>, and <ph id="ph3">&lt;xref:System.Collections.Generic.List%601.FindAll%2A&gt;</ph> methods are used to search the list with the search predicate method, and then the <ph id="ph4">&lt;xref:System.Collections.Generic.List%601.RemoveAll%2A&gt;</ph> method is used to remove all entries ending with "saurus".</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.Collections.Generic.List%601.Find%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Collections.Generic.List%601.FindLast%2A&gt;</ph>, y <ph id="ph3">&lt;xref:System.Collections.Generic.List%601.FindAll%2A&gt;</ph> métodos se usan para buscar la lista con el método de predicado de búsqueda y, a continuación, el <ph id="ph4">&lt;xref:System.Collections.Generic.List%601.RemoveAll%2A&gt;</ph> método se utiliza para quitar todas las entradas que terminen en "saurus".</target>       </trans-unit>
        <trans-unit id="442" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.Exists(System.Predicate{`0})">
          <source>Finally, the <ph id="ph1">&lt;xref:System.Collections.Generic.List%601.Exists%2A&gt;</ph> method is called.</source>
          <target state="translated">Por último, el <ph id="ph1">&lt;xref:System.Collections.Generic.List%601.Exists%2A&gt;</ph> se llama al método.</target>       </trans-unit>
        <trans-unit id="443" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.Exists(System.Predicate{`0})">
          <source>It traverses the list from the beginning, passing each element in turn to the <ph id="ph1">`EndsWithSaurus`</ph> method.</source>
          <target state="translated">Recorre la lista desde el principio, pasando cada elemento a su vez a la <ph id="ph1">`EndsWithSaurus`</ph> método.</target>       </trans-unit>
        <trans-unit id="444" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.Exists(System.Predicate{`0})">
          <source>The search stops and the method returns <ph id="ph1">`true`</ph> if the <ph id="ph2">`EndsWithSaurus`</ph> method returns <ph id="ph3">`true`</ph> for any element.</source>
          <target state="translated">La búsqueda se detiene y el método devuelve <ph id="ph1">`true`</ph> si la <ph id="ph2">`EndsWithSaurus`</ph> método <ph id="ph3">`true`</ph> para cualquier elemento.</target>       </trans-unit>
        <trans-unit id="445" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.Exists(System.Predicate{`0})">
          <source>The <ph id="ph1">&lt;xref:System.Collections.Generic.List%601.Exists%2A&gt;</ph> method returns <ph id="ph2">`false`</ph> because all such elements have been removed.</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.Collections.Generic.List%601.Exists%2A&gt;</ph> método <ph id="ph2">`false`</ph> porque se han quitado todos los elementos de este tipo.</target>       </trans-unit>
        <trans-unit id="446" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.Exists(System.Predicate{`0})">
          <source>In C# and Visual Basic, it is not necessary to create the <ph id="ph1">`Predicate&lt;string&gt;`</ph> delegate (<ph id="ph2">`Predicate(Of String)`</ph> in Visual Basic) explicitly.</source>
          <target state="translated">En C# y Visual Basic, no es necesario crear la <ph id="ph1">`Predicate&lt;string&gt;`</ph> delegar (<ph id="ph2">`Predicate(Of String)`</ph> en Visual Basic) explícitamente.</target>       </trans-unit>
        <trans-unit id="447" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.Exists(System.Predicate{`0})">
          <source>These languages infer the correct delegate from context and create it automatically.</source>
          <target state="translated">Estos lenguajes deducen al delegado correcto del contexto y lo crean automáticamente.</target>       </trans-unit>
        <trans-unit id="448" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.List`1.Exists(System.Predicate{`0})">
          <source><ph id="ph1">&lt;paramref name="match" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="match" /&gt;</ph> es <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="449" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.List`1.Find(System.Predicate{`0})">
          <source>The <ph id="ph1">&lt;see cref="T:System.Predicate`1" /&gt;</ph> delegate that defines the conditions of the element to search for.</source>
          <target state="translated">Delegado <ph id="ph1">&lt;see cref="T:System.Predicate`1" /&gt;</ph> que define las condiciones del elemento que se va a buscar.</target>       </trans-unit>
        <trans-unit id="450" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.List`1.Find(System.Predicate{`0})">
          <source>Searches for an element that matches the conditions defined by the specified predicate, and returns the first occurrence within the entire <ph id="ph1">&lt;see cref="T:System.Collections.Generic.List`1" /&gt;</ph>.</source>
          <target state="translated">Busca un elemento que coincida con las condiciones definidas por el predicado especificado y devuelve la primera aparición en toda la matriz <ph id="ph1">&lt;see cref="T:System.Collections.Generic.List`1" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="451" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.List`1.Find(System.Predicate{`0})">
          <source>The first element that matches the conditions defined by the specified predicate, if found; otherwise, the default value for type <ph id="ph1">&lt;paramref name="T" /&gt;</ph>.</source>
          <target state="translated">Primer elemento que coincide con las condiciones definidas por el predicado especificado, si se encuentra; de lo contrario, valor predeterminado para el tipo <ph id="ph1">&lt;paramref name="T" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="452" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.Find(System.Predicate{`0})">
          <source>The <ph id="ph1">&lt;xref:System.Predicate%601&gt;</ph> is a delegate to a method that returns <ph id="ph2">`true`</ph> if the object passed to it matches the conditions defined in the delegate.</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.Predicate%601&gt;</ph> es un delegado a un método que devuelve <ph id="ph2">`true`</ph> si el objeto pasado a coincide con las condiciones definidas en el delegado.</target>       </trans-unit>
        <trans-unit id="453" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.Find(System.Predicate{`0})">
          <source>The elements of the current <ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph> are individually passed to the <ph id="ph2">&lt;xref:System.Predicate%601&gt;</ph> delegate, moving forward in the <ph id="ph3">&lt;xref:System.Collections.Generic.List%601&gt;</ph>, starting with the first element and ending with the last element.</source>
          <target state="translated">Los elementos del elemento actual <ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph> se pasan individualmente a la <ph id="ph2">&lt;xref:System.Predicate%601&gt;</ph> delegado, avanzando el <ph id="ph3">&lt;xref:System.Collections.Generic.List%601&gt;</ph>, empezando por el primer elemento y terminando con el último elemento.</target>       </trans-unit>
        <trans-unit id="454" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.Find(System.Predicate{`0})">
          <source>Processing is stopped when a match is found.</source>
          <target state="translated">Cuando se encuentra una coincidencia, se detiene el procesamiento.</target>       </trans-unit>
        <trans-unit id="455" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.Find(System.Predicate{`0})">
          <source>When searching a list containing value types, make sure the default value for the type does not satisfy the search predicate.</source>
          <target state="translated">Al buscar una lista que contiene los tipos de valor, asegúrese de que el valor predeterminado para el tipo no cumple el predicado de búsqueda.</target>       </trans-unit>
        <trans-unit id="456" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.Find(System.Predicate{`0})">
          <source>Otherwise, there is no way to distinguish between a default value indicating that no match was found and a list element that happens to have the default value for the type.</source>
          <target state="translated">En caso contrario, no hay ninguna manera de distinguir entre un elemento de lista que posee el valor predeterminado para el tipo y un valor predeterminado que indica que se encontró ninguna coincidencia.</target>       </trans-unit>
        <trans-unit id="457" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.Find(System.Predicate{`0})">
          <source>If the default value satisfies the search predicate, use the <ph id="ph1">&lt;xref:System.Collections.Generic.List%601.FindIndex%2A&gt;</ph> method instead.</source>
          <target state="translated">Si el valor predeterminado satisface el predicado de búsqueda, utilice la <ph id="ph1">&lt;xref:System.Collections.Generic.List%601.FindIndex%2A&gt;</ph> método en su lugar.</target>       </trans-unit>
        <trans-unit id="458" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.Find(System.Predicate{`0})">
          <source>This method performs a linear search; therefore, this method is an O(<bpt id="p1">*</bpt>n<ept id="p1">*</ept>) operation, where <bpt id="p2">*</bpt>n<ept id="p2">*</ept> is <ph id="ph1">&lt;xref:System.Collections.Generic.List%601.Count%2A&gt;</ph>.</source>
          <target state="translated">Este método realiza una búsqueda lineal; por lo tanto, este método es una O (<bpt id="p1">*</bpt>n<ept id="p1">*</ept>) operación, donde <bpt id="p2">*</bpt>n<ept id="p2">*</ept> es <ph id="ph1">&lt;xref:System.Collections.Generic.List%601.Count%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="459" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.Find(System.Predicate{`0})">
          <source>The following example demonstrates the <ph id="ph1">&lt;xref:System.Collections.Generic.List%601.Find%2A&gt;</ph> method on a <ph id="ph2">&lt;xref:System.Collections.Generic.List%601&gt;</ph> that contains a simple complex object.</source>
          <target state="translated">En el ejemplo siguiente se muestra la <ph id="ph1">&lt;xref:System.Collections.Generic.List%601.Find%2A&gt;</ph> método en un <ph id="ph2">&lt;xref:System.Collections.Generic.List%601&gt;</ph> que contiene un objeto complejo simple.</target>       </trans-unit>
        <trans-unit id="460" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.Find(System.Predicate{`0})">
          <source>The following example demonstrates the find methods for the <ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph> class.</source>
          <target state="translated">El ejemplo siguiente muestra los métodos de búsqueda para la <ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph> clase.</target>       </trans-unit>
        <trans-unit id="461" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.Find(System.Predicate{`0})">
          <source>The example for the <ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph> class contains <ph id="ph2">`book`</ph> objects, of class <ph id="ph3">`Book`</ph>, using the data from the <bpt id="p1">[</bpt>Sample XML File: Books (LINQ to XML)<ept id="p1">](http://msdn.microsoft.com/library/94252daf-6097-4625-afc2-0eb778958d4f)</ept>.</source>
          <target state="translated">El ejemplo de la <ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph> clase contiene <ph id="ph2">`book`</ph> objetos de clase <ph id="ph3">`Book`</ph>, con los datos de la <bpt id="p1">[</bpt>archivo XML de ejemplo: libros (LINQ to XML)<ept id="p1">](http://msdn.microsoft.com/library/94252daf-6097-4625-afc2-0eb778958d4f)</ept>.</target>       </trans-unit>
        <trans-unit id="462" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.Find(System.Predicate{`0})">
          <source>The <ph id="ph1">`FillList`</ph> method in the example uses <bpt id="p1">[</bpt>LINQ to XML<ept id="p1">](http://msdn.microsoft.com/library/f0fe21e9-ee43-4a55-b91a-0800e5782c13)</ept> to parse the values from the XML to property values of the <ph id="ph2">`book`</ph> objects.</source>
          <target state="translated">El <ph id="ph1">`FillList`</ph> método en el ejemplo usa <bpt id="p1">[</bpt>LINQ to XML<ept id="p1">](http://msdn.microsoft.com/library/f0fe21e9-ee43-4a55-b91a-0800e5782c13)</ept> para analizar los valores del archivo XML para los valores de propiedad de la <ph id="ph2">`book`</ph> objetos.</target>       </trans-unit>
        <trans-unit id="463" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.Find(System.Predicate{`0})">
          <source>The following table describes the examples provided for the find methods.</source>
          <target state="translated">En la tabla siguiente describe los ejemplos de los métodos de búsqueda.</target>       </trans-unit>
        <trans-unit id="464" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.Find(System.Predicate{`0})">
          <source>Method</source>
          <target state="translated">Método</target>       </trans-unit>
        <trans-unit id="465" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.Find(System.Predicate{`0})">
          <source>Example</source>
          <target state="translated">Ejemplo</target>       </trans-unit>
        <trans-unit id="466" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.Find(System.Predicate{`0})">
          <source>Finds a book by an ID using the <ph id="ph1">`IDToFind`</ph> predicate delegate.</source>
          <target state="translated">Encuentra un libro por un identificador utilizando el <ph id="ph1">`IDToFind`</ph> delegado de predicado.</target>       </trans-unit>
        <trans-unit id="467" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.Find(System.Predicate{`0})">
          <source>C# example uses an anonymous delegate.</source>
          <target state="translated">Ejemplo de C# usa a un delegado anónimo.</target>       </trans-unit>
        <trans-unit id="468" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.Find(System.Predicate{`0})">
          <source>Find all books that whose <ph id="ph1">`Genre`</ph> property is "Computer" using the <ph id="ph2">`FindComputer`</ph> predicate delegate.</source>
          <target state="translated">Buscar todos los libros que cuya <ph id="ph1">`Genre`</ph> propiedad es "Equipo" con el <ph id="ph2">`FindComputer`</ph> delegado de predicado.</target>       </trans-unit>
        <trans-unit id="469" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.Find(System.Predicate{`0})">
          <source>Finds the last book in the collection that has a publish date before 2001, using the <ph id="ph1">`PubBefore2001`</ph> predicate delegate.</source>
          <target state="translated">Busca el último libro en la colección que tiene una fecha de publicación anterior a 2001, utilizando el <ph id="ph1">`PubBefore2001`</ph> delegado de predicado.</target>       </trans-unit>
        <trans-unit id="470" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.Find(System.Predicate{`0})">
          <source>C# example uses an anonymous delegate.</source>
          <target state="translated">Ejemplo de C# usa a un delegado anónimo.</target>       </trans-unit>
        <trans-unit id="471" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.Find(System.Predicate{`0})">
          <source>Finds the index of first computer book using the <ph id="ph1">`FindComputer`</ph> predicate delegate.</source>
          <target state="translated">Busca el índice del primer equipo libro utilizando la <ph id="ph1">`FindComputer`</ph> delegado de predicado.</target>       </trans-unit>
        <trans-unit id="472" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.Find(System.Predicate{`0})">
          <source>Finds the index of the last computer book using the <ph id="ph1">`FindComputer`</ph> predicate delegate.</source>
          <target state="translated">Busca el índice del último libro equipo utilizando el <ph id="ph1">`FindComputer`</ph> delegado de predicado.</target>       </trans-unit>
        <trans-unit id="473" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.Find(System.Predicate{`0})">
          <source>Finds the index of first computer book in the second half of the collection, using the <ph id="ph1">`FindComputer`</ph> predicate delegate.</source>
          <target state="translated">Busca el índice del primer libro informático en la segunda mitad de la colección, usando el <ph id="ph1">`FindComputer`</ph> delegado de predicado.</target>       </trans-unit>
        <trans-unit id="474" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.Find(System.Predicate{`0})">
          <source>Finds the index of last computer book in the second half of the collection, using the <ph id="ph1">`FindComputer`</ph> predicate delegate.</source>
          <target state="translated">Busca el índice del último libro informático en la segunda mitad de la colección, usando el <ph id="ph1">`FindComputer`</ph> delegado de predicado.</target>       </trans-unit>
        <trans-unit id="475" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.List`1.Find(System.Predicate{`0})">
          <source><ph id="ph1">&lt;paramref name="match" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="match" /&gt;</ph> es <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="476" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.List`1.FindAll(System.Predicate{`0})">
          <source>The <ph id="ph1">&lt;see cref="T:System.Predicate`1" /&gt;</ph> delegate that defines the conditions of the elements to search for.</source>
          <target state="translated">Delegado <ph id="ph1">&lt;see cref="T:System.Predicate`1" /&gt;</ph> que define las condiciones de los elementos que se van a buscar.</target>       </trans-unit>
        <trans-unit id="477" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.List`1.FindAll(System.Predicate{`0})">
          <source>Retrieves all the elements that match the conditions defined by the specified predicate.</source>
          <target state="translated">Recupera todos los elementos que coinciden con las condiciones definidas por el predicado especificado.</target>       </trans-unit>
        <trans-unit id="478" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.List`1.FindAll(System.Predicate{`0})">
          <source>A <ph id="ph1">&lt;see cref="T:System.Collections.Generic.List`1" /&gt;</ph> containing all the elements that match the conditions defined by the specified predicate, if found; otherwise, an empty <ph id="ph2">&lt;see cref="T:System.Collections.Generic.List`1" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Collections.Generic.List`1" /&gt;</ph> que contiene todos los elementos que cumplen las condiciones definidas por el predicado especificado, si se encuentran; en caso contrario, devuelve una <ph id="ph2">&lt;see cref="T:System.Collections.Generic.List`1" /&gt;</ph> vacía.</target>       </trans-unit>
        <trans-unit id="479" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.FindAll(System.Predicate{`0})">
          <source>The <ph id="ph1">&lt;xref:System.Predicate%601&gt;</ph> is a delegate to a method that returns <ph id="ph2">`true`</ph> if the object passed to it matches the conditions defined in the delegate.</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.Predicate%601&gt;</ph> es un delegado a un método que devuelve <ph id="ph2">`true`</ph> si el objeto pasado a coincide con las condiciones definidas en el delegado.</target>       </trans-unit>
        <trans-unit id="480" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.FindAll(System.Predicate{`0})">
          <source>The elements of the current <ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph> are individually passed to the <ph id="ph2">&lt;xref:System.Predicate%601&gt;</ph> delegate, and the elements that match the conditions are saved in the returned <ph id="ph3">&lt;xref:System.Collections.Generic.List%601&gt;</ph>.</source>
          <target state="translated">Los elementos del elemento actual <ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph> se pasan individualmente a la <ph id="ph2">&lt;xref:System.Predicate%601&gt;</ph> delegado y los elementos que cumplen las condiciones se guardan en el valor devuelto <ph id="ph3">&lt;xref:System.Collections.Generic.List%601&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="481" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.FindAll(System.Predicate{`0})">
          <source>This method performs a linear search; therefore, this method is an O(<bpt id="p1">*</bpt>n<ept id="p1">*</ept>) operation, where <bpt id="p2">*</bpt>n<ept id="p2">*</ept> is <ph id="ph1">&lt;xref:System.Collections.Generic.List%601.Count%2A&gt;</ph>.</source>
          <target state="translated">Este método realiza una búsqueda lineal; por lo tanto, este método es una O (<bpt id="p1">*</bpt>n<ept id="p1">*</ept>) operación, donde <bpt id="p2">*</bpt>n<ept id="p2">*</ept> es <ph id="ph1">&lt;xref:System.Collections.Generic.List%601.Count%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="482" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.FindAll(System.Predicate{`0})">
          <source>The following example demonstrates the find methods for the <ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph> class.</source>
          <target state="translated">El ejemplo siguiente muestra los métodos de búsqueda para la <ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph> clase.</target>       </trans-unit>
        <trans-unit id="483" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.FindAll(System.Predicate{`0})">
          <source>The example for the <ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph> class contains <ph id="ph2">`book`</ph> objects, of class <ph id="ph3">`Book`</ph>, using the data from the <bpt id="p1">[</bpt>Sample XML File: Books (LINQ to XML)<ept id="p1">](http://msdn.microsoft.com/library/94252daf-6097-4625-afc2-0eb778958d4f)</ept>.</source>
          <target state="translated">El ejemplo de la <ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph> clase contiene <ph id="ph2">`book`</ph> objetos de clase <ph id="ph3">`Book`</ph>, con los datos de la <bpt id="p1">[</bpt>archivo XML de ejemplo: libros (LINQ to XML)<ept id="p1">](http://msdn.microsoft.com/library/94252daf-6097-4625-afc2-0eb778958d4f)</ept>.</target>       </trans-unit>
        <trans-unit id="484" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.FindAll(System.Predicate{`0})">
          <source>The <ph id="ph1">`FillList`</ph> method in the example uses <bpt id="p1">[</bpt>LINQ to XML<ept id="p1">](http://msdn.microsoft.com/library/f0fe21e9-ee43-4a55-b91a-0800e5782c13)</ept> to parse the values from the XML to property values of the <ph id="ph2">`book`</ph> objects.</source>
          <target state="translated">El <ph id="ph1">`FillList`</ph> método en el ejemplo usa <bpt id="p1">[</bpt>LINQ to XML<ept id="p1">](http://msdn.microsoft.com/library/f0fe21e9-ee43-4a55-b91a-0800e5782c13)</ept> para analizar los valores del archivo XML para los valores de propiedad de la <ph id="ph2">`book`</ph> objetos.</target>       </trans-unit>
        <trans-unit id="485" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.FindAll(System.Predicate{`0})">
          <source>The following table describes the examples provided for the find methods.</source>
          <target state="translated">En la tabla siguiente describe los ejemplos de los métodos de búsqueda.</target>       </trans-unit>
        <trans-unit id="486" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.FindAll(System.Predicate{`0})">
          <source>Method</source>
          <target state="translated">Método</target>       </trans-unit>
        <trans-unit id="487" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.FindAll(System.Predicate{`0})">
          <source>Example</source>
          <target state="translated">Ejemplo</target>       </trans-unit>
        <trans-unit id="488" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.FindAll(System.Predicate{`0})">
          <source>Finds a book by an ID using the <ph id="ph1">`IDToFind`</ph> predicate delegate.</source>
          <target state="translated">Encuentra un libro por un identificador utilizando el <ph id="ph1">`IDToFind`</ph> delegado de predicado.</target>       </trans-unit>
        <trans-unit id="489" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.FindAll(System.Predicate{`0})">
          <source>C# example uses an anonymous delegate.</source>
          <target state="translated">Ejemplo de C# usa a un delegado anónimo.</target>       </trans-unit>
        <trans-unit id="490" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.FindAll(System.Predicate{`0})">
          <source>Find all books that whose <ph id="ph1">`Genre`</ph> property is "Computer" using the <ph id="ph2">`FindComputer`</ph> predicate delegate.</source>
          <target state="translated">Buscar todos los libros que cuya <ph id="ph1">`Genre`</ph> propiedad es "Equipo" con el <ph id="ph2">`FindComputer`</ph> delegado de predicado.</target>       </trans-unit>
        <trans-unit id="491" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.FindAll(System.Predicate{`0})">
          <source>Finds the last book in the collection that has a publish date before 2001, using the <ph id="ph1">`PubBefore2001`</ph> predicate delegate.</source>
          <target state="translated">Busca el último libro en la colección que tiene una fecha de publicación anterior a 2001, utilizando el <ph id="ph1">`PubBefore2001`</ph> delegado de predicado.</target>       </trans-unit>
        <trans-unit id="492" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.FindAll(System.Predicate{`0})">
          <source>C# example uses an anonymous delegate.</source>
          <target state="translated">Ejemplo de C# usa a un delegado anónimo.</target>       </trans-unit>
        <trans-unit id="493" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.FindAll(System.Predicate{`0})">
          <source>Finds the index of first computer book using the <ph id="ph1">`FindComputer`</ph> predicate delegate.</source>
          <target state="translated">Busca el índice del primer equipo libro utilizando la <ph id="ph1">`FindComputer`</ph> delegado de predicado.</target>       </trans-unit>
        <trans-unit id="494" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.FindAll(System.Predicate{`0})">
          <source>Finds the index of the last computer book using the <ph id="ph1">`FindComputer`</ph> predicate delegate.</source>
          <target state="translated">Busca el índice del último libro equipo utilizando el <ph id="ph1">`FindComputer`</ph> delegado de predicado.</target>       </trans-unit>
        <trans-unit id="495" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.FindAll(System.Predicate{`0})">
          <source>Finds the index of first computer book in the second half of the collection, using the <ph id="ph1">`FindComputer`</ph> predicate delegate.</source>
          <target state="translated">Busca el índice del primer libro informático en la segunda mitad de la colección, usando el <ph id="ph1">`FindComputer`</ph> delegado de predicado.</target>       </trans-unit>
        <trans-unit id="496" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.FindAll(System.Predicate{`0})">
          <source>Finds the index of last computer book in the second half of the collection, using the <ph id="ph1">`FindComputer`</ph> predicate delegate.</source>
          <target state="translated">Busca el índice del último libro informático en la segunda mitad de la colección, usando el <ph id="ph1">`FindComputer`</ph> delegado de predicado.</target>       </trans-unit>
        <trans-unit id="497" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.List`1.FindAll(System.Predicate{`0})">
          <source><ph id="ph1">&lt;paramref name="match" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="match" /&gt;</ph> es <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="498" translate="yes" xml:space="preserve" uid="T:System.Collections.Generic.List`1">
          <source>Searches for an element that matches the conditions defined by a specified predicate, and returns the zero-based index of the first occurrence within the <ph id="ph1">&lt;see cref="T:System.Collections.Generic.List`1" /&gt;</ph> or a portion of it.</source>
          <target state="translated">Busca un elemento que cumpla las condiciones definidas por el predicado especificado y devuelve el índice de base cero de la primera aparición en <ph id="ph1">&lt;see cref="T:System.Collections.Generic.List`1" /&gt;</ph> o en una parte.</target>       </trans-unit>
        <trans-unit id="499" translate="yes" xml:space="preserve" uid="T:System.Collections.Generic.List`1">
          <source>This method returns -1 if an item that matches the conditions is not found.</source>
          <target state="translated">Este método devuelve -1 si no se encuentra un elemento que cumpla las condiciones.</target>       </trans-unit>
        <trans-unit id="500" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.List`1.FindIndex(System.Predicate{`0})">
          <source>The <ph id="ph1">&lt;see cref="T:System.Predicate`1" /&gt;</ph> delegate that defines the conditions of the element to search for.</source>
          <target state="translated">Delegado <ph id="ph1">&lt;see cref="T:System.Predicate`1" /&gt;</ph> que define las condiciones del elemento que se va a buscar.</target>       </trans-unit>
        <trans-unit id="501" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.List`1.FindIndex(System.Predicate{`0})">
          <source>Searches for an element that matches the conditions defined by the specified predicate, and returns the zero-based index of the first occurrence within the entire <ph id="ph1">&lt;see cref="T:System.Collections.Generic.List`1" /&gt;</ph>.</source>
          <target state="translated">Busca un elemento que coincida con las condiciones definidas por el predicado especificado y devuelve el índice de base cero de la primera aparición en toda la matriz <ph id="ph1">&lt;see cref="T:System.Collections.Generic.List`1" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="502" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.List`1.FindIndex(System.Predicate{`0})">
          <source>The zero-based index of the first occurrence of an element that matches the conditions defined by <ph id="ph1">&lt;paramref name="match" /&gt;</ph>, if found; otherwise, –1.</source>
          <target state="translated">Índice de base cero de la primera aparición de un elemento que coincide con las condiciones definidas por <ph id="ph1">&lt;paramref name="match" /&gt;</ph>, si se encuentra; en caso contrario, -1.</target>       </trans-unit>
        <trans-unit id="503" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.FindIndex(System.Predicate{`0})">
          <source>The <ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph> is searched forward starting at the first element and ending at the last element.</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph> se busca hacia delante a partir del primer elemento y terminando con el último elemento.</target>       </trans-unit>
        <trans-unit id="504" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.FindIndex(System.Predicate{`0})">
          <source>The <ph id="ph1">&lt;xref:System.Predicate%601&gt;</ph> is a delegate to a method that returns <ph id="ph2">`true`</ph> if the object passed to it matches the conditions defined in the delegate.</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.Predicate%601&gt;</ph> es un delegado a un método que devuelve <ph id="ph2">`true`</ph> si el objeto pasado a coincide con las condiciones definidas en el delegado.</target>       </trans-unit>
        <trans-unit id="505" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.FindIndex(System.Predicate{`0})">
          <source>The elements of the current <ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph> are individually passed to the <ph id="ph2">&lt;xref:System.Predicate%601&gt;</ph> delegate.</source>
          <target state="translated">Los elementos del elemento actual <ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph> se pasan individualmente a la <ph id="ph2">&lt;xref:System.Predicate%601&gt;</ph> delegar.</target>       </trans-unit>
        <trans-unit id="506" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.FindIndex(System.Predicate{`0})">
          <source>The delegate has the signature:</source>
          <target state="translated">El delegado tiene la firma:</target>       </trans-unit>
        <trans-unit id="507" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.FindIndex(System.Predicate{`0})">
          <source>This method performs a linear search; therefore, this method is an O(<bpt id="p1">*</bpt>n<ept id="p1">*</ept>) operation, where <bpt id="p2">*</bpt>n<ept id="p2">*</ept> is <ph id="ph1">&lt;xref:System.Collections.Generic.List%601.Count%2A&gt;</ph>.</source>
          <target state="translated">Este método realiza una búsqueda lineal; por lo tanto, este método es una O (<bpt id="p1">*</bpt>n<ept id="p1">*</ept>) operación, donde <bpt id="p2">*</bpt>n<ept id="p2">*</ept> es <ph id="ph1">&lt;xref:System.Collections.Generic.List%601.Count%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="508" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.FindIndex(System.Predicate{`0})">
          <source>The following example defines an <ph id="ph1">`Employee`</ph> class with two fields, <ph id="ph2">`Name`</ph> and <ph id="ph3">`Id`</ph>.</source>
          <target state="translated">En el ejemplo siguiente se define un <ph id="ph1">`Employee`</ph> clase con dos campos, <ph id="ph2">`Name`</ph> y <ph id="ph3">`Id`</ph>.</target>       </trans-unit>
        <trans-unit id="509" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.FindIndex(System.Predicate{`0})">
          <source>It also defines an <ph id="ph1">`EmployeeSearch`</ph> class with a single method, <ph id="ph2">`StartsWith`</ph>, that indicates whether the <ph id="ph3">`Employee.Name`</ph> field starts with a specified substring that is supplied to the <ph id="ph4">`EmployeeSearch`</ph> class constructor.</source>
          <target state="translated">También define un <ph id="ph1">`EmployeeSearch`</ph> clase con un método único, <ph id="ph2">`StartsWith`</ph>, que indica si la <ph id="ph3">`Employee.Name`</ph> campo comienza con una subcadena especificada que se proporciona a los <ph id="ph4">`EmployeeSearch`</ph> constructor de clase.</target>       </trans-unit>
        <trans-unit id="510" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.FindIndex(System.Predicate{`0})">
          <source>Note  the signature of this method</source>
          <target state="translated">Tenga en cuenta la firma de este método</target>       </trans-unit>
        <trans-unit id="511" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.FindIndex(System.Predicate{`0})">
          <source>corresponds to the signature of the delegate that can be passed to the <ph id="ph1">&lt;xref:System.Collections.Generic.List%601.FindIndex%2A&gt;</ph> method.</source>
          <target state="translated">corresponde a la firma del delegado que puede pasarse a la <ph id="ph1">&lt;xref:System.Collections.Generic.List%601.FindIndex%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="512" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.FindIndex(System.Predicate{`0})">
          <source>The example instantiates a <ph id="ph1">`List&lt;Employee&gt;`</ph> object, adds a number of <ph id="ph2">`Employee`</ph> objets to it, and then calls the <ph id="ph3">&lt;xref:System.Collections.Generic.List%601.FindIndex%28System.Int32%2CSystem.Int32%2CSystem.Predicate%7B%600%7D%29&gt;</ph> method twice  to search the entire collection , the first time for the first <ph id="ph4">`Employee`</ph> object whose <ph id="ph5">`Name`</ph> field begins with "J", and the second time for the first <ph id="ph6">`Employee`</ph> object whose <ph id="ph7">`Name`</ph> field begins with "Ju".</source>
          <target state="translated">El ejemplo crea un <ph id="ph1">`List&lt;Employee&gt;`</ph> de objetos, se agrega un número de <ph id="ph2">`Employee`</ph> objetos y, a continuación, llama el <ph id="ph3">&lt;xref:System.Collections.Generic.List%601.FindIndex%28System.Int32%2CSystem.Int32%2CSystem.Predicate%7B%600%7D%29&gt;</ph> método dos veces para buscar la colección completa, la primera vez para el primer <ph id="ph4">`Employee`</ph> cuyos <ph id="ph5">`Name`</ph> campo comienza con "J" y la segunda vez para el primer <ph id="ph6">`Employee`</ph> cuyos <ph id="ph7">`Name`</ph> campo comienza con "Ju".</target>       </trans-unit>
        <trans-unit id="513" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.List`1.FindIndex(System.Predicate{`0})">
          <source><ph id="ph1">&lt;paramref name="match" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="match" /&gt;</ph> es <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="514" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.List`1.FindIndex(System.Int32,System.Predicate{`0})">
          <source>The zero-based starting index of the search.</source>
          <target state="translated">Índice inicial de base cero de la búsqueda.</target>       </trans-unit>
        <trans-unit id="515" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.List`1.FindIndex(System.Int32,System.Predicate{`0})">
          <source>The <ph id="ph1">&lt;see cref="T:System.Predicate`1" /&gt;</ph> delegate that defines the conditions of the element to search for.</source>
          <target state="translated">Delegado <ph id="ph1">&lt;see cref="T:System.Predicate`1" /&gt;</ph> que define las condiciones del elemento que se va a buscar.</target>       </trans-unit>
        <trans-unit id="516" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.List`1.FindIndex(System.Int32,System.Predicate{`0})">
          <source>Searches for an element that matches the conditions defined by the specified predicate, and returns the zero-based index of the first occurrence within the range of elements in the <ph id="ph1">&lt;see cref="T:System.Collections.Generic.List`1" /&gt;</ph> that extends from the specified index to the last element.</source>
          <target state="translated">Busca un elemento que coincida con las condiciones definidas por el predicado especificado y devuelve el índice de base cero de la primera aparición en el intervalo de elementos de la matriz <ph id="ph1">&lt;see cref="T:System.Collections.Generic.List`1" /&gt;</ph> que va desde el índice especificado hasta el último elemento.</target>       </trans-unit>
        <trans-unit id="517" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.List`1.FindIndex(System.Int32,System.Predicate{`0})">
          <source>The zero-based index of the first occurrence of an element that matches the conditions defined by <ph id="ph1">&lt;paramref name="match" /&gt;</ph>, if found; otherwise, –1.</source>
          <target state="translated">Índice de base cero de la primera aparición de un elemento que coincide con las condiciones definidas por <ph id="ph1">&lt;paramref name="match" /&gt;</ph>, si se encuentra; en caso contrario, -1.</target>       </trans-unit>
        <trans-unit id="518" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.FindIndex(System.Int32,System.Predicate{`0})">
          <source>The <ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph> is searched forward starting at <ph id="ph2">`startIndex`</ph> and ending at the last element.</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph> se busca hacia delante, empezando en <ph id="ph2">`startIndex`</ph> y terminando con el último elemento.</target>       </trans-unit>
        <trans-unit id="519" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.FindIndex(System.Int32,System.Predicate{`0})">
          <source>The <ph id="ph1">&lt;xref:System.Predicate%601&gt;</ph> is a delegate to a method that returns <ph id="ph2">`true`</ph> if the object passed to it matches the conditions defined in the delegate.</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.Predicate%601&gt;</ph> es un delegado a un método que devuelve <ph id="ph2">`true`</ph> si el objeto pasado a coincide con las condiciones definidas en el delegado.</target>       </trans-unit>
        <trans-unit id="520" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.FindIndex(System.Int32,System.Predicate{`0})">
          <source>The elements of the current <ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph> are individually passed to the <ph id="ph2">&lt;xref:System.Predicate%601&gt;</ph> delegate.</source>
          <target state="translated">Los elementos del elemento actual <ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph> se pasan individualmente a la <ph id="ph2">&lt;xref:System.Predicate%601&gt;</ph> delegar.</target>       </trans-unit>
        <trans-unit id="521" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.FindIndex(System.Int32,System.Predicate{`0})">
          <source>The delegate has the signature:</source>
          <target state="translated">El delegado tiene la firma:</target>       </trans-unit>
        <trans-unit id="522" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.FindIndex(System.Int32,System.Predicate{`0})">
          <source>This method performs a linear search; therefore, this method is an O(<bpt id="p1">*</bpt>n<ept id="p1">*</ept>) operation, where <bpt id="p2">*</bpt>n<ept id="p2">*</ept> is the number of elements from <ph id="ph1">`startIndex`</ph> to the end of the <ph id="ph2">&lt;xref:System.Collections.Generic.List%601&gt;</ph>.</source>
          <target state="translated">Este método realiza una búsqueda lineal; por lo tanto, este método es una O (<bpt id="p1">*</bpt>n<ept id="p1">*</ept>) operación, donde <bpt id="p2">*</bpt>n<ept id="p2">*</ept> es el número de elementos de <ph id="ph1">`startIndex`</ph> al final de la <ph id="ph2">&lt;xref:System.Collections.Generic.List%601&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="523" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.FindIndex(System.Int32,System.Predicate{`0})">
          <source>The following example defines an <ph id="ph1">`Employee`</ph> class with two fields, <ph id="ph2">`Name`</ph> and <ph id="ph3">`Id`</ph>.</source>
          <target state="translated">En el ejemplo siguiente se define un <ph id="ph1">`Employee`</ph> clase con dos campos, <ph id="ph2">`Name`</ph> y <ph id="ph3">`Id`</ph>.</target>       </trans-unit>
        <trans-unit id="524" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.FindIndex(System.Int32,System.Predicate{`0})">
          <source>It also defines an <ph id="ph1">`EmployeeSearch`</ph> class with a single method, <ph id="ph2">`StartsWith`</ph>, that indicates whether the <ph id="ph3">`Employee.Name`</ph> field starts with a specified substring that is supplied to the <ph id="ph4">`EmployeeSearch`</ph> class constructor.</source>
          <target state="translated">También define un <ph id="ph1">`EmployeeSearch`</ph> clase con un método único, <ph id="ph2">`StartsWith`</ph>, que indica si la <ph id="ph3">`Employee.Name`</ph> campo comienza con una subcadena especificada que se proporciona a los <ph id="ph4">`EmployeeSearch`</ph> constructor de clase.</target>       </trans-unit>
        <trans-unit id="525" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.FindIndex(System.Int32,System.Predicate{`0})">
          <source>Note  the signature of this method</source>
          <target state="translated">Tenga en cuenta la firma de este método</target>       </trans-unit>
        <trans-unit id="526" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.FindIndex(System.Int32,System.Predicate{`0})">
          <source>corresponds to the signature of the delegate that can be passed to the <ph id="ph1">&lt;xref:System.Collections.Generic.List%601.FindIndex%2A&gt;</ph> method.</source>
          <target state="translated">corresponde a la firma del delegado que puede pasarse a la <ph id="ph1">&lt;xref:System.Collections.Generic.List%601.FindIndex%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="527" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.FindIndex(System.Int32,System.Predicate{`0})">
          <source>The example instantiates a <ph id="ph1">`List&lt;Employee&gt;`</ph> object, adds a number of <ph id="ph2">`Employee`</ph> objets to it, and then calls the <ph id="ph3">&lt;xref:System.Collections.Generic.List%601.FindIndex%28System.Int32%2CSystem.Int32%2CSystem.Predicate%7B%600%7D%29&gt;</ph> method twice  to search the collection starting with its fifth member (that is, the member at index 4).</source>
          <target state="translated">El ejemplo crea un <ph id="ph1">`List&lt;Employee&gt;`</ph> de objetos, se agrega un número de <ph id="ph2">`Employee`</ph> objetos y, a continuación, llama el <ph id="ph3">&lt;xref:System.Collections.Generic.List%601.FindIndex%28System.Int32%2CSystem.Int32%2CSystem.Predicate%7B%600%7D%29&gt;</ph> método dos veces para buscar en la colección a partir de su miembro quinto (es decir, el miembro en el índice 4).</target>       </trans-unit>
        <trans-unit id="528" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.FindIndex(System.Int32,System.Predicate{`0})">
          <source>The first time, it searches for the first <ph id="ph1">`Employee`</ph> object whose <ph id="ph2">`Name`</ph> field begins with "J"; the second time, it searches for the first <ph id="ph3">`Employee`</ph> object whose <ph id="ph4">`Name`</ph> field begins with "Ju".</source>
          <target state="translated">La primera vez, busca la primera <ph id="ph1">`Employee`</ph> cuyos <ph id="ph2">`Name`</ph> campo comienza con "J"; la segunda vez, busca la primera <ph id="ph3">`Employee`</ph> cuyos <ph id="ph4">`Name`</ph> campo comienza con "Ju".</target>       </trans-unit>
        <trans-unit id="529" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.List`1.FindIndex(System.Int32,System.Predicate{`0})">
          <source><ph id="ph1">&lt;paramref name="match" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="match" /&gt;</ph> es <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="530" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.List`1.FindIndex(System.Int32,System.Predicate{`0})">
          <source><ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph> is outside the range of valid indexes for the <ph id="ph2">&lt;see cref="T:System.Collections.Generic.List`1" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph> está fuera del intervalo de índices válidos para <ph id="ph2">&lt;see cref="T:System.Collections.Generic.List`1" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="531" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.List`1.FindIndex(System.Int32,System.Int32,System.Predicate{`0})">
          <source>The zero-based starting index of the search.</source>
          <target state="translated">Índice inicial de base cero de la búsqueda.</target>       </trans-unit>
        <trans-unit id="532" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.List`1.FindIndex(System.Int32,System.Int32,System.Predicate{`0})">
          <source>The number of elements in the section to search.</source>
          <target state="translated">Número de elementos de la sección en la que se va a realizar la búsqueda.</target>       </trans-unit>
        <trans-unit id="533" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.List`1.FindIndex(System.Int32,System.Int32,System.Predicate{`0})">
          <source>The <ph id="ph1">&lt;see cref="T:System.Predicate`1" /&gt;</ph> delegate that defines the conditions of the element to search for.</source>
          <target state="translated">Delegado <ph id="ph1">&lt;see cref="T:System.Predicate`1" /&gt;</ph> que define las condiciones del elemento que se va a buscar.</target>       </trans-unit>
        <trans-unit id="534" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.List`1.FindIndex(System.Int32,System.Int32,System.Predicate{`0})">
          <source>Searches for an element that matches the conditions defined by the specified predicate, and returns the zero-based index of the first occurrence within the range of elements in the <ph id="ph1">&lt;see cref="T:System.Collections.Generic.List`1" /&gt;</ph> that starts at the specified index and contains the specified number of elements.</source>
          <target state="translated">Busca un elemento que coincida con las condiciones definidas por el predicado especificado y devuelve el índice de base cero de la primera aparición en el intervalo de elementos de la matriz <ph id="ph1">&lt;see cref="T:System.Collections.Generic.List`1" /&gt;</ph> que comienza en el índice especificado y contiene el número especificado de elementos.</target>       </trans-unit>
        <trans-unit id="535" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.List`1.FindIndex(System.Int32,System.Int32,System.Predicate{`0})">
          <source>The zero-based index of the first occurrence of an element that matches the conditions defined by <ph id="ph1">&lt;paramref name="match" /&gt;</ph>, if found; otherwise, –1.</source>
          <target state="translated">Índice de base cero de la primera aparición de un elemento que coincide con las condiciones definidas por <ph id="ph1">&lt;paramref name="match" /&gt;</ph>, si se encuentra; en caso contrario, -1.</target>       </trans-unit>
        <trans-unit id="536" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.FindIndex(System.Int32,System.Int32,System.Predicate{`0})">
          <source>The <ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph> is searched forward starting at <ph id="ph2">`startIndex`</ph> and ending at <ph id="ph3">`startIndex`</ph> plus <ph id="ph4">`count`</ph> minus 1, if <ph id="ph5">`count`</ph> is greater than 0.</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph> se busca hacia delante, empezando en <ph id="ph2">`startIndex`</ph> y terminando en <ph id="ph3">`startIndex`</ph> más <ph id="ph4">`count`</ph> menos 1, si <ph id="ph5">`count`</ph> es mayor que 0.</target>       </trans-unit>
        <trans-unit id="537" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.FindIndex(System.Int32,System.Int32,System.Predicate{`0})">
          <source>The <ph id="ph1">&lt;xref:System.Predicate%601&gt;</ph> is a delegate to a method that returns <ph id="ph2">`true`</ph> if the object passed to it matches the conditions defined in the delegate.</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.Predicate%601&gt;</ph> es un delegado a un método que devuelve <ph id="ph2">`true`</ph> si el objeto pasado a coincide con las condiciones definidas en el delegado.</target>       </trans-unit>
        <trans-unit id="538" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.FindIndex(System.Int32,System.Int32,System.Predicate{`0})">
          <source>The elements of the current <ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph> are individually passed to the <ph id="ph2">&lt;xref:System.Predicate%601&gt;</ph> delegate.</source>
          <target state="translated">Los elementos del elemento actual <ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph> se pasan individualmente a la <ph id="ph2">&lt;xref:System.Predicate%601&gt;</ph> delegar.</target>       </trans-unit>
        <trans-unit id="539" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.FindIndex(System.Int32,System.Int32,System.Predicate{`0})">
          <source>The delegate has the signature:</source>
          <target state="translated">El delegado tiene la firma:</target>       </trans-unit>
        <trans-unit id="540" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.FindIndex(System.Int32,System.Int32,System.Predicate{`0})">
          <source>This method performs a linear search; therefore, this method is an O(<bpt id="p1">*</bpt>n<ept id="p1">*</ept>) operation, where <bpt id="p2">*</bpt>n<ept id="p2">*</ept> is <ph id="ph1">`count`</ph>.</source>
          <target state="translated">Este método realiza una búsqueda lineal; por lo tanto, este método es una O (<bpt id="p1">*</bpt>n<ept id="p1">*</ept>) operación, donde <bpt id="p2">*</bpt>n<ept id="p2">*</ept> es <ph id="ph1">`count`</ph>.</target>       </trans-unit>
        <trans-unit id="541" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.FindIndex(System.Int32,System.Int32,System.Predicate{`0})">
          <source>The following example defines an <ph id="ph1">`Employee`</ph> class with two fields, <ph id="ph2">`Name`</ph> and <ph id="ph3">`Id`</ph>.</source>
          <target state="translated">En el ejemplo siguiente se define un <ph id="ph1">`Employee`</ph> clase con dos campos, <ph id="ph2">`Name`</ph> y <ph id="ph3">`Id`</ph>.</target>       </trans-unit>
        <trans-unit id="542" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.FindIndex(System.Int32,System.Int32,System.Predicate{`0})">
          <source>It also defines an <ph id="ph1">`EmployeeSearch`</ph> class with a single method, <ph id="ph2">`StartsWith`</ph>, that indicates whether the <ph id="ph3">`Employee.Name`</ph> field starts with a specified substring that is supplied to the <ph id="ph4">`EmployeeSearch`</ph> class constructor.</source>
          <target state="translated">También define un <ph id="ph1">`EmployeeSearch`</ph> clase con un método único, <ph id="ph2">`StartsWith`</ph>, que indica si la <ph id="ph3">`Employee.Name`</ph> campo comienza con una subcadena especificada que se proporciona a los <ph id="ph4">`EmployeeSearch`</ph> constructor de clase.</target>       </trans-unit>
        <trans-unit id="543" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.FindIndex(System.Int32,System.Int32,System.Predicate{`0})">
          <source>Note  the signature of this method</source>
          <target state="translated">Tenga en cuenta la firma de este método</target>       </trans-unit>
        <trans-unit id="544" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.FindIndex(System.Int32,System.Int32,System.Predicate{`0})">
          <source>corresponds to the signature of the delegate that can be passed to the <ph id="ph1">&lt;xref:System.Collections.Generic.List%601.FindIndex%2A&gt;</ph> method.</source>
          <target state="translated">corresponde a la firma del delegado que puede pasarse a la <ph id="ph1">&lt;xref:System.Collections.Generic.List%601.FindIndex%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="545" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.FindIndex(System.Int32,System.Int32,System.Predicate{`0})">
          <source>The example instantiates a <ph id="ph1">`List&lt;Employee&gt;`</ph> object, adds a number of <ph id="ph2">`Employee`</ph> objets to it, and then calls the <ph id="ph3">&lt;xref:System.Collections.Generic.List%601.FindIndex%28System.Int32%2CSystem.Int32%2CSystem.Predicate%7B%600%7D%29&gt;</ph> method twice  to search the entire collection (that is, the members from index 0 to index <ph id="ph4">&lt;xref:System.Collections.Generic.List%601.Count%2A&gt;</ph> - 1).</source>
          <target state="translated">El ejemplo crea un <ph id="ph1">`List&lt;Employee&gt;`</ph> de objetos, se agrega un número de <ph id="ph2">`Employee`</ph> objetos y, a continuación, llama el <ph id="ph3">&lt;xref:System.Collections.Generic.List%601.FindIndex%28System.Int32%2CSystem.Int32%2CSystem.Predicate%7B%600%7D%29&gt;</ph> método dos veces para buscar la colección completa (es decir, los miembros desde el índice 0 al índice <ph id="ph4">&lt;xref:System.Collections.Generic.List%601.Count%2A&gt;</ph> - 1).</target>       </trans-unit>
        <trans-unit id="546" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.FindIndex(System.Int32,System.Int32,System.Predicate{`0})">
          <source>The first time, it searches for the first <ph id="ph1">`Employee`</ph> object whose <ph id="ph2">`Name`</ph> field begins with "J"; the second time, it searches for the first <ph id="ph3">`Employee`</ph> object whose <ph id="ph4">`Name`</ph> field begins with "Ju".</source>
          <target state="translated">La primera vez, busca la primera <ph id="ph1">`Employee`</ph> cuyos <ph id="ph2">`Name`</ph> campo comienza con "J"; la segunda vez, busca la primera <ph id="ph3">`Employee`</ph> cuyos <ph id="ph4">`Name`</ph> campo comienza con "Ju".</target>       </trans-unit>
        <trans-unit id="547" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.List`1.FindIndex(System.Int32,System.Int32,System.Predicate{`0})">
          <source><ph id="ph1">&lt;paramref name="match" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="match" /&gt;</ph> es <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="548" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.List`1.FindIndex(System.Int32,System.Int32,System.Predicate{`0})">
          <source><ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph> is outside the range of valid indexes for the <ph id="ph2">&lt;see cref="T:System.Collections.Generic.List`1" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph> está fuera del intervalo de índices válidos para <ph id="ph2">&lt;see cref="T:System.Collections.Generic.List`1" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="549" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.List`1.FindIndex(System.Int32,System.Int32,System.Predicate{`0})">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="550" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.List`1.FindIndex(System.Int32,System.Int32,System.Predicate{`0})">
          <source><ph id="ph1">&lt;paramref name="count" /&gt;</ph> is less than 0.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="count" /&gt;</ph> es menor que 0.</target>       </trans-unit>
        <trans-unit id="551" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.List`1.FindIndex(System.Int32,System.Int32,System.Predicate{`0})">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="552" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.List`1.FindIndex(System.Int32,System.Int32,System.Predicate{`0})">
          <source><ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph> and <ph id="ph2">&lt;paramref name="count" /&gt;</ph> do not specify a valid section in the <ph id="ph3">&lt;see cref="T:System.Collections.Generic.List`1" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph> y <ph id="ph2">&lt;paramref name="count" /&gt;</ph> no especifican una sección válida en <ph id="ph3">&lt;see cref="T:System.Collections.Generic.List`1" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="553" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.List`1.FindLast(System.Predicate{`0})">
          <source>The <ph id="ph1">&lt;see cref="T:System.Predicate`1" /&gt;</ph> delegate that defines the conditions of the element to search for.</source>
          <target state="translated">Delegado <ph id="ph1">&lt;see cref="T:System.Predicate`1" /&gt;</ph> que define las condiciones del elemento que se va a buscar.</target>       </trans-unit>
        <trans-unit id="554" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.List`1.FindLast(System.Predicate{`0})">
          <source>Searches for an element that matches the conditions defined by the specified predicate, and returns the last occurrence within the entire <ph id="ph1">&lt;see cref="T:System.Collections.Generic.List`1" /&gt;</ph>.</source>
          <target state="translated">Busca un elemento que coincida con las condiciones definidas por el predicado especificado y devuelve la última aparición en toda la matriz <ph id="ph1">&lt;see cref="T:System.Collections.Generic.List`1" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="555" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.List`1.FindLast(System.Predicate{`0})">
          <source>The last element that matches the conditions defined by the specified predicate, if found; otherwise, the default value for type <ph id="ph1">&lt;paramref name="T" /&gt;</ph>.</source>
          <target state="translated">Último elemento que coincide con las condiciones definidas por el predicado especificado, si se encuentra; de lo contrario, valor predeterminado para el tipo <ph id="ph1">&lt;paramref name="T" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="556" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.FindLast(System.Predicate{`0})">
          <source>The <ph id="ph1">&lt;xref:System.Predicate%601&gt;</ph> is a delegate to a method that returns <ph id="ph2">`true`</ph> if the object passed to it matches the conditions defined in the delegate.</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.Predicate%601&gt;</ph> es un delegado a un método que devuelve <ph id="ph2">`true`</ph> si el objeto pasado a coincide con las condiciones definidas en el delegado.</target>       </trans-unit>
        <trans-unit id="557" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.FindLast(System.Predicate{`0})">
          <source>The elements of the current <ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph> are individually passed to the <ph id="ph2">&lt;xref:System.Predicate%601&gt;</ph> delegate, moving backward in the <ph id="ph3">&lt;xref:System.Collections.Generic.List%601&gt;</ph>, starting with the last element and ending with the first element.</source>
          <target state="translated">Los elementos del elemento actual <ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph> se pasan individualmente a la <ph id="ph2">&lt;xref:System.Predicate%601&gt;</ph> delegado, mover hacia atrás el <ph id="ph3">&lt;xref:System.Collections.Generic.List%601&gt;</ph>, empezando por el último elemento y terminando por el primer elemento.</target>       </trans-unit>
        <trans-unit id="558" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.FindLast(System.Predicate{`0})">
          <source>Processing is stopped when a match is found.</source>
          <target state="translated">Cuando se encuentra una coincidencia, se detiene el procesamiento.</target>       </trans-unit>
        <trans-unit id="559" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.FindLast(System.Predicate{`0})">
          <source>When searching a list containing value types, make sure the default value for the type does not satisfy the search predicate.</source>
          <target state="translated">Al buscar una lista que contiene los tipos de valor, asegúrese de que el valor predeterminado para el tipo no cumple el predicado de búsqueda.</target>       </trans-unit>
        <trans-unit id="560" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.FindLast(System.Predicate{`0})">
          <source>Otherwise, there is no way to distinguish between a default value indicating that no match was found and a list element that happens to have the default value for the type.</source>
          <target state="translated">En caso contrario, no hay ninguna manera de distinguir entre un elemento de lista que posee el valor predeterminado para el tipo y un valor predeterminado que indica que se encontró ninguna coincidencia.</target>       </trans-unit>
        <trans-unit id="561" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.FindLast(System.Predicate{`0})">
          <source>If the default value satisfies the search predicate, use the <ph id="ph1">&lt;xref:System.Collections.Generic.List%601.FindLastIndex%2A&gt;</ph> method instead.</source>
          <target state="translated">Si el valor predeterminado satisface el predicado de búsqueda, utilice la <ph id="ph1">&lt;xref:System.Collections.Generic.List%601.FindLastIndex%2A&gt;</ph> método en su lugar.</target>       </trans-unit>
        <trans-unit id="562" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.FindLast(System.Predicate{`0})">
          <source>This method performs a linear search; therefore, this method is an O(<bpt id="p1">*</bpt>n<ept id="p1">*</ept>) operation, where <bpt id="p2">*</bpt>n<ept id="p2">*</ept> is <ph id="ph1">&lt;xref:System.Collections.Generic.List%601.Count%2A&gt;</ph>.</source>
          <target state="translated">Este método realiza una búsqueda lineal; por lo tanto, este método es una O (<bpt id="p1">*</bpt>n<ept id="p1">*</ept>) operación, donde <bpt id="p2">*</bpt>n<ept id="p2">*</ept> es <ph id="ph1">&lt;xref:System.Collections.Generic.List%601.Count%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="563" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.FindLast(System.Predicate{`0})">
          <source>The following example demonstrates the find methods for the <ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph> class.</source>
          <target state="translated">El ejemplo siguiente muestra los métodos de búsqueda para la <ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph> clase.</target>       </trans-unit>
        <trans-unit id="564" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.FindLast(System.Predicate{`0})">
          <source>The example for the <ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph> class contains <ph id="ph2">`book`</ph> objects, of class <ph id="ph3">`Book`</ph>, using the data from the <bpt id="p1">[</bpt>Sample XML File: Books (LINQ to XML)<ept id="p1">](http://msdn.microsoft.com/library/94252daf-6097-4625-afc2-0eb778958d4f)</ept>.</source>
          <target state="translated">El ejemplo de la <ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph> clase contiene <ph id="ph2">`book`</ph> objetos de clase <ph id="ph3">`Book`</ph>, con los datos de la <bpt id="p1">[</bpt>archivo XML de ejemplo: libros (LINQ to XML)<ept id="p1">](http://msdn.microsoft.com/library/94252daf-6097-4625-afc2-0eb778958d4f)</ept>.</target>       </trans-unit>
        <trans-unit id="565" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.FindLast(System.Predicate{`0})">
          <source>The <ph id="ph1">`FillList`</ph> method in the example uses <bpt id="p1">[</bpt>LINQ to XML<ept id="p1">](http://msdn.microsoft.com/library/f0fe21e9-ee43-4a55-b91a-0800e5782c13)</ept> to parse the values from the XML to property values of the <ph id="ph2">`book`</ph> objects.</source>
          <target state="translated">El <ph id="ph1">`FillList`</ph> método en el ejemplo usa <bpt id="p1">[</bpt>LINQ to XML<ept id="p1">](http://msdn.microsoft.com/library/f0fe21e9-ee43-4a55-b91a-0800e5782c13)</ept> para analizar los valores del archivo XML para los valores de propiedad de la <ph id="ph2">`book`</ph> objetos.</target>       </trans-unit>
        <trans-unit id="566" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.FindLast(System.Predicate{`0})">
          <source>The following table describes the examples provided for the find methods.</source>
          <target state="translated">En la tabla siguiente describe los ejemplos de los métodos de búsqueda.</target>       </trans-unit>
        <trans-unit id="567" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.FindLast(System.Predicate{`0})">
          <source>Method</source>
          <target state="translated">Método</target>       </trans-unit>
        <trans-unit id="568" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.FindLast(System.Predicate{`0})">
          <source>Example</source>
          <target state="translated">Ejemplo</target>       </trans-unit>
        <trans-unit id="569" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.FindLast(System.Predicate{`0})">
          <source>Finds a book by an ID using the <ph id="ph1">`IDToFind`</ph> predicate delegate.</source>
          <target state="translated">Encuentra un libro por un identificador utilizando el <ph id="ph1">`IDToFind`</ph> delegado de predicado.</target>       </trans-unit>
        <trans-unit id="570" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.FindLast(System.Predicate{`0})">
          <source>C# example uses an anonymous delegate.</source>
          <target state="translated">Ejemplo de C# usa a un delegado anónimo.</target>       </trans-unit>
        <trans-unit id="571" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.FindLast(System.Predicate{`0})">
          <source>Find all books that whose <ph id="ph1">`Genre`</ph> property is "Computer" using the <ph id="ph2">`FindComputer`</ph> predicate delegate.</source>
          <target state="translated">Buscar todos los libros que cuya <ph id="ph1">`Genre`</ph> propiedad es "Equipo" con el <ph id="ph2">`FindComputer`</ph> delegado de predicado.</target>       </trans-unit>
        <trans-unit id="572" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.FindLast(System.Predicate{`0})">
          <source>Finds the last book in the collection that has a publish date before 2001, using the <ph id="ph1">`PubBefore2001`</ph> predicate delegate.</source>
          <target state="translated">Busca el último libro en la colección que tiene una fecha de publicación anterior a 2001, utilizando el <ph id="ph1">`PubBefore2001`</ph> delegado de predicado.</target>       </trans-unit>
        <trans-unit id="573" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.FindLast(System.Predicate{`0})">
          <source>C# example uses an anonymous delegate.</source>
          <target state="translated">Ejemplo de C# usa a un delegado anónimo.</target>       </trans-unit>
        <trans-unit id="574" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.FindLast(System.Predicate{`0})">
          <source>Finds the index of first computer book using the <ph id="ph1">`FindComputer`</ph> predicate delegate.</source>
          <target state="translated">Busca el índice del primer equipo libro utilizando la <ph id="ph1">`FindComputer`</ph> delegado de predicado.</target>       </trans-unit>
        <trans-unit id="575" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.FindLast(System.Predicate{`0})">
          <source>Finds the index of the last computer book using the <ph id="ph1">`FindComputer`</ph> predicate delegate.</source>
          <target state="translated">Busca el índice del último libro equipo utilizando el <ph id="ph1">`FindComputer`</ph> delegado de predicado.</target>       </trans-unit>
        <trans-unit id="576" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.FindLast(System.Predicate{`0})">
          <source>Finds the index of first computer book in the second half of the collection, using the <ph id="ph1">`FindComputer`</ph> predicate delegate.</source>
          <target state="translated">Busca el índice del primer libro informático en la segunda mitad de la colección, usando el <ph id="ph1">`FindComputer`</ph> delegado de predicado.</target>       </trans-unit>
        <trans-unit id="577" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.FindLast(System.Predicate{`0})">
          <source>Finds the index of last computer book in the second half of the collection, using the <ph id="ph1">`FindComputer`</ph> predicate delegate.</source>
          <target state="translated">Busca el índice del último libro informático en la segunda mitad de la colección, usando el <ph id="ph1">`FindComputer`</ph> delegado de predicado.</target>       </trans-unit>
        <trans-unit id="578" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.List`1.FindLast(System.Predicate{`0})">
          <source><ph id="ph1">&lt;paramref name="match" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="match" /&gt;</ph> es <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="579" translate="yes" xml:space="preserve" uid="T:System.Collections.Generic.List`1">
          <source>Searches for an element that matches the conditions defined by a specified predicate, and returns the zero-based index of the last occurrence within the <ph id="ph1">&lt;see cref="T:System.Collections.Generic.List`1" /&gt;</ph> or a portion of it.</source>
          <target state="translated">Busca un elemento que cumpla las condiciones definidas por el predicado especificado y devuelve el índice de base cero de la última aparición en <ph id="ph1">&lt;see cref="T:System.Collections.Generic.List`1" /&gt;</ph> o en una parte.</target>       </trans-unit>
        <trans-unit id="580" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.List`1.FindLastIndex(System.Predicate{`0})">
          <source>The <ph id="ph1">&lt;see cref="T:System.Predicate`1" /&gt;</ph> delegate that defines the conditions of the element to search for.</source>
          <target state="translated">Delegado <ph id="ph1">&lt;see cref="T:System.Predicate`1" /&gt;</ph> que define las condiciones del elemento que se va a buscar.</target>       </trans-unit>
        <trans-unit id="581" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.List`1.FindLastIndex(System.Predicate{`0})">
          <source>Searches for an element that matches the conditions defined by the specified predicate, and returns the zero-based index of the last occurrence within the entire <ph id="ph1">&lt;see cref="T:System.Collections.Generic.List`1" /&gt;</ph>.</source>
          <target state="translated">Busca un elemento que coincida con las condiciones definidas por el predicado especificado y devuelve el índice de base cero de la última aparición en toda la matriz <ph id="ph1">&lt;see cref="T:System.Collections.Generic.List`1" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="582" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.List`1.FindLastIndex(System.Predicate{`0})">
          <source>The zero-based index of the last occurrence of an element that matches the conditions defined by <ph id="ph1">&lt;paramref name="match" /&gt;</ph>, if found; otherwise, –1.</source>
          <target state="translated">Índice de base cero de la última aparición de un elemento que coincide con las condiciones definidas por <ph id="ph1">&lt;paramref name="match" /&gt;</ph>, si se encuentra; en caso contrario, -1.</target>       </trans-unit>
        <trans-unit id="583" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.FindLastIndex(System.Predicate{`0})">
          <source>The <ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph> is searched backward starting at the last element and ending at the first element.</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph> se realiza hacia atrás, empezando en el último elemento y terminando en el primer elemento.</target>       </trans-unit>
        <trans-unit id="584" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.FindLastIndex(System.Predicate{`0})">
          <source>The <ph id="ph1">&lt;xref:System.Predicate%601&gt;</ph> is a delegate to a method that returns <ph id="ph2">`true`</ph> if the object passed to it matches the conditions defined in the delegate.</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.Predicate%601&gt;</ph> es un delegado a un método que devuelve <ph id="ph2">`true`</ph> si el objeto pasado a coincide con las condiciones definidas en el delegado.</target>       </trans-unit>
        <trans-unit id="585" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.FindLastIndex(System.Predicate{`0})">
          <source>The elements of the current <ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph> are individually passed to the <ph id="ph2">&lt;xref:System.Predicate%601&gt;</ph> delegate.</source>
          <target state="translated">Los elementos del elemento actual <ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph> se pasan individualmente a la <ph id="ph2">&lt;xref:System.Predicate%601&gt;</ph> delegar.</target>       </trans-unit>
        <trans-unit id="586" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.FindLastIndex(System.Predicate{`0})">
          <source>This method performs a linear search; therefore, this method is an O(<bpt id="p1">*</bpt>n<ept id="p1">*</ept>) operation, where <bpt id="p2">*</bpt>n<ept id="p2">*</ept> is <ph id="ph1">&lt;xref:System.Collections.Generic.List%601.Count%2A&gt;</ph>.</source>
          <target state="translated">Este método realiza una búsqueda lineal; por lo tanto, este método es una O (<bpt id="p1">*</bpt>n<ept id="p1">*</ept>) operación, donde <bpt id="p2">*</bpt>n<ept id="p2">*</ept> es <ph id="ph1">&lt;xref:System.Collections.Generic.List%601.Count%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="587" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.FindLastIndex(System.Predicate{`0})">
          <source>The following example demonstrates the find methods for the <ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph> class.</source>
          <target state="translated">El ejemplo siguiente muestra los métodos de búsqueda para la <ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph> clase.</target>       </trans-unit>
        <trans-unit id="588" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.FindLastIndex(System.Predicate{`0})">
          <source>The example for the <ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph> class contains <ph id="ph2">`book`</ph> objects, of class <ph id="ph3">`Book`</ph>, using the data from the <bpt id="p1">[</bpt>Sample XML File: Books (LINQ to XML)<ept id="p1">](http://msdn.microsoft.com/library/94252daf-6097-4625-afc2-0eb778958d4f)</ept>.</source>
          <target state="translated">El ejemplo de la <ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph> clase contiene <ph id="ph2">`book`</ph> objetos de clase <ph id="ph3">`Book`</ph>, con los datos de la <bpt id="p1">[</bpt>archivo XML de ejemplo: libros (LINQ to XML)<ept id="p1">](http://msdn.microsoft.com/library/94252daf-6097-4625-afc2-0eb778958d4f)</ept>.</target>       </trans-unit>
        <trans-unit id="589" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.FindLastIndex(System.Predicate{`0})">
          <source>The <ph id="ph1">`FillList`</ph> method in the example uses <bpt id="p1">[</bpt>LINQ to XML<ept id="p1">](http://msdn.microsoft.com/library/f0fe21e9-ee43-4a55-b91a-0800e5782c13)</ept> to parse the values from the XML to property values of the <ph id="ph2">`book`</ph> objects.</source>
          <target state="translated">El <ph id="ph1">`FillList`</ph> método en el ejemplo usa <bpt id="p1">[</bpt>LINQ to XML<ept id="p1">](http://msdn.microsoft.com/library/f0fe21e9-ee43-4a55-b91a-0800e5782c13)</ept> para analizar los valores del archivo XML para los valores de propiedad de la <ph id="ph2">`book`</ph> objetos.</target>       </trans-unit>
        <trans-unit id="590" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.FindLastIndex(System.Predicate{`0})">
          <source>The following table describes the examples provided for the find methods.</source>
          <target state="translated">En la tabla siguiente describe los ejemplos de los métodos de búsqueda.</target>       </trans-unit>
        <trans-unit id="591" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.FindLastIndex(System.Predicate{`0})">
          <source>Method</source>
          <target state="translated">Método</target>       </trans-unit>
        <trans-unit id="592" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.FindLastIndex(System.Predicate{`0})">
          <source>Example</source>
          <target state="translated">Ejemplo</target>       </trans-unit>
        <trans-unit id="593" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.FindLastIndex(System.Predicate{`0})">
          <source>Finds a book by an ID using the <ph id="ph1">`IDToFind`</ph> predicate delegate.</source>
          <target state="translated">Encuentra un libro por un identificador utilizando el <ph id="ph1">`IDToFind`</ph> delegado de predicado.</target>       </trans-unit>
        <trans-unit id="594" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.FindLastIndex(System.Predicate{`0})">
          <source>C# example uses an anonymous delegate.</source>
          <target state="translated">Ejemplo de C# usa a un delegado anónimo.</target>       </trans-unit>
        <trans-unit id="595" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.FindLastIndex(System.Predicate{`0})">
          <source>Find all books that whose <ph id="ph1">`Genre`</ph> property is "Computer" using the <ph id="ph2">`FindComputer`</ph> predicate delegate.</source>
          <target state="translated">Buscar todos los libros que cuya <ph id="ph1">`Genre`</ph> propiedad es "Equipo" con el <ph id="ph2">`FindComputer`</ph> delegado de predicado.</target>       </trans-unit>
        <trans-unit id="596" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.FindLastIndex(System.Predicate{`0})">
          <source>Finds the last book in the collection that has a publish date before 2001, using the <ph id="ph1">`PubBefore2001`</ph> predicate delegate.</source>
          <target state="translated">Busca el último libro en la colección que tiene una fecha de publicación anterior a 2001, utilizando el <ph id="ph1">`PubBefore2001`</ph> delegado de predicado.</target>       </trans-unit>
        <trans-unit id="597" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.FindLastIndex(System.Predicate{`0})">
          <source>C# example uses an anonymous delegate.</source>
          <target state="translated">Ejemplo de C# usa a un delegado anónimo.</target>       </trans-unit>
        <trans-unit id="598" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.FindLastIndex(System.Predicate{`0})">
          <source>Finds the index of first computer book using the <ph id="ph1">`FindComputer`</ph> predicate delegate.</source>
          <target state="translated">Busca el índice del primer equipo libro utilizando la <ph id="ph1">`FindComputer`</ph> delegado de predicado.</target>       </trans-unit>
        <trans-unit id="599" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.FindLastIndex(System.Predicate{`0})">
          <source>Finds the index of the last computer book using the <ph id="ph1">`FindComputer`</ph> predicate delegate.</source>
          <target state="translated">Busca el índice del último libro equipo utilizando el <ph id="ph1">`FindComputer`</ph> delegado de predicado.</target>       </trans-unit>
        <trans-unit id="600" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.FindLastIndex(System.Predicate{`0})">
          <source>Finds the index of first computer book in the second half of the collection, using the <ph id="ph1">`FindComputer`</ph> predicate delegate.</source>
          <target state="translated">Busca el índice del primer libro informático en la segunda mitad de la colección, usando el <ph id="ph1">`FindComputer`</ph> delegado de predicado.</target>       </trans-unit>
        <trans-unit id="601" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.FindLastIndex(System.Predicate{`0})">
          <source>Finds the index of last computer book in the second half of the collection, using the <ph id="ph1">`FindComputer`</ph> predicate delegate.</source>
          <target state="translated">Busca el índice del último libro informático en la segunda mitad de la colección, usando el <ph id="ph1">`FindComputer`</ph> delegado de predicado.</target>       </trans-unit>
        <trans-unit id="602" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.List`1.FindLastIndex(System.Predicate{`0})">
          <source><ph id="ph1">&lt;paramref name="match" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="match" /&gt;</ph> es <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="603" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.List`1.FindLastIndex(System.Int32,System.Predicate{`0})">
          <source>The zero-based starting index of the backward search.</source>
          <target state="translated">Índice inicial de base cero de la búsqueda hacia atrás.</target>       </trans-unit>
        <trans-unit id="604" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.List`1.FindLastIndex(System.Int32,System.Predicate{`0})">
          <source>The <ph id="ph1">&lt;see cref="T:System.Predicate`1" /&gt;</ph> delegate that defines the conditions of the element to search for.</source>
          <target state="translated">Delegado <ph id="ph1">&lt;see cref="T:System.Predicate`1" /&gt;</ph> que define las condiciones del elemento que se va a buscar.</target>       </trans-unit>
        <trans-unit id="605" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.List`1.FindLastIndex(System.Int32,System.Predicate{`0})">
          <source>Searches for an element that matches the conditions defined by the specified predicate, and returns the zero-based index of the last occurrence within the range of elements in the <ph id="ph1">&lt;see cref="T:System.Collections.Generic.List`1" /&gt;</ph> that extends from the first element to the specified index.</source>
          <target state="translated">Busca un elemento que coincida con las condiciones definidas por el predicado especificado y devuelve el índice de base cero de la última aparición en el intervalo de elementos de la matriz <ph id="ph1">&lt;see cref="T:System.Collections.Generic.List`1" /&gt;</ph> que va desde el primer elemento hasta el índice especificado.</target>       </trans-unit>
        <trans-unit id="606" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.List`1.FindLastIndex(System.Int32,System.Predicate{`0})">
          <source>The zero-based index of the last occurrence of an element that matches the conditions defined by <ph id="ph1">&lt;paramref name="match" /&gt;</ph>, if found; otherwise, –1.</source>
          <target state="translated">Índice de base cero de la última aparición de un elemento que coincide con las condiciones definidas por <ph id="ph1">&lt;paramref name="match" /&gt;</ph>, si se encuentra; en caso contrario, -1.</target>       </trans-unit>
        <trans-unit id="607" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.FindLastIndex(System.Int32,System.Predicate{`0})">
          <source>The <ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph> is searched backward starting at <ph id="ph2">`startIndex`</ph> and ending at the first element.</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph> es la búsqueda hacia atrás, empezando en <ph id="ph2">`startIndex`</ph> y finaliza con el primer elemento.</target>       </trans-unit>
        <trans-unit id="608" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.FindLastIndex(System.Int32,System.Predicate{`0})">
          <source>The <ph id="ph1">&lt;xref:System.Predicate%601&gt;</ph> is a delegate to a method that returns <ph id="ph2">`true`</ph> if the object passed to it matches the conditions defined in the delegate.</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.Predicate%601&gt;</ph> es un delegado a un método que devuelve <ph id="ph2">`true`</ph> si el objeto pasado a coincide con las condiciones definidas en el delegado.</target>       </trans-unit>
        <trans-unit id="609" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.FindLastIndex(System.Int32,System.Predicate{`0})">
          <source>The elements of the current <ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph> are individually passed to the <ph id="ph2">&lt;xref:System.Predicate%601&gt;</ph> delegate.</source>
          <target state="translated">Los elementos del elemento actual <ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph> se pasan individualmente a la <ph id="ph2">&lt;xref:System.Predicate%601&gt;</ph> delegar.</target>       </trans-unit>
        <trans-unit id="610" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.FindLastIndex(System.Int32,System.Predicate{`0})">
          <source>This method performs a linear search; therefore, this method is an O(<bpt id="p1">*</bpt>n<ept id="p1">*</ept>) operation, where <bpt id="p2">*</bpt>n<ept id="p2">*</ept> is the number of elements from the beginning of the <ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph> to <ph id="ph2">`startIndex`</ph>.</source>
          <target state="translated">Este método realiza una búsqueda lineal; por lo tanto, este método es una O (<bpt id="p1">*</bpt>n<ept id="p1">*</ept>) operación, donde <bpt id="p2">*</bpt>n<ept id="p2">*</ept> es el número de elementos desde el principio de la <ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph> a <ph id="ph2">`startIndex`</ph>.</target>       </trans-unit>
        <trans-unit id="611" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.List`1.FindLastIndex(System.Int32,System.Predicate{`0})">
          <source><ph id="ph1">&lt;paramref name="match" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="match" /&gt;</ph> es <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="612" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.List`1.FindLastIndex(System.Int32,System.Predicate{`0})">
          <source><ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph> is outside the range of valid indexes for the <ph id="ph2">&lt;see cref="T:System.Collections.Generic.List`1" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph> está fuera del intervalo de índices válidos para <ph id="ph2">&lt;see cref="T:System.Collections.Generic.List`1" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="613" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.List`1.FindLastIndex(System.Int32,System.Int32,System.Predicate{`0})">
          <source>The zero-based starting index of the backward search.</source>
          <target state="translated">Índice inicial de base cero de la búsqueda hacia atrás.</target>       </trans-unit>
        <trans-unit id="614" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.List`1.FindLastIndex(System.Int32,System.Int32,System.Predicate{`0})">
          <source>The number of elements in the section to search.</source>
          <target state="translated">Número de elementos de la sección en la que se va a realizar la búsqueda.</target>       </trans-unit>
        <trans-unit id="615" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.List`1.FindLastIndex(System.Int32,System.Int32,System.Predicate{`0})">
          <source>The <ph id="ph1">&lt;see cref="T:System.Predicate`1" /&gt;</ph> delegate that defines the conditions of the element to search for.</source>
          <target state="translated">Delegado <ph id="ph1">&lt;see cref="T:System.Predicate`1" /&gt;</ph> que define las condiciones del elemento que se va a buscar.</target>       </trans-unit>
        <trans-unit id="616" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.List`1.FindLastIndex(System.Int32,System.Int32,System.Predicate{`0})">
          <source>Searches for an element that matches the conditions defined by the specified predicate, and returns the zero-based index of the last occurrence within the range of elements in the <ph id="ph1">&lt;see cref="T:System.Collections.Generic.List`1" /&gt;</ph> that contains the specified number of elements and ends at the specified index.</source>
          <target state="translated">Busca un elemento que coincida con las condiciones definidas por el predicado especificado y devuelve el índice de base cero de la última aparición en el intervalo de elementos de la matriz <ph id="ph1">&lt;see cref="T:System.Collections.Generic.List`1" /&gt;</ph> que contiene el número especificado de elementos y termina en el índice especificado.</target>       </trans-unit>
        <trans-unit id="617" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.List`1.FindLastIndex(System.Int32,System.Int32,System.Predicate{`0})">
          <source>The zero-based index of the last occurrence of an element that matches the conditions defined by <ph id="ph1">&lt;paramref name="match" /&gt;</ph>, if found; otherwise, –1.</source>
          <target state="translated">Índice de base cero de la última aparición de un elemento que coincide con las condiciones definidas por <ph id="ph1">&lt;paramref name="match" /&gt;</ph>, si se encuentra; en caso contrario, -1.</target>       </trans-unit>
        <trans-unit id="618" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.FindLastIndex(System.Int32,System.Int32,System.Predicate{`0})">
          <source>The <ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph> is searched backward starting at <ph id="ph2">`startIndex`</ph> and ending at <ph id="ph3">`startIndex`</ph> minus <ph id="ph4">`count`</ph> plus 1, if <ph id="ph5">`count`</ph> is greater than 0.</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph> es la búsqueda hacia atrás, empezando en <ph id="ph2">`startIndex`</ph> y terminando en <ph id="ph3">`startIndex`</ph> menos <ph id="ph4">`count`</ph> más 1, si <ph id="ph5">`count`</ph> es mayor que 0.</target>       </trans-unit>
        <trans-unit id="619" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.FindLastIndex(System.Int32,System.Int32,System.Predicate{`0})">
          <source>The <ph id="ph1">&lt;xref:System.Predicate%601&gt;</ph> is a delegate to a method that returns <ph id="ph2">`true`</ph> if the object passed to it matches the conditions defined in the delegate.</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.Predicate%601&gt;</ph> es un delegado a un método que devuelve <ph id="ph2">`true`</ph> si el objeto pasado a coincide con las condiciones definidas en el delegado.</target>       </trans-unit>
        <trans-unit id="620" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.FindLastIndex(System.Int32,System.Int32,System.Predicate{`0})">
          <source>The elements of the current <ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph> are individually passed to the <ph id="ph2">&lt;xref:System.Predicate%601&gt;</ph> delegate.</source>
          <target state="translated">Los elementos del elemento actual <ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph> se pasan individualmente a la <ph id="ph2">&lt;xref:System.Predicate%601&gt;</ph> delegar.</target>       </trans-unit>
        <trans-unit id="621" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.FindLastIndex(System.Int32,System.Int32,System.Predicate{`0})">
          <source>This method performs a linear search; therefore, this method is an O(<bpt id="p1">*</bpt>n<ept id="p1">*</ept>) operation, where <bpt id="p2">*</bpt>n<ept id="p2">*</ept> is <ph id="ph1">`count`</ph>.</source>
          <target state="translated">Este método realiza una búsqueda lineal; por lo tanto, este método es una O (<bpt id="p1">*</bpt>n<ept id="p1">*</ept>) operación, donde <bpt id="p2">*</bpt>n<ept id="p2">*</ept> es <ph id="ph1">`count`</ph>.</target>       </trans-unit>
        <trans-unit id="622" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.FindLastIndex(System.Int32,System.Int32,System.Predicate{`0})">
          <source>The following example demonstrates the find methods for the <ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph> class.</source>
          <target state="translated">El ejemplo siguiente muestra los métodos de búsqueda para la <ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph> clase.</target>       </trans-unit>
        <trans-unit id="623" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.FindLastIndex(System.Int32,System.Int32,System.Predicate{`0})">
          <source>The example for the <ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph> class contains <ph id="ph2">`book`</ph> objects, of class <ph id="ph3">`Book`</ph>, using the data from the <bpt id="p1">[</bpt>Sample XML File: Books (LINQ to XML)<ept id="p1">](http://msdn.microsoft.com/library/94252daf-6097-4625-afc2-0eb778958d4f)</ept>.</source>
          <target state="translated">El ejemplo de la <ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph> clase contiene <ph id="ph2">`book`</ph> objetos de clase <ph id="ph3">`Book`</ph>, con los datos de la <bpt id="p1">[</bpt>archivo XML de ejemplo: libros (LINQ to XML)<ept id="p1">](http://msdn.microsoft.com/library/94252daf-6097-4625-afc2-0eb778958d4f)</ept>.</target>       </trans-unit>
        <trans-unit id="624" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.FindLastIndex(System.Int32,System.Int32,System.Predicate{`0})">
          <source>The <ph id="ph1">`FillList`</ph> method in the example uses <bpt id="p1">[</bpt>LINQ to XML<ept id="p1">](http://msdn.microsoft.com/library/f0fe21e9-ee43-4a55-b91a-0800e5782c13)</ept> to parse the values from the XML to property values of the <ph id="ph2">`book`</ph> objects.</source>
          <target state="translated">El <ph id="ph1">`FillList`</ph> método en el ejemplo usa <bpt id="p1">[</bpt>LINQ to XML<ept id="p1">](http://msdn.microsoft.com/library/f0fe21e9-ee43-4a55-b91a-0800e5782c13)</ept> para analizar los valores del archivo XML para los valores de propiedad de la <ph id="ph2">`book`</ph> objetos.</target>       </trans-unit>
        <trans-unit id="625" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.FindLastIndex(System.Int32,System.Int32,System.Predicate{`0})">
          <source>The following table describes the examples provided for the find methods.</source>
          <target state="translated">En la tabla siguiente describe los ejemplos de los métodos de búsqueda.</target>       </trans-unit>
        <trans-unit id="626" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.FindLastIndex(System.Int32,System.Int32,System.Predicate{`0})">
          <source>Method</source>
          <target state="translated">Método</target>       </trans-unit>
        <trans-unit id="627" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.FindLastIndex(System.Int32,System.Int32,System.Predicate{`0})">
          <source>Example</source>
          <target state="translated">Ejemplo</target>       </trans-unit>
        <trans-unit id="628" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.FindLastIndex(System.Int32,System.Int32,System.Predicate{`0})">
          <source>Finds a book by an ID using the <ph id="ph1">`IDToFind`</ph> predicate delegate.</source>
          <target state="translated">Encuentra un libro por un identificador utilizando el <ph id="ph1">`IDToFind`</ph> delegado de predicado.</target>       </trans-unit>
        <trans-unit id="629" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.FindLastIndex(System.Int32,System.Int32,System.Predicate{`0})">
          <source>C# example uses an anonymous delegate.</source>
          <target state="translated">Ejemplo de C# usa a un delegado anónimo.</target>       </trans-unit>
        <trans-unit id="630" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.FindLastIndex(System.Int32,System.Int32,System.Predicate{`0})">
          <source>Find all books that whose <ph id="ph1">`Genre`</ph> property is "Computer" using the <ph id="ph2">`FindComputer`</ph> predicate delegate.</source>
          <target state="translated">Buscar todos los libros que cuya <ph id="ph1">`Genre`</ph> propiedad es "Equipo" con el <ph id="ph2">`FindComputer`</ph> delegado de predicado.</target>       </trans-unit>
        <trans-unit id="631" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.FindLastIndex(System.Int32,System.Int32,System.Predicate{`0})">
          <source>Finds the last book in the collection that has a publish date before 2001, using the <ph id="ph1">`PubBefore2001`</ph> predicate delegate.</source>
          <target state="translated">Busca el último libro en la colección que tiene una fecha de publicación anterior a 2001, utilizando el <ph id="ph1">`PubBefore2001`</ph> delegado de predicado.</target>       </trans-unit>
        <trans-unit id="632" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.FindLastIndex(System.Int32,System.Int32,System.Predicate{`0})">
          <source>C# example uses an anonymous delegate.</source>
          <target state="translated">Ejemplo de C# usa a un delegado anónimo.</target>       </trans-unit>
        <trans-unit id="633" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.FindLastIndex(System.Int32,System.Int32,System.Predicate{`0})">
          <source>Finds the index of first computer book using the <ph id="ph1">`FindComputer`</ph> predicate delegate.</source>
          <target state="translated">Busca el índice del primer equipo libro utilizando la <ph id="ph1">`FindComputer`</ph> delegado de predicado.</target>       </trans-unit>
        <trans-unit id="634" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.FindLastIndex(System.Int32,System.Int32,System.Predicate{`0})">
          <source>Finds the index of the last computer book using the <ph id="ph1">`FindComputer`</ph> predicate delegate.</source>
          <target state="translated">Busca el índice del último libro equipo utilizando el <ph id="ph1">`FindComputer`</ph> delegado de predicado.</target>       </trans-unit>
        <trans-unit id="635" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.FindLastIndex(System.Int32,System.Int32,System.Predicate{`0})">
          <source>Finds the index of first computer book in the second half of the collection, using the <ph id="ph1">`FindComputer`</ph> predicate delegate.</source>
          <target state="translated">Busca el índice del primer libro informático en la segunda mitad de la colección, usando el <ph id="ph1">`FindComputer`</ph> delegado de predicado.</target>       </trans-unit>
        <trans-unit id="636" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.FindLastIndex(System.Int32,System.Int32,System.Predicate{`0})">
          <source>Finds the index of last computer book in the second half of the collection, using the <ph id="ph1">`FindComputer`</ph> predicate delegate.</source>
          <target state="translated">Busca el índice del último libro informático en la segunda mitad de la colección, usando el <ph id="ph1">`FindComputer`</ph> delegado de predicado.</target>       </trans-unit>
        <trans-unit id="637" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.List`1.FindLastIndex(System.Int32,System.Int32,System.Predicate{`0})">
          <source><ph id="ph1">&lt;paramref name="match" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="match" /&gt;</ph> es <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="638" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.List`1.FindLastIndex(System.Int32,System.Int32,System.Predicate{`0})">
          <source><ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph> is outside the range of valid indexes for the <ph id="ph2">&lt;see cref="T:System.Collections.Generic.List`1" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph> está fuera del intervalo de índices válidos para <ph id="ph2">&lt;see cref="T:System.Collections.Generic.List`1" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="639" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.List`1.FindLastIndex(System.Int32,System.Int32,System.Predicate{`0})">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="640" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.List`1.FindLastIndex(System.Int32,System.Int32,System.Predicate{`0})">
          <source><ph id="ph1">&lt;paramref name="count" /&gt;</ph> is less than 0.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="count" /&gt;</ph> es menor que 0.</target>       </trans-unit>
        <trans-unit id="641" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.List`1.FindLastIndex(System.Int32,System.Int32,System.Predicate{`0})">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="642" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.List`1.FindLastIndex(System.Int32,System.Int32,System.Predicate{`0})">
          <source><ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph> and <ph id="ph2">&lt;paramref name="count" /&gt;</ph> do not specify a valid section in the <ph id="ph3">&lt;see cref="T:System.Collections.Generic.List`1" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph> y <ph id="ph2">&lt;paramref name="count" /&gt;</ph> no especifican una sección válida en <ph id="ph3">&lt;see cref="T:System.Collections.Generic.List`1" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="643" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.List`1.ForEach(System.Action{`0})">
          <source>The <ph id="ph1">&lt;see cref="T:System.Action`1" /&gt;</ph> delegate to perform on each element of the <ph id="ph2">&lt;see cref="T:System.Collections.Generic.List`1" /&gt;</ph>.</source>
          <target state="translated">Delegado <ph id="ph1">&lt;see cref="T:System.Action`1" /&gt;</ph> para realizar la acción en cada elemento de <ph id="ph2">&lt;see cref="T:System.Collections.Generic.List`1" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="644" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.List`1.ForEach(System.Action{`0})">
          <source>Performs the specified action on each element of the <ph id="ph1">&lt;see cref="T:System.Collections.Generic.List`1" /&gt;</ph>.</source>
          <target state="translated">Realiza la acción especificada en cada elemento de <ph id="ph1">&lt;see cref="T:System.Collections.Generic.List`1" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="645" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.ForEach(System.Action{`0})">
          <source>The <ph id="ph1">&lt;xref:System.Action%601&gt;</ph> is a delegate to a method that performs an action on the object passed to it.</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.Action%601&gt;</ph> se pasa un delegado a un método que realiza una acción en el objeto.</target>       </trans-unit>
        <trans-unit id="646" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.ForEach(System.Action{`0})">
          <source>The elements of the current <ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph> are individually passed to the <ph id="ph2">&lt;xref:System.Action%601&gt;</ph> delegate.</source>
          <target state="translated">Los elementos del elemento actual <ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph> se pasan individualmente a la <ph id="ph2">&lt;xref:System.Action%601&gt;</ph> delegar.</target>       </trans-unit>
        <trans-unit id="647" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.ForEach(System.Action{`0})">
          <source>This method is an O(<bpt id="p1">*</bpt>n<ept id="p1">*</ept>) operation, where <bpt id="p2">*</bpt>n<ept id="p2">*</ept> is <ph id="ph1">&lt;xref:System.Collections.Generic.List%601.Count%2A&gt;</ph>.</source>
          <target state="translated">Este método es una O (<bpt id="p1">*</bpt>n<ept id="p1">*</ept>) operación, donde <bpt id="p2">*</bpt>n<ept id="p2">*</ept> es <ph id="ph1">&lt;xref:System.Collections.Generic.List%601.Count%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="648" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.ForEach(System.Action{`0})">
          <source>Modifying the underlying collection in the body of the <ph id="ph1">&lt;xref:System.Action%601&gt;</ph> delegate is not supported and causes undefined behavior.</source>
          <target state="translated">Modificar la colección subyacente en el cuerpo de la <ph id="ph1">&lt;xref:System.Action%601&gt;</ph> delegado no se admite y provoca un comportamiento indefinido.</target>       </trans-unit>
        <trans-unit id="649" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.ForEach(System.Action{`0})">
          <source>The following example demonstrates the use of the <ph id="ph1">&lt;xref:System.Action%601&gt;</ph> delegate to print the contents of a <ph id="ph2">&lt;xref:System.Collections.Generic.List%601&gt;</ph> object.</source>
          <target state="translated">En el ejemplo siguiente se muestra el uso de la <ph id="ph1">&lt;xref:System.Action%601&gt;</ph> delegado que se va a imprimir el contenido de un <ph id="ph2">&lt;xref:System.Collections.Generic.List%601&gt;</ph> objeto.</target>       </trans-unit>
        <trans-unit id="650" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.ForEach(System.Action{`0})">
          <source>In this example the <ph id="ph1">`Print`</ph> method is used to display the contents of the list to the console.</source>
          <target state="translated">En este ejemplo el <ph id="ph1">`Print`</ph> método se usa para mostrar el contenido de la lista en la consola.</target>       </trans-unit>
        <trans-unit id="651" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.ForEach(System.Action{`0})">
          <source>In addition to displaying the contents using the <ph id="ph1">`Print`</ph> method, the C# example demonstrates the use of  to display the results to the console.</source>
          <target state="translated">Además de mostrar el contenido mediante el <ph id="ph1">`Print`</ph> método, el ejemplo de C# muestra el uso de para mostrar los resultados en la consola.</target>       </trans-unit>
        <trans-unit id="652" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.List`1.ForEach(System.Action{`0})">
          <source><ph id="ph1">&lt;paramref name="action" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="action" /&gt;</ph> es <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="653" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.List`1.ForEach(System.Action{`0})">
          <source>An element in the collection has been modified.</source>
          <target state="translated">Se ha modificado un elemento de la colección.</target>       </trans-unit>
        <trans-unit id="654" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.List`1.GetEnumerator">
          <source>Returns an enumerator that iterates through the <ph id="ph1">&lt;see cref="T:System.Collections.Generic.List`1" /&gt;</ph>.</source>
          <target state="translated">Devuelve un enumerador que recorre en iteración la colección <ph id="ph1">&lt;see cref="T:System.Collections.Generic.List`1" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="655" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.List`1.GetEnumerator">
          <source>A <ph id="ph1">&lt;see cref="T:System.Collections.Generic.List`1.Enumerator" /&gt;</ph> for the <ph id="ph2">&lt;see cref="T:System.Collections.Generic.List`1" /&gt;</ph>.</source>
          <target state="translated">Estructura <ph id="ph1">&lt;see cref="T:System.Collections.Generic.List`1.Enumerator" /&gt;</ph> para la colección <ph id="ph2">&lt;see cref="T:System.Collections.Generic.List`1" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="656" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.GetEnumerator">
          <source>The <ph id="ph1">`foreach`</ph> statement of the C# language (<ph id="ph2">`for each`</ph> in C++, <ph id="ph3">`For Each`</ph> in Visual Basic) hides the complexity of the enumerators.</source>
          <target state="translated">El <ph id="ph1">`foreach`</ph> instrucción del lenguaje C# (<ph id="ph2">`for each`</ph> en C++, <ph id="ph3">`For Each`</ph> en Visual Basic) oculta la complejidad de los enumeradores.</target>       </trans-unit>
        <trans-unit id="657" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.GetEnumerator">
          <source>Therefore, using <ph id="ph1">`foreach`</ph> is recommended, instead of directly manipulating the enumerator.</source>
          <target state="translated">Por lo tanto, se recomienda el uso de <ph id="ph1">`foreach`</ph>, en lugar de manipular directamente el enumerador.</target>       </trans-unit>
        <trans-unit id="658" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.GetEnumerator">
          <source>Enumerators can be used to read the data in the collection, but they cannot be used to modify the underlying collection.</source>
          <target state="translated">Los enumeradores pueden usarse para leer los datos de la colección, pero no para modificar la colección subyacente.</target>       </trans-unit>
        <trans-unit id="659" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.GetEnumerator">
          <source>Initially, the enumerator is positioned before the first element in the collection.</source>
          <target state="translated">En principio, el enumerador se coloca antes del primer elemento de la colección.</target>       </trans-unit>
        <trans-unit id="660" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.GetEnumerator">
          <source>At this position, the <ph id="ph1">&lt;xref:System.Collections.Generic.List%601.Enumerator.Current%2A&gt;</ph> property is undefined.</source>
          <target state="translated">En esta posición, el <ph id="ph1">&lt;xref:System.Collections.Generic.List%601.Enumerator.Current%2A&gt;</ph> propiedad no está definida.</target>       </trans-unit>
        <trans-unit id="661" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.GetEnumerator">
          <source>Therefore, you must call the <ph id="ph1">&lt;xref:System.Collections.Generic.List%601.Enumerator.MoveNext%2A&gt;</ph> method to advance the enumerator to the first element of the collection before reading the value of <ph id="ph2">&lt;xref:System.Collections.Generic.List%601.Enumerator.Current%2A&gt;</ph>.</source>
          <target state="translated">Por lo tanto, debe llamar a la <ph id="ph1">&lt;xref:System.Collections.Generic.List%601.Enumerator.MoveNext%2A&gt;</ph> método para adelantar el enumerador hasta el primer elemento de la colección antes de leer el valor de <ph id="ph2">&lt;xref:System.Collections.Generic.List%601.Enumerator.Current%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="662" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.GetEnumerator">
          <source>The <ph id="ph1">&lt;xref:System.Collections.Generic.List%601.Enumerator.Current%2A&gt;</ph> property returns the same object until <ph id="ph2">&lt;xref:System.Collections.Generic.List%601.Enumerator.MoveNext%2A&gt;</ph> is called.</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.Collections.Generic.List%601.Enumerator.Current%2A&gt;</ph> propiedad devuelve el mismo objeto hasta que <ph id="ph2">&lt;xref:System.Collections.Generic.List%601.Enumerator.MoveNext%2A&gt;</ph> se llama.</target>       </trans-unit>
        <trans-unit id="663" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.GetEnumerator">
          <source><ph id="ph1">&lt;xref:System.Collections.Generic.List%601.Enumerator.MoveNext%2A&gt;</ph> sets <ph id="ph2">&lt;xref:System.Collections.Generic.List%601.Enumerator.Current%2A&gt;</ph> to the next element.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Collections.Generic.List%601.Enumerator.MoveNext%2A&gt;</ph> establece <ph id="ph2">&lt;xref:System.Collections.Generic.List%601.Enumerator.Current%2A&gt;</ph> en el siguiente elemento.</target>       </trans-unit>
        <trans-unit id="664" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.GetEnumerator">
          <source>If <ph id="ph1">&lt;xref:System.Collections.Generic.List%601.Enumerator.MoveNext%2A&gt;</ph> passes the end of the collection, the enumerator is positioned after the last element in the collection and <ph id="ph2">&lt;xref:System.Collections.Generic.List%601.Enumerator.MoveNext%2A&gt;</ph> returns <ph id="ph3">`false`</ph>.</source>
          <target state="translated">Si <ph id="ph1">&lt;xref:System.Collections.Generic.List%601.Enumerator.MoveNext%2A&gt;</ph> pasa el final de la colección, el enumerador se coloca después del último elemento de la colección y <ph id="ph2">&lt;xref:System.Collections.Generic.List%601.Enumerator.MoveNext%2A&gt;</ph> devuelve <ph id="ph3">`false`</ph>.</target>       </trans-unit>
        <trans-unit id="665" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.GetEnumerator">
          <source>When the enumerator is at this position, subsequent calls to <ph id="ph1">&lt;xref:System.Collections.Generic.List%601.Enumerator.MoveNext%2A&gt;</ph> also return <ph id="ph2">`false`</ph>.</source>
          <target state="translated">Mientras el enumerador permanezca en esta posición, las llamadas subsiguientes a <ph id="ph1">&lt;xref:System.Collections.Generic.List%601.Enumerator.MoveNext%2A&gt;</ph> también devolver <ph id="ph2">`false`</ph>.</target>       </trans-unit>
        <trans-unit id="666" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.GetEnumerator">
          <source>If the last call to <ph id="ph1">&lt;xref:System.Collections.Generic.List%601.Enumerator.MoveNext%2A&gt;</ph> returned <ph id="ph2">`false`</ph>, <ph id="ph3">&lt;xref:System.Collections.Generic.List%601.Enumerator.Current%2A&gt;</ph> is undefined.</source>
          <target state="translated">Si la última llamada a <ph id="ph1">&lt;xref:System.Collections.Generic.List%601.Enumerator.MoveNext%2A&gt;</ph> devuelve <ph id="ph2">`false`</ph>, <ph id="ph3">&lt;xref:System.Collections.Generic.List%601.Enumerator.Current%2A&gt;</ph> no está definido.</target>       </trans-unit>
        <trans-unit id="667" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.GetEnumerator">
          <source>You cannot set <ph id="ph1">&lt;xref:System.Collections.Generic.List%601.Enumerator.Current%2A&gt;</ph> to the first element of the collection again; you must create a new enumerator instance instead.</source>
          <target state="translated">No puede volver a establecer la propiedad <ph id="ph1">&lt;xref:System.Collections.Generic.List%601.Enumerator.Current%2A&gt;</ph> en el primer elemento de la colección, sino que debe crear una nueva instancia del enumerador.</target>       </trans-unit>
        <trans-unit id="668" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.GetEnumerator">
          <source>An enumerator remains valid as long as the collection remains unchanged.</source>
          <target state="translated">Un enumerador es válido mientras la colección no cambie.</target>       </trans-unit>
        <trans-unit id="669" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.GetEnumerator">
          <source>If changes are made to the collection, such as adding, modifying, or deleting elements, the enumerator is irrecoverably invalidated and its behavior is undefined.</source>
          <target state="translated">Si se hacen cambios en la colección (como agregar, modificar o eliminar elementos), el enumerador queda invalidado permanentemente y su comportamiento es indefinido.</target>       </trans-unit>
        <trans-unit id="670" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.GetEnumerator">
          <source>The enumerator does not have exclusive access to the collection; therefore, enumerating through a collection is intrinsically not a thread-safe procedure.</source>
          <target state="translated">El enumerador no tiene acceso exclusivo a la colección y, por tanto, la enumeración en una colección no es intrínsicamente un procedimiento seguro para subprocesos.</target>       </trans-unit>
        <trans-unit id="671" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.GetEnumerator">
          <source>To guarantee thread safety during enumeration, you can lock the collection during the entire enumeration.</source>
          <target state="translated">A fin de garantizar la seguridad de los subprocesos, se puede bloquear la colección durante toda la enumeración.</target>       </trans-unit>
        <trans-unit id="672" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.GetEnumerator">
          <source>To allow the collection to be accessed by multiple threads for reading and writing, you must implement your own synchronization.</source>
          <target state="translated">Para permitir que varios subprocesos obtengan acceso de lectura y escritura a la colección, debe implementar su propia sincronización.</target>       </trans-unit>
        <trans-unit id="673" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.GetEnumerator">
          <source>Default implementations of collections in the <ph id="ph1">&lt;xref:System.Collections.Generic?displayProperty=nameWithType&gt;</ph> namespace are not synchronized.</source>
          <target state="translated">Las implementaciones predeterminadas de las colecciones del espacio de nombres <ph id="ph1">&lt;xref:System.Collections.Generic?displayProperty=nameWithType&gt;</ph> no están sincronizadas.</target>       </trans-unit>
        <trans-unit id="674" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.GetEnumerator">
          <source>This method is an O(1) operation.</source>
          <target state="translated">Este método es una operación o (1).</target>       </trans-unit>
        <trans-unit id="675" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.List`1.GetRange(System.Int32,System.Int32)">
          <source>The zero-based <ph id="ph1">&lt;see cref="T:System.Collections.Generic.List`1" /&gt;</ph> index at which the range starts.</source>
          <target state="translated">Índice de <ph id="ph1">&lt;see cref="T:System.Collections.Generic.List`1" /&gt;</ph> de base cero en el que empieza el intervalo.</target>       </trans-unit>
        <trans-unit id="676" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.List`1.GetRange(System.Int32,System.Int32)">
          <source>The number of elements in the range.</source>
          <target state="translated">Número de elementos del intervalo.</target>       </trans-unit>
        <trans-unit id="677" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.List`1.GetRange(System.Int32,System.Int32)">
          <source>Creates a shallow copy of a range of elements in the source <ph id="ph1">&lt;see cref="T:System.Collections.Generic.List`1" /&gt;</ph>.</source>
          <target state="translated">Crea una copia superficial de un intervalo de elementos en la <ph id="ph1">&lt;see cref="T:System.Collections.Generic.List`1" /&gt;</ph> de origen.</target>       </trans-unit>
        <trans-unit id="678" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.List`1.GetRange(System.Int32,System.Int32)">
          <source>A shallow copy of a range of elements in the source <ph id="ph1">&lt;see cref="T:System.Collections.Generic.List`1" /&gt;</ph>.</source>
          <target state="translated">Copia superficial de un intervalo de elementos en la <ph id="ph1">&lt;see cref="T:System.Collections.Generic.List`1" /&gt;</ph> de origen.</target>       </trans-unit>
        <trans-unit id="679" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.GetRange(System.Int32,System.Int32)">
          <source>A shallow copy of a collection of reference types, or a subset of that collection, contains only the references to the elements of the collection.</source>
          <target state="translated">Una copia superficial de una colección de tipos de referencia o un subconjunto de dicha colección, sólo contiene las referencias a los elementos de la colección.</target>       </trans-unit>
        <trans-unit id="680" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.GetRange(System.Int32,System.Int32)">
          <source>The objects themselves are not copied.</source>
          <target state="translated">No se copian los propios objetos.</target>       </trans-unit>
        <trans-unit id="681" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.GetRange(System.Int32,System.Int32)">
          <source>The references in the new list point to the same objects as the references in the original list.</source>
          <target state="translated">Las referencias de la nueva lista apuntan a los mismos objetos que las referencias de la lista original.</target>       </trans-unit>
        <trans-unit id="682" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.GetRange(System.Int32,System.Int32)">
          <source>A shallow copy of a collection of value types, or a subset of that collection, contains the elements of the collection.</source>
          <target state="translated">Una copia superficial de una colección de tipos de valor o un subconjunto de dicha colección, contiene los elementos de la colección.</target>       </trans-unit>
        <trans-unit id="683" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.GetRange(System.Int32,System.Int32)">
          <source>However, if the elements of the collection contain references to other objects, those objects are not copied.</source>
          <target state="translated">Sin embargo, si los elementos de la colección contienen referencias a otros objetos, esos objetos no se copian.</target>       </trans-unit>
        <trans-unit id="684" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.GetRange(System.Int32,System.Int32)">
          <source>The references in the elements of the new collection point to the same objects as the references in the elements of the original collection.</source>
          <target state="translated">Las referencias de los elementos de la nueva colección apuntan a los mismos objetos que las referencias de los elementos de la colección original.</target>       </trans-unit>
        <trans-unit id="685" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.GetRange(System.Int32,System.Int32)">
          <source>In contrast, a deep copy of a collection copies the elements and everything directly or indirectly referenced by the elements.</source>
          <target state="translated">En cambio, una copia en profundidad de una colección copia los elementos y todo lo que hacen referencia directa o indirectamente el elementos.</target>       </trans-unit>
        <trans-unit id="686" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.GetRange(System.Int32,System.Int32)">
          <source>This method is an O(<bpt id="p1">*</bpt>n<ept id="p1">*</ept>) operation, where <bpt id="p2">*</bpt>n<ept id="p2">*</ept> is <ph id="ph1">`count`</ph>.</source>
          <target state="translated">Este método es una O (<bpt id="p1">*</bpt>n<ept id="p1">*</ept>) operación, donde <bpt id="p2">*</bpt>n<ept id="p2">*</ept> es <ph id="ph1">`count`</ph>.</target>       </trans-unit>
        <trans-unit id="687" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.GetRange(System.Int32,System.Int32)">
          <source>The following example demonstrates the <ph id="ph1">&lt;xref:System.Collections.Generic.List%601.GetRange%2A&gt;</ph> method and other methods of the <ph id="ph2">&lt;xref:System.Collections.Generic.List%601&gt;</ph> class that act on ranges.</source>
          <target state="translated">En el ejemplo siguiente se muestra la <ph id="ph1">&lt;xref:System.Collections.Generic.List%601.GetRange%2A&gt;</ph> método y otros métodos de la <ph id="ph2">&lt;xref:System.Collections.Generic.List%601&gt;</ph> clase que operan en intervalos.</target>       </trans-unit>
        <trans-unit id="688" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.GetRange(System.Int32,System.Int32)">
          <source>At the end of the example, the <ph id="ph1">&lt;xref:System.Collections.Generic.List%601.GetRange%2A&gt;</ph> method is used to get three items from the list, beginning with index location 2.</source>
          <target state="translated">Al final del ejemplo, el <ph id="ph1">&lt;xref:System.Collections.Generic.List%601.GetRange%2A&gt;</ph> método se usa para obtener tres elementos de la lista, a partir de la posición de índice 2.</target>       </trans-unit>
        <trans-unit id="689" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.GetRange(System.Int32,System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.Collections.Generic.List%601.ToArray%2A&gt;</ph> method is called on the resulting <ph id="ph2">&lt;xref:System.Collections.Generic.List%601&gt;</ph>, creating an array of three elements.</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.Collections.Generic.List%601.ToArray%2A&gt;</ph> método se llama en el cuadro <ph id="ph2">&lt;xref:System.Collections.Generic.List%601&gt;</ph>, creación de una matriz de tres elementos.</target>       </trans-unit>
        <trans-unit id="690" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.GetRange(System.Int32,System.Int32)">
          <source>The elements of the array are displayed.</source>
          <target state="translated">Se muestran los elementos de la matriz.</target>       </trans-unit>
        <trans-unit id="691" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.List`1.GetRange(System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="index" /&gt;</ph> is less than 0.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="index" /&gt;</ph> es menor que 0.</target>       </trans-unit>
        <trans-unit id="692" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.List`1.GetRange(System.Int32,System.Int32)">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="693" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.List`1.GetRange(System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="count" /&gt;</ph> is less than 0.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="count" /&gt;</ph> es menor que 0.</target>       </trans-unit>
        <trans-unit id="694" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.List`1.GetRange(System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="index" /&gt;</ph> and <ph id="ph2">&lt;paramref name="count" /&gt;</ph> do not denote a valid range of elements in the <ph id="ph3">&lt;see cref="T:System.Collections.Generic.List`1" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="index" /&gt;</ph> y <ph id="ph2">&lt;paramref name="count" /&gt;</ph> no denotan un intervalo válido de elementos en <ph id="ph3">&lt;see cref="T:System.Collections.Generic.List`1" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="695" translate="yes" xml:space="preserve" uid="T:System.Collections.Generic.List`1">
          <source>Returns the zero-based index of the first occurrence of a value in the <ph id="ph1">&lt;see cref="T:System.Collections.Generic.List`1" /&gt;</ph> or in a portion of it.</source>
          <target state="translated">Devuelve el índice de base cero de la primera aparición de un valor en la <ph id="ph1">&lt;see cref="T:System.Collections.Generic.List`1" /&gt;</ph> o en una parte de ella.</target>       </trans-unit>
        <trans-unit id="696" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.List`1.IndexOf(`0)">
          <source>The object to locate in the <ph id="ph1">&lt;see cref="T:System.Collections.Generic.List`1" /&gt;</ph>.</source>
          <target state="translated">Objeto que se va a buscar en <ph id="ph1">&lt;see cref="T:System.Collections.Generic.List`1" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="697" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.List`1.IndexOf(`0)">
          <source>The value can be <ph id="ph1">&lt;see langword="null" /&gt;</ph> for reference types.</source>
          <target state="translated">El valor puede ser <ph id="ph1">&lt;see langword="null" /&gt;</ph> para los tipos de referencia.</target>       </trans-unit>
        <trans-unit id="698" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.List`1.IndexOf(`0)">
          <source>Searches for the specified object and returns the zero-based index of the first occurrence within the entire <ph id="ph1">&lt;see cref="T:System.Collections.Generic.List`1" /&gt;</ph>.</source>
          <target state="translated">Busca el objeto especificado y devuelve el índice de base cero de la primera aparición en todo el objeto <ph id="ph1">&lt;see cref="T:System.Collections.Generic.List`1" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="699" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.List`1.IndexOf(`0)">
          <source>The zero-based index of the first occurrence of <ph id="ph1">&lt;paramref name="item" /&gt;</ph> within the entire <ph id="ph2">&lt;see cref="T:System.Collections.Generic.List`1" /&gt;</ph>, if found; otherwise, –1.</source>
          <target state="translated">Índice de base cero de la primera aparición de <ph id="ph1">&lt;paramref name="item" /&gt;</ph> en la totalidad de <ph id="ph2">&lt;see cref="T:System.Collections.Generic.List`1" /&gt;</ph>, si se encuentra; en caso contrario, -1.</target>       </trans-unit>
        <trans-unit id="700" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.IndexOf(`0)">
          <source>The <ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph> is searched forward starting at the first element and ending at the last element.</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph> se busca hacia delante a partir del primer elemento y terminando con el último elemento.</target>       </trans-unit>
        <trans-unit id="701" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.IndexOf(`0)">
          <source>This method determines equality using the default equality comparer <ph id="ph1">&lt;xref:System.Collections.Generic.EqualityComparer%601.Default%2A?displayProperty=nameWithType&gt;</ph> for <ph id="ph2">`T`</ph>, the type of values in the list.</source>
          <target state="translated">Este método determina la igualdad utilizando el comparador de igualdad predeterminado <ph id="ph1">&lt;xref:System.Collections.Generic.EqualityComparer%601.Default%2A?displayProperty=nameWithType&gt;</ph> para <ph id="ph2">`T`</ph>, el tipo de valores de la lista.</target>       </trans-unit>
        <trans-unit id="702" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.IndexOf(`0)">
          <source>This method performs a linear search; therefore, this method is an O(<bpt id="p1">*</bpt>n<ept id="p1">*</ept>) operation, where <bpt id="p2">*</bpt>n<ept id="p2">*</ept> is <ph id="ph1">&lt;xref:System.Collections.Generic.List%601.Count%2A&gt;</ph>.</source>
          <target state="translated">Este método realiza una búsqueda lineal; por lo tanto, este método es una O (<bpt id="p1">*</bpt>n<ept id="p1">*</ept>) operación, donde <bpt id="p2">*</bpt>n<ept id="p2">*</ept> es <ph id="ph1">&lt;xref:System.Collections.Generic.List%601.Count%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="703" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.IndexOf(`0)">
          <source>The following example demonstrates all three overloads of the <ph id="ph1">&lt;xref:System.Collections.Generic.List%601.IndexOf%2A&gt;</ph> method.</source>
          <target state="translated">En el ejemplo siguiente se muestra las tres sobrecargas de la <ph id="ph1">&lt;xref:System.Collections.Generic.List%601.IndexOf%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="704" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.IndexOf(`0)">
          <source>A <ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph> of strings is created, with one entry that appears twice, at index location 0 and index location 5.</source>
          <target state="translated">Un <ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph> de cadenas se crea, con una entrada que aparece dos veces, en la ubicación de índice 0 y la ubicación de índice 5.</target>       </trans-unit>
        <trans-unit id="705" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.IndexOf(`0)">
          <source>The <ph id="ph1">&lt;xref:System.Collections.Generic.List%601.IndexOf%28%600%29&gt;</ph> method overload searches the list from the beginning, and finds the first occurrence of the string.</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.Collections.Generic.List%601.IndexOf%28%600%29&gt;</ph> sobrecarga del método busca en la lista desde el principio y busca la primera aparición de la cadena.</target>       </trans-unit>
        <trans-unit id="706" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.IndexOf(`0)">
          <source>The <ph id="ph1">&lt;xref:System.Collections.Generic.List%601.IndexOf%28%600%2CSystem.Int32%29&gt;</ph> method overload is used to search the list beginning with index location 3 and continuing to the end of the list, and finds the second occurrence of the string.</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.Collections.Generic.List%601.IndexOf%28%600%2CSystem.Int32%29&gt;</ph> sobrecarga del método se usa para buscar la lista comenzando en la posición de índice 3 y continuando hasta el final de la lista y encuentra la segunda aparición de la cadena.</target>       </trans-unit>
        <trans-unit id="707" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.IndexOf(`0)">
          <source>Finally, the <ph id="ph1">&lt;xref:System.Collections.Generic.List%601.IndexOf%28%600%2CSystem.Int32%2CSystem.Int32%29&gt;</ph> method overload is used to search a range of two entries, beginning at index location two; it returns –1 because there are no instances of the search string in that range.</source>
          <target state="translated">Por último, el <ph id="ph1">&lt;xref:System.Collections.Generic.List%601.IndexOf%28%600%2CSystem.Int32%2CSystem.Int32%29&gt;</ph> sobrecarga del método se usa para buscar en un intervalo de dos entradas, comenzando en la posición de índice dos; devuelve -1 porque no hay ninguna instancia de la cadena de búsqueda en ese intervalo.</target>       </trans-unit>
        <trans-unit id="708" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.List`1.IndexOf(`0,System.Int32)">
          <source>The object to locate in the <ph id="ph1">&lt;see cref="T:System.Collections.Generic.List`1" /&gt;</ph>.</source>
          <target state="translated">Objeto que se va a buscar en <ph id="ph1">&lt;see cref="T:System.Collections.Generic.List`1" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="709" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.List`1.IndexOf(`0,System.Int32)">
          <source>The value can be <ph id="ph1">&lt;see langword="null" /&gt;</ph> for reference types.</source>
          <target state="translated">El valor puede ser <ph id="ph1">&lt;see langword="null" /&gt;</ph> para los tipos de referencia.</target>       </trans-unit>
        <trans-unit id="710" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.List`1.IndexOf(`0,System.Int32)">
          <source>The zero-based starting index of the search.</source>
          <target state="translated">Índice inicial de base cero de la búsqueda.</target>       </trans-unit>
        <trans-unit id="711" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.List`1.IndexOf(`0,System.Int32)">
          <source>0 (zero) is valid in an empty list.</source>
          <target state="translated">0 (cero) es válido en una lista vacía.</target>       </trans-unit>
        <trans-unit id="712" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.List`1.IndexOf(`0,System.Int32)">
          <source>Searches for the specified object and returns the zero-based index of the first occurrence within the range of elements in the <ph id="ph1">&lt;see cref="T:System.Collections.Generic.List`1" /&gt;</ph> that extends from the specified index to the last element.</source>
          <target state="translated">Busca el objeto especificado y devuelve el índice de base cero de la primera aparición dentro del intervalo de elementos de <ph id="ph1">&lt;see cref="T:System.Collections.Generic.List`1" /&gt;</ph> que abarca desde el índice especificado hasta el último elemento.</target>       </trans-unit>
        <trans-unit id="713" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.List`1.IndexOf(`0,System.Int32)">
          <source>The zero-based index of the first occurrence of <ph id="ph1">&lt;paramref name="item" /&gt;</ph> within the range of elements in the <ph id="ph2">&lt;see cref="T:System.Collections.Generic.List`1" /&gt;</ph> that extends from <ph id="ph3">&lt;paramref name="index" /&gt;</ph> to the last element, if found; otherwise, –1.</source>
          <target state="translated">Índice de base cero de la primera aparición de <ph id="ph1">&lt;paramref name="item" /&gt;</ph> dentro del intervalo de elementos de <ph id="ph2">&lt;see cref="T:System.Collections.Generic.List`1" /&gt;</ph> que abarca desde <ph id="ph3">&lt;paramref name="index" /&gt;</ph> hasta el último elemento, si se encuentra; en caso contrario, -1.</target>       </trans-unit>
        <trans-unit id="714" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.IndexOf(`0,System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph> is searched forward starting at <ph id="ph2">`index`</ph> and ending at the last element.</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph> se busca hacia delante, empezando en <ph id="ph2">`index`</ph> y terminando con el último elemento.</target>       </trans-unit>
        <trans-unit id="715" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.IndexOf(`0,System.Int32)">
          <source>This method determines equality using the default equality comparer <ph id="ph1">&lt;xref:System.Collections.Generic.EqualityComparer%601.Default%2A?displayProperty=nameWithType&gt;</ph> for <ph id="ph2">`T`</ph>, the type of values in the list.</source>
          <target state="translated">Este método determina la igualdad utilizando el comparador de igualdad predeterminado <ph id="ph1">&lt;xref:System.Collections.Generic.EqualityComparer%601.Default%2A?displayProperty=nameWithType&gt;</ph> para <ph id="ph2">`T`</ph>, el tipo de valores de la lista.</target>       </trans-unit>
        <trans-unit id="716" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.IndexOf(`0,System.Int32)">
          <source>This method performs a linear search; therefore, this method is an O(<bpt id="p1">*</bpt>n<ept id="p1">*</ept>) operation, where <bpt id="p2">*</bpt>n<ept id="p2">*</ept> is the number of elements from <ph id="ph1">`index`</ph> to the end of the <ph id="ph2">&lt;xref:System.Collections.Generic.List%601&gt;</ph>.</source>
          <target state="translated">Este método realiza una búsqueda lineal; por lo tanto, este método es una O (<bpt id="p1">*</bpt>n<ept id="p1">*</ept>) operación, donde <bpt id="p2">*</bpt>n<ept id="p2">*</ept> es el número de elementos de <ph id="ph1">`index`</ph> al final de la <ph id="ph2">&lt;xref:System.Collections.Generic.List%601&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="717" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.IndexOf(`0,System.Int32)">
          <source>The following example demonstrates all three overloads of the <ph id="ph1">&lt;xref:System.Collections.Generic.List%601.IndexOf%2A&gt;</ph> method.</source>
          <target state="translated">En el ejemplo siguiente se muestra las tres sobrecargas de la <ph id="ph1">&lt;xref:System.Collections.Generic.List%601.IndexOf%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="718" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.IndexOf(`0,System.Int32)">
          <source>A <ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph> of strings is created, with one entry that appears twice, at index location 0 and index location 5.</source>
          <target state="translated">Un <ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph> de cadenas se crea, con una entrada que aparece dos veces, en la ubicación de índice 0 y la ubicación de índice 5.</target>       </trans-unit>
        <trans-unit id="719" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.IndexOf(`0,System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.Collections.Generic.List%601.IndexOf%28%600%29&gt;</ph> method overload searches the list from the beginning, and finds the first occurrence of the string.</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.Collections.Generic.List%601.IndexOf%28%600%29&gt;</ph> sobrecarga del método busca en la lista desde el principio y busca la primera aparición de la cadena.</target>       </trans-unit>
        <trans-unit id="720" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.IndexOf(`0,System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.Collections.Generic.List%601.IndexOf%28%600%2CSystem.Int32%29&gt;</ph> method overload is used to search the list beginning with index location 3 and continuing to the end of the list, and finds the second occurrence of the string.</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.Collections.Generic.List%601.IndexOf%28%600%2CSystem.Int32%29&gt;</ph> sobrecarga del método se usa para buscar la lista comenzando en la posición de índice 3 y continuando hasta el final de la lista y encuentra la segunda aparición de la cadena.</target>       </trans-unit>
        <trans-unit id="721" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.IndexOf(`0,System.Int32)">
          <source>Finally, the <ph id="ph1">&lt;xref:System.Collections.Generic.List%601.IndexOf%28%600%2CSystem.Int32%2CSystem.Int32%29&gt;</ph> method overload is used to search a range of two entries, beginning at index location two; it returns –1 because there are no instances of the search string in that range.</source>
          <target state="translated">Por último, el <ph id="ph1">&lt;xref:System.Collections.Generic.List%601.IndexOf%28%600%2CSystem.Int32%2CSystem.Int32%29&gt;</ph> sobrecarga del método se usa para buscar en un intervalo de dos entradas, comenzando en la posición de índice dos; devuelve -1 porque no hay ninguna instancia de la cadena de búsqueda en ese intervalo.</target>       </trans-unit>
        <trans-unit id="722" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.List`1.IndexOf(`0,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="index" /&gt;</ph> is outside the range of valid indexes for the <ph id="ph2">&lt;see cref="T:System.Collections.Generic.List`1" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="index" /&gt;</ph> está fuera del intervalo de índices válidos para <ph id="ph2">&lt;see cref="T:System.Collections.Generic.List`1" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="723" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.List`1.IndexOf(`0,System.Int32,System.Int32)">
          <source>The object to locate in the <ph id="ph1">&lt;see cref="T:System.Collections.Generic.List`1" /&gt;</ph>.</source>
          <target state="translated">Objeto que se va a buscar en <ph id="ph1">&lt;see cref="T:System.Collections.Generic.List`1" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="724" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.List`1.IndexOf(`0,System.Int32,System.Int32)">
          <source>The value can be <ph id="ph1">&lt;see langword="null" /&gt;</ph> for reference types.</source>
          <target state="translated">El valor puede ser <ph id="ph1">&lt;see langword="null" /&gt;</ph> para los tipos de referencia.</target>       </trans-unit>
        <trans-unit id="725" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.List`1.IndexOf(`0,System.Int32,System.Int32)">
          <source>The zero-based starting index of the search.</source>
          <target state="translated">Índice inicial de base cero de la búsqueda.</target>       </trans-unit>
        <trans-unit id="726" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.List`1.IndexOf(`0,System.Int32,System.Int32)">
          <source>0 (zero) is valid in an empty list.</source>
          <target state="translated">0 (cero) es válido en una lista vacía.</target>       </trans-unit>
        <trans-unit id="727" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.List`1.IndexOf(`0,System.Int32,System.Int32)">
          <source>The number of elements in the section to search.</source>
          <target state="translated">Número de elementos de la sección en la que se va a realizar la búsqueda.</target>       </trans-unit>
        <trans-unit id="728" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.List`1.IndexOf(`0,System.Int32,System.Int32)">
          <source>Searches for the specified object and returns the zero-based index of the first occurrence within the range of elements in the <ph id="ph1">&lt;see cref="T:System.Collections.Generic.List`1" /&gt;</ph> that starts at the specified index and contains the specified number of elements.</source>
          <target state="translated">Busca el objeto especificado y devuelve el índice de base cero de la primera aparición dentro del intervalo de elementos de <ph id="ph1">&lt;see cref="T:System.Collections.Generic.List`1" /&gt;</ph> que comienza en el índice especificado y contiene el número especificado de elementos.</target>       </trans-unit>
        <trans-unit id="729" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.List`1.IndexOf(`0,System.Int32,System.Int32)">
          <source>The zero-based index of the first occurrence of <ph id="ph1">&lt;paramref name="item" /&gt;</ph> within the range of elements in the <ph id="ph2">&lt;see cref="T:System.Collections.Generic.List`1" /&gt;</ph> that starts at <ph id="ph3">&lt;paramref name="index" /&gt;</ph> and contains <ph id="ph4">&lt;paramref name="count" /&gt;</ph> number of elements, if found; otherwise, –1.</source>
          <target state="translated">Índice de base cero de la primera aparición de <ph id="ph1">&lt;paramref name="item" /&gt;</ph> dentro del intervalo de elementos de <ph id="ph2">&lt;see cref="T:System.Collections.Generic.List`1" /&gt;</ph> que comienza en <ph id="ph3">&lt;paramref name="index" /&gt;</ph> y contiene el número de elementos de <ph id="ph4">&lt;paramref name="count" /&gt;</ph>, si se encuentra; en caso contrario, -1.</target>       </trans-unit>
        <trans-unit id="730" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.IndexOf(`0,System.Int32,System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph> is searched forward starting at <ph id="ph2">`index`</ph> and ending at <ph id="ph3">`index`</ph> plus <ph id="ph4">`count`</ph> minus 1, if <ph id="ph5">`count`</ph> is greater than 0.</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph> se busca hacia delante, empezando en <ph id="ph2">`index`</ph> y terminando en <ph id="ph3">`index`</ph> más <ph id="ph4">`count`</ph> menos 1, si <ph id="ph5">`count`</ph> es mayor que 0.</target>       </trans-unit>
        <trans-unit id="731" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.IndexOf(`0,System.Int32,System.Int32)">
          <source>This method determines equality using the default equality comparer <ph id="ph1">&lt;xref:System.Collections.Generic.EqualityComparer%601.Default%2A?displayProperty=nameWithType&gt;</ph> for <ph id="ph2">`T`</ph>, the type of values in the list.</source>
          <target state="translated">Este método determina la igualdad utilizando el comparador de igualdad predeterminado <ph id="ph1">&lt;xref:System.Collections.Generic.EqualityComparer%601.Default%2A?displayProperty=nameWithType&gt;</ph> para <ph id="ph2">`T`</ph>, el tipo de valores de la lista.</target>       </trans-unit>
        <trans-unit id="732" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.IndexOf(`0,System.Int32,System.Int32)">
          <source>This method performs a linear search; therefore, this method is an O(<bpt id="p1">*</bpt>n<ept id="p1">*</ept>) operation, where <bpt id="p2">*</bpt>n<ept id="p2">*</ept> is <ph id="ph1">`count`</ph>.</source>
          <target state="translated">Este método realiza una búsqueda lineal; por lo tanto, este método es una O (<bpt id="p1">*</bpt>n<ept id="p1">*</ept>) operación, donde <bpt id="p2">*</bpt>n<ept id="p2">*</ept> es <ph id="ph1">`count`</ph>.</target>       </trans-unit>
        <trans-unit id="733" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.IndexOf(`0,System.Int32,System.Int32)">
          <source>The following example demonstrates all three overloads of the <ph id="ph1">&lt;xref:System.Collections.Generic.List%601.IndexOf%2A&gt;</ph> method.</source>
          <target state="translated">En el ejemplo siguiente se muestra las tres sobrecargas de la <ph id="ph1">&lt;xref:System.Collections.Generic.List%601.IndexOf%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="734" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.IndexOf(`0,System.Int32,System.Int32)">
          <source>A <ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph> of strings is created, with one entry that appears twice, at index location 0 and index location 5.</source>
          <target state="translated">Un <ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph> de cadenas se crea, con una entrada que aparece dos veces, en la ubicación de índice 0 y la ubicación de índice 5.</target>       </trans-unit>
        <trans-unit id="735" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.IndexOf(`0,System.Int32,System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.Collections.Generic.List%601.IndexOf%28%600%29&gt;</ph> method overload searches the list from the beginning, and finds the first occurrence of the string.</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.Collections.Generic.List%601.IndexOf%28%600%29&gt;</ph> sobrecarga del método busca en la lista desde el principio y busca la primera aparición de la cadena.</target>       </trans-unit>
        <trans-unit id="736" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.IndexOf(`0,System.Int32,System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.Collections.Generic.List%601.IndexOf%28%600%2CSystem.Int32%29&gt;</ph> method overload is used to search the list beginning with index location 3 and continuing to the end of the list, and finds the second occurrence of the string.</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.Collections.Generic.List%601.IndexOf%28%600%2CSystem.Int32%29&gt;</ph> sobrecarga del método se usa para buscar la lista comenzando en la posición de índice 3 y continuando hasta el final de la lista y encuentra la segunda aparición de la cadena.</target>       </trans-unit>
        <trans-unit id="737" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.IndexOf(`0,System.Int32,System.Int32)">
          <source>Finally, the <ph id="ph1">&lt;xref:System.Collections.Generic.List%601.IndexOf%28%600%2CSystem.Int32%2CSystem.Int32%29&gt;</ph> method overload is used to search a range of two entries, beginning at index location two; it returns –1 because there are no instances of the search string in that range.</source>
          <target state="translated">Por último, el <ph id="ph1">&lt;xref:System.Collections.Generic.List%601.IndexOf%28%600%2CSystem.Int32%2CSystem.Int32%29&gt;</ph> sobrecarga del método se usa para buscar en un intervalo de dos entradas, comenzando en la posición de índice dos; devuelve -1 porque no hay ninguna instancia de la cadena de búsqueda en ese intervalo.</target>       </trans-unit>
        <trans-unit id="738" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.List`1.IndexOf(`0,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="index" /&gt;</ph> is outside the range of valid indexes for the <ph id="ph2">&lt;see cref="T:System.Collections.Generic.List`1" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="index" /&gt;</ph> está fuera del intervalo de índices válidos para <ph id="ph2">&lt;see cref="T:System.Collections.Generic.List`1" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="739" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.List`1.IndexOf(`0,System.Int32,System.Int32)">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="740" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.List`1.IndexOf(`0,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="count" /&gt;</ph> is less than 0.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="count" /&gt;</ph> es menor que 0.</target>       </trans-unit>
        <trans-unit id="741" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.List`1.IndexOf(`0,System.Int32,System.Int32)">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="742" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.List`1.IndexOf(`0,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="index" /&gt;</ph> and <ph id="ph2">&lt;paramref name="count" /&gt;</ph> do not specify a valid section in the <ph id="ph3">&lt;see cref="T:System.Collections.Generic.List`1" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="index" /&gt;</ph> y <ph id="ph2">&lt;paramref name="count" /&gt;</ph> no especifican una sección válida en <ph id="ph3">&lt;see cref="T:System.Collections.Generic.List`1" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="743" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.List`1.Insert(System.Int32,`0)">
          <source>The zero-based index at which <bpt id="p1">&lt;c&gt;</bpt>item<ept id="p1">&lt;/c&gt;</ept> should be inserted.</source>
          <target state="translated">Índice de base cero donde debe insertarse <bpt id="p1">&lt;c&gt;</bpt>item<ept id="p1">&lt;/c&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="744" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.List`1.Insert(System.Int32,`0)">
          <source>The object to insert.</source>
          <target state="translated">Objeto que se va a insertar.</target>       </trans-unit>
        <trans-unit id="745" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.List`1.Insert(System.Int32,`0)">
          <source>The value can be <ph id="ph1">&lt;see langword="null" /&gt;</ph> for reference types.</source>
          <target state="translated">El valor puede ser <ph id="ph1">&lt;see langword="null" /&gt;</ph> para los tipos de referencia.</target>       </trans-unit>
        <trans-unit id="746" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.List`1.Insert(System.Int32,`0)">
          <source>Inserts an element into the <ph id="ph1">&lt;see cref="T:System.Collections.Generic.List`1" /&gt;</ph> at the specified index.</source>
          <target state="translated">Inserta un elemento en <ph id="ph1">&lt;see cref="T:System.Collections.Generic.List`1" /&gt;</ph>, en el índice especificado.</target>       </trans-unit>
        <trans-unit id="747" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.Insert(System.Int32,`0)">
          <source><ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph> accepts <ph id="ph2">`null`</ph> as a valid value for reference types and allows duplicate elements.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph> acepta <ph id="ph2">`null`</ph> como un valor válido para la referencia de tipos y permite a los elementos duplicados.</target>       </trans-unit>
        <trans-unit id="748" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.Insert(System.Int32,`0)">
          <source>If <ph id="ph1">&lt;xref:System.Collections.Generic.List%601.Count%2A&gt;</ph> already equals <ph id="ph2">&lt;xref:System.Collections.Generic.List%601.Capacity%2A&gt;</ph>, the capacity of the <ph id="ph3">&lt;xref:System.Collections.Generic.List%601&gt;</ph> is increased by automatically reallocating the internal array, and the existing elements are copied to the new array before the new element is added.</source>
          <target state="translated">Si <ph id="ph1">&lt;xref:System.Collections.Generic.List%601.Count%2A&gt;</ph> ya es igual a <ph id="ph2">&lt;xref:System.Collections.Generic.List%601.Capacity%2A&gt;</ph>, la capacidad de la <ph id="ph3">&lt;xref:System.Collections.Generic.List%601&gt;</ph> se incrementa mediante la reasignación automática de la matriz interna, y se copian los elementos existentes en la nueva matriz antes de agrega el nuevo elemento.</target>       </trans-unit>
        <trans-unit id="749" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.Insert(System.Int32,`0)">
          <source>If <ph id="ph1">`index`</ph> is equal to <ph id="ph2">&lt;xref:System.Collections.Generic.List%601.Count%2A&gt;</ph>, <ph id="ph3">`item`</ph> is added to the end of <ph id="ph4">&lt;xref:System.Collections.Generic.List%601&gt;</ph>.</source>
          <target state="translated">Si <ph id="ph1">`index`</ph> es igual a <ph id="ph2">&lt;xref:System.Collections.Generic.List%601.Count%2A&gt;</ph>, <ph id="ph3">`item`</ph> se agrega al final de <ph id="ph4">&lt;xref:System.Collections.Generic.List%601&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="750" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.Insert(System.Int32,`0)">
          <source>This method is an O(<bpt id="p1">*</bpt>n<ept id="p1">*</ept>) operation, where <bpt id="p2">*</bpt>n<ept id="p2">*</ept> is <ph id="ph1">&lt;xref:System.Collections.Generic.List%601.Count%2A&gt;</ph>.</source>
          <target state="translated">Este método es una O (<bpt id="p1">*</bpt>n<ept id="p1">*</ept>) operación, donde <bpt id="p2">*</bpt>n<ept id="p2">*</ept> es <ph id="ph1">&lt;xref:System.Collections.Generic.List%601.Count%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="751" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.Insert(System.Int32,`0)">
          <source>The following example demonstrates how to add, remove, and insert a simple business object in a <ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph>.</source>
          <target state="translated">En el ejemplo siguiente se muestra cómo agregar, quitar e insertar un objeto comercial simple en una <ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="752" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.Insert(System.Int32,`0)">
          <source>The following example demonstrates the <ph id="ph1">&lt;xref:System.Collections.Generic.List%601.Insert%2A&gt;</ph> method, along with various other properties and methods of the <ph id="ph2">&lt;xref:System.Collections.Generic.List%601&gt;</ph> generic class.</source>
          <target state="translated">En el ejemplo siguiente se muestra la <ph id="ph1">&lt;xref:System.Collections.Generic.List%601.Insert%2A&gt;</ph> método, junto con otras propiedades y métodos de la <ph id="ph2">&lt;xref:System.Collections.Generic.List%601&gt;</ph> clase genérica.</target>       </trans-unit>
        <trans-unit id="753" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.Insert(System.Int32,`0)">
          <source>After the list is created, elements are added.</source>
          <target state="translated">Una vez creada la lista, se agregan elementos.</target>       </trans-unit>
        <trans-unit id="754" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.Insert(System.Int32,`0)">
          <source>The <ph id="ph1">&lt;xref:System.Collections.Generic.List%601.Insert%2A&gt;</ph> method is used to insert an item into the middle of the list.</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.Collections.Generic.List%601.Insert%2A&gt;</ph> método se utiliza para insertar un elemento en la mitad de la lista.</target>       </trans-unit>
        <trans-unit id="755" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.Insert(System.Int32,`0)">
          <source>The item inserted is a duplicate, which is later removed using the <ph id="ph1">&lt;xref:System.Collections.Generic.List%601.Remove%2A&gt;</ph> method.</source>
          <target state="translated">El elemento insertado es un duplicado, que se quita más tarde mediante el <ph id="ph1">&lt;xref:System.Collections.Generic.List%601.Remove%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="756" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.List`1.Insert(System.Int32,`0)">
          <source><ph id="ph1">&lt;paramref name="index" /&gt;</ph> is less than 0.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="index" /&gt;</ph> es menor que 0.</target>       </trans-unit>
        <trans-unit id="757" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.List`1.Insert(System.Int32,`0)">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="758" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.List`1.Insert(System.Int32,`0)">
          <source><ph id="ph1">&lt;paramref name="index" /&gt;</ph> is greater than <ph id="ph2">&lt;see cref="P:System.Collections.Generic.List`1.Count" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="index" /&gt;</ph> es mayor que <ph id="ph2">&lt;see cref="P:System.Collections.Generic.List`1.Count" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="759" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.List`1.InsertRange(System.Int32,System.Collections.Generic.IEnumerable{`0})">
          <source>The zero-based index at which the new elements should be inserted.</source>
          <target state="translated">Índice de base cero donde se deben insertar los nuevos elementos.</target>       </trans-unit>
        <trans-unit id="760" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.List`1.InsertRange(System.Int32,System.Collections.Generic.IEnumerable{`0})">
          <source>The collection whose elements should be inserted into the <ph id="ph1">&lt;see cref="T:System.Collections.Generic.List`1" /&gt;</ph>.</source>
          <target state="translated">Colección cuyos elementos se deben insertar en <ph id="ph1">&lt;see cref="T:System.Collections.Generic.List`1" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="761" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.List`1.InsertRange(System.Int32,System.Collections.Generic.IEnumerable{`0})">
          <source>The collection itself cannot be <ph id="ph1">&lt;see langword="null" /&gt;</ph>, but it can contain elements that are <ph id="ph2">&lt;see langword="null" /&gt;</ph>, if type <bpt id="p1">&lt;c&gt;</bpt>T<ept id="p1">&lt;/c&gt;</ept> is a reference type.</source>
          <target state="translated">La propia colección no puede ser <ph id="ph1">&lt;see langword="null" /&gt;</ph>, pero puede contener elementos que sean <ph id="ph2">&lt;see langword="null" /&gt;</ph> si el tipo <bpt id="p1">&lt;c&gt;</bpt>T<ept id="p1">&lt;/c&gt;</ept> es un tipo de referencia.</target>       </trans-unit>
        <trans-unit id="762" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.List`1.InsertRange(System.Int32,System.Collections.Generic.IEnumerable{`0})">
          <source>Inserts the elements of a collection into the <ph id="ph1">&lt;see cref="T:System.Collections.Generic.List`1" /&gt;</ph> at the specified index.</source>
          <target state="translated">Inserta los elementos de una colección en <ph id="ph1">&lt;see cref="T:System.Collections.Generic.List`1" /&gt;</ph> en el índice especificado.</target>       </trans-unit>
        <trans-unit id="763" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.InsertRange(System.Int32,System.Collections.Generic.IEnumerable{`0})">
          <source><ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph> accepts <ph id="ph2">`null`</ph> as a valid value for reference types and allows duplicate elements.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph> acepta <ph id="ph2">`null`</ph> como un valor válido para la referencia de tipos y permite a los elementos duplicados.</target>       </trans-unit>
        <trans-unit id="764" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.InsertRange(System.Int32,System.Collections.Generic.IEnumerable{`0})">
          <source>If the new <ph id="ph1">&lt;xref:System.Collections.Generic.List%601.Count%2A&gt;</ph> (the current <ph id="ph2">&lt;xref:System.Collections.Generic.List%601.Count%2A&gt;</ph> plus the size of the collection) will be greater than <ph id="ph3">&lt;xref:System.Collections.Generic.List%601.Capacity%2A&gt;</ph>, the capacity of the <ph id="ph4">&lt;xref:System.Collections.Generic.List%601&gt;</ph> is increased by automatically reallocating the internal array to accommodate the new elements, and the existing elements are copied to the new array before the new elements are added.</source>
          <target state="translated">Si el nuevo <ph id="ph1">&lt;xref:System.Collections.Generic.List%601.Count%2A&gt;</ph> (actual <ph id="ph2">&lt;xref:System.Collections.Generic.List%601.Count%2A&gt;</ph> más el tamaño de la colección) será mayor que <ph id="ph3">&lt;xref:System.Collections.Generic.List%601.Capacity%2A&gt;</ph>, la capacidad de la <ph id="ph4">&lt;xref:System.Collections.Generic.List%601&gt;</ph> se incrementa mediante la reasignación automática de la matriz interna para dar cabida a los nuevos elementos, y se copian los elementos existentes en la nueva matriz antes de que se agregan los nuevos elementos.</target>       </trans-unit>
        <trans-unit id="765" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.InsertRange(System.Int32,System.Collections.Generic.IEnumerable{`0})">
          <source>If <ph id="ph1">`index`</ph> is equal to <ph id="ph2">&lt;xref:System.Collections.Generic.List%601.Count%2A&gt;</ph>, the elements are added to the end of <ph id="ph3">&lt;xref:System.Collections.Generic.List%601&gt;</ph>.</source>
          <target state="translated">Si <ph id="ph1">`index`</ph> es igual a <ph id="ph2">&lt;xref:System.Collections.Generic.List%601.Count%2A&gt;</ph>, los elementos se agregan al final de <ph id="ph3">&lt;xref:System.Collections.Generic.List%601&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="766" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.InsertRange(System.Int32,System.Collections.Generic.IEnumerable{`0})">
          <source>The order of the elements in the collection is preserved in the <ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph>.</source>
          <target state="translated">Se conserva el orden de los elementos de la colección en el <ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="767" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.InsertRange(System.Int32,System.Collections.Generic.IEnumerable{`0})">
          <source>This method is an O(<bpt id="p1">*</bpt>n<ept id="p1">*</ept><ph id="ph1"> * </ph><bpt id="p2">*</bpt>m<ept id="p2">*</ept>) operation, where <bpt id="p3">*</bpt>n<ept id="p3">*</ept> is the number of elements to be added and <bpt id="p4">*</bpt>m<ept id="p4">*</ept> is <ph id="ph2">&lt;xref:System.Collections.Generic.List%601.Count%2A&gt;</ph>.</source>
          <target state="translated">Este método es una O (<bpt id="p1">*</bpt>n<ept id="p1">*</ept><ph id="ph1"> * </ph><bpt id="p2">*</bpt>m<ept id="p2">*</ept>) operación, donde <bpt id="p3">*</bpt>n<ept id="p3">*</ept> es el número de elementos que se va a agregarse y <bpt id="p4">*</bpt>m<ept id="p4">*</ept> es <ph id="ph2">&lt;xref:System.Collections.Generic.List%601.Count%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="768" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.InsertRange(System.Int32,System.Collections.Generic.IEnumerable{`0})">
          <source>The following example demonstrates <ph id="ph1">&lt;xref:System.Collections.Generic.List%601.InsertRange%2A&gt;</ph> method and various other methods of the <ph id="ph2">&lt;xref:System.Collections.Generic.List%601&gt;</ph> class that act on ranges.</source>
          <target state="translated">En el ejemplo siguiente se muestra <ph id="ph1">&lt;xref:System.Collections.Generic.List%601.InsertRange%2A&gt;</ph> método y otros métodos de la <ph id="ph2">&lt;xref:System.Collections.Generic.List%601&gt;</ph> clase que operan en intervalos.</target>       </trans-unit>
        <trans-unit id="769" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.InsertRange(System.Int32,System.Collections.Generic.IEnumerable{`0})">
          <source>After the list has been created and populated with the names of several peaceful plant-eating dinosaurs, the <ph id="ph1">&lt;xref:System.Collections.Generic.List%601.InsertRange%2A&gt;</ph> method is used to insert an array of three ferocious meat-eating dinosaurs into the list, beginning at index location 3.</source>
          <target state="translated">Después de haber creado y se rellena con los nombres de varios pacíficos comer planta dinosaurios, la lista el <ph id="ph1">&lt;xref:System.Collections.Generic.List%601.InsertRange%2A&gt;</ph> método se utiliza para insertar una matriz de tres dinosaurios feroces comer carne en la lista, comenzando en la posición de índice 3.</target>       </trans-unit>
        <trans-unit id="770" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.List`1.InsertRange(System.Int32,System.Collections.Generic.IEnumerable{`0})">
          <source><ph id="ph1">&lt;paramref name="collection" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="collection" /&gt;</ph> es <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="771" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.List`1.InsertRange(System.Int32,System.Collections.Generic.IEnumerable{`0})">
          <source><ph id="ph1">&lt;paramref name="index" /&gt;</ph> is less than 0.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="index" /&gt;</ph> es menor que 0.</target>       </trans-unit>
        <trans-unit id="772" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.List`1.InsertRange(System.Int32,System.Collections.Generic.IEnumerable{`0})">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="773" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.List`1.InsertRange(System.Int32,System.Collections.Generic.IEnumerable{`0})">
          <source><ph id="ph1">&lt;paramref name="index" /&gt;</ph> is greater than <ph id="ph2">&lt;see cref="P:System.Collections.Generic.List`1.Count" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="index" /&gt;</ph> es mayor que <ph id="ph2">&lt;see cref="P:System.Collections.Generic.List`1.Count" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="774" translate="yes" xml:space="preserve" uid="P:System.Collections.Generic.List`1.Item(System.Int32)">
          <source>The zero-based index of the element to get or set.</source>
          <target state="translated">Índice de base cero del elemento que se va a obtener o establecer.</target>       </trans-unit>
        <trans-unit id="775" translate="yes" xml:space="preserve" uid="P:System.Collections.Generic.List`1.Item(System.Int32)">
          <source>Gets or sets the element at the specified index.</source>
          <target state="translated">Obtiene o establece el elemento en el índice especificado.</target>       </trans-unit>
        <trans-unit id="776" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.Generic.List`1.Item(System.Int32)">
          <source>The element at the specified index.</source>
          <target state="translated">Elemento en el índice especificado.</target>       </trans-unit>
        <trans-unit id="777" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.Generic.List`1.Item(System.Int32)">
          <source><ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph> accepts <ph id="ph2">`null`</ph> as a valid value for reference types and allows duplicate elements.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph> acepta <ph id="ph2">`null`</ph> como un valor válido para la referencia de tipos y permite a los elementos duplicados.</target>       </trans-unit>
        <trans-unit id="778" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.Generic.List`1.Item(System.Int32)">
          <source>This property provides the ability to access a specific element in the collection by using the following syntax: <ph id="ph1">`myCollection[index]`</ph>.</source>
          <target state="translated">Esta propiedad permite obtener acceso a un elemento específico de la colección utilizando la sintaxis siguiente: <ph id="ph1">`myCollection[index]`</ph>.</target>       </trans-unit>
        <trans-unit id="779" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.Generic.List`1.Item(System.Int32)">
          <source>Retrieving the value of this property is an O(1) operation; setting the property is also an O(1) operation.</source>
          <target state="translated">La recuperación del valor de esta propiedad es una operación o (1); establecer la propiedad también es una operación o (1).</target>       </trans-unit>
        <trans-unit id="780" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.Generic.List`1.Item(System.Int32)">
          <source>The example in this section demonstrates the <ph id="ph1">&lt;xref:System.Collections.Generic.List%601.Item%2A&gt;</ph> property (the indexer in C#) and various other properties and methods of the <ph id="ph2">&lt;xref:System.Collections.Generic.List%601&gt;</ph> generic class.</source>
          <target state="translated">El ejemplo de esta sección se muestra la <ph id="ph1">&lt;xref:System.Collections.Generic.List%601.Item%2A&gt;</ph> propiedad (el indizador en C#) y como otras propiedades y métodos de la <ph id="ph2">&lt;xref:System.Collections.Generic.List%601&gt;</ph> clase genérica.</target>       </trans-unit>
        <trans-unit id="781" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.Generic.List`1.Item(System.Int32)">
          <source>After the list has been created and populated using the <ph id="ph1">&lt;xref:System.Collections.Generic.List%601.Add%2A&gt;</ph> method, an element is retrieved and displayed using the <ph id="ph2">&lt;xref:System.Collections.Generic.List%601.Item%2A&gt;</ph> property.</source>
          <target state="translated">Después de la lista crean y rellenan con el <ph id="ph1">&lt;xref:System.Collections.Generic.List%601.Add%2A&gt;</ph> método, un elemento se recupera y muestra el uso de la <ph id="ph2">&lt;xref:System.Collections.Generic.List%601.Item%2A&gt;</ph> propiedad.</target>       </trans-unit>
        <trans-unit id="782" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.Generic.List`1.Item(System.Int32)">
          <source>(For an example that uses the <ph id="ph1">&lt;xref:System.Collections.Generic.List%601.Item%2A&gt;</ph> property to set the value of a list element, see <ph id="ph2">&lt;xref:System.Collections.Generic.List%601.AsReadOnly%2A&gt;</ph>.)</source>
          <target state="translated">(Para obtener un ejemplo que usa el <ph id="ph1">&lt;xref:System.Collections.Generic.List%601.Item%2A&gt;</ph> propiedad para establecer el valor de un elemento de lista, vea <ph id="ph2">&lt;xref:System.Collections.Generic.List%601.AsReadOnly%2A&gt;</ph>.)</target>       </trans-unit>
        <trans-unit id="783" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.Generic.List`1.Item(System.Int32)">
          <source>Visual Basic, C#, and C++ all have syntax for accessing the <ph id="ph1">&lt;xref:System.Collections.Generic.List%601.Item%2A&gt;</ph> property without using its name.</source>
          <target state="translated">Visual Basic, C# y C++ todas tengan la sintaxis para tener acceso a la <ph id="ph1">&lt;xref:System.Collections.Generic.List%601.Item%2A&gt;</ph> propiedad sin utilizar su nombre.</target>       </trans-unit>
        <trans-unit id="784" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.Generic.List`1.Item(System.Int32)">
          <source>Instead, the variable containing the <ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph> is used as if it were an array.</source>
          <target state="translated">En su lugar, la variable que contiene el <ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph> se utiliza como si fuera una matriz.</target>       </trans-unit>
        <trans-unit id="785" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.Generic.List`1.Item(System.Int32)">
          <source>The C# language uses the  keyword to define the indexers instead of implementing the <ph id="ph1">&lt;xref:System.Collections.Generic.List%601.Item%2A&gt;</ph> property.</source>
          <target state="translated">El lenguaje C# utiliza la palabra clave para definir los indizadores en lugar de implementar la <ph id="ph1">&lt;xref:System.Collections.Generic.List%601.Item%2A&gt;</ph> propiedad.</target>       </trans-unit>
        <trans-unit id="786" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.Generic.List`1.Item(System.Int32)">
          <source>Visual Basic implements <ph id="ph1">&lt;xref:System.Collections.Generic.List%601.Item%2A&gt;</ph> as a default property, which provides the same indexing functionality.</source>
          <target state="translated">Visual Basic implementa <ph id="ph1">&lt;xref:System.Collections.Generic.List%601.Item%2A&gt;</ph> como propiedad predeterminada, lo que proporciona la misma funcionalidad de indización.</target>       </trans-unit>
        <trans-unit id="787" translate="yes" xml:space="preserve" uid="P:System.Collections.Generic.List`1.Item(System.Int32)">
          <source><ph id="ph1">&lt;paramref name="index" /&gt;</ph> is less than 0.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="index" /&gt;</ph> es menor que 0.</target>       </trans-unit>
        <trans-unit id="788" translate="yes" xml:space="preserve" uid="P:System.Collections.Generic.List`1.Item(System.Int32)">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="789" translate="yes" xml:space="preserve" uid="P:System.Collections.Generic.List`1.Item(System.Int32)">
          <source><ph id="ph1">&lt;paramref name="index" /&gt;</ph> is equal to or greater than <ph id="ph2">&lt;see cref="P:System.Collections.Generic.List`1.Count" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="index" /&gt;</ph> es igual o mayor que <ph id="ph2">&lt;see cref="P:System.Collections.Generic.List`1.Count" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="790" translate="yes" xml:space="preserve" uid="T:System.Collections.Generic.List`1">
          <source>Returns the zero-based index of the last occurrence of a value in the <ph id="ph1">&lt;see cref="T:System.Collections.Generic.List`1" /&gt;</ph> or in a portion of it.</source>
          <target state="translated">Devuelve el índice de base cero de la última aparición de un valor en la <ph id="ph1">&lt;see cref="T:System.Collections.Generic.List`1" /&gt;</ph> o en una parte de ella.</target>       </trans-unit>
        <trans-unit id="791" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.List`1.LastIndexOf(`0)">
          <source>The object to locate in the <ph id="ph1">&lt;see cref="T:System.Collections.Generic.List`1" /&gt;</ph>.</source>
          <target state="translated">Objeto que se va a buscar en <ph id="ph1">&lt;see cref="T:System.Collections.Generic.List`1" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="792" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.List`1.LastIndexOf(`0)">
          <source>The value can be <ph id="ph1">&lt;see langword="null" /&gt;</ph> for reference types.</source>
          <target state="translated">El valor puede ser <ph id="ph1">&lt;see langword="null" /&gt;</ph> para los tipos de referencia.</target>       </trans-unit>
        <trans-unit id="793" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.List`1.LastIndexOf(`0)">
          <source>Searches for the specified object and returns the zero-based index of the last occurrence within the entire <ph id="ph1">&lt;see cref="T:System.Collections.Generic.List`1" /&gt;</ph>.</source>
          <target state="translated">Busca el objeto especificado y devuelve el índice de base cero de la última aparición en toda la <ph id="ph1">&lt;see cref="T:System.Collections.Generic.List`1" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="794" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.List`1.LastIndexOf(`0)">
          <source>The zero-based index of the last occurrence of <ph id="ph1">&lt;paramref name="item" /&gt;</ph> within the entire the <ph id="ph2">&lt;see cref="T:System.Collections.Generic.List`1" /&gt;</ph>, if found; otherwise, –1.</source>
          <target state="translated">Índice de base cero de la última aparición de <ph id="ph1">&lt;paramref name="item" /&gt;</ph> en toda la <ph id="ph2">&lt;see cref="T:System.Collections.Generic.List`1" /&gt;</ph>, si se encuentra; en caso contrario, -1.</target>       </trans-unit>
        <trans-unit id="795" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.LastIndexOf(`0)">
          <source>The <ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph> is searched backward starting at the last element and ending at the first element.</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph> se realiza hacia atrás, empezando en el último elemento y terminando en el primer elemento.</target>       </trans-unit>
        <trans-unit id="796" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.LastIndexOf(`0)">
          <source>This method determines equality using the default equality comparer <ph id="ph1">&lt;xref:System.Collections.Generic.EqualityComparer%601.Default%2A?displayProperty=nameWithType&gt;</ph> for <ph id="ph2">`T`</ph>, the type of values in the list.</source>
          <target state="translated">Este método determina la igualdad utilizando el comparador de igualdad predeterminado <ph id="ph1">&lt;xref:System.Collections.Generic.EqualityComparer%601.Default%2A?displayProperty=nameWithType&gt;</ph> para <ph id="ph2">`T`</ph>, el tipo de valores de la lista.</target>       </trans-unit>
        <trans-unit id="797" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.LastIndexOf(`0)">
          <source>This method performs a linear search; therefore, this method is an O(<bpt id="p1">*</bpt>n<ept id="p1">*</ept>) operation, where <bpt id="p2">*</bpt>n<ept id="p2">*</ept> is <ph id="ph1">&lt;xref:System.Collections.Generic.List%601.Count%2A&gt;</ph>.</source>
          <target state="translated">Este método realiza una búsqueda lineal; por lo tanto, este método es una O (<bpt id="p1">*</bpt>n<ept id="p1">*</ept>) operación, donde <bpt id="p2">*</bpt>n<ept id="p2">*</ept> es <ph id="ph1">&lt;xref:System.Collections.Generic.List%601.Count%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="798" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.LastIndexOf(`0)">
          <source>The following example demonstrates all three overloads of the <ph id="ph1">&lt;xref:System.Collections.Generic.List%601.LastIndexOf%2A&gt;</ph> method.</source>
          <target state="translated">En el ejemplo siguiente se muestra las tres sobrecargas de la <ph id="ph1">&lt;xref:System.Collections.Generic.List%601.LastIndexOf%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="799" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.LastIndexOf(`0)">
          <source>A <ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph> of strings is created, with one entry that appears twice, at index location 0 and index location 5.</source>
          <target state="translated">Un <ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph> de cadenas se crea, con una entrada que aparece dos veces, en la ubicación de índice 0 y la ubicación de índice 5.</target>       </trans-unit>
        <trans-unit id="800" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.LastIndexOf(`0)">
          <source>The <ph id="ph1">&lt;xref:System.Collections.Generic.List%601.LastIndexOf%28%600%29&gt;</ph> method overload searches the entire list from the end, and finds the second occurrence of the string.</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.Collections.Generic.List%601.LastIndexOf%28%600%29&gt;</ph> sobrecarga del método busca en toda la lista desde el final y encuentra la segunda aparición de la cadena.</target>       </trans-unit>
        <trans-unit id="801" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.LastIndexOf(`0)">
          <source>The <ph id="ph1">&lt;xref:System.Collections.Generic.List%601.LastIndexOf%28%600%2CSystem.Int32%29&gt;</ph> method overload is used to search the list backward beginning with index location 3 and continuing to the beginning of the list, so it finds the first occurrence of the string in the list.</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.Collections.Generic.List%601.LastIndexOf%28%600%2CSystem.Int32%29&gt;</ph> sobrecarga del método se utiliza para buscar la lista hacia atrás a partir de la posición de índice 3 y continuando hasta el principio de la lista, por lo que busca la primera aparición de la cadena en la lista.</target>       </trans-unit>
        <trans-unit id="802" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.LastIndexOf(`0)">
          <source>Finally, the <ph id="ph1">&lt;xref:System.Collections.Generic.List%601.LastIndexOf%28%600%2CSystem.Int32%2CSystem.Int32%29&gt;</ph> method overload is used to search a range of four entries, beginning at index location 4 and extending backward (that is, it searches the items at locations 4, 3, 2, and 1); this search returns –1 because there are no instances of the search string in that range.</source>
          <target state="translated">Por último, el <ph id="ph1">&lt;xref:System.Collections.Generic.List%601.LastIndexOf%28%600%2CSystem.Int32%2CSystem.Int32%29&gt;</ph> sobrecarga del método se utiliza para buscar un intervalo de cuatro entradas, comenzando en la posición de índice 4 y avanzando hacia atrás (es decir, busca en los elementos en ubicaciones 4, 3, 2 y 1); esta búsqueda devuelve – 1 porque no hay ninguna instancia de la búsqueda cadena en ese intervalo.</target>       </trans-unit>
        <trans-unit id="803" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.List`1.LastIndexOf(`0,System.Int32)">
          <source>The object to locate in the <ph id="ph1">&lt;see cref="T:System.Collections.Generic.List`1" /&gt;</ph>.</source>
          <target state="translated">Objeto que se va a buscar en <ph id="ph1">&lt;see cref="T:System.Collections.Generic.List`1" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="804" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.List`1.LastIndexOf(`0,System.Int32)">
          <source>The value can be <ph id="ph1">&lt;see langword="null" /&gt;</ph> for reference types.</source>
          <target state="translated">El valor puede ser <ph id="ph1">&lt;see langword="null" /&gt;</ph> para los tipos de referencia.</target>       </trans-unit>
        <trans-unit id="805" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.List`1.LastIndexOf(`0,System.Int32)">
          <source>The zero-based starting index of the backward search.</source>
          <target state="translated">Índice inicial de base cero de la búsqueda hacia atrás.</target>       </trans-unit>
        <trans-unit id="806" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.List`1.LastIndexOf(`0,System.Int32)">
          <source>Searches for the specified object and returns the zero-based index of the last occurrence within the range of elements in the <ph id="ph1">&lt;see cref="T:System.Collections.Generic.List`1" /&gt;</ph> that extends from the first element to the specified index.</source>
          <target state="translated">Busca el objeto especificado y devuelve el índice de base cero de la última aparición dentro del intervalo de elementos de <ph id="ph1">&lt;see cref="T:System.Collections.Generic.List`1" /&gt;</ph> que abarca desde el primer elemento hasta el último índice especificado.</target>       </trans-unit>
        <trans-unit id="807" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.List`1.LastIndexOf(`0,System.Int32)">
          <source>The zero-based index of the last occurrence of <ph id="ph1">&lt;paramref name="item" /&gt;</ph> within the range of elements in the <ph id="ph2">&lt;see cref="T:System.Collections.Generic.List`1" /&gt;</ph> that extends from the first element to <ph id="ph3">&lt;paramref name="index" /&gt;</ph>, if found; otherwise, –1.</source>
          <target state="translated">Índice de base cero de la última aparición de <ph id="ph1">&lt;paramref name="item" /&gt;</ph> dentro del intervalo de elementos de <ph id="ph2">&lt;see cref="T:System.Collections.Generic.List`1" /&gt;</ph> que abarca desde el primer elemento hasta <ph id="ph3">&lt;paramref name="index" /&gt;</ph>, si se encuentra; en caso contrario, -1.</target>       </trans-unit>
        <trans-unit id="808" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.LastIndexOf(`0,System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph> is searched backward starting at <ph id="ph2">`index`</ph> and ending at the first element.</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph> es la búsqueda hacia atrás, empezando en <ph id="ph2">`index`</ph> y finaliza con el primer elemento.</target>       </trans-unit>
        <trans-unit id="809" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.LastIndexOf(`0,System.Int32)">
          <source>This method determines equality using the default equality comparer <ph id="ph1">&lt;xref:System.Collections.Generic.EqualityComparer%601.Default%2A?displayProperty=nameWithType&gt;</ph> for <ph id="ph2">`T`</ph>, the type of values in the list.</source>
          <target state="translated">Este método determina la igualdad utilizando el comparador de igualdad predeterminado <ph id="ph1">&lt;xref:System.Collections.Generic.EqualityComparer%601.Default%2A?displayProperty=nameWithType&gt;</ph> para <ph id="ph2">`T`</ph>, el tipo de valores de la lista.</target>       </trans-unit>
        <trans-unit id="810" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.LastIndexOf(`0,System.Int32)">
          <source>This method performs a linear search; therefore, this method is an O(<bpt id="p1">*</bpt>n<ept id="p1">*</ept>) operation, where <bpt id="p2">*</bpt>n<ept id="p2">*</ept> is the number of elements from the beginning of the <ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph> to <ph id="ph2">`index`</ph>.</source>
          <target state="translated">Este método realiza una búsqueda lineal; por lo tanto, este método es una O (<bpt id="p1">*</bpt>n<ept id="p1">*</ept>) operación, donde <bpt id="p2">*</bpt>n<ept id="p2">*</ept> es el número de elementos desde el principio de la <ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph> a <ph id="ph2">`index`</ph>.</target>       </trans-unit>
        <trans-unit id="811" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.LastIndexOf(`0,System.Int32)">
          <source>The following example demonstrates all three overloads of the <ph id="ph1">&lt;xref:System.Collections.Generic.List%601.LastIndexOf%2A&gt;</ph> method.</source>
          <target state="translated">En el ejemplo siguiente se muestra las tres sobrecargas de la <ph id="ph1">&lt;xref:System.Collections.Generic.List%601.LastIndexOf%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="812" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.LastIndexOf(`0,System.Int32)">
          <source>A <ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph> of strings is created, with one entry that appears twice, at index location 0 and index location 5.</source>
          <target state="translated">Un <ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph> de cadenas se crea, con una entrada que aparece dos veces, en la ubicación de índice 0 y la ubicación de índice 5.</target>       </trans-unit>
        <trans-unit id="813" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.LastIndexOf(`0,System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.Collections.Generic.List%601.LastIndexOf%28%600%29&gt;</ph> method overload searches the entire list from the end, and finds the second occurrence of the string.</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.Collections.Generic.List%601.LastIndexOf%28%600%29&gt;</ph> sobrecarga del método busca en toda la lista desde el final y encuentra la segunda aparición de la cadena.</target>       </trans-unit>
        <trans-unit id="814" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.LastIndexOf(`0,System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.Collections.Generic.List%601.LastIndexOf%28%600%2CSystem.Int32%29&gt;</ph> method overload is used to search the list backward beginning with index location 3 and continuing to the beginning of the list, so it finds the first occurrence of the string in the list.</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.Collections.Generic.List%601.LastIndexOf%28%600%2CSystem.Int32%29&gt;</ph> sobrecarga del método se utiliza para buscar la lista hacia atrás a partir de la posición de índice 3 y continuando hasta el principio de la lista, por lo que busca la primera aparición de la cadena en la lista.</target>       </trans-unit>
        <trans-unit id="815" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.LastIndexOf(`0,System.Int32)">
          <source>Finally, the <ph id="ph1">&lt;xref:System.Collections.Generic.List%601.LastIndexOf%28%600%2CSystem.Int32%2CSystem.Int32%29&gt;</ph> method overload is used to search a range of four entries, beginning at index location 4 and extending backward (that is, it searches the items at locations 4, 3, 2, and 1); this search returns –1 because there are no instances of the search string in that range.</source>
          <target state="translated">Por último, el <ph id="ph1">&lt;xref:System.Collections.Generic.List%601.LastIndexOf%28%600%2CSystem.Int32%2CSystem.Int32%29&gt;</ph> sobrecarga del método se utiliza para buscar un intervalo de cuatro entradas, comenzando en la posición de índice 4 y avanzando hacia atrás (es decir, busca en los elementos en ubicaciones 4, 3, 2 y 1); esta búsqueda devuelve – 1 porque no hay ninguna instancia de la búsqueda cadena en ese intervalo.</target>       </trans-unit>
        <trans-unit id="816" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.List`1.LastIndexOf(`0,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="index" /&gt;</ph> is outside the range of valid indexes for the <ph id="ph2">&lt;see cref="T:System.Collections.Generic.List`1" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="index" /&gt;</ph> está fuera del intervalo de índices válidos para <ph id="ph2">&lt;see cref="T:System.Collections.Generic.List`1" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="817" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.List`1.LastIndexOf(`0,System.Int32,System.Int32)">
          <source>The object to locate in the <ph id="ph1">&lt;see cref="T:System.Collections.Generic.List`1" /&gt;</ph>.</source>
          <target state="translated">Objeto que se va a buscar en <ph id="ph1">&lt;see cref="T:System.Collections.Generic.List`1" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="818" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.List`1.LastIndexOf(`0,System.Int32,System.Int32)">
          <source>The value can be <ph id="ph1">&lt;see langword="null" /&gt;</ph> for reference types.</source>
          <target state="translated">El valor puede ser <ph id="ph1">&lt;see langword="null" /&gt;</ph> para los tipos de referencia.</target>       </trans-unit>
        <trans-unit id="819" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.List`1.LastIndexOf(`0,System.Int32,System.Int32)">
          <source>The zero-based starting index of the backward search.</source>
          <target state="translated">Índice inicial de base cero de la búsqueda hacia atrás.</target>       </trans-unit>
        <trans-unit id="820" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.List`1.LastIndexOf(`0,System.Int32,System.Int32)">
          <source>The number of elements in the section to search.</source>
          <target state="translated">Número de elementos de la sección en la que se va a realizar la búsqueda.</target>       </trans-unit>
        <trans-unit id="821" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.List`1.LastIndexOf(`0,System.Int32,System.Int32)">
          <source>Searches for the specified object and returns the zero-based index of the last occurrence within the range of elements in the <ph id="ph1">&lt;see cref="T:System.Collections.Generic.List`1" /&gt;</ph> that contains the specified number of elements and ends at the specified index.</source>
          <target state="translated">Busca el objeto especificado y devuelve el índice de base cero de la última aparición dentro del intervalo de elementos de <ph id="ph1">&lt;see cref="T:System.Collections.Generic.List`1" /&gt;</ph> que contiene el número de elementos especificado y termina en el índice determinado.</target>       </trans-unit>
        <trans-unit id="822" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.List`1.LastIndexOf(`0,System.Int32,System.Int32)">
          <source>The zero-based index of the last occurrence of <ph id="ph1">&lt;paramref name="item" /&gt;</ph> within the range of elements in the <ph id="ph2">&lt;see cref="T:System.Collections.Generic.List`1" /&gt;</ph> that contains <ph id="ph3">&lt;paramref name="count" /&gt;</ph> number of elements and ends at <ph id="ph4">&lt;paramref name="index" /&gt;</ph>, if found; otherwise, –1.</source>
          <target state="translated">Índice de base cero de la última aparición de <ph id="ph1">&lt;paramref name="item" /&gt;</ph> dentro del intervalo de elementos de <ph id="ph2">&lt;see cref="T:System.Collections.Generic.List`1" /&gt;</ph> que contiene el número de elementos de <ph id="ph3">&lt;paramref name="count" /&gt;</ph> y termina en <ph id="ph4">&lt;paramref name="index" /&gt;</ph>, si se encuentra; en caso contrario, -1.</target>       </trans-unit>
        <trans-unit id="823" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.LastIndexOf(`0,System.Int32,System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph> is searched backward starting at <ph id="ph2">`index`</ph> and ending at <ph id="ph3">`index`</ph> minus <ph id="ph4">`count`</ph> plus 1, if <ph id="ph5">`count`</ph> is greater than 0.</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph> es la búsqueda hacia atrás, empezando en <ph id="ph2">`index`</ph> y terminando en <ph id="ph3">`index`</ph> menos <ph id="ph4">`count`</ph> más 1, si <ph id="ph5">`count`</ph> es mayor que 0.</target>       </trans-unit>
        <trans-unit id="824" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.LastIndexOf(`0,System.Int32,System.Int32)">
          <source>This method determines equality using the default equality comparer <ph id="ph1">&lt;xref:System.Collections.Generic.EqualityComparer%601.Default%2A?displayProperty=nameWithType&gt;</ph> for <ph id="ph2">`T`</ph>, the type of values in the list.</source>
          <target state="translated">Este método determina la igualdad utilizando el comparador de igualdad predeterminado <ph id="ph1">&lt;xref:System.Collections.Generic.EqualityComparer%601.Default%2A?displayProperty=nameWithType&gt;</ph> para <ph id="ph2">`T`</ph>, el tipo de valores de la lista.</target>       </trans-unit>
        <trans-unit id="825" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.LastIndexOf(`0,System.Int32,System.Int32)">
          <source>This method performs a linear search; therefore, this method is an O(<bpt id="p1">*</bpt>n<ept id="p1">*</ept>) operation, where <bpt id="p2">*</bpt>n<ept id="p2">*</ept> is <ph id="ph1">`count`</ph>.</source>
          <target state="translated">Este método realiza una búsqueda lineal; por lo tanto, este método es una O (<bpt id="p1">*</bpt>n<ept id="p1">*</ept>) operación, donde <bpt id="p2">*</bpt>n<ept id="p2">*</ept> es <ph id="ph1">`count`</ph>.</target>       </trans-unit>
        <trans-unit id="826" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.LastIndexOf(`0,System.Int32,System.Int32)">
          <source>The following example demonstrates all three overloads of the <ph id="ph1">&lt;xref:System.Collections.Generic.List%601.LastIndexOf%2A&gt;</ph> method.</source>
          <target state="translated">En el ejemplo siguiente se muestra las tres sobrecargas de la <ph id="ph1">&lt;xref:System.Collections.Generic.List%601.LastIndexOf%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="827" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.LastIndexOf(`0,System.Int32,System.Int32)">
          <source>A <ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph> of strings is created, with one entry that appears twice, at index location 0 and index location 5.</source>
          <target state="translated">Un <ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph> de cadenas se crea, con una entrada que aparece dos veces, en la ubicación de índice 0 y la ubicación de índice 5.</target>       </trans-unit>
        <trans-unit id="828" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.LastIndexOf(`0,System.Int32,System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.Collections.Generic.List%601.LastIndexOf%28%600%29&gt;</ph> method overload searches the entire list from the end, and finds the second occurrence of the string.</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.Collections.Generic.List%601.LastIndexOf%28%600%29&gt;</ph> sobrecarga del método busca en toda la lista desde el final y encuentra la segunda aparición de la cadena.</target>       </trans-unit>
        <trans-unit id="829" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.LastIndexOf(`0,System.Int32,System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.Collections.Generic.List%601.LastIndexOf%28%600%2CSystem.Int32%29&gt;</ph> method overload is used to search the list backward beginning with index location 3 and continuing to the beginning of the list, so it finds the first occurrence of the string in the list.</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.Collections.Generic.List%601.LastIndexOf%28%600%2CSystem.Int32%29&gt;</ph> sobrecarga del método se utiliza para buscar la lista hacia atrás a partir de la posición de índice 3 y continuando hasta el principio de la lista, por lo que busca la primera aparición de la cadena en la lista.</target>       </trans-unit>
        <trans-unit id="830" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.LastIndexOf(`0,System.Int32,System.Int32)">
          <source>Finally, the <ph id="ph1">&lt;xref:System.Collections.Generic.List%601.LastIndexOf%28%600%2CSystem.Int32%2CSystem.Int32%29&gt;</ph> method overload is used to search a range of 4 entries, beginning at index location 4 and extending backward (that is, it searches the items at locations 4, 3, 2, and 1); this search returns –1 because there are no instances of the search string in that range.</source>
          <target state="translated">Por último, el <ph id="ph1">&lt;xref:System.Collections.Generic.List%601.LastIndexOf%28%600%2CSystem.Int32%2CSystem.Int32%29&gt;</ph> sobrecarga del método se utiliza para buscar un intervalo de 4 entradas, comenzando en la posición de índice 4 y avanzando hacia atrás (es decir, busca en los elementos en ubicaciones 4, 3, 2 y 1); esta búsqueda devuelve – 1 porque no hay ninguna instancia de la búsqueda cadena en ese intervalo.</target>       </trans-unit>
        <trans-unit id="831" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.List`1.LastIndexOf(`0,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="index" /&gt;</ph> is outside the range of valid indexes for the <ph id="ph2">&lt;see cref="T:System.Collections.Generic.List`1" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="index" /&gt;</ph> está fuera del intervalo de índices válidos para <ph id="ph2">&lt;see cref="T:System.Collections.Generic.List`1" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="832" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.List`1.LastIndexOf(`0,System.Int32,System.Int32)">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="833" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.List`1.LastIndexOf(`0,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="count" /&gt;</ph> is less than 0.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="count" /&gt;</ph> es menor que 0.</target>       </trans-unit>
        <trans-unit id="834" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.List`1.LastIndexOf(`0,System.Int32,System.Int32)">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="835" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.List`1.LastIndexOf(`0,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="index" /&gt;</ph> and <ph id="ph2">&lt;paramref name="count" /&gt;</ph> do not specify a valid section in the <ph id="ph3">&lt;see cref="T:System.Collections.Generic.List`1" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="index" /&gt;</ph> y <ph id="ph2">&lt;paramref name="count" /&gt;</ph> no especifican una sección válida en <ph id="ph3">&lt;see cref="T:System.Collections.Generic.List`1" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="836" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.List`1.Remove(`0)">
          <source>The object to remove from the <ph id="ph1">&lt;see cref="T:System.Collections.Generic.List`1" /&gt;</ph>.</source>
          <target state="translated">Objeto que se va a quitar de <ph id="ph1">&lt;see cref="T:System.Collections.Generic.List`1" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="837" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.List`1.Remove(`0)">
          <source>The value can be <ph id="ph1">&lt;see langword="null" /&gt;</ph> for reference types.</source>
          <target state="translated">El valor puede ser <ph id="ph1">&lt;see langword="null" /&gt;</ph> para los tipos de referencia.</target>       </trans-unit>
        <trans-unit id="838" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.List`1.Remove(`0)">
          <source>Removes the first occurrence of a specific object from the <ph id="ph1">&lt;see cref="T:System.Collections.Generic.List`1" /&gt;</ph>.</source>
          <target state="translated">Quita la primera aparición de un objeto específico de la interfaz <ph id="ph1">&lt;see cref="T:System.Collections.Generic.List`1" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="839" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.List`1.Remove(`0)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if <ph id="ph2">&lt;paramref name="item" /&gt;</ph> is successfully removed; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> si <ph id="ph2">&lt;paramref name="item" /&gt;</ph> se quita correctamente; en caso contrario, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="840" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.List`1.Remove(`0)">
          <source>This method also returns <ph id="ph1">&lt;see langword="false" /&gt;</ph> if <ph id="ph2">&lt;paramref name="item" /&gt;</ph> was not found in the <ph id="ph3">&lt;see cref="T:System.Collections.Generic.List`1" /&gt;</ph>.</source>
          <target state="translated">Este método también devuelve <ph id="ph1">&lt;see langword="false" /&gt;</ph> si no se encuentra <ph id="ph2">&lt;paramref name="item" /&gt;</ph> en <ph id="ph3">&lt;see cref="T:System.Collections.Generic.List`1" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="841" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.Remove(`0)">
          <source>If type <ph id="ph1">`T`</ph> implements the <ph id="ph2">&lt;xref:System.IEquatable%601&gt;</ph> generic interface, the equality comparer is the <ph id="ph3">&lt;xref:System.IEquatable%601.Equals%2A&gt;</ph> method of that interface; otherwise, the default equality comparer is <ph id="ph4">&lt;xref:System.Object.Equals%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Si tipo <ph id="ph1">`T`</ph> implementa la <ph id="ph2">&lt;xref:System.IEquatable%601&gt;</ph> el comparador de igualdad es la interfaz genérica, la <ph id="ph3">&lt;xref:System.IEquatable%601.Equals%2A&gt;</ph> método de dicha interfaz; en caso contrario, el comparador de igualdad predeterminado es <ph id="ph4">&lt;xref:System.Object.Equals%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="842" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.Remove(`0)">
          <source>This method performs a linear search; therefore, this method is an O(<bpt id="p1">*</bpt>n<ept id="p1">*</ept>) operation, where <bpt id="p2">*</bpt>n<ept id="p2">*</ept> is <ph id="ph1">&lt;xref:System.Collections.Generic.List%601.Count%2A&gt;</ph>.</source>
          <target state="translated">Este método realiza una búsqueda lineal; por lo tanto, este método es una O (<bpt id="p1">*</bpt>n<ept id="p1">*</ept>) operación, donde <bpt id="p2">*</bpt>n<ept id="p2">*</ept> es <ph id="ph1">&lt;xref:System.Collections.Generic.List%601.Count%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="843" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.Remove(`0)">
          <source>The following example demonstrates how to add, remove, and insert a simple business object in a <ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph>.</source>
          <target state="translated">En el ejemplo siguiente se muestra cómo agregar, quitar e insertar un objeto comercial simple en una <ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="844" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.Remove(`0)">
          <source>The following example demonstrates <ph id="ph1">&lt;xref:System.Collections.Generic.List%601.Remove%2A&gt;</ph> method.</source>
          <target state="translated">En el ejemplo siguiente se muestra <ph id="ph1">&lt;xref:System.Collections.Generic.List%601.Remove%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="845" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.Remove(`0)">
          <source>Several properties and methods of the <ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph> generic class are used to add, insert, and search the list.</source>
          <target state="translated">Varias propiedades y métodos de la <ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph> clase genérica sirven para agregar, insertar y buscar en la lista.</target>       </trans-unit>
        <trans-unit id="846" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.Remove(`0)">
          <source>After these operations, the list contains a duplicate.</source>
          <target state="translated">Después de estas operaciones, la lista contiene un duplicado.</target>       </trans-unit>
        <trans-unit id="847" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.Remove(`0)">
          <source>The <ph id="ph1">&lt;xref:System.Collections.Generic.List%601.Remove%2A&gt;</ph> method is used to remove the first instance of the duplicate item, and the contents are displayed.</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.Collections.Generic.List%601.Remove%2A&gt;</ph> método se utiliza para quitar la primera instancia del elemento duplicado y se muestra el contenido.</target>       </trans-unit>
        <trans-unit id="848" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.Remove(`0)">
          <source>The <ph id="ph1">&lt;xref:System.Collections.Generic.List%601.Remove%2A&gt;</ph> method always removes the first instance it encounters.</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.Collections.Generic.List%601.Remove%2A&gt;</ph> método siempre quita la primera instancia que encuentra.</target>       </trans-unit>
        <trans-unit id="849" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.List`1.RemoveAll(System.Predicate{`0})">
          <source>The <ph id="ph1">&lt;see cref="T:System.Predicate`1" /&gt;</ph> delegate that defines the conditions of the elements to remove.</source>
          <target state="translated">Delegado <ph id="ph1">&lt;see cref="T:System.Predicate`1" /&gt;</ph> que define las condiciones de los elementos que se van a quitar.</target>       </trans-unit>
        <trans-unit id="850" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.List`1.RemoveAll(System.Predicate{`0})">
          <source>Removes all the elements that match the conditions defined by the specified predicate.</source>
          <target state="translated">Quita todos los elementos que cumplen las condiciones definidas por el predicado especificado.</target>       </trans-unit>
        <trans-unit id="851" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.List`1.RemoveAll(System.Predicate{`0})">
          <source>The number of elements removed from the <ph id="ph1">&lt;see cref="T:System.Collections.Generic.List`1" /&gt;</ph> .</source>
          <target state="translated">Número de elementos que se han quitado de <ph id="ph1">&lt;see cref="T:System.Collections.Generic.List`1" /&gt;</ph> .</target>       </trans-unit>
        <trans-unit id="852" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.RemoveAll(System.Predicate{`0})">
          <source>The <ph id="ph1">&lt;xref:System.Predicate%601&gt;</ph> is a delegate to a method that returns <ph id="ph2">`true`</ph> if the object passed to it matches the conditions defined in the delegate.</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.Predicate%601&gt;</ph> es un delegado a un método que devuelve <ph id="ph2">`true`</ph> si el objeto pasado a coincide con las condiciones definidas en el delegado.</target>       </trans-unit>
        <trans-unit id="853" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.RemoveAll(System.Predicate{`0})">
          <source>The elements of the current <ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph> are individually passed to the <ph id="ph2">&lt;xref:System.Predicate%601&gt;</ph> delegate, and the elements that match the conditions are removed from the <ph id="ph3">&lt;xref:System.Collections.Generic.List%601&gt;</ph>.</source>
          <target state="translated">Los elementos del elemento actual <ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph> se pasan individualmente a la <ph id="ph2">&lt;xref:System.Predicate%601&gt;</ph> delegado y los elementos que cumplen las condiciones se quitan de la <ph id="ph3">&lt;xref:System.Collections.Generic.List%601&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="854" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.RemoveAll(System.Predicate{`0})">
          <source>This method performs a linear search; therefore, this method is an O(<bpt id="p1">*</bpt>n<ept id="p1">*</ept>) operation, where <bpt id="p2">*</bpt>n<ept id="p2">*</ept> is <ph id="ph1">&lt;xref:System.Collections.Generic.List%601.Count%2A&gt;</ph>.</source>
          <target state="translated">Este método realiza una búsqueda lineal; por lo tanto, este método es una O (<bpt id="p1">*</bpt>n<ept id="p1">*</ept>) operación, donde <bpt id="p2">*</bpt>n<ept id="p2">*</ept> es <ph id="ph1">&lt;xref:System.Collections.Generic.List%601.Count%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="855" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.RemoveAll(System.Predicate{`0})">
          <source>The following example demonstrates the <ph id="ph1">&lt;xref:System.Collections.Generic.List%601.RemoveAll%2A&gt;</ph> method and several other methods that use the <ph id="ph2">&lt;xref:System.Predicate%601&gt;</ph> generic delegate.</source>
          <target state="translated">En el ejemplo siguiente se muestra la <ph id="ph1">&lt;xref:System.Collections.Generic.List%601.RemoveAll%2A&gt;</ph> (método) y otros métodos que utilizan el <ph id="ph2">&lt;xref:System.Predicate%601&gt;</ph> delegado genérico.</target>       </trans-unit>
        <trans-unit id="856" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.RemoveAll(System.Predicate{`0})">
          <source>A <ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph> of strings is created, containing 8 dinosaur names, two of which (at positions 1 and 5) end with "saurus".</source>
          <target state="translated">Un <ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph> de cadenas se crea, que contiene 8 nombres de dinosaurio, dos de los cuales (en las posiciones 1 y 5) terminan en "saurus".</target>       </trans-unit>
        <trans-unit id="857" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.RemoveAll(System.Predicate{`0})">
          <source>The example also defines a search predicate method named <ph id="ph1">`EndsWithSaurus`</ph>, which accepts a string parameter and returns a Boolean value indicating whether the input string ends in "saurus".</source>
          <target state="translated">El ejemplo también define un método de predicado de búsqueda denominado <ph id="ph1">`EndsWithSaurus`</ph>, que acepta un parámetro de cadena y devuelve un valor booleano de valor que indica si la cadena de entrada termina en "saurus".</target>       </trans-unit>
        <trans-unit id="858" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.RemoveAll(System.Predicate{`0})">
          <source>The <ph id="ph1">&lt;xref:System.Collections.Generic.List%601.Find%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Collections.Generic.List%601.FindLast%2A&gt;</ph>, and <ph id="ph3">&lt;xref:System.Collections.Generic.List%601.FindAll%2A&gt;</ph> methods are used to search the list with the search predicate method.</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.Collections.Generic.List%601.Find%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Collections.Generic.List%601.FindLast%2A&gt;</ph>, y <ph id="ph3">&lt;xref:System.Collections.Generic.List%601.FindAll%2A&gt;</ph> métodos se usan para buscar la lista con el método de predicado de búsqueda.</target>       </trans-unit>
        <trans-unit id="859" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.RemoveAll(System.Predicate{`0})">
          <source>The <ph id="ph1">&lt;xref:System.Collections.Generic.List%601.RemoveAll%2A&gt;</ph> method is used to remove all entries ending with "saurus".</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.Collections.Generic.List%601.RemoveAll%2A&gt;</ph> método se utiliza para quitar todas las entradas que terminen en "saurus".</target>       </trans-unit>
        <trans-unit id="860" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.RemoveAll(System.Predicate{`0})">
          <source>It traverses the list from the beginning, passing each element in turn to the <ph id="ph1">`EndsWithSaurus`</ph> method.</source>
          <target state="translated">Recorre la lista desde el principio, pasando cada elemento a su vez a la <ph id="ph1">`EndsWithSaurus`</ph> método.</target>       </trans-unit>
        <trans-unit id="861" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.RemoveAll(System.Predicate{`0})">
          <source>The element is removed if the <ph id="ph1">`EndsWithSaurus`</ph> method returns <ph id="ph2">`true`</ph>.</source>
          <target state="translated">El elemento se quita si la <ph id="ph1">`EndsWithSaurus`</ph> método <ph id="ph2">`true`</ph>.</target>       </trans-unit>
        <trans-unit id="862" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.RemoveAll(System.Predicate{`0})">
          <source>In C# and Visual Basic, it is not necessary to create the <ph id="ph1">`Predicate&lt;string&gt;`</ph> delegate (<ph id="ph2">`Predicate(Of String)`</ph> in Visual Basic) explicitly.</source>
          <target state="translated">En C# y Visual Basic, no es necesario crear la <ph id="ph1">`Predicate&lt;string&gt;`</ph> delegar (<ph id="ph2">`Predicate(Of String)`</ph> en Visual Basic) explícitamente.</target>       </trans-unit>
        <trans-unit id="863" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.RemoveAll(System.Predicate{`0})">
          <source>These languages infer the correct delegate from context, and create it automatically.</source>
          <target state="translated">Estos lenguajes deducen al delegado correcto del contexto y lo crean automáticamente.</target>       </trans-unit>
        <trans-unit id="864" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.RemoveAll(System.Predicate{`0})">
          <source>Finally, the <ph id="ph1">&lt;xref:System.Collections.Generic.List%601.Exists%2A&gt;</ph> method verifies that there are no strings in the list that end with "saurus".</source>
          <target state="translated">Por último, el <ph id="ph1">&lt;xref:System.Collections.Generic.List%601.Exists%2A&gt;</ph> método verifica que no hay ninguna cadena de la lista que terminan en "saurus".</target>       </trans-unit>
        <trans-unit id="865" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.List`1.RemoveAll(System.Predicate{`0})">
          <source><ph id="ph1">&lt;paramref name="match" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="match" /&gt;</ph> es <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="866" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.List`1.RemoveAt(System.Int32)">
          <source>The zero-based index of the element to remove.</source>
          <target state="translated">Índice de base cero del elemento que se va a quitar.</target>       </trans-unit>
        <trans-unit id="867" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.List`1.RemoveAt(System.Int32)">
          <source>Removes the element at the specified index of the <ph id="ph1">&lt;see cref="T:System.Collections.Generic.List`1" /&gt;</ph>.</source>
          <target state="translated">Quita el elemento situado en el índice especificado de <ph id="ph1">&lt;see cref="T:System.Collections.Generic.List`1" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="868" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.RemoveAt(System.Int32)">
          <source>When you call <ph id="ph1">&lt;xref:System.Collections.Generic.List%601.RemoveAt%2A&gt;</ph> to remove an item, the remaining items in the list are renumbered to replace the removed item.</source>
          <target state="translated">Cuando se llama a <ph id="ph1">&lt;xref:System.Collections.Generic.List%601.RemoveAt%2A&gt;</ph> para quitar un elemento, se vuelven a numerar los elementos restantes en la lista para reemplazar el elemento quitado.</target>       </trans-unit>
        <trans-unit id="869" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.RemoveAt(System.Int32)">
          <source>For example, if you remove the item at index 3, the item at index 4 is moved to the 3 position.</source>
          <target state="translated">Por ejemplo, si quita el elemento en el índice 3, el elemento situado en índice 4 se mueve a la posición 3.</target>       </trans-unit>
        <trans-unit id="870" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.RemoveAt(System.Int32)">
          <source>In addition, the number of items in the list (as represented by the <ph id="ph1">&lt;xref:System.Collections.Generic.List%601.Count%2A&gt;</ph> property) is reduced by 1.</source>
          <target state="translated">Además, el número de elementos de la lista (tal como está representado por la <ph id="ph1">&lt;xref:System.Collections.Generic.List%601.Count%2A&gt;</ph> propiedad) se reduce en 1.</target>       </trans-unit>
        <trans-unit id="871" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.RemoveAt(System.Int32)">
          <source>This method is an O(<bpt id="p1">*</bpt>n<ept id="p1">*</ept>) operation, where <bpt id="p2">*</bpt>n<ept id="p2">*</ept> is (<ph id="ph1">&lt;xref:System.Collections.Generic.List%601.Count%2A&gt;</ph><ph id="ph2"> - </ph><ph id="ph3">`index`</ph>).</source>
          <target state="translated">Este método es una O (<bpt id="p1">*</bpt>n<ept id="p1">*</ept>) operación, donde <bpt id="p2">*</bpt>n<ept id="p2">*</ept> es (<ph id="ph1">&lt;xref:System.Collections.Generic.List%601.Count%2A&gt;</ph><ph id="ph2"> - </ph><ph id="ph3">`index`</ph>).</target>       </trans-unit>
        <trans-unit id="872" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.RemoveAt(System.Int32)">
          <source>The following example demonstrates how to add, remove, and insert a simple business object in a <ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph>.</source>
          <target state="translated">En el ejemplo siguiente se muestra cómo agregar, quitar e insertar un objeto comercial simple en una <ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="873" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.List`1.RemoveAt(System.Int32)">
          <source><ph id="ph1">&lt;paramref name="index" /&gt;</ph> is less than 0.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="index" /&gt;</ph> es menor que 0.</target>       </trans-unit>
        <trans-unit id="874" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.List`1.RemoveAt(System.Int32)">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="875" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.List`1.RemoveAt(System.Int32)">
          <source><ph id="ph1">&lt;paramref name="index" /&gt;</ph> is equal to or greater than <ph id="ph2">&lt;see cref="P:System.Collections.Generic.List`1.Count" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="index" /&gt;</ph> es igual o mayor que <ph id="ph2">&lt;see cref="P:System.Collections.Generic.List`1.Count" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="876" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.List`1.RemoveRange(System.Int32,System.Int32)">
          <source>The zero-based starting index of the range of elements to remove.</source>
          <target state="translated">Índice inicial de base cero del intervalo de elementos que se va a quitar.</target>       </trans-unit>
        <trans-unit id="877" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.List`1.RemoveRange(System.Int32,System.Int32)">
          <source>The number of elements to remove.</source>
          <target state="translated">Número de elementos que se va a quitar.</target>       </trans-unit>
        <trans-unit id="878" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.List`1.RemoveRange(System.Int32,System.Int32)">
          <source>Removes a range of elements from the <ph id="ph1">&lt;see cref="T:System.Collections.Generic.List`1" /&gt;</ph>.</source>
          <target state="translated">Quita todos los elementos de <ph id="ph1">&lt;see cref="T:System.Collections.Generic.List`1" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="879" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.RemoveRange(System.Int32,System.Int32)">
          <source>The items are removed and all the elements following them in the <ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph> have their indexes reduced by <ph id="ph2">`count`</ph>.</source>
          <target state="translated">Se quitan los elementos y todos los elementos siguientes en la <ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph> tienen sus índices reducidos en <ph id="ph2">`count`</ph>.</target>       </trans-unit>
        <trans-unit id="880" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.RemoveRange(System.Int32,System.Int32)">
          <source>This method is an O(<bpt id="p1">*</bpt>n<ept id="p1">*</ept>) operation, where <bpt id="p2">*</bpt>n<ept id="p2">*</ept> is <ph id="ph1">&lt;xref:System.Collections.Generic.List%601.Count%2A&gt;</ph>.</source>
          <target state="translated">Este método es una O (<bpt id="p1">*</bpt>n<ept id="p1">*</ept>) operación, donde <bpt id="p2">*</bpt>n<ept id="p2">*</ept> es <ph id="ph1">&lt;xref:System.Collections.Generic.List%601.Count%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="881" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.RemoveRange(System.Int32,System.Int32)">
          <source>The following example demonstrates the <ph id="ph1">&lt;xref:System.Collections.Generic.List%601.RemoveRange%2A&gt;</ph> method and various other methods of the <ph id="ph2">&lt;xref:System.Collections.Generic.List%601&gt;</ph> class that act on ranges.</source>
          <target state="translated">En el ejemplo siguiente se muestra la <ph id="ph1">&lt;xref:System.Collections.Generic.List%601.RemoveRange%2A&gt;</ph> método y otros métodos de la <ph id="ph2">&lt;xref:System.Collections.Generic.List%601&gt;</ph> clase que operan en intervalos.</target>       </trans-unit>
        <trans-unit id="882" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.RemoveRange(System.Int32,System.Int32)">
          <source>After the list has been created and modified, the <ph id="ph1">&lt;xref:System.Collections.Generic.List%601.RemoveRange%2A&gt;</ph> method is used to remove two elements from the list, beginning at index location 2.</source>
          <target state="translated">Después de haber creado y modificado, la lista el <ph id="ph1">&lt;xref:System.Collections.Generic.List%601.RemoveRange%2A&gt;</ph> método se usa para quitar dos elementos de la lista, comenzando en la posición de índice 2.</target>       </trans-unit>
        <trans-unit id="883" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.List`1.RemoveRange(System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="index" /&gt;</ph> is less than 0.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="index" /&gt;</ph> es menor que 0.</target>       </trans-unit>
        <trans-unit id="884" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.List`1.RemoveRange(System.Int32,System.Int32)">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="885" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.List`1.RemoveRange(System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="count" /&gt;</ph> is less than 0.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="count" /&gt;</ph> es menor que 0.</target>       </trans-unit>
        <trans-unit id="886" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.List`1.RemoveRange(System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="index" /&gt;</ph> and <ph id="ph2">&lt;paramref name="count" /&gt;</ph> do not denote a valid range of elements in the <ph id="ph3">&lt;see cref="T:System.Collections.Generic.List`1" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="index" /&gt;</ph> y <ph id="ph2">&lt;paramref name="count" /&gt;</ph> no denotan un intervalo válido de elementos en <ph id="ph3">&lt;see cref="T:System.Collections.Generic.List`1" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="887" translate="yes" xml:space="preserve" uid="T:System.Collections.Generic.List`1">
          <source>Reverses the order of the elements in the <ph id="ph1">&lt;see cref="T:System.Collections.Generic.List`1" /&gt;</ph> or a portion of it.</source>
          <target state="translated">Invierte el orden de los elementos en la <ph id="ph1">&lt;see cref="T:System.Collections.Generic.List`1" /&gt;</ph> o en una parte de ella.</target>       </trans-unit>
        <trans-unit id="888" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.List`1.Reverse">
          <source>Reverses the order of the elements in the entire <ph id="ph1">&lt;see cref="T:System.Collections.Generic.List`1" /&gt;</ph>.</source>
          <target state="translated">Invierte el orden de los elementos en la <ph id="ph1">&lt;see cref="T:System.Collections.Generic.List`1" /&gt;</ph> completa.</target>       </trans-unit>
        <trans-unit id="889" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.Reverse">
          <source>This method uses <ph id="ph1">&lt;xref:System.Array.Reverse%2A?displayProperty=nameWithType&gt;</ph> to reverse the order of the elements.</source>
          <target state="translated">Este método usa <ph id="ph1">&lt;xref:System.Array.Reverse%2A?displayProperty=nameWithType&gt;</ph> para invertir el orden de los elementos.</target>       </trans-unit>
        <trans-unit id="890" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.Reverse">
          <source>This method is an O(<bpt id="p1">*</bpt>n<ept id="p1">*</ept>) operation, where <bpt id="p2">*</bpt>n<ept id="p2">*</ept> is <ph id="ph1">&lt;xref:System.Collections.Generic.List%601.Count%2A&gt;</ph>.</source>
          <target state="translated">Este método es una O (<bpt id="p1">*</bpt>n<ept id="p1">*</ept>) operación, donde <bpt id="p2">*</bpt>n<ept id="p2">*</ept> es <ph id="ph1">&lt;xref:System.Collections.Generic.List%601.Count%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="891" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.Reverse">
          <source>The following example demonstrates both overloads of the <ph id="ph1">&lt;xref:System.Collections.Generic.List%601.Reverse%2A&gt;</ph> method.</source>
          <target state="translated">El ejemplo siguiente muestra ambas sobrecargas de la <ph id="ph1">&lt;xref:System.Collections.Generic.List%601.Reverse%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="892" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.Reverse">
          <source>The example creates a <ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph> of strings and adds six strings.</source>
          <target state="translated">El ejemplo se crea un <ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph> de cadenas y se agregan seis cadenas.</target>       </trans-unit>
        <trans-unit id="893" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.Reverse">
          <source>The <ph id="ph1">&lt;xref:System.Collections.Generic.List%601.Reverse&gt;</ph> method overload is used to reverse the list, and then the <ph id="ph2">&lt;xref:System.Collections.Generic.List%601.Reverse%28System.Int32%2CSystem.Int32%29&gt;</ph> method overload is used to reverse the middle of the list, beginning with element 1 and encompassing four elements.</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.Collections.Generic.List%601.Reverse&gt;</ph> sobrecarga del método se utiliza para invertir la lista y, a continuación, el <ph id="ph2">&lt;xref:System.Collections.Generic.List%601.Reverse%28System.Int32%2CSystem.Int32%29&gt;</ph> sobrecarga del método se utiliza para invertir la mitad de la lista, empezando con el elemento 1 y que abarcan las cuatro elementos.</target>       </trans-unit>
        <trans-unit id="894" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.List`1.Reverse(System.Int32,System.Int32)">
          <source>The zero-based starting index of the range to reverse.</source>
          <target state="translated">Índice inicial de base cero del intervalo que se va a invertir.</target>       </trans-unit>
        <trans-unit id="895" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.List`1.Reverse(System.Int32,System.Int32)">
          <source>The number of elements in the range to reverse.</source>
          <target state="translated">Número de elementos del intervalo que se va a invertir.</target>       </trans-unit>
        <trans-unit id="896" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.List`1.Reverse(System.Int32,System.Int32)">
          <source>Reverses the order of the elements in the specified range.</source>
          <target state="translated">Invierte el orden de los elementos en el intervalo especificado.</target>       </trans-unit>
        <trans-unit id="897" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.Reverse(System.Int32,System.Int32)">
          <source>This method uses <ph id="ph1">&lt;xref:System.Array.Reverse%2A?displayProperty=nameWithType&gt;</ph> to reverse the order of the elements.</source>
          <target state="translated">Este método usa <ph id="ph1">&lt;xref:System.Array.Reverse%2A?displayProperty=nameWithType&gt;</ph> para invertir el orden de los elementos.</target>       </trans-unit>
        <trans-unit id="898" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.Reverse(System.Int32,System.Int32)">
          <source>This method is an O(<bpt id="p1">*</bpt>n<ept id="p1">*</ept>) operation, where <bpt id="p2">*</bpt>n<ept id="p2">*</ept> is <ph id="ph1">&lt;xref:System.Collections.Generic.List%601.Count%2A&gt;</ph>.</source>
          <target state="translated">Este método es una O (<bpt id="p1">*</bpt>n<ept id="p1">*</ept>) operación, donde <bpt id="p2">*</bpt>n<ept id="p2">*</ept> es <ph id="ph1">&lt;xref:System.Collections.Generic.List%601.Count%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="899" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.Reverse(System.Int32,System.Int32)">
          <source>The following example demonstrates both overloads of the <ph id="ph1">&lt;xref:System.Collections.Generic.List%601.Reverse%2A&gt;</ph> method.</source>
          <target state="translated">El ejemplo siguiente muestra ambas sobrecargas de la <ph id="ph1">&lt;xref:System.Collections.Generic.List%601.Reverse%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="900" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.Reverse(System.Int32,System.Int32)">
          <source>The example creates a <ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph> of strings and adds six strings.</source>
          <target state="translated">El ejemplo se crea un <ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph> de cadenas y se agregan seis cadenas.</target>       </trans-unit>
        <trans-unit id="901" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.Reverse(System.Int32,System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.Collections.Generic.List%601.Reverse&gt;</ph> method overload is used to reverse the list, and then the <ph id="ph2">&lt;xref:System.Collections.Generic.List%601.Reverse%28System.Int32%2CSystem.Int32%29&gt;</ph> method overload is used to reverse the middle of the list, beginning with element 1 and encompassing four elements.</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.Collections.Generic.List%601.Reverse&gt;</ph> sobrecarga del método se utiliza para invertir la lista y, a continuación, el <ph id="ph2">&lt;xref:System.Collections.Generic.List%601.Reverse%28System.Int32%2CSystem.Int32%29&gt;</ph> sobrecarga del método se utiliza para invertir la mitad de la lista, empezando con el elemento 1 y que abarcan las cuatro elementos.</target>       </trans-unit>
        <trans-unit id="902" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.List`1.Reverse(System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="index" /&gt;</ph> is less than 0.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="index" /&gt;</ph> es menor que 0.</target>       </trans-unit>
        <trans-unit id="903" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.List`1.Reverse(System.Int32,System.Int32)">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="904" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.List`1.Reverse(System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="count" /&gt;</ph> is less than 0.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="count" /&gt;</ph> es menor que 0.</target>       </trans-unit>
        <trans-unit id="905" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.List`1.Reverse(System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="index" /&gt;</ph> and <ph id="ph2">&lt;paramref name="count" /&gt;</ph> do not denote a valid range of elements in the <ph id="ph3">&lt;see cref="T:System.Collections.Generic.List`1" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="index" /&gt;</ph> y <ph id="ph2">&lt;paramref name="count" /&gt;</ph> no denotan un intervalo válido de elementos en <ph id="ph3">&lt;see cref="T:System.Collections.Generic.List`1" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="906" translate="yes" xml:space="preserve" uid="T:System.Collections.Generic.List`1">
          <source>Sorts the elements in the <ph id="ph1">&lt;see cref="T:System.Collections.Generic.List`1" /&gt;</ph> or a portion of it.</source>
          <target state="translated">Ordena los elementos en la <ph id="ph1">&lt;see cref="T:System.Collections.Generic.List`1" /&gt;</ph> o en una parte de ella.</target>       </trans-unit>
        <trans-unit id="907" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.Generic.List`1">
          <source>Overloaded method syntax</source>
          <target state="translated">Sintaxis del método sobrecargado</target>       </trans-unit>
        <trans-unit id="908" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.Generic.List`1">
          <source>The  <ph id="ph1">&lt;xref:System.Collections.Generic.List%601.Sort%2A&gt;</ph> methods enable you to sort with the default comparer for the object type in the list, or specify a customer sort method.</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.Collections.Generic.List%601.Sort%2A&gt;</ph> métodos permiten ordenar con el comparador predeterminado para el tipo de objeto en la lista o especificar un método de ordenación de cliente.</target>       </trans-unit>
        <trans-unit id="909" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.Generic.List`1">
          <source><bpt id="p1">[</bpt>List<ph id="ph1">\&lt;</ph>T&gt;.Sort()<ept id="p1">](xref:System.Collections.Generic.List`1.Sort*)</ept> Sorts the elements in the entire list using the default comparer of the object type held in the list.</source>
          <target state="translated"><bpt id="p1">[</bpt>Lista<ph id="ph1">\&lt;</ph>T &gt;. Sort()<ept id="p1">](xref:System.Collections.Generic.List`1.Sort*)</ept> ordena los elementos de la lista completa utilizando el comparador predeterminado del tipo de objeto contenidos en la lista.</target>       </trans-unit>
        <trans-unit id="910" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.Generic.List`1">
          <source><bpt id="p1">[</bpt>List<ph id="ph1">\&lt;</ph>T&gt;.Sort M(Comparison<ph id="ph2">\&lt;</ph>T&gt; comparison)<ept id="p1">](xref:System.Collections.Generic.List%601.Sort%28System.Comparison%7B%600%7D%29)</ept> Sorts the elements in the entire list using the specified comparer.</source>
          <target state="translated"><bpt id="p1">[</bpt>Lista<ph id="ph1">\&lt;</ph>T &gt;. Ordenación M (comparación<ph id="ph2">\&lt;</ph>T &gt; comparación)<ept id="p1">](xref:System.Collections.Generic.List%601.Sort%28System.Comparison%7B%600%7D%29)</ept> ordena los elementos de la lista completa utilizando el comparador especificado.</target>       </trans-unit>
        <trans-unit id="911" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.Generic.List`1">
          <source><bpt id="p1">[</bpt>List<ph id="ph1">\&lt;</ph>T&gt;.Sort(IComparer<ph id="ph2">\&lt;</ph>T&gt; comparer)<ept id="p1">](xref:System.Collections.Generic.List%601.Sort%28System.Collections.Generic.IComparer%7B%600%7D%29)</ept> Sorts the elements in the entire list using the specified <ph id="ph3">&lt;xref:System.Comparison%601?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated"><bpt id="p1">[</bpt>Lista<ph id="ph1">\&lt;</ph>T &gt;. Sort (IComparer<ph id="ph2">\&lt;</ph>T &gt; comparador)<ept id="p1">](xref:System.Collections.Generic.List%601.Sort%28System.Collections.Generic.IComparer%7B%600%7D%29)</ept> ordena los elementos de toda la lista utilizando especificado <ph id="ph3">&lt;xref:System.Comparison%601?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="912" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.Generic.List`1">
          <source><bpt id="p1">[</bpt>List<ph id="ph1">\&lt;</ph>T&gt;.Sort(Int32 index, Int32 count, IComparer<ph id="ph2">\&lt;</ph>T&gt; comparer)<ept id="p1">](xref:System.Collections.Generic.List%601.Sort%28System.Int32,System.Int32,System.Collections.Generic.IComparer%7B%600%7D%29)</ept> Sorts the elements in a range of elements in list using the specified comparer.</source>
          <target state="translated"><bpt id="p1">[</bpt>Lista<ph id="ph1">\&lt;</ph>T &gt;. Ordenación (Int32 index, recuento de Int32, IComparer<ph id="ph2">\&lt;</ph>T &gt; comparador)<ept id="p1">](xref:System.Collections.Generic.List%601.Sort%28System.Int32,System.Int32,System.Collections.Generic.IComparer%7B%600%7D%29)</ept> ordena los elementos de un intervalo de elementos de lista usando el comparador especificado.</target>       </trans-unit>
        <trans-unit id="913" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.Generic.List`1">
          <source>Parameters</source>
          <target state="translated">Parámetros</target>       </trans-unit>
        <trans-unit id="914" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.Generic.List`1">
          <source>Parameter</source>
          <target state="translated">Parámetro</target>       </trans-unit>
        <trans-unit id="915" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.Generic.List`1">
          <source>Type</source>
          <target state="translated">Tipo</target>       </trans-unit>
        <trans-unit id="916" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.Generic.List`1">
          <source>Description</source>
          <target state="translated">Descripción</target>       </trans-unit>
        <trans-unit id="917" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.Generic.List`1">
          <source>The delegate method to use when comparing elements</source>
          <target state="translated">El método de delegado a utilizar al comparar elementos</target>       </trans-unit>
        <trans-unit id="918" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.Generic.List`1">
          <source>comparer</source>
          <target state="translated">comparer</target>       </trans-unit>
        <trans-unit id="919" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.Generic.List`1">
          <source>The <ph id="ph1">&lt;xref:System.Collections.Generic.IComparer%601&gt;</ph> implementation to use when comparing elements, or null to use the default comparer <ph id="ph2">&lt;xref:System.Collections.Generic.Comparer%601.Default&gt;</ph>.</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.Collections.Generic.IComparer%601&gt;</ph> implementación a utilizar al comparar elementos, o null para utilizar el comparador predeterminado <ph id="ph2">&lt;xref:System.Collections.Generic.Comparer%601.Default&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="920" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.Generic.List`1">
          <source>The zero-based starting index of the range to sort.</source>
          <target state="translated">Índice inicial de base cero del intervalo que se va a ordenar.</target>       </trans-unit>
        <trans-unit id="921" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.Generic.List`1">
          <source>The length of the range to sort.</source>
          <target state="translated">Longitud del intervalo que se va a ordenar.</target>       </trans-unit>
        <trans-unit id="922" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.Generic.List`1">
          <source>Exceptions</source>
          <target state="translated">Excepciones</target>       </trans-unit>
        <trans-unit id="923" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.Generic.List`1">
          <source>Exception</source>
          <target state="translated">Excepción</target>       </trans-unit>
        <trans-unit id="924" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.Generic.List`1">
          <source>Condition</source>
          <target state="translated">Condición</target>       </trans-unit>
        <trans-unit id="925" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.Generic.List`1">
          <source><ph id="ph1">`comparer`</ph> is not specified or <ph id="ph2">`null`</ph>, and the default comparer <ph id="ph3">&lt;xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType&gt;</ph> cannot find implementation of the <ph id="ph4">&lt;xref:System.IComparable%601?displayProperty=nameWithType&gt;</ph> generic interface or the <ph id="ph5">&lt;xref:System.IComparable?displayProperty=nameWithType&gt;</ph> interface for type T.</source>
          <target state="translated"><ph id="ph1">`comparer`</ph> no se especifica o <ph id="ph2">`null`</ph>y el comparador predeterminado <ph id="ph3">&lt;xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType&gt;</ph> no se puede encontrar la implementación de la <ph id="ph4">&lt;xref:System.IComparable%601?displayProperty=nameWithType&gt;</ph> interfaz genérica o <ph id="ph5">&lt;xref:System.IComparable?displayProperty=nameWithType&gt;</ph> interfaz de tipo T.</target>       </trans-unit>
        <trans-unit id="926" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.Generic.List`1">
          <source><ph id="ph1">`comparison`</ph> is <ph id="ph2">`null`</ph>.</source>
          <target state="translated"><ph id="ph1">`comparison`</ph> es <ph id="ph2">`null`</ph>.</target>       </trans-unit>
        <trans-unit id="927" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.Generic.List`1">
          <source>The implementation of <ph id="ph1">`comparison`</ph> or <ph id="ph2">`comparer`</ph> caused an error during the sort.</source>
          <target state="translated">La implementación de <ph id="ph1">`comparison`</ph> o <ph id="ph2">`comparer`</ph> produjo un error durante la ordenación.</target>       </trans-unit>
        <trans-unit id="928" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.Generic.List`1">
          <source>For example, <ph id="ph1">`comparison`</ph> might not return 0 when comparing an item with itself.</source>
          <target state="translated">Por ejemplo, es posible que <ph id="ph1">`comparison`</ph> no devuelva 0 al comparar un elemento consigo mismo.</target>       </trans-unit>
        <trans-unit id="929" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.Generic.List`1">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="930" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.Generic.List`1">
          <source><ph id="ph1">`index`</ph> and <ph id="ph2">`count`</ph> do not specify a valid range in the <ph id="ph3">&lt;xref:System.Collections.Generic.List%601&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">`index`</ph> y <ph id="ph2">`count`</ph> no especifican un intervalo válido en <ph id="ph3">&lt;xref:System.Collections.Generic.List%601&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="931" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Collections.Generic.List`1">
          <source><ph id="ph1">`index`</ph> is less than 0 or <ph id="ph2">`count`</ph> is less than 0.</source>
          <target state="translated"><ph id="ph1">`index`</ph> es menor que 0 o <ph id="ph2">`count`</ph> es menor que 0.</target>       </trans-unit>
        <trans-unit id="932" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.List`1.Sort">
          <source>Sorts the elements in the entire <ph id="ph1">&lt;see cref="T:System.Collections.Generic.List`1" /&gt;</ph> using the default comparer.</source>
          <target state="translated">Ordena los elementos de toda la <ph id="ph1">&lt;see cref="T:System.Collections.Generic.List`1" /&gt;</ph> utilizando el comparador predeterminado.</target>       </trans-unit>
        <trans-unit id="933" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.Sort">
          <source>This method uses the default comparer <ph id="ph1">&lt;xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType&gt;</ph> for type <ph id="ph2">`T`</ph> to determine the order of list elements.</source>
          <target state="translated">Este método utiliza el comparador predeterminado <ph id="ph1">&lt;xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType&gt;</ph> para el tipo <ph id="ph2">`T`</ph> para determinar el orden de los elementos de lista.</target>       </trans-unit>
        <trans-unit id="934" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.Sort">
          <source>The <ph id="ph1">&lt;xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType&gt;</ph> property checks whether type <ph id="ph2">`T`</ph> implements the <ph id="ph3">&lt;xref:System.IComparable%601&gt;</ph> generic interface and uses that implementation, if available.</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType&gt;</ph> propiedad comprueba si tipo <ph id="ph2">`T`</ph> implementa el <ph id="ph3">&lt;xref:System.IComparable%601&gt;</ph> interfaz genérica y utiliza esa implementación, si está disponible.</target>       </trans-unit>
        <trans-unit id="935" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.Sort">
          <source>If not, <ph id="ph1">&lt;xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType&gt;</ph> checks whether type <ph id="ph2">`T`</ph> implements the <ph id="ph3">&lt;xref:System.IComparable&gt;</ph> interface.</source>
          <target state="translated">Si no es así, <ph id="ph1">&lt;xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType&gt;</ph> comprueba si tipo <ph id="ph2">`T`</ph> implementa el <ph id="ph3">&lt;xref:System.IComparable&gt;</ph> interfaz.</target>       </trans-unit>
        <trans-unit id="936" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.Sort">
          <source>If type <ph id="ph1">`T`</ph> does not implement either interface, <ph id="ph2">&lt;xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType&gt;</ph> throws an <ph id="ph3">&lt;xref:System.InvalidOperationException&gt;</ph>.</source>
          <target state="translated">Si tipo <ph id="ph1">`T`</ph> no implementa ninguna de estas interfaces, <ph id="ph2">&lt;xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType&gt;</ph> produce una <ph id="ph3">&lt;xref:System.InvalidOperationException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="937" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.Sort">
          <source>This method uses the <ph id="ph1">&lt;xref:System.Array.Sort%2A?displayProperty=nameWithType&gt;</ph> method, which applies the introspective sort as follows:</source>
          <target state="translated">Este método usa la <ph id="ph1">&lt;xref:System.Array.Sort%2A?displayProperty=nameWithType&gt;</ph> método, que se aplica la ordenación introspectivas como se indica a continuación:</target>       </trans-unit>
        <trans-unit id="938" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.Sort">
          <source>If the partition size is fewer than 16 elements, it uses an insertion sort algorithm.</source>
          <target state="translated">Si el tamaño de partición es menos de 16 elementos, utiliza un algoritmo de ordenación de inserción.</target>       </trans-unit>
        <trans-unit id="939" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.Sort">
          <source>If the number of partitions exceeds 2 log <bpt id="p1">*</bpt>n<ept id="p1">*</ept>, where <bpt id="p2">*</bpt>n<ept id="p2">*</ept> is the range of the input array, it uses a Heapsort algorithm.</source>
          <target state="translated">Si el número de particiones superior a 2 registro <bpt id="p1">*</bpt>n<ept id="p1">*</ept>, donde <bpt id="p2">*</bpt>n<ept id="p2">*</ept> es el intervalo de la matriz de entrada, utiliza un algoritmo de Heapsort.</target>       </trans-unit>
        <trans-unit id="940" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.Sort">
          <source>Otherwise, it uses a Quicksort algorithm.</source>
          <target state="translated">En caso contrario, utiliza un algoritmo Quicksort.</target>       </trans-unit>
        <trans-unit id="941" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.Sort">
          <source>This implementation performs an unstable sort; that is, if two elements are equal, their order might not be preserved.</source>
          <target state="translated">Esta implementación realiza a una ordenación inestable; es decir, si dos elementos son iguales, puede que no se conserve su orden.</target>       </trans-unit>
        <trans-unit id="942" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.Sort">
          <source>In contrast, a stable sort preserves the order of elements that are equal.</source>
          <target state="translated">En cambio, una ordenación estable conserva el orden de los elementos que son iguales.</target>       </trans-unit>
        <trans-unit id="943" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.Sort">
          <source>On average, this method is an O(<bpt id="p1">*</bpt>n<ept id="p1">*</ept> log <bpt id="p2">*</bpt>n<ept id="p2">*</ept>) operation, where <bpt id="p3">*</bpt>n<ept id="p3">*</ept> is <ph id="ph1">&lt;xref:System.Collections.Generic.List%601.Count%2A&gt;</ph>; in the worst case it is an O(<bpt id="p4">*</bpt>n<ept id="p4">*</ept><bpt id="p5">&lt;sup&gt;</bpt>2<ept id="p5">&lt;/sup&gt;</ept>) operation.</source>
          <target state="translated">En promedio, este método es una O (<bpt id="p1">*</bpt>n<ept id="p1">*</ept> registro <bpt id="p2">*</bpt>n<ept id="p2">*</ept>) operación, donde <bpt id="p3">*</bpt>n<ept id="p3">*</ept> es <ph id="ph1">&lt;xref:System.Collections.Generic.List%601.Count%2A&gt;</ph>; en el peor de los casos es una O (<bpt id="p4">*</bpt>n<ept id="p4">*</ept> <bpt id="p5">&lt;sup&gt;</bpt>2<ept id="p5">&lt;/sup&gt;</ept>) operación.</target>       </trans-unit>
        <trans-unit id="944" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.Sort">
          <source>The following example adds some names to a <ph id="ph1">`List&lt;String&gt;`</ph> object, displays the list in unsorted order, calls the <ph id="ph2">&lt;xref:System.Collections.Generic.List%601.Sort%2A&gt;</ph> method, and then displays the sorted list.</source>
          <target state="translated">En el ejemplo siguiente se agrega algunos nombres para un <ph id="ph1">`List&lt;String&gt;`</ph> (objeto), muestra la lista sin ordenar, llama a la <ph id="ph2">&lt;xref:System.Collections.Generic.List%601.Sort%2A&gt;</ph> (método) y, a continuación, muestra la lista ordenada.</target>       </trans-unit>
        <trans-unit id="945" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.Sort">
          <source>The following code demonstrates the <ph id="ph1">&lt;xref:System.Collections.Generic.List%601.Sort&gt;</ph> and <ph id="ph2">&lt;xref:System.Collections.Generic.List%601.Sort%28System.Comparison%7B%600%7D%29&gt;</ph> method overloads on a simple business object.</source>
          <target state="translated">El código siguiente muestra el <ph id="ph1">&lt;xref:System.Collections.Generic.List%601.Sort&gt;</ph> y <ph id="ph2">&lt;xref:System.Collections.Generic.List%601.Sort%28System.Comparison%7B%600%7D%29&gt;</ph> sobrecargas de método en un objeto comercial simple.</target>       </trans-unit>
        <trans-unit id="946" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.Sort">
          <source>Calling the <ph id="ph1">&lt;xref:System.Collections.Generic.List%601.Sort&gt;</ph> method results in the use of the default comparer for the Part type, and the <ph id="ph2">&lt;xref:System.Collections.Generic.List%601.Sort%28System.Comparison%7B%600%7D%29&gt;</ph> method is implemented by using an anonymous method.</source>
          <target state="translated">Llamar a la <ph id="ph1">&lt;xref:System.Collections.Generic.List%601.Sort&gt;</ph> método implica el uso del comparador predeterminado para el tipo de elemento y el <ph id="ph2">&lt;xref:System.Collections.Generic.List%601.Sort%28System.Comparison%7B%600%7D%29&gt;</ph> método se implementa mediante el uso de un método anónimo.</target>       </trans-unit>
        <trans-unit id="947" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.Sort">
          <source>The following example demonstrates the <ph id="ph1">&lt;xref:System.Collections.Generic.List%601.Sort&gt;</ph> method overload and the <ph id="ph2">&lt;xref:System.Collections.Generic.List%601.BinarySearch%28%600%29&gt;</ph> method overload.</source>
          <target state="translated">En el ejemplo siguiente se muestra la <ph id="ph1">&lt;xref:System.Collections.Generic.List%601.Sort&gt;</ph> sobrecarga del método y el <ph id="ph2">&lt;xref:System.Collections.Generic.List%601.BinarySearch%28%600%29&gt;</ph> sobrecarga del método.</target>       </trans-unit>
        <trans-unit id="948" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.Sort">
          <source>A <ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph> of strings is created and populated with four strings, in no particular order.</source>
          <target state="translated">Un <ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph> de cadenas se crean y rellenan con cuatro cadenas, sin ningún orden determinado.</target>       </trans-unit>
        <trans-unit id="949" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.Sort">
          <source>The list is displayed, sorted, and displayed again.</source>
          <target state="translated">La lista se muestran, ordenada y vuelve a aparecer.</target>       </trans-unit>
        <trans-unit id="950" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.Sort">
          <source>The <ph id="ph1">&lt;xref:System.Collections.Generic.List%601.BinarySearch%28%600%29&gt;</ph> method overload is then used to search for two strings that are not in the list, and the <ph id="ph2">&lt;xref:System.Collections.Generic.List%601.Insert%2A&gt;</ph> method is used to insert them.</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.Collections.Generic.List%601.BinarySearch%28%600%29&gt;</ph> sobrecarga del método, a continuación, se usa para buscar dos cadenas que no están en la lista, y el <ph id="ph2">&lt;xref:System.Collections.Generic.List%601.Insert%2A&gt;</ph> método se usa para insertarlos.</target>       </trans-unit>
        <trans-unit id="951" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.Sort">
          <source>The return value of the <ph id="ph1">&lt;xref:System.Collections.Generic.List%601.BinarySearch%2A&gt;</ph> method is negative in each case, because the strings are not in the list.</source>
          <target state="translated">El valor devuelto de la <ph id="ph1">&lt;xref:System.Collections.Generic.List%601.BinarySearch%2A&gt;</ph> método es negativo en cada caso, dado que las cadenas no están en la lista.</target>       </trans-unit>
        <trans-unit id="952" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.Sort">
          <source>Taking the bitwise complement (the ~ operator in C# and Visual C++, <ph id="ph1">`Xor`</ph> -1 in Visual Basic) of this negative number produces the index of the first element in the list that is larger than the search string, and inserting at this location preserves the sort order.</source>
          <target state="translated">Tomar el complemento bit a bit (el ~ operador en C# y Visual C++, <ph id="ph1">`Xor`</ph> -1 en Visual Basic) de este número negativo se produce el índice del primer elemento de la lista que es mayor que la cadena de búsqueda y, a continuación, insertar en esta ubicación conserva la ordenación orden.</target>       </trans-unit>
        <trans-unit id="953" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.Sort">
          <source>The second search string is larger than any element in the list, so the insertion position is at the end of the list.</source>
          <target state="translated">La segunda cadena de búsqueda es mayor que cualquier elemento de la lista, por lo que es la posición de inserción al final de la lista.</target>       </trans-unit>
        <trans-unit id="954" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.List`1.Sort">
          <source>The default comparer <ph id="ph1">&lt;see cref="P:System.Collections.Generic.Comparer`1.Default" /&gt;</ph> cannot find an implementation of the <ph id="ph2">&lt;see cref="T:System.IComparable`1" /&gt;</ph> generic interface or the <ph id="ph3">&lt;see cref="T:System.IComparable" /&gt;</ph> interface for type <ph id="ph4">&lt;paramref name="T" /&gt;</ph>.</source>
          <target state="translated">El comparador predeterminado <ph id="ph1">&lt;see cref="P:System.Collections.Generic.Comparer`1.Default" /&gt;</ph> no puede encontrar una implementación de la interfaz genérica <ph id="ph2">&lt;see cref="T:System.IComparable`1" /&gt;</ph> o de la interfaz <ph id="ph3">&lt;see cref="T:System.IComparable" /&gt;</ph> para el tipo <ph id="ph4">&lt;paramref name="T" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="955" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.List`1.Sort(System.Collections.Generic.IComparer{`0})">
          <source>The <ph id="ph1">&lt;see cref="T:System.Collections.Generic.IComparer`1" /&gt;</ph> implementation to use when comparing elements, or <ph id="ph2">&lt;see langword="null" /&gt;</ph> to use the default comparer <ph id="ph3">&lt;see cref="P:System.Collections.Generic.Comparer`1.Default" /&gt;</ph>.</source>
          <target state="translated">Implementación de <ph id="ph1">&lt;see cref="T:System.Collections.Generic.IComparer`1" /&gt;</ph> que se va a utilizar al comparar elementos, o <ph id="ph2">&lt;see langword="null" /&gt;</ph> para utilizar el comparador predeterminado <ph id="ph3">&lt;see cref="P:System.Collections.Generic.Comparer`1.Default" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="956" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.List`1.Sort(System.Collections.Generic.IComparer{`0})">
          <source>Sorts the elements in the entire <ph id="ph1">&lt;see cref="T:System.Collections.Generic.List`1" /&gt;</ph> using the specified comparer.</source>
          <target state="translated">Ordena los elementos en la <ph id="ph1">&lt;see cref="T:System.Collections.Generic.List`1" /&gt;</ph> completa usando el comparador especificado.</target>       </trans-unit>
        <trans-unit id="957" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.Sort(System.Collections.Generic.IComparer{`0})">
          <source>If <ph id="ph1">`comparer`</ph> is provided, the elements of the <ph id="ph2">&lt;xref:System.Collections.Generic.List%601&gt;</ph> are sorted using the specified <ph id="ph3">&lt;xref:System.Collections.Generic.IComparer%601&gt;</ph> implementation.</source>
          <target state="translated">Si <ph id="ph1">`comparer`</ph> se proporciona, los elementos de la <ph id="ph2">&lt;xref:System.Collections.Generic.List%601&gt;</ph> se ordenan mediante especificado <ph id="ph3">&lt;xref:System.Collections.Generic.IComparer%601&gt;</ph> implementación.</target>       </trans-unit>
        <trans-unit id="958" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.Sort(System.Collections.Generic.IComparer{`0})">
          <source>If <ph id="ph1">`comparer`</ph> is <ph id="ph2">`null`</ph>, the default comparer <ph id="ph3">&lt;xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType&gt;</ph> checks whether type <ph id="ph4">`T`</ph> implements the <ph id="ph5">&lt;xref:System.IComparable%601&gt;</ph> generic interface and uses that implementation, if available.</source>
          <target state="translated">Si <ph id="ph1">`comparer`</ph> es <ph id="ph2">`null`</ph>, el comparador predeterminado <ph id="ph3">&lt;xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType&gt;</ph> comprueba si tipo <ph id="ph4">`T`</ph> implementa el <ph id="ph5">&lt;xref:System.IComparable%601&gt;</ph> interfaz genérica y utiliza esa implementación, si está disponible.</target>       </trans-unit>
        <trans-unit id="959" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.Sort(System.Collections.Generic.IComparer{`0})">
          <source>If not, <ph id="ph1">&lt;xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType&gt;</ph> checks whether type <ph id="ph2">`T`</ph> implements the <ph id="ph3">&lt;xref:System.IComparable&gt;</ph> interface.</source>
          <target state="translated">Si no es así, <ph id="ph1">&lt;xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType&gt;</ph> comprueba si tipo <ph id="ph2">`T`</ph> implementa el <ph id="ph3">&lt;xref:System.IComparable&gt;</ph> interfaz.</target>       </trans-unit>
        <trans-unit id="960" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.Sort(System.Collections.Generic.IComparer{`0})">
          <source>If type <ph id="ph1">`T`</ph> does not implement either interface, <ph id="ph2">&lt;xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType&gt;</ph> throws an <ph id="ph3">&lt;xref:System.InvalidOperationException&gt;</ph>.</source>
          <target state="translated">Si tipo <ph id="ph1">`T`</ph> no implementa ninguna de estas interfaces, <ph id="ph2">&lt;xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType&gt;</ph> produce una <ph id="ph3">&lt;xref:System.InvalidOperationException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="961" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.Sort(System.Collections.Generic.IComparer{`0})">
          <source>This method uses the <ph id="ph1">&lt;xref:System.Array.Sort%2A?displayProperty=nameWithType&gt;</ph> method, which applies the introspective sort as follows:</source>
          <target state="translated">Este método usa la <ph id="ph1">&lt;xref:System.Array.Sort%2A?displayProperty=nameWithType&gt;</ph> método, que se aplica la ordenación introspectivas como se indica a continuación:</target>       </trans-unit>
        <trans-unit id="962" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.Sort(System.Collections.Generic.IComparer{`0})">
          <source>If the partition size is fewer than 16 elements, it uses an insertion sort algorithm.</source>
          <target state="translated">Si el tamaño de partición es menos de 16 elementos, utiliza un algoritmo de ordenación de inserción.</target>       </trans-unit>
        <trans-unit id="963" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.Sort(System.Collections.Generic.IComparer{`0})">
          <source>If the number of partitions exceeds 2 log <bpt id="p1">*</bpt>n<ept id="p1">*</ept>, where <bpt id="p2">*</bpt>n<ept id="p2">*</ept> is the range of the input array, it uses a Heapsort algorithm.</source>
          <target state="translated">Si el número de particiones superior a 2 registro <bpt id="p1">*</bpt>n<ept id="p1">*</ept>, donde <bpt id="p2">*</bpt>n<ept id="p2">*</ept> es el intervalo de la matriz de entrada, utiliza un algoritmo de Heapsort.</target>       </trans-unit>
        <trans-unit id="964" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.Sort(System.Collections.Generic.IComparer{`0})">
          <source>Otherwise, it uses a Quicksort algorithm.</source>
          <target state="translated">En caso contrario, utiliza un algoritmo Quicksort.</target>       </trans-unit>
        <trans-unit id="965" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.Sort(System.Collections.Generic.IComparer{`0})">
          <source>This implementation performs an unstable sort; that is, if two elements are equal, their order might not be preserved.</source>
          <target state="translated">Esta implementación realiza a una ordenación inestable; es decir, si dos elementos son iguales, puede que no se conserve su orden.</target>       </trans-unit>
        <trans-unit id="966" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.Sort(System.Collections.Generic.IComparer{`0})">
          <source>In contrast, a stable sort preserves the order of elements that are equal.</source>
          <target state="translated">En cambio, una ordenación estable conserva el orden de los elementos que son iguales.</target>       </trans-unit>
        <trans-unit id="967" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.Sort(System.Collections.Generic.IComparer{`0})">
          <source>On average, this method is an O(<bpt id="p1">*</bpt>n<ept id="p1">*</ept> log <bpt id="p2">*</bpt>n<ept id="p2">*</ept>) operation, where <bpt id="p3">*</bpt>n<ept id="p3">*</ept> is <ph id="ph1">&lt;xref:System.Collections.Generic.List%601.Count%2A&gt;</ph>; in the worst case it is an O(<bpt id="p4">*</bpt>n<ept id="p4">*</ept><bpt id="p5">&lt;sup&gt;</bpt>2<ept id="p5">&lt;/sup&gt;</ept>) operation.</source>
          <target state="translated">En promedio, este método es una O (<bpt id="p1">*</bpt>n<ept id="p1">*</ept> registro <bpt id="p2">*</bpt>n<ept id="p2">*</ept>) operación, donde <bpt id="p3">*</bpt>n<ept id="p3">*</ept> es <ph id="ph1">&lt;xref:System.Collections.Generic.List%601.Count%2A&gt;</ph>; en el peor de los casos es una O (<bpt id="p4">*</bpt>n<ept id="p4">*</ept> <bpt id="p5">&lt;sup&gt;</bpt>2<ept id="p5">&lt;/sup&gt;</ept>) operación.</target>       </trans-unit>
        <trans-unit id="968" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.Sort(System.Collections.Generic.IComparer{`0})">
          <source>The following example demonstrates the <ph id="ph1">&lt;xref:System.Collections.Generic.List%601.Sort%28System.Collections.Generic.IComparer%7B%600%7D%29&gt;</ph> method overload and the <ph id="ph2">&lt;xref:System.Collections.Generic.List%601.BinarySearch%28%600%2CSystem.Collections.Generic.IComparer%7B%600%7D%29&gt;</ph> method overload.</source>
          <target state="translated">En el ejemplo siguiente se muestra la <ph id="ph1">&lt;xref:System.Collections.Generic.List%601.Sort%28System.Collections.Generic.IComparer%7B%600%7D%29&gt;</ph> sobrecarga del método y el <ph id="ph2">&lt;xref:System.Collections.Generic.List%601.BinarySearch%28%600%2CSystem.Collections.Generic.IComparer%7B%600%7D%29&gt;</ph> sobrecarga del método.</target>       </trans-unit>
        <trans-unit id="969" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.Sort(System.Collections.Generic.IComparer{`0})">
          <source>The example defines an alternative comparer for strings named DinoCompare, which implements the <ph id="ph1">`IComparer&lt;string&gt;`</ph> (<ph id="ph2">`IComparer(Of String)`</ph> in Visual Basic, <ph id="ph3">`IComparer&lt;String^&gt;`</ph> in Visual C++) generic interface.</source>
          <target state="translated">En el ejemplo se define un comparador alternativo para las cadenas denominado DinoCompare, que implementa el <ph id="ph1">`IComparer&lt;string&gt;`</ph> (<ph id="ph2">`IComparer(Of String)`</ph> en Visual Basic, <ph id="ph3">`IComparer&lt;String^&gt;`</ph> en Visual C++) interfaz genérica.</target>       </trans-unit>
        <trans-unit id="970" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.Sort(System.Collections.Generic.IComparer{`0})">
          <source>The comparer works as follows: First, the comparands are tested for <ph id="ph1">`null`</ph>, and a null reference is treated as less than a non-null.</source>
          <target state="translated">El comparador funciona del siguiente modo: en primer lugar, la comparación se comprueba si hay <ph id="ph1">`null`</ph>, y una referencia nula es tratada como menor que un valor no nulo.</target>       </trans-unit>
        <trans-unit id="971" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.Sort(System.Collections.Generic.IComparer{`0})">
          <source>Second, the string lengths are compared, and the longer string is deemed to be greater.</source>
          <target state="translated">En segundo lugar, se comparan las longitudes de cadena y la cadena más larga se considera mayor.</target>       </trans-unit>
        <trans-unit id="972" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.Sort(System.Collections.Generic.IComparer{`0})">
          <source>Third, if the lengths are equal, ordinary string comparison is used.</source>
          <target state="translated">En tercer lugar, si las longitudes son iguales, se usa la comparación de cadenas normales.</target>       </trans-unit>
        <trans-unit id="973" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.Sort(System.Collections.Generic.IComparer{`0})">
          <source>A <ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph> of strings is created and populated with four strings, in no particular order.</source>
          <target state="translated">Un <ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph> de cadenas se crean y rellenan con cuatro cadenas, sin ningún orden determinado.</target>       </trans-unit>
        <trans-unit id="974" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.Sort(System.Collections.Generic.IComparer{`0})">
          <source>The list is displayed, sorted using the alternate comparer, and displayed again.</source>
          <target state="translated">Muestra la lista se ordena utilizando al comparador alternativo y se muestran nuevo.</target>       </trans-unit>
        <trans-unit id="975" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.Sort(System.Collections.Generic.IComparer{`0})">
          <source>The <ph id="ph1">&lt;xref:System.Collections.Generic.List%601.BinarySearch%28%600%2CSystem.Collections.Generic.IComparer%7B%600%7D%29&gt;</ph> method overload is then used to search for several strings that are not in the list, employing the alternate comparer.</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.Collections.Generic.List%601.BinarySearch%28%600%2CSystem.Collections.Generic.IComparer%7B%600%7D%29&gt;</ph> , a continuación, se utiliza la sobrecarga del método para buscar varias cadenas que no se en la lista, empleando el comparador alternativo.</target>       </trans-unit>
        <trans-unit id="976" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.Sort(System.Collections.Generic.IComparer{`0})">
          <source>The <ph id="ph1">&lt;xref:System.Collections.Generic.List%601.Insert%2A&gt;</ph> method is used to insert the strings.</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.Collections.Generic.List%601.Insert%2A&gt;</ph> método se utiliza para insertar las cadenas.</target>       </trans-unit>
        <trans-unit id="977" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.Sort(System.Collections.Generic.IComparer{`0})">
          <source>These two methods are located in the function named <ph id="ph1">`SearchAndInsert`</ph>, along with code to take the bitwise complement (the ~ operator in C# and Visual C++, <ph id="ph2">`Xor`</ph> -1 in Visual Basic) of the negative number returned by <ph id="ph3">&lt;xref:System.Collections.Generic.List%601.BinarySearch%28%600%2CSystem.Collections.Generic.IComparer%7B%600%7D%29&gt;</ph> and use it as an index for inserting the new string.</source>
          <target state="translated">Estos dos métodos se encuentran en la función denominada <ph id="ph1">`SearchAndInsert`</ph>, junto con el código para tomar el complemento bit a bit (el ~ operador en C# y Visual C++, <ph id="ph2">`Xor`</ph> -1 en Visual Basic) del número negativo devuelto por <ph id="ph3">&lt;xref:System.Collections.Generic.List%601.BinarySearch%28%600%2CSystem.Collections.Generic.IComparer%7B%600%7D%29&gt;</ph> y usarlo como un índice para Insertar la nueva cadena.</target>       </trans-unit>
        <trans-unit id="978" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.List`1.Sort(System.Collections.Generic.IComparer{`0})">
          <source><ph id="ph1">&lt;paramref name="comparer" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>, and the default comparer <ph id="ph3">&lt;see cref="P:System.Collections.Generic.Comparer`1.Default" /&gt;</ph> cannot find implementation of the <ph id="ph4">&lt;see cref="T:System.IComparable`1" /&gt;</ph> generic interface or the <ph id="ph5">&lt;see cref="T:System.IComparable" /&gt;</ph> interface for type <ph id="ph6">&lt;paramref name="T" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="comparer" /&gt;</ph> es <ph id="ph2">&lt;see langword="null" /&gt;</ph>, y el comparador predeterminado <ph id="ph3">&lt;see cref="P:System.Collections.Generic.Comparer`1.Default" /&gt;</ph> no puede encontrar una implementación de la interfaz genérica <ph id="ph4">&lt;see cref="T:System.IComparable`1" /&gt;</ph> o la interfaz <ph id="ph5">&lt;see cref="T:System.IComparable" /&gt;</ph> del tipo <ph id="ph6">&lt;paramref name="T" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="979" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.List`1.Sort(System.Collections.Generic.IComparer{`0})">
          <source>The implementation of <ph id="ph1">&lt;paramref name="comparer" /&gt;</ph> caused an error during the sort.</source>
          <target state="translated">La implementación de <ph id="ph1">&lt;paramref name="comparer" /&gt;</ph> produjo un error durante la ordenación.</target>       </trans-unit>
        <trans-unit id="980" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.List`1.Sort(System.Collections.Generic.IComparer{`0})">
          <source>For example, <ph id="ph1">&lt;paramref name="comparer" /&gt;</ph> might not return 0 when comparing an item with itself.</source>
          <target state="translated">Por ejemplo, es posible que <ph id="ph1">&lt;paramref name="comparer" /&gt;</ph> no devuelva 0 al comparar un elemento consigo mismo.</target>       </trans-unit>
        <trans-unit id="981" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.List`1.Sort(System.Comparison{`0})">
          <source>The <ph id="ph1">&lt;see cref="T:System.Comparison`1" /&gt;</ph> to use when comparing elements.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Comparison`1" /&gt;</ph> que se va a utilizar al comparar elementos.</target>       </trans-unit>
        <trans-unit id="982" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.List`1.Sort(System.Comparison{`0})">
          <source>Sorts the elements in the entire <ph id="ph1">&lt;see cref="T:System.Collections.Generic.List`1" /&gt;</ph> using the specified <ph id="ph2">&lt;see cref="T:System.Comparison`1" /&gt;</ph>.</source>
          <target state="translated">Ordena los elementos de toda la <ph id="ph1">&lt;see cref="T:System.Collections.Generic.List`1" /&gt;</ph> utilizando el <ph id="ph2">&lt;see cref="T:System.Comparison`1" /&gt;</ph> especificado.</target>       </trans-unit>
        <trans-unit id="983" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.Sort(System.Comparison{`0})">
          <source>If <ph id="ph1">`comparison`</ph> is provided, the elements of the <ph id="ph2">&lt;xref:System.Collections.Generic.List%601&gt;</ph> are sorted using the method represented by the delegate.</source>
          <target state="translated">Si <ph id="ph1">`comparison`</ph> se proporciona, los elementos de la <ph id="ph2">&lt;xref:System.Collections.Generic.List%601&gt;</ph> se ordenan mediante el método representado por el delegado.</target>       </trans-unit>
        <trans-unit id="984" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.Sort(System.Comparison{`0})">
          <source>If <ph id="ph1">`comparison`</ph> is <ph id="ph2">`null`</ph>, an <ph id="ph3">&lt;xref:System.ArgumentNullException&gt;</ph> is thrown.</source>
          <target state="translated">Si <ph id="ph1">`comparison`</ph> es <ph id="ph2">`null`</ph>, un <ph id="ph3">&lt;xref:System.ArgumentNullException&gt;</ph> se produce.</target>       </trans-unit>
        <trans-unit id="985" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.Sort(System.Comparison{`0})">
          <source>This method uses <ph id="ph1">&lt;xref:System.Array.Sort%2A?displayProperty=nameWithType&gt;</ph>, which applies the introspective sort as follows:</source>
          <target state="translated">Este método usa <ph id="ph1">&lt;xref:System.Array.Sort%2A?displayProperty=nameWithType&gt;</ph>, que aplica la ordenación introspectivas como se indica a continuación:</target>       </trans-unit>
        <trans-unit id="986" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.Sort(System.Comparison{`0})">
          <source>If the partition size is fewer than 16 elements, it uses an insertion sort algorithm</source>
          <target state="translated">Si el tamaño de partición es menos de 16 elementos, utiliza un algoritmo de ordenación de inserción</target>       </trans-unit>
        <trans-unit id="987" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.Sort(System.Comparison{`0})">
          <source>If the number of partitions exceeds 2 log <bpt id="p1">*</bpt>n<ept id="p1">*</ept>, where <bpt id="p2">*</bpt>n<ept id="p2">*</ept> is the range of the input array, it uses a <bpt id="p3">[</bpt>Heapsort<ept id="p3">](https://en.wikipedia.org/wiki/Heapsort)</ept> algorithm.</source>
          <target state="translated">Si el número de particiones superior a 2 registro <bpt id="p1">*</bpt>n<ept id="p1">*</ept>, donde <bpt id="p2">*</bpt>n<ept id="p2">*</ept> es el intervalo de la matriz de entrada, utiliza un <bpt id="p3">[</bpt>Heapsort<ept id="p3">](https://en.wikipedia.org/wiki/Heapsort)</ept> algoritmo.</target>       </trans-unit>
        <trans-unit id="988" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.Sort(System.Comparison{`0})">
          <source>Otherwise, it uses a Quicksort algorithm.</source>
          <target state="translated">En caso contrario, utiliza un algoritmo Quicksort.</target>       </trans-unit>
        <trans-unit id="989" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.Sort(System.Comparison{`0})">
          <source>This implementation performs an unstable sort; that is, if two elements are equal, their order might not be preserved.</source>
          <target state="translated">Esta implementación realiza a una ordenación inestable; es decir, si dos elementos son iguales, puede que no se conserve su orden.</target>       </trans-unit>
        <trans-unit id="990" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.Sort(System.Comparison{`0})">
          <source>In contrast, a stable sort preserves the order of elements that are equal.</source>
          <target state="translated">En cambio, una ordenación estable conserva el orden de los elementos que son iguales.</target>       </trans-unit>
        <trans-unit id="991" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.Sort(System.Comparison{`0})">
          <source>On average, this method is an O(<bpt id="p1">*</bpt>n<ept id="p1">*</ept> log <bpt id="p2">*</bpt>n<ept id="p2">*</ept>) operation, where <bpt id="p3">*</bpt>n<ept id="p3">*</ept> is <ph id="ph1">&lt;xref:System.Collections.Generic.List%601.Count%2A&gt;</ph>; in the worst case it is an O(<bpt id="p4">*</bpt>n<ept id="p4">*</ept><bpt id="p5">&lt;sup&gt;</bpt>2<ept id="p5">&lt;/sup&gt;</ept>) operation.</source>
          <target state="translated">En promedio, este método es una O (<bpt id="p1">*</bpt>n<ept id="p1">*</ept> registro <bpt id="p2">*</bpt>n<ept id="p2">*</ept>) operación, donde <bpt id="p3">*</bpt>n<ept id="p3">*</ept> es <ph id="ph1">&lt;xref:System.Collections.Generic.List%601.Count%2A&gt;</ph>; en el peor de los casos es una O (<bpt id="p4">*</bpt>n<ept id="p4">*</ept> <bpt id="p5">&lt;sup&gt;</bpt>2<ept id="p5">&lt;/sup&gt;</ept>) operación.</target>       </trans-unit>
        <trans-unit id="992" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.Sort(System.Comparison{`0})">
          <source>The following code demonstrates the <ph id="ph1">&lt;xref:System.Collections.Generic.List%601.Sort%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Collections.Generic.List%601.Sort%2A&gt;</ph> method overloads on a simple business object.</source>
          <target state="translated">El código siguiente muestra el <ph id="ph1">&lt;xref:System.Collections.Generic.List%601.Sort%2A&gt;</ph> y <ph id="ph2">&lt;xref:System.Collections.Generic.List%601.Sort%2A&gt;</ph> sobrecargas de método en un objeto comercial simple.</target>       </trans-unit>
        <trans-unit id="993" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.Sort(System.Comparison{`0})">
          <source>Calling the <ph id="ph1">&lt;xref:System.Collections.Generic.List%601.Sort%2A&gt;</ph> method results in the use of the default comparer for the Part type, and the <ph id="ph2">&lt;xref:System.Collections.Generic.List%601.Sort%2A&gt;</ph> method is implemented using an anonymous method.</source>
          <target state="translated">Llamar a la <ph id="ph1">&lt;xref:System.Collections.Generic.List%601.Sort%2A&gt;</ph> método implica el uso del comparador predeterminado para el tipo de elemento y el <ph id="ph2">&lt;xref:System.Collections.Generic.List%601.Sort%2A&gt;</ph> método se implementa mediante un método anónimo.</target>       </trans-unit>
        <trans-unit id="994" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.Sort(System.Comparison{`0})">
          <source>The following example demonstrates the <ph id="ph1">&lt;xref:System.Collections.Generic.List%601.Sort%28System.Comparison%7B%600%7D%29&gt;</ph> method overload.</source>
          <target state="translated">En el ejemplo siguiente se muestra el <ph id="ph1">&lt;xref:System.Collections.Generic.List%601.Sort%28System.Comparison%7B%600%7D%29&gt;</ph> sobrecarga del método.</target>       </trans-unit>
        <trans-unit id="995" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.Sort(System.Comparison{`0})">
          <source>The example defines an alternative comparison method for strings, named <ph id="ph1">`CompareDinosByLength`</ph>.</source>
          <target state="translated">En el ejemplo se define un método de comparación alternativo para las cadenas, denominado <ph id="ph1">`CompareDinosByLength`</ph>.</target>       </trans-unit>
        <trans-unit id="996" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.Sort(System.Comparison{`0})">
          <source>This method works as follows: First, the comparands are tested for <ph id="ph1">`null`</ph>, and a null reference is treated as less than a non-null.</source>
          <target state="translated">Este método funciona del siguiente modo: en primer lugar, la comparación se comprueba si hay <ph id="ph1">`null`</ph>, y una referencia nula es tratada como menor que un valor no nulo.</target>       </trans-unit>
        <trans-unit id="997" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.Sort(System.Comparison{`0})">
          <source>Second, the string lengths are compared, and the longer string is deemed to be greater.</source>
          <target state="translated">En segundo lugar, se comparan las longitudes de cadena y la cadena más larga se considera mayor.</target>       </trans-unit>
        <trans-unit id="998" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.Sort(System.Comparison{`0})">
          <source>Third, if the lengths are equal, ordinary string comparison is used.</source>
          <target state="translated">En tercer lugar, si las longitudes son iguales, se usa la comparación de cadenas normales.</target>       </trans-unit>
        <trans-unit id="999" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.Sort(System.Comparison{`0})">
          <source>A <ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph> of strings is created and populated with four strings, in no particular order.</source>
          <target state="translated">Un <ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph> de cadenas se crean y rellenan con cuatro cadenas, sin ningún orden determinado.</target>       </trans-unit>
        <trans-unit id="1000" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.Sort(System.Comparison{`0})">
          <source>The list also includes an empty string and a null reference.</source>
          <target state="translated">La lista también incluye una cadena vacía y una referencia nula.</target>       </trans-unit>
        <trans-unit id="1001" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.Sort(System.Comparison{`0})">
          <source>The list is displayed, sorted using a <ph id="ph1">&lt;xref:System.Comparison%601&gt;</ph> generic delegate representing the <ph id="ph2">`CompareDinosByLength`</ph> method, and displayed again.</source>
          <target state="translated">La lista se muestra, se ordena usando un <ph id="ph1">&lt;xref:System.Comparison%601&gt;</ph> delegado genérico que representa la <ph id="ph2">`CompareDinosByLength`</ph> método y vuelve a aparecer.</target>       </trans-unit>
        <trans-unit id="1002" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.List`1.Sort(System.Comparison{`0})">
          <source><ph id="ph1">&lt;paramref name="comparison" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="comparison" /&gt;</ph> es <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1003" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.List`1.Sort(System.Comparison{`0})">
          <source>The implementation of <ph id="ph1">&lt;paramref name="comparison" /&gt;</ph> caused an error during the sort.</source>
          <target state="translated">La implementación de <ph id="ph1">&lt;paramref name="comparison" /&gt;</ph> ha producido un error durante la ordenación.</target>       </trans-unit>
        <trans-unit id="1004" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.List`1.Sort(System.Comparison{`0})">
          <source>For example, <ph id="ph1">&lt;paramref name="comparison" /&gt;</ph> might not return 0 when comparing an item with itself.</source>
          <target state="translated">Por ejemplo, es posible que <ph id="ph1">&lt;paramref name="comparison" /&gt;</ph> no devuelva 0 al comparar un elemento consigo mismo.</target>       </trans-unit>
        <trans-unit id="1005" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.List`1.Sort(System.Int32,System.Int32,System.Collections.Generic.IComparer{`0})">
          <source>The zero-based starting index of the range to sort.</source>
          <target state="translated">Índice inicial de base cero del intervalo que se va a ordenar.</target>       </trans-unit>
        <trans-unit id="1006" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.List`1.Sort(System.Int32,System.Int32,System.Collections.Generic.IComparer{`0})">
          <source>The length of the range to sort.</source>
          <target state="translated">Longitud del intervalo que se va a ordenar.</target>       </trans-unit>
        <trans-unit id="1007" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.List`1.Sort(System.Int32,System.Int32,System.Collections.Generic.IComparer{`0})">
          <source>The <ph id="ph1">&lt;see cref="T:System.Collections.Generic.IComparer`1" /&gt;</ph> implementation to use when comparing elements, or <ph id="ph2">&lt;see langword="null" /&gt;</ph> to use the default comparer <ph id="ph3">&lt;see cref="P:System.Collections.Generic.Comparer`1.Default" /&gt;</ph>.</source>
          <target state="translated">Implementación de <ph id="ph1">&lt;see cref="T:System.Collections.Generic.IComparer`1" /&gt;</ph> que se va a utilizar al comparar elementos, o <ph id="ph2">&lt;see langword="null" /&gt;</ph> para utilizar el comparador predeterminado <ph id="ph3">&lt;see cref="P:System.Collections.Generic.Comparer`1.Default" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1008" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.List`1.Sort(System.Int32,System.Int32,System.Collections.Generic.IComparer{`0})">
          <source>Sorts the elements in a range of elements in <ph id="ph1">&lt;see cref="T:System.Collections.Generic.List`1" /&gt;</ph> using the specified comparer.</source>
          <target state="translated">Ordena los elementos en un intervalo de elementos de la matriz <ph id="ph1">&lt;see cref="T:System.Collections.Generic.List`1" /&gt;</ph> usando el comparador especificado.</target>       </trans-unit>
        <trans-unit id="1009" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.Sort(System.Int32,System.Int32,System.Collections.Generic.IComparer{`0})">
          <source>If <ph id="ph1">`comparer`</ph> is provided, the elements of the <ph id="ph2">&lt;xref:System.Collections.Generic.List%601&gt;</ph> are sorted using the specified <ph id="ph3">&lt;xref:System.Collections.Generic.IComparer%601&gt;</ph> implementation.</source>
          <target state="translated">Si <ph id="ph1">`comparer`</ph> se proporciona, los elementos de la <ph id="ph2">&lt;xref:System.Collections.Generic.List%601&gt;</ph> se ordenan mediante especificado <ph id="ph3">&lt;xref:System.Collections.Generic.IComparer%601&gt;</ph> implementación.</target>       </trans-unit>
        <trans-unit id="1010" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.Sort(System.Int32,System.Int32,System.Collections.Generic.IComparer{`0})">
          <source>If <ph id="ph1">`comparer`</ph> is <ph id="ph2">`null`</ph>, the default comparer <ph id="ph3">&lt;xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType&gt;</ph> checks whether type <ph id="ph4">`T`</ph> implements the <ph id="ph5">&lt;xref:System.IComparable%601&gt;</ph> generic interface and uses that implementation, if available.</source>
          <target state="translated">Si <ph id="ph1">`comparer`</ph> es <ph id="ph2">`null`</ph>, el comparador predeterminado <ph id="ph3">&lt;xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType&gt;</ph> comprueba si tipo <ph id="ph4">`T`</ph> implementa el <ph id="ph5">&lt;xref:System.IComparable%601&gt;</ph> interfaz genérica y utiliza esa implementación, si está disponible.</target>       </trans-unit>
        <trans-unit id="1011" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.Sort(System.Int32,System.Int32,System.Collections.Generic.IComparer{`0})">
          <source>If not, <ph id="ph1">&lt;xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType&gt;</ph> checks whether type <ph id="ph2">`T`</ph> implements the <ph id="ph3">&lt;xref:System.IComparable&gt;</ph> interface.</source>
          <target state="translated">Si no es así, <ph id="ph1">&lt;xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType&gt;</ph> comprueba si tipo <ph id="ph2">`T`</ph> implementa el <ph id="ph3">&lt;xref:System.IComparable&gt;</ph> interfaz.</target>       </trans-unit>
        <trans-unit id="1012" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.Sort(System.Int32,System.Int32,System.Collections.Generic.IComparer{`0})">
          <source>If type <ph id="ph1">`T`</ph> does not implement either interface, <ph id="ph2">&lt;xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType&gt;</ph> throws an <ph id="ph3">&lt;xref:System.InvalidOperationException&gt;</ph>.</source>
          <target state="translated">Si tipo <ph id="ph1">`T`</ph> no implementa ninguna de estas interfaces, <ph id="ph2">&lt;xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType&gt;</ph> produce una <ph id="ph3">&lt;xref:System.InvalidOperationException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1013" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.Sort(System.Int32,System.Int32,System.Collections.Generic.IComparer{`0})">
          <source>This method uses <ph id="ph1">&lt;xref:System.Array.Sort%2A?displayProperty=nameWithType&gt;</ph>, which applies the introspective sort as follows:</source>
          <target state="translated">Este método usa <ph id="ph1">&lt;xref:System.Array.Sort%2A?displayProperty=nameWithType&gt;</ph>, que aplica la ordenación introspectivas como se indica a continuación:</target>       </trans-unit>
        <trans-unit id="1014" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.Sort(System.Int32,System.Int32,System.Collections.Generic.IComparer{`0})">
          <source>If the partition size is fewer than 16 elements, it uses an insertion sort algorithm</source>
          <target state="translated">Si el tamaño de partición es menos de 16 elementos, utiliza un algoritmo de ordenación de inserción</target>       </trans-unit>
        <trans-unit id="1015" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.Sort(System.Int32,System.Int32,System.Collections.Generic.IComparer{`0})">
          <source>If the number of partitions exceeds 2 log <bpt id="p1">*</bpt>n<ept id="p1">*</ept>, where <bpt id="p2">*</bpt>n<ept id="p2">*</ept> is the range of the input array, it uses a <bpt id="p3">[</bpt>Heapsort<ept id="p3">](https://en.wikipedia.org/wiki/Heapsort)</ept> algorithm.</source>
          <target state="translated">Si el número de particiones superior a 2 registro <bpt id="p1">*</bpt>n<ept id="p1">*</ept>, donde <bpt id="p2">*</bpt>n<ept id="p2">*</ept> es el intervalo de la matriz de entrada, utiliza un <bpt id="p3">[</bpt>Heapsort<ept id="p3">](https://en.wikipedia.org/wiki/Heapsort)</ept> algoritmo.</target>       </trans-unit>
        <trans-unit id="1016" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.Sort(System.Int32,System.Int32,System.Collections.Generic.IComparer{`0})">
          <source>Otherwise, it uses a Quicksort algorithm.</source>
          <target state="translated">En caso contrario, utiliza un algoritmo Quicksort.</target>       </trans-unit>
        <trans-unit id="1017" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.Sort(System.Int32,System.Int32,System.Collections.Generic.IComparer{`0})">
          <source>This implementation performs an unstable sort; that is, if two elements are equal, their order might not be preserved.</source>
          <target state="translated">Esta implementación realiza a una ordenación inestable; es decir, si dos elementos son iguales, puede que no se conserve su orden.</target>       </trans-unit>
        <trans-unit id="1018" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.Sort(System.Int32,System.Int32,System.Collections.Generic.IComparer{`0})">
          <source>In contrast, a stable sort preserves the order of elements that are equal.</source>
          <target state="translated">En cambio, una ordenación estable conserva el orden de los elementos que son iguales.</target>       </trans-unit>
        <trans-unit id="1019" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.Sort(System.Int32,System.Int32,System.Collections.Generic.IComparer{`0})">
          <source>On average, this method is an O(<bpt id="p1">*</bpt>n<ept id="p1">*</ept> log <bpt id="p2">*</bpt>n<ept id="p2">*</ept>) operation, where <bpt id="p3">*</bpt>n<ept id="p3">*</ept> is <ph id="ph1">&lt;xref:System.Collections.Generic.List%601.Count%2A&gt;</ph>; in the worst case it is an O(<bpt id="p4">*</bpt>n<ept id="p4">*</ept><bpt id="p5">&lt;sup&gt;</bpt>2<ept id="p5">&lt;/sup&gt;</ept>) operation.</source>
          <target state="translated">En promedio, este método es una O (<bpt id="p1">*</bpt>n<ept id="p1">*</ept> registro <bpt id="p2">*</bpt>n<ept id="p2">*</ept>) operación, donde <bpt id="p3">*</bpt>n<ept id="p3">*</ept> es <ph id="ph1">&lt;xref:System.Collections.Generic.List%601.Count%2A&gt;</ph>; en el peor de los casos es una O (<bpt id="p4">*</bpt>n<ept id="p4">*</ept> <bpt id="p5">&lt;sup&gt;</bpt>2<ept id="p5">&lt;/sup&gt;</ept>) operación.</target>       </trans-unit>
        <trans-unit id="1020" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.Sort(System.Int32,System.Int32,System.Collections.Generic.IComparer{`0})">
          <source>The following example demonstrates the <ph id="ph1">&lt;xref:System.Collections.Generic.List%601.Sort%28System.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%600%7D%29&gt;</ph> method overload and the <ph id="ph2">&lt;xref:System.Collections.Generic.List%601.BinarySearch%28System.Int32%2CSystem.Int32%2C%600%2CSystem.Collections.Generic.IComparer%7B%600%7D%29&gt;</ph> method overload.</source>
          <target state="translated">En el ejemplo siguiente se muestra la <ph id="ph1">&lt;xref:System.Collections.Generic.List%601.Sort%28System.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%600%7D%29&gt;</ph> sobrecarga del método y el <ph id="ph2">&lt;xref:System.Collections.Generic.List%601.BinarySearch%28System.Int32%2CSystem.Int32%2C%600%2CSystem.Collections.Generic.IComparer%7B%600%7D%29&gt;</ph> sobrecarga del método.</target>       </trans-unit>
        <trans-unit id="1021" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.Sort(System.Int32,System.Int32,System.Collections.Generic.IComparer{`0})">
          <source>The example defines an alternative comparer for strings named DinoCompare, which implements the <ph id="ph1">`IComparer&lt;string&gt;`</ph> (<ph id="ph2">`IComparer(Of String)`</ph> in Visual Basic, <ph id="ph3">`IComparer&lt;String^&gt;`</ph> in Visual C++) generic interface.</source>
          <target state="translated">En el ejemplo se define un comparador alternativo para las cadenas denominado DinoCompare, que implementa el <ph id="ph1">`IComparer&lt;string&gt;`</ph> (<ph id="ph2">`IComparer(Of String)`</ph> en Visual Basic, <ph id="ph3">`IComparer&lt;String^&gt;`</ph> en Visual C++) interfaz genérica.</target>       </trans-unit>
        <trans-unit id="1022" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.Sort(System.Int32,System.Int32,System.Collections.Generic.IComparer{`0})">
          <source>The comparer works as follows: First, the comparands are tested for <ph id="ph1">`null`</ph>, and a null reference is treated as less than a non-null.</source>
          <target state="translated">El comparador funciona del siguiente modo: en primer lugar, la comparación se comprueba si hay <ph id="ph1">`null`</ph>, y una referencia nula es tratada como menor que un valor no nulo.</target>       </trans-unit>
        <trans-unit id="1023" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.Sort(System.Int32,System.Int32,System.Collections.Generic.IComparer{`0})">
          <source>Second, the string lengths are compared, and the longer string is deemed to be greater.</source>
          <target state="translated">En segundo lugar, se comparan las longitudes de cadena y la cadena más larga se considera mayor.</target>       </trans-unit>
        <trans-unit id="1024" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.Sort(System.Int32,System.Int32,System.Collections.Generic.IComparer{`0})">
          <source>Third, if the lengths are equal, ordinary string comparison is used.</source>
          <target state="translated">En tercer lugar, si las longitudes son iguales, se usa la comparación de cadenas normales.</target>       </trans-unit>
        <trans-unit id="1025" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.Sort(System.Int32,System.Int32,System.Collections.Generic.IComparer{`0})">
          <source>A <ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph> of strings is created and populated with the names of five herbivorous dinosaurs and three carnivorous dinosaurs.</source>
          <target state="translated">Un <ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph> de cadenas se crean y rellenan con los nombres de cinco dinosaurios herbívoros y tres dinosaurios carnívoros.</target>       </trans-unit>
        <trans-unit id="1026" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.Sort(System.Int32,System.Int32,System.Collections.Generic.IComparer{`0})">
          <source>Within each of the two groups, the names are not in any particular sort order.</source>
          <target state="translated">Dentro de cada uno de los dos grupos, los nombres no están en ningún orden determinado.</target>       </trans-unit>
        <trans-unit id="1027" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.Sort(System.Int32,System.Int32,System.Collections.Generic.IComparer{`0})">
          <source>The list is displayed, the range of herbivores is sorted using the alternate comparer, and the list is displayed again.</source>
          <target state="translated">Se muestra la lista, se ordena el intervalo de herbívoros utilizando al comparador alternativo y se muestra la lista de nuevo.</target>       </trans-unit>
        <trans-unit id="1028" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.Sort(System.Int32,System.Int32,System.Collections.Generic.IComparer{`0})">
          <source>The <ph id="ph1">&lt;xref:System.Collections.Generic.List%601.BinarySearch%28System.Int32%2CSystem.Int32%2C%600%2CSystem.Collections.Generic.IComparer%7B%600%7D%29&gt;</ph> method overload is then used to search only the range of herbivores for "Brachiosaurus".</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.Collections.Generic.List%601.BinarySearch%28System.Int32%2CSystem.Int32%2C%600%2CSystem.Collections.Generic.IComparer%7B%600%7D%29&gt;</ph> , a continuación, se utiliza la sobrecarga del método para buscar sólo el intervalo de herbívoros "Brachiosaurus".</target>       </trans-unit>
        <trans-unit id="1029" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.Sort(System.Int32,System.Int32,System.Collections.Generic.IComparer{`0})">
          <source>The string is not found, and the bitwise complement (the ~ operator in C# and Visual C++, <ph id="ph1">`Xor`</ph> -1 in Visual Basic) of the negative number returned by the <ph id="ph2">&lt;xref:System.Collections.Generic.List%601.BinarySearch%28System.Int32%2CSystem.Int32%2C%600%2CSystem.Collections.Generic.IComparer%7B%600%7D%29&gt;</ph> method is used as an index for inserting the new string.</source>
          <target state="translated">No se encuentra la cadena y el complemento bit a bit (el ~ operador en C# y Visual C++, <ph id="ph1">`Xor`</ph> -1 en Visual Basic) del número negativo devuelto por la <ph id="ph2">&lt;xref:System.Collections.Generic.List%601.BinarySearch%28System.Int32%2CSystem.Int32%2C%600%2CSystem.Collections.Generic.IComparer%7B%600%7D%29&gt;</ph> método se utiliza como un índice para insertar la nueva cadena.</target>       </trans-unit>
        <trans-unit id="1030" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.List`1.Sort(System.Int32,System.Int32,System.Collections.Generic.IComparer{`0})">
          <source><ph id="ph1">&lt;paramref name="index" /&gt;</ph> is less than 0.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="index" /&gt;</ph> es menor que 0.</target>       </trans-unit>
        <trans-unit id="1031" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.List`1.Sort(System.Int32,System.Int32,System.Collections.Generic.IComparer{`0})">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="1032" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.List`1.Sort(System.Int32,System.Int32,System.Collections.Generic.IComparer{`0})">
          <source><ph id="ph1">&lt;paramref name="count" /&gt;</ph> is less than 0.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="count" /&gt;</ph> es menor que 0.</target>       </trans-unit>
        <trans-unit id="1033" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.List`1.Sort(System.Int32,System.Int32,System.Collections.Generic.IComparer{`0})">
          <source><ph id="ph1">&lt;paramref name="index" /&gt;</ph> and <ph id="ph2">&lt;paramref name="count" /&gt;</ph> do not specify a valid range in the <ph id="ph3">&lt;see cref="T:System.Collections.Generic.List`1" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="index" /&gt;</ph> y <ph id="ph2">&lt;paramref name="count" /&gt;</ph> no especifican un intervalo válido en <ph id="ph3">&lt;see cref="T:System.Collections.Generic.List`1" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1034" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.List`1.Sort(System.Int32,System.Int32,System.Collections.Generic.IComparer{`0})">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="1035" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.List`1.Sort(System.Int32,System.Int32,System.Collections.Generic.IComparer{`0})">
          <source>The implementation of <ph id="ph1">&lt;paramref name="comparer" /&gt;</ph> caused an error during the sort.</source>
          <target state="translated">La implementación de <ph id="ph1">&lt;paramref name="comparer" /&gt;</ph> produjo un error durante la ordenación.</target>       </trans-unit>
        <trans-unit id="1036" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.List`1.Sort(System.Int32,System.Int32,System.Collections.Generic.IComparer{`0})">
          <source>For example, <ph id="ph1">&lt;paramref name="comparer" /&gt;</ph> might not return 0 when comparing an item with itself.</source>
          <target state="translated">Por ejemplo, es posible que <ph id="ph1">&lt;paramref name="comparer" /&gt;</ph> no devuelva 0 al comparar un elemento consigo mismo.</target>       </trans-unit>
        <trans-unit id="1037" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.List`1.Sort(System.Int32,System.Int32,System.Collections.Generic.IComparer{`0})">
          <source><ph id="ph1">&lt;paramref name="comparer" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>, and the default comparer <ph id="ph3">&lt;see cref="P:System.Collections.Generic.Comparer`1.Default" /&gt;</ph> cannot find implementation of the <ph id="ph4">&lt;see cref="T:System.IComparable`1" /&gt;</ph> generic interface or the <ph id="ph5">&lt;see cref="T:System.IComparable" /&gt;</ph> interface for type <ph id="ph6">&lt;paramref name="T" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="comparer" /&gt;</ph> es <ph id="ph2">&lt;see langword="null" /&gt;</ph>, y el comparador predeterminado <ph id="ph3">&lt;see cref="P:System.Collections.Generic.Comparer`1.Default" /&gt;</ph> no puede encontrar una implementación de la interfaz genérica <ph id="ph4">&lt;see cref="T:System.IComparable`1" /&gt;</ph> o la interfaz <ph id="ph5">&lt;see cref="T:System.IComparable" /&gt;</ph> del tipo <ph id="ph6">&lt;paramref name="T" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1038" translate="yes" xml:space="preserve" uid="P:System.Collections.Generic.List`1.System#Collections#Generic#ICollection&amp;lt;T&amp;gt;#IsReadOnly">
          <source>Gets a value indicating whether the <ph id="ph1">&lt;see cref="T:System.Collections.Generic.ICollection`1" /&gt;</ph> is read-only.</source>
          <target state="translated">Obtiene un valor que indica si <ph id="ph1">&lt;see cref="T:System.Collections.Generic.ICollection`1" /&gt;</ph> es de solo lectura.</target>       </trans-unit>
        <trans-unit id="1039" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.Generic.List`1.System#Collections#Generic#ICollection&amp;lt;T&amp;gt;#IsReadOnly">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the <ph id="ph2">&lt;see cref="T:System.Collections.Generic.ICollection`1" /&gt;</ph> is read-only; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">Es <ph id="ph1">&lt;see langword="true" /&gt;</ph> si la interfaz <ph id="ph2">&lt;see cref="T:System.Collections.Generic.ICollection`1" /&gt;</ph> es de solo lectura; de lo contrario, es <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1040" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.Generic.List`1.System#Collections#Generic#ICollection&amp;lt;T&amp;gt;#IsReadOnly">
          <source>In the default implementation of <ph id="ph1">&lt;see cref="T:System.Collections.Generic.List`1" /&gt;</ph>, this property always returns <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">En la implementación predeterminada de <ph id="ph1">&lt;see cref="T:System.Collections.Generic.List`1" /&gt;</ph>, esta propiedad siempre devuelve <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1041" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.Generic.List`1.System#Collections#Generic#ICollection&amp;lt;T&amp;gt;#IsReadOnly">
          <source>A collection that is read-only does not allow the addition, removal, or modification of elements after the collection is created.</source>
          <target state="translated">Una colección de solo lectura no permite que se agreguen, quiten o modifiquen elementos una vez que se ha creado.</target>       </trans-unit>
        <trans-unit id="1042" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.Generic.List`1.System#Collections#Generic#ICollection&amp;lt;T&amp;gt;#IsReadOnly">
          <source>A collection that is read-only is simply a collection with a wrapper that prevents modifying the collection; therefore, if changes are made to the underlying collection, the read-only collection reflects those changes.</source>
          <target state="translated">Una colección que es de solo lectura es simplemente una colección con un contenedor que impide modificar la colección; por lo tanto, si se realizan cambios en la colección subyacente, la colección de solo lectura refleja esos cambios.</target>       </trans-unit>
        <trans-unit id="1043" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.Generic.List`1.System#Collections#Generic#ICollection&amp;lt;T&amp;gt;#IsReadOnly">
          <source>Retrieving the value of this property is an O(1) operation.</source>
          <target state="translated">La recuperación del valor de esta propiedad es una operación O(1).</target>       </trans-unit>
        <trans-unit id="1044" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.List`1.System#Collections#Generic#IEnumerable&amp;lt;T&amp;gt;#GetEnumerator">
          <source>Returns an enumerator that iterates through a collection.</source>
          <target state="translated">Devuelve un enumerador que recorre en iteración una colección.</target>       </trans-unit>
        <trans-unit id="1045" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.List`1.System#Collections#Generic#IEnumerable&amp;lt;T&amp;gt;#GetEnumerator">
          <source>An <ph id="ph1">&lt;see cref="T:System.Collections.Generic.IEnumerator`1" /&gt;</ph> that can be used to iterate through the collection.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Collections.Generic.IEnumerator`1" /&gt;</ph> que se puede utilizar para recorrer en iteración la colección.</target>       </trans-unit>
        <trans-unit id="1046" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.System#Collections#Generic#IEnumerable&amp;lt;T&amp;gt;#GetEnumerator">
          <source>The <ph id="ph1">`foreach`</ph> statement of the C# language (<ph id="ph2">`for each`</ph> in C++, <ph id="ph3">`For Each`</ph> in Visual Basic) hides the complexity of the enumerators.</source>
          <target state="translated">El <ph id="ph1">`foreach`</ph> instrucción del lenguaje C# (<ph id="ph2">`for each`</ph> en C++, <ph id="ph3">`For Each`</ph> en Visual Basic) oculta la complejidad de los enumeradores.</target>       </trans-unit>
        <trans-unit id="1047" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.System#Collections#Generic#IEnumerable&amp;lt;T&amp;gt;#GetEnumerator">
          <source>Therefore, using <ph id="ph1">`foreach`</ph> is recommended, instead of directly manipulating the enumerator.</source>
          <target state="translated">Por lo tanto, se recomienda el uso de <ph id="ph1">`foreach`</ph>, en lugar de manipular directamente el enumerador.</target>       </trans-unit>
        <trans-unit id="1048" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.System#Collections#Generic#IEnumerable&amp;lt;T&amp;gt;#GetEnumerator">
          <source>Enumerators can be used to read the data in the collection, but they cannot be used to modify the underlying collection.</source>
          <target state="translated">Los enumeradores pueden usarse para leer los datos de la colección, pero no para modificar la colección subyacente.</target>       </trans-unit>
        <trans-unit id="1049" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.System#Collections#Generic#IEnumerable&amp;lt;T&amp;gt;#GetEnumerator">
          <source>Initially, the enumerator is positioned before the first element in the collection.</source>
          <target state="translated">En principio, el enumerador se coloca antes del primer elemento de la colección.</target>       </trans-unit>
        <trans-unit id="1050" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.System#Collections#Generic#IEnumerable&amp;lt;T&amp;gt;#GetEnumerator">
          <source>At this position, the <ph id="ph1">&lt;xref:System.Collections.Generic.IEnumerator%601.Current%2A&gt;</ph> property is undefined.</source>
          <target state="translated">En esta posición, el <ph id="ph1">&lt;xref:System.Collections.Generic.IEnumerator%601.Current%2A&gt;</ph> propiedad no está definida.</target>       </trans-unit>
        <trans-unit id="1051" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.System#Collections#Generic#IEnumerable&amp;lt;T&amp;gt;#GetEnumerator">
          <source>Therefore, you must call the <ph id="ph1">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph> method to advance the enumerator to the first element of the collection before reading the value of <ph id="ph2">&lt;xref:System.Collections.Generic.IEnumerator%601.Current%2A&gt;</ph>.</source>
          <target state="translated">Por lo tanto, debe llamar a la <ph id="ph1">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph> método para adelantar el enumerador hasta el primer elemento de la colección antes de leer el valor de <ph id="ph2">&lt;xref:System.Collections.Generic.IEnumerator%601.Current%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1052" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.System#Collections#Generic#IEnumerable&amp;lt;T&amp;gt;#GetEnumerator">
          <source>The <ph id="ph1">&lt;xref:System.Collections.Generic.IEnumerator%601.Current%2A&gt;</ph> property returns the same object until <ph id="ph2">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph> is called.</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.Collections.Generic.IEnumerator%601.Current%2A&gt;</ph> propiedad devuelve el mismo objeto hasta que <ph id="ph2">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph> se llama.</target>       </trans-unit>
        <trans-unit id="1053" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.System#Collections#Generic#IEnumerable&amp;lt;T&amp;gt;#GetEnumerator">
          <source><ph id="ph1">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph> sets <ph id="ph2">&lt;xref:System.Collections.Generic.IEnumerator%601.Current%2A&gt;</ph> to the next element.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph> establece <ph id="ph2">&lt;xref:System.Collections.Generic.IEnumerator%601.Current%2A&gt;</ph> en el siguiente elemento.</target>       </trans-unit>
        <trans-unit id="1054" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.System#Collections#Generic#IEnumerable&amp;lt;T&amp;gt;#GetEnumerator">
          <source>If <ph id="ph1">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph> passes the end of the collection, the enumerator is positioned after the last element in the collection and <ph id="ph2">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph> returns <ph id="ph3">`false`</ph>.</source>
          <target state="translated">Si <ph id="ph1">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph> pasa el final de la colección, el enumerador se coloca después del último elemento de la colección y <ph id="ph2">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph> devuelve <ph id="ph3">`false`</ph>.</target>       </trans-unit>
        <trans-unit id="1055" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.System#Collections#Generic#IEnumerable&amp;lt;T&amp;gt;#GetEnumerator">
          <source>When the enumerator is at this position, subsequent calls to <ph id="ph1">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph> also return <ph id="ph2">`false`</ph>.</source>
          <target state="translated">Mientras el enumerador permanezca en esta posición, las llamadas subsiguientes a <ph id="ph1">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph> también devolver <ph id="ph2">`false`</ph>.</target>       </trans-unit>
        <trans-unit id="1056" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.System#Collections#Generic#IEnumerable&amp;lt;T&amp;gt;#GetEnumerator">
          <source>If the last call to <ph id="ph1">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph> returned <ph id="ph2">`false`</ph>, <ph id="ph3">&lt;xref:System.Collections.Generic.IEnumerator%601.Current%2A&gt;</ph> is undefined.</source>
          <target state="translated">Si la última llamada a <ph id="ph1">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph> devuelve <ph id="ph2">`false`</ph>, <ph id="ph3">&lt;xref:System.Collections.Generic.IEnumerator%601.Current%2A&gt;</ph> no está definido.</target>       </trans-unit>
        <trans-unit id="1057" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.System#Collections#Generic#IEnumerable&amp;lt;T&amp;gt;#GetEnumerator">
          <source>You cannot set <ph id="ph1">&lt;xref:System.Collections.Generic.IEnumerator%601.Current%2A&gt;</ph> to the first element of the collection again; you must create a new enumerator instance instead.</source>
          <target state="translated">No puede volver a establecer la propiedad <ph id="ph1">&lt;xref:System.Collections.Generic.IEnumerator%601.Current%2A&gt;</ph> en el primer elemento de la colección, sino que debe crear una nueva instancia del enumerador.</target>       </trans-unit>
        <trans-unit id="1058" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.System#Collections#Generic#IEnumerable&amp;lt;T&amp;gt;#GetEnumerator">
          <source>An enumerator remains valid as long as the collection remains unchanged.</source>
          <target state="translated">Un enumerador es válido mientras la colección no cambie.</target>       </trans-unit>
        <trans-unit id="1059" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.System#Collections#Generic#IEnumerable&amp;lt;T&amp;gt;#GetEnumerator">
          <source>If changes are made to the collection, such as adding, modifying, or deleting elements, the enumerator is irrecoverably invalidated and its behavior is undefined.</source>
          <target state="translated">Si se hacen cambios en la colección (como agregar, modificar o eliminar elementos), el enumerador queda invalidado permanentemente y su comportamiento es indefinido.</target>       </trans-unit>
        <trans-unit id="1060" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.System#Collections#Generic#IEnumerable&amp;lt;T&amp;gt;#GetEnumerator">
          <source>The enumerator does not have exclusive access to the collection; therefore, enumerating through a collection is intrinsically not a thread-safe procedure.</source>
          <target state="translated">El enumerador no tiene acceso exclusivo a la colección y, por tanto, la enumeración en una colección no es intrínsicamente un procedimiento seguro para subprocesos.</target>       </trans-unit>
        <trans-unit id="1061" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.System#Collections#Generic#IEnumerable&amp;lt;T&amp;gt;#GetEnumerator">
          <source>To guarantee thread safety during enumeration, you can lock the collection during the entire enumeration.</source>
          <target state="translated">A fin de garantizar la seguridad de los subprocesos, se puede bloquear la colección durante toda la enumeración.</target>       </trans-unit>
        <trans-unit id="1062" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.System#Collections#Generic#IEnumerable&amp;lt;T&amp;gt;#GetEnumerator">
          <source>To allow the collection to be accessed by multiple threads for reading and writing, you must implement your own synchronization.</source>
          <target state="translated">Para permitir que varios subprocesos obtengan acceso de lectura y escritura a la colección, debe implementar su propia sincronización.</target>       </trans-unit>
        <trans-unit id="1063" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.System#Collections#Generic#IEnumerable&amp;lt;T&amp;gt;#GetEnumerator">
          <source>Default implementations of collections in the <ph id="ph1">&lt;xref:System.Collections.Generic?displayProperty=nameWithType&gt;</ph> namespace are not synchronized.</source>
          <target state="translated">Las implementaciones predeterminadas de las colecciones del espacio de nombres <ph id="ph1">&lt;xref:System.Collections.Generic?displayProperty=nameWithType&gt;</ph> no están sincronizadas.</target>       </trans-unit>
        <trans-unit id="1064" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.System#Collections#Generic#IEnumerable&amp;lt;T&amp;gt;#GetEnumerator">
          <source>This method is an O(1) operation.</source>
          <target state="translated">Este método es una operación o (1).</target>       </trans-unit>
        <trans-unit id="1065" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.List`1.System#Collections#ICollection#CopyTo(System.Array,System.Int32)">
          <source>The one-dimensional <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> that is the destination of the elements copied from <ph id="ph2">&lt;see cref="T:System.Collections.ICollection" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> unidimensional que constituye el destino de los elementos copiados de <ph id="ph2">&lt;see cref="T:System.Collections.ICollection" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1066" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.List`1.System#Collections#ICollection#CopyTo(System.Array,System.Int32)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> must have zero-based indexing.</source>
          <target state="translated">La matriz <ph id="ph1">&lt;see cref="T:System.Array" /&gt;</ph> debe tener una indización de base cero.</target>       </trans-unit>
        <trans-unit id="1067" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.List`1.System#Collections#ICollection#CopyTo(System.Array,System.Int32)">
          <source>The zero-based index in <bpt id="p1">&lt;c&gt;</bpt>array<ept id="p1">&lt;/c&gt;</ept> at which copying begins.</source>
          <target state="translated">Índice de base cero de <bpt id="p1">&lt;c&gt;</bpt>array<ept id="p1">&lt;/c&gt;</ept> donde comienza la copia.</target>       </trans-unit>
        <trans-unit id="1068" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.List`1.System#Collections#ICollection#CopyTo(System.Array,System.Int32)">
          <source>Copies the elements of the <ph id="ph1">&lt;see cref="T:System.Collections.ICollection" /&gt;</ph> to an <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph>, starting at a particular <ph id="ph3">&lt;see cref="T:System.Array" /&gt;</ph> index.</source>
          <target state="translated">Copia los elementos de <ph id="ph1">&lt;see cref="T:System.Collections.ICollection" /&gt;</ph> en <ph id="ph2">&lt;see cref="T:System.Array" /&gt;</ph>, empezando por un índice determinado de <ph id="ph3">&lt;see cref="T:System.Array" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1069" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.System#Collections#ICollection#CopyTo(System.Array,System.Int32)">
          <source>If the type of the source <ph id="ph1">&lt;xref:System.Collections.ICollection&gt;</ph> cannot be cast automatically to the type of the destination <ph id="ph2">`array`</ph>, the nongeneric implementations of <ph id="ph3">&lt;xref:System.Collections.ICollection.CopyTo%2A?displayProperty=nameWithType&gt;</ph> throw <ph id="ph4">&lt;xref:System.InvalidCastException&gt;</ph>, whereas the generic implementations throw <ph id="ph5">&lt;xref:System.ArgumentException&gt;</ph>.</source>
          <target state="translated">Si el tipo del origen de <ph id="ph1">&lt;xref:System.Collections.ICollection&gt;</ph> no puede convertirse automáticamente al tipo del destino de <ph id="ph2">`array`</ph>, las implementaciones no genéricas de <ph id="ph3">&lt;xref:System.Collections.ICollection.CopyTo%2A?displayProperty=nameWithType&gt;</ph> throw <ph id="ph4">&lt;xref:System.InvalidCastException&gt;</ph>, mientras que las implementaciones genéricas inician <ph id="ph5">&lt;xref:System.ArgumentException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1070" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.System#Collections#ICollection#CopyTo(System.Array,System.Int32)">
          <source>This method is an O(<bpt id="p1">*</bpt>n<ept id="p1">*</ept>) operation, where <bpt id="p2">*</bpt>n<ept id="p2">*</ept> is <ph id="ph1">&lt;xref:System.Collections.Generic.List%601.Count%2A&gt;</ph>.</source>
          <target state="translated">Este método es una O (<bpt id="p1">*</bpt>n<ept id="p1">*</ept>) operación, donde <bpt id="p2">*</bpt>n<ept id="p2">*</ept> es <ph id="ph1">&lt;xref:System.Collections.Generic.List%601.Count%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1071" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.List`1.System#Collections#ICollection#CopyTo(System.Array,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="array" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="array" /&gt;</ph> es <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1072" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.List`1.System#Collections#ICollection#CopyTo(System.Array,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="arrayIndex" /&gt;</ph> is less than 0.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="arrayIndex" /&gt;</ph> es menor que 0.</target>       </trans-unit>
        <trans-unit id="1073" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.List`1.System#Collections#ICollection#CopyTo(System.Array,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="array" /&gt;</ph> is multidimensional.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="array" /&gt;</ph> es multidimensional.</target>       </trans-unit>
        <trans-unit id="1074" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.List`1.System#Collections#ICollection#CopyTo(System.Array,System.Int32)">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="1075" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.List`1.System#Collections#ICollection#CopyTo(System.Array,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="array" /&gt;</ph> does not have zero-based indexing.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="array" /&gt;</ph> no tiene índices de base cero.</target>       </trans-unit>
        <trans-unit id="1076" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.List`1.System#Collections#ICollection#CopyTo(System.Array,System.Int32)">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="1077" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.List`1.System#Collections#ICollection#CopyTo(System.Array,System.Int32)">
          <source>The number of elements in the source <ph id="ph1">&lt;see cref="T:System.Collections.ICollection" /&gt;</ph> is greater than the available space from <ph id="ph2">&lt;paramref name="arrayIndex" /&gt;</ph> to the end of the destination <ph id="ph3">&lt;paramref name="array" /&gt;</ph>.</source>
          <target state="translated">El número de elementos de la <ph id="ph1">&lt;see cref="T:System.Collections.ICollection" /&gt;</ph> de origen es mayor que el espacio disponible desde <ph id="ph2">&lt;paramref name="arrayIndex" /&gt;</ph> hasta el final de la <ph id="ph3">&lt;paramref name="array" /&gt;</ph> de destino.</target>       </trans-unit>
        <trans-unit id="1078" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.List`1.System#Collections#ICollection#CopyTo(System.Array,System.Int32)">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="1079" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.List`1.System#Collections#ICollection#CopyTo(System.Array,System.Int32)">
          <source>The type of the source <ph id="ph1">&lt;see cref="T:System.Collections.ICollection" /&gt;</ph> cannot be cast automatically to the type of the destination <ph id="ph2">&lt;paramref name="array" /&gt;</ph>.</source>
          <target state="translated">El tipo de la <ph id="ph1">&lt;see cref="T:System.Collections.ICollection" /&gt;</ph> de origen no puede convertirse automáticamente al tipo de la <ph id="ph2">&lt;paramref name="array" /&gt;</ph> de destino.</target>       </trans-unit>
        <trans-unit id="1080" translate="yes" xml:space="preserve" uid="P:System.Collections.Generic.List`1.System#Collections#ICollection#IsSynchronized">
          <source>Gets a value indicating whether access to the <ph id="ph1">&lt;see cref="T:System.Collections.ICollection" /&gt;</ph> is synchronized (thread safe).</source>
          <target state="translated">Obtiene un valor que indica si el acceso a la interfaz <ph id="ph1">&lt;see cref="T:System.Collections.ICollection" /&gt;</ph> está sincronizado (es seguro para subprocesos).</target>       </trans-unit>
        <trans-unit id="1081" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.Generic.List`1.System#Collections#ICollection#IsSynchronized">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if access to the <ph id="ph2">&lt;see cref="T:System.Collections.ICollection" /&gt;</ph> is synchronized (thread safe); otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">Es <ph id="ph1">&lt;see langword="true" /&gt;</ph> si el acceso a <ph id="ph2">&lt;see cref="T:System.Collections.ICollection" /&gt;</ph> está sincronizado (es seguro para subprocesos); de lo contrario, es <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1082" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.Generic.List`1.System#Collections#ICollection#IsSynchronized">
          <source>In the default implementation of <ph id="ph1">&lt;see cref="T:System.Collections.Generic.List`1" /&gt;</ph>, this property always returns <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">En la implementación predeterminada de <ph id="ph1">&lt;see cref="T:System.Collections.Generic.List`1" /&gt;</ph>, esta propiedad siempre devuelve <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1083" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.Generic.List`1.System#Collections#ICollection#IsSynchronized">
          <source>Default implementations of collections in the <ph id="ph1">&lt;xref:System.Collections.Generic?displayProperty=nameWithType&gt;</ph> namespace are not synchronized.</source>
          <target state="translated">Las implementaciones predeterminadas de las colecciones del espacio de nombres <ph id="ph1">&lt;xref:System.Collections.Generic?displayProperty=nameWithType&gt;</ph> no están sincronizadas.</target>       </trans-unit>
        <trans-unit id="1084" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.Generic.List`1.System#Collections#ICollection#IsSynchronized">
          <source>Enumerating through a collection is intrinsically not a thread-safe procedure.</source>
          <target state="translated">Enumerar una colección no es intrínsecamente un procedimiento seguro para subprocesos.</target>       </trans-unit>
        <trans-unit id="1085" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.Generic.List`1.System#Collections#ICollection#IsSynchronized">
          <source>In the rare case where enumeration contends with write accesses, you can lock the collection during the entire enumeration.</source>
          <target state="translated">En el caso excepcional donde enumeración sostiene con accesos de escritura, puede bloquear la colección durante toda la enumeración.</target>       </trans-unit>
        <trans-unit id="1086" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.Generic.List`1.System#Collections#ICollection#IsSynchronized">
          <source>To allow the collection to be accessed by multiple threads for reading and writing, you must implement your own synchronization.</source>
          <target state="translated">Para permitir que varios subprocesos obtengan acceso de lectura y escritura a la colección, debe implementar su propia sincronización.</target>       </trans-unit>
        <trans-unit id="1087" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.Generic.List`1.System#Collections#ICollection#IsSynchronized">
          <source><ph id="ph1">&lt;xref:System.Collections.ICollection.SyncRoot%2A&gt;</ph> returns an object that can be used to synchronize access to the <ph id="ph2">&lt;xref:System.Collections.ICollection&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Collections.ICollection.SyncRoot%2A&gt;</ph> Devuelve un objeto que puede utilizarse para sincronizar el acceso a la <ph id="ph2">&lt;xref:System.Collections.ICollection&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1088" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.Generic.List`1.System#Collections#ICollection#IsSynchronized">
          <source>Synchronization is effective only if all threads lock this object before accessing the collection.</source>
          <target state="translated">La sincronización es efectiva sólo si todos los subprocesos bloquean este objeto antes de obtener acceso a la colección.</target>       </trans-unit>
        <trans-unit id="1089" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.Generic.List`1.System#Collections#ICollection#IsSynchronized">
          <source>Retrieving the value of this property is an O(1) operation.</source>
          <target state="translated">La recuperación del valor de esta propiedad es una operación O(1).</target>       </trans-unit>
        <trans-unit id="1090" translate="yes" xml:space="preserve" uid="P:System.Collections.Generic.List`1.System#Collections#ICollection#SyncRoot">
          <source>Gets an object that can be used to synchronize access to the <ph id="ph1">&lt;see cref="T:System.Collections.ICollection" /&gt;</ph>.</source>
          <target state="translated">Obtiene un objeto que se puede usar para sincronizar el acceso a <ph id="ph1">&lt;see cref="T:System.Collections.ICollection" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1091" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.Generic.List`1.System#Collections#ICollection#SyncRoot">
          <source>An object that can be used to synchronize access to the <ph id="ph1">&lt;see cref="T:System.Collections.ICollection" /&gt;</ph>.</source>
          <target state="translated">Objeto que se puede usar para sincronizar el acceso a <ph id="ph1">&lt;see cref="T:System.Collections.ICollection" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1092" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.Generic.List`1.System#Collections#ICollection#SyncRoot">
          <source>In the default implementation of <ph id="ph1">&lt;see cref="T:System.Collections.Generic.List`1" /&gt;</ph>, this property always returns the current instance.</source>
          <target state="translated">En la implementación predeterminada de <ph id="ph1">&lt;see cref="T:System.Collections.Generic.List`1" /&gt;</ph>, esta propiedad siempre devuelve la instancia actual.</target>       </trans-unit>
        <trans-unit id="1093" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.Generic.List`1.System#Collections#ICollection#SyncRoot">
          <source>Default implementations of collections in the <ph id="ph1">&lt;xref:System.Collections.Generic?displayProperty=nameWithType&gt;</ph> namespace are not synchronized.</source>
          <target state="translated">Las implementaciones predeterminadas de las colecciones del espacio de nombres <ph id="ph1">&lt;xref:System.Collections.Generic?displayProperty=nameWithType&gt;</ph> no están sincronizadas.</target>       </trans-unit>
        <trans-unit id="1094" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.Generic.List`1.System#Collections#ICollection#SyncRoot">
          <source>Enumerating through a collection is intrinsically not a thread-safe procedure.</source>
          <target state="translated">Enumerar una colección no es intrínsecamente un procedimiento seguro para subprocesos.</target>       </trans-unit>
        <trans-unit id="1095" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.Generic.List`1.System#Collections#ICollection#SyncRoot">
          <source>To guarantee thread safety during enumeration, you can lock the collection during the entire enumeration.</source>
          <target state="translated">A fin de garantizar la seguridad de los subprocesos, se puede bloquear la colección durante toda la enumeración.</target>       </trans-unit>
        <trans-unit id="1096" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.Generic.List`1.System#Collections#ICollection#SyncRoot">
          <source>To allow the collection to be accessed by multiple threads for reading and writing, you must implement your own synchronization.</source>
          <target state="translated">Para permitir que varios subprocesos obtengan acceso de lectura y escritura a la colección, debe implementar su propia sincronización.</target>       </trans-unit>
        <trans-unit id="1097" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.Generic.List`1.System#Collections#ICollection#SyncRoot">
          <source><ph id="ph1">&lt;xref:System.Collections.ICollection.SyncRoot%2A&gt;</ph> returns an object that can be used to synchronize access to the <ph id="ph2">&lt;xref:System.Collections.ICollection&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Collections.ICollection.SyncRoot%2A&gt;</ph> Devuelve un objeto que puede utilizarse para sincronizar el acceso a la <ph id="ph2">&lt;xref:System.Collections.ICollection&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1098" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.Generic.List`1.System#Collections#ICollection#SyncRoot">
          <source>Synchronization is effective only if all threads lock this object before accessing the collection.</source>
          <target state="translated">La sincronización es efectiva sólo si todos los subprocesos bloquean este objeto antes de obtener acceso a la colección.</target>       </trans-unit>
        <trans-unit id="1099" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.Generic.List`1.System#Collections#ICollection#SyncRoot">
          <source>The following code shows the use of the <ph id="ph1">&lt;xref:System.Collections.ICollection.SyncRoot%2A&gt;</ph> property for C#, C++, and Visual Basic.</source>
          <target state="translated">El código siguiente muestra el uso de la <ph id="ph1">&lt;xref:System.Collections.ICollection.SyncRoot%2A&gt;</ph> propiedad para C#, C++ y Visual Basic.</target>       </trans-unit>
        <trans-unit id="1100" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.Generic.List`1.System#Collections#ICollection#SyncRoot">
          <source>Retrieving the value of this property is an O(1) operation.</source>
          <target state="translated">La recuperación del valor de esta propiedad es una operación O(1).</target>       </trans-unit>
        <trans-unit id="1101" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.List`1.System#Collections#IEnumerable#GetEnumerator">
          <source>Returns an enumerator that iterates through a collection.</source>
          <target state="translated">Devuelve un enumerador que recorre en iteración una colección.</target>       </trans-unit>
        <trans-unit id="1102" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.List`1.System#Collections#IEnumerable#GetEnumerator">
          <source>An <ph id="ph1">&lt;see cref="T:System.Collections.IEnumerator" /&gt;</ph> that can be used to iterate through the collection.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Collections.IEnumerator" /&gt;</ph> que se puede utilizar para recorrer en iteración la colección.</target>       </trans-unit>
        <trans-unit id="1103" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.System#Collections#IEnumerable#GetEnumerator">
          <source>The <ph id="ph1">`foreach`</ph> statement of the C# language (<ph id="ph2">`for each`</ph> in C++, <ph id="ph3">`For Each`</ph> in Visual Basic) hides the complexity of the enumerators.</source>
          <target state="translated">El <ph id="ph1">`foreach`</ph> instrucción del lenguaje C# (<ph id="ph2">`for each`</ph> en C++, <ph id="ph3">`For Each`</ph> en Visual Basic) oculta la complejidad de los enumeradores.</target>       </trans-unit>
        <trans-unit id="1104" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.System#Collections#IEnumerable#GetEnumerator">
          <source>Therefore, using <ph id="ph1">`foreach`</ph> is recommended, instead of directly manipulating the enumerator.</source>
          <target state="translated">Por lo tanto, se recomienda el uso de <ph id="ph1">`foreach`</ph>, en lugar de manipular directamente el enumerador.</target>       </trans-unit>
        <trans-unit id="1105" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.System#Collections#IEnumerable#GetEnumerator">
          <source>Enumerators can be used to read the data in the collection, but they cannot be used to modify the underlying collection.</source>
          <target state="translated">Los enumeradores pueden usarse para leer los datos de la colección, pero no para modificar la colección subyacente.</target>       </trans-unit>
        <trans-unit id="1106" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.System#Collections#IEnumerable#GetEnumerator">
          <source>Initially, the enumerator is positioned before the first element in the collection.</source>
          <target state="translated">En principio, el enumerador se coloca antes del primer elemento de la colección.</target>       </trans-unit>
        <trans-unit id="1107" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.System#Collections#IEnumerable#GetEnumerator">
          <source><ph id="ph1">&lt;xref:System.Collections.IEnumerator.Reset%2A&gt;</ph> also brings the enumerator back to this position.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Collections.IEnumerator.Reset%2A&gt;</ph> también devuelve el enumerador a esta posición.</target>       </trans-unit>
        <trans-unit id="1108" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.System#Collections#IEnumerable#GetEnumerator">
          <source>At this position, the <ph id="ph1">&lt;xref:System.Collections.IEnumerator.Current%2A&gt;</ph> property is undefined.</source>
          <target state="translated">En esta posición, el <ph id="ph1">&lt;xref:System.Collections.IEnumerator.Current%2A&gt;</ph> propiedad no está definida.</target>       </trans-unit>
        <trans-unit id="1109" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.System#Collections#IEnumerable#GetEnumerator">
          <source>Therefore, you must call the <ph id="ph1">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph> method to advance the enumerator to the first element of the collection before reading the value of <ph id="ph2">&lt;xref:System.Collections.IEnumerator.Current%2A&gt;</ph>.</source>
          <target state="translated">Por lo tanto, debe llamar a la <ph id="ph1">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph> método para adelantar el enumerador hasta el primer elemento de la colección antes de leer el valor de <ph id="ph2">&lt;xref:System.Collections.IEnumerator.Current%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1110" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.System#Collections#IEnumerable#GetEnumerator">
          <source>The <ph id="ph1">&lt;xref:System.Collections.IEnumerator.Current%2A&gt;</ph> property returns the same object until either <ph id="ph2">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph> or <ph id="ph3">&lt;xref:System.Collections.IEnumerator.Reset%2A&gt;</ph> is called.</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.Collections.IEnumerator.Current%2A&gt;</ph> propiedad devuelve el mismo objeto hasta que <ph id="ph2">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph> o <ph id="ph3">&lt;xref:System.Collections.IEnumerator.Reset%2A&gt;</ph> se llama.</target>       </trans-unit>
        <trans-unit id="1111" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.System#Collections#IEnumerable#GetEnumerator">
          <source><ph id="ph1">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph> sets <ph id="ph2">&lt;xref:System.Collections.IEnumerator.Current%2A&gt;</ph> to the next element.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph> establece <ph id="ph2">&lt;xref:System.Collections.IEnumerator.Current%2A&gt;</ph> en el siguiente elemento.</target>       </trans-unit>
        <trans-unit id="1112" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.System#Collections#IEnumerable#GetEnumerator">
          <source>If <ph id="ph1">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph> passes the end of the collection, the enumerator is positioned after the last element in the collection and <ph id="ph2">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph> returns <ph id="ph3">`false`</ph>.</source>
          <target state="translated">Si <ph id="ph1">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph> pasa el final de la colección, el enumerador se coloca después del último elemento de la colección y <ph id="ph2">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph> devuelve <ph id="ph3">`false`</ph>.</target>       </trans-unit>
        <trans-unit id="1113" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.System#Collections#IEnumerable#GetEnumerator">
          <source>When the enumerator is at this position, subsequent calls to <ph id="ph1">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph> also return <ph id="ph2">`false`</ph>.</source>
          <target state="translated">Mientras el enumerador permanezca en esta posición, las llamadas subsiguientes a <ph id="ph1">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph> también devolver <ph id="ph2">`false`</ph>.</target>       </trans-unit>
        <trans-unit id="1114" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.System#Collections#IEnumerable#GetEnumerator">
          <source>If the last call to <ph id="ph1">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph> returned <ph id="ph2">`false`</ph>, <ph id="ph3">&lt;xref:System.Collections.IEnumerator.Current%2A&gt;</ph> is undefined.</source>
          <target state="translated">Si la última llamada a <ph id="ph1">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph> devuelve <ph id="ph2">`false`</ph>, <ph id="ph3">&lt;xref:System.Collections.IEnumerator.Current%2A&gt;</ph> no está definido.</target>       </trans-unit>
        <trans-unit id="1115" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.System#Collections#IEnumerable#GetEnumerator">
          <source>To set <ph id="ph1">&lt;xref:System.Collections.IEnumerator.Current%2A&gt;</ph> to the first element of the collection again, you can call <ph id="ph2">&lt;xref:System.Collections.IEnumerator.Reset%2A&gt;</ph> followed by <ph id="ph3">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph>.</source>
          <target state="translated">Para volver a establecer el valor de <ph id="ph1">&lt;xref:System.Collections.IEnumerator.Current%2A&gt;</ph> en el primer elemento de la colección, se puede llamar primero a <ph id="ph2">&lt;xref:System.Collections.IEnumerator.Reset%2A&gt;</ph> y después a <ph id="ph3">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1116" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.System#Collections#IEnumerable#GetEnumerator">
          <source>An enumerator remains valid as long as the collection remains unchanged.</source>
          <target state="translated">Un enumerador es válido mientras la colección no cambie.</target>       </trans-unit>
        <trans-unit id="1117" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.System#Collections#IEnumerable#GetEnumerator">
          <source>If changes are made to the collection, such as adding, modifying, or deleting elements, the enumerator is irrecoverably invalidated and its behavior is undefined.</source>
          <target state="translated">Si se hacen cambios en la colección (como agregar, modificar o eliminar elementos), el enumerador queda invalidado permanentemente y su comportamiento es indefinido.</target>       </trans-unit>
        <trans-unit id="1118" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.System#Collections#IEnumerable#GetEnumerator">
          <source>The enumerator does not have exclusive access to the collection; therefore, enumerating through a collection is intrinsically not a thread-safe procedure.</source>
          <target state="translated">El enumerador no tiene acceso exclusivo a la colección y, por tanto, la enumeración en una colección no es intrínsicamente un procedimiento seguro para subprocesos.</target>       </trans-unit>
        <trans-unit id="1119" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.System#Collections#IEnumerable#GetEnumerator">
          <source>To guarantee thread safety during enumeration, you can lock the collection during the entire enumeration.</source>
          <target state="translated">A fin de garantizar la seguridad de los subprocesos, se puede bloquear la colección durante toda la enumeración.</target>       </trans-unit>
        <trans-unit id="1120" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.System#Collections#IEnumerable#GetEnumerator">
          <source>To allow the collection to be accessed by multiple threads for reading and writing, you must implement your own synchronization.</source>
          <target state="translated">Para permitir que varios subprocesos obtengan acceso de lectura y escritura a la colección, debe implementar su propia sincronización.</target>       </trans-unit>
        <trans-unit id="1121" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.System#Collections#IEnumerable#GetEnumerator">
          <source>Default implementations of collections in the <ph id="ph1">&lt;xref:System.Collections.Generic?displayProperty=nameWithType&gt;</ph> namespace are not synchronized.</source>
          <target state="translated">Las implementaciones predeterminadas de las colecciones del espacio de nombres <ph id="ph1">&lt;xref:System.Collections.Generic?displayProperty=nameWithType&gt;</ph> no están sincronizadas.</target>       </trans-unit>
        <trans-unit id="1122" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.System#Collections#IEnumerable#GetEnumerator">
          <source>This method is an O(1) operation.</source>
          <target state="translated">Este método es una operación o (1).</target>       </trans-unit>
        <trans-unit id="1123" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.List`1.System#Collections#IList#Add(System.Object)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Object" /&gt;</ph> to add to the <ph id="ph2">&lt;see cref="T:System.Collections.IList" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Object" /&gt;</ph> que se va a agregar a <ph id="ph2">&lt;see cref="T:System.Collections.IList" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1124" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.List`1.System#Collections#IList#Add(System.Object)">
          <source>Adds an item to the <ph id="ph1">&lt;see cref="T:System.Collections.IList" /&gt;</ph>.</source>
          <target state="translated">Agrega un elemento a <ph id="ph1">&lt;see cref="T:System.Collections.IList" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1125" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.List`1.System#Collections#IList#Add(System.Object)">
          <source>The position into which the new element was inserted.</source>
          <target state="translated">Posición en la que se insertó el nuevo elemento.</target>       </trans-unit>
        <trans-unit id="1126" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.System#Collections#IList#Add(System.Object)">
          <source>If <ph id="ph1">&lt;xref:System.Collections.Generic.List%601.Count%2A&gt;</ph> is less than <ph id="ph2">&lt;xref:System.Collections.Generic.List%601.Capacity%2A&gt;</ph>, this method is an O(1) operation.</source>
          <target state="translated">Si <ph id="ph1">&lt;xref:System.Collections.Generic.List%601.Count%2A&gt;</ph> es menor que <ph id="ph2">&lt;xref:System.Collections.Generic.List%601.Capacity%2A&gt;</ph>, este método es una operación o (1).</target>       </trans-unit>
        <trans-unit id="1127" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.System#Collections#IList#Add(System.Object)">
          <source>If the capacity needs to be increased to accommodate the new element, this method becomes an O(<bpt id="p1">*</bpt>n<ept id="p1">*</ept>) operation, where <bpt id="p2">*</bpt>n<ept id="p2">*</ept> is <ph id="ph1">&lt;xref:System.Collections.Generic.List%601.Count%2A&gt;</ph>.</source>
          <target state="translated">Si la capacidad debe aumentarse para alojar el nuevo elemento, este método se convierte en una O (<bpt id="p1">*</bpt>n<ept id="p1">*</ept>) operación, donde <bpt id="p2">*</bpt>n<ept id="p2">*</ept> es <ph id="ph1">&lt;xref:System.Collections.Generic.List%601.Count%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1128" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.List`1.System#Collections#IList#Add(System.Object)">
          <source><ph id="ph1">&lt;paramref name="item" /&gt;</ph> is of a type that is not assignable to the <ph id="ph2">&lt;see cref="T:System.Collections.IList" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="item" /&gt;</ph> es de un tipo que no se puede asignar a <ph id="ph2">&lt;see cref="T:System.Collections.IList" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1129" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.List`1.System#Collections#IList#Contains(System.Object)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Object" /&gt;</ph> to locate in the <ph id="ph2">&lt;see cref="T:System.Collections.IList" /&gt;</ph>.</source>
          <target state="translated">Objeto <ph id="ph1">&lt;see cref="T:System.Object" /&gt;</ph> que se va a buscar en la interfaz <ph id="ph2">&lt;see cref="T:System.Collections.IList" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1130" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.List`1.System#Collections#IList#Contains(System.Object)">
          <source>Determines whether the <ph id="ph1">&lt;see cref="T:System.Collections.IList" /&gt;</ph> contains a specific value.</source>
          <target state="translated">Determina si <ph id="ph1">&lt;see cref="T:System.Collections.IList" /&gt;</ph> contiene un valor específico.</target>       </trans-unit>
        <trans-unit id="1131" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.List`1.System#Collections#IList#Contains(System.Object)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if <ph id="ph2">&lt;paramref name="item" /&gt;</ph> is found in the <ph id="ph3">&lt;see cref="T:System.Collections.IList" /&gt;</ph>; otherwise, <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> si <ph id="ph2">&lt;paramref name="item" /&gt;</ph> se encuentra en la matriz <ph id="ph3">&lt;see cref="T:System.Collections.IList" /&gt;</ph>; en caso contrario, <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1132" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.System#Collections#IList#Contains(System.Object)">
          <source>This method determines equality using the default equality comparer <ph id="ph1">&lt;xref:System.Collections.Generic.EqualityComparer%601.Default%2A?displayProperty=nameWithType&gt;</ph> for <ph id="ph2">`T`</ph>, the type of values in the list.</source>
          <target state="translated">Este método determina la igualdad utilizando el comparador de igualdad predeterminado <ph id="ph1">&lt;xref:System.Collections.Generic.EqualityComparer%601.Default%2A?displayProperty=nameWithType&gt;</ph> para <ph id="ph2">`T`</ph>, el tipo de valores de la lista.</target>       </trans-unit>
        <trans-unit id="1133" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.System#Collections#IList#Contains(System.Object)">
          <source>This method performs a linear search; therefore, this method is an O(<bpt id="p1">*</bpt>n<ept id="p1">*</ept>) operation, where <bpt id="p2">*</bpt>n<ept id="p2">*</ept> is <ph id="ph1">&lt;xref:System.Collections.Generic.List%601.Count%2A&gt;</ph>.</source>
          <target state="translated">Este método realiza una búsqueda lineal; por lo tanto, este método es una O (<bpt id="p1">*</bpt>n<ept id="p1">*</ept>) operación, donde <bpt id="p2">*</bpt>n<ept id="p2">*</ept> es <ph id="ph1">&lt;xref:System.Collections.Generic.List%601.Count%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1134" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.List`1.System#Collections#IList#IndexOf(System.Object)">
          <source>The object to locate in the <ph id="ph1">&lt;see cref="T:System.Collections.IList" /&gt;</ph>.</source>
          <target state="translated">Objeto que se va a buscar en <ph id="ph1">&lt;see cref="T:System.Collections.IList" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1135" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.List`1.System#Collections#IList#IndexOf(System.Object)">
          <source>Determines the index of a specific item in the <ph id="ph1">&lt;see cref="T:System.Collections.IList" /&gt;</ph>.</source>
          <target state="translated">Determina el índice de un elemento específico de <ph id="ph1">&lt;see cref="T:System.Collections.IList" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1136" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.List`1.System#Collections#IList#IndexOf(System.Object)">
          <source>The index of <ph id="ph1">&lt;paramref name="item" /&gt;</ph> if found in the list; otherwise, –1.</source>
          <target state="translated">Devuelve el índice de <ph id="ph1">&lt;paramref name="item" /&gt;</ph> si se encuentra en la lista; en caso contrario, devuelve -1.</target>       </trans-unit>
        <trans-unit id="1137" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.System#Collections#IList#IndexOf(System.Object)">
          <source>This method determines equality using the default equality comparer <ph id="ph1">&lt;xref:System.Collections.Generic.EqualityComparer%601.Default%2A?displayProperty=nameWithType&gt;</ph> for <ph id="ph2">`T`</ph>, the type of values in the list.</source>
          <target state="translated">Este método determina la igualdad utilizando el comparador de igualdad predeterminado <ph id="ph1">&lt;xref:System.Collections.Generic.EqualityComparer%601.Default%2A?displayProperty=nameWithType&gt;</ph> para <ph id="ph2">`T`</ph>, el tipo de valores de la lista.</target>       </trans-unit>
        <trans-unit id="1138" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.System#Collections#IList#IndexOf(System.Object)">
          <source>This method performs a linear search; therefore, this method is an O(<bpt id="p1">*</bpt>n<ept id="p1">*</ept>) operation, where <bpt id="p2">*</bpt>n<ept id="p2">*</ept> is <ph id="ph1">&lt;xref:System.Collections.Generic.List%601.Count%2A&gt;</ph>.</source>
          <target state="translated">Este método realiza una búsqueda lineal; por lo tanto, este método es una O (<bpt id="p1">*</bpt>n<ept id="p1">*</ept>) operación, donde <bpt id="p2">*</bpt>n<ept id="p2">*</ept> es <ph id="ph1">&lt;xref:System.Collections.Generic.List%601.Count%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1139" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.List`1.System#Collections#IList#IndexOf(System.Object)">
          <source><ph id="ph1">&lt;paramref name="item" /&gt;</ph> is of a type that is not assignable to the <ph id="ph2">&lt;see cref="T:System.Collections.IList" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="item" /&gt;</ph> es de un tipo que no se puede asignar a <ph id="ph2">&lt;see cref="T:System.Collections.IList" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1140" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.List`1.System#Collections#IList#Insert(System.Int32,System.Object)">
          <source>The zero-based index at which <bpt id="p1">&lt;c&gt;</bpt>item<ept id="p1">&lt;/c&gt;</ept> should be inserted.</source>
          <target state="translated">Índice de base cero donde debe insertarse <bpt id="p1">&lt;c&gt;</bpt>item<ept id="p1">&lt;/c&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="1141" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.List`1.System#Collections#IList#Insert(System.Int32,System.Object)">
          <source>The object to insert into the <ph id="ph1">&lt;see cref="T:System.Collections.IList" /&gt;</ph>.</source>
          <target state="translated">Objeto que se va a insertar en <ph id="ph1">&lt;see cref="T:System.Collections.IList" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1142" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.List`1.System#Collections#IList#Insert(System.Int32,System.Object)">
          <source>Inserts an item to the <ph id="ph1">&lt;see cref="T:System.Collections.IList" /&gt;</ph> at the specified index.</source>
          <target state="translated">Inserta un elemento en la interfaz <ph id="ph1">&lt;see cref="T:System.Collections.IList" /&gt;</ph>, en el índice especificado.</target>       </trans-unit>
        <trans-unit id="1143" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.System#Collections#IList#Insert(System.Int32,System.Object)">
          <source>If <ph id="ph1">`index`</ph> equals the number of items in the <ph id="ph2">&lt;xref:System.Collections.IList&gt;</ph>, then <ph id="ph3">`item`</ph> is appended to the end.</source>
          <target state="translated">Si <ph id="ph1">`index`</ph> es igual al número de elementos de <ph id="ph2">&lt;xref:System.Collections.IList&gt;</ph>, entonces <ph id="ph3">`item`</ph> se agrega al final.</target>       </trans-unit>
        <trans-unit id="1144" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.System#Collections#IList#Insert(System.Int32,System.Object)">
          <source>This method is an O(<bpt id="p1">*</bpt>n<ept id="p1">*</ept>) operation, where <bpt id="p2">*</bpt>n<ept id="p2">*</ept> is <ph id="ph1">&lt;xref:System.Collections.Generic.List%601.Count%2A&gt;</ph>.</source>
          <target state="translated">Este método es una O (<bpt id="p1">*</bpt>n<ept id="p1">*</ept>) operación, donde <bpt id="p2">*</bpt>n<ept id="p2">*</ept> es <ph id="ph1">&lt;xref:System.Collections.Generic.List%601.Count%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1145" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.List`1.System#Collections#IList#Insert(System.Int32,System.Object)">
          <source><ph id="ph1">&lt;paramref name="index" /&gt;</ph> is not a valid index in the <ph id="ph2">&lt;see cref="T:System.Collections.IList" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="index" /&gt;</ph> no es un índice válido para <ph id="ph2">&lt;see cref="T:System.Collections.IList" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1146" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.List`1.System#Collections#IList#Insert(System.Int32,System.Object)">
          <source><ph id="ph1">&lt;paramref name="item" /&gt;</ph> is of a type that is not assignable to the <ph id="ph2">&lt;see cref="T:System.Collections.IList" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="item" /&gt;</ph> es de un tipo que no se puede asignar a <ph id="ph2">&lt;see cref="T:System.Collections.IList" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1147" translate="yes" xml:space="preserve" uid="P:System.Collections.Generic.List`1.System#Collections#IList#IsFixedSize">
          <source>Gets a value indicating whether the <ph id="ph1">&lt;see cref="T:System.Collections.IList" /&gt;</ph> has a fixed size.</source>
          <target state="translated">Obtiene un valor que indica si la interfaz <ph id="ph1">&lt;see cref="T:System.Collections.IList" /&gt;</ph> tiene un tamaño fijo.</target>       </trans-unit>
        <trans-unit id="1148" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.Generic.List`1.System#Collections#IList#IsFixedSize">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the <ph id="ph2">&lt;see cref="T:System.Collections.IList" /&gt;</ph> has a fixed size; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">Es <ph id="ph1">&lt;see langword="true" /&gt;</ph> si la interfaz <ph id="ph2">&lt;see cref="T:System.Collections.IList" /&gt;</ph> tiene un tamaño fijo; de lo contrario, es <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1149" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.Generic.List`1.System#Collections#IList#IsFixedSize">
          <source>In the default implementation of <ph id="ph1">&lt;see cref="T:System.Collections.Generic.List`1" /&gt;</ph>, this property always returns <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">En la implementación predeterminada de <ph id="ph1">&lt;see cref="T:System.Collections.Generic.List`1" /&gt;</ph>, esta propiedad siempre devuelve <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1150" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.Generic.List`1.System#Collections#IList#IsFixedSize">
          <source>A collection with a fixed size does not allow the addition or removal of elements after the collection is created, but it allows the modification of existing elements.</source>
          <target state="translated">Una colección de tamaño fijo no permite agregar o quitar elementos una vez que se ha creado, pero sí permite modificar los elementos existentes.</target>       </trans-unit>
        <trans-unit id="1151" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.Generic.List`1.System#Collections#IList#IsFixedSize">
          <source>A collection with a fixed size is simply a collection with a wrapper that prevents adding and removing elements; therefore, if changes are made to the underlying collection, including the addition or removal of elements, the fixed-size collection reflects those changes.</source>
          <target state="translated">Una colección con un tamaño fijo es simplemente una colección con un contenedor que impide agregar y quitar elementos; por lo tanto, si se realizan cambios en la colección subyacente, incluida la adición o eliminación de elementos, la colección de tamaño fijo refleja esos cambios.</target>       </trans-unit>
        <trans-unit id="1152" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.Generic.List`1.System#Collections#IList#IsFixedSize">
          <source>Retrieving the value of this property is an O(1) operation.</source>
          <target state="translated">La recuperación del valor de esta propiedad es una operación O(1).</target>       </trans-unit>
        <trans-unit id="1153" translate="yes" xml:space="preserve" uid="P:System.Collections.Generic.List`1.System#Collections#IList#IsReadOnly">
          <source>Gets a value indicating whether the <ph id="ph1">&lt;see cref="T:System.Collections.IList" /&gt;</ph> is read-only.</source>
          <target state="translated">Obtiene un valor que indica si <ph id="ph1">&lt;see cref="T:System.Collections.IList" /&gt;</ph> es de solo lectura.</target>       </trans-unit>
        <trans-unit id="1154" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.Generic.List`1.System#Collections#IList#IsReadOnly">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the <ph id="ph2">&lt;see cref="T:System.Collections.IList" /&gt;</ph> is read-only; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">Es <ph id="ph1">&lt;see langword="true" /&gt;</ph> si la interfaz <ph id="ph2">&lt;see cref="T:System.Collections.IList" /&gt;</ph> es de solo lectura; de lo contrario, es <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1155" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.Generic.List`1.System#Collections#IList#IsReadOnly">
          <source>In the default implementation of <ph id="ph1">&lt;see cref="T:System.Collections.Generic.List`1" /&gt;</ph>, this property always returns <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">En la implementación predeterminada de <ph id="ph1">&lt;see cref="T:System.Collections.Generic.List`1" /&gt;</ph>, esta propiedad siempre devuelve <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1156" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.Generic.List`1.System#Collections#IList#IsReadOnly">
          <source>A collection that is read-only does not allow the addition, removal, or modification of elements after the collection is created.</source>
          <target state="translated">Una colección de solo lectura no permite que se agreguen, quiten o modifiquen elementos una vez que se ha creado.</target>       </trans-unit>
        <trans-unit id="1157" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.Generic.List`1.System#Collections#IList#IsReadOnly">
          <source>A collection that is read-only is simply a collection with a wrapper that prevents modifying the collection; therefore, if changes are made to the underlying collection, the read-only collection reflects those changes.</source>
          <target state="translated">Una colección que es de solo lectura es simplemente una colección con un contenedor que impide modificar la colección; por lo tanto, si se realizan cambios en la colección subyacente, la colección de solo lectura refleja esos cambios.</target>       </trans-unit>
        <trans-unit id="1158" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.Generic.List`1.System#Collections#IList#IsReadOnly">
          <source>Retrieving the value of this property is an O(1) operation.</source>
          <target state="translated">La recuperación del valor de esta propiedad es una operación O(1).</target>       </trans-unit>
        <trans-unit id="1159" translate="yes" xml:space="preserve" uid="P:System.Collections.Generic.List`1.System#Collections#IList#Item(System.Int32)">
          <source>The zero-based index of the element to get or set.</source>
          <target state="translated">Índice de base cero del elemento que se va a obtener o establecer.</target>       </trans-unit>
        <trans-unit id="1160" translate="yes" xml:space="preserve" uid="P:System.Collections.Generic.List`1.System#Collections#IList#Item(System.Int32)">
          <source>Gets or sets the element at the specified index.</source>
          <target state="translated">Obtiene o establece el elemento en el índice especificado.</target>       </trans-unit>
        <trans-unit id="1161" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.Generic.List`1.System#Collections#IList#Item(System.Int32)">
          <source>The element at the specified index.</source>
          <target state="translated">Elemento en el índice especificado.</target>       </trans-unit>
        <trans-unit id="1162" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.Generic.List`1.System#Collections#IList#Item(System.Int32)">
          <source>The C# language uses the <bpt id="p1">[</bpt>this<ept id="p1">](~/docs/csharp/language-reference/keywords/this.md)</ept> keyword to define the indexers instead of implementing the <ph id="ph1">&lt;xref:System.Collections.Generic.List%601.System%23Collections%23IList%23Item%2A&gt;</ph> property.</source>
          <target state="translated">El lenguaje C# utiliza el <bpt id="p1">[</bpt>esto<ept id="p1">](~/docs/csharp/language-reference/keywords/this.md)</ept> palabra clave para definir los indizadores en lugar de implementar la <ph id="ph1">&lt;xref:System.Collections.Generic.List%601.System%23Collections%23IList%23Item%2A&gt;</ph> propiedad.</target>       </trans-unit>
        <trans-unit id="1163" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.Generic.List`1.System#Collections#IList#Item(System.Int32)">
          <source>Visual Basic implements <ph id="ph1">&lt;xref:System.Collections.Generic.List%601.System%23Collections%23IList%23Item%2A&gt;</ph> as a default property, which provides the same indexing functionality.</source>
          <target state="translated">Visual Basic implementa <ph id="ph1">&lt;xref:System.Collections.Generic.List%601.System%23Collections%23IList%23Item%2A&gt;</ph> como propiedad predeterminada, lo que proporciona la misma funcionalidad de indización.</target>       </trans-unit>
        <trans-unit id="1164" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Collections.Generic.List`1.System#Collections#IList#Item(System.Int32)">
          <source>Retrieving the value of this property is an O(1) operation; setting the property is also an O(1) operation.</source>
          <target state="translated">La recuperación del valor de esta propiedad es una operación o (1); establecer la propiedad también es una operación o (1).</target>       </trans-unit>
        <trans-unit id="1165" translate="yes" xml:space="preserve" uid="P:System.Collections.Generic.List`1.System#Collections#IList#Item(System.Int32)">
          <source><ph id="ph1">&lt;paramref name="index" /&gt;</ph> is not a valid index in the <ph id="ph2">&lt;see cref="T:System.Collections.IList" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="index" /&gt;</ph> no es un índice válido para <ph id="ph2">&lt;see cref="T:System.Collections.IList" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1166" translate="yes" xml:space="preserve" uid="P:System.Collections.Generic.List`1.System#Collections#IList#Item(System.Int32)">
          <source>The property is set and <ph id="ph1">&lt;paramref name="value" /&gt;</ph> is of a type that is not assignable to the <ph id="ph2">&lt;see cref="T:System.Collections.IList" /&gt;</ph>.</source>
          <target state="translated">La propiedad ya está establecida y el tipo de <ph id="ph1">&lt;paramref name="value" /&gt;</ph> no se puede asignar a la interfaz <ph id="ph2">&lt;see cref="T:System.Collections.IList" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1167" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.List`1.System#Collections#IList#Remove(System.Object)">
          <source>The object to remove from the <ph id="ph1">&lt;see cref="T:System.Collections.IList" /&gt;</ph>.</source>
          <target state="translated">Objeto que se va a quitar de <ph id="ph1">&lt;see cref="T:System.Collections.IList" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1168" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.List`1.System#Collections#IList#Remove(System.Object)">
          <source>Removes the first occurrence of a specific object from the <ph id="ph1">&lt;see cref="T:System.Collections.IList" /&gt;</ph>.</source>
          <target state="translated">Quita la primera aparición de un objeto específico de la interfaz <ph id="ph1">&lt;see cref="T:System.Collections.IList" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1169" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.System#Collections#IList#Remove(System.Object)">
          <source>This method determines equality using the default equality comparer <ph id="ph1">&lt;xref:System.Collections.Generic.EqualityComparer%601.Default%2A?displayProperty=nameWithType&gt;</ph> for <ph id="ph2">`T`</ph>, the type of values in the list.</source>
          <target state="translated">Este método determina la igualdad utilizando el comparador de igualdad predeterminado <ph id="ph1">&lt;xref:System.Collections.Generic.EqualityComparer%601.Default%2A?displayProperty=nameWithType&gt;</ph> para <ph id="ph2">`T`</ph>, el tipo de valores de la lista.</target>       </trans-unit>
        <trans-unit id="1170" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.System#Collections#IList#Remove(System.Object)">
          <source>This method performs a linear search; therefore, this method is an O(<bpt id="p1">*</bpt>n<ept id="p1">*</ept>) operation, where <bpt id="p2">*</bpt>n<ept id="p2">*</ept> is <ph id="ph1">&lt;xref:System.Collections.Generic.List%601.Count%2A&gt;</ph>.</source>
          <target state="translated">Este método realiza una búsqueda lineal; por lo tanto, este método es una O (<bpt id="p1">*</bpt>n<ept id="p1">*</ept>) operación, donde <bpt id="p2">*</bpt>n<ept id="p2">*</ept> es <ph id="ph1">&lt;xref:System.Collections.Generic.List%601.Count%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1171" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.List`1.System#Collections#IList#Remove(System.Object)">
          <source><ph id="ph1">&lt;paramref name="item" /&gt;</ph> is of a type that is not assignable to the <ph id="ph2">&lt;see cref="T:System.Collections.IList" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="item" /&gt;</ph> es de un tipo que no se puede asignar a <ph id="ph2">&lt;see cref="T:System.Collections.IList" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1172" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.List`1.ToArray">
          <source>Copies the elements of the <ph id="ph1">&lt;see cref="T:System.Collections.Generic.List`1" /&gt;</ph> to a new array.</source>
          <target state="translated">Copia los elementos de <ph id="ph1">&lt;see cref="T:System.Collections.Generic.List`1" /&gt;</ph> en una nueva matriz.</target>       </trans-unit>
        <trans-unit id="1173" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.List`1.ToArray">
          <source>An array containing copies of the elements of the <ph id="ph1">&lt;see cref="T:System.Collections.Generic.List`1" /&gt;</ph>.</source>
          <target state="translated">Matriz que contiene copias de los elementos de <ph id="ph1">&lt;see cref="T:System.Collections.Generic.List`1" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1174" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.ToArray">
          <source>The elements are copied using <ph id="ph1">&lt;xref:System.Array.Copy%2A?displayProperty=nameWithType&gt;</ph>, which is an O(<bpt id="p1">*</bpt>n<ept id="p1">*</ept>) operation, where <bpt id="p2">*</bpt>n<ept id="p2">*</ept> is <ph id="ph2">&lt;xref:System.Collections.Generic.List%601.Count%2A&gt;</ph>.</source>
          <target state="translated">Los elementos se copian utilizando <ph id="ph1">&lt;xref:System.Array.Copy%2A?displayProperty=nameWithType&gt;</ph>, que es una O (<bpt id="p1">*</bpt>n<ept id="p1">*</ept>) operación, donde <bpt id="p2">*</bpt>n<ept id="p2">*</ept> es <ph id="ph2">&lt;xref:System.Collections.Generic.List%601.Count%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1175" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.ToArray">
          <source>This method is an O(<bpt id="p1">*</bpt>n<ept id="p1">*</ept>) operation, where <bpt id="p2">*</bpt>n<ept id="p2">*</ept> is <ph id="ph1">&lt;xref:System.Collections.Generic.List%601.Count%2A&gt;</ph>.</source>
          <target state="translated">Este método es una O (<bpt id="p1">*</bpt>n<ept id="p1">*</ept>) operación, donde <bpt id="p2">*</bpt>n<ept id="p2">*</ept> es <ph id="ph1">&lt;xref:System.Collections.Generic.List%601.Count%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1176" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.ToArray">
          <source>The following example demonstrates the <ph id="ph1">&lt;xref:System.Collections.Generic.List%601.ToArray%2A&gt;</ph> method and other methods of the <ph id="ph2">&lt;xref:System.Collections.Generic.List%601&gt;</ph> class that act on ranges.</source>
          <target state="translated">En el ejemplo siguiente se muestra la <ph id="ph1">&lt;xref:System.Collections.Generic.List%601.ToArray%2A&gt;</ph> método y otros métodos de la <ph id="ph2">&lt;xref:System.Collections.Generic.List%601&gt;</ph> clase que operan en intervalos.</target>       </trans-unit>
        <trans-unit id="1177" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.ToArray">
          <source>At the end of the example, the <ph id="ph1">&lt;xref:System.Collections.Generic.List%601.GetRange%2A&gt;</ph> method is used to get three items from the list, beginning with index location 2.</source>
          <target state="translated">Al final del ejemplo, el <ph id="ph1">&lt;xref:System.Collections.Generic.List%601.GetRange%2A&gt;</ph> método se usa para obtener tres elementos de la lista, a partir de la posición de índice 2.</target>       </trans-unit>
        <trans-unit id="1178" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.ToArray">
          <source>The <ph id="ph1">&lt;xref:System.Collections.Generic.List%601.ToArray%2A&gt;</ph> method is called on the resulting <ph id="ph2">&lt;xref:System.Collections.Generic.List%601&gt;</ph>, creating an array of three elements.</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.Collections.Generic.List%601.ToArray%2A&gt;</ph> método se llama en el cuadro <ph id="ph2">&lt;xref:System.Collections.Generic.List%601&gt;</ph>, creación de una matriz de tres elementos.</target>       </trans-unit>
        <trans-unit id="1179" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.ToArray">
          <source>The elements of the array are displayed.</source>
          <target state="translated">Se muestran los elementos de la matriz.</target>       </trans-unit>
        <trans-unit id="1180" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.List`1.TrimExcess">
          <source>Sets the capacity to the actual number of elements in the <ph id="ph1">&lt;see cref="T:System.Collections.Generic.List`1" /&gt;</ph>, if that number is less than a threshold value.</source>
          <target state="translated">Establece la capacidad en el número real de elementos que hay en <ph id="ph1">&lt;see cref="T:System.Collections.Generic.List`1" /&gt;</ph>, si dicho número es inferior a un valor umbral.</target>       </trans-unit>
        <trans-unit id="1181" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.TrimExcess">
          <source>This method can be used to minimize a collection's memory overhead if no new elements will be added to the collection.</source>
          <target state="translated">Este método se puede utilizar para minimizar la sobrecarga de memoria de la colección si ningún elemento nuevo se agregará a la colección.</target>       </trans-unit>
        <trans-unit id="1182" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.TrimExcess">
          <source>The cost of reallocating and copying a large <ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph> can be considerable, however, so the <ph id="ph2">&lt;xref:System.Collections.Generic.List%601.TrimExcess%2A&gt;</ph> method does nothing if the list is at more than 90 percent of capacity.</source>
          <target state="translated">El costo de reasignar y copiar una gran <ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph> puede ser considerable, sin embargo, por lo que el <ph id="ph2">&lt;xref:System.Collections.Generic.List%601.TrimExcess%2A&gt;</ph> método no hace nada si la lista está en más del 90 por ciento de capacidad.</target>       </trans-unit>
        <trans-unit id="1183" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.TrimExcess">
          <source>This avoids incurring a large reallocation cost for a relatively small gain.</source>
          <target state="translated">Esto evita incurrir en un gran costo de reasignación para lograr una mejora relativamente pequeño.</target>       </trans-unit>
        <trans-unit id="1184" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.TrimExcess">
          <source>The current threshold of 90 percent might change in future releases.</source>
          <target state="translated">El umbral actual del 90 por ciento puede cambiar en futuras versiones.</target>       </trans-unit>
        <trans-unit id="1185" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.TrimExcess">
          <source>This method is an O(<bpt id="p1">*</bpt>n<ept id="p1">*</ept>) operation, where <bpt id="p2">*</bpt>n<ept id="p2">*</ept> is <ph id="ph1">&lt;xref:System.Collections.Generic.List%601.Count%2A&gt;</ph>.</source>
          <target state="translated">Este método es una O (<bpt id="p1">*</bpt>n<ept id="p1">*</ept>) operación, donde <bpt id="p2">*</bpt>n<ept id="p2">*</ept> es <ph id="ph1">&lt;xref:System.Collections.Generic.List%601.Count%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1186" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.TrimExcess">
          <source>To reset a <ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph> to its initial state, call the <ph id="ph2">&lt;xref:System.Collections.Generic.List%601.Clear%2A&gt;</ph> method before calling the <ph id="ph3">&lt;xref:System.Collections.Generic.List%601.TrimExcess%2A&gt;</ph> method.</source>
          <target state="translated">Para restablecer un <ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph> a su estado inicial, llame a la <ph id="ph2">&lt;xref:System.Collections.Generic.List%601.Clear%2A&gt;</ph> método antes de llamar a la <ph id="ph3">&lt;xref:System.Collections.Generic.List%601.TrimExcess%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="1187" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.TrimExcess">
          <source>Trimming an empty <ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph> sets the capacity of the <ph id="ph2">&lt;xref:System.Collections.Generic.List%601&gt;</ph> to the default capacity.</source>
          <target state="translated">Recortar vacío <ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph> establece la capacidad de la <ph id="ph2">&lt;xref:System.Collections.Generic.List%601&gt;</ph> en la capacidad predeterminada.</target>       </trans-unit>
        <trans-unit id="1188" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.TrimExcess">
          <source>The capacity can also be set using the <ph id="ph1">&lt;xref:System.Collections.Generic.List%601.Capacity%2A&gt;</ph> property.</source>
          <target state="translated">La capacidad también puede establecerse utilizando el <ph id="ph1">&lt;xref:System.Collections.Generic.List%601.Capacity%2A&gt;</ph> propiedad.</target>       </trans-unit>
        <trans-unit id="1189" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.TrimExcess">
          <source>The following example demonstrates how to check the capacity and count of a  <ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph> that contains a simple business object, and illustrates using the <ph id="ph2">&lt;xref:System.Collections.Generic.List%601.TrimExcess%2A&gt;</ph> method to remove extra capacity.</source>
          <target state="translated">En el ejemplo siguiente se muestra cómo comprobar la capacidad y el recuento de un <ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph> que contiene un objeto comercial simple y se muestra cómo utilizar el <ph id="ph2">&lt;xref:System.Collections.Generic.List%601.TrimExcess%2A&gt;</ph> método para quitar una capacidad adicional.</target>       </trans-unit>
        <trans-unit id="1190" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.TrimExcess">
          <source>The following example demonstrates the <ph id="ph1">&lt;xref:System.Collections.Generic.List%601.TrimExcess%2A&gt;</ph> method.</source>
          <target state="translated">En el ejemplo siguiente se muestra el <ph id="ph1">&lt;xref:System.Collections.Generic.List%601.TrimExcess%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="1191" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.TrimExcess">
          <source>Several properties and methods of the <ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph> class are used to add, insert, and remove items from a list of strings.</source>
          <target state="translated">Varias propiedades y métodos de la <ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph> clase se utiliza para agregar, insertar y quitar elementos de una lista de cadenas.</target>       </trans-unit>
        <trans-unit id="1192" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.TrimExcess">
          <source>Then the <ph id="ph1">&lt;xref:System.Collections.Generic.List%601.TrimExcess%2A&gt;</ph> method is used to reduce the capacity to match the count, and the <ph id="ph2">&lt;xref:System.Collections.Generic.List%601.Capacity%2A&gt;</ph> and <ph id="ph3">&lt;xref:System.Collections.Generic.List%601.Count%2A&gt;</ph> properties are displayed.</source>
          <target state="translated">La <ph id="ph1">&lt;xref:System.Collections.Generic.List%601.TrimExcess%2A&gt;</ph> método se usa para reducir la capacidad para que coincida con el recuento y el <ph id="ph2">&lt;xref:System.Collections.Generic.List%601.Capacity%2A&gt;</ph> y <ph id="ph3">&lt;xref:System.Collections.Generic.List%601.Count%2A&gt;</ph> se muestran las propiedades.</target>       </trans-unit>
        <trans-unit id="1193" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.TrimExcess">
          <source>If the unused capacity had been less than 10 percent of total capacity, the list would not have been resized.</source>
          <target state="translated">Si la capacidad no utilizada hubiera sido menor que el 10 por ciento de la capacidad total, la lista no habría cambió de tamaño.</target>       </trans-unit>
        <trans-unit id="1194" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.TrimExcess">
          <source>Finally, the contents of the list are cleared.</source>
          <target state="translated">Por último, se borra el contenido de la lista.</target>       </trans-unit>
        <trans-unit id="1195" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.List`1.TrueForAll(System.Predicate{`0})">
          <source>The <ph id="ph1">&lt;see cref="T:System.Predicate`1" /&gt;</ph> delegate that defines the conditions to check against the elements.</source>
          <target state="translated">Delegado <ph id="ph1">&lt;see cref="T:System.Predicate`1" /&gt;</ph> que define las condiciones que los elementos deben cumplir.</target>       </trans-unit>
        <trans-unit id="1196" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.List`1.TrueForAll(System.Predicate{`0})">
          <source>Determines whether every element in the <ph id="ph1">&lt;see cref="T:System.Collections.Generic.List`1" /&gt;</ph> matches the conditions defined by the specified predicate.</source>
          <target state="translated">Determina si cada elemento de <ph id="ph1">&lt;see cref="T:System.Collections.Generic.List`1" /&gt;</ph> cumple las condiciones que define el predicado especificado.</target>       </trans-unit>
        <trans-unit id="1197" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.List`1.TrueForAll(System.Predicate{`0})">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if every element in the <ph id="ph2">&lt;see cref="T:System.Collections.Generic.List`1" /&gt;</ph> matches the conditions defined by the specified predicate; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">Es <ph id="ph1">&lt;see langword="true" /&gt;</ph> si cada elemento de <ph id="ph2">&lt;see cref="T:System.Collections.Generic.List`1" /&gt;</ph> cumple las condiciones definidas por el predicado especificado; en caso contrario, es <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1198" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.List`1.TrueForAll(System.Predicate{`0})">
          <source>If the list has no elements, the return value is <ph id="ph1">&lt;see langword="true" /&gt;</ph>.</source>
          <target state="translated">Si la lista no tiene ningún elemento, el valor devuelto es <ph id="ph1">&lt;see langword="true" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1199" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.TrueForAll(System.Predicate{`0})">
          <source>The <ph id="ph1">&lt;xref:System.Predicate%601&gt;</ph> is a delegate to a method that returns <ph id="ph2">`true`</ph> if the object passed to it matches the conditions defined in the delegate.</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.Predicate%601&gt;</ph> es un delegado a un método que devuelve <ph id="ph2">`true`</ph> si el objeto pasado a coincide con las condiciones definidas en el delegado.</target>       </trans-unit>
        <trans-unit id="1200" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.TrueForAll(System.Predicate{`0})">
          <source>The elements of the current <ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph> are individually passed to the <ph id="ph2">&lt;xref:System.Predicate%601&gt;</ph> delegate, and processing is stopped when the delegate returns <ph id="ph3">`false`</ph> for any element.</source>
          <target state="translated">Los elementos del elemento actual <ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph> se pasan individualmente a la <ph id="ph2">&lt;xref:System.Predicate%601&gt;</ph> delegado y el procesamiento se detiene cuando el delegado devuelve <ph id="ph3">`false`</ph> para cualquier elemento.</target>       </trans-unit>
        <trans-unit id="1201" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.TrueForAll(System.Predicate{`0})">
          <source>The elements are processed in order, and all calls are made on a single thread.</source>
          <target state="translated">Los elementos se procesan en orden y todas las llamadas se realizan en un solo subproceso.</target>       </trans-unit>
        <trans-unit id="1202" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.TrueForAll(System.Predicate{`0})">
          <source>This method is an O(<bpt id="p1">*</bpt>n<ept id="p1">*</ept>) operation, where <bpt id="p2">*</bpt>n<ept id="p2">*</ept> is <ph id="ph1">&lt;xref:System.Collections.Generic.List%601.Count%2A&gt;</ph>.</source>
          <target state="translated">Este método es una O (<bpt id="p1">*</bpt>n<ept id="p1">*</ept>) operación, donde <bpt id="p2">*</bpt>n<ept id="p2">*</ept> es <ph id="ph1">&lt;xref:System.Collections.Generic.List%601.Count%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1203" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.TrueForAll(System.Predicate{`0})">
          <source>The following example demonstrates the <ph id="ph1">&lt;xref:System.Collections.Generic.List%601.TrueForAll%2A&gt;</ph> method and several other methods that use <ph id="ph2">&lt;xref:System.Predicate%601&gt;</ph> generic delegate.</source>
          <target state="translated">En el ejemplo siguiente se muestra la <ph id="ph1">&lt;xref:System.Collections.Generic.List%601.TrueForAll%2A&gt;</ph> (método) y otros métodos que usan <ph id="ph2">&lt;xref:System.Predicate%601&gt;</ph> delegado genérico.</target>       </trans-unit>
        <trans-unit id="1204" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.TrueForAll(System.Predicate{`0})">
          <source>A <ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph> of strings is created, containing 8 dinosaur names, two of which (at positions 1 and 5) end with "saurus".</source>
          <target state="translated">Un <ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph> de cadenas se crea, que contiene 8 nombres de dinosaurio, dos de los cuales (en las posiciones 1 y 5) terminan en "saurus".</target>       </trans-unit>
        <trans-unit id="1205" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.TrueForAll(System.Predicate{`0})">
          <source>The example also defines a search predicate method named <ph id="ph1">`EndsWithSaurus`</ph>, which accepts a string parameter and returns a Boolean value indicating whether the input string ends in "saurus".</source>
          <target state="translated">El ejemplo también define un método de predicado de búsqueda denominado <ph id="ph1">`EndsWithSaurus`</ph>, que acepta un parámetro de cadena y devuelve un valor booleano de valor que indica si la cadena de entrada termina en "saurus".</target>       </trans-unit>
        <trans-unit id="1206" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.TrueForAll(System.Predicate{`0})">
          <source>The <ph id="ph1">&lt;xref:System.Collections.Generic.List%601.TrueForAll%2A&gt;</ph> method traverses the list from the beginning, passing each element in turn to the <ph id="ph2">`EndsWithSaurus`</ph> method.</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.Collections.Generic.List%601.TrueForAll%2A&gt;</ph> método recorre la lista desde el principio, pasando cada elemento a su vez a la <ph id="ph2">`EndsWithSaurus`</ph> método.</target>       </trans-unit>
        <trans-unit id="1207" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.TrueForAll(System.Predicate{`0})">
          <source>The search stops when the <ph id="ph1">`EndsWithSaurus`</ph> method returns <ph id="ph2">`false`</ph>.</source>
          <target state="translated">La búsqueda detiene cuando la <ph id="ph1">`EndsWithSaurus`</ph> método <ph id="ph2">`false`</ph>.</target>       </trans-unit>
        <trans-unit id="1208" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.TrueForAll(System.Predicate{`0})">
          <source>In C# and Visual Basic, it is not necessary to create the <ph id="ph1">`Predicate&lt;string&gt;`</ph> delegate (<ph id="ph2">`Predicate(Of String)`</ph> in Visual Basic) explicitly.</source>
          <target state="translated">En C# y Visual Basic, no es necesario crear la <ph id="ph1">`Predicate&lt;string&gt;`</ph> delegar (<ph id="ph2">`Predicate(Of String)`</ph> en Visual Basic) explícitamente.</target>       </trans-unit>
        <trans-unit id="1209" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Collections.Generic.List`1.TrueForAll(System.Predicate{`0})">
          <source>These languages infer the correct delegate from context and create it automatically.</source>
          <target state="translated">Estos lenguajes deducen al delegado correcto del contexto y lo crean automáticamente.</target>       </trans-unit>
        <trans-unit id="1210" translate="yes" xml:space="preserve" uid="M:System.Collections.Generic.List`1.TrueForAll(System.Predicate{`0})">
          <source><ph id="ph1">&lt;paramref name="match" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="match" /&gt;</ph> es <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>