<Type Name="BindingOperations" FullName="System.Windows.Data.BindingOperations">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="b6d6ad02d9cad5d3fea47f68a5d2f16bfb2f4a51" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="es-ES" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
    <Meta Name="ms.locfileid" Value="30631079" />
  </Metadata>
  <TypeSignature Language="C#" Value="public static class BindingOperations" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract sealed beforefieldinit BindingOperations extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Data.BindingOperations" />
  <TypeSignature Language="VB.NET" Value="Public Class BindingOperations" />
  <TypeSignature Language="C++ CLI" Value="public ref class BindingOperations abstract sealed" />
  <AssemblyInfo>
    <AssemblyName>PresentationFramework</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Proporciona métodos estáticos para manipular los enlaces, como los objetos <see cref="T:System.Windows.Data.Binding" />, <see cref="T:System.Windows.Data.MultiBinding" /> y <see cref="T:System.Windows.Data.PriorityBinding" />.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esta clase expone un conjunto de métodos estáticos que actúan como operaciones auxiliares para los enlaces de datos.  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName="AccessCollection">
      <MemberSignature Language="C#" Value="public static void AccessCollection (System.Collections.IEnumerable collection, Action accessMethod, bool writeAccess);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void AccessCollection(class System.Collections.IEnumerable collection, class System.Action accessMethod, bool writeAccess) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Data.BindingOperations.AccessCollection(System.Collections.IEnumerable,System.Action,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub AccessCollection (collection As IEnumerable, accessMethod As Action, writeAccess As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void AccessCollection(System::Collections::IEnumerable ^ collection, Action ^ accessMethod, bool writeAccess);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="collection" Type="System.Collections.IEnumerable" />
        <Parameter Name="accessMethod" Type="System.Action" />
        <Parameter Name="writeAccess" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="collection">Colección a la que se va a acceder.</param>
        <param name="accessMethod">La acción para realizar en la colección.</param>
        <param name="writeAccess">
          Es <see langword="true" /> si <c>accessMethod</c> va a escribir en la colección; de lo contrario, es <see langword="false" />.</param>
        <summary>Proporciona acceso a una colección mediante el mecanismo de sincronización que la aplicación especificó al llamar a EnableCollectionSynchronization.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ClearAllBindings">
      <MemberSignature Language="C#" Value="public static void ClearAllBindings (System.Windows.DependencyObject target);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void ClearAllBindings(class System.Windows.DependencyObject target) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Data.BindingOperations.ClearAllBindings(System.Windows.DependencyObject)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub ClearAllBindings (target As DependencyObject)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void ClearAllBindings(System::Windows::DependencyObject ^ target);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Windows.DependencyObject" />
      </Parameters>
      <Docs>
        <param name="target">Objeto del que se van a quitar los enlaces.</param>
        <summary>Quita todos los enlaces, incluidos los enlaces de tipo <see cref="T:System.Windows.Data.Binding" />, <see cref="T:System.Windows.Data.MultiBinding" /> y <see cref="T:System.Windows.Data.PriorityBinding" />, del objeto <see cref="T:System.Windows.DependencyObject" /> especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si el objeto especificado no está enlazado a datos, este método no tiene ningún efecto.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Si <paramref name="target" /> es <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ClearBinding">
      <MemberSignature Language="C#" Value="public static void ClearBinding (System.Windows.DependencyObject target, System.Windows.DependencyProperty dp);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void ClearBinding(class System.Windows.DependencyObject target, class System.Windows.DependencyProperty dp) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Data.BindingOperations.ClearBinding(System.Windows.DependencyObject,System.Windows.DependencyProperty)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub ClearBinding (target As DependencyObject, dp As DependencyProperty)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void ClearBinding(System::Windows::DependencyObject ^ target, System::Windows::DependencyProperty ^ dp);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Windows.DependencyObject" />
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
      </Parameters>
      <Docs>
        <param name="target">Objeto del que se va a quitar el enlace.</param>
        <param name="dp">Propiedad de dependencia de la que se va a quitar el enlace.</param>
        <summary>Quita el enlace de una propiedad, si existe uno.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si la propiedad especificada está enlazado a datos con un <xref:System.Windows.Data.Binding>, <xref:System.Windows.Data.PriorityBinding>, o <xref:System.Windows.Data.MultiBinding>, este método quita la expresión de enlace y las restauraciones se estableció el valor de la propiedad al que tenía antes de cualquier valor local a través del enlace correspondiente.  
  
 Si la propiedad especificada no está enlazado a datos, este método no tiene ningún efecto.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Los parámetros <paramref name="target" /> y <paramref name="dp" /> no pueden ser <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="CollectionRegistering">
      <MemberSignature Language="C#" Value="public static event EventHandler&lt;System.Windows.Data.CollectionRegisteringEventArgs&gt; CollectionRegistering;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Windows.Data.CollectionRegisteringEventArgs&gt; CollectionRegistering" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Data.BindingOperations.CollectionRegistering" />
      <MemberSignature Language="VB.NET" Value="Public Shared Event CollectionRegistering As EventHandler(Of CollectionRegisteringEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static event EventHandler&lt;System::Windows::Data::CollectionRegisteringEventArgs ^&gt; ^ CollectionRegistering;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Windows.Data.CollectionRegisteringEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produce cuando el sistema de enlace de datos observa una colección.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CollectionViewRegistering">
      <MemberSignature Language="C#" Value="public static event EventHandler&lt;System.Windows.Data.CollectionViewRegisteringEventArgs&gt; CollectionViewRegistering;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Windows.Data.CollectionViewRegisteringEventArgs&gt; CollectionViewRegistering" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Data.BindingOperations.CollectionViewRegistering" />
      <MemberSignature Language="VB.NET" Value="Public Shared Event CollectionViewRegistering As EventHandler(Of CollectionViewRegisteringEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static event EventHandler&lt;System::Windows::Data::CollectionViewRegisteringEventArgs ^&gt; ^ CollectionViewRegistering;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Windows.Data.CollectionViewRegisteringEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produce cuando el sistema de enlace de datos observa una vista de colección.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DisableCollectionSynchronization">
      <MemberSignature Language="C#" Value="public static void DisableCollectionSynchronization (System.Collections.IEnumerable collection);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void DisableCollectionSynchronization(class System.Collections.IEnumerable collection) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Data.BindingOperations.DisableCollectionSynchronization(System.Collections.IEnumerable)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub DisableCollectionSynchronization (collection As IEnumerable)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void DisableCollectionSynchronization(System::Collections::IEnumerable ^ collection);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="collection" Type="System.Collections.IEnumerable" />
      </Parameters>
      <Docs>
        <param name="collection">Colección de la que se va a quitar el acceso sincronizado.</param>
        <summary>Quite la sincronización registrada para la colección especificada.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DisconnectedSource">
      <MemberSignature Language="C#" Value="public static object DisconnectedSource { get; }" />
      <MemberSignature Language="ILAsm" Value=".property object DisconnectedSource" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Data.BindingOperations.DisconnectedSource" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property DisconnectedSource As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Object ^ DisconnectedSource { System::Object ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene un objeto que reemplaza la propiedad <see cref="P:System.Windows.FrameworkElement.DataContext" /> cuando un contenedor de elementos se quita del árbol visual.</summary>
        <value>Un objeto que reemplaza la propiedad <see cref="P:System.Windows.FrameworkElement.DataContext" /> cuando un contenedor de elemento se quita del árbol visual.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilice esta propiedad si tiene que tratar con el <xref:System.Windows.FrameworkElement.DataContext%2A> de un contenedor de elementos.  Un contenedor de elementos es el elemento de interfaz de usuario que muestra un elemento en un <xref:System.Windows.Controls.ItemsControl>.  Cuando un <xref:System.Windows.Controls.ItemsControl> datos enlazados a una colección, se genera un contenedor de elementos para cada elemento.  En algunos casos, los contenedores de elementos se quitan del árbol visual.  Dos casos típicos donde se quita un contenedor de elementos son cuando se quita un elemento de la colección subyacente y cuando está habilitada la virtualización en el <xref:System.Windows.Controls.ItemsControl>.  En estos casos, el <xref:System.Windows.FrameworkElement.DataContext%2A> se establecerá la propiedad del elemento contenedor en el <xref:System.Windows.Data.BindingOperations.DisconnectedSource%2A> propiedad debe comprobar si el <xref:System.Windows.FrameworkElement.DataContext%2A> es igual a la <xref:System.Windows.Data.BindingOperations.DisconnectedSource%2A> antes de acceder a la <xref:System.Windows.FrameworkElement.DataContext%2A> en el <xref:System.Windows.FrameworkElement.DataContextChanged> eventos de contenedores de elementos. Para obtener más información acerca de la virtualización y contenedores de elementos, vea los comentarios de la <xref:System.Windows.Controls.VirtualizingStackPanel> clase.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="EnableCollectionSynchronization">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Permite que un objeto <see cref="T:System.Windows.Data.CollectionView" /> participe en el acceso sincronizado a una colección que se usa en varios subprocesos. </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

Una aplicación WPF puede mostrar una colección de datos mediante un <xref:System.Windows.Controls.ItemsControl> o una de sus subclases (<xref:System.Windows.Controls.ListBox>, <xref:System.Windows.Controls.DataGrid>, <xref:System.Windows.Controls.TreeView>, <xref:System.Windows.Controls.ListView>, etcetera.). Todo su acceso a la colección a través de una subclase de los canales de WPF <xref:System.Windows.Data.CollectionView>. Tanto el <xref:System.Windows.Controls.ItemsControl> y <xref:System.Windows.Data.CollectionView> tienen afinidad para el subproceso en el que el <xref:System.Windows.Controls.ItemsControl> se ha creado, lo que significa que su uso en otro subproceso está prohibido y produce una excepción. En efecto, esta restricción se aplica a la colección.
 
Puede usar la colección en varios subprocesos.   Por ejemplo, desea actualizar la colección (Agregar o quitar elementos) en un subproceso "recopilación de datos", al mostrar los resultados en un subproceso de "interfaz de usuario", por lo que la interfaz de usuario sigue respondiendo mientras recolección de datos se está realizando. En esta situación, usted es responsable de garantizar el acceso sincronizado de ("subprocesos") a la colección.   Esto se suele realizar mediante un mecanismo de bloqueo simple o un mecanismo de sincronización más elaborado como semáforos, eventos, etcetera de restablecimiento. 
 
Mientras se debe sincronizar el acceso de la aplicación a la colección, se debe garantizar que el acceso de WPF (específicamente desde <xref:System.Windows.Data.CollectionView>) participa en el mismo mecanismo de sincronización.  Puede hacerlo llamando al método <xref:System.Windows.Data.BindingOperations.EnableCollectionSynchronization%2A>.
 
Para utilizar una colección en varios subprocesos, uno de los cuales es el subproceso de interfaz de usuario que posee el <xref:System.Windows.Controls.ItemsControl>, una aplicación tiene las siguientes responsabilidades:

1. Elija un mecanismo de sincronización.

1. Sincronizar todo el acceso de la aplicación a la colección mediante este mecanismo.

1. Llame a <xref:System.Windows.Data.BindingOperations.EnableCollectionSynchronization%2A> para informar a WPF del mecanismo de.

   - La llamada se debe producir en el subproceso de interfaz de usuario.

   - La llamada debe producirse antes de usar la colección en un subproceso distinto o antes de adjuntar la colección a la <xref:System.Windows.Controls.ItemsControl>, lo que sea posterior.

   - Llame a la <xref:System.Windows.Data.BindingOperations.EnableCollectionSynchronization(System.Collections.IEnumerable,System.Object)> sobrecarga si utiliza un mecanismo de bloqueo simple; la llamada a la <xref:System.Windows.Data.BindingOperations.EnableCollectionSynchronization(System.Collections.IEnumerable,System.Object,System.Windows.Data.CollectionSynchronizationCallback)> sobrecarga si utiliza un mecanismo más elaborado.

1. Asegúrese de que un cambio en la colección y la notificación del cambio (a través de <xref:System.Collections.Specialized.INotifyCollectionChanged>) son atómico; no puede intervenir acceso de otros subprocesos.  (Esto es suele ser gratis. For Instance, <xref:System.Collections.ObjectModel.ObservableCollection%601> garantiza, siempre que todos los cambios están protegidos mediante la sincronización.)

1. Si se llama a <xref:System.Windows.Data.BindingOperations.DisableCollectionSynchronization%2A>, que la llamada también debe producir en el subproceso de interfaz de usuario.

1. Si desea usar la misma colección en varios subprocesos de interfaz de usuario, debe llamar a <xref:System.Windows.Data.BindingOperations.EnableCollectionSynchronization%2A> (y <xref:System.Windows.Data.BindingOperations.DisableCollectionSynchronization%2A>, si es necesario) por separado en cada subproceso de interfaz de usuario.

1. Evitar un interbloqueo.  Esto ya está responsabilidad de la aplicación una vez que decide utilizar la sincronización, pero debe tener en la participación de WPF de cuenta en la sincronización, como se describe en el párrafo siguiente.

En cambio, WPF proporciona el siguiente comportamiento:

- El <xref:System.Windows.Data.CollectionView> tiene acceso a la colección utilizando el mecanismo de sincronización.

- El <xref:System.Windows.Data.CollectionView> mantiene una "instantánea" de la colección para su uso en el subproceso de interfaz de usuario.

- <xref:System.Windows.Data.CollectionView.CollectionChanged> eventos se ponen en cola medida que llegan (en cualquier subproceso).

- Eventos pendientes se aplican a las instantáneas de forma asincrónica en el subproceso de interfaz de usuario cuando tiene la oportunidad de hacerlo.

- El <xref:System.Windows.Data.CollectionView> no usar directamente el mecanismo de sincronización visible para la aplicación. Esta es manera de WPF para ayudar a evitar un interbloqueo (consulte el elemento anterior 7).   

El efecto neto es que puede cambiar la recopilación en cualquier subproceso y, finalmente, esos cambios aparecerán en el <xref:System.Windows.Controls.ItemsControl> cuando el subproceso de interfaz de usuario tiene tiempo "ponerse al día".  La implementación se ha ajustado para limitar la velocidad de flujo de los cambios en el subproceso de interfaz de usuario para mantener el fondo de subprocesos de saturar el subproceso de interfaz de usuario y privar a la respuesta a la entrada de usuario normal.

 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="EnableCollectionSynchronization">
      <MemberSignature Language="C#" Value="public static void EnableCollectionSynchronization (System.Collections.IEnumerable collection, object lockObject);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void EnableCollectionSynchronization(class System.Collections.IEnumerable collection, object lockObject) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Data.BindingOperations.EnableCollectionSynchronization(System.Collections.IEnumerable,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub EnableCollectionSynchronization (collection As IEnumerable, lockObject As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void EnableCollectionSynchronization(System::Collections::IEnumerable ^ collection, System::Object ^ lockObject);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="collection" Type="System.Collections.IEnumerable" />
        <Parameter Name="lockObject" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="collection">Colección que necesita obtener acceso sincronizado.</param>
        <param name="lockObject">Objeto que se va a bloquear al acceder a la colección.</param>
        <summary>Permite que un objeto <see cref="T:System.Windows.Data.CollectionView" /> participe en el acceso sincronizado a una colección que se usa en varios subprocesos mediante un mecanismo sencillo de bloqueo. </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  

## Remarks

Una aplicación WPF puede mostrar una colección de datos mediante un <xref:System.Windows.Controls.ItemsControl> o una de sus subclases (<xref:System.Windows.Controls.ListBox>, <xref:System.Windows.Controls.DataGrid>, <xref:System.Windows.Controls.TreeView>, <xref:System.Windows.Controls.ListView>, etcetera.). Todo su acceso a la colección a través de una subclase de los canales de WPF <xref:System.Windows.Data.CollectionView>. Tanto el <xref:System.Windows.Controls.ItemsControl> y <xref:System.Windows.Data.CollectionView> tienen afinidad para el subproceso en el que el <xref:System.Windows.Controls.ItemsControl> se ha creado, lo que significa que su uso en otro subproceso está prohibido y produce una excepción. En efecto, esta restricción se aplica a la colección.
 
Puede usar la colección en varios subprocesos.   Por ejemplo, desea actualizar la colección (Agregar o quitar elementos) en un subproceso "recopilación de datos", al mostrar los resultados en un subproceso de "interfaz de usuario", por lo que la interfaz de usuario sigue respondiendo mientras recolección de datos se está realizando. En esta situación, es responsable de asegurarse de sincroniza el acceso de ("subprocesos") a la colección y para garantizar que el acceso de WPF (específicamente desde <xref:System.Windows.Data.CollectionView>) participa en el mismo mecanismo de sincronización. Mediante una llamada a la <xref:System.Windows.Data.BindingOperations.EnableCollectionSynchronization(System.Collections.IEnumerable,System.Object)> método, puede hacerlo mediante un mecanismo de bloqueo simple. 
 
Para utilizar una colección en varios subprocesos, uno de los cuales es el subproceso de interfaz de usuario que posee el <xref:System.Windows.Controls.ItemsControl>, debe hacer lo siguiente:

1. Crear una instancia de un objeto para bloquear al obtener acceso a la colección.

1. Sincronizar todo el acceso de la aplicación a la colección de bloqueo de ese objeto.

1. Llame a <xref:System.Windows.Data.BindingOperations.EnableCollectionSynchronization(System.Collections.IEnumerable,System.Object)> para informar a WPF que está usando un mecanismo de bloqueo simple.

   - La llamada se debe producir en el subproceso de interfaz de usuario.

   - La llamada debe producirse antes de usar la colección en un subproceso distinto o antes de adjuntar la colección a la <xref:System.Windows.Controls.ItemsControl>, lo que sea posterior.

1. Asegúrese de que un cambio en la colección y la notificación del cambio (a través de <xref:System.Collections.Specialized.INotifyCollectionChanged>) son atómico; no puede intervenir acceso de otros subprocesos.  (Esto es suele ser gratis. For Instance, <xref:System.Collections.ObjectModel.ObservableCollection%601> garantiza, siempre que todos los cambios están protegidos mediante la sincronización.)

1. Si se llama a <xref:System.Windows.Data.BindingOperations.DisableCollectionSynchronization%2A>, que la llamada también debe producir en el subproceso de interfaz de usuario.

1. Si desea usar la misma colección en varios subprocesos de interfaz de usuario, debe llamar a <xref:System.Windows.Data.BindingOperations.EnableCollectionSynchronization%2A> (y <xref:System.Windows.Data.BindingOperations.DisableCollectionSynchronization%2A>, si es necesario) por separado en cada subproceso de interfaz de usuario.

1. Evitar un interbloqueo.  Ya es responsabilidad de la aplicación una vez que decide utilizar la sincronización, pero también debe tener en cuenta la participación de WPF en la sincronización. (Vea más, a continuación).

En cambio, WPF proporciona el siguiente comportamiento:

- El <xref:System.Windows.Data.CollectionView> tiene acceso a la colección utilizando el mecanismo de bloqueo.

- El <xref:System.Windows.Data.CollectionView> mantiene una "instantánea" de la colección para su uso en el subproceso de interfaz de usuario.

- <xref:System.Windows.Data.CollectionView.CollectionChanged> eventos se ponen en cola medida que llegan (en cualquier subproceso).

- Eventos pendientes se aplican a las instantáneas de forma asincrónica en el subproceso de interfaz de usuario cuando tiene la oportunidad de hacerlo.

- El <xref:System.Windows.Data.CollectionView> no directamente usará cualquier otro mecanismo de sincronización visible para la aplicación. Esta es manera de WPF para ayudar a evitar un interbloqueo (consulte el elemento anterior 7).   

El efecto neto es que puede cambiar la recopilación en cualquier subproceso y, finalmente, esos cambios aparecerán en el <xref:System.Windows.Controls.ItemsControl> cuando el subproceso de interfaz de usuario tiene tiempo "ponerse al día".  La implementación se ha ajustado para limitar la velocidad de flujo de los cambios en el subproceso de interfaz de usuario para mantener el fondo de subprocesos de saturar el subproceso de interfaz de usuario y privar a la respuesta a la entrada de usuario normal.
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EnableCollectionSynchronization">
      <MemberSignature Language="C#" Value="public static void EnableCollectionSynchronization (System.Collections.IEnumerable collection, object context, System.Windows.Data.CollectionSynchronizationCallback synchronizationCallback);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void EnableCollectionSynchronization(class System.Collections.IEnumerable collection, object context, class System.Windows.Data.CollectionSynchronizationCallback synchronizationCallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Data.BindingOperations.EnableCollectionSynchronization(System.Collections.IEnumerable,System.Object,System.Windows.Data.CollectionSynchronizationCallback)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub EnableCollectionSynchronization (collection As IEnumerable, context As Object, synchronizationCallback As CollectionSynchronizationCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void EnableCollectionSynchronization(System::Collections::IEnumerable ^ collection, System::Object ^ context, System::Windows::Data::CollectionSynchronizationCallback ^ synchronizationCallback);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="collection" Type="System.Collections.IEnumerable" />
        <Parameter Name="context" Type="System.Object" />
        <Parameter Name="synchronizationCallback" Type="System.Windows.Data.CollectionSynchronizationCallback" />
      </Parameters>
      <Docs>
        <param name="collection">Colección que necesita obtener acceso sincronizado.</param>
        <param name="context">Objeto que se pasa a la devolución de llamada.</param>
        <param name="synchronizationCallback">Devolución de llamada que se invoca cuando se requiere acceso a la colección. Puede usarla para asegurarse de que los subprocesos accedan a la colección de uno en uno. </param>
        <summary>Permite que un objeto <see cref="T:System.Windows.Data.CollectionView" /> participe en el acceso sincronizado a una colección usada en varios subprocesos mediante un mecanismo distinto a un bloqueo sencillo. </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

Una aplicación WPF puede mostrar una colección de datos mediante un <xref:System.Windows.Controls.ItemsControl> o una de sus subclases (<xref:System.Windows.Controls.ListBox>, <xref:System.Windows.Controls.DataGrid>, <xref:System.Windows.Controls.TreeView>, <xref:System.Windows.Controls.ListView>, etcetera.). Todo su acceso a la colección a través de una subclase de los canales de WPF <xref:System.Windows.Data.CollectionView>. Tanto el <xref:System.Windows.Controls.ItemsControl> y <xref:System.Windows.Data.CollectionView> tienen afinidad para el subproceso en el que el <xref:System.Windows.Controls.ItemsControl> se ha creado, lo que significa que su uso en otro subproceso está prohibido y produce una excepción. En efecto, esta restricción se aplica a la colección.
 
Puede usar la colección en varios subprocesos.   Por ejemplo, desea actualizar la colección (Agregar o quitar elementos) en un subproceso "recopilación de datos", al mostrar los resultados en un subproceso de "interfaz de usuario", por lo que la interfaz de usuario sigue respondiendo mientras recolección de datos se está realizando. En esta situación, es responsable de asegurarse de sincroniza el acceso de ("subprocesos") a la colección y para garantizar que el acceso de WPF (específicamente desde <xref:System.Windows.Data.CollectionView>) participa en el mismo mecanismo de sincronización. Mediante una llamada a la <xref:System.Windows.Data.BindingOperations.EnableCollectionSynchronization(System.Collections.IEnumerable,System.Object,System.Windows.Data.CollectionSynchronizationCallback)> método, puede hacerlo mediante un mecanismo de sincronización, como un semáforos, un evento de restablecimiento, etcetera. 
 
Para utilizar una colección en varios subprocesos, uno de los cuales es el subproceso de interfaz de usuario que posee el <xref:System.Windows.Controls.ItemsControl>, debe hacer lo siguiente:

1. Elija un mecanismo de sincronización.

1. Sincronizar todo el acceso de la aplicación a la colección mediante este mecanismo.

1. Llame a la <xref:System.Windows.Data.BindingOperations.EnableCollectionSynchronization(System.Collections.IEnumerable,System.Object,System.Windows.Data.CollectionSynchronizationCallback)> sobrecarga para informar a WPF que está usando un mecanismo distinto del bloqueo simple.

   - La llamada se debe producir en el subproceso de interfaz de usuario.

   - La llamada debe producirse antes de usar la colección en un subproceso distinto o antes de adjuntar la colección a la <xref:System.Windows.Controls.ItemsControl>, lo que sea posterior.

1. Asegúrese de que un cambio en la colección y la notificación del cambio (a través de <xref:System.Collections.Specialized.INotifyCollectionChanged>) son atómico; no puede intervenir acceso de otros subprocesos.  (Esto es suele ser gratis. For Instance, <xref:System.Collections.ObjectModel.ObservableCollection%601> garantiza, siempre que todos los cambios están protegidos mediante la sincronización.)

1. Si se llama a <xref:System.Windows.Data.BindingOperations.DisableCollectionSynchronization%2A>, que la llamada también debe producir en el subproceso de interfaz de usuario.

1. Si desea usar la misma colección en varios subprocesos de interfaz de usuario, debe llamar a <xref:System.Windows.Data.BindingOperations.EnableCollectionSynchronization%2A> (y <xref:System.Windows.Data.BindingOperations.DisableCollectionSynchronization%2A>, si es necesario) por separado en cada subproceso de interfaz de usuario.

1. Evitar un interbloqueo.  Ya es responsabilidad de la aplicación una vez que decide utilizar la sincronización, pero también debe tener en cuenta la participación de WPF en la sincronización. (Vea más, a continuación).

En cambio, WPF proporciona el siguiente comportamiento:

- El <xref:System.Windows.Data.CollectionView> tiene acceso a la colección mediante una llamada a registrado <xref:System.Windows.Data.CollectionSynchronizationCallback> con los argumentos siguientes:

   - `collection`: la colección de interés.
   - `context`: el objeto de contexto registrado.
   - `accessMethod`: un delegado que realiza el acceso real.
   - `writeAccess`: `true` si el delegado va a modificar la colección; `false` en caso contrario.

   Su <xref:System.Windows.Data.CollectionSynchronizationCallback> debe establecer la sincronización en la colección (mediante el `context` objeto y el `writeAccess` valor, según corresponda), llame a la `accessMethod`, a continuación, suelte la sincronización.

- El <xref:System.Windows.Data.CollectionView> mantiene una "instantánea" de la colección para su uso en el subproceso de interfaz de usuario.

- <xref:System.Windows.Data.CollectionView.CollectionChanged> eventos se ponen en cola medida que llegan (en cualquier subproceso).

- Eventos pendientes se aplican a las instantáneas de forma asincrónica en el subproceso de interfaz de usuario cuando tiene la oportunidad de hacerlo.

- El <xref:System.Windows.Data.CollectionView> no directamente usará cualquier otro mecanismo de sincronización visible para la aplicación. Esta es manera de WPF para ayudar a evitar un interbloqueo (consulte el elemento anterior 7).   

El efecto neto es que puede cambiar la recopilación en cualquier subproceso y, finalmente, esos cambios aparecerán en el <xref:System.Windows.Controls.ItemsControl> cuando el subproceso de interfaz de usuario tiene tiempo "ponerse al día".  La implementación se ha ajustado para limitar la velocidad de flujo de los cambios en el subproceso de interfaz de usuario para mantener el fondo de subprocesos de saturar el subproceso de interfaz de usuario y privar a la respuesta a la entrada de usuario normal.

 El `context` parámetro es un objeto arbitrario que se pasa a la `callback`. Puede usar para determinar el mecanismo de sincronización utilizado para controlar el acceso a `collection`. `Context` puede ser `null`.  
 
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetBinding">
      <MemberSignature Language="C#" Value="public static System.Windows.Data.Binding GetBinding (System.Windows.DependencyObject target, System.Windows.DependencyProperty dp);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.Data.Binding GetBinding(class System.Windows.DependencyObject target, class System.Windows.DependencyProperty dp) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Data.BindingOperations.GetBinding(System.Windows.DependencyObject,System.Windows.DependencyProperty)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetBinding (target As DependencyObject, dp As DependencyProperty) As Binding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::Data::Binding ^ GetBinding(System::Windows::DependencyObject ^ target, System::Windows::DependencyProperty ^ dp);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Data.Binding</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Windows.DependencyObject" />
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
      </Parameters>
      <Docs>
        <param name="target">Objeto en el que se encuentra <c>dp</c>.</param>
        <param name="dp">Propiedad del destino de enlace desde la que se va a recuperar el enlace.</param>
        <summary>Recupera el objeto <see cref="T:System.Windows.Data.Binding" /> establecido en la propiedad especificada.</summary>
        <returns>Objeto <see cref="T:System.Windows.Data.Binding" /> establecido en la propiedad especificada o <see langword="null" /> si no se ha establecido ningún objeto <see cref="T:System.Windows.Data.Binding" />.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">El valor de los parámetros <paramref name="target" /> y <paramref name="dp" /> no puede ser null.</exception>
        <altmember cref="M:System.Windows.Data.BindingOperations.GetBindingBase(System.Windows.DependencyObject,System.Windows.DependencyProperty)" />
        <altmember cref="M:System.Windows.Data.BindingOperations.GetBindingExpression(System.Windows.DependencyObject,System.Windows.DependencyProperty)" />
        <altmember cref="M:System.Windows.Data.BindingOperations.GetMultiBinding(System.Windows.DependencyObject,System.Windows.DependencyProperty)" />
        <altmember cref="M:System.Windows.Data.BindingOperations.GetPriorityBinding(System.Windows.DependencyObject,System.Windows.DependencyProperty)" />
      </Docs>
    </Member>
    <Member MemberName="GetBindingBase">
      <MemberSignature Language="C#" Value="public static System.Windows.Data.BindingBase GetBindingBase (System.Windows.DependencyObject target, System.Windows.DependencyProperty dp);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.Data.BindingBase GetBindingBase(class System.Windows.DependencyObject target, class System.Windows.DependencyProperty dp) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Data.BindingOperations.GetBindingBase(System.Windows.DependencyObject,System.Windows.DependencyProperty)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetBindingBase (target As DependencyObject, dp As DependencyProperty) As BindingBase" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::Data::BindingBase ^ GetBindingBase(System::Windows::DependencyObject ^ target, System::Windows::DependencyProperty ^ dp);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Data.BindingBase</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Windows.DependencyObject" />
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
      </Parameters>
      <Docs>
        <param name="target">Objeto en el que se encuentra <c>dp</c>.</param>
        <param name="dp">Propiedad de destino de enlace a partir de la cual recuperar el objeto <see cref="T:System.Windows.Data.BindingBase" />.</param>
        <summary>Recupera el objeto <see cref="T:System.Windows.Data.BindingBase" /> establecido en la propiedad especificada.</summary>
        <returns>Objeto <see cref="T:System.Windows.Data.BindingBase" /> establecido en la propiedad especificada o <see langword="null" /> si no se ha establecido ningún objeto de enlace.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Windows.Data.BindingBase> clase es la clase base común para la <xref:System.Windows.Data.Binding>, <xref:System.Windows.Data.PriorityBinding>, y <xref:System.Windows.Data.MultiBinding> clases. Puede usar el <xref:System.Windows.Data.BindingOperations.GetBinding%2A>, <xref:System.Windows.Data.BindingOperations.GetPriorityBinding%2A>, y <xref:System.Windows.Data.BindingOperations.GetMultiBinding%2A> métodos si conoce de antemano el tipo de enlace que es establecer en la propiedad.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Los parámetros <paramref name="target" /> y <paramref name="dp" /> no pueden ser <see langword="null" />.</exception>
        <altmember cref="M:System.Windows.Data.BindingOperations.GetBindingExpressionBase(System.Windows.DependencyObject,System.Windows.DependencyProperty)" />
      </Docs>
    </Member>
    <Member MemberName="GetBindingExpression">
      <MemberSignature Language="C#" Value="public static System.Windows.Data.BindingExpression GetBindingExpression (System.Windows.DependencyObject target, System.Windows.DependencyProperty dp);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.Data.BindingExpression GetBindingExpression(class System.Windows.DependencyObject target, class System.Windows.DependencyProperty dp) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Data.BindingOperations.GetBindingExpression(System.Windows.DependencyObject,System.Windows.DependencyProperty)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetBindingExpression (target As DependencyObject, dp As DependencyProperty) As BindingExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::Data::BindingExpression ^ GetBindingExpression(System::Windows::DependencyObject ^ target, System::Windows::DependencyProperty ^ dp);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Data.BindingExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Windows.DependencyObject" />
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
      </Parameters>
      <Docs>
        <param name="target">Objeto de destino de enlace donde se encuentra <c>dp</c>.</param>
        <param name="dp">Propiedad de destino de enlace a partir de la cual recuperar el objeto <see cref="T:System.Windows.Data.BindingExpression" />.</param>
        <summary>Devuelve el objeto <see cref="T:System.Windows.Data.BindingExpression" /> asociado a la propiedad de destino de enlace especificada en el objeto especificado.</summary>
        <returns>Objeto <see cref="T:System.Windows.Data.BindingExpression" /> asociado a la propiedad especificada o <see langword="null" /> si no existe ninguno. Si un objeto <see cref="T:System.Windows.Data.PriorityBindingExpression" /> se establece en la propiedad, se devuelve <see cref="P:System.Windows.Data.PriorityBindingExpression.ActiveBindingExpression" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La <xref:System.Windows.Data.BindingExpression> objeto mantiene la conexión entre el origen de enlace y el destino de enlace. Puede obtener el <xref:System.Windows.Data.BindingExpression> objeto mediante una llamada a este método estático o mediante una llamada a la <xref:System.Windows.FrameworkElement.GetBindingExpression%2A> método en un enlace de datos <xref:System.Windows.FrameworkElement> o <xref:System.Windows.FrameworkContentElement> objeto.  
  
   
  
## Examples  
 En el ejemplo siguiente se muestra la implementación de un <xref:System.Windows.Controls.Primitives.ButtonBase.Click> controlador de eventos que utiliza la <xref:System.Windows.Data.BindingOperations.GetBindingExpression%2A> método para obtener el <xref:System.Windows.Data.BindingExpression> y, a continuación, llama a la <xref:System.Windows.Data.BindingExpression.DataItem%2A> propiedad que se va a obtener acceso al objeto de origen de enlace.  
  
 El <xref:System.Windows.Controls.TextBlock> `SavingsText` es el objeto de destino de enlace y <xref:System.Windows.Controls.TextBlock.Text%2A> es la propiedad de destino de enlace.  
  
 [!code-csharp[DirectionalBinding#OnRentRaise](~/samples/snippets/csharp/VS_Snippets_Wpf/DirectionalBinding/CSharp/Page1.xaml.cs#onrentraise)]
 [!code-vb[DirectionalBinding#OnRentRaise](~/samples/snippets/visualbasic/VS_Snippets_Wpf/DirectionalBinding/VisualBasic/DirectionalBinding.vb#onrentraise)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Los parámetros <paramref name="target" /> y <paramref name="dp" /> no pueden ser <see langword="null" />.</exception>
        <altmember cref="M:System.Windows.Data.BindingOperations.GetMultiBindingExpression(System.Windows.DependencyObject,System.Windows.DependencyProperty)" />
        <altmember cref="M:System.Windows.Data.BindingOperations.GetPriorityBindingExpression(System.Windows.DependencyObject,System.Windows.DependencyProperty)" />
        <altmember cref="M:System.Windows.Data.BindingOperations.GetBindingExpressionBase(System.Windows.DependencyObject,System.Windows.DependencyProperty)" />
      </Docs>
    </Member>
    <Member MemberName="GetBindingExpressionBase">
      <MemberSignature Language="C#" Value="public static System.Windows.Data.BindingExpressionBase GetBindingExpressionBase (System.Windows.DependencyObject target, System.Windows.DependencyProperty dp);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.Data.BindingExpressionBase GetBindingExpressionBase(class System.Windows.DependencyObject target, class System.Windows.DependencyProperty dp) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Data.BindingOperations.GetBindingExpressionBase(System.Windows.DependencyObject,System.Windows.DependencyProperty)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetBindingExpressionBase (target As DependencyObject, dp As DependencyProperty) As BindingExpressionBase" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::Data::BindingExpressionBase ^ GetBindingExpressionBase(System::Windows::DependencyObject ^ target, System::Windows::DependencyProperty ^ dp);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Data.BindingExpressionBase</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Windows.DependencyObject" />
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
      </Parameters>
      <Docs>
        <param name="target">Objeto en el que se encuentra <c>dp</c>.</param>
        <param name="dp">Propiedad de destino de enlace a partir de la cual recuperar el objeto <see cref="T:System.Windows.Data.BindingExpressionBase" />.</param>
        <summary>Recupera el objeto <see cref="T:System.Windows.Data.BindingExpressionBase" /> establecido en la propiedad especificada.</summary>
        <returns>Objeto <see cref="T:System.Windows.Data.BindingExpressionBase" /> establecido en la propiedad especificada o <see langword="null" /> si no se ha establecido ningún objeto de enlace.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Windows.Data.BindingExpressionBase> clase es la clase base común para la <xref:System.Windows.Data.BindingExpression>, <xref:System.Windows.Data.PriorityBindingExpression>, y <xref:System.Windows.Data.MultiBindingExpression> clases. Puede usar el <xref:System.Windows.Data.BindingOperations.GetBindingExpression%2A>, <xref:System.Windows.Data.BindingOperations.GetPriorityBindingExpression%2A>, y <xref:System.Windows.Data.BindingOperations.GetMultiBindingExpression%2A> métodos si conoce de antemano el tipo de enlace que se establece en la propiedad.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El valor de los parámetros <paramref name="target" /> y <paramref name="dp" /> no puede ser null.</exception>
        <altmember cref="M:System.Windows.Data.BindingOperations.GetBindingBase(System.Windows.DependencyObject,System.Windows.DependencyProperty)" />
      </Docs>
    </Member>
    <Member MemberName="GetMultiBinding">
      <MemberSignature Language="C#" Value="public static System.Windows.Data.MultiBinding GetMultiBinding (System.Windows.DependencyObject target, System.Windows.DependencyProperty dp);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.Data.MultiBinding GetMultiBinding(class System.Windows.DependencyObject target, class System.Windows.DependencyProperty dp) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Data.BindingOperations.GetMultiBinding(System.Windows.DependencyObject,System.Windows.DependencyProperty)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetMultiBinding (target As DependencyObject, dp As DependencyProperty) As MultiBinding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::Data::MultiBinding ^ GetMultiBinding(System::Windows::DependencyObject ^ target, System::Windows::DependencyProperty ^ dp);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Data.MultiBinding</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Windows.DependencyObject" />
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
      </Parameters>
      <Docs>
        <param name="target">Objeto en el que se encuentra <c>dp</c>.</param>
        <param name="dp">Propiedad del destino de enlace desde la que se va a recuperar el enlace.</param>
        <summary>Recupera el objeto <see cref="T:System.Windows.Data.MultiBinding" /> establecido en la propiedad especificada.</summary>
        <returns>Objeto <see cref="T:System.Windows.Data.MultiBinding" /> establecido en la propiedad especificada o <see langword="null" /> si no se ha establecido ningún objeto <see cref="T:System.Windows.Data.MultiBinding" />.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">El valor de los parámetros <paramref name="target" /> y <paramref name="dp" /> no puede ser null.</exception>
        <altmember cref="M:System.Windows.Data.BindingOperations.GetBinding(System.Windows.DependencyObject,System.Windows.DependencyProperty)" />
        <altmember cref="M:System.Windows.Data.BindingOperations.GetBindingBase(System.Windows.DependencyObject,System.Windows.DependencyProperty)" />
      </Docs>
    </Member>
    <Member MemberName="GetMultiBindingExpression">
      <MemberSignature Language="C#" Value="public static System.Windows.Data.MultiBindingExpression GetMultiBindingExpression (System.Windows.DependencyObject target, System.Windows.DependencyProperty dp);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.Data.MultiBindingExpression GetMultiBindingExpression(class System.Windows.DependencyObject target, class System.Windows.DependencyProperty dp) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Data.BindingOperations.GetMultiBindingExpression(System.Windows.DependencyObject,System.Windows.DependencyProperty)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetMultiBindingExpression (target As DependencyObject, dp As DependencyProperty) As MultiBindingExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::Data::MultiBindingExpression ^ GetMultiBindingExpression(System::Windows::DependencyObject ^ target, System::Windows::DependencyProperty ^ dp);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Data.MultiBindingExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Windows.DependencyObject" />
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
      </Parameters>
      <Docs>
        <param name="target">Objeto de destino de enlace donde se encuentra <c>dp</c>.</param>
        <param name="dp">Propiedad de destino de enlace a partir de la cual recuperar el objeto <see cref="T:System.Windows.Data.MultiBindingExpression" />.</param>
        <summary>Devuelve el objeto <see cref="T:System.Windows.Data.MultiBindingExpression" /> asociado a la propiedad de destino de enlace especificada en el objeto especificado.</summary>
        <returns>Objeto <see cref="T:System.Windows.Data.MultiBindingExpression" /> asociado a la propiedad especificada o <see langword="null" /> si no existe ninguno.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Objeto <xref:System.Windows.Data.MultiBindingExpression> asociado a la propiedad especificada o `null` si no existe ninguno.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Los parámetros <paramref name="target" /> y <paramref name="dp" /> no pueden ser <see langword="null" />.</exception>
        <altmember cref="M:System.Windows.Data.BindingOperations.GetBindingExpressionBase(System.Windows.DependencyObject,System.Windows.DependencyProperty)" />
        <altmember cref="M:System.Windows.Data.BindingOperations.GetBindingExpression(System.Windows.DependencyObject,System.Windows.DependencyProperty)" />
        <altmember cref="M:System.Windows.Data.BindingOperations.GetMultiBinding(System.Windows.DependencyObject,System.Windows.DependencyProperty)" />
      </Docs>
    </Member>
    <Member MemberName="GetPriorityBinding">
      <MemberSignature Language="C#" Value="public static System.Windows.Data.PriorityBinding GetPriorityBinding (System.Windows.DependencyObject target, System.Windows.DependencyProperty dp);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.Data.PriorityBinding GetPriorityBinding(class System.Windows.DependencyObject target, class System.Windows.DependencyProperty dp) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Data.BindingOperations.GetPriorityBinding(System.Windows.DependencyObject,System.Windows.DependencyProperty)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetPriorityBinding (target As DependencyObject, dp As DependencyProperty) As PriorityBinding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::Data::PriorityBinding ^ GetPriorityBinding(System::Windows::DependencyObject ^ target, System::Windows::DependencyProperty ^ dp);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Data.PriorityBinding</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Windows.DependencyObject" />
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
      </Parameters>
      <Docs>
        <param name="target">Objeto en el que se encuentra <c>dp</c>.</param>
        <param name="dp">Propiedad del destino de enlace desde la que se va a recuperar el enlace.</param>
        <summary>Recupera el objeto <see cref="T:System.Windows.Data.PriorityBinding" /> establecido en la propiedad especificada.</summary>
        <returns>Objeto <see cref="T:System.Windows.Data.PriorityBinding" /> establecido en la propiedad especificada o <see langword="null" /> si no se ha establecido ningún objeto <see cref="T:System.Windows.Data.PriorityBinding" />.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">El valor de los parámetros <paramref name="target" /> y <paramref name="dp" /> no puede ser null.</exception>
        <altmember cref="M:System.Windows.Data.BindingOperations.GetBinding(System.Windows.DependencyObject,System.Windows.DependencyProperty)" />
        <altmember cref="M:System.Windows.Data.BindingOperations.GetBindingBase(System.Windows.DependencyObject,System.Windows.DependencyProperty)" />
      </Docs>
    </Member>
    <Member MemberName="GetPriorityBindingExpression">
      <MemberSignature Language="C#" Value="public static System.Windows.Data.PriorityBindingExpression GetPriorityBindingExpression (System.Windows.DependencyObject target, System.Windows.DependencyProperty dp);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.Data.PriorityBindingExpression GetPriorityBindingExpression(class System.Windows.DependencyObject target, class System.Windows.DependencyProperty dp) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Data.BindingOperations.GetPriorityBindingExpression(System.Windows.DependencyObject,System.Windows.DependencyProperty)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetPriorityBindingExpression (target As DependencyObject, dp As DependencyProperty) As PriorityBindingExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::Data::PriorityBindingExpression ^ GetPriorityBindingExpression(System::Windows::DependencyObject ^ target, System::Windows::DependencyProperty ^ dp);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Data.PriorityBindingExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Windows.DependencyObject" />
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
      </Parameters>
      <Docs>
        <param name="target">Objeto de destino de enlace donde se encuentra <c>dp</c>.</param>
        <param name="dp">Propiedad de destino de enlace a partir de la cual recuperar el objeto <see cref="T:System.Windows.Data.PriorityBindingExpression" />.</param>
        <summary>Devuelve el objeto <see cref="T:System.Windows.Data.PriorityBindingExpression" /> asociado a la propiedad de destino de enlace especificada en el objeto especificado.</summary>
        <returns>Objeto <see cref="T:System.Windows.Data.PriorityBindingExpression" /> asociado a la propiedad especificada o <see langword="null" /> si no existe ninguno.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">Los parámetros <paramref name="target" /> y <paramref name="dp" /> no pueden ser <see langword="null" />.</exception>
        <altmember cref="M:System.Windows.Data.BindingOperations.GetBindingExpressionBase(System.Windows.DependencyObject,System.Windows.DependencyProperty)" />
        <altmember cref="M:System.Windows.Data.BindingOperations.GetBindingExpression(System.Windows.DependencyObject,System.Windows.DependencyProperty)" />
        <altmember cref="M:System.Windows.Data.BindingOperations.GetPriorityBinding(System.Windows.DependencyObject,System.Windows.DependencyProperty)" />
      </Docs>
    </Member>
    <Member MemberName="GetSourceUpdatingBindingGroups">
      <MemberSignature Language="C#" Value="public static System.Collections.ObjectModel.ReadOnlyCollection&lt;System.Windows.Data.BindingGroup&gt; GetSourceUpdatingBindingGroups (System.Windows.DependencyObject root);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.ObjectModel.ReadOnlyCollection`1&lt;class System.Windows.Data.BindingGroup&gt; GetSourceUpdatingBindingGroups(class System.Windows.DependencyObject root) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Data.BindingOperations.GetSourceUpdatingBindingGroups(System.Windows.DependencyObject)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetSourceUpdatingBindingGroups (root As DependencyObject) As ReadOnlyCollection(Of BindingGroup)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Collections::ObjectModel::ReadOnlyCollection&lt;System::Windows::Data::BindingGroup ^&gt; ^ GetSourceUpdatingBindingGroups(System::Windows::DependencyObject ^ root);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ObjectModel.ReadOnlyCollection&lt;System.Windows.Data.BindingGroup&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="root" Type="System.Windows.DependencyObject" />
      </Parameters>
      <Docs>
        <param name="root">
          <see cref="T:System.Windows.UIElement" /> raíz para obtener grupos de enlace.  Este método devuelve los objetos <see cref="T:System.Windows.Data.BindingGroup" /> que están asociados a este elemento o sus elementos descendientes.</param>
        <summary>Obtiene todos los objetos <see cref="T:System.Windows.Data.BindingGroup" /> que tienen valores no válidos o valores de destino que no se han actualizado en el origen.</summary>
        <returns>Colección de objetos <see cref="T:System.Windows.Data.BindingGroup" /> que son asociados al elemento especificado y tienen valores no válidos o valores de destino que no han sido actualizados en el origen.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si `root` es `null`, <xref:System.Windows.Data.BindingOperations.GetSourceUpdatingBindingGroups%2A> todos los devuelve <xref:System.Windows.Data.BindingGroup> objetos que no son válidas o no se ha actualizado.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetSourceUpdatingBindings">
      <MemberSignature Language="C#" Value="public static System.Collections.ObjectModel.ReadOnlyCollection&lt;System.Windows.Data.BindingExpressionBase&gt; GetSourceUpdatingBindings (System.Windows.DependencyObject root);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.ObjectModel.ReadOnlyCollection`1&lt;class System.Windows.Data.BindingExpressionBase&gt; GetSourceUpdatingBindings(class System.Windows.DependencyObject root) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Data.BindingOperations.GetSourceUpdatingBindings(System.Windows.DependencyObject)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetSourceUpdatingBindings (root As DependencyObject) As ReadOnlyCollection(Of BindingExpressionBase)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Collections::ObjectModel::ReadOnlyCollection&lt;System::Windows::Data::BindingExpressionBase ^&gt; ^ GetSourceUpdatingBindings(System::Windows::DependencyObject ^ root);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ObjectModel.ReadOnlyCollection&lt;System.Windows.Data.BindingExpressionBase&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="root" Type="System.Windows.DependencyObject" />
      </Parameters>
      <Docs>
        <param name="root">
          <see cref="T:System.Windows.UIElement" /> raíz para obtener grupos de enlace.  Este método devuelve los objetos <see cref="T:System.Windows.Data.BindingExpressionBase" /> que están asociados a este elemento o sus elementos descendientes.</param>
        <summary>Obtiene todos los objetos <see cref="T:System.Windows.Data.BindingExpressionBase" /> que tienen valores no válidos o valores de destino que no se han actualizado en el origen.</summary>
        <returns>Colección de objetos <see cref="T:System.Windows.Data.BindingExpressionBase" /> que son asociados al elemento especificado y tienen valores no válidos o valores de destino que no han sido actualizados en el origen.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si `root` es `null`, <xref:System.Windows.Data.BindingOperations.GetSourceUpdatingBindings%2A> todos los devuelve <xref:System.Windows.Data.BindingExpressionBase> objetos que no son válidas o no se ha actualizado.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsDataBound">
      <MemberSignature Language="C#" Value="public static bool IsDataBound (System.Windows.DependencyObject target, System.Windows.DependencyProperty dp);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsDataBound(class System.Windows.DependencyObject target, class System.Windows.DependencyProperty dp) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Data.BindingOperations.IsDataBound(System.Windows.DependencyObject,System.Windows.DependencyProperty)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsDataBound (target As DependencyObject, dp As DependencyProperty) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsDataBound(System::Windows::DependencyObject ^ target, System::Windows::DependencyProperty ^ dp);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Windows.DependencyObject" />
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
      </Parameters>
      <Docs>
        <param name="target">Objeto en el que se encuentra <c>dp</c>.</param>
        <param name="dp">Propiedad de dependencia que se va a comprobar.</param>
        <summary>Devuelve un valor que indica si la propiedad especificada está enlazada a datos actualmente.</summary>
        <returns>
          Es <see langword="true" /> si la propiedad especificada está enlazada a datos; de lo contrario, es <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">Si <paramref name="target" /> es <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="SetBinding">
      <MemberSignature Language="C#" Value="public static System.Windows.Data.BindingExpressionBase SetBinding (System.Windows.DependencyObject target, System.Windows.DependencyProperty dp, System.Windows.Data.BindingBase binding);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.Data.BindingExpressionBase SetBinding(class System.Windows.DependencyObject target, class System.Windows.DependencyProperty dp, class System.Windows.Data.BindingBase binding) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Data.BindingOperations.SetBinding(System.Windows.DependencyObject,System.Windows.DependencyProperty,System.Windows.Data.BindingBase)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SetBinding (target As DependencyObject, dp As DependencyProperty, binding As BindingBase) As BindingExpressionBase" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::Data::BindingExpressionBase ^ SetBinding(System::Windows::DependencyObject ^ target, System::Windows::DependencyProperty ^ dp, System::Windows::Data::BindingBase ^ binding);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Data.BindingExpressionBase</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Windows.DependencyObject" />
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
        <Parameter Name="binding" Type="System.Windows.Data.BindingBase" />
      </Parameters>
      <Docs>
        <param name="target">Destino de enlace del enlace.</param>
        <param name="dp">Propiedad de destino del enlace.</param>
        <param name="binding">Objeto <see cref="T:System.Windows.Data.BindingBase" /> que describe el enlace.</param>
        <summary>Crea y asocia una nueva instancia de <see cref="T:System.Windows.Data.BindingExpressionBase" /> con la propiedad de destino de enlace especificada.</summary>
        <returns>Instancia de <see cref="T:System.Windows.Data.BindingExpressionBase" /> creada y asociada con la propiedad especificada. La clase <see cref="T:System.Windows.Data.BindingExpressionBase" /> es la clase base de <see cref="T:System.Windows.Data.BindingExpression" />, <see cref="T:System.Windows.Data.MultiBindingExpression" /> y <see cref="T:System.Windows.Data.PriorityBindingExpression" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método crea una nueva instancia de un <xref:System.Windows.Data.BindingExpressionBase> y asocia la instancia a la propiedad de dependencia especificada del objeto especificado. Este método es la manera de asociar un enlace a arbitrario <xref:System.Windows.DependencyObject> que no puede exponer su propio método SetBinding.  
  
   
  
## Examples  
 En el ejemplo siguiente se muestra cómo utilizar este método para establecer un enlace. En este ejemplo, `myNewBindDef` es un <xref:System.Windows.Data.Binding> objeto que describe el enlace. El destino de enlace es `myDateText`, una instancia de la <xref:System.Windows.Controls.TextBlock> clase.  
  
 [!code-csharp[BindConversion#BOSetBinding](~/samples/snippets/csharp/VS_Snippets_Wpf/BindConversion/CSharp/Window1.xaml.cs#bosetbinding)]
 [!code-vb[BindConversion#BOSetBinding](~/samples/snippets/visualbasic/VS_Snippets_Wpf/BindConversion/visualbasic/window1.xaml.vb#bosetbinding)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El parámetro <paramref name="binding" /> no puede ser <see langword="null" />.</exception>
      </Docs>
    </Member>
  </Members>
</Type>