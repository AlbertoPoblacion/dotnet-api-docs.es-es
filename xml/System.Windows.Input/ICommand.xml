<Type Name="ICommand" FullName="System.Windows.Input.ICommand">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="ea5eff6a81bd27b0ab5ad70e628f1d59b7ee7f56" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="es-ES" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
    <Meta Name="ms.locfileid" Value="30647939" />
  </Metadata>
  <TypeSignature Language="C#" Value="public interface ICommand" />
  <TypeSignature Language="ILAsm" Value=".class public interface auto ansi abstract ICommand" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Input.ICommand" />
  <TypeSignature Language="VB.NET" Value="Public Interface ICommand" />
  <TypeSignature Language="C++ CLI" Value="public interface class ICommand" />
  <AssemblyInfo>
    <AssemblyName>System.ObjectModel</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.CompilerServices.TypeForwardedFrom("PresentationCore, Version=4.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35")</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>
      <span data-ttu-id="89137-101">Define un comando.</span>
      <span class="sxs-lookup">
        <span data-stu-id="89137-101">Defines a command.</span>
      </span>
    </summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="89137-102"><xref:System.Windows.Input.RoutedCommand> y <xref:System.Windows.Input.RoutedUICommand> son dos implementaciones de la <xref:System.Windows.Input.ICommand> en la interfaz [!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)].</span><span class="sxs-lookup"><span data-stu-id="89137-102"><xref:System.Windows.Input.RoutedCommand> and <xref:System.Windows.Input.RoutedUICommand> are two implementations of the <xref:System.Windows.Input.ICommand> interface in [!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)].</span></span>  
  
## <a name="icommand-in-windows-runtime-apps"></a><span data-ttu-id="89137-103">ICommand en Windows en tiempo de ejecución</span><span class="sxs-lookup"><span data-stu-id="89137-103">ICommand in Windows Runtime apps</span></span>  
 <span data-ttu-id="89137-104">La <xref:System.Windows.Input.ICommand> interfaz es el contrato de código para los comandos que se escriben en las aplicaciones de .NET para Windows en tiempo de ejecución.</span><span class="sxs-lookup"><span data-stu-id="89137-104">The <xref:System.Windows.Input.ICommand> interface is the code contract for commands that are written in .NET for Windows Runtime apps.</span></span> <span data-ttu-id="89137-105">Estos comandos proporcionan el comportamiento de comandos para los elementos de interfaz de usuario como un XAML en tiempo de ejecución de Windows `Button` y, en particular una `AppBarButton`.</span><span class="sxs-lookup"><span data-stu-id="89137-105">These commands provide the commanding behavior for UI elements such as a Windows Runtime XAML `Button` and in particular an `AppBarButton`.</span></span> <span data-ttu-id="89137-106">Si va a definir comandos para aplicaciones de Windows Runtime utilizarás básicamente las mismas técnicas que se utilizaría para definir los comandos para una aplicación. NET.</span><span class="sxs-lookup"><span data-stu-id="89137-106">If you're defining commands for Windows Runtime apps you use basically the same techniques you'd use for defining commands for a .NET app.</span></span> <span data-ttu-id="89137-107">Implementar el comando definiendo una clase que implementa <xref:System.Windows.Input.ICommand> e implemente específicamente el <xref:System.Windows.Input.ICommand.Execute%2A> método.</span><span class="sxs-lookup"><span data-stu-id="89137-107">Implement the command by defining a class that implements <xref:System.Windows.Input.ICommand> and specifically implement the <xref:System.Windows.Input.ICommand.Execute%2A> method.</span></span>  
  
 <span data-ttu-id="89137-108">XAML de Windows en tiempo de ejecución no admite x`:Static`, por lo que no intente utilizar la `x:Static` extensión de marcado si se utiliza el comando de Windows en tiempo de ejecución XAML.</span><span class="sxs-lookup"><span data-stu-id="89137-108">XAML for Windows Runtime does not support x`:Static`, so don't attempt to use the `x:Static` markup extension if the command is used from Windows Runtime XAML.</span></span> <span data-ttu-id="89137-109">Además, el tiempo de ejecución de Windows no tiene cualquier biblioteca de comandos predefinidos, por lo que la sintaxis XAML mostrada aquí no se aplica realmente en el caso de que está implementando la interfaz y definir el comando para el uso de Windows en tiempo de ejecución.</span><span class="sxs-lookup"><span data-stu-id="89137-109">Also, the Windows Runtime does not have any predefined command libraries, so the XAML syntax shown here doesn't really apply for the case where you're implementing the interface and defining the command for Windows Runtime usage.</span></span>  
  
<a name="xamlTextUsage_ICommand"></a>   
## <a name="xaml-attribute-usage"></a><span data-ttu-id="89137-110">Uso de atributos XAML</span><span class="sxs-lookup"><span data-stu-id="89137-110">XAML Attribute Usage</span></span>  
 <span data-ttu-id="89137-111">\<*propiedad de objeto*= "*predefinedCommandName*" / ></span><span class="sxs-lookup"><span data-stu-id="89137-111">\<*object property*="*predefinedCommandName*"/></span></span>  
  
 <span data-ttu-id="89137-112">\- o -</span><span class="sxs-lookup"><span data-stu-id="89137-112">\- or -</span></span>  
  
 <span data-ttu-id="89137-113">\<*propiedad de objeto*= "*predefinedCommandName.predefinedCommandName*" / ></span><span class="sxs-lookup"><span data-stu-id="89137-113">\<*object property*="*predefinedCommandName.predefinedCommandName*"/></span></span>  
  
 <span data-ttu-id="89137-114">\- o -</span><span class="sxs-lookup"><span data-stu-id="89137-114">\- or -</span></span>  
  
 <span data-ttu-id="89137-115">\<*propiedad de objeto*= "{ *customClassName.customCommandName*}" / ></span><span class="sxs-lookup"><span data-stu-id="89137-115">\<*object property*="{ *customClassName.customCommandName*}"/></span></span>  
  
<a name="xamlValues_ICommand"></a>   
## <a name="xaml-values"></a><span data-ttu-id="89137-116">Valores XAML</span><span class="sxs-lookup"><span data-stu-id="89137-116">XAML Values</span></span>  
 <span data-ttu-id="89137-117">*predefinedClassName*</span><span class="sxs-lookup"><span data-stu-id="89137-117">*predefinedClassName*</span></span>  
 <span data-ttu-id="89137-118">Una de las clases de comandos predefinidos.</span><span class="sxs-lookup"><span data-stu-id="89137-118">One of the predefined command classes.</span></span>  
  
 <span data-ttu-id="89137-119">*predefinedCommandName*</span><span class="sxs-lookup"><span data-stu-id="89137-119">*predefinedCommandName*</span></span>  
 <span data-ttu-id="89137-120">Uno de los comandos predefinidos.</span><span class="sxs-lookup"><span data-stu-id="89137-120">One of the predefined commands.</span></span>  
  
 <span data-ttu-id="89137-121">*customClassName*</span><span class="sxs-lookup"><span data-stu-id="89137-121">*customClassName*</span></span>  
 <span data-ttu-id="89137-122">Una clase personalizada que contiene el comando personalizado.</span><span class="sxs-lookup"><span data-stu-id="89137-122">A custom class that contains the custom command.</span></span> <span data-ttu-id="89137-123">Las clases personalizadas generalmente requieren un `xlmns` prefijar la asignación; vea [espacios de nombres XAML y asignación de Namespace para XAML de WPF](~/docs/framework/wpf/advanced/xaml-namespaces-and-namespace-mapping-for-wpf-xaml.md).</span><span class="sxs-lookup"><span data-stu-id="89137-123">Custom classes generally require an `xlmns` prefix mapping; see [XAML Namespaces and Namespace Mapping for WPF XAML](~/docs/framework/wpf/advanced/xaml-namespaces-and-namespace-mapping-for-wpf-xaml.md).</span></span>  
  
 <span data-ttu-id="89137-124">*customCommandName*</span><span class="sxs-lookup"><span data-stu-id="89137-124">*customCommandName*</span></span>  
 <span data-ttu-id="89137-125">Un comando personalizado.</span><span class="sxs-lookup"><span data-stu-id="89137-125">A custom command.</span></span>  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName="CanExecute">
      <MemberSignature Language="C#" Value="public bool CanExecute (object parameter);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool CanExecute(object parameter) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Input.ICommand.CanExecute(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function CanExecute (parameter As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool CanExecute(System::Object ^ parameter);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ObjectModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="parameter" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="parameter">
          <span data-ttu-id="89137-126">Datos que usa el comando.</span>
          <span class="sxs-lookup">
            <span data-stu-id="89137-126">Data used by the command.</span>
          </span>
          <span data-ttu-id="89137-127">Si el comando no exige pasar los datos, se puede establecer este objeto en <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="89137-127">If the command does not require data to be passed, this object can be set to <see langword="null" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="89137-128">Define el método que determina si el comando puede ejecutarse en su estado actual.</span>
          <span class="sxs-lookup">
            <span data-stu-id="89137-128">Defines the method that determines whether the command can execute in its current state.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="89137-129">
            <see langword="true" /> si se puede ejecutar este comando; de lo contrario, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="89137-129">
              <see langword="true" /> if this command can be executed; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="89137-130">Normalmente, un origen de comando llama el <xref:System.Windows.Input.ICommand.CanExecute%2A> método cuando el <xref:System.Windows.Input.ICommand.CanExecuteChanged> evento se desencadena.</span><span class="sxs-lookup"><span data-stu-id="89137-130">Typically, a command source calls the <xref:System.Windows.Input.ICommand.CanExecute%2A> method when the <xref:System.Windows.Input.ICommand.CanExecuteChanged> event is raised.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Input.ICommandSource" />
        <altmember cref="T:System.Windows.Input.RoutedCommand" />
        <altmember cref="T:System.Windows.Input.CommandManager" />
      </Docs>
    </Member>
    <Member MemberName="CanExecuteChanged">
      <MemberSignature Language="C#" Value="event EventHandler CanExecuteChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler CanExecuteChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Input.ICommand.CanExecuteChanged" />
      <MemberSignature Language="VB.NET" Value="Event CanExecuteChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ CanExecuteChanged;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ObjectModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="89137-131">Se produce cuando hay cambios que influyen en si el comando debería ejecutarse o no.</span>
          <span class="sxs-lookup">
            <span data-stu-id="89137-131">Occurs when changes occur that affect whether or not the command should execute.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="89137-132">Normalmente, un origen de comando llama <xref:System.Windows.Input.ICommand.CanExecute%2A> en el comando cuando se produce este evento.</span><span class="sxs-lookup"><span data-stu-id="89137-132">Normally, a command source calls <xref:System.Windows.Input.ICommand.CanExecute%2A> on the command when this event occurs.</span></span>  
  
 <span data-ttu-id="89137-133">Normalmente, si no se puede ejecutar el comando, el origen del comando deshabilita a sí mismo.</span><span class="sxs-lookup"><span data-stu-id="89137-133">Normally, if the command cannot execute, the command source disables itself.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Input.ICommandSource" />
        <altmember cref="T:System.Windows.Input.RoutedCommand" />
        <altmember cref="T:System.Windows.Input.CommandManager" />
      </Docs>
    </Member>
    <Member MemberName="Execute">
      <MemberSignature Language="C#" Value="public void Execute (object parameter);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Execute(object parameter) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Input.ICommand.Execute(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Execute (parameter As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Execute(System::Object ^ parameter);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ObjectModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="parameter" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="parameter">
          <span data-ttu-id="89137-134">Datos que usa el comando.</span>
          <span class="sxs-lookup">
            <span data-stu-id="89137-134">Data used by the command.</span>
          </span>
          <span data-ttu-id="89137-135">Si el comando no exige pasar los datos, se puede establecer este objeto en <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="89137-135">If the command does not require data to be passed, this object can be set to <see langword="null" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="89137-136">Define el método al que se llamará cuando se invoque el comando.</span>
          <span class="sxs-lookup">
            <span data-stu-id="89137-136">Defines the method to be called when the command is invoked.</span>
          </span>
        </summary>
        <remarks>To be added.</remarks>
        <altmember cref="T:System.Windows.Input.ICommandSource" />
        <altmember cref="T:System.Windows.Input.RoutedCommand" />
        <altmember cref="T:System.Windows.Input.CommandManager" />
      </Docs>
    </Member>
  </Members>
</Type>