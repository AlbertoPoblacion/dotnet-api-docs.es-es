<Type Name="CanExecuteRoutedEventHandler" FullName="System.Windows.Input.CanExecuteRoutedEventHandler">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="40314ee81839ebd0b1ef25f5f831b2e68f2b0ad5" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="es-ES" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
    <Meta Name="ms.locfileid" Value="30646669" />
  </Metadata>
  <TypeSignature Language="C#" Value="public delegate void CanExecuteRoutedEventHandler(object sender, CanExecuteRoutedEventArgs e);" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed CanExecuteRoutedEventHandler extends System.MulticastDelegate" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Input.CanExecuteRoutedEventHandler" />
  <TypeSignature Language="VB.NET" Value="Public Delegate Sub CanExecuteRoutedEventHandler(sender As Object, e As CanExecuteRoutedEventArgs)" />
  <TypeSignature Language="C++ CLI" Value="public delegate void CanExecuteRoutedEventHandler(System::Object ^ sender, CanExecuteRoutedEventArgs ^ e);" />
  <AssemblyInfo>
    <AssemblyName>PresentationCore</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Delegate</BaseTypeName>
  </Base>
  <Parameters>
    <Parameter Name="sender" Type="System.Object" />
    <Parameter Name="e" Type="System.Windows.Input.CanExecuteRoutedEventArgs" />
  </Parameters>
  <ReturnValue>
    <ReturnType>System.Void</ReturnType>
  </ReturnValue>
  <Docs>
    <param name="sender">Destino de comando que invoca al controlador.</param>
    <param name="e">Datos del evento.</param>
    <summary>Representa el método que controlará el evento <see cref="E:System.Windows.Input.CommandBinding.CanExecute" />.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Windows.Input.CanExecuteRoutedEventHandler> determina si el comando asociado con el origen del evento es capaz de ejecutar en el destino del comando. Si el comando no tiene un origen de comando que especifica un destino, la información de destino puede obtenerse a través de `sender`. Si el <xref:System.Windows.Input.ICommandSource.CommandTarget%2A> no se establece, el elemento tiene el foco de teclado es el destino y también puede obtenerse a través de `sender`.  Si se determina que el comando puede ejecutarse en el destino, la <xref:System.Windows.Input.CanExecuteRoutedEventArgs.CanExecute%2A?displayProperty=nameWithType> propiedad debe establecerse en `true`; en caso contrario, establézcalo en `false`.  
  
 No debe confiar en los datos del evento para determinar el comando, el origen y el destino. Puede limitar el uso del controlador a las invocaciones de comando posibles conocido, aunque esto es más difícil de lograr si la estructura de comandos depende en gran medida el enrutamiento de comandos para ejecutar el mismo comando en posibles destinos sucesivos en una ruta del evento.  
  
   
  
## Examples  
 El ejemplo siguiente muestra un <xref:System.Windows.Input.CanExecuteRoutedEventHandler> que establece <xref:System.Windows.Input.CanExecuteRoutedEventArgs.CanExecute%2A> a `true`.  
  
 [!code-csharp[commandwithhandler#CommandHandlerCanExecuteHandler](~/samples/snippets/csharp/VS_Snippets_Wpf/commandWithHandler/CSharp/Window1.xaml.cs#commandhandlercanexecutehandler)]
 [!code-vb[commandwithhandler#CommandHandlerCanExecuteHandler](~/samples/snippets/visualbasic/VS_Snippets_Wpf/commandWithHandler/VisualBasic/Window1.xaml.vb#commandhandlercanexecutehandler)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Windows.Input.CommandBinding" />
    <altmember cref="T:System.Windows.Input.ExecutedRoutedEventHandler" />
  </Docs>
</Type>