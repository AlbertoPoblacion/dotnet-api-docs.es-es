<Type Name="FocusManager" FullName="System.Windows.Input.FocusManager">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="1d6d9fcb88d7d279e85f852ae0f07a5a866d3b86" />
    <Meta Name="ms.sourcegitcommit" Value="434f60616a9793fa8436744549fc856e94f7a648" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="es-ES" />
    <Meta Name="ms.lasthandoff" Value="08/25/2018" />
    <Meta Name="ms.locfileid" Value="39876946" />
  </Metadata>
  <TypeSignature Language="C#" Value="public static class FocusManager" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract sealed beforefieldinit FocusManager extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Input.FocusManager" />
  <TypeSignature Language="VB.NET" Value="Public Class FocusManager" />
  <TypeSignature Language="C++ CLI" Value="public ref class FocusManager abstract sealed" />
  <TypeSignature Language="F#" Value="type FocusManager = class" />
  <AssemblyInfo>
    <AssemblyName>PresentationCore</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Proporciona un conjunto de métodos estáticos, propiedades asociadas y eventos para determinar y establecer los ámbitos de foco, así como para establecer el elemento enfocado dentro del ámbito.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 En Windows Presentation Foundation (WPF) hay dos conceptos relativos al foco: foco de teclado y el foco lógico.  
  
 El foco de teclado pertenece al elemento que está recibiendo actualmente la entrada de teclado.  Puede haber solo un elemento con foco de teclado.  Este elemento con foco de teclado tiene <xref:System.Windows.IInputElement.IsKeyboardFocused%2A> establecido en `true`.  <xref:System.Windows.Input.Keyboard.FocusedElement%2A?displayProperty=nameWithType> Devuelve el elemento con foco de teclado.  
  
 Foco lógico pertenece a la <xref:System.Windows.Input.FocusManager.FocusedElement%2A?displayProperty=nameWithType> dentro de un ámbito de foco concreto.  
  
 Un ámbito de foco es un elemento contenedor que realiza un seguimiento de la <xref:System.Windows.Input.FocusManager.FocusedElement%2A?displayProperty=nameWithType> dentro de su ámbito.  De forma predeterminada, el <xref:System.Windows.Window> clase es un ámbito de foco, como son el <xref:System.Windows.Controls.Menu>, <xref:System.Windows.Controls.ContextMenu>, y <xref:System.Windows.Controls.ToolBar> clases.  Tiene un elemento que es un ámbito de foco <xref:System.Windows.Input.FocusManager.IsFocusScope%2A> establecido en `true`.  
  
 Puede haber varios elementos con el foco lógico, pero solo puede haber un elemento con el foco lógico dentro de un ámbito de foco único.  Un elemento con foco lógico no tiene necesariamente el foco de teclado, pero un elemento con foco de teclado tendrá el foco lógico.  Es posible definir un ámbito de foco dentro de un ámbito de foco.  En este caso, pueden tener el ámbito de foco del elemento primario y el ámbito de foco secundario un <xref:System.Windows.Input.FocusManager.FocusedElement%2A?displayProperty=nameWithType>.  
  
 El siguiente escenario muestra cómo cambian el foco del teclado y el foco lógico en una aplicación WPF que tiene un <xref:System.Windows.Window> con un <xref:System.Windows.Controls.TextBox> y un <xref:System.Windows.Controls.Menu> que tiene un <xref:System.Windows.Controls.MenuItem>.  Cuando se cambia el foco de teclado de la <xref:System.Windows.Controls.TextBox> a la <xref:System.Windows.Controls.MenuItem>, el <xref:System.Windows.Controls.TextBox> el foco de teclado pérdidas, pero conserva el foco lógico para el <xref:System.Windows.Window> centrar el ámbito.  El <xref:System.Windows.Controls.MenuItem> recibe el foco de teclado y recibe el foco lógico para el <xref:System.Windows.Controls.Menu> centrar el ámbito.  Cuando el foco de teclado se devuelve a la raíz <xref:System.Windows.Window>, el elemento <xref:System.Windows.Window> ámbito de foco con el foco lógico obtendrá el foco de teclado, que en este caso es el <xref:System.Windows.Controls.TextBox>.  El <xref:System.Windows.Controls.TextBox> ahora tiene el foco de teclado y el foco lógico.  El <xref:System.Windows.Controls.MenuItem> pierde el foco de teclado, pero conserva el foco lógico para el <xref:System.Windows.Controls.Menu> centrar el ámbito.  
  
 El valor predeterminado de <xref:System.Windows.Input.FocusManager.IsFocusScope%2A> en un <xref:System.Windows.Window>, <xref:System.Windows.Controls.Menu>, <xref:System.Windows.Controls.ToolBar>, y <xref:System.Windows.Controls.ContextMenu> es `true`.  
  
 Para obtener más información sobre el foco, vea el [Input Overview](~/docs/framework/wpf/advanced/input-overview.md) y [foco lógico](~/docs/framework/wpf/advanced/focus-overview.md).  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName="AddGotFocusHandler">
      <MemberSignature Language="C#" Value="public static void AddGotFocusHandler (System.Windows.DependencyObject element, System.Windows.RoutedEventHandler handler);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void AddGotFocusHandler(class System.Windows.DependencyObject element, class System.Windows.RoutedEventHandler handler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Input.FocusManager.AddGotFocusHandler(System.Windows.DependencyObject,System.Windows.RoutedEventHandler)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub AddGotFocusHandler (element As DependencyObject, handler As RoutedEventHandler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void AddGotFocusHandler(System::Windows::DependencyObject ^ element, System::Windows::RoutedEventHandler ^ handler);" />
      <MemberSignature Language="F#" Value="static member AddGotFocusHandler : System.Windows.DependencyObject * System.Windows.RoutedEventHandler -&gt; unit" Usage="System.Windows.Input.FocusManager.AddGotFocusHandler (element, handler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
        <Parameter Name="handler" Type="System.Windows.RoutedEventHandler" />
      </Parameters>
      <Docs>
        <param name="element">Objeto <see cref="T:System.Windows.UIElement" /> o <see cref="T:System.Windows.ContentElement" /> que escucha este evento.</param>
        <param name="handler">Controlador de eventos que se va a agregar.</param>
        <summary>Agrega un controlador para el evento adjunto <see cref="E:System.Windows.Input.FocusManager.GotFocus" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AddLostFocusHandler">
      <MemberSignature Language="C#" Value="public static void AddLostFocusHandler (System.Windows.DependencyObject element, System.Windows.RoutedEventHandler handler);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void AddLostFocusHandler(class System.Windows.DependencyObject element, class System.Windows.RoutedEventHandler handler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Input.FocusManager.AddLostFocusHandler(System.Windows.DependencyObject,System.Windows.RoutedEventHandler)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub AddLostFocusHandler (element As DependencyObject, handler As RoutedEventHandler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void AddLostFocusHandler(System::Windows::DependencyObject ^ element, System::Windows::RoutedEventHandler ^ handler);" />
      <MemberSignature Language="F#" Value="static member AddLostFocusHandler : System.Windows.DependencyObject * System.Windows.RoutedEventHandler -&gt; unit" Usage="System.Windows.Input.FocusManager.AddLostFocusHandler (element, handler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
        <Parameter Name="handler" Type="System.Windows.RoutedEventHandler" />
      </Parameters>
      <Docs>
        <param name="element">Objeto <see cref="T:System.Windows.UIElement" /> o <see cref="T:System.Windows.ContentElement" /> que escucha este evento.</param>
        <param name="handler">Controlador de eventos que se va a agregar.</param>
        <summary>Agrega un controlador para el evento adjunto <see cref="E:System.Windows.Input.FocusManager.LostFocus" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="FocusedElement">
      <MemberSignature Language="C#" Value="see GetFocusedElement, and SetFocusedElement" />
      <MemberSignature Language="ILAsm" Value="see GetFocusedElement, and SetFocusedElement" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Input.FocusManager.FocusedElement" />
      <MemberSignature Language="VB.NET" Value="see GetFocusedElement, and SetFocusedElement" />
      <MemberSignature Language="F#" Value="see GetFocusedElement, and SetFocusedElement" Usage="see GetFocusedElement, and SetFocusedElement" />
      <MemberType>AttachedProperty</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Determina si el elemento al que está asociado esta propiedad tiene el foco lógico.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Windows.Input.FocusManager.FocusedElement%2A> es el elemento que tiene el foco lógico para un ámbito de foco concreto.  Este objeto puede o no tenga el foco de teclado.  El foco de teclado hace referencia al elemento que recibe la entrada de teclado.  Para obtener más información sobre el foco, el foco de teclado y el foco lógico, consulte el [Input Overview](~/docs/framework/wpf/advanced/input-overview.md).  
  
 <xref:System.Windows.Input.FocusManager.GetFocusedElement%2A> y <xref:System.Windows.Input.FocusManager.SetFocusedElement%2A> puede usarse para obtener y establecer el elemento enfocado dentro del ámbito de foco especificado.  
  
<a name="dependencyPropertyInfo_FocusedElement"></a>   
## <a name="dependency-property-information"></a>Información sobre propiedades de dependencia  
  
|||  
|-|-|  
|Campo de identificador|<xref:System.Windows.Input.FocusManager.FocusedElementProperty>|  
|Propiedades de metadatos establecidas **true**|None|  
  
   
  
## Examples  
 El ejemplo siguiente muestra cómo realizar una <xref:System.Windows.Controls.Button> el elemento con foco.  
  
 [!code-xml[markupsnippets#MarkupFocusManagerFocusedElementXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/MarkupSnippets/CSharp/Window1.xaml#markupfocusmanagerfocusedelementxaml)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FocusedElementProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty FocusedElementProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty FocusedElementProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Input.FocusManager.FocusedElementProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly FocusedElementProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ FocusedElementProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable FocusedElementProperty : System.Windows.DependencyProperty" Usage="System.Windows.Input.FocusManager.FocusedElementProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifica la propiedad adjunta <see cref="P:System.Windows.Input.FocusManager.FocusedElement" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetFocusedElement">
      <MemberSignature Language="C#" Value="public static System.Windows.IInputElement GetFocusedElement (System.Windows.DependencyObject element);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.IInputElement GetFocusedElement(class System.Windows.DependencyObject element) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Input.FocusManager.GetFocusedElement(System.Windows.DependencyObject)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetFocusedElement (element As DependencyObject) As IInputElement" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::IInputElement ^ GetFocusedElement(System::Windows::DependencyObject ^ element);" />
      <MemberSignature Language="F#" Value="static member GetFocusedElement : System.Windows.DependencyObject -&gt; System.Windows.IInputElement" Usage="System.Windows.Input.FocusManager.GetFocusedElement element" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.IInputElement</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
      </Parameters>
      <Docs>
        <param name="element">Elemento con el foco lógico en el ámbito de foco especificado.</param>
        <summary>Obtiene el elemento con el foco lógico dentro del ámbito de foco especificado.</summary>
        <returns>Elemento del ámbito de foco especificado con el foco lógico.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Windows.Input.FocusManager.FocusedElement%2A> es el elemento que tiene el foco lógico para un ámbito de foco concreto.  Este objeto puede o no tenga el foco de teclado.  El foco de teclado hace referencia al elemento que recibe la entrada de teclado.  Para obtener más información sobre el foco, el foco de teclado y el foco lógico, consulte el [Input Overview](~/docs/framework/wpf/advanced/input-overview.md).  
  
 Si `element` no es un ámbito de foco, este método devolverá `null`.  
  
 Use <xref:System.Windows.Input.FocusManager.SetFocusedElement%2A>, para especificar el elemento con el foco lógico dentro de un ámbito de foco especificado.  
  
   
  
## Examples  
 En el ejemplo siguiente se establece el elemento con foco lógico mediante el uso de la <xref:System.Windows.Input.FocusManager.SetFocusedElement%2A> y obtiene el elemento con foco lógico mediante el uso de la <xref:System.Windows.Input.FocusManager.GetFocusedElement%2A>.  
  
 [!code-csharp[focussnippets#FocusGetSetFocusedElement](~/samples/snippets/csharp/VS_Snippets_Wpf/FocusSnippets/CSharp/Window1.xaml.cs#focusgetsetfocusedelement)]
 [!code-vb[focussnippets#FocusGetSetFocusedElement](~/samples/snippets/visualbasic/VS_Snippets_Wpf/FocusSnippets/visualbasic/window1.xaml.vb#focusgetsetfocusedelement)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="element" /> es <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetFocusScope">
      <MemberSignature Language="C#" Value="public static System.Windows.DependencyObject GetFocusScope (System.Windows.DependencyObject element);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.DependencyObject GetFocusScope(class System.Windows.DependencyObject element) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Input.FocusManager.GetFocusScope(System.Windows.DependencyObject)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetFocusScope (element As DependencyObject) As DependencyObject" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::DependencyObject ^ GetFocusScope(System::Windows::DependencyObject ^ element);" />
      <MemberSignature Language="F#" Value="static member GetFocusScope : System.Windows.DependencyObject -&gt; System.Windows.DependencyObject" Usage="System.Windows.Input.FocusManager.GetFocusScope element" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyObject</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
      </Parameters>
      <Docs>
        <param name="element">Elemento para el que se va a obtener el ámbito de foco más cercano.</param>
        <summary>Determina el antecesor más cercano del elemento especificado que tiene la propiedad <see cref="P:System.Windows.Input.FocusManager.IsFocusScope" /> establecida en <see langword="true" />.</summary>
        <returns>Ámbito del foco del elemento especificado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El valor predeterminado de <xref:System.Windows.Input.FocusManager.IsFocusScope%2A> en un <xref:System.Windows.Window>, <xref:System.Windows.Controls.Menu>, <xref:System.Windows.Controls.ToolBar>, <xref:System.Windows.Controls.ContextMenu> es `true`.  
  
 Un ámbito de foco es un elemento contenedor que realiza un seguimiento de la <xref:System.Windows.Input.FocusManager.FocusedElement%2A?displayProperty=nameWithType> dentro de su ámbito.  De forma predeterminada, el <xref:System.Windows.Window> clase es un ámbito de foco, como son el <xref:System.Windows.Controls.Menu>, <xref:System.Windows.Controls.ContextMenu>, y <xref:System.Windows.Controls.ToolBar> clases.  Tiene un elemento que es un ámbito de foco <xref:System.Windows.Input.FocusManager.IsFocusScope%2A> establecido en `true`.  
  
 Para obtener más información sobre el foco, el foco de teclado y el foco lógico, consulte el [Input Overview](~/docs/framework/wpf/advanced/input-overview.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="element" /> es <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetIsFocusScope">
      <MemberSignature Language="C#" Value="public static bool GetIsFocusScope (System.Windows.DependencyObject element);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool GetIsFocusScope(class System.Windows.DependencyObject element) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Input.FocusManager.GetIsFocusScope(System.Windows.DependencyObject)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetIsFocusScope (element As DependencyObject) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool GetIsFocusScope(System::Windows::DependencyObject ^ element);" />
      <MemberSignature Language="F#" Value="static member GetIsFocusScope : System.Windows.DependencyObject -&gt; bool" Usage="System.Windows.Input.FocusManager.GetIsFocusScope element" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
      </Parameters>
      <Docs>
        <param name="element">Elemento del que se va a leer la propiedad adjunta.</param>
        <summary>Determina si el <see cref="T:System.Windows.DependencyObject" /> especificado es un ámbito de foco.</summary>
        <returns>Es <see langword="true" /> si la propiedad <see cref="P:System.Windows.Input.FocusManager.IsFocusScope" /> está establecida en <see langword="true" /> en el elemento especificado; de lo contrario, es <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un ámbito de foco es un elemento contenedor que realiza un seguimiento de la <xref:System.Windows.Input.FocusManager.FocusedElement%2A?displayProperty=nameWithType> dentro de su ámbito.  De forma predeterminada, el <xref:System.Windows.Window> clase es un ámbito de foco, como son el <xref:System.Windows.Controls.Menu>, <xref:System.Windows.Controls.ContextMenu>, y <xref:System.Windows.Controls.ToolBar> clases.  Tiene un elemento que es un ámbito de foco <xref:System.Windows.Input.FocusManager.IsFocusScope%2A> establecido en `true`.  
  
 Para obtener más información sobre el foco, el foco de teclado y el foco lógico, consulte el [Input Overview](~/docs/framework/wpf/advanced/input-overview.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GotFocus">
      <MemberSignature Language="C#" Value="see AddGotFocusHandler, and RemoveGotFocusHandler" />
      <MemberSignature Language="ILAsm" Value="see AddGotFocusHandler, and RemoveGotFocusHandler" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Input.FocusManager.GotFocus" />
      <MemberSignature Language="VB.NET" Value="see AddGotFocusHandler, and RemoveGotFocusHandler" />
      <MemberSignature Language="F#" Value="see AddGotFocusHandler, and RemoveGotFocusHandler" Usage="see AddGotFocusHandler, and RemoveGotFocusHandler" />
      <MemberType>AttachedEvent</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Se produce cuando un elemento obtiene el foco.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GotFocusEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent GotFocusEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent GotFocusEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Input.FocusManager.GotFocusEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly GotFocusEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ GotFocusEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable GotFocusEvent : System.Windows.RoutedEvent" Usage="System.Windows.Input.FocusManager.GotFocusEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifica el evento adjunto <see cref="E:System.Windows.Input.FocusManager.GotFocus" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsFocusScope">
      <MemberSignature Language="C#" Value="see GetIsFocusScope, and SetIsFocusScope" />
      <MemberSignature Language="ILAsm" Value="see GetIsFocusScope, and SetIsFocusScope" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Input.FocusManager.IsFocusScope" />
      <MemberSignature Language="VB.NET" Value="see GetIsFocusScope, and SetIsFocusScope" />
      <MemberSignature Language="F#" Value="see GetIsFocusScope, and SetIsFocusScope" Usage="see GetIsFocusScope, and SetIsFocusScope" />
      <MemberType>AttachedProperty</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Determina si el elemento al que está asociado esta propiedad es un ámbito de foco.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un ámbito de foco es un elemento contenedor que realiza un seguimiento de la <xref:System.Windows.Input.FocusManager.FocusedElement%2A?displayProperty=nameWithType> dentro de su ámbito.  De forma predeterminada, el <xref:System.Windows.Window> clase es un ámbito de foco, como son el <xref:System.Windows.Controls.Menu>, <xref:System.Windows.Controls.ContextMenu>, y <xref:System.Windows.Controls.ToolBar> clases.  Tiene un elemento que es un ámbito de foco <xref:System.Windows.Input.FocusManager.IsFocusScope%2A> establecido en `true`.  
  
 Para obtener más información sobre el foco, el foco de teclado y el foco lógico, consulte el [Input Overview](~/docs/framework/wpf/advanced/input-overview.md).  
  
<a name="dependencyPropertyInfo_IsFocusScope"></a>   
## <a name="dependency-property-information"></a>Información sobre propiedades de dependencia  
  
|||  
|-|-|  
|Campo de identificador|<xref:System.Windows.Input.FocusManager.IsFocusScopeProperty>|  
|Propiedades de metadatos establecidas **true**|None|  
  
   
  
## Examples  
 En el ejemplo siguiente se realiza una <xref:System.Windows.Controls.StackPanel> un ámbito de foco.  
  
 [!code-xml[markupsnippets#MarkupIsFocusScopeXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/MarkupSnippets/CSharp/Window1.xaml#markupisfocusscopexaml)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsFocusScopeProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty IsFocusScopeProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty IsFocusScopeProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Input.FocusManager.IsFocusScopeProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly IsFocusScopeProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ IsFocusScopeProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable IsFocusScopeProperty : System.Windows.DependencyProperty" Usage="System.Windows.Input.FocusManager.IsFocusScopeProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifica la propiedad adjunta <see cref="P:System.Windows.Input.FocusManager.IsFocusScope" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El valor predeterminado de <xref:System.Windows.Input.FocusManager.IsFocusScope%2A> en un <xref:System.Windows.Window>, <xref:System.Windows.Controls.Menu>, <xref:System.Windows.Controls.ToolBar>, <xref:System.Windows.Controls.ContextMenu> es `true`.  
  
 Un ámbito de foco es un elemento contenedor que realiza un seguimiento de la <xref:System.Windows.Input.FocusManager.FocusedElement%2A?displayProperty=nameWithType> dentro de su ámbito.  De forma predeterminada, el <xref:System.Windows.Window> clase es un ámbito de foco, como son el <xref:System.Windows.Controls.Menu>, <xref:System.Windows.Controls.ContextMenu>, y <xref:System.Windows.Controls.ToolBar> clases.  Tiene un elemento que es un ámbito de foco <xref:System.Windows.Input.FocusManager.IsFocusScope%2A> establecido en `true`.  
  
 Para obtener más información sobre el foco, el foco de teclado y el foco lógico, consulte el [Input Overview](~/docs/framework/wpf/advanced/input-overview.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LostFocus">
      <MemberSignature Language="C#" Value="see AddLostFocusHandler, and RemoveLostFocusHandler" />
      <MemberSignature Language="ILAsm" Value="see AddLostFocusHandler, and RemoveLostFocusHandler" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Input.FocusManager.LostFocus" />
      <MemberSignature Language="VB.NET" Value="see AddLostFocusHandler, and RemoveLostFocusHandler" />
      <MemberSignature Language="F#" Value="see AddLostFocusHandler, and RemoveLostFocusHandler" Usage="see AddLostFocusHandler, and RemoveLostFocusHandler" />
      <MemberType>AttachedEvent</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Se produce cuando un elemento pierde el foco.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="LostFocusEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent LostFocusEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent LostFocusEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Input.FocusManager.LostFocusEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly LostFocusEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ LostFocusEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable LostFocusEvent : System.Windows.RoutedEvent" Usage="System.Windows.Input.FocusManager.LostFocusEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifica el evento adjunto <see cref="E:System.Windows.Input.FocusManager.LostFocus" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RemoveGotFocusHandler">
      <MemberSignature Language="C#" Value="public static void RemoveGotFocusHandler (System.Windows.DependencyObject element, System.Windows.RoutedEventHandler handler);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RemoveGotFocusHandler(class System.Windows.DependencyObject element, class System.Windows.RoutedEventHandler handler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Input.FocusManager.RemoveGotFocusHandler(System.Windows.DependencyObject,System.Windows.RoutedEventHandler)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RemoveGotFocusHandler (element As DependencyObject, handler As RoutedEventHandler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RemoveGotFocusHandler(System::Windows::DependencyObject ^ element, System::Windows::RoutedEventHandler ^ handler);" />
      <MemberSignature Language="F#" Value="static member RemoveGotFocusHandler : System.Windows.DependencyObject * System.Windows.RoutedEventHandler -&gt; unit" Usage="System.Windows.Input.FocusManager.RemoveGotFocusHandler (element, handler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
        <Parameter Name="handler" Type="System.Windows.RoutedEventHandler" />
      </Parameters>
      <Docs>
        <param name="element">Objeto <see cref="T:System.Windows.UIElement" /> o <see cref="T:System.Windows.ContentElement" /> que escucha este evento.</param>
        <param name="handler">Controlador de eventos que se va a quitar.</param>
        <summary>Quita un controlador del evento adjunto <see cref="E:System.Windows.Input.FocusManager.GotFocus" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RemoveLostFocusHandler">
      <MemberSignature Language="C#" Value="public static void RemoveLostFocusHandler (System.Windows.DependencyObject element, System.Windows.RoutedEventHandler handler);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RemoveLostFocusHandler(class System.Windows.DependencyObject element, class System.Windows.RoutedEventHandler handler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Input.FocusManager.RemoveLostFocusHandler(System.Windows.DependencyObject,System.Windows.RoutedEventHandler)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RemoveLostFocusHandler (element As DependencyObject, handler As RoutedEventHandler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RemoveLostFocusHandler(System::Windows::DependencyObject ^ element, System::Windows::RoutedEventHandler ^ handler);" />
      <MemberSignature Language="F#" Value="static member RemoveLostFocusHandler : System.Windows.DependencyObject * System.Windows.RoutedEventHandler -&gt; unit" Usage="System.Windows.Input.FocusManager.RemoveLostFocusHandler (element, handler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
        <Parameter Name="handler" Type="System.Windows.RoutedEventHandler" />
      </Parameters>
      <Docs>
        <param name="element">Objeto <see cref="T:System.Windows.UIElement" /> o <see cref="T:System.Windows.ContentElement" /> que escucha este evento.</param>
        <param name="handler">Controlador de eventos que se va a quitar.</param>
        <summary>Quita un controlador del evento adjunto <see cref="E:System.Windows.Input.FocusManager.LostFocus" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SetFocusedElement">
      <MemberSignature Language="C#" Value="public static void SetFocusedElement (System.Windows.DependencyObject element, System.Windows.IInputElement value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetFocusedElement(class System.Windows.DependencyObject element, class System.Windows.IInputElement value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Input.FocusManager.SetFocusedElement(System.Windows.DependencyObject,System.Windows.IInputElement)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetFocusedElement (element As DependencyObject, value As IInputElement)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetFocusedElement(System::Windows::DependencyObject ^ element, System::Windows::IInputElement ^ value);" />
      <MemberSignature Language="F#" Value="static member SetFocusedElement : System.Windows.DependencyObject * System.Windows.IInputElement -&gt; unit" Usage="System.Windows.Input.FocusManager.SetFocusedElement (element, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
        <Parameter Name="value" Type="System.Windows.IInputElement" />
      </Parameters>
      <Docs>
        <param name="element">Ámbito del foco en el que el elemento especificado se va a convertir en <see cref="P:System.Windows.Input.FocusManager.FocusedElement" />.</param>
        <param name="value">Elemento al que se va a dar el foco lógico.</param>
        <summary>Establece el foco lógico en el elemento especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Windows.Input.FocusManager.FocusedElement%2A> es el elemento que tiene el foco lógico para el ámbito de foco concreto.  Este objeto puede o no tenga el foco de teclado.  El foco de teclado hace referencia al elemento que recibe la entrada de teclado.  Para obtener más información sobre el foco, el foco de teclado y el foco lógico, consulte el [Input Overview](~/docs/framework/wpf/advanced/input-overview.md).  
  
 Es posible especificar un ámbito de foco es un antecesor del elemento está en el ámbito de foco.  Por ejemplo, si un <xref:System.Windows.Controls.StackPanel> es un ámbito de foco y su elemento primario <xref:System.Windows.Window> es un ámbito de foco, un <xref:System.Windows.Controls.TextBox> secundarios de la <xref:System.Windows.Controls.StackPanel> podría especificar el <xref:System.Windows.Window> como el ámbito de foco cuando se llama a <xref:System.Windows.Input.FocusManager.SetFocusedElement%2A>.  El <xref:System.Windows.Controls.TextBox> es, a continuación, <xref:System.Windows.Input.FocusManager.FocusedElement%2A> tanto para el <xref:System.Windows.Window> centrar el ámbito y el <xref:System.Windows.Controls.StackPanel> centrar el ámbito.  
  
 <xref:System.Windows.Input.FocusManager.SetFocusedElement%2A> le dará el foco lógico del elemento especificado en el ámbito de foco especificado y se intentará dar el foco de teclado del elemento.  
  
   
  
## Examples  
 En el ejemplo siguiente se establece el elemento con foco lógico mediante el uso de la <xref:System.Windows.Input.FocusManager.SetFocusedElement%2A> y obtiene el elemento con foco lógico mediante el uso de la <xref:System.Windows.Input.FocusManager.GetFocusedElement%2A>.  
  
 [!code-csharp[focussnippets#FocusGetSetFocusedElement](~/samples/snippets/csharp/VS_Snippets_Wpf/FocusSnippets/CSharp/Window1.xaml.cs#focusgetsetfocusedelement)]
 [!code-vb[focussnippets#FocusGetSetFocusedElement](~/samples/snippets/visualbasic/VS_Snippets_Wpf/FocusSnippets/visualbasic/window1.xaml.vb#focusgetsetfocusedelement)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetIsFocusScope">
      <MemberSignature Language="C#" Value="public static void SetIsFocusScope (System.Windows.DependencyObject element, bool value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetIsFocusScope(class System.Windows.DependencyObject element, bool value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Input.FocusManager.SetIsFocusScope(System.Windows.DependencyObject,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetIsFocusScope (element As DependencyObject, value As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetIsFocusScope(System::Windows::DependencyObject ^ element, bool value);" />
      <MemberSignature Language="F#" Value="static member SetIsFocusScope : System.Windows.DependencyObject * bool -&gt; unit" Usage="System.Windows.Input.FocusManager.SetIsFocusScope (element, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
        <Parameter Name="value" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="element">Elemento que se va a convertir en un ámbito de foco.</param>
        <param name="value">Es <see langword="true" /> si <c>element</c> es un ámbito de foco; de lo contrario, es <see langword="false" />.</param>
        <summary>Establece el <see cref="T:System.Windows.DependencyObject" /> especificado como un ámbito de foco.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un ámbito de foco es un elemento contenedor que realiza un seguimiento de la <xref:System.Windows.Input.FocusManager.FocusedElement%2A?displayProperty=nameWithType> dentro de su ámbito.  De forma predeterminada, el <xref:System.Windows.Window> clase es un ámbito de foco, como son el <xref:System.Windows.Controls.Menu>, <xref:System.Windows.Controls.ContextMenu>, y <xref:System.Windows.Controls.ToolBar> clases.  Tiene un elemento que es un ámbito de foco <xref:System.Windows.Input.FocusManager.IsFocusScope%2A> establecido en `true`.  
  
 Para obtener más información sobre el foco, el foco de teclado y el foco lógico, consulte el [Input Overview](~/docs/framework/wpf/advanced/input-overview.md).  
  
   
  
## Examples  
 El ejemplo siguiente convierte un ámbito de foco de un elemento mediante el uso de <xref:System.Windows.Input.FocusManager.SetIsFocusScope%2A>.  
  
 [!code-csharp[focussnippets#FocusSetIsFocusScope](~/samples/snippets/csharp/VS_Snippets_Wpf/FocusSnippets/CSharp/Window1.xaml.cs#focussetisfocusscope)]
 [!code-vb[focussnippets#FocusSetIsFocusScope](~/samples/snippets/visualbasic/VS_Snippets_Wpf/FocusSnippets/visualbasic/window1.xaml.vb#focussetisfocusscope)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>