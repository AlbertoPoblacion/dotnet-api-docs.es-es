<Type Name="FocusManager" FullName="System.Windows.Input.FocusManager">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="3e1051a2c47fbf0892f35e2ccc3f38ea87cba9a5" />
    <Meta Name="ms.sourcegitcommit" Value="cc0c87a2e12b0fb9ba9ecdd3d4950f0572524db8" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="es-ES" />
    <Meta Name="ms.lasthandoff" Value="05/03/2018" />
    <Meta Name="ms.locfileid" Value="32693859" />
  </Metadata>
  <TypeSignature Language="C#" Value="public static class FocusManager" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract sealed beforefieldinit FocusManager extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Input.FocusManager" />
  <TypeSignature Language="VB.NET" Value="Public Class FocusManager" />
  <TypeSignature Language="C++ CLI" Value="public ref class FocusManager abstract sealed" />
  <AssemblyInfo>
    <AssemblyName>PresentationCore</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Proporciona un conjunto de métodos estáticos, propiedades asociadas y eventos para determinar y establecer los ámbitos de foco, así como para establecer el elemento enfocado dentro del ámbito.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 En Windows Presentation Foundation (WPF) hay dos conceptos relativos al foco: foco del teclado y el foco lógico.  
  
 El foco de teclado pertenece al elemento que está recibiendo actualmente la entrada de teclado.  Puede haber un único elemento con el foco de teclado.  Este elemento tiene el foco de teclado tiene <xref:System.Windows.IInputElement.IsKeyboardFocused%2A> establecido en `true`.  <xref:System.Windows.Input.Keyboard.FocusedElement%2A?displayProperty=nameWithType> Devuelve el elemento con el foco de teclado.  
  
 El foco lógico pertenece a la <xref:System.Windows.Input.FocusManager.FocusedElement%2A?displayProperty=nameWithType> dentro de un ámbito de foco concreto.  
  
 Un ámbito de foco es un elemento contenedor que realiza un seguimiento de los <xref:System.Windows.Input.FocusManager.FocusedElement%2A?displayProperty=nameWithType> dentro de su ámbito.  De forma predeterminada, el <xref:System.Windows.Window> clase es un ámbito de foco sea la <xref:System.Windows.Controls.Menu>, <xref:System.Windows.Controls.ContextMenu>, y <xref:System.Windows.Controls.ToolBar> clases.  Un elemento que es un ámbito de foco tiene <xref:System.Windows.Input.FocusManager.IsFocusScope%2A> establecido en `true`.  
  
 Puede haber varios elementos con el foco lógico, pero solo puede haber un elemento con el foco lógico dentro de un ámbito de foco único.  Un elemento con el foco lógico no tiene necesariamente el foco del teclado, pero un elemento con el foco de teclado tendrá el foco lógico.  Es posible definir un ámbito de foco dentro de un ámbito de foco.  En este caso, pueden tener el ámbito de foco primario y el ámbito de foco secundario un <xref:System.Windows.Input.FocusManager.FocusedElement%2A?displayProperty=nameWithType>.  
  
 El siguiente escenario muestra cómo cambian el foco de teclado y el foco lógico en una aplicación WPF que tiene un <xref:System.Windows.Window> con un <xref:System.Windows.Controls.TextBox> y un <xref:System.Windows.Controls.Menu> que tiene un <xref:System.Windows.Controls.MenuItem>.  Cuando cambie el foco del teclado de la <xref:System.Windows.Controls.TextBox> a la <xref:System.Windows.Controls.MenuItem>, el <xref:System.Windows.Controls.TextBox> el foco del teclado de pérdidas, pero conserva el foco lógico para el <xref:System.Windows.Window> centrarse ámbito.  El <xref:System.Windows.Controls.MenuItem> Obtiene el foco de teclado y obtiene el foco lógico para el <xref:System.Windows.Controls.Menu> centrarse ámbito.  Cuando se devuelve el foco del teclado a la raíz <xref:System.Windows.Window>, el elemento de <xref:System.Windows.Window> ámbito de foco con el foco lógico obtendrá foco del teclado, que en este caso es el <xref:System.Windows.Controls.TextBox>.  El <xref:System.Windows.Controls.TextBox> ahora tiene el foco del teclado y el foco lógico.  El <xref:System.Windows.Controls.MenuItem> pierde el foco de teclado, pero conserva el foco lógico para el <xref:System.Windows.Controls.Menu> centrarse ámbito.  
  
 El valor predeterminado de <xref:System.Windows.Input.FocusManager.IsFocusScope%2A> en un <xref:System.Windows.Window>, <xref:System.Windows.Controls.Menu>, <xref:System.Windows.Controls.ToolBar>, y <xref:System.Windows.Controls.ContextMenu> es `true`.  
  
 Para obtener más información acerca del foco, consulte el [Input Overview](~/docs/framework/wpf/advanced/input-overview.md) y [Focus Overview](~/docs/framework/wpf/advanced/focus-overview.md).  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName="AddGotFocusHandler">
      <MemberSignature Language="C#" Value="public static void AddGotFocusHandler (System.Windows.DependencyObject element, System.Windows.RoutedEventHandler handler);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void AddGotFocusHandler(class System.Windows.DependencyObject element, class System.Windows.RoutedEventHandler handler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Input.FocusManager.AddGotFocusHandler(System.Windows.DependencyObject,System.Windows.RoutedEventHandler)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub AddGotFocusHandler (element As DependencyObject, handler As RoutedEventHandler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void AddGotFocusHandler(System::Windows::DependencyObject ^ element, System::Windows::RoutedEventHandler ^ handler);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
        <Parameter Name="handler" Type="System.Windows.RoutedEventHandler" />
      </Parameters>
      <Docs>
        <param name="element">Objeto <see cref="T:System.Windows.UIElement" /> o <see cref="T:System.Windows.ContentElement" /> que escucha este evento.</param>
        <param name="handler">Controlador de eventos que se va a agregar.</param>
        <summary>Agrega un controlador para el evento adjunto <see cref="E:System.Windows.Input.FocusManager.GotFocus" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AddLostFocusHandler">
      <MemberSignature Language="C#" Value="public static void AddLostFocusHandler (System.Windows.DependencyObject element, System.Windows.RoutedEventHandler handler);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void AddLostFocusHandler(class System.Windows.DependencyObject element, class System.Windows.RoutedEventHandler handler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Input.FocusManager.AddLostFocusHandler(System.Windows.DependencyObject,System.Windows.RoutedEventHandler)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub AddLostFocusHandler (element As DependencyObject, handler As RoutedEventHandler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void AddLostFocusHandler(System::Windows::DependencyObject ^ element, System::Windows::RoutedEventHandler ^ handler);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
        <Parameter Name="handler" Type="System.Windows.RoutedEventHandler" />
      </Parameters>
      <Docs>
        <param name="element">Objeto <see cref="T:System.Windows.UIElement" /> o <see cref="T:System.Windows.ContentElement" /> que escucha este evento.</param>
        <param name="handler">Controlador de eventos que se va a agregar.</param>
        <summary>Agrega un controlador para el evento adjunto <see cref="E:System.Windows.Input.FocusManager.LostFocus" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="FocusedElement">
      <MemberSignature Language="C#" Value="see GetFocusedElement, and SetFocusedElement" />
      <MemberSignature Language="ILAsm" Value="see GetFocusedElement, and SetFocusedElement" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Input.FocusManager.FocusedElement" />
      <MemberSignature Language="VB.NET" Value="see GetFocusedElement, and SetFocusedElement" />
      <MemberType>AttachedProperty</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="FocusedElementProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty FocusedElementProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty FocusedElementProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Input.FocusManager.FocusedElementProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly FocusedElementProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ FocusedElementProperty;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifica la propiedad adjunta <see cref="P:System.Windows.Input.FocusManager.FocusedElement" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetFocusedElement">
      <MemberSignature Language="C#" Value="public static System.Windows.IInputElement GetFocusedElement (System.Windows.DependencyObject element);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.IInputElement GetFocusedElement(class System.Windows.DependencyObject element) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Input.FocusManager.GetFocusedElement(System.Windows.DependencyObject)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetFocusedElement (element As DependencyObject) As IInputElement" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::IInputElement ^ GetFocusedElement(System::Windows::DependencyObject ^ element);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.IInputElement</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
      </Parameters>
      <Docs>
        <param name="element">Elemento con el foco lógico en el ámbito de foco especificado.</param>
        <summary>Obtiene el elemento con el foco lógico dentro del ámbito de foco especificado.</summary>
        <returns>Elemento del ámbito de foco especificado con el foco lógico.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Windows.Input.FocusManager.FocusedElement%2A> es el elemento que tiene el foco lógico para un ámbito de foco concreto.  Este objeto puede o no puede tener el foco del teclado.  El foco de teclado hace referencia al elemento que recibe la entrada de teclado.  Para obtener más información sobre el foco, el foco del teclado y el foco lógico, consulte el [Input Overview](~/docs/framework/wpf/advanced/input-overview.md).  
  
 Si `element` no es un ámbito de foco, este método devolverá `null`.  
  
 Use <xref:System.Windows.Input.FocusManager.SetFocusedElement%2A>, para especificar el elemento con el foco lógico dentro de un ámbito de foco especificado.  
  
   
  
## Examples  
 En el ejemplo siguiente se establece el elemento con el foco lógico mediante el uso de la <xref:System.Windows.Input.FocusManager.SetFocusedElement%2A> y obtiene el elemento con el foco lógico mediante el <xref:System.Windows.Input.FocusManager.GetFocusedElement%2A>.  
  
 [!code-csharp[focussnippets#FocusGetSetFocusedElement](~/samples/snippets/csharp/VS_Snippets_Wpf/FocusSnippets/CSharp/Window1.xaml.cs#focusgetsetfocusedelement)]
 [!code-vb[focussnippets#FocusGetSetFocusedElement](~/samples/snippets/visualbasic/VS_Snippets_Wpf/FocusSnippets/visualbasic/window1.xaml.vb#focusgetsetfocusedelement)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="element" /> es <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetFocusScope">
      <MemberSignature Language="C#" Value="public static System.Windows.DependencyObject GetFocusScope (System.Windows.DependencyObject element);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.DependencyObject GetFocusScope(class System.Windows.DependencyObject element) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Input.FocusManager.GetFocusScope(System.Windows.DependencyObject)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetFocusScope (element As DependencyObject) As DependencyObject" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::DependencyObject ^ GetFocusScope(System::Windows::DependencyObject ^ element);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyObject</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
      </Parameters>
      <Docs>
        <param name="element">Elemento para el que se va a obtener el ámbito de foco más cercano.</param>
        <summary>Determina el antecesor más cercano del elemento especificado que tiene la propiedad <see cref="P:System.Windows.Input.FocusManager.IsFocusScope" /> establecida en <see langword="true" />.</summary>
        <returns>Ámbito del foco del elemento especificado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El valor predeterminado de <xref:System.Windows.Input.FocusManager.IsFocusScope%2A> en un <xref:System.Windows.Window>, <xref:System.Windows.Controls.Menu>, <xref:System.Windows.Controls.ToolBar>, <xref:System.Windows.Controls.ContextMenu> es `true`.  
  
 Un ámbito de foco es un elemento contenedor que realiza un seguimiento de los <xref:System.Windows.Input.FocusManager.FocusedElement%2A?displayProperty=nameWithType> dentro de su ámbito.  De forma predeterminada, el <xref:System.Windows.Window> clase es un ámbito de foco sea la <xref:System.Windows.Controls.Menu>, <xref:System.Windows.Controls.ContextMenu>, y <xref:System.Windows.Controls.ToolBar> clases.  Un elemento que es un ámbito de foco tiene <xref:System.Windows.Input.FocusManager.IsFocusScope%2A> establecido en `true`.  
  
 Para obtener más información sobre el foco, el foco del teclado y el foco lógico, consulte el [Input Overview](~/docs/framework/wpf/advanced/input-overview.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="element" /> es <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetIsFocusScope">
      <MemberSignature Language="C#" Value="public static bool GetIsFocusScope (System.Windows.DependencyObject element);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool GetIsFocusScope(class System.Windows.DependencyObject element) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Input.FocusManager.GetIsFocusScope(System.Windows.DependencyObject)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetIsFocusScope (element As DependencyObject) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool GetIsFocusScope(System::Windows::DependencyObject ^ element);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
      </Parameters>
      <Docs>
        <param name="element">Elemento del que se va a leer la propiedad adjunta.</param>
        <summary>Determina si el <see cref="T:System.Windows.DependencyObject" /> especificado es un ámbito de foco.</summary>
        <returns>
          Es <see langword="true" /> si la propiedad <see cref="P:System.Windows.Input.FocusManager.IsFocusScope" /> está establecida en <see langword="true" /> en el elemento especificado; de lo contrario, es <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un ámbito de foco es un elemento contenedor que realiza un seguimiento de los <xref:System.Windows.Input.FocusManager.FocusedElement%2A?displayProperty=nameWithType> dentro de su ámbito.  De forma predeterminada, el <xref:System.Windows.Window> clase es un ámbito de foco sea la <xref:System.Windows.Controls.Menu>, <xref:System.Windows.Controls.ContextMenu>, y <xref:System.Windows.Controls.ToolBar> clases.  Un elemento que es un ámbito de foco tiene <xref:System.Windows.Input.FocusManager.IsFocusScope%2A> establecido en `true`.  
  
 Para obtener más información sobre el foco, el foco del teclado y el foco lógico, consulte el [Input Overview](~/docs/framework/wpf/advanced/input-overview.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GotFocus">
      <MemberSignature Language="C#" Value="see AddGotFocusHandler, and RemoveGotFocusHandler" />
      <MemberSignature Language="ILAsm" Value="see AddGotFocusHandler, and RemoveGotFocusHandler" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Input.FocusManager.GotFocus" />
      <MemberSignature Language="VB.NET" Value="see AddGotFocusHandler, and RemoveGotFocusHandler" />
      <MemberType>AttachedEvent</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GotFocusEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent GotFocusEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent GotFocusEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Input.FocusManager.GotFocusEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly GotFocusEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ GotFocusEvent;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifica el evento adjunto <see cref="E:System.Windows.Input.FocusManager.GotFocus" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsFocusScope">
      <MemberSignature Language="C#" Value="see GetIsFocusScope, and SetIsFocusScope" />
      <MemberSignature Language="ILAsm" Value="see GetIsFocusScope, and SetIsFocusScope" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Input.FocusManager.IsFocusScope" />
      <MemberSignature Language="VB.NET" Value="see GetIsFocusScope, and SetIsFocusScope" />
      <MemberType>AttachedProperty</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsFocusScopeProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty IsFocusScopeProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty IsFocusScopeProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Input.FocusManager.IsFocusScopeProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly IsFocusScopeProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ IsFocusScopeProperty;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifica la propiedad adjunta <see cref="P:System.Windows.Input.FocusManager.IsFocusScope" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El valor predeterminado de <xref:System.Windows.Input.FocusManager.IsFocusScope%2A> en un <xref:System.Windows.Window>, <xref:System.Windows.Controls.Menu>, <xref:System.Windows.Controls.ToolBar>, <xref:System.Windows.Controls.ContextMenu> es `true`.  
  
 Un ámbito de foco es un elemento contenedor que realiza un seguimiento de los <xref:System.Windows.Input.FocusManager.FocusedElement%2A?displayProperty=nameWithType> dentro de su ámbito.  De forma predeterminada, el <xref:System.Windows.Window> clase es un ámbito de foco sea la <xref:System.Windows.Controls.Menu>, <xref:System.Windows.Controls.ContextMenu>, y <xref:System.Windows.Controls.ToolBar> clases.  Un elemento que es un ámbito de foco tiene <xref:System.Windows.Input.FocusManager.IsFocusScope%2A> establecido en `true`.  
  
 Para obtener más información sobre el foco, el foco del teclado y el foco lógico, consulte el [Input Overview](~/docs/framework/wpf/advanced/input-overview.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LostFocus">
      <MemberSignature Language="C#" Value="see AddLostFocusHandler, and RemoveLostFocusHandler" />
      <MemberSignature Language="ILAsm" Value="see AddLostFocusHandler, and RemoveLostFocusHandler" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Input.FocusManager.LostFocus" />
      <MemberSignature Language="VB.NET" Value="see AddLostFocusHandler, and RemoveLostFocusHandler" />
      <MemberType>AttachedEvent</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="LostFocusEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent LostFocusEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent LostFocusEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Input.FocusManager.LostFocusEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly LostFocusEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ LostFocusEvent;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifica el evento adjunto <see cref="E:System.Windows.Input.FocusManager.LostFocus" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RemoveGotFocusHandler">
      <MemberSignature Language="C#" Value="public static void RemoveGotFocusHandler (System.Windows.DependencyObject element, System.Windows.RoutedEventHandler handler);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RemoveGotFocusHandler(class System.Windows.DependencyObject element, class System.Windows.RoutedEventHandler handler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Input.FocusManager.RemoveGotFocusHandler(System.Windows.DependencyObject,System.Windows.RoutedEventHandler)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RemoveGotFocusHandler (element As DependencyObject, handler As RoutedEventHandler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RemoveGotFocusHandler(System::Windows::DependencyObject ^ element, System::Windows::RoutedEventHandler ^ handler);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
        <Parameter Name="handler" Type="System.Windows.RoutedEventHandler" />
      </Parameters>
      <Docs>
        <param name="element">Objeto <see cref="T:System.Windows.UIElement" /> o <see cref="T:System.Windows.ContentElement" /> que escucha este evento.</param>
        <param name="handler">Controlador de eventos que se va a quitar.</param>
        <summary>Quita un controlador del evento adjunto <see cref="E:System.Windows.Input.FocusManager.GotFocus" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RemoveLostFocusHandler">
      <MemberSignature Language="C#" Value="public static void RemoveLostFocusHandler (System.Windows.DependencyObject element, System.Windows.RoutedEventHandler handler);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RemoveLostFocusHandler(class System.Windows.DependencyObject element, class System.Windows.RoutedEventHandler handler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Input.FocusManager.RemoveLostFocusHandler(System.Windows.DependencyObject,System.Windows.RoutedEventHandler)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RemoveLostFocusHandler (element As DependencyObject, handler As RoutedEventHandler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RemoveLostFocusHandler(System::Windows::DependencyObject ^ element, System::Windows::RoutedEventHandler ^ handler);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
        <Parameter Name="handler" Type="System.Windows.RoutedEventHandler" />
      </Parameters>
      <Docs>
        <param name="element">Objeto <see cref="T:System.Windows.UIElement" /> o <see cref="T:System.Windows.ContentElement" /> que escucha este evento.</param>
        <param name="handler">Controlador de eventos que se va a quitar.</param>
        <summary>Quita un controlador del evento adjunto <see cref="E:System.Windows.Input.FocusManager.LostFocus" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SetFocusedElement">
      <MemberSignature Language="C#" Value="public static void SetFocusedElement (System.Windows.DependencyObject element, System.Windows.IInputElement value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetFocusedElement(class System.Windows.DependencyObject element, class System.Windows.IInputElement value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Input.FocusManager.SetFocusedElement(System.Windows.DependencyObject,System.Windows.IInputElement)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetFocusedElement (element As DependencyObject, value As IInputElement)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetFocusedElement(System::Windows::DependencyObject ^ element, System::Windows::IInputElement ^ value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
        <Parameter Name="value" Type="System.Windows.IInputElement" />
      </Parameters>
      <Docs>
        <param name="element">Ámbito del foco en el que el elemento especificado se va a convertir en <see cref="P:System.Windows.Input.FocusManager.FocusedElement" />.</param>
        <param name="value">Elemento al que se va a dar el foco lógico.</param>
        <summary>Establece el foco lógico en el elemento especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Windows.Input.FocusManager.FocusedElement%2A> es el elemento que tiene el foco lógico para el ámbito de foco concreto.  Este objeto puede o no puede tener el foco del teclado.  El foco de teclado hace referencia al elemento que recibe la entrada de teclado.  Para obtener más información sobre el foco, el foco del teclado y el foco lógico, consulte el [Input Overview](~/docs/framework/wpf/advanced/input-overview.md).  
  
 Es posible especificar un ámbito de foco es un antecesor del elemento está en el ámbito de foco.  Por ejemplo, si un <xref:System.Windows.Controls.StackPanel> es un ámbito de foco y su elemento primario <xref:System.Windows.Window> es un ámbito de foco, un <xref:System.Windows.Controls.TextBox> elemento secundario de la <xref:System.Windows.Controls.StackPanel> podría especificar el <xref:System.Windows.Window> como el ámbito de foco al llamar a <xref:System.Windows.Input.FocusManager.SetFocusedElement%2A>.  El <xref:System.Windows.Controls.TextBox> es, a continuación, <xref:System.Windows.Input.FocusManager.FocusedElement%2A> tanto para el <xref:System.Windows.Window> centrarse ámbito y el <xref:System.Windows.Controls.StackPanel> centrarse ámbito.  
  
 <xref:System.Windows.Input.FocusManager.SetFocusedElement%2A> le dará el foco lógico al elemento especificado en el ámbito de foco especificado e intentará a dar el foco de teclado del elemento.  
  
   
  
## Examples  
 En el ejemplo siguiente se establece el elemento con el foco lógico mediante el uso de la <xref:System.Windows.Input.FocusManager.SetFocusedElement%2A> y obtiene el elemento con el foco lógico mediante el <xref:System.Windows.Input.FocusManager.GetFocusedElement%2A>.  
  
 [!code-csharp[focussnippets#FocusGetSetFocusedElement](~/samples/snippets/csharp/VS_Snippets_Wpf/FocusSnippets/CSharp/Window1.xaml.cs#focusgetsetfocusedelement)]
 [!code-vb[focussnippets#FocusGetSetFocusedElement](~/samples/snippets/visualbasic/VS_Snippets_Wpf/FocusSnippets/visualbasic/window1.xaml.vb#focusgetsetfocusedelement)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetIsFocusScope">
      <MemberSignature Language="C#" Value="public static void SetIsFocusScope (System.Windows.DependencyObject element, bool value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetIsFocusScope(class System.Windows.DependencyObject element, bool value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Input.FocusManager.SetIsFocusScope(System.Windows.DependencyObject,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetIsFocusScope (element As DependencyObject, value As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetIsFocusScope(System::Windows::DependencyObject ^ element, bool value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
        <Parameter Name="value" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="element">Elemento que se va a convertir en un ámbito de foco.</param>
        <param name="value">
          Es <see langword="true" /> si <c>element</c> es un ámbito de foco; de lo contrario, es <see langword="false" />.</param>
        <summary>Establece el <see cref="T:System.Windows.DependencyObject" /> especificado como un ámbito de foco.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un ámbito de foco es un elemento contenedor que realiza un seguimiento de los <xref:System.Windows.Input.FocusManager.FocusedElement%2A?displayProperty=nameWithType> dentro de su ámbito.  De forma predeterminada, el <xref:System.Windows.Window> clase es un ámbito de foco sea la <xref:System.Windows.Controls.Menu>, <xref:System.Windows.Controls.ContextMenu>, y <xref:System.Windows.Controls.ToolBar> clases.  Un elemento que es un ámbito de foco tiene <xref:System.Windows.Input.FocusManager.IsFocusScope%2A> establecido en `true`.  
  
 Para obtener más información sobre el foco, el foco del teclado y el foco lógico, consulte el [Input Overview](~/docs/framework/wpf/advanced/input-overview.md).  
  
   
  
## Examples  
 El ejemplo siguiente convierte un elemento en un ámbito de foco utilizando <xref:System.Windows.Input.FocusManager.SetIsFocusScope%2A>.  
  
 [!code-csharp[focussnippets#FocusSetIsFocusScope](~/samples/snippets/csharp/VS_Snippets_Wpf/FocusSnippets/CSharp/Window1.xaml.cs#focussetisfocusscope)]
 [!code-vb[focussnippets#FocusSetIsFocusScope](~/samples/snippets/visualbasic/VS_Snippets_Wpf/FocusSnippets/visualbasic/window1.xaml.vb#focussetisfocusscope)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>