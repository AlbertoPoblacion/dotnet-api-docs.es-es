<Type Name="XPathMessageFilterTable&lt;TFilterData&gt;" FullName="System.ServiceModel.Dispatcher.XPathMessageFilterTable&lt;TFilterData&gt;">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="a5b9830e3a9e8ccd62b29feada9a85728203f121" />
    <Meta Name="ms.sourcegitcommit" Value="723b8a6d92667ba86fcda96190bad3b4a03283b3" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="es-ES" />
    <Meta Name="ms.lasthandoff" Value="11/09/2018" />
    <Meta Name="ms.locfileid" Value="51324988" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class XPathMessageFilterTable&lt;TFilterData&gt; : System.Collections.Generic.ICollection&lt;System.Collections.Generic.KeyValuePair&lt;System.ServiceModel.Dispatcher.MessageFilter,TFilterData&gt;&gt;, System.Collections.Generic.IDictionary&lt;System.ServiceModel.Dispatcher.MessageFilter,TFilterData&gt;, System.Collections.Generic.IEnumerable&lt;System.Collections.Generic.KeyValuePair&lt;System.ServiceModel.Dispatcher.MessageFilter,TFilterData&gt;&gt;, System.ServiceModel.Dispatcher.IMessageFilterTable&lt;TFilterData&gt;" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit XPathMessageFilterTable`1&lt;TFilterData&gt; extends System.Object implements class System.Collections.Generic.ICollection`1&lt;valuetype System.Collections.Generic.KeyValuePair`2&lt;class System.ServiceModel.Dispatcher.MessageFilter, !TFilterData&gt;&gt;, class System.Collections.Generic.IDictionary`2&lt;class System.ServiceModel.Dispatcher.MessageFilter, !TFilterData&gt;, class System.Collections.Generic.IEnumerable`1&lt;valuetype System.Collections.Generic.KeyValuePair`2&lt;class System.ServiceModel.Dispatcher.MessageFilter, !TFilterData&gt;&gt;, class System.Collections.IEnumerable, class System.ServiceModel.Dispatcher.IMessageFilterTable`1&lt;!TFilterData&gt;" />
  <TypeSignature Language="DocId" Value="T:System.ServiceModel.Dispatcher.XPathMessageFilterTable`1" />
  <TypeSignature Language="VB.NET" Value="Public Class XPathMessageFilterTable(Of TFilterData)&#xA;Implements ICollection(Of KeyValuePair(Of MessageFilter, TFilterData)), IDictionary(Of MessageFilter, TFilterData), IEnumerable(Of KeyValuePair(Of MessageFilter, TFilterData)), IMessageFilterTable(Of TFilterData)" />
  <TypeSignature Language="C++ CLI" Value="generic &lt;typename TFilterData&gt;&#xA;public ref class XPathMessageFilterTable : System::Collections::Generic::ICollection&lt;System::Collections::Generic::KeyValuePair&lt;System::ServiceModel::Dispatcher::MessageFilter ^, TFilterData&gt;&gt;, System::Collections::Generic::IDictionary&lt;System::ServiceModel::Dispatcher::MessageFilter ^, TFilterData&gt;, System::Collections::Generic::IEnumerable&lt;System::Collections::Generic::KeyValuePair&lt;System::ServiceModel::Dispatcher::MessageFilter ^, TFilterData&gt;&gt;, System::ServiceModel::Dispatcher::IMessageFilterTable&lt;TFilterData&gt;" />
  <TypeSignature Language="F#" Value="type XPathMessageFilterTable&lt;'FilterData&gt; = class&#xA;    interface IMessageFilterTable&lt;'FilterData&gt;&#xA;    interface IDictionary&lt;MessageFilter, 'FilterData&gt;&#xA;    interface ICollection&lt;KeyValuePair&lt;MessageFilter, 'FilterData&gt;&gt;&#xA;    interface seq&lt;KeyValuePair&lt;MessageFilter, 'FilterData&gt;&gt;&#xA;    interface IEnumerable" />
  <AssemblyInfo>
    <AssemblyName>System.ServiceModel</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <TypeParameters>
    <TypeParameter Name="TFilterData" />
  </TypeParameters>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Collections.Generic.ICollection&lt;System.Collections.Generic.KeyValuePair&lt;System.ServiceModel.Dispatcher.MessageFilter,TFilterData&gt;&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.Generic.ICollection&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.Generic.IDictionary&lt;System.ServiceModel.Dispatcher.MessageFilter,TFilterData&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.Generic.IEnumerable&lt;System.Collections.Generic.KeyValuePair&lt;System.ServiceModel.Dispatcher.MessageFilter,TFilterData&gt;&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.Generic.IEnumerable&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.Generic.IEnumerable&lt;T&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.IEnumerable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.ServiceModel.Dispatcher.IMessageFilterTable&lt;TFilterData&gt;</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
      <AttributeName>System.Runtime.Serialization.DataContract</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <typeparam name="TFilterData">Tipo de datos de filtro asociados a cada filtro de la tabla.</typeparam>
    <summary>Contiene una colección de pares de filtro/datos para una coincidencia eficaz.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.ServiceModel.Dispatcher.XPathMessageFilterTable%601> implementa la interfaz <xref:System.ServiceModel.Dispatcher.IMessageFilterTable%601>. Esta tabla de filtro está optimizada para los filtros de XPath declarativos, por lo que la clave de la tabla es <xref:System.ServiceModel.Dispatcher.XPathMessageFilter>.  
  
 La clase <xref:System.ServiceModel.Dispatcher.XPathMessageFilterTable%601> optimiza la coincidencia para un subconjunto de XPath que cubre la mayoría de los escenarios de mensajería y también admite la gramática completa de XPath 1.0. Ha optimizado los algoritmos para una coincidencia paralela eficaz.  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.ServiceModel.Dispatcher.XPathMessageFilterTable`1" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public XPathMessageFilterTable ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Dispatcher.XPathMessageFilterTable`1.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; XPathMessageFilterTable();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.ServiceModel.Dispatcher.XPathMessageFilterTable`1" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public XPathMessageFilterTable (int capacity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 capacity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Dispatcher.XPathMessageFilterTable`1.#ctor(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (capacity As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; XPathMessageFilterTable(int capacity);" />
      <MemberSignature Language="F#" Value="new System.ServiceModel.Dispatcher.XPathMessageFilterTable&lt;'FilterData&gt; : int -&gt; System.ServiceModel.Dispatcher.XPathMessageFilterTable&lt;'FilterData&gt;" Usage="new System.ServiceModel.Dispatcher.XPathMessageFilterTable&lt;'FilterData&gt; capacity" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="capacity" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="capacity">Capacidad inicial de la tabla.</param>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.ServiceModel.Dispatcher.XPathMessageFilterTable`1" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Add">
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Agrega <see cref="T:System.ServiceModel.Dispatcher.XPathMessageFilter" /> y su <paramref name="FilterData" /> asociado a <see cref="T:System.ServiceModel.Dispatcher.XPathMessageFilterTable`1" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public void Add (System.Collections.Generic.KeyValuePair&lt;System.ServiceModel.Dispatcher.MessageFilter,TFilterData&gt; item);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Add(valuetype System.Collections.Generic.KeyValuePair`2&lt;class System.ServiceModel.Dispatcher.MessageFilter, !TFilterData&gt; item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Dispatcher.XPathMessageFilterTable`1.Add(System.Collections.Generic.KeyValuePair{System.ServiceModel.Dispatcher.MessageFilter,`0})" />
      <MemberSignature Language="VB.NET" Value="Public Sub Add (item As KeyValuePair(Of MessageFilter, TFilterData))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Add(System::Collections::Generic::KeyValuePair&lt;System::ServiceModel::Dispatcher::MessageFilter ^, TFilterData&gt; item);" />
      <MemberSignature Language="F#" Value="abstract member Add : System.Collections.Generic.KeyValuePair&lt;System.ServiceModel.Dispatcher.MessageFilter, 'FilterData&gt; -&gt; unit&#xA;override this.Add : System.Collections.Generic.KeyValuePair&lt;System.ServiceModel.Dispatcher.MessageFilter, 'FilterData&gt; -&gt; unit" Usage="xPathMessageFilterTable.Add item" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.ICollection`1.Add(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="System.Collections.Generic.KeyValuePair&lt;System.ServiceModel.Dispatcher.MessageFilter,TFilterData&gt;" />
      </Parameters>
      <Docs>
        <param name="item">El <see cref="T:System.Collections.Generic.KeyValuePair`2" /> &lt;Filter, <c>FilterData</c>&gt; que agregar a la tabla.</param>
        <summary>Agrega un par filtro/<paramref name="FilterData" /> (clave-valor) a <see cref="T:System.ServiceModel.Dispatcher.XPathMessageFilterTable`1" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método implementa el método <xref:System.Collections.Generic.ICollection%601.Add%2A> de la clase <xref:System.Collections.Generic.ICollection%601>.  La conversión implícita del parámetro `filter` del tipo <xref:System.ServiceModel.Dispatcher.MessageFilter> al tipo <xref:System.ServiceModel.Dispatcher.XPathMessageFilter> se puede evitar utilizando la sobrecarga fuertemente tipada, <xref:System.ServiceModel.Dispatcher.XPathMessageFilterTable%601.Add%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El valor de <paramref name="filter" /> es <see langword="null" />.</exception>
        <exception cref="T:System.Xml.XPath.XPathException">Se ha producido un error del compilador.</exception>
      </Docs>
    </Member>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public void Add (System.ServiceModel.Dispatcher.MessageFilter filter, TFilterData data);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Add(class System.ServiceModel.Dispatcher.MessageFilter filter, !TFilterData data) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Dispatcher.XPathMessageFilterTable`1.Add(System.ServiceModel.Dispatcher.MessageFilter,`0)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Add (filter As MessageFilter, data As TFilterData)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Add(System::ServiceModel::Dispatcher::MessageFilter ^ filter, TFilterData data);" />
      <MemberSignature Language="F#" Value="abstract member Add : System.ServiceModel.Dispatcher.MessageFilter * 'FilterData -&gt; unit&#xA;override this.Add : System.ServiceModel.Dispatcher.MessageFilter * 'FilterData -&gt; unit" Usage="xPathMessageFilterTable.Add (filter, data)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.IDictionary`2.Add(`0,`1)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="filter" Type="System.ServiceModel.Dispatcher.MessageFilter" />
        <Parameter Name="data" Type="TFilterData" />
      </Parameters>
      <Docs>
        <param name="filter">El <see cref="T:System.ServiceModel.Dispatcher.MessageFilter" /> que se utiliza como clave del par agregado. Debe ser una instancia de <see cref="T:System.ServiceModel.Dispatcher.XPathMessageFilter" />.</param>
        <param name="data">
          <c>FilterData</c> asociado al filtro usado como valor del par agregado.</param>
        <summary>Agrega un par filtro/datos a la tabla de filtro.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La conversión interna del parámetro `filter` del tipo <xref:System.ServiceModel.Dispatcher.MessageFilter> al tipo <xref:System.ServiceModel.Dispatcher.XPathMessageFilter> se puede evitar utilizando la sobrecarga fuertemente tipada, <xref:System.ServiceModel.Dispatcher.XPathMessageFilterTable%601.Add%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El valor de <paramref name="filter" /> es <see langword="null" />.</exception>
        <exception cref="T:System.InvalidCastException">
          <paramref name="filter" /> no es un objeto <see cref="T:System.ServiceModel.Dispatcher.XPathMessageFilter" />.</exception>
        <exception cref="T:System.Xml.XPath.XPathException">Se ha producido un error del compilador.</exception>
      </Docs>
    </Member>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public void Add (System.ServiceModel.Dispatcher.XPathMessageFilter filter, TFilterData data);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Add(class System.ServiceModel.Dispatcher.XPathMessageFilter filter, !TFilterData data) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Dispatcher.XPathMessageFilterTable`1.Add(System.ServiceModel.Dispatcher.XPathMessageFilter,`0)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Add (filter As XPathMessageFilter, data As TFilterData)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Add(System::ServiceModel::Dispatcher::XPathMessageFilter ^ filter, TFilterData data);" />
      <MemberSignature Language="F#" Value="member this.Add : System.ServiceModel.Dispatcher.XPathMessageFilter * 'FilterData -&gt; unit" Usage="xPathMessageFilterTable.Add (filter, data)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="filter" Type="System.ServiceModel.Dispatcher.XPathMessageFilter" />
        <Parameter Name="data" Type="TFilterData" />
      </Parameters>
      <Docs>
        <param name="filter">El <see cref="T:System.ServiceModel.Dispatcher.XPathMessageFilter" /> que se utiliza como clave del par agregado.</param>
        <param name="data">
          <c>FilterData</c> asociado al filtro; usado como valor del par agregado.</param>
        <summary>Agrega un par filtro/datos a la tabla de filtro.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esto proporciona una sobrecarga fuertemente tipada para agregar un <xref:System.ServiceModel.Dispatcher.XPathMessageFilter> a la tabla de filtros que funciona mejor que la sobrecarga con tipos débiles porque evita la conversión implícita del parámetro `filter` del tipo <xref:System.ServiceModel.Dispatcher.MessageFilter> al tipo <xref:System.ServiceModel.Dispatcher.XPathMessageFilter>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El valor de <paramref name="filter" /> es <see langword="null" />.</exception>
        <exception cref="T:System.Xml.XPath.XPathException">Se ha producido un error del compilador.</exception>
      </Docs>
    </Member>
    <Member MemberName="Clear">
      <MemberSignature Language="C#" Value="public void Clear ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Clear() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Dispatcher.XPathMessageFilterTable`1.Clear" />
      <MemberSignature Language="VB.NET" Value="Public Sub Clear ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Clear();" />
      <MemberSignature Language="F#" Value="abstract member Clear : unit -&gt; unit&#xA;override this.Clear : unit -&gt; unit" Usage="xPathMessageFilterTable.Clear " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.ICollection`1.Clear</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Quita todos los pares de filtro/datos de la tabla de filtro.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Contains">
      <MemberSignature Language="C#" Value="public bool Contains (System.Collections.Generic.KeyValuePair&lt;System.ServiceModel.Dispatcher.MessageFilter,TFilterData&gt; item);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Contains(valuetype System.Collections.Generic.KeyValuePair`2&lt;class System.ServiceModel.Dispatcher.MessageFilter, !TFilterData&gt; item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Dispatcher.XPathMessageFilterTable`1.Contains(System.Collections.Generic.KeyValuePair{System.ServiceModel.Dispatcher.MessageFilter,`0})" />
      <MemberSignature Language="VB.NET" Value="Public Function Contains (item As KeyValuePair(Of MessageFilter, TFilterData)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Contains(System::Collections::Generic::KeyValuePair&lt;System::ServiceModel::Dispatcher::MessageFilter ^, TFilterData&gt; item);" />
      <MemberSignature Language="F#" Value="abstract member Contains : System.Collections.Generic.KeyValuePair&lt;System.ServiceModel.Dispatcher.MessageFilter, 'FilterData&gt; -&gt; bool&#xA;override this.Contains : System.Collections.Generic.KeyValuePair&lt;System.ServiceModel.Dispatcher.MessageFilter, 'FilterData&gt; -&gt; bool" Usage="xPathMessageFilterTable.Contains item" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.ICollection`1.Contains(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="System.Collections.Generic.KeyValuePair&lt;System.ServiceModel.Dispatcher.MessageFilter,TFilterData&gt;" />
      </Parameters>
      <Docs>
        <param name="item">El <see cref="T:System.Collections.Generic.KeyValuePair`2" /> &lt;<see cref="T:System.ServiceModel.Dispatcher.MessageFilter" />, <c>FilterData</c>&gt; que encontrar en la tabla.</param>
        <summary>Determina si la tabla de filtro contiene un filtro especificado y su <paramref name="FilterData" /> asociado.</summary>
        <returns>
          <see langword="true" /> si el par Filter/*FilterData* está contenido en la tabla de filtro; en caso contrario <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método devuelve `false` si el filtro se encuentra pero corresponde a datos diferentes.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ContainsKey">
      <MemberSignature Language="C#" Value="public bool ContainsKey (System.ServiceModel.Dispatcher.MessageFilter filter);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool ContainsKey(class System.ServiceModel.Dispatcher.MessageFilter filter) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Dispatcher.XPathMessageFilterTable`1.ContainsKey(System.ServiceModel.Dispatcher.MessageFilter)" />
      <MemberSignature Language="VB.NET" Value="Public Function ContainsKey (filter As MessageFilter) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool ContainsKey(System::ServiceModel::Dispatcher::MessageFilter ^ filter);" />
      <MemberSignature Language="F#" Value="abstract member ContainsKey : System.ServiceModel.Dispatcher.MessageFilter -&gt; bool&#xA;override this.ContainsKey : System.ServiceModel.Dispatcher.MessageFilter -&gt; bool" Usage="xPathMessageFilterTable.ContainsKey filter" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.IDictionary`2.ContainsKey(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="filter" Type="System.ServiceModel.Dispatcher.MessageFilter" />
      </Parameters>
      <Docs>
        <param name="filter">
          <see cref="T:System.ServiceModel.Dispatcher.MessageFilter" /> que se busca.</param>
        <summary>Determina si la tabla de filtro contiene un filtro especificado.</summary>
        <returns>
          <see langword="true" /> si el <paramref name="filter" /> está contenido en la tabla de filtro; de lo contrario <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método implementa el método `ContainsKey` de <xref:System.Collections.Generic.IDictionary%602>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public void CopyTo (System.Collections.Generic.KeyValuePair&lt;System.ServiceModel.Dispatcher.MessageFilter,TFilterData&gt;[] array, int arrayIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void CopyTo(valuetype System.Collections.Generic.KeyValuePair`2&lt;class System.ServiceModel.Dispatcher.MessageFilter, !TFilterData&gt;[] array, int32 arrayIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Dispatcher.XPathMessageFilterTable`1.CopyTo(System.Collections.Generic.KeyValuePair{System.ServiceModel.Dispatcher.MessageFilter,`0}[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub CopyTo (array As KeyValuePair(Of MessageFilter, TFilterData)(), arrayIndex As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void CopyTo(cli::array &lt;System::Collections::Generic::KeyValuePair&lt;System::ServiceModel::Dispatcher::MessageFilter ^, TFilterData&gt;&gt; ^ array, int arrayIndex);" />
      <MemberSignature Language="F#" Value="abstract member CopyTo : System.Collections.Generic.KeyValuePair&lt;System.ServiceModel.Dispatcher.MessageFilter, 'FilterData&gt;[] * int -&gt; unit&#xA;override this.CopyTo : System.Collections.Generic.KeyValuePair&lt;System.ServiceModel.Dispatcher.MessageFilter, 'FilterData&gt;[] * int -&gt; unit" Usage="xPathMessageFilterTable.CopyTo (array, arrayIndex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Collections.Generic.KeyValuePair&lt;System.ServiceModel.Dispatcher.MessageFilter,TFilterData&gt;[]" />
        <Parameter Name="arrayIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">Matriz de tipo <see cref="T:System.Collections.Generic.KeyValuePair`2" /> &lt;Filter, <c>FilterData</c>&gt; en la que se copian los pares.</param>
        <param name="arrayIndex">Índice en el que se va a empezar a copiar.</param>
        <summary>Copia los pares de filtro/<paramref name="FilterData" /> en una matriz que se inicia en un índice especificado.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Count">
      <MemberSignature Language="C#" Value="public int Count { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Count" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.Dispatcher.XPathMessageFilterTable`1.Count" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Count As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Count { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Count : int" Usage="System.ServiceModel.Dispatcher.XPathMessageFilterTable&lt;'FilterData&gt;.Count" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.Generic.ICollection`1.Count</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene el número de pares de filtro/datos que hay actualmente en la tabla de filtro.</summary>
        <value>Número de pares de filtro/datos que hay actualmente en la tabla de filtro.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetEnumerator">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerator&lt;System.Collections.Generic.KeyValuePair&lt;System.ServiceModel.Dispatcher.MessageFilter,TFilterData&gt;&gt; GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.Generic.IEnumerator`1&lt;valuetype System.Collections.Generic.KeyValuePair`2&lt;class System.ServiceModel.Dispatcher.MessageFilter, !TFilterData&gt;&gt; GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Dispatcher.XPathMessageFilterTable`1.GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Public Function GetEnumerator () As IEnumerator(Of KeyValuePair(Of MessageFilter, TFilterData))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Collections::Generic::IEnumerator&lt;System::Collections::Generic::KeyValuePair&lt;System::ServiceModel::Dispatcher::MessageFilter ^, TFilterData&gt;&gt; ^ GetEnumerator();" />
      <MemberSignature Language="F#" Value="abstract member GetEnumerator : unit -&gt; System.Collections.Generic.IEnumerator&lt;System.Collections.Generic.KeyValuePair&lt;System.ServiceModel.Dispatcher.MessageFilter, 'FilterData&gt;&gt;&#xA;override this.GetEnumerator : unit -&gt; System.Collections.Generic.IEnumerator&lt;System.Collections.Generic.KeyValuePair&lt;System.ServiceModel.Dispatcher.MessageFilter, 'FilterData&gt;&gt;" Usage="xPathMessageFilterTable.GetEnumerator " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.IEnumerable`1.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerator&lt;System.Collections.Generic.KeyValuePair&lt;System.ServiceModel.Dispatcher.MessageFilter,TFilterData&gt;&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Devuelve un enumerador que puede recorrer en iteración la tabla de filtros.</summary>
        <returns>Un <see cref="T:System.Collections.Generic.IEnumerator`1" />&lt;KeyValuePair&lt;Filter, FilterData&gt;&gt; que se puede usar para iterar en la tabla de filtros.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método implementa <xref:System.Collections.Generic.SynchronizedCollection%601.GetEnumerator%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetMatchingFilter">
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Devuelve un valor que indica si el mensaje especificado o el mensaje almacenado en búfer satisface el criterio de coincidencia de un filtro de la tabla exactamente y devuelve ese filtro en un parámetro <see langword="out" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Prueba si un mensaje satisface exactamente uno de los filtros de la tabla de filtros.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetMatchingFilter">
      <MemberSignature Language="C#" Value="public bool GetMatchingFilter (System.ServiceModel.Channels.Message message, out System.ServiceModel.Dispatcher.MessageFilter filter);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool GetMatchingFilter(class System.ServiceModel.Channels.Message message, [out] class System.ServiceModel.Dispatcher.MessageFilter&amp; filter) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Dispatcher.XPathMessageFilterTable`1.GetMatchingFilter(System.ServiceModel.Channels.Message,System.ServiceModel.Dispatcher.MessageFilter@)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool GetMatchingFilter(System::ServiceModel::Channels::Message ^ message, [Runtime::InteropServices::Out] System::ServiceModel::Dispatcher::MessageFilter ^ % filter);" />
      <MemberSignature Language="F#" Value="abstract member GetMatchingFilter : System.ServiceModel.Channels.Message *  -&gt; bool&#xA;override this.GetMatchingFilter : System.ServiceModel.Channels.Message *  -&gt; bool" Usage="xPathMessageFilterTable.GetMatchingFilter (message, filter)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ServiceModel.Dispatcher.IMessageFilterTable`1.GetMatchingFilter(System.ServiceModel.Channels.Message,System.ServiceModel.Dispatcher.MessageFilter@)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="message" Type="System.ServiceModel.Channels.Message" />
        <Parameter Name="filter" Type="System.ServiceModel.Dispatcher.MessageFilter" RefType="out" />
      </Parameters>
      <Docs>
        <param name="message">
          <see cref="T:System.ServiceModel.Channels.Message" /> que se va a probar.</param>
        <param name="filter">Parámetro <see langword="out" /> que almacena el filtro que <c>message</c> satisface. Si no se encuentra ningún filtro, el parámetro se establece en su valor predeterminado.</param>
        <summary>Devuelve un valor que indica si el mensaje especificado satisface el criterio de coincidencia de un filtro de la tabla exactamente y devuelve ese filtro en un parámetro <see langword="out" />.</summary>
        <returns>
          <see cref="T:System.ServiceModel.Dispatcher.MessageFilter" /> cuyos criterios de búsqueda satisface el mensaje; o <see langword="null" /> si no se encuentra ningún filtro que coincida.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use este método cuando se espera que un filtro único coincida con el mensaje y se requiere el filtro coincidente.  
  
 Este método comprueba una coincidencia de filtro única en el depósito de filtros de prioridad máxima. Los filtros de la tabla no pueden inspeccionar el cuerpo del mensaje.  
  
 Si se espera que más de un filtro coincida con el mensaje, utilice <xref:System.ServiceModel.Dispatcher.XPathMessageFilterTable%601.GetMatchingFilters%2A>.  
  
 Este método implementa <xref:System.ServiceModel.Dispatcher.IMessageFilterTable%601.GetMatchingFilter%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El valor de <paramref name="message" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ServiceModel.Dispatcher.MultipleFilterMatchesException">Más de un filtro coincide con el <paramref name="message" />.</exception>
        <exception cref="T:System.ServiceModel.Dispatcher.InvalidBodyAccessException">Un filtro intentó examinar el contenido del cuerpo del mensaje.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetMatchingFilter">
      <MemberSignature Language="C#" Value="public bool GetMatchingFilter (System.ServiceModel.Channels.MessageBuffer messageBuffer, out System.ServiceModel.Dispatcher.MessageFilter filter);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool GetMatchingFilter(class System.ServiceModel.Channels.MessageBuffer messageBuffer, [out] class System.ServiceModel.Dispatcher.MessageFilter&amp; filter) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Dispatcher.XPathMessageFilterTable`1.GetMatchingFilter(System.ServiceModel.Channels.MessageBuffer,System.ServiceModel.Dispatcher.MessageFilter@)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool GetMatchingFilter(System::ServiceModel::Channels::MessageBuffer ^ messageBuffer, [Runtime::InteropServices::Out] System::ServiceModel::Dispatcher::MessageFilter ^ % filter);" />
      <MemberSignature Language="F#" Value="abstract member GetMatchingFilter : System.ServiceModel.Channels.MessageBuffer *  -&gt; bool&#xA;override this.GetMatchingFilter : System.ServiceModel.Channels.MessageBuffer *  -&gt; bool" Usage="xPathMessageFilterTable.GetMatchingFilter (messageBuffer, filter)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ServiceModel.Dispatcher.IMessageFilterTable`1.GetMatchingFilter(System.ServiceModel.Channels.MessageBuffer,System.ServiceModel.Dispatcher.MessageFilter@)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="messageBuffer" Type="System.ServiceModel.Channels.MessageBuffer" />
        <Parameter Name="filter" Type="System.ServiceModel.Dispatcher.MessageFilter" RefType="out" />
      </Parameters>
      <Docs>
        <param name="messageBuffer">
          <see cref="T:System.ServiceModel.Channels.MessageBuffer" /> que se va a probar.</param>
        <param name="filter">Parámetro <see langword="out" /> que almacena el filtro que <c>message</c> satisface. Si no se encuentra ningún filtro, el parámetro se establece en su valor predeterminado.</param>
        <summary>Devuelve un valor que indica si el mensaje especificado o el mensaje almacenado en búfer satisface el criterio de coincidencia de un filtro de la tabla exactamente y devuelve ese filtro en un parámetro <see langword="out" />.</summary>
        <returns>
          <see cref="T:System.ServiceModel.Dispatcher.MessageFilter" /> cuyos criterios de búsqueda satisface el mensaje almacenado en búfer; o <see langword="null" /> si no se encuentra ningún filtro que coincida.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilice este método cuando se espere que un filtro único coincida con el mensaje almacenado en búfer y se requiera el filtro coincidente.  
  
 Los filtros de la tabla pueden inspeccionar el cuerpo del mensaje.  
  
 Si se espera que más de un filtro coincida con el mensaje, utilice <xref:System.ServiceModel.Dispatcher.XPathMessageFilterTable%601.GetMatchingFilters%2A>.  
  
 Este método implementa <xref:System.ServiceModel.Dispatcher.IMessageFilterTable%601.GetMatchingFilter%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El valor de <paramref name="messageBuffer" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ServiceModel.Dispatcher.MultipleFilterMatchesException">Más de un filtro coincide con el <paramref name="messageBuffer" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetMatchingFilter">
      <MemberSignature Language="C#" Value="public bool GetMatchingFilter (System.ServiceModel.Dispatcher.SeekableXPathNavigator navigator, out System.ServiceModel.Dispatcher.MessageFilter filter);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool GetMatchingFilter(class System.ServiceModel.Dispatcher.SeekableXPathNavigator navigator, [out] class System.ServiceModel.Dispatcher.MessageFilter&amp; filter) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Dispatcher.XPathMessageFilterTable`1.GetMatchingFilter(System.ServiceModel.Dispatcher.SeekableXPathNavigator,System.ServiceModel.Dispatcher.MessageFilter@)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMatchingFilter (navigator As SeekableXPathNavigator, ByRef filter As MessageFilter) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool GetMatchingFilter(System::ServiceModel::Dispatcher::SeekableXPathNavigator ^ navigator, [Runtime::InteropServices::Out] System::ServiceModel::Dispatcher::MessageFilter ^ % filter);" />
      <MemberSignature Language="F#" Value="member this.GetMatchingFilter : System.ServiceModel.Dispatcher.SeekableXPathNavigator *  -&gt; bool" Usage="xPathMessageFilterTable.GetMatchingFilter (navigator, filter)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="navigator" Type="System.ServiceModel.Dispatcher.SeekableXPathNavigator" />
        <Parameter Name="filter" Type="System.ServiceModel.Dispatcher.MessageFilter" RefType="out" />
      </Parameters>
      <Docs>
        <param name="navigator">
          <see cref="T:System.ServiceModel.Dispatcher.SeekableXPathNavigator" /> que se va a probar.</param>
        <param name="filter">Parámetro <see langword="out" /> que almacena el filtro que <c>message</c> satisface. Si no se encuentra ningún filtro, el parámetro se establece en su valor predeterminado.</param>
        <summary>Devuelve un valor que indica si el mensaje o el mensaje almacenado en búfer especificado satisface los criterios de coincidencia de exactamente un <see cref="T:System.ServiceModel.Dispatcher.SeekableXPathNavigator" />de la tabla, y devuelve dicho filtro en un parámetro <see langword="out" />.</summary>
        <returns>
          <see cref="T:System.ServiceModel.Dispatcher.MessageFilter" /> cuyos criterios de búsqueda satisface el navegador; o <see langword="null" /> si no se encuentra ningún filtro coincidente.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilice este método cuando se espere que un filtro único coincida con el mensaje especificado por <xref:System.ServiceModel.Dispatcher.SeekableXPathNavigator> y se requiera el filtro coincidente.  
  
 Si se espera que más de un filtro coincida con el mensaje, utilice <xref:System.ServiceModel.Dispatcher.XPathMessageFilterTable%601.GetMatchingFilters%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El valor de <paramref name="navigator" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ServiceModel.Dispatcher.MultipleFilterMatchesException">Más de un filtro coincide con el <paramref name="navigator" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetMatchingFilter">
      <MemberSignature Language="C#" Value="public bool GetMatchingFilter (System.Xml.XPath.XPathNavigator navigator, out System.ServiceModel.Dispatcher.MessageFilter filter);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool GetMatchingFilter(class System.Xml.XPath.XPathNavigator navigator, [out] class System.ServiceModel.Dispatcher.MessageFilter&amp; filter) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Dispatcher.XPathMessageFilterTable`1.GetMatchingFilter(System.Xml.XPath.XPathNavigator,System.ServiceModel.Dispatcher.MessageFilter@)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMatchingFilter (navigator As XPathNavigator, ByRef filter As MessageFilter) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool GetMatchingFilter(System::Xml::XPath::XPathNavigator ^ navigator, [Runtime::InteropServices::Out] System::ServiceModel::Dispatcher::MessageFilter ^ % filter);" />
      <MemberSignature Language="F#" Value="member this.GetMatchingFilter : System.Xml.XPath.XPathNavigator *  -&gt; bool" Usage="xPathMessageFilterTable.GetMatchingFilter (navigator, filter)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="navigator" Type="System.Xml.XPath.XPathNavigator" />
        <Parameter Name="filter" Type="System.ServiceModel.Dispatcher.MessageFilter" RefType="out" />
      </Parameters>
      <Docs>
        <param name="navigator">
          <see cref="T:System.Xml.XPath.XPathNavigator" /> que se va a probar.</param>
        <param name="filter">Parámetro <see langword="out" /> que almacena el filtro que <c>navigator</c> satisface. Si no se encuentra ningún filtro, el parámetro se establece en su valor predeterminado.</param>
        <summary>Devuelve un valor que indica si el mensaje o el mensaje almacenado en búfer especificado satisface los criterios de coincidencia de exactamente un <see cref="T:System.Xml.XPath.XPathNavigator" />de la tabla, y devuelve dicho filtro en un parámetro <see langword="out" />.</summary>
        <returns>
          <see cref="T:System.ServiceModel.Dispatcher.MessageFilter" /> cuyos criterios de búsqueda satisface el navegador; o <see langword="null" /> si no se encuentra ningún filtro coincidente.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilice este método cuando se espere que un filtro único coincida con el mensaje especificado por <xref:System.Xml.XPath.XPathNavigator> y se requiera el filtro coincidente.  
  
 Si se espera que más de un filtro coincida con el mensaje, utilice <xref:System.ServiceModel.Dispatcher.XPathMessageFilterTable%601.GetMatchingFilters%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El valor de <paramref name="navigator" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ServiceModel.Dispatcher.MultipleFilterMatchesException">Más de un filtro coincide con el <paramref name="navigator" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetMatchingFilters">
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Devuelve un valor que indica si el documento XML especificado satisface los criterios de coincidencia de un filtro de la tabla, y agrega los filtros correspondientes a una colección.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use este método cuando se espera que más de un filtro coincida con el mensaje y se requieran filtros coincidentes.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetMatchingFilters">
      <MemberSignature Language="C#" Value="public bool GetMatchingFilters (System.ServiceModel.Channels.Message message, System.Collections.Generic.ICollection&lt;System.ServiceModel.Dispatcher.MessageFilter&gt; results);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool GetMatchingFilters(class System.ServiceModel.Channels.Message message, class System.Collections.Generic.ICollection`1&lt;class System.ServiceModel.Dispatcher.MessageFilter&gt; results) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Dispatcher.XPathMessageFilterTable`1.GetMatchingFilters(System.ServiceModel.Channels.Message,System.Collections.Generic.ICollection{System.ServiceModel.Dispatcher.MessageFilter})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool GetMatchingFilters(System::ServiceModel::Channels::Message ^ message, System::Collections::Generic::ICollection&lt;System::ServiceModel::Dispatcher::MessageFilter ^&gt; ^ results);" />
      <MemberSignature Language="F#" Value="abstract member GetMatchingFilters : System.ServiceModel.Channels.Message * System.Collections.Generic.ICollection&lt;System.ServiceModel.Dispatcher.MessageFilter&gt; -&gt; bool&#xA;override this.GetMatchingFilters : System.ServiceModel.Channels.Message * System.Collections.Generic.ICollection&lt;System.ServiceModel.Dispatcher.MessageFilter&gt; -&gt; bool" Usage="xPathMessageFilterTable.GetMatchingFilters (message, results)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ServiceModel.Dispatcher.IMessageFilterTable`1.GetMatchingFilters(System.ServiceModel.Channels.Message,System.Collections.Generic.ICollection{System.ServiceModel.Dispatcher.MessageFilter})</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="message" Type="System.ServiceModel.Channels.Message" />
        <Parameter Name="results" Type="System.Collections.Generic.ICollection&lt;System.ServiceModel.Dispatcher.MessageFilter&gt;" />
      </Parameters>
      <Docs>
        <param name="message">
          <see cref="T:System.ServiceModel.Channels.Message" /> que se va a probar.</param>
        <param name="results">Parámetro de referencia que almacena los objetos <see cref="T:System.ServiceModel.Dispatcher.MessageFilter" /> coincidentes de la <see cref="T:System.Collections.Generic.ICollection`1" />&lt;Filter&gt;.</param>
        <summary>Devuelve un valor que indica si el mensaje especificado satisface los criterios de coincidencia de al menos un <see cref="T:System.ServiceModel.Dispatcher.XPathMessageFilter" /> de la tabla, y agrega los filtros correspondientes a una colección.</summary>
        <returns>
          <see langword="true" /> si <paramref name="message" /> cumplen los criterios de coincidencia de al menos un filtro de la tabla; <see langword="false" /> si no se cumplen los criterios de ningún filtro.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use este método cuando se espera que más de un filtro coincida con el mensaje y se requieran filtros coincidentes.  
  
 Los filtros de la tabla no pueden inspeccionar el cuerpo del mensaje.  
  
 Los objetos <xref:System.ServiceModel.Dispatcher.XPathMessageFilter> correspondientes se almacenan en el parámetro `results` de <xref:System.Collections.Generic.ICollection%601>. A continuación, los `FilterData` se pueden recuperar de la tabla de filtros utilizando estos filtros como claves con los métodos proporcionados por <xref:System.Collections.Generic.IDictionary%602>.  
  
 Este método implementa <xref:System.ServiceModel.Dispatcher.IMessageFilterTable%601.GetMatchingFilters%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El valor de <paramref name="results" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ServiceModel.Dispatcher.InvalidBodyAccessException">Un filtro intentó examinar el contenido del cuerpo del mensaje.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetMatchingFilters">
      <MemberSignature Language="C#" Value="public bool GetMatchingFilters (System.ServiceModel.Channels.MessageBuffer messageBuffer, System.Collections.Generic.ICollection&lt;System.ServiceModel.Dispatcher.MessageFilter&gt; results);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool GetMatchingFilters(class System.ServiceModel.Channels.MessageBuffer messageBuffer, class System.Collections.Generic.ICollection`1&lt;class System.ServiceModel.Dispatcher.MessageFilter&gt; results) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Dispatcher.XPathMessageFilterTable`1.GetMatchingFilters(System.ServiceModel.Channels.MessageBuffer,System.Collections.Generic.ICollection{System.ServiceModel.Dispatcher.MessageFilter})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool GetMatchingFilters(System::ServiceModel::Channels::MessageBuffer ^ messageBuffer, System::Collections::Generic::ICollection&lt;System::ServiceModel::Dispatcher::MessageFilter ^&gt; ^ results);" />
      <MemberSignature Language="F#" Value="abstract member GetMatchingFilters : System.ServiceModel.Channels.MessageBuffer * System.Collections.Generic.ICollection&lt;System.ServiceModel.Dispatcher.MessageFilter&gt; -&gt; bool&#xA;override this.GetMatchingFilters : System.ServiceModel.Channels.MessageBuffer * System.Collections.Generic.ICollection&lt;System.ServiceModel.Dispatcher.MessageFilter&gt; -&gt; bool" Usage="xPathMessageFilterTable.GetMatchingFilters (messageBuffer, results)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ServiceModel.Dispatcher.IMessageFilterTable`1.GetMatchingFilters(System.ServiceModel.Channels.MessageBuffer,System.Collections.Generic.ICollection{System.ServiceModel.Dispatcher.MessageFilter})</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="messageBuffer" Type="System.ServiceModel.Channels.MessageBuffer" />
        <Parameter Name="results" Type="System.Collections.Generic.ICollection&lt;System.ServiceModel.Dispatcher.MessageFilter&gt;" />
      </Parameters>
      <Docs>
        <param name="messageBuffer">
          <see cref="T:System.ServiceModel.Channels.MessageBuffer" /> que se va a probar.</param>
        <param name="results">Parámetro de referencia que almacena los objetos <see cref="T:System.ServiceModel.Dispatcher.MessageFilter" /> coincidentes de la <see cref="T:System.Collections.Generic.ICollection`1" />&lt;Filter&gt;.</param>
        <summary>Devuelve un valor que indica si el mensaje almacenado en búfer especificado satisface los criterios de coincidencia de al menos un <see cref="T:System.ServiceModel.Dispatcher.XPathMessageFilter" /> de la tabla, y agrega los filtros correspondientes a una colección.</summary>
        <returns>
          <see langword="true" /> si <paramref name="messageBuffer" /> cumplen los criterios de coincidencia de al menos un filtro de la tabla; <see langword="false" /> si no se cumplen los criterios de ningún filtro.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilice este método cuando se espere que más de un filtro coincida con el mensaje almacenado en búfer y se requieran los filtros correspondientes.  
  
 Los filtros de la tabla pueden inspeccionar el cuerpo del mensaje.  
  
 Los objetos <xref:System.ServiceModel.Dispatcher.MessageFilter> correspondientes se almacenan en el parámetro `results` de <xref:System.Collections.Generic.ICollection%601>. A continuación, los `FilterData` se pueden recuperar de la tabla de filtros utilizando estos filtros como claves con los métodos proporcionados por <xref:System.Collections.Generic.IDictionary%602>.  
  
 Este método implementa <xref:System.ServiceModel.Dispatcher.MessageFilterTable%601.GetMatchingFilters%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El valor de <paramref name="results" /> es <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetMatchingFilters">
      <MemberSignature Language="C#" Value="public bool GetMatchingFilters (System.ServiceModel.Dispatcher.SeekableXPathNavigator navigator, System.Collections.Generic.ICollection&lt;System.ServiceModel.Dispatcher.MessageFilter&gt; results);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool GetMatchingFilters(class System.ServiceModel.Dispatcher.SeekableXPathNavigator navigator, class System.Collections.Generic.ICollection`1&lt;class System.ServiceModel.Dispatcher.MessageFilter&gt; results) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Dispatcher.XPathMessageFilterTable`1.GetMatchingFilters(System.ServiceModel.Dispatcher.SeekableXPathNavigator,System.Collections.Generic.ICollection{System.ServiceModel.Dispatcher.MessageFilter})" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMatchingFilters (navigator As SeekableXPathNavigator, results As ICollection(Of MessageFilter)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool GetMatchingFilters(System::ServiceModel::Dispatcher::SeekableXPathNavigator ^ navigator, System::Collections::Generic::ICollection&lt;System::ServiceModel::Dispatcher::MessageFilter ^&gt; ^ results);" />
      <MemberSignature Language="F#" Value="member this.GetMatchingFilters : System.ServiceModel.Dispatcher.SeekableXPathNavigator * System.Collections.Generic.ICollection&lt;System.ServiceModel.Dispatcher.MessageFilter&gt; -&gt; bool" Usage="xPathMessageFilterTable.GetMatchingFilters (navigator, results)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="navigator" Type="System.ServiceModel.Dispatcher.SeekableXPathNavigator" />
        <Parameter Name="results" Type="System.Collections.Generic.ICollection&lt;System.ServiceModel.Dispatcher.MessageFilter&gt;" />
      </Parameters>
      <Docs>
        <param name="navigator">
          <see cref="T:System.ServiceModel.Dispatcher.SeekableXPathNavigator" /> que se va a probar.</param>
        <param name="results">Parámetro de referencia que almacena los objetos <see cref="T:System.ServiceModel.Dispatcher.MessageFilter" /> coincidentes de la <see cref="T:System.Collections.Generic.ICollection`1" />&lt;Filter&gt;.</param>
        <summary>Devuelve un valor que indica si el mensaje almacenado en búfer especificado satisface los criterios de coincidencia de al menos un <see cref="T:System.ServiceModel.Dispatcher.SeekableXPathNavigator" /> de la tabla, y agrega los filtros correspondientes a una colección.</summary>
        <returns>
          <see langword="true" /> si <paramref name="messageBuffer" /> cumplen los criterios de coincidencia de al menos un filtro de la tabla; <see langword="false" /> si no se cumplen los criterios de ningún filtro.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilice este método cuando se espere que haya más de un filtro coincidente con el navegador y se requieran los filtros coincidentes.  
  
 Si se espera que sólo un filtro coincida con el mensaje, utilice el método <xref:System.ServiceModel.Dispatcher.XPathMessageFilterTable%601.GetMatchingFilter%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El valor de <paramref name="results" /> es <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetMatchingFilters">
      <MemberSignature Language="C#" Value="public bool GetMatchingFilters (System.Xml.XPath.XPathNavigator navigator, System.Collections.Generic.ICollection&lt;System.ServiceModel.Dispatcher.MessageFilter&gt; results);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool GetMatchingFilters(class System.Xml.XPath.XPathNavigator navigator, class System.Collections.Generic.ICollection`1&lt;class System.ServiceModel.Dispatcher.MessageFilter&gt; results) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Dispatcher.XPathMessageFilterTable`1.GetMatchingFilters(System.Xml.XPath.XPathNavigator,System.Collections.Generic.ICollection{System.ServiceModel.Dispatcher.MessageFilter})" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMatchingFilters (navigator As XPathNavigator, results As ICollection(Of MessageFilter)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool GetMatchingFilters(System::Xml::XPath::XPathNavigator ^ navigator, System::Collections::Generic::ICollection&lt;System::ServiceModel::Dispatcher::MessageFilter ^&gt; ^ results);" />
      <MemberSignature Language="F#" Value="member this.GetMatchingFilters : System.Xml.XPath.XPathNavigator * System.Collections.Generic.ICollection&lt;System.ServiceModel.Dispatcher.MessageFilter&gt; -&gt; bool" Usage="xPathMessageFilterTable.GetMatchingFilters (navigator, results)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="navigator" Type="System.Xml.XPath.XPathNavigator" />
        <Parameter Name="results" Type="System.Collections.Generic.ICollection&lt;System.ServiceModel.Dispatcher.MessageFilter&gt;" />
      </Parameters>
      <Docs>
        <param name="navigator">
          <see cref="T:System.Xml.XPath.XPathNavigator" /> que se va a probar.</param>
        <param name="results">Parámetro de referencia que almacena los objetos <see cref="T:System.ServiceModel.Dispatcher.MessageFilter" /> coincidentes de la <see cref="T:System.Collections.Generic.ICollection`1" />&lt;Filter&gt;.</param>
        <summary>Devuelve un valor que indica si el mensaje almacenado en búfer especificado satisface los criterios de coincidencia de al menos un <see cref="T:System.Xml.XPath.XPathNavigator" /> de la tabla, y agrega los filtros correspondientes a una colección.</summary>
        <returns>
          <see langword="true" /> si <paramref name="messageBuffer" /> cumplen los criterios de coincidencia de al menos un filtro de la tabla; <see langword="false" /> si no se cumplen los criterios de ningún filtro.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilice este método cuando se pueda esperar que varios filtros coincidan con el mensaje especificado por <xref:System.Xml.XPath.XPathNavigator> y se requieran los filtros correspondientes.  
  
 Si se espera que sólo un filtro coincida con el mensaje, utilice el método <xref:System.ServiceModel.Dispatcher.XPathMessageFilterTable%601.GetMatchingFilter%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El valor de <paramref name="matches" /> es <see langword="null" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetMatchingValue">
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Devuelve un valor que indica si el objeto de documento especificado satisface los criterios de coincidencia de exactamente un <see cref="T:System.ServiceModel.Dispatcher.XPathMessageFilter" /> de la tabla, y agrega los datos del filtro correspondiente a una colección.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use uno de estos cuatro métodos cuando se espera que un único filtro coincida con el objeto de documento y sólo se deban recuperar los `FilterData` del filtro correspondiente.  
  
 Los dos primeros métodos son implementaciones de <xref:System.ServiceModel.Dispatcher.XPathMessageFilterTable%601.GetMatchingValue%2A>.  
  
 Use <xref:System.ServiceModel.Dispatcher.XPathMessageFilterTable%601.GetMatchingValue%2A> si no es necesario examinar el contenido del cuerpo del mensaje. Use <xref:System.ServiceModel.Dispatcher.XPathMessageFilterTable%601.GetMatchingValue%2A> si el contenido del cuerpo del mensaje podría tener que examinarse.  
  
 Los dos métodos restantes son sobrecargas específicas de <xref:System.ServiceModel.Dispatcher.XPathMessageFilterTable%601>. Para filtrar en un documento proporcionado a través de un navegador, utilice <xref:System.ServiceModel.Dispatcher.XPathMessageFilterTable%601.GetMatchingValue%2A> o <xref:System.ServiceModel.Dispatcher.XPathMessageFilterTable%601.GetMatchingValue%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetMatchingValue">
      <MemberSignature Language="C#" Value="public bool GetMatchingValue (System.ServiceModel.Channels.Message message, out TFilterData data);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool GetMatchingValue(class System.ServiceModel.Channels.Message message, [out] !TFilterData&amp; data) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Dispatcher.XPathMessageFilterTable`1.GetMatchingValue(System.ServiceModel.Channels.Message,`0@)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool GetMatchingValue(System::ServiceModel::Channels::Message ^ message, [Runtime::InteropServices::Out] TFilterData % data);" />
      <MemberSignature Language="F#" Value="abstract member GetMatchingValue : System.ServiceModel.Channels.Message *  -&gt; bool&#xA;override this.GetMatchingValue : System.ServiceModel.Channels.Message *  -&gt; bool" Usage="xPathMessageFilterTable.GetMatchingValue (message, data)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ServiceModel.Dispatcher.IMessageFilterTable`1.GetMatchingValue(System.ServiceModel.Channels.Message,`0@)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="message" Type="System.ServiceModel.Channels.Message" />
        <Parameter Name="data" Type="TFilterData" RefType="out" />
      </Parameters>
      <Docs>
        <param name="message">
          <see cref="T:System.ServiceModel.Channels.Message" /> que se va a probar.</param>
        <param name="data">Parámetro <see langword="out" /> que almacena el <c>FilterData</c> del filtro que coincide con <c>message</c>.</param>
        <summary>Devuelve un valor que indica si el mensaje especificado satisface los criterios de coincidencia de exactamente un <see cref="T:System.ServiceModel.Dispatcher.XPathMessageFilter" /> de la tabla, y devuelve los datos de filtro correspondientes.</summary>
        <returns>
          <see langword="true" /> si el mensaje satisface los criterios de coincidencia de un filtro de la tabla; <see langword="false" /> si no se cumple ningún filtro.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilice este método cuando se espere que un único filtro coincida con el mensaje y sólo se deban recuperar los `FilterData` del filtro correspondiente.  
  
 Este método implementa <xref:System.ServiceModel.Dispatcher.IMessageFilterTable%601.GetMatchingValue%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El valor de <paramref name="message" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ServiceModel.Dispatcher.MultipleFilterMatchesException">Más de un filtro coincide con el <paramref name="message" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetMatchingValue">
      <MemberSignature Language="C#" Value="public bool GetMatchingValue (System.ServiceModel.Channels.MessageBuffer messageBuffer, out TFilterData data);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool GetMatchingValue(class System.ServiceModel.Channels.MessageBuffer messageBuffer, [out] !TFilterData&amp; data) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Dispatcher.XPathMessageFilterTable`1.GetMatchingValue(System.ServiceModel.Channels.MessageBuffer,`0@)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool GetMatchingValue(System::ServiceModel::Channels::MessageBuffer ^ messageBuffer, [Runtime::InteropServices::Out] TFilterData % data);" />
      <MemberSignature Language="F#" Value="abstract member GetMatchingValue : System.ServiceModel.Channels.MessageBuffer *  -&gt; bool&#xA;override this.GetMatchingValue : System.ServiceModel.Channels.MessageBuffer *  -&gt; bool" Usage="xPathMessageFilterTable.GetMatchingValue (messageBuffer, data)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ServiceModel.Dispatcher.IMessageFilterTable`1.GetMatchingValue(System.ServiceModel.Channels.MessageBuffer,`0@)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="messageBuffer" Type="System.ServiceModel.Channels.MessageBuffer" />
        <Parameter Name="data" Type="TFilterData" RefType="out" />
      </Parameters>
      <Docs>
        <param name="messageBuffer">
          <see cref="T:System.ServiceModel.Channels.MessageBuffer" /> que se va a probar.</param>
        <param name="data">Parámetro <see langword="out" /> que almacena el <c>FilterData</c> del filtro que coincide con <c>messageBuffer</c>.</param>
        <summary>Devuelve un valor que indica si el mensaje almacenado en búfer especificado satisface los criterios de coincidencia de exactamente un <see cref="T:System.ServiceModel.Dispatcher.XPathMessageFilter" /> de la tabla, y devuelve los datos de filtro correspondientes.</summary>
        <returns>
          <see langword="true" /> si el mensaje almacenado en búfer satisface los criterios de coincidencia de un filtro de la tabla; <see langword="false" /> si no se cumple ningún filtro.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilice este método cuando se espera que un único filtro coincida con el mensaje almacenado en búfer y sólo se deban recuperar los `FilterData` del filtro correspondiente.  
  
 Este método implementa <xref:System.ServiceModel.Dispatcher.IMessageFilterTable%601.GetMatchingFilter%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El valor de <paramref name="message" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ServiceModel.Dispatcher.MultipleFilterMatchesException">Más de un filtro coincide con el <paramref name="messageBuffer" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetMatchingValue">
      <MemberSignature Language="C#" Value="public bool GetMatchingValue (System.ServiceModel.Dispatcher.SeekableXPathNavigator navigator, out TFilterData data);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool GetMatchingValue(class System.ServiceModel.Dispatcher.SeekableXPathNavigator navigator, [out] !TFilterData&amp; data) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Dispatcher.XPathMessageFilterTable`1.GetMatchingValue(System.ServiceModel.Dispatcher.SeekableXPathNavigator,`0@)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMatchingValue (navigator As SeekableXPathNavigator, ByRef data As TFilterData) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool GetMatchingValue(System::ServiceModel::Dispatcher::SeekableXPathNavigator ^ navigator, [Runtime::InteropServices::Out] TFilterData % data);" />
      <MemberSignature Language="F#" Value="member this.GetMatchingValue : System.ServiceModel.Dispatcher.SeekableXPathNavigator *  -&gt; bool" Usage="xPathMessageFilterTable.GetMatchingValue (navigator, data)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="navigator" Type="System.ServiceModel.Dispatcher.SeekableXPathNavigator" />
        <Parameter Name="data" Type="TFilterData" RefType="out" />
      </Parameters>
      <Docs>
        <param name="navigator">
          <see cref="T:System.ServiceModel.Dispatcher.SeekableXPathNavigator" /> que se va a probar.</param>
        <param name="data">Parámetro <see langword="out" /> que almacena el <c>FilterData</c> que coincide con <c>navigator</c>.</param>
        <summary>Devuelve un valor que indica si el <see cref="T:System.ServiceModel.Dispatcher.SeekableXPathNavigator" /> satisface los criterios de coincidencia de exactamente un <paramref name="navigator" /> de la tabla, y devuelve los datos de filtro del filtro correspondiente en un parámetro <see langword="out" />.</summary>
        <returns>
          <see langword="true" /> si el <paramref name="navigator" /> cumple los criterios de coincidencia de exactamente un filtro de la tabla; <see langword="false" /> si no se cumplen los criterios de ningún filtro.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilice este método para especificar una condición del XPath que debe encontrarse el mensaje.  
  
 Este método es similar a <xref:System.ServiceModel.Dispatcher.XPathMessageFilterTable%601.GetMatchingValue%2A>, sólo que utiliza <xref:System.ServiceModel.Dispatcher.SeekableXPathNavigator>, lo que extiende la funcionalidad de <xref:System.Xml.XPath.XPathNavigator> para incluir métodos que permiten varias optimizaciones.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El valor de <paramref name="navigator" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ServiceModel.Dispatcher.MultipleFilterMatchesException">Más de un filtro coincide con el <paramref name="navigator" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetMatchingValue">
      <MemberSignature Language="C#" Value="public bool GetMatchingValue (System.Xml.XPath.XPathNavigator navigator, out TFilterData data);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool GetMatchingValue(class System.Xml.XPath.XPathNavigator navigator, [out] !TFilterData&amp; data) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Dispatcher.XPathMessageFilterTable`1.GetMatchingValue(System.Xml.XPath.XPathNavigator,`0@)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMatchingValue (navigator As XPathNavigator, ByRef data As TFilterData) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool GetMatchingValue(System::Xml::XPath::XPathNavigator ^ navigator, [Runtime::InteropServices::Out] TFilterData % data);" />
      <MemberSignature Language="F#" Value="member this.GetMatchingValue : System.Xml.XPath.XPathNavigator *  -&gt; bool" Usage="xPathMessageFilterTable.GetMatchingValue (navigator, data)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="navigator" Type="System.Xml.XPath.XPathNavigator" />
        <Parameter Name="data" Type="TFilterData" RefType="out" />
      </Parameters>
      <Docs>
        <param name="navigator">
          <see cref="T:System.Xml.XPath.XPathNavigator" /> que se va a probar.</param>
        <param name="data">Parámetro <see langword="out" /> que almacena el <c>FilterData</c> que coincide con <c>navigator</c>.</param>
        <summary>Devuelve un valor que indica si el <see cref="T:System.Xml.XPath.XPathNavigator" /> satisface los criterios de coincidencia de exactamente un <paramref name="navigator" /> de la tabla, y devuelve los datos de filtro del filtro correspondiente en un parámetro <see langword="out" />.</summary>
        <returns>
          <see langword="true" /> si el <paramref name="navigator" /> cumple los criterios de coincidencia de exactamente un filtro de la tabla; <see langword="false" /> si no se cumplen los criterios de ningún filtro.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilice este método para especificar una condición del XPath que debe encontrarse el mensaje.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El valor de <paramref name="navigator" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ServiceModel.Dispatcher.MultipleFilterMatchesException">Más de un filtro coincide con el <paramref name="navigator" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetMatchingValues">
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Devuelve un valor que indica si el mensaje especificado o el mensaje almacenado en búfer satisface el criterio de coincidencia de al menos un filtro de la tabla y agrega <paramref name="FilterData" /> de los filtros coincidentes a una colección.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilice este método cuando se espere que más de un filtro coincida con el mensaje o el mensaje almacenado en búfer y sólo se requieran los `FilterData`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetMatchingValues">
      <MemberSignature Language="C#" Value="public bool GetMatchingValues (System.ServiceModel.Channels.Message message, System.Collections.Generic.ICollection&lt;TFilterData&gt; results);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool GetMatchingValues(class System.ServiceModel.Channels.Message message, class System.Collections.Generic.ICollection`1&lt;!TFilterData&gt; results) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Dispatcher.XPathMessageFilterTable`1.GetMatchingValues(System.ServiceModel.Channels.Message,System.Collections.Generic.ICollection{`0})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool GetMatchingValues(System::ServiceModel::Channels::Message ^ message, System::Collections::Generic::ICollection&lt;TFilterData&gt; ^ results);" />
      <MemberSignature Language="F#" Value="abstract member GetMatchingValues : System.ServiceModel.Channels.Message * System.Collections.Generic.ICollection&lt;'FilterData&gt; -&gt; bool&#xA;override this.GetMatchingValues : System.ServiceModel.Channels.Message * System.Collections.Generic.ICollection&lt;'FilterData&gt; -&gt; bool" Usage="xPathMessageFilterTable.GetMatchingValues (message, results)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ServiceModel.Dispatcher.IMessageFilterTable`1.GetMatchingValues(System.ServiceModel.Channels.Message,System.Collections.Generic.ICollection{`0})</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="message" Type="System.ServiceModel.Channels.Message" />
        <Parameter Name="results" Type="System.Collections.Generic.ICollection&lt;TFilterData&gt;" />
      </Parameters>
      <Docs>
        <param name="message">
          <see cref="T:System.ServiceModel.Channels.Message" /> que se va a probar.</param>
        <param name="results">Parámetro de referencia que almacena los datos de los filtros correspondientes en una colección <see cref="T:System.Collections.Generic.ICollection`1" />&lt;<c>FilterData</c>&gt; genérica.</param>
        <summary>Devuelve un valor que indica si el mensaje almacenado en búfer especificado satisface los criterios de coincidencia de al menos un filtro de la tabla, y agrega los datos de filtro de los filtros correspondientes a una colección.</summary>
        <returns>
          <see langword="true" /> si <paramref name="message" /> cumplen los criterios de coincidencia de al menos un filtro de la tabla; <see langword="false" /> si no se cumplen los criterios de ningún filtro.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilice este método cuando se espere que más de un filtro coincida con el mensaje, sólo se requieren los datos de filtro y no se inspeccione el cuerpo del mensaje.  
  
 Los datos de filtro de los objetos <xref:System.ServiceModel.Dispatcher.MessageFilter> correspondientes se almacenan en el parámetro `results` de <xref:System.Collections.Generic.ICollection%601>.  
  
 Este método implementa <xref:System.ServiceModel.Dispatcher.IMessageFilterTable%601.GetMatchingValues%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El valor de <paramref name="results" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ServiceModel.Dispatcher.InvalidBodyAccessException">Un filtro intentó examinar el contenido del cuerpo del mensaje.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetMatchingValues">
      <MemberSignature Language="C#" Value="public bool GetMatchingValues (System.ServiceModel.Channels.MessageBuffer messageBuffer, System.Collections.Generic.ICollection&lt;TFilterData&gt; results);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool GetMatchingValues(class System.ServiceModel.Channels.MessageBuffer messageBuffer, class System.Collections.Generic.ICollection`1&lt;!TFilterData&gt; results) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Dispatcher.XPathMessageFilterTable`1.GetMatchingValues(System.ServiceModel.Channels.MessageBuffer,System.Collections.Generic.ICollection{`0})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool GetMatchingValues(System::ServiceModel::Channels::MessageBuffer ^ messageBuffer, System::Collections::Generic::ICollection&lt;TFilterData&gt; ^ results);" />
      <MemberSignature Language="F#" Value="abstract member GetMatchingValues : System.ServiceModel.Channels.MessageBuffer * System.Collections.Generic.ICollection&lt;'FilterData&gt; -&gt; bool&#xA;override this.GetMatchingValues : System.ServiceModel.Channels.MessageBuffer * System.Collections.Generic.ICollection&lt;'FilterData&gt; -&gt; bool" Usage="xPathMessageFilterTable.GetMatchingValues (messageBuffer, results)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ServiceModel.Dispatcher.IMessageFilterTable`1.GetMatchingValues(System.ServiceModel.Channels.MessageBuffer,System.Collections.Generic.ICollection{`0})</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="messageBuffer" Type="System.ServiceModel.Channels.MessageBuffer" />
        <Parameter Name="results" Type="System.Collections.Generic.ICollection&lt;TFilterData&gt;" />
      </Parameters>
      <Docs>
        <param name="messageBuffer">
          <see cref="T:System.ServiceModel.Channels.MessageBuffer" /> que se va a probar.</param>
        <param name="results">Parámetro de referencia que almacena los datos de los filtros correspondientes en una colección <see cref="T:System.Collections.Generic.ICollection`1" />&lt;<c>FilterData</c>&gt; genérica.</param>
        <summary>Devuelve un valor que indica si el mensaje almacenado en búfer especificado satisface los criterios de coincidencia de al menos un filtro de la tabla, y agrega los datos de filtro de los filtros correspondientes a una colección.</summary>
        <returns>
          <see langword="true" /> si <paramref name="message" /> cumplen los criterios de coincidencia de al menos un filtro de la tabla; <see langword="false" /> si no se cumplen los criterios de ningún filtro.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use este método cuando se espera que más de un filtro coincida con el mensaje almacenado en búfer y sólo se requieren los datos de filtro.  
  
 Los datos de filtro de los objetos <xref:System.ServiceModel.Dispatcher.XPathMessageFilter> correspondientes se almacenan en `results`<xref:System.Collections.Generic.ICollection%601>.  
  
 Este método implementa <xref:System.ServiceModel.Dispatcher.IMessageFilterTable%601.GetMatchingValues%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El valor de <paramref name="results" /> es <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetMatchingValues">
      <MemberSignature Language="C#" Value="public bool GetMatchingValues (System.ServiceModel.Dispatcher.SeekableXPathNavigator navigator, System.Collections.Generic.ICollection&lt;TFilterData&gt; results);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool GetMatchingValues(class System.ServiceModel.Dispatcher.SeekableXPathNavigator navigator, class System.Collections.Generic.ICollection`1&lt;!TFilterData&gt; results) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Dispatcher.XPathMessageFilterTable`1.GetMatchingValues(System.ServiceModel.Dispatcher.SeekableXPathNavigator,System.Collections.Generic.ICollection{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMatchingValues (navigator As SeekableXPathNavigator, results As ICollection(Of TFilterData)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool GetMatchingValues(System::ServiceModel::Dispatcher::SeekableXPathNavigator ^ navigator, System::Collections::Generic::ICollection&lt;TFilterData&gt; ^ results);" />
      <MemberSignature Language="F#" Value="member this.GetMatchingValues : System.ServiceModel.Dispatcher.SeekableXPathNavigator * System.Collections.Generic.ICollection&lt;'FilterData&gt; -&gt; bool" Usage="xPathMessageFilterTable.GetMatchingValues (navigator, results)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="navigator" Type="System.ServiceModel.Dispatcher.SeekableXPathNavigator" />
        <Parameter Name="results" Type="System.Collections.Generic.ICollection&lt;TFilterData&gt;" />
      </Parameters>
      <Docs>
        <param name="navigator">
          <see cref="T:System.ServiceModel.Dispatcher.SeekableXPathNavigator" /> que se va a probar.</param>
        <param name="results">Parámetro de referencia que almacena los datos de los filtros correspondientes en una colección <see cref="T:System.Collections.Generic.ICollection`1" />&lt;<c>FilterData</c>&gt; genérica.</param>
        <summary>Devuelve un valor que indica si el <see cref="T:System.ServiceModel.Dispatcher.SeekableXPathNavigator" /> satisface los criterios de coincidencia de al menos un <paramref name="navigator" /> de la tabla, y agrega los datos de filtro de los filtros correspondientes a una colección.</summary>
        <returns>
          <see langword="true" /> si <paramref name="navigator" /> cumple los criterios de coincidencia de al menos un filtro de la tabla; <see langword="false" /> si no se cumplen los criterios de ningún filtro.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilice este método cuando se espere que más de un filtro coincida con los criterios de búsqueda del documento XML derivado del XPath navegador <xref:System.ServiceModel.Dispatcher.SeekableXPathNavigator> optimizado y sólo se requieran los datos de filtro.  
  
 Los datos de filtro de los objetos <xref:System.ServiceModel.Dispatcher.XPathMessageFilter> correspondientes se almacenan en el parámetro `results` de <xref:System.Collections.Generic.ICollection%601>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El valor de <paramref name="results" /> es <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetMatchingValues">
      <MemberSignature Language="C#" Value="public bool GetMatchingValues (System.Xml.XPath.XPathNavigator navigator, System.Collections.Generic.ICollection&lt;TFilterData&gt; results);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool GetMatchingValues(class System.Xml.XPath.XPathNavigator navigator, class System.Collections.Generic.ICollection`1&lt;!TFilterData&gt; results) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Dispatcher.XPathMessageFilterTable`1.GetMatchingValues(System.Xml.XPath.XPathNavigator,System.Collections.Generic.ICollection{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMatchingValues (navigator As XPathNavigator, results As ICollection(Of TFilterData)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool GetMatchingValues(System::Xml::XPath::XPathNavigator ^ navigator, System::Collections::Generic::ICollection&lt;TFilterData&gt; ^ results);" />
      <MemberSignature Language="F#" Value="member this.GetMatchingValues : System.Xml.XPath.XPathNavigator * System.Collections.Generic.ICollection&lt;'FilterData&gt; -&gt; bool" Usage="xPathMessageFilterTable.GetMatchingValues (navigator, results)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="navigator" Type="System.Xml.XPath.XPathNavigator" />
        <Parameter Name="results" Type="System.Collections.Generic.ICollection&lt;TFilterData&gt;" />
      </Parameters>
      <Docs>
        <param name="navigator">
          <see cref="T:System.Xml.XPath.XPathNavigator" /> que se va a probar.</param>
        <param name="results">Parámetro de referencia que almacena los datos de los filtros correspondientes en una colección <see cref="T:System.Collections.Generic.ICollection`1" />&lt;<c>FilterData</c>&gt; genérica.</param>
        <summary>Devuelve un valor que indica si el <see cref="T:System.Xml.XPath.XPathNavigator" /> satisface los criterios de coincidencia de al menos un <paramref name="navigator" /> de la tabla, y agrega los datos de filtro de los filtros correspondientes a una colección.</summary>
        <returns>
          <see langword="true" /> si <paramref name="navigator" /> cumple los criterios de coincidencia de al menos un filtro de la tabla; <see langword="false" /> si no se cumplen los criterios de ningún filtro.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilice este método cuando se espere que más de un filtro coincida con los criterios de búsqueda del documento XML derivado del XPath navegador <xref:System.ServiceModel.Dispatcher.SeekableXPathNavigator> optimizado y sólo se requieran los datos de filtro.  
  
 Los datos de filtro de los objetos <xref:System.ServiceModel.Dispatcher.XPathMessageFilter> correspondientes se almacenan en el parámetro `results` de <xref:System.Collections.Generic.ICollection%601>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El valor de <paramref name="results" /> es <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="IsReadOnly">
      <MemberSignature Language="C#" Value="public bool IsReadOnly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsReadOnly" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.Dispatcher.XPathMessageFilterTable`1.IsReadOnly" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsReadOnly As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsReadOnly { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsReadOnly : bool" Usage="System.ServiceModel.Dispatcher.XPathMessageFilterTable&lt;'FilterData&gt;.IsReadOnly" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.Generic.ICollection`1.IsReadOnly</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="T:System.ServiceModel.Dispatcher.XPathMessageFilterTable`1" /> no es de solo lectura.</summary>
        <value>Siempre devuelve <see langword="false" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Item">
      <MemberSignature Language="C#" Value="public TFilterData this[System.ServiceModel.Dispatcher.MessageFilter filter] { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance !TFilterData Item(class System.ServiceModel.Dispatcher.MessageFilter)" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.Dispatcher.XPathMessageFilterTable`1.Item(System.ServiceModel.Dispatcher.MessageFilter)" />
      <MemberSignature Language="VB.NET" Value="Default Public Property Item(filter As MessageFilter) As TFilterData" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property TFilterData default[System::ServiceModel::Dispatcher::MessageFilter ^] { TFilterData get(System::ServiceModel::Dispatcher::MessageFilter ^ filter); void set(System::ServiceModel::Dispatcher::MessageFilter ^ filter, TFilterData value); };" />
      <MemberSignature Language="F#" Value="member this.Item(System.ServiceModel.Dispatcher.MessageFilter) : 'FilterData with get, set" Usage="System.ServiceModel.Dispatcher.XPathMessageFilterTable&lt;'FilterData&gt;.Item" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.Generic.IDictionary`2.Item(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TFilterData</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="filter" Type="System.ServiceModel.Dispatcher.MessageFilter" />
      </Parameters>
      <Docs>
        <param name="filter">
          <see cref="T:System.ServiceModel.Dispatcher.MessageFilter" /> asociado a los  a obtener o establecer.</param>
        <summary>Obtiene o establece los datos de filtro asociados con el <paramref name="filter" /> especificado.</summary>
        <value>Los datos de filtro asociados al <paramref name="filter" />. Si no se encuentra el <paramref name="filter" /> especificado, en el caso de una operación Get se iniciará una <see cref="T:System.Collections.Generic.KeyNotFoundException" /> y en el caso de una operación Set se creará un nuevo elemento de datos de filtro con el <paramref name="filter" /> especificado como clave.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La propiedad `Item` (el indizador en C#) proporciona la capacidad de tener acceso a los datos del filtro asociados al `filter` de la colección de filtros de la tabla utilizando la sintaxis siguiente.  
  
```csharp  
myFilters[filter]  
```  
  
```vb  
myFilters(filter)  
```  
  
 También puede utilizar la propiedad `Item` para agregar los nuevos elementos estableciendo los valores de un par de datos `filter`/filtro que no existe en la tabla de filtro de acción. Sin embargo, si la `filter` ya existe en la tabla, al establecer la propiedad `Item`, se sobrescribe el valor anterior. En contraste, el método <xref:System.ServiceModel.Dispatcher.XPathMessageFilterTable%601.Add%2A> no modifica los datos del filtro de un `filter` existente.  
  
 El `Item` de diccionario es un par de datos `filter`/filtro en el caso de <xref:System.ServiceModel.Dispatcher.XPathMessageFilterTable%601>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El valor de <paramref name="filter" /> es <see langword="null" />.</exception>
        <exception cref="T:System.Xml.XPath.XPathException">Se ha producido un error del compilador.</exception>
        <exception cref="T:System.Collections.Generic.KeyNotFoundException">Se recupera la propiedad y el <paramref name="filter" /> no está en la tabla.</exception>
      </Docs>
    </Member>
    <Member MemberName="Keys">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.ICollection&lt;System.ServiceModel.Dispatcher.MessageFilter&gt; Keys { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.ICollection`1&lt;class System.ServiceModel.Dispatcher.MessageFilter&gt; Keys" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.Dispatcher.XPathMessageFilterTable`1.Keys" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Keys As ICollection(Of MessageFilter)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::Generic::ICollection&lt;System::ServiceModel::Dispatcher::MessageFilter ^&gt; ^ Keys { System::Collections::Generic::ICollection&lt;System::ServiceModel::Dispatcher::MessageFilter ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Keys : System.Collections.Generic.ICollection&lt;System.ServiceModel.Dispatcher.MessageFilter&gt;" Usage="System.ServiceModel.Dispatcher.XPathMessageFilterTable&lt;'FilterData&gt;.Keys" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.Generic.IDictionary`2.Keys</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.ICollection&lt;System.ServiceModel.Dispatcher.MessageFilter&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene una colección de todos los filtros contenidos en <see cref="T:System.ServiceModel.Dispatcher.XPathMessageFilterTable`1" />.</summary>
        <value>
          <see cref="T:System.Collections.Generic.ICollection`1" /> de todos los <see cref="T:System.ServiceModel.Dispatcher.XPathMessageFilter" /> contenidos en la tabla de filtro.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esta propiedad implementa <xref:System.Collections.Generic.IDictionary%602.Keys%2A>. <xref:System.Collections.Generic.IDictionary%602> que la tabla de filtro implementa utiliza <xref:System.ServiceModel.Dispatcher.MessageFilter> como clave y `FilterData` como valor del par.  
  
 El orden de los filtros devueltos en la colección no está especificado, pero se garantiza que será el mismo orden que el de `FilterData` correspondientes en la colección devuelta por la propiedad <xref:System.ServiceModel.Dispatcher.XPathMessageFilterTable%601.Values%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="NodeQuota">
      <MemberSignature Language="C#" Value="public int NodeQuota { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 NodeQuota" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.Dispatcher.XPathMessageFilterTable`1.NodeQuota" />
      <MemberSignature Language="VB.NET" Value="Public Property NodeQuota As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int NodeQuota { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.NodeQuota : int with get, set" Usage="System.ServiceModel.Dispatcher.XPathMessageFilterTable&lt;'FilterData&gt;.NodeQuota" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Runtime.Serialization.DataMember</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece el número máximo de nodos de documento XML que pueden ser examinados por los filtros individuales durante una llamada única a un método <see langword="Match" />. Este valor se aplica a cada filtro.</summary>
        <value>El número de nodos que se pueden examinar.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esta propiedad se puede utilizar para evitar una amenaza de seguridad. Algunos filtros pueden ser sumamente caros de evaluar o de ejecución muy prolongada. Los filtros <xref:System.ServiceModel.Dispatcher.XPathMessageFilter> se evalúan con mayor frecuencia contra un documento procedente de un origen que no es de confianza (mensaje SOAP fuera de la conexión), que puede ser malintencionado. Puesto que los filtros funcionan sobre los documentos XML, la manera mejor de establecer los límites computacionales en tablas de filtro es especificar el número máximo de nodos que se examinan mientras se evalúa un filtro en esta tabla.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Remove">
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Quita un filtro y sus datos del filtro asociados de la tabla de filtro.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Remove">
      <MemberSignature Language="C#" Value="public bool Remove (System.Collections.Generic.KeyValuePair&lt;System.ServiceModel.Dispatcher.MessageFilter,TFilterData&gt; item);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Remove(valuetype System.Collections.Generic.KeyValuePair`2&lt;class System.ServiceModel.Dispatcher.MessageFilter, !TFilterData&gt; item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Dispatcher.XPathMessageFilterTable`1.Remove(System.Collections.Generic.KeyValuePair{System.ServiceModel.Dispatcher.MessageFilter,`0})" />
      <MemberSignature Language="VB.NET" Value="Public Function Remove (item As KeyValuePair(Of MessageFilter, TFilterData)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Remove(System::Collections::Generic::KeyValuePair&lt;System::ServiceModel::Dispatcher::MessageFilter ^, TFilterData&gt; item);" />
      <MemberSignature Language="F#" Value="abstract member Remove : System.Collections.Generic.KeyValuePair&lt;System.ServiceModel.Dispatcher.MessageFilter, 'FilterData&gt; -&gt; bool&#xA;override this.Remove : System.Collections.Generic.KeyValuePair&lt;System.ServiceModel.Dispatcher.MessageFilter, 'FilterData&gt; -&gt; bool" Usage="xPathMessageFilterTable.Remove item" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.ICollection`1.Remove(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="System.Collections.Generic.KeyValuePair&lt;System.ServiceModel.Dispatcher.MessageFilter,TFilterData&gt;" />
      </Parameters>
      <Docs>
        <param name="item">
          <see cref="T:System.Collections.Generic.KeyValuePair`2" /> &lt;Filter, <c>FilterData</c>&gt; que quitar de la tabla.</param>
        <summary>Quita un filtro y sus datos del filtro asociados de la tabla de filtro.</summary>
        <returns>
          <see langword="true" /> si se ha encontrado y eliminado el par filtro/<paramref name="FilterData" />; <see langword="false" /> si no se ha encontrado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si la clave de filtro de `item` está presente pero está asociada con datos que difieren de `FilterData`, el método no puede quitar el filtro y devuelve `false`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Remove">
      <MemberSignature Language="C#" Value="public bool Remove (System.ServiceModel.Dispatcher.MessageFilter filter);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Remove(class System.ServiceModel.Dispatcher.MessageFilter filter) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Dispatcher.XPathMessageFilterTable`1.Remove(System.ServiceModel.Dispatcher.MessageFilter)" />
      <MemberSignature Language="VB.NET" Value="Public Function Remove (filter As MessageFilter) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Remove(System::ServiceModel::Dispatcher::MessageFilter ^ filter);" />
      <MemberSignature Language="F#" Value="abstract member Remove : System.ServiceModel.Dispatcher.MessageFilter -&gt; bool&#xA;override this.Remove : System.ServiceModel.Dispatcher.MessageFilter -&gt; bool" Usage="xPathMessageFilterTable.Remove filter" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.IDictionary`2.Remove(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="filter" Type="System.ServiceModel.Dispatcher.MessageFilter" />
      </Parameters>
      <Docs>
        <param name="filter">
          <see cref="T:System.ServiceModel.Dispatcher.MessageFilter" /> que se va a quitar.</param>
        <summary>Quita un filtro y sus datos del filtro asociados de la tabla de filtro.</summary>
        <returns>
          <see langword="true" /> si ha encontrado y eliminado el filtro; de lo contrario, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">El valor de <paramref name="filter" /> es <see langword="null" />.</exception>
        <exception cref="T:System.InvalidCastException">
          <paramref name="filter" /> no es un <see cref="T:System.ServiceModel.Dispatcher.XPathMessageFilter" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Remove">
      <MemberSignature Language="C#" Value="public bool Remove (System.ServiceModel.Dispatcher.XPathMessageFilter filter);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Remove(class System.ServiceModel.Dispatcher.XPathMessageFilter filter) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Dispatcher.XPathMessageFilterTable`1.Remove(System.ServiceModel.Dispatcher.XPathMessageFilter)" />
      <MemberSignature Language="VB.NET" Value="Public Function Remove (filter As XPathMessageFilter) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Remove(System::ServiceModel::Dispatcher::XPathMessageFilter ^ filter);" />
      <MemberSignature Language="F#" Value="member this.Remove : System.ServiceModel.Dispatcher.XPathMessageFilter -&gt; bool" Usage="xPathMessageFilterTable.Remove filter" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="filter" Type="System.ServiceModel.Dispatcher.XPathMessageFilter" />
      </Parameters>
      <Docs>
        <param name="filter">
          <see cref="T:System.ServiceModel.Dispatcher.XPathMessageFilter" /> que se va a quitar.</param>
        <summary>Quita un <see cref="T:System.ServiceModel.Dispatcher.XPathMessageFilter" /> y sus datos del filtro asociados de la tabla de filtro.</summary>
        <returns>
          <see langword="true" /> si <see cref="T:System.ServiceModel.Dispatcher.XPathMessageFilter" /> se ha encontrado y eliminado; en caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método no produce una excepción si el filtro especificado no existe en la tabla de filtro.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El valor de <paramref name="filter" /> es <see langword="null" />.</exception>
        <exception cref="T:System.InvalidCastException">
          <paramref name="filter" /> no es un objeto <see cref="T:System.ServiceModel.Dispatcher.XPathMessageFilter" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IEnumerable.GetEnumerator">
      <MemberSignature Language="C#" Value="System.Collections.IEnumerator IEnumerable.GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Dispatcher.XPathMessageFilterTable`1.System#Collections#IEnumerable#GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Function GetEnumerator () As IEnumerator Implements IEnumerable.GetEnumerator" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Collections::IEnumerator ^ System.Collections.IEnumerable.GetEnumerator() = System::Collections::IEnumerable::GetEnumerator;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IEnumerable.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Devuelve un enumerador que puede recorrer en iteración la tabla de filtros.</summary>
        <returns>Un <see cref="T:System.Collections.Generic.IEnumerator`1" />&lt;KeyValuePair&lt;Filter, FilterData&gt;&gt; que se puede usar para iterar en la tabla de filtros.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método implementa <xref:System.Collections.Generic.SynchronizedCollection%601.GetEnumerator%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TrimToSize">
      <MemberSignature Language="C#" Value="public void TrimToSize ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void TrimToSize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Dispatcher.XPathMessageFilterTable`1.TrimToSize" />
      <MemberSignature Language="VB.NET" Value="Public Sub TrimToSize ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void TrimToSize();" />
      <MemberSignature Language="F#" Value="member this.TrimToSize : unit -&gt; unit" Usage="xPathMessageFilterTable.TrimToSize " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Compacta la tabla de filtro purgando las asignaciones o los búferes excesivos.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método es conceptualmente equivalente a establecer la capacidad de una colección a su recuento.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TryGetValue">
      <MemberSignature Language="C#" Value="public bool TryGetValue (System.ServiceModel.Dispatcher.MessageFilter filter, out TFilterData data);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool TryGetValue(class System.ServiceModel.Dispatcher.MessageFilter filter, [out] !TFilterData&amp; data) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Dispatcher.XPathMessageFilterTable`1.TryGetValue(System.ServiceModel.Dispatcher.MessageFilter,`0@)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryGetValue (filter As MessageFilter, ByRef data As TFilterData) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool TryGetValue(System::ServiceModel::Dispatcher::MessageFilter ^ filter, [Runtime::InteropServices::Out] TFilterData % data);" />
      <MemberSignature Language="F#" Value="abstract member TryGetValue : System.ServiceModel.Dispatcher.MessageFilter *  -&gt; bool&#xA;override this.TryGetValue : System.ServiceModel.Dispatcher.MessageFilter *  -&gt; bool" Usage="xPathMessageFilterTable.TryGetValue (filter, data)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="filter" Type="System.ServiceModel.Dispatcher.MessageFilter" />
        <Parameter Name="data" Type="TFilterData" RefType="out" />
      </Parameters>
      <Docs>
        <param name="filter">Una clave para recuperar los datos.</param>
        <param name="data">
          <c>data</c> asociados con el <c>filter</c> cuando este método devuelve <see langword="true" />; en caso contrario, valor predeterminado del tipo del parámetro <c>data</c>.</param>
        <summary>Comprueba si un filtro está almacenado en la tabla de filtro.</summary>
        <returns>
          <see langword="true" /> si <paramref name="filter" /> se encuentra en la tabla de filtro; <see langword="false" /> de lo contrario.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método es una manera eficaz de comprobar si un filtro está en la tabla de filtro porque, cuando el filtro no está presente, devuelve `false` en lugar de producir una excepción. Si intenta recuperar el filtro de la tabla utilizando su propiedad `Item` (el indizador en C#) y no está allí, se produce una excepción.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Values">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.ICollection&lt;TFilterData&gt; Values { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.ICollection`1&lt;!TFilterData&gt; Values" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.Dispatcher.XPathMessageFilterTable`1.Values" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Values As ICollection(Of TFilterData)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::Generic::ICollection&lt;TFilterData&gt; ^ Values { System::Collections::Generic::ICollection&lt;TFilterData&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Values : System.Collections.Generic.ICollection&lt;'FilterData&gt;" Usage="System.ServiceModel.Dispatcher.XPathMessageFilterTable&lt;'FilterData&gt;.Values" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.Generic.IDictionary`2.Values</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.ICollection&lt;TFilterData&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene una colección de todos los <paramref name="FilterData" /> contenidos en <see cref="T:System.ServiceModel.Dispatcher.XPathMessageFilterTable`1" />.</summary>
        <value>
          <see cref="T:System.Collections.Generic.ICollection`1" /> de todos los <paramref name="FilterData" /> contenidos en la tabla de filtro.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esta propiedad implementa <xref:System.Collections.Generic.IDictionary%602.Values%2A>. El <xref:System.Collections.Generic.IDictionary%602><Filtro, `FilterData`> implementado por la tabla de filtro utiliza <xref:System.ServiceModel.Dispatcher.MessageFilter> como clave y `FilterData` como valor del par.  
  
 El orden de los `FilterData` devueltos en la colección no está especificado, pero se garantiza que será el mismo orden que el de los filtros correspondientes en la colección devuelta por la propiedad <xref:System.ServiceModel.Dispatcher.XPathMessageFilterTable%601.Keys%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>