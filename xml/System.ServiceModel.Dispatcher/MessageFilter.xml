<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="MessageFilter.xml" source-language="en-US" target-language="es-ES">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-15c36f0" tool-company="Microsoft" />
      <xliffext:skl_file_name xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">02cd5861-7ce2-4a82-b358-31f8435a0ac544fa6f6bb564bb469186db822d7d73979753126e.skl</xliffext:skl_file_name>
      <xliffext:version xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">1.2</xliffext:version>
      <xliffext:ms.openlocfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">44fa6f6bb564bb469186db822d7d73979753126e</xliffext:ms.openlocfilehash>
      <xliffext:ms.sourcegitcommit xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b</xliffext:ms.sourcegitcommit>
      <xliffext:ms.lasthandoff xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">04/03/2018</xliffext:ms.lasthandoff>
      <xliffext:moniker_ids xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">netframework-4.5.1,netframework-4.5.2,netframework-4.5,netframework-4.6.1,netframework-4.6.2,netframework-4.6,netframework-4.7.1,netframework-4.7,xamarinmac-3.0</xliffext:moniker_ids>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve" uid="T:System.ServiceModel.Dispatcher.MessageFilter">
          <source><ph id="ph1">&lt;see langword="abstract" /&gt;</ph> base class for different classes of filters used to query messages.</source>
          <target state="translated">Clase base <ph id="ph1">&lt;see langword="abstract" /&gt;</ph> para distintas clases de filtros utilizadas para realizar consultas en mensajes.</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.ServiceModel.Dispatcher.MessageFilter">
          <source><ph id="ph1">&lt;xref:System.ServiceModel.Dispatcher.MessageFilter&gt;</ph> is an <ph id="ph2">`abstract`</ph> class that developers implement in order to specify the criteria to use for inspecting messages.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.ServiceModel.Dispatcher.MessageFilter&gt;</ph> es una clase <ph id="ph2">`abstract`</ph> que los desarrolladores implementan para especificar los criterios que se van a usar para inspeccionar los mensajes.</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.ServiceModel.Dispatcher.MessageFilter">
          <source>Typically, filters are used by an endpoint application to determine what to do with a message based on an examination of some part of the message.</source>
          <target state="translated">Normalmente, una aplicación de extremo utiliza filtros para determinar qué hacer con un mensaje en función de un examen de alguna parte del mensaje.</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.ServiceModel.Dispatcher.MessageFilter">
          <source>A queuing process, for example, can use an XPath 1.0 query to check the priority element of a known header to determine whether to move a message to the front of the queue.</source>
          <target state="translated">Un proceso de cola, por ejemplo, puede utilizar una consulta de XPath 1.0 para comprobar el elemento de prioridad de un encabezado conocido para determinar si poner un mensaje al principio de la cola.</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.ServiceModel.Dispatcher.MessageFilter">
          <source>Filters are stored in a filter table that implements <ph id="ph1">&lt;xref:System.ServiceModel.Dispatcher.IMessageFilterTable%601&gt;</ph>.</source>
          <target state="translated">Los filtros se almacenan en una tabla de filtros que implementa <ph id="ph1">&lt;xref:System.ServiceModel.Dispatcher.IMessageFilterTable%601&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.ServiceModel.Dispatcher.MessageFilter">
          <source>Each filter in the table is associated with specified filter data that can be used to indicate what actions to take if a message matches the filter.</source>
          <target state="translated">Cada filtro de la tabla está asociado a datos de filtro especificados que se pueden utilizar para indicar qué acciones se deben tomar si un mensaje coincide con el filtro.</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.ServiceModel.Dispatcher.MessageFilter">
          <source>The <ph id="ph1">&lt;xref:System.ServiceModel.Dispatcher.MessageFilter.Match%2A&gt;</ph> methods are used to determine if a message satisfies a filter.</source>
          <target state="translated">Los métodos de <ph id="ph1">&lt;xref:System.ServiceModel.Dispatcher.MessageFilter.Match%2A&gt;</ph> se utilizan para determinar si un mensaje satisface un filtro.</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.ServiceModel.Dispatcher.MessageFilter">
          <source>The criteria used by a filter cannot be changed once the filter is constructed because the filter tables have no way to detect a change.</source>
          <target state="translated">Los criterios utilizados por un filtro no se pueden cambiar una vez que se ha construido el filtro, porque las tablas de filtros no cuentan con una forma de detectar cambios.</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.ServiceModel.Dispatcher.MessageFilter">
          <source>The only way to modify the criteria of a filter is to construct a new one and delete the existing filter.</source>
          <target state="translated">La única manera de modificar los criterios de un filtro es la de construir otro y eliminar el filtro existente.</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.ServiceModel.Dispatcher.MessageFilter">
          <source>The following classes implement the <ph id="ph1">`abstract`</ph><ph id="ph2">&lt;xref:System.ServiceModel.Dispatcher.MessageFilter&gt;</ph> class:</source>
          <target state="translated">Las clases siguientes implementan la clase <ph id="ph1">`abstract`</ph><ph id="ph2">&lt;xref:System.ServiceModel.Dispatcher.MessageFilter&gt;</ph>:</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.ServiceModel.Dispatcher.MessageFilter">
          <source><ph id="ph1">&lt;xref:System.ServiceModel.Dispatcher.XPathMessageFilter&gt;</ph> uses an XPath 1.0 expression to specify the criteria for a match.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.ServiceModel.Dispatcher.XPathMessageFilter&gt;</ph> utiliza una expresión XPath 1.0 para especificar los criterios de una coincidencia.</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.ServiceModel.Dispatcher.MessageFilter">
          <source><ph id="ph1">&lt;xref:System.ServiceModel.Dispatcher.MatchAllMessageFilter&gt;</ph> matches all messages.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.ServiceModel.Dispatcher.MatchAllMessageFilter&gt;</ph> hace que coincidan todos los mensajes.</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.ServiceModel.Dispatcher.MessageFilter">
          <source><ph id="ph1">&lt;xref:System.ServiceModel.Dispatcher.MatchNoneMessageFilter&gt;</ph> matches none of the messages.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.ServiceModel.Dispatcher.MatchNoneMessageFilter&gt;</ph> hace que no coincida ninguno de los mensajes.</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.ServiceModel.Dispatcher.MessageFilter">
          <source><ph id="ph1">&lt;xref:System.ServiceModel.Dispatcher.ActionMessageFilter&gt;</ph> tests whether the action of a message is one of a specified set of actions.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.ServiceModel.Dispatcher.ActionMessageFilter&gt;</ph> prueba si la acción de un mensaje forma parte de un conjunto especificado de acciones.</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.ServiceModel.Dispatcher.MessageFilter">
          <source><ph id="ph1">&lt;xref:System.ServiceModel.Dispatcher.EndpointAddressMessageFilter&gt;</ph> tests whether a message satisfies a specified endpoint address.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.ServiceModel.Dispatcher.EndpointAddressMessageFilter&gt;</ph> prueba si un mensaje satisface una dirección de extremo especificada.</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.ServiceModel.Dispatcher.MessageFilter">
          <source><ph id="ph1">&lt;xref:System.ServiceModel.Channels.ChannelListenerBase%601&gt;</ph> is an <ph id="ph2">`abstract`</ph> base class that you can use for writing non-queuing listeners.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.ServiceModel.Channels.ChannelListenerBase%601&gt;</ph> es una clase base <ph id="ph2">`abstract`</ph> que se puede utilizar para escribir agentes de escucha que no se ponen en cola.</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve" uid="M:System.ServiceModel.Dispatcher.MessageFilter.#ctor">
          <source>When called in a derived class, initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.ServiceModel.Dispatcher.MessageFilter" /&gt;</ph> class.</source>
          <target state="translated">Cuando se llama en una clase derivada, inicializa una nueva instancia de la clase <ph id="ph1">&lt;see cref="T:System.ServiceModel.Dispatcher.MessageFilter" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.ServiceModel.Dispatcher.MessageFilter.#ctor">
          <source>The constructor is protected so that only filters that derive from <ph id="ph1">&lt;xref:System.ServiceModel.Dispatcher.MessageFilter&gt;</ph> can be instantiated.</source>
          <target state="translated">Se protege el constructor de forma que sólo se puedan crear instancias de los filtros derivados de <ph id="ph1">&lt;xref:System.ServiceModel.Dispatcher.MessageFilter&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.ServiceModel.Dispatcher.MessageFilter.CreateFilterTable``1">
          <source>Data associated with the filters in the table.</source>
          <target state="translated">Datos asociados a los filtros de la tabla.</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve" uid="M:System.ServiceModel.Dispatcher.MessageFilter.CreateFilterTable``1">
          <source>Creates a filter table for a filter that has a specified type of data associated with it.</source>
          <target state="translated">Crea una tabla de filtros para un filtro que tiene un tipo de datos especificado asociado.</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve" uid="M:System.ServiceModel.Dispatcher.MessageFilter.CreateFilterTable``1">
          <source>An <ph id="ph1">&lt;see cref="T:System.ServiceModel.Dispatcher.IMessageFilterTable`1" /&gt;</ph> object to which filters associated with <ph id="ph2">&lt;paramref name="FilterData" /&gt;</ph> can be added.</source>
          <target state="translated">Objeto <ph id="ph1">&lt;see cref="T:System.ServiceModel.Dispatcher.IMessageFilterTable`1" /&gt;</ph> al que se pueden agregar filtros asociados a <ph id="ph2">&lt;paramref name="FilterData" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.ServiceModel.Dispatcher.MessageFilter.CreateFilterTable``1">
          <source>This method is intended to be called by <ph id="ph1">&lt;xref:System.ServiceModel.Dispatcher.MessageFilterTable%601&gt;</ph>.</source>
          <target state="translated">Este método está pensado para que lo llame <ph id="ph1">&lt;xref:System.ServiceModel.Dispatcher.MessageFilterTable%601&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.ServiceModel.Dispatcher.MessageFilter.CreateFilterTable``1">
          <source>Users should create a filter table by calling a constructor for the filter table.</source>
          <target state="translated">Los usuarios deben crear una tabla de filtros llamando a un constructor para la tabla de filtros.</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.ServiceModel.Dispatcher.MessageFilter.CreateFilterTable``1">
          <source>The default implementation of this method returns a filter table that calls the <ph id="ph1">&lt;xref:System.ServiceModel.Dispatcher.MessageFilter.Match%2A&gt;</ph> method of each filter sequentially.</source>
          <target state="translated">La implementación predeterminada de este método devuelve una tabla de filtros que llama al método <ph id="ph1">&lt;xref:System.ServiceModel.Dispatcher.MessageFilter.Match%2A&gt;</ph> de cada filtro de forma secuencial.</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.ServiceModel.Dispatcher.MessageFilter.CreateFilterTable``1">
          <source>Override this method to associate a custom filter table when implementing a filter.</source>
          <target state="translated">Invalide este método para asociar una tabla de filtros personalizada al implementar un filtro.</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve" uid="T:System.ServiceModel.Dispatcher.MessageFilter">
          <source>When overridden in a derived class, tests whether a message or a buffered message satisfies the criteria of a filter.</source>
          <target state="translated">Si se invalida en una clase derivada, prueba si un mensaje o un mensaje almacenado en búfer satisface los criterios de un filtro.</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.ServiceModel.Dispatcher.MessageFilter">
          <source>The difference between the two overloads is that one takes a <ph id="ph1">&lt;xref:System.ServiceModel.Channels.Message&gt;</ph> parameter and is not permitted to examine the body.</source>
          <target state="translated">La diferencia entre las dos sobrecargas es que una toma un parámetro <ph id="ph1">&lt;xref:System.ServiceModel.Channels.Message&gt;</ph> y no puede examinar el cuerpo del mensaje.</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.ServiceModel.Dispatcher.MessageFilter">
          <source>The other takes a <ph id="ph1">&lt;xref:System.ServiceModel.Channels.MessageBuffer&gt;</ph> parameter and can examine any part of the message.</source>
          <target state="translated">La otra toma un parámetro <ph id="ph1">&lt;xref:System.ServiceModel.Channels.MessageBuffer&gt;</ph> y puede examinar cualquier parte del mensaje.</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.ServiceModel.Dispatcher.MessageFilter">
          <source>Message headers are automatically buffered and can be inspected by a filter without being consumed.</source>
          <target state="translated">Los encabezados de mensaje se almacenan en búfer automáticamente y un filtro puede inspeccionarlos sin utilizarse.</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.ServiceModel.Dispatcher.MessageFilter">
          <source>But if the body is to be inspected by a filter, then the entire message must be buffered because an unbuffered message body can be consumed by a query and its contents destroyed.</source>
          <target state="translated">Pero si un filtro debe inspeccionar el cuerpo del mensaje, el mensaje completo debe estar almacenado en búfer porque el cuerpo de mensaje sin almacenar en búfer puede ser utilizado por una consulta, y su contenido se destruye.</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.ServiceModel.Dispatcher.MessageFilter">
          <source>Use <ph id="ph1">&lt;xref:System.ServiceModel.Dispatcher.MessageFilter.Match%2A&gt;</ph> if examination of the body is not required.</source>
          <target state="translated">Use <ph id="ph1">&lt;xref:System.ServiceModel.Dispatcher.MessageFilter.Match%2A&gt;</ph> si no es necesario que se examine el cuerpo del mensaje.</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.ServiceModel.Dispatcher.MessageFilter">
          <source>Use <ph id="ph1">&lt;xref:System.ServiceModel.Dispatcher.MessageFilter.Match%2A&gt;</ph> if examination of the message body is required.</source>
          <target state="translated">Use <ph id="ph1">&lt;xref:System.ServiceModel.Dispatcher.MessageFilter.Match%2A&gt;</ph> si es necesario que examinar el cuerpo del mensaje.</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.ServiceModel.Dispatcher.MessageFilter">
          <source><ph id="ph1">&lt;see langword="Null" /&gt;</ph> messages are invalid, and should cause an <ph id="ph2">&lt;see cref="T:System.ArgumentNullException" /&gt;</ph> to be thrown.</source>
          <target state="translated">Los mensajes <ph id="ph1">&lt;see langword="Null" /&gt;</ph> no son válidos y deben hacer que se inicie una <ph id="ph2">&lt;see cref="T:System.ArgumentNullException" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve" uid="M:System.ServiceModel.Dispatcher.MessageFilter.Match(System.ServiceModel.Channels.Message)">
          <source>The <ph id="ph1">&lt;see cref="T:System.ServiceModel.Channels.Message" /&gt;</ph> object to test.</source>
          <target state="translated">Objeto <ph id="ph1">&lt;see cref="T:System.ServiceModel.Channels.Message" /&gt;</ph> que se va a probar.</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve" uid="M:System.ServiceModel.Dispatcher.MessageFilter.Match(System.ServiceModel.Channels.Message)">
          <source>When overridden in a derived class, tests whether a message satisfies the filter criteria.</source>
          <target state="translated">Si se invalida en una clase derivada, prueba si un mensaje satisface los criterios del filtro.</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve" uid="M:System.ServiceModel.Dispatcher.MessageFilter.Match(System.ServiceModel.Channels.Message)">
          <source>The body cannot be examined.</source>
          <target state="translated">No se puede examinar el cuerpo del mensaje.</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve" uid="M:System.ServiceModel.Dispatcher.MessageFilter.Match(System.ServiceModel.Channels.Message)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the <ph id="ph2">&lt;see cref="T:System.ServiceModel.Channels.Message" /&gt;</ph> object satisfies the filter criteria; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> si el objeto <ph id="ph2">&lt;see cref="T:System.ServiceModel.Channels.Message" /&gt;</ph> satisface los criterios del filtro; de lo contrario, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.ServiceModel.Dispatcher.MessageFilter.Match(System.ServiceModel.Channels.Message)">
          <source>This method cannot inspect the contents of the message body.</source>
          <target state="translated">Este método no puede inspeccionar el contenido del cuerpo del mensaje.</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.ServiceModel.Dispatcher.MessageFilter.Match(System.ServiceModel.Channels.Message)">
          <source>If the filter attempts to examine the body of an unbuffered message, then the filter must throw an <ph id="ph1">&lt;see cref="T:System.ServiceModel.Dispatcher.InvalidBodyAccessException" /&gt;</ph>.</source>
          <target state="translated">Si un filtro intenta examinar el cuerpo de un mensaje no almacenado en búfer, dicho filtro debe iniciar <ph id="ph1">&lt;see cref="T:System.ServiceModel.Dispatcher.InvalidBodyAccessException" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.ServiceModel.Dispatcher.MessageFilter.Match(System.ServiceModel.Channels.Message)">
          <source>It should not return <ph id="ph1">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">No debe devolver <ph id="ph1">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve" uid="M:System.ServiceModel.Dispatcher.MessageFilter.Match(System.ServiceModel.Channels.MessageBuffer)">
          <source>The <ph id="ph1">&lt;see cref="T:System.ServiceModel.Channels.MessageBuffer" /&gt;</ph> object to test.</source>
          <target state="translated">Objeto <ph id="ph1">&lt;see cref="T:System.ServiceModel.Channels.MessageBuffer" /&gt;</ph> que se va a probar.</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve" uid="M:System.ServiceModel.Dispatcher.MessageFilter.Match(System.ServiceModel.Channels.MessageBuffer)">
          <source>When overridden in a derived class, tests whether a buffered message satisfies the criteria of a filter.</source>
          <target state="translated">Si se invalida en una clase derivada, prueba si un mensaje almacenado en búfer satisface los criterios de un filtro.</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve" uid="M:System.ServiceModel.Dispatcher.MessageFilter.Match(System.ServiceModel.Channels.MessageBuffer)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the <ph id="ph2">&lt;see cref="T:System.ServiceModel.Channels.MessageBuffer" /&gt;</ph> object satisfies the filter criteria; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> si el objeto <ph id="ph2">&lt;see cref="T:System.ServiceModel.Channels.MessageBuffer" /&gt;</ph> satisface los criterios del filtro; de lo contrario, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.ServiceModel.Dispatcher.MessageFilter.Match(System.ServiceModel.Channels.MessageBuffer)">
          <source>The message must be fully buffered if the body is to be inspected by the filter.</source>
          <target state="translated">El mensaje debe estar totalmente almacenado en búfer si el filtro va a inspeccionar el cuerpo.</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.ServiceModel.Dispatcher.MessageFilter.Match(System.ServiceModel.Channels.MessageBuffer)">
          <source>The body of the <ph id="ph1">&lt;xref:System.ServiceModel.Channels.MessageBuffer&gt;</ph> is fully buffered and therefore can be inspected by a filter.</source>
          <target state="translated">El cuerpo del <ph id="ph1">&lt;xref:System.ServiceModel.Channels.MessageBuffer&gt;</ph> está totalmente almacenado en búfer y, por consiguiente, puede ser inspeccionado por un filtro.</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.ServiceModel.Dispatcher.MessageFilter.Match(System.ServiceModel.Channels.MessageBuffer)">
          <source>The body of a <ph id="ph1">&lt;xref:System.ServiceModel.Channels.Message&gt;</ph> that has not been fully buffered may be consumed by the filter inspection.</source>
          <target state="translated">El cuerpo de un <ph id="ph1">&lt;xref:System.ServiceModel.Channels.Message&gt;</ph> no se ha almacenado totalmente en búfer y la inspección realizada por el filtro podría consumirlo.</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.ServiceModel.Dispatcher.MessageFilter.Match(System.ServiceModel.Channels.MessageBuffer)">
          <source>The header element of a <ph id="ph1">&lt;xref:System.ServiceModel.Channels.Message&gt;</ph> is automatically buffered and therefore can be inspected without being consumed.</source>
          <target state="translated">El elemento de encabezado de un <ph id="ph1">&lt;xref:System.ServiceModel.Channels.Message&gt;</ph> se almacena en búfer automáticamente y, por consiguiente, se puede inspeccionar sin ser consumido.</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>