<Type Name="ActivityCollection" FullName="System.Workflow.ComponentModel.ActivityCollection">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="475d0e0e4aaa11a84b0ecb960e1a3bb50640bc68" />
    <Meta Name="ms.sourcegitcommit" Value="4b4804968da1dfdf71c501075a5b66957b54f2e8" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="es-ES" />
    <Meta Name="ms.lasthandoff" Value="04/27/2018" />
    <Meta Name="ms.locfileid" Value="32037584" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class ActivityCollection : System.Collections.Generic.List&lt;System.Workflow.ComponentModel.Activity&gt;, System.Collections.Generic.ICollection&lt;System.Workflow.ComponentModel.Activity&gt;, System.Collections.Generic.IEnumerable&lt;System.Workflow.ComponentModel.Activity&gt;, System.Collections.Generic.IList&lt;System.Workflow.ComponentModel.Activity&gt;, System.Collections.IList" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit ActivityCollection extends System.Collections.Generic.List`1&lt;class System.Workflow.ComponentModel.Activity&gt; implements class System.Collections.Generic.ICollection`1&lt;class System.Workflow.ComponentModel.Activity&gt;, class System.Collections.Generic.IEnumerable`1&lt;class System.Workflow.ComponentModel.Activity&gt;, class System.Collections.Generic.IList`1&lt;class System.Workflow.ComponentModel.Activity&gt;, class System.Collections.ICollection, class System.Collections.IEnumerable, class System.Collections.IList" />
  <TypeSignature Language="DocId" Value="T:System.Workflow.ComponentModel.ActivityCollection" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class ActivityCollection&#xA;Inherits List(Of Activity)&#xA;Implements ICollection(Of Activity), IEnumerable(Of Activity), IList, IList(Of Activity)" />
  <TypeSignature Language="C++ CLI" Value="public ref class ActivityCollection sealed : System::Collections::Generic::List&lt;System::Workflow::ComponentModel::Activity ^&gt;, System::Collections::Generic::ICollection&lt;System::Workflow::ComponentModel::Activity ^&gt;, System::Collections::Generic::IEnumerable&lt;System::Workflow::ComponentModel::Activity ^&gt;, System::Collections::Generic::IList&lt;System::Workflow::ComponentModel::Activity ^&gt;, System::Collections::IList" />
  <AssemblyInfo>
    <AssemblyName>System.Workflow.ComponentModel</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Collections.Generic.List&lt;System.Workflow.ComponentModel.Activity&gt;</BaseTypeName>
    <BaseTypeArguments>
      <BaseTypeArgument TypeParamName="!0">System.Workflow.ComponentModel.Activity</BaseTypeArgument>
    </BaseTypeArguments>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Collections.Generic.ICollection&lt;System.Workflow.ComponentModel.Activity&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.Generic.IEnumerable&lt;System.Workflow.ComponentModel.Activity&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.Generic.IList&lt;System.Workflow.ComponentModel.Activity&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.IList</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.ComponentModel.Design.Serialization.DesignerSerializer(typeof(System.Workflow.ComponentModel.Serialization.ActivityCollectionMarkupSerializer), typeof(System.Workflow.ComponentModel.Serialization.WorkflowMarkupSerializer))</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Obsolete("The System.Workflow.* types are deprecated.  Instead, please use the new types from System.Activities.*")</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Modela un <see cref="T:System.Collections.ICollection" /> fuertemente tipado de <see cref="T:System.Workflow.ComponentModel.Activity" />.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  [!INCLUDE[DeprecatedContent](~/includes/deprecatedcontent-md.md)]  
  
 Esta clase se utiliza para representar la lista de actividades secundarias para <xref:System.Workflow.ComponentModel.CompositeActivity>.  
  
> [!NOTE]
>  Sólo los métodos de llamada derivan de <xref:System.Collections.Generic.IList%601> y no <xref:System.Collections.Generic.List%601>, como usar <xref:System.Workflow.ComponentModel.ActivityCollection.Add%2A> para agregar actividades en lugar de <xref:System.Collections.Generic.List%601.AddRange%2A>. Llamar a métodos derivados de <xref:System.Collections.Generic.List%601> tendrá consecuencias inesperadas.  
  
   
  
## Examples  
 El ejemplo siguiente muestra el acceso de <xref:System.Workflow.ComponentModel.ActivityCollection> que es el miembro de una clase de actividad compuesta que contiene todas las actividades secundarias. Este ejemplo de código es parte de la muestra Throw SDK y pertenece al archivo ThrowWorkflow.cs. Para obtener más información, consulte [mediante la actividad ThrowActivity](http://msdn.microsoft.com/library/82bc0fef-d78a-4750-82b4-e4cb397a10f1).  
  
 [!code-csharp[WF_Samples#179](~/samples/snippets/csharp/VS_Snippets_CFX/wf_samples/cs/snippets11.cs#179)]
 [!code-vb[WF_Samples#179](~/samples/snippets/visualbasic/VS_Snippets_CFX/wf_samples/vb/snippets11.vb#179)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public ActivityCollection (System.Workflow.ComponentModel.Activity owner);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Workflow.ComponentModel.Activity owner) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Workflow.ComponentModel.ActivityCollection.#ctor(System.Workflow.ComponentModel.Activity)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (owner As Activity)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; ActivityCollection(System::Workflow::ComponentModel::Activity ^ owner);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Workflow.ComponentModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="owner" Type="System.Workflow.ComponentModel.Activity" />
      </Parameters>
      <Docs>
        <param name="owner">
          <see cref="T:System.Workflow.ComponentModel.Activity" /> designó como poseer esta instancia.</param>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Workflow.ComponentModel.ActivityCollection" />, inicializando una clase <see cref="T:System.Workflow.ComponentModel.Activity" /> de propietario.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ejemplo  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="owner" /> es una referencia nula (<see langword="Nothing" /> en Visual Basic).</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="owner" /> no es un descendiente de <see cref="T:System.Workflow.ComponentModel.Activity" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public void Add (System.Workflow.ComponentModel.Activity item);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Add(class System.Workflow.ComponentModel.Activity item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Workflow.ComponentModel.ActivityCollection.Add(System.Workflow.ComponentModel.Activity)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Add (item As Activity)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Add(System::Workflow::ComponentModel::Activity ^ item);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.ICollection`1.Add(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Workflow.ComponentModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="System.Workflow.ComponentModel.Activity" />
      </Parameters>
      <Docs>
        <param name="item">
          <see cref="T:System.Workflow.ComponentModel.Activity" /> que se va a agregar a <see cref="T:System.Collections.ICollection" />.</param>
        <summary>Agrega <see cref="T:System.Workflow.ComponentModel.Activity" /> a <see cref="T:System.Collections.ICollection" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 El ejemplo siguiente muestra el acceso de <xref:System.Workflow.ComponentModel.ActivityCollection> que es el miembro de una clase de actividad compuesta que contiene todas las actividades secundarias. Este ejemplo también muestra el uso de <xref:System.Workflow.ComponentModel.ActivityCollection.Add%2A>. Este ejemplo de código es parte de la muestra de SDK Iniciar y pertenece al archivo ThrowWorkflow.cs. Para obtener más información, consulte [mediante la actividad ThrowActivity](http://msdn.microsoft.com/library/82bc0fef-d78a-4750-82b4-e4cb397a10f1).  
  
 [!code-csharp[WF_Samples#179](~/samples/snippets/csharp/VS_Snippets_CFX/wf_samples/cs/snippets11.cs#179)]
 [!code-vb[WF_Samples#179](~/samples/snippets/visualbasic/VS_Snippets_CFX/wf_samples/vb/snippets11.vb#179)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Clear">
      <MemberSignature Language="C#" Value="public void Clear ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Clear() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Workflow.ComponentModel.ActivityCollection.Clear" />
      <MemberSignature Language="VB.NET" Value="Public Sub Clear ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Clear();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.ICollection`1.Clear</InterfaceMember>
        <InterfaceMember>M:System.Collections.IList.Clear</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Workflow.ComponentModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Elimina todos <see cref="T:System.Workflow.ComponentModel.Activity" /> de <see cref="T:System.Collections.ICollection" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Contains">
      <MemberSignature Language="C#" Value="public bool Contains (System.Workflow.ComponentModel.Activity item);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Contains(class System.Workflow.ComponentModel.Activity item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Workflow.ComponentModel.ActivityCollection.Contains(System.Workflow.ComponentModel.Activity)" />
      <MemberSignature Language="VB.NET" Value="Public Function Contains (item As Activity) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Contains(System::Workflow::ComponentModel::Activity ^ item);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.ICollection`1.Contains(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Workflow.ComponentModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="System.Workflow.ComponentModel.Activity" />
      </Parameters>
      <Docs>
        <param name="item">
          <see cref="T:System.Workflow.ComponentModel.Activity" /> aprobándose para la pertenencia.</param>
        <summary>Proporciona una prueba para la pertenencia de <see cref="T:System.Workflow.ComponentModel.Activity" /> en <see cref="T:System.Collections.ICollection" />.</summary>
        <returns>
          <see langword="true" /> si la <see cref="T:System.Workflow.ComponentModel.Activity" /> pertenece a la <see cref="T:System.Collections.ICollection" />; de lo contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este <xref:System.Collections.ICollection> posee seguridad de tipos. Se produce una excepción en tiempo de ejecución si el elemento no es del tipo <xref:System.Workflow.ComponentModel.Activity>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Count">
      <MemberSignature Language="C#" Value="public int Count { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Count" />
      <MemberSignature Language="DocId" Value="P:System.Workflow.ComponentModel.ActivityCollection.Count" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Count As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Count { int get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.Generic.ICollection`1.Count</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Workflow.ComponentModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene el número del miembro de <see cref="T:System.Collections.ICollection" />.</summary>
        <value>Número de miembros de <see cref="T:System.Collections.ICollection" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetEnumerator">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerator&lt;System.Workflow.ComponentModel.Activity&gt; GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.IEnumerator`1&lt;class System.Workflow.ComponentModel.Activity&gt; GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Workflow.ComponentModel.ActivityCollection.GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Public Function GetEnumerator () As IEnumerator(Of Activity)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::IEnumerator&lt;System::Workflow::ComponentModel::Activity ^&gt; ^ GetEnumerator();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.IEnumerable`1.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Workflow.ComponentModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerator&lt;System.Workflow.ComponentModel.Activity&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Implementa una interfaz de enumeración a <see cref="T:System.Collections.ICollection" />.</summary>
        <returns>Devuelve un enumerador que puede iterar a través de la instancia de <see cref="T:System.Collections.ReadOnlyCollectionBase" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Los enumeradores sólo habilitan la lectura de los datos de la colección. No puede usar enumeradores para modificar la colección subyacente.  
  
 Inicialmente, el enumerador se coloca delante del primer elemento de la colección. <xref:System.Collections.IEnumerator.Reset%2A> también devuelve el enumerador a esta posición. En esta posición, la llamada a <xref:System.Collections.IEnumerator.Current%2A> provoca una excepción. Por lo tanto, debe llamar a <xref:System.Collections.IEnumerator.MoveNext%2A> para adelantar el enumerador hasta el primer elemento de la colección antes de leer el valor de <xref:System.Collections.IEnumerator.Current%2A>.  
  
 <xref:System.Collections.IEnumerator.Current%2A> devuelve el mismo objeto hasta que se llama a <xref:System.Collections.IEnumerator.MoveNext%2A> o a <xref:System.Collections.IEnumerator.Reset%2A>. <xref:System.Collections.IEnumerator.MoveNext%2A> establece <xref:System.Collections.IEnumerator.Current%2A> en el siguiente elemento.  
  
 Cuando se pasa el final de la colección, el enumerador se coloca detrás del último elemento de la colección y si se llama al método <xref:System.Collections.IEnumerator.MoveNext%2A> devuelve `false`. Si la última llamada a <xref:System.Collections.IEnumerator.MoveNext%2A> ha devuelto `false` y se realiza una llamada a la propiedad <xref:System.Collections.IEnumerator.Current%2A>, se produce una excepción.  
  
 Para volver a establecer el valor de `Current` en el primer elemento de la colección, se puede llamar primero a `Reset` y después a <xref:System.Collections.IEnumerator.MoveNext%2A>.  
  
 Un enumerador es válido mientras la colección no cambie. Si se realizan cambios en la colección (como agregar, modificar o eliminar elementos), el enumerador queda invalidado de forma irreversible y la siguiente llamada a <xref:System.Collections.IEnumerator.MoveNext%2A> o `Reset` provoca un <xref:System.InvalidOperationException>. Si la colección se modifica entre <xref:System.Collections.IEnumerator.MoveNext%2A> y <xref:System.Collections.IEnumerator.Current%2A>, <xref:System.Collections.IEnumerator.Current%2A> devolverá el elemento en el que está establecido, aunque el enumerador ya haya quedado invalidado.  
  
 El enumerador no tiene acceso exclusivo a la colección y, por tanto, la enumeración en una colección no es intrínsicamente un procedimiento seguro para subprocesos. Incluso cuando una colección está sincronizada, otros subprocesos podrían modificar la colección. Esto hace que el enumerador produzca una excepción. Con el fin de garantizar la seguridad para la ejecución de subprocesos durante la enumeración, se puede bloquear la colección durante toda la enumeración o detectar las excepciones resultantes de los cambios realizados por otros subprocesos.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public int IndexOf (System.Workflow.ComponentModel.Activity item);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOf(class System.Workflow.ComponentModel.Activity item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Workflow.ComponentModel.ActivityCollection.IndexOf(System.Workflow.ComponentModel.Activity)" />
      <MemberSignature Language="VB.NET" Value="Public Function IndexOf (item As Activity) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IndexOf(System::Workflow::ComponentModel::Activity ^ item);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.IList`1.IndexOf(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Workflow.ComponentModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="System.Workflow.ComponentModel.Activity" />
      </Parameters>
      <Docs>
        <param name="item">La actividad para la cual se adquiere el índice.</param>
        <summary>Obtiene el índice de <see cref="T:System.Workflow.ComponentModel.Activity" /> en el <see cref="T:System.Collections.ICollection" />.</summary>
        <returns>Índice de <see cref="T:System.Workflow.ComponentModel.Activity" /> en <see cref="T:System.Collections.ICollection" />. De lo contrario -1 (si <see cref="T:System.Workflow.ComponentModel.Activity" /> no está en <see cref="T:System.Collections.ICollection" />).</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esta colección posee seguridad de tipos. Se producirá una excepción en tiempo de ejecución si un elemento no es del tipo <xref:System.Workflow.ComponentModel.Activity>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public void Insert (int index, System.Workflow.ComponentModel.Activity item);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Insert(int32 index, class System.Workflow.ComponentModel.Activity item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Workflow.ComponentModel.ActivityCollection.Insert(System.Int32,System.Workflow.ComponentModel.Activity)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Insert (index As Integer, item As Activity)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Insert(int index, System::Workflow::ComponentModel::Activity ^ item);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.IList`1.Insert(System.Int32,`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Workflow.ComponentModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="item" Type="System.Workflow.ComponentModel.Activity" />
      </Parameters>
      <Docs>
        <param name="index">Índice de base cero de la colección en el que se va a insertar el elemento.</param>
        <param name="item">
          <see cref="T:System.Workflow.ComponentModel.Activity" /> que se va a insertar en la colección.</param>
        <summary>Inserta el elemento en el índice en <see cref="T:System.Collections.ICollection" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este <xref:System.Collections.ICollection> posee seguridad de tipos. Se produce una excepción en tiempo de ejecución si un elemento no es del tipo <xref:System.Workflow.ComponentModel.Activity>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Item">
      <AssemblyInfo>
        <AssemblyName>System.Workflow.ComponentModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Obtiene un elemento <see cref="T:System.Workflow.ComponentModel.Activity" /> en el <see cref="T:System.Collections.ICollection" /> por nombre o índice.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Item">
      <MemberSignature Language="C#" Value="public System.Workflow.ComponentModel.Activity this[int index] { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Workflow.ComponentModel.Activity Item(int32)" />
      <MemberSignature Language="DocId" Value="P:System.Workflow.ComponentModel.ActivityCollection.Item(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Default Public Property Item(index As Integer) As Activity" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Workflow::ComponentModel::Activity ^ default[int] { System::Workflow::ComponentModel::Activity ^ get(int index); void set(int index, System::Workflow::ComponentModel::Activity ^ value); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.Generic.IList`1.Item(System.Int32)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Workflow.ComponentModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Workflow.ComponentModel.Activity</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">Índice basado en cero en el <see cref="T:System.Collections.ICollection" />.</param>
        <summary>Obtiene o establece la actividad en <see cref="T:System.Collections.ICollection" /> según el índice.</summary>
        <value>Una actividad de miembro de <see cref="T:System.Collections.ICollection" />, cuyo el índice en <see cref="T:System.Collections.ICollection" /> se especificó en la llamada.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> no es un índice válido para <see cref="T:System.Collections.IList" />.</exception>
        <exception cref="T:System.NotSupportedException">La propiedad está establecida y <see cref="T:System.Collections.IList" /> es de solo lectura.</exception>
        <exception cref="T:System.Exception">Se ha intentado establecer <see cref="T:System.Object" /> que no es un <see cref="T:System.Workflow.ComponentModel.Activity" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Item">
      <MemberSignature Language="C#" Value="public System.Workflow.ComponentModel.Activity this[string key] { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Workflow.ComponentModel.Activity Item(string)" />
      <MemberSignature Language="DocId" Value="P:System.Workflow.ComponentModel.ActivityCollection.Item(System.String)" />
      <MemberSignature Language="VB.NET" Value="Default Public ReadOnly Property Item(key As String) As Activity" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Workflow::ComponentModel::Activity ^ default[System::String ^] { System::Workflow::ComponentModel::Activity ^ get(System::String ^ key); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Workflow.ComponentModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Workflow.ComponentModel.Activity</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="key">Identificador único para la actividad en <see cref="T:System.Collections.ICollection" />.</param>
        <summary>Obtiene la actividad en <see cref="T:System.Collections.ICollection" /> basada en la cadena que es una clave única.</summary>
        <value>Un miembro <see cref="T:System.Workflow.ComponentModel.Activity" /> de <see cref="T:System.Collections.ICollection" />; la clave en <see cref="T:System.Collections.ICollection" /> que se especificó en la llamada.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si no hay <xref:System.Workflow.ComponentModel.Activity> en <xref:System.Collections.ICollection> con clave especificada, se producirá una excepción.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ListChanged">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Workflow.ComponentModel.ActivityCollectionChangeEventArgs&gt; ListChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Workflow.ComponentModel.ActivityCollectionChangeEventArgs&gt; ListChanged" />
      <MemberSignature Language="DocId" Value="E:System.Workflow.ComponentModel.ActivityCollection.ListChanged" />
      <MemberSignature Language="VB.NET" Value="Public Event ListChanged As EventHandler(Of ActivityCollectionChangeEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler&lt;System::Workflow::ComponentModel::ActivityCollectionChangeEventArgs ^&gt; ^ ListChanged;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Workflow.ComponentModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Workflow.ComponentModel.ActivityCollectionChangeEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se eleva cuando se realiza un cambio en el contenido de <see cref="T:System.Collections.ICollection" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 En este contexto, agregar o quitar los miembros genera el evento. Al modificar un miembro, no se genera este evento.  
  
 Cuando se crea un delegado <xref:System.Workflow.ComponentModel.ActivityCollection>, se identifica el método que controlará el evento. Para asociar el evento al controlador, se debe agregar una instancia del delegado al evento. Siempre que se produce el evento, se llama a su controlador, a menos que se quite el delegado. Para obtener más información sobre los delegados de controladores de eventos, vea [controlar y provocar eventos](~/docs/standard/events/index.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Remove">
      <MemberSignature Language="C#" Value="public bool Remove (System.Workflow.ComponentModel.Activity item);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Remove(class System.Workflow.ComponentModel.Activity item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Workflow.ComponentModel.ActivityCollection.Remove(System.Workflow.ComponentModel.Activity)" />
      <MemberSignature Language="VB.NET" Value="Public Function Remove (item As Activity) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Remove(System::Workflow::ComponentModel::Activity ^ item);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.ICollection`1.Remove(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Workflow.ComponentModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="System.Workflow.ComponentModel.Activity" />
      </Parameters>
      <Docs>
        <param name="item">La actividad que se va a quitar de <see cref="T:System.Collections.ICollection" />.</param>
        <summary>Elimina la actividad especificada en la llamada de <see cref="T:System.Collections.ICollection" />.</summary>
        <returns>
          Es <see langword="true" /> si la operación se realiza correctamente; de lo contrario, es <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este <xref:System.Collections.ICollection> posee seguridad de tipos. Se produce una excepción en tiempo de ejecución si un elemento no es del tipo <xref:System.Workflow.ComponentModel.Activity>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RemoveAt">
      <MemberSignature Language="C#" Value="public void RemoveAt (int index);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void RemoveAt(int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Workflow.ComponentModel.ActivityCollection.RemoveAt(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RemoveAt (index As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void RemoveAt(int index);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.IList`1.RemoveAt(System.Int32)</InterfaceMember>
        <InterfaceMember>M:System.Collections.IList.RemoveAt(System.Int32)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Workflow.ComponentModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">Coloque en un índice de base cero para quitar la actividad de la colección.</param>
        <summary>Elimina el <see cref="T:System.Workflow.ComponentModel.Activity" /> en el <see cref="T:System.Collections.ICollection" /> en el <paramref name="index" /> especificado</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si el índice no es válido se produce una excepción en tiempo de ejecución (fuera de intervalo).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Generic.ICollection&lt;System.Workflow.ComponentModel.Activity&gt;.Add">
      <MemberSignature Language="C#" Value="void ICollection&lt;Activity&gt;.Add (System.Workflow.ComponentModel.Activity item);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Collections.Generic.ICollection&lt;System.Workflow.ComponentModel.Activity&gt;.Add(class System.Workflow.ComponentModel.Activity item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Workflow.ComponentModel.ActivityCollection.System#Collections#Generic#ICollection&lt;System#Workflow#ComponentModel#Activity&gt;#Add(System.Workflow.ComponentModel.Activity)" />
      <MemberSignature Language="VB.NET" Value="Sub Add (item As Activity) Implements ICollection(Of Activity).Add" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Collections.Generic.ICollection&lt;System.Workflow.ComponentModel.Activity&gt;.Add(System::Workflow::ComponentModel::Activity ^ item) = System::Collections::Generic::ICollection&lt;System::Workflow::ComponentModel::Activity ^&gt;::Add;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.ICollection`1.Add(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Workflow.ComponentModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="System.Workflow.ComponentModel.Activity" />
      </Parameters>
      <Docs>
        <param name="item">
          <see cref="T:System.Object" /> que se va a agregar a <see cref="T:System.Collections.IList" />.</param>
        <summary>Agrega un objeto a <see cref="T:System.Collections.IList" /> al final de <see cref="T:System.Collections.IList" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Producir una excepción con el mensaje de error "Error_InvalidListItem" si <xref:System.Object> no es del tipo <xref:System.Workflow.ComponentModel.Activity>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Generic.ICollection&lt;System.Workflow.ComponentModel.Activity&gt;.Clear">
      <MemberSignature Language="C#" Value="void ICollection&lt;Activity&gt;.Clear ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Collections.Generic.ICollection&lt;System.Workflow.ComponentModel.Activity&gt;.Clear() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Workflow.ComponentModel.ActivityCollection.System#Collections#Generic#ICollection&lt;System#Workflow#ComponentModel#Activity&gt;#Clear" />
      <MemberSignature Language="VB.NET" Value="Sub Clear () Implements ICollection(Of Activity).Clear" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Collections.Generic.ICollection&lt;System.Workflow.ComponentModel.Activity&gt;.Clear() = System::Collections::Generic::ICollection&lt;System::Workflow::ComponentModel::Activity ^&gt;::Clear;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.ICollection`1.Clear</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Workflow.ComponentModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Borra todas las actividades de <see cref="T:System.Collections.IList" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La propiedad <xref:System.Collections.CollectionBase.Count%2A> es cero una vez finalizada esta operación.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Generic.ICollection&lt;System.Workflow.ComponentModel.Activity&gt;.Contains">
      <MemberSignature Language="C#" Value="bool ICollection&lt;Activity&gt;.Contains (System.Workflow.ComponentModel.Activity item);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool System.Collections.Generic.ICollection&lt;System.Workflow.ComponentModel.Activity&gt;.Contains(class System.Workflow.ComponentModel.Activity item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Workflow.ComponentModel.ActivityCollection.System#Collections#Generic#ICollection&lt;System#Workflow#ComponentModel#Activity&gt;#Contains(System.Workflow.ComponentModel.Activity)" />
      <MemberSignature Language="VB.NET" Value="Function Contains (item As Activity) As Boolean Implements ICollection(Of Activity).Contains" />
      <MemberSignature Language="C++ CLI" Value=" virtual bool System.Collections.Generic.ICollection&lt;System.Workflow.ComponentModel.Activity&gt;.Contains(System::Workflow::ComponentModel::Activity ^ item) = System::Collections::Generic::ICollection&lt;System::Workflow::ComponentModel::Activity ^&gt;::Contains;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.ICollection`1.Contains(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Workflow.ComponentModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="System.Workflow.ComponentModel.Activity" />
      </Parameters>
      <Docs>
        <param name="item">Objeto <see cref="T:System.Object" /> que se va a buscar en la interfaz <see cref="T:System.Collections.IList" />.</param>
        <summary>Obtiene un valor que indica si <see cref="T:System.Object" /> es un miembro de la colección.</summary>
        <returns>
          <see langword="true" /> si el valor está en la colección; en caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Producir una excepción con el mensaje de error "Error_InvalidListItem" si <xref:System.Object> no es del tipo <xref:System.Workflow.ComponentModel.Activity>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Generic.ICollection&lt;System.Workflow.ComponentModel.Activity&gt;.CopyTo">
      <MemberSignature Language="C#" Value="void ICollection&lt;Activity&gt;.CopyTo (System.Workflow.ComponentModel.Activity[] array, int arrayIndex);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Collections.Generic.ICollection&lt;System.Workflow.ComponentModel.Activity&gt;.CopyTo(class System.Workflow.ComponentModel.Activity[] array, int32 arrayIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Workflow.ComponentModel.ActivityCollection.System#Collections#Generic#ICollection&lt;System#Workflow#ComponentModel#Activity&gt;#CopyTo(System.Workflow.ComponentModel.Activity[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Sub CopyTo (array As Activity(), arrayIndex As Integer) Implements ICollection(Of Activity).CopyTo" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Collections.Generic.ICollection&lt;System.Workflow.ComponentModel.Activity&gt;.CopyTo(cli::array &lt;System::Workflow::ComponentModel::Activity ^&gt; ^ array, int arrayIndex) = System::Collections::Generic::ICollection&lt;System::Workflow::ComponentModel::Activity ^&gt;::CopyTo;" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Workflow.ComponentModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Workflow.ComponentModel.Activity[]" />
        <Parameter Name="arrayIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">
          <see cref="T:System.Array" /> que es el destino de la operación de copia.</param>
        <param name="arrayIndex">Índice de base cero en el <see cref="T:System.Collections.ICollection" /> donde se comienza a copiar.</param>
        <summary>Copia los elementos de <see cref="T:System.Collections.ICollection" /> en <see cref="T:System.Array" />, empezando por un índice determinado de <see cref="T:System.Array" />.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> es una referencia nula (<see langword="Nothing" /> en Visual Basic).</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> es menor que cero.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="array" /> es multidimensional.  
  
 <paramref name="index" /> es igual o mayor que la longitud de la <paramref name="array" />.  
  
 El número de elementos de la <see cref="T:System.Collections.ICollection" /> de origen es mayor que el espacio disponible desde <paramref name="index" /> hasta el final de la matriz de destino.</exception>
        <exception cref="T:System.InvalidCastException">El tipo <see cref="T:System.Workflow.ComponentModel.Activity" /> no puede convertirse automáticamente al tipo del parámetro <paramref name="array" /> de destino.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Generic.ICollection&lt;System.Workflow.ComponentModel.Activity&gt;.Count">
      <MemberSignature Language="C#" Value="int System.Collections.Generic.ICollection&lt;System.Workflow.ComponentModel.Activity&gt;.Count { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 System.Collections.Generic.ICollection&lt;System.Workflow.ComponentModel.Activity&gt;.Count" />
      <MemberSignature Language="DocId" Value="P:System.Workflow.ComponentModel.ActivityCollection.System#Collections#Generic#ICollection&lt;System#Workflow#ComponentModel#Activity&gt;#Count" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property Count As Integer Implements ICollection(Of Activity).Count" />
      <MemberSignature Language="C++ CLI" Value="property int System.Collections.Generic.ICollection&lt;System.Workflow.ComponentModel.Activity&gt;.Count { int get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.Generic.ICollection`1.Count</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Workflow.ComponentModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene el número de elementos incluidos en <see cref="T:System.Collections.Generic.ICollection`1" />.</summary>
        <value>Número de elementos contenidos en <see cref="T:System.Collections.Generic.ICollection`1" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Generic.ICollection&lt;System.Workflow.ComponentModel.Activity&gt;.IsReadOnly">
      <MemberSignature Language="C#" Value="bool System.Collections.Generic.ICollection&lt;System.Workflow.ComponentModel.Activity&gt;.IsReadOnly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Collections.Generic.ICollection&lt;System.Workflow.ComponentModel.Activity&gt;.IsReadOnly" />
      <MemberSignature Language="DocId" Value="P:System.Workflow.ComponentModel.ActivityCollection.System#Collections#Generic#ICollection&lt;System#Workflow#ComponentModel#Activity&gt;#IsReadOnly" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsReadOnly As Boolean Implements ICollection(Of Activity).IsReadOnly" />
      <MemberSignature Language="C++ CLI" Value="property bool System.Collections.Generic.ICollection&lt;System.Workflow.ComponentModel.Activity&gt;.IsReadOnly { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.Generic.ICollection`1.IsReadOnly</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Workflow.ComponentModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene un valor que indica si <see cref="T:System.Collections.IList" /> es de solo lectura.</summary>
        <value>
          Es <see langword="true" /> si la interfaz <see cref="T:System.Collections.IList" /> es de solo lectura; de lo contrario, es <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Una colección de solo lectura no permite que se agreguen, quiten o modifiquen elementos una vez que se ha creado.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Generic.ICollection&lt;System.Workflow.ComponentModel.Activity&gt;.Remove">
      <MemberSignature Language="C#" Value="bool ICollection&lt;Activity&gt;.Remove (System.Workflow.ComponentModel.Activity item);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool System.Collections.Generic.ICollection&lt;System.Workflow.ComponentModel.Activity&gt;.Remove(class System.Workflow.ComponentModel.Activity item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Workflow.ComponentModel.ActivityCollection.System#Collections#Generic#ICollection&lt;System#Workflow#ComponentModel#Activity&gt;#Remove(System.Workflow.ComponentModel.Activity)" />
      <MemberSignature Language="VB.NET" Value="Function Remove (item As Activity) As Boolean Implements ICollection(Of Activity).Remove" />
      <MemberSignature Language="C++ CLI" Value=" virtual bool System.Collections.Generic.ICollection&lt;System.Workflow.ComponentModel.Activity&gt;.Remove(System::Workflow::ComponentModel::Activity ^ item) = System::Collections::Generic::ICollection&lt;System::Workflow::ComponentModel::Activity ^&gt;::Remove;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.ICollection`1.Remove(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Workflow.ComponentModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="System.Workflow.ComponentModel.Activity" />
      </Parameters>
      <Docs>
        <param name="item">Objeto que se va a quitar de <see cref="T:System.Collections.Generic.ICollection`1" />.</param>
        <summary>Quita la primera aparición de un objeto específico de la interfaz <see cref="T:System.Collections.Generic.ICollection`1" />.</summary>
        <returns>
          Es <see langword="true" /> si <paramref name="item" /> se ha quitado correctamente de la interfaz <see cref="T:System.Collections.Generic.ICollection`1" />; en caso contrario, es <see langword="false" />. Este método también devuelve <see langword="false" /> si no se encuentra <paramref name="item" /> en la <see cref="T:System.Collections.Generic.ICollection`1" /> original.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Las implementaciones pueden variar en la forma en que determinan la igualdad de los objetos; por ejemplo, <xref:System.Collections.Generic.List%601> utiliza <xref:System.Collections.Generic.Comparer%601.Default%2A>, mientras que <xref:System.Collections.Generic.Dictionary%602> permite al usuario especificar la implementación de <xref:System.Collections.Generic.IComparer%601> que se utilizará para comparar las claves.  
  
 En colecciones de elementos contiguos, como listas, los elementos que van a continuación del elemento eliminado se desplazan hacia arriba para ocupar el espacio libre. Si la colección está indizada, también se actualizan los índices de los elementos que se han movido. Este comportamiento no se aplica a las colecciones cuyos elementos se agrupan conceptualmente en sectores de almacenamiento, como una tabla hash.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">
          <see langword="ICollection" /> es de solo lectura.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Generic.IEnumerable&lt;System.Workflow.ComponentModel.Activity&gt;.GetEnumerator">
      <MemberSignature Language="C#" Value="System.Collections.Generic.IEnumerator&lt;System.Workflow.ComponentModel.Activity&gt; IEnumerable&lt;Activity&gt;.GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.Generic.IEnumerator`1&lt;class System.Workflow.ComponentModel.Activity&gt; System.Collections.Generic.IEnumerable&lt;System.Workflow.ComponentModel.Activity&gt;.GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Workflow.ComponentModel.ActivityCollection.System#Collections#Generic#IEnumerable&lt;System#Workflow#ComponentModel#Activity&gt;#GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Function GetEnumerator () As IEnumerator(Of Activity) Implements IEnumerable(Of Activity).GetEnumerator" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Collections::Generic::IEnumerator&lt;System::Workflow::ComponentModel::Activity ^&gt; ^ System.Collections.Generic.IEnumerable&lt;System.Workflow.ComponentModel.Activity&gt;.GetEnumerator() = System::Collections::Generic::IEnumerable&lt;System::Workflow::ComponentModel::Activity ^&gt;::GetEnumerator;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.IEnumerable`1.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Workflow.ComponentModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerator&lt;System.Workflow.ComponentModel.Activity&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Devuelve un enumerador que procesa una iteración en la colección.</summary>
        <returns>
          <see cref="T:System.Collections.Generic.IEnumerator`1" /> que se puede utilizar para recorrer en iteración la colección.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El `foreach` instrucción del lenguaje C# (`for each` en C++, `For Each` en Visual Basic) oculta la complejidad de los enumeradores. Por lo tanto, se recomienda el uso de `foreach`, en lugar de manipular directamente el enumerador.  
  
 Los enumeradores pueden usarse para leer los datos de la colección, pero no para modificar la colección subyacente.  
  
 En principio, el enumerador se coloca antes del primer elemento de la colección. En esta posición, el valor de propiedad <xref:System.Collections.Generic.IEnumerator%601.Current%2A> está sin definir. Por lo tanto, debe llamar a <xref:System.Collections.IEnumerator.MoveNext%2A> para adelantar el enumerador hasta el primer elemento de la colección antes de leer el valor de <xref:System.Collections.Generic.IEnumerator%601.Current%2A>.  
  
 <xref:System.Collections.Generic.IEnumerator%601.Current%2A> devuelve el mismo objeto hasta que se llama a <xref:System.Collections.IEnumerator.MoveNext%2A>. <xref:System.Collections.IEnumerator.MoveNext%2A> establece <xref:System.Collections.Generic.IEnumerator%601.Current%2A> en el siguiente elemento.  
  
 Si <xref:System.Collections.IEnumerator.MoveNext%2A> rebasa el final de la colección, el enumerador quedará tras el último elemento de la colección y <xref:System.Collections.IEnumerator.MoveNext%2A> devolverá el valor false. Mientras el enumerador permanezca en esta posición, las llamadas a <xref:System.Collections.IEnumerator.MoveNext%2A> seguirán devolviendo el valor false. Si la última llamada al <xref:System.Collections.IEnumerator.MoveNext%2A> devuelve el valor false, <xref:System.Collections.Generic.IEnumerator%601.Current%2A>no está definido. No puede volver a establecer la propiedad <xref:System.Collections.Generic.IEnumerator%601.Current%2A> en el primer elemento de la colección, sino que debe crear una nueva instancia del enumerador.  
  
 Un enumerador es válido mientras la colección no cambie. Si se hacen cambios en la colección (como agregar, modificar o eliminar elementos), el enumerador queda invalidado permanentemente y su comportamiento es indefinido.  
  
 El enumerador no tiene acceso exclusivo a la colección y, por tanto, la enumeración en una colección no es intrínsicamente un procedimiento seguro para subprocesos. A fin de garantizar la seguridad de los subprocesos, se puede bloquear la colección durante toda la enumeración. Para permitir que varios subprocesos obtengan acceso de lectura y escritura a la colección, debe implementar su propia sincronización.  
  
 Las implementaciones predeterminadas de las colecciones del espacio de nombres <xref:System.Collections.Generic> no están sincronizadas.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Generic.IList&lt;System.Workflow.ComponentModel.Activity&gt;.IndexOf">
      <MemberSignature Language="C#" Value="int IList&lt;Activity&gt;.IndexOf (System.Workflow.ComponentModel.Activity item);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int32 System.Collections.Generic.IList&lt;System.Workflow.ComponentModel.Activity&gt;.IndexOf(class System.Workflow.ComponentModel.Activity item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Workflow.ComponentModel.ActivityCollection.System#Collections#Generic#IList&lt;System#Workflow#ComponentModel#Activity&gt;#IndexOf(System.Workflow.ComponentModel.Activity)" />
      <MemberSignature Language="VB.NET" Value="Function IndexOf (item As Activity) As Integer Implements IList(Of Activity).IndexOf" />
      <MemberSignature Language="C++ CLI" Value=" virtual int System.Collections.Generic.IList&lt;System.Workflow.ComponentModel.Activity&gt;.IndexOf(System::Workflow::ComponentModel::Activity ^ item) = System::Collections::Generic::IList&lt;System::Workflow::ComponentModel::Activity ^&gt;::IndexOf;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.IList`1.IndexOf(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Workflow.ComponentModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="System.Workflow.ComponentModel.Activity" />
      </Parameters>
      <Docs>
        <param name="item">Objeto que se va a buscar en <see cref="T:System.Collections.IList" />.</param>
        <summary>Determina el índice de un elemento específico de <see cref="T:System.Collections.IList" />.</summary>
        <returns>Devuelve el índice de <paramref name="item" /> si se encuentra en la lista; de lo contrario, devuelve -1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si un objeto aparece varias veces en la lista, el método `IndexOf` siempre devolverá la primera instancia encontrada.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Generic.IList&lt;System.Workflow.ComponentModel.Activity&gt;.Insert">
      <MemberSignature Language="C#" Value="void IList&lt;Activity&gt;.Insert (int index, System.Workflow.ComponentModel.Activity item);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Collections.Generic.IList&lt;System.Workflow.ComponentModel.Activity&gt;.Insert(int32 index, class System.Workflow.ComponentModel.Activity item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Workflow.ComponentModel.ActivityCollection.System#Collections#Generic#IList&lt;System#Workflow#ComponentModel#Activity&gt;#Insert(System.Int32,System.Workflow.ComponentModel.Activity)" />
      <MemberSignature Language="VB.NET" Value="Sub Insert (index As Integer, item As Activity) Implements IList(Of Activity).Insert" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Collections.Generic.IList&lt;System.Workflow.ComponentModel.Activity&gt;.Insert(int index, System::Workflow::ComponentModel::Activity ^ item) = System::Collections::Generic::IList&lt;System::Workflow::ComponentModel::Activity ^&gt;::Insert;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.IList`1.Insert(System.Int32,`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Workflow.ComponentModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="item" Type="System.Workflow.ComponentModel.Activity" />
      </Parameters>
      <Docs>
        <param name="index">La posición de base cero de la inserción.</param>
        <param name="item">Objeto que se va a insertar. Debe ser del tipo <see cref="T:System.Workflow.ComponentModel.Activity" />.</param>
        <summary>Inserta una clase <see cref="T:System.Object" /> en <see cref="T:System.Collections.IList" /> en el índice de base cero especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si <xref:System.Object> no se puede convertir a <xref:System.Workflow.ComponentModel.Activity>, se eleva un <xref:System.Exception> personalizado.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Generic.IList&lt;System.Workflow.ComponentModel.Activity&gt;.Item">
      <MemberSignature Language="C#" Value="System.Workflow.ComponentModel.Activity System.Collections.Generic.IList&lt;System.Workflow.ComponentModel.Activity&gt;.Item[int index] { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Workflow.ComponentModel.Activity System.Collections.Generic.IList&lt;System.Workflow.ComponentModel.Activity&gt;.Item(int32)" />
      <MemberSignature Language="DocId" Value="P:System.Workflow.ComponentModel.ActivityCollection.System#Collections#Generic#IList&lt;System#Workflow#ComponentModel#Activity&gt;#Item(System.Int32)" />
      <MemberSignature Language="VB.NET" Value=" Property Item(index As Integer) As Activity Implements IList(Of Activity).Item" />
      <MemberSignature Language="C++ CLI" Value="property System::Workflow::ComponentModel::Activity ^ System.Collections.Generic.IList&lt;System.Workflow.ComponentModel.Activity&gt;.Item[int] { System::Workflow::ComponentModel::Activity ^ get(int index); void set(int index, System::Workflow::ComponentModel::Activity ^ value); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.Generic.IList`1.Item(System.Int32)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Workflow.ComponentModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Workflow.ComponentModel.Activity</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">Índice de base cero del elemento que se va a obtener o establecer.</param>
        <summary>Obtiene o establece el elemento en el índice especificado.</summary>
        <value>
          <see cref="T:System.Object" /> en el índice especificado.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esta propiedad permite obtener acceso a un elemento específico de la colección mediante la siguiente sintaxis: myCollection[index].  
  
 El lenguaje C# utiliza la palabra clave `this` para definir los indizadores en lugar de implementar la propiedad de `Item`. Visual Basic implementa `Item` como propiedad predeterminada, lo que proporciona la misma funcionalidad de indización.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> no es un índice válido para <see cref="T:System.Collections.IList" />.</exception>
        <exception cref="T:System.NotSupportedException">
          <see langword="ICollection" /> es de solo lectura.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Generic.IList&lt;System.Workflow.ComponentModel.Activity&gt;.RemoveAt">
      <MemberSignature Language="C#" Value="void IList&lt;Activity&gt;.RemoveAt (int index);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Collections.Generic.IList&lt;System.Workflow.ComponentModel.Activity&gt;.RemoveAt(int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Workflow.ComponentModel.ActivityCollection.System#Collections#Generic#IList&lt;System#Workflow#ComponentModel#Activity&gt;#RemoveAt(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Sub RemoveAt (index As Integer) Implements IList(Of Activity).RemoveAt" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Collections.Generic.IList&lt;System.Workflow.ComponentModel.Activity&gt;.RemoveAt(int index) = System::Collections::Generic::IList&lt;System::Workflow::ComponentModel::Activity ^&gt;::RemoveAt;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.IList`1.RemoveAt(System.Int32)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Workflow.ComponentModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">Índice de base cero del elemento que se va a quitar.</param>
        <summary>Quita el elemento de la interfaz <see cref="T:System.Collections.IList" /> que se encuentra en el índice especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 En colecciones de elementos contiguos, como listas, los elementos que van a continuación del elemento eliminado se desplazan hacia arriba para ocupar el espacio libre. Si la colección está indizada, también se actualizan los índices de los elementos que se han movido. Este comportamiento no se aplica a las colecciones cuyos elementos se agrupan conceptualmente en sectores de almacenamiento, como una tabla hash.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> no es un índice válido para <see cref="T:System.Collections.IList" />.</exception>
        <exception cref="T:System.NotSupportedException">
          <see langword="ICollection" /> es de solo lectura.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.ICollection.CopyTo">
      <MemberSignature Language="C#" Value="void ICollection.CopyTo (Array array, int index);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Collections.ICollection.CopyTo(class System.Array array, int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Workflow.ComponentModel.ActivityCollection.System#Collections#ICollection#CopyTo(System.Array,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Collections.ICollection.CopyTo(Array ^ array, int index) = System::Collections::ICollection::CopyTo;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.ICollection.CopyTo(System.Array,System.Int32)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Workflow.ComponentModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">
          <see cref="T:System.Array" /> que es el destino de la operación de copia.</param>
        <param name="index">Índice de base cero en el <see cref="T:System.Collections.ICollection" /> donde se comienza a copiar.</param>
        <summary>Copia los elementos de <see cref="T:System.Collections.ICollection" /> en <see cref="T:System.Array" />, empezando por un índice determinado de <see cref="T:System.Array" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.ICollection.IsSynchronized">
      <MemberSignature Language="C#" Value="bool System.Collections.ICollection.IsSynchronized { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Collections.ICollection.IsSynchronized" />
      <MemberSignature Language="DocId" Value="P:System.Workflow.ComponentModel.ActivityCollection.System#Collections#ICollection#IsSynchronized" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsSynchronized As Boolean Implements ICollection.IsSynchronized" />
      <MemberSignature Language="C++ CLI" Value="property bool System.Collections.ICollection.IsSynchronized { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.IsSynchronized</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Workflow.ComponentModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene un valor que indica si el acceso al objeto <see cref="T:System.Collections.Generic.ICollection`1" /> está sincronizado (es seguro para la ejecución de subprocesos).</summary>
        <value>
          <see langword="true" /> si se sincroniza el acceso al objeto <see cref="T:System.Collections.Generic.ICollection`1" />, es decir, es seguro para subprocesos; en caso contrario, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.ICollection.SyncRoot%2A> devuelve un objeto que puede utilizarse para sincronizar el acceso a <xref:System.Collections.Generic.ICollection%601>.  
  
 La mayoría de las clases de colección del espacio de nombres <xref:System.Collections?displayProperty=nameWithType> también implementan un método `Synchronized` que proporciona un contenedor sincronizado alrededor de la colección subyacente.  
  
 Enumerar una colección no es intrínsecamente un procedimiento seguro para subprocesos. Incluso cuando una colección está sincronizada, otros subprocesos todavía pueden modificarla, lo que hace que el enumerador produzca una excepción. Con el fin de garantizar la seguridad para la ejecución de subprocesos durante la enumeración, se puede bloquear la colección durante toda la enumeración o detectar las excepciones resultantes de los cambios realizados por otros subprocesos.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.ICollection.SyncRoot">
      <MemberSignature Language="C#" Value="object System.Collections.ICollection.SyncRoot { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object System.Collections.ICollection.SyncRoot" />
      <MemberSignature Language="DocId" Value="P:System.Workflow.ComponentModel.ActivityCollection.System#Collections#ICollection#SyncRoot" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property SyncRoot As Object Implements ICollection.SyncRoot" />
      <MemberSignature Language="C++ CLI" Value="property System::Object ^ System.Collections.ICollection.SyncRoot { System::Object ^ get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.SyncRoot</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Workflow.ComponentModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene un objeto que se puede usar para sincronizar el acceso a <see cref="T:System.Collections.Generic.ICollection`1" />.</summary>
        <value>Objeto que se puede usar para sincronizar el acceso a <see cref="T:System.Collections.Generic.ICollection`1" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para las colecciones cuyo almacenamiento subyacente no esté disponible públicamente, la implementación esperada tan sólo debe devolver la instancia actual. Hay que tener en cuenta que puede que el puntero que señala a la instancia actual no sea suficiente para las colecciones que contienen otras colecciones, que deben devolver la propiedad <xref:System.Collections.ICollection.SyncRoot%2A> de la colección subyacente.  
  
 La mayoría de las clases de colección del espacio de nombres <xref:System.Collections?displayProperty=nameWithType> también implementan un método `Synchronized` que proporciona un contenedor sincronizado alrededor de la colección subyacente. Sin embargo, las clases derivadas pueden proporcionar su propia versión sincronizada de la colección mediante la propiedad <xref:System.Workflow.ComponentModel.ActivityCollection.System%23Collections%23ICollection%23SyncRoot>. El código de la sincronización debe realizar las operaciones en la propiedad <xref:System.Workflow.ComponentModel.ActivityCollection.System%23Collections%23ICollection%23SyncRoot> de la colección, y no directamente en la colección. De este modo, se garantiza el funcionamiento correcto de las colecciones derivadas de otros objetos. En concreto, mantiene la sincronización correcta con otros subprocesos que podrían modificar al mismo tiempo la instancia de la colección.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IEnumerable.GetEnumerator">
      <MemberSignature Language="C#" Value="System.Collections.IEnumerator IEnumerable.GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Workflow.ComponentModel.ActivityCollection.System#Collections#IEnumerable#GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Function GetEnumerator () As IEnumerator Implements IEnumerable.GetEnumerator" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Collections::IEnumerator ^ System.Collections.IEnumerable.GetEnumerator() = System::Collections::IEnumerable::GetEnumerator;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IEnumerable.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Workflow.ComponentModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Devuelve un <see cref="T:System.Collections.IEnumerator" /> que recorre en iteración las <see cref="T:System.Collections.IList" /> subyacentes.</summary>
        <returns>
          <see cref="T:System.Collections.IEnumerator" /> que se puede utilizar para recorrer en iteración la colección.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un <xref:System.Collections.IEnumerator> sólo permite la lectura de datos de la colección. No puede utilizar un <xref:System.Collections.IEnumerator> para modificar la colección subyacente.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.Add">
      <MemberSignature Language="C#" Value="int IList.Add (object value);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int32 System.Collections.IList.Add(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Workflow.ComponentModel.ActivityCollection.System#Collections#IList#Add(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Function Add (value As Object) As Integer Implements IList.Add" />
      <MemberSignature Language="C++ CLI" Value=" virtual int System.Collections.IList.Add(System::Object ^ value) = System::Collections::IList::Add;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IList.Add(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Workflow.ComponentModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">
          <see cref="T:System.Object" /> que se va a agregar a <see cref="T:System.Collections.IList" />.</param>
        <summary>Agrega un objeto a <see cref="T:System.Collections.IList" /> al final de <see cref="T:System.Collections.IList" />.</summary>
        <returns>Devuelve <see cref="T:System.Int32" />.  
  
 El índice de base cero <see cref="T:System.Object" /> agregado recientemente.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.Clear">
      <MemberSignature Language="C#" Value="void IList.Clear ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Collections.IList.Clear() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Workflow.ComponentModel.ActivityCollection.System#Collections#IList#Clear" />
      <MemberSignature Language="VB.NET" Value="Sub Clear () Implements IList.Clear" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Collections.IList.Clear() = System::Collections::IList::Clear;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IList.Clear</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Workflow.ComponentModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Quita todos los <see cref="T:System.Workflow.ComponentModel.Activity" /> de <see cref="T:System.Collections.ICollection" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.Contains">
      <MemberSignature Language="C#" Value="bool IList.Contains (object value);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool System.Collections.IList.Contains(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Workflow.ComponentModel.ActivityCollection.System#Collections#IList#Contains(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Function Contains (value As Object) As Boolean Implements IList.Contains" />
      <MemberSignature Language="C++ CLI" Value=" virtual bool System.Collections.IList.Contains(System::Object ^ value) = System::Collections::IList::Contains;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IList.Contains(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Workflow.ComponentModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">Objeto <see cref="T:System.Object" /> que se va a buscar en la interfaz <see cref="T:System.Collections.IList" />.</param>
        <summary>Obtiene un valor que indica si <see cref="T:System.Object" /> es un miembro de la colección.</summary>
        <returns>Devuelve <see cref="T:System.Boolean" /><see langword="true" /> si <paramref name="value" /> está en la colección; de lo contrario, devuelve <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.IndexOf">
      <MemberSignature Language="C#" Value="int IList.IndexOf (object value);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int32 System.Collections.IList.IndexOf(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Workflow.ComponentModel.ActivityCollection.System#Collections#IList#IndexOf(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Function IndexOf (value As Object) As Integer Implements IList.IndexOf" />
      <MemberSignature Language="C++ CLI" Value=" virtual int System.Collections.IList.IndexOf(System::Object ^ value) = System::Collections::IList::IndexOf;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IList.IndexOf(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Workflow.ComponentModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">
          <see cref="T:System.Object" /> que se va a indizar.</param>
        <summary>Obtiene el índice de base cero de <see cref="T:System.Object" /> en la colección de actividades subyacentes.</summary>
        <returns>Índice de base cero de <paramref name="value" /> en la colección de actividades subyacentes o -1 no se encuentra en la colección.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="value" /> no es de tipo <see cref="T:System.Workflow.ComponentModel.Activity" /> y el objeto de excepción contiene un mensaje de error "Error_InvalidListItem".</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.Insert">
      <MemberSignature Language="C#" Value="void IList.Insert (int index, object value);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Collections.IList.Insert(int32 index, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Workflow.ComponentModel.ActivityCollection.System#Collections#IList#Insert(System.Int32,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Sub Insert (index As Integer, value As Object) Implements IList.Insert" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Collections.IList.Insert(int index, System::Object ^ value) = System::Collections::IList::Insert;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IList.Insert(System.Int32,System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Workflow.ComponentModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="index">La posición de base cero de la inserción.</param>
        <param name="value">Objeto que se va a insertar. Debe ser del tipo <see cref="T:System.Workflow.ComponentModel.Activity" />.</param>
        <summary>Inserta una clase <see cref="T:System.Object" /> en <see cref="T:System.Collections.IList" /> en el índice de base cero especificado.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.IsFixedSize">
      <MemberSignature Language="C#" Value="bool System.Collections.IList.IsFixedSize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Collections.IList.IsFixedSize" />
      <MemberSignature Language="DocId" Value="P:System.Workflow.ComponentModel.ActivityCollection.System#Collections#IList#IsFixedSize" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsFixedSize As Boolean Implements IList.IsFixedSize" />
      <MemberSignature Language="C++ CLI" Value="property bool System.Collections.IList.IsFixedSize { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.IList.IsFixedSize</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Workflow.ComponentModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene un valor que indica si la interfaz <see cref="T:System.Collections.IList" /> tiene un tamaño fijo.</summary>
        <value>
          Es <see langword="true" /> si la interfaz <see cref="T:System.Collections.IList" /> tiene un tamaño fijo; de lo contrario, es <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Una colección de tamaño fijo no permite agregar o quitar elementos una vez que se ha creado, pero sí permite modificar los elementos existentes.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.IsReadOnly">
      <MemberSignature Language="C#" Value="bool System.Collections.IList.IsReadOnly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Collections.IList.IsReadOnly" />
      <MemberSignature Language="DocId" Value="P:System.Workflow.ComponentModel.ActivityCollection.System#Collections#IList#IsReadOnly" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsReadOnly As Boolean Implements IList.IsReadOnly" />
      <MemberSignature Language="C++ CLI" Value="property bool System.Collections.IList.IsReadOnly { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.IList.IsReadOnly</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Workflow.ComponentModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene un valor que indica si <see cref="T:System.Collections.Generic.ICollection`1" /> es de solo lectura.</summary>
        <value>Devuelve <see cref="T:System.Boolean" /><see langword="true" /> si <see cref="T:System.Collections.Generic.ICollection`1" /> es de solo lectura; de lo contrario, devuelve <see langword="false" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.Item">
      <MemberSignature Language="C#" Value="object System.Collections.IList.Item[int index] { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object System.Collections.IList.Item(int32)" />
      <MemberSignature Language="DocId" Value="P:System.Workflow.ComponentModel.ActivityCollection.System#Collections#IList#Item(System.Int32)" />
      <MemberSignature Language="VB.NET" Value=" Property Item(index As Integer) As Object Implements IList.Item" />
      <MemberSignature Language="C++ CLI" Value="property System::Object ^ System.Collections.IList.Item[int] { System::Object ^ get(int index); void set(int index, System::Object ^ value); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.IList.Item(System.Int32)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Workflow.ComponentModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">Índice basado en cero en el <see cref="T:System.Collections.ICollection" />.</param>
        <summary>Obtiene o establece la actividad en <see cref="T:System.Collections.ICollection" /> según el índice.</summary>
        <value>Devuelve <see cref="T:System.Object" />, una actividad de miembro de <see cref="T:System.Collections.ICollection" />, cuyo índice en <see cref="T:System.Collections.ICollection" /> se especificó en la llamada.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.Remove">
      <MemberSignature Language="C#" Value="void IList.Remove (object value);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Collections.IList.Remove(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Workflow.ComponentModel.ActivityCollection.System#Collections#IList#Remove(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Sub Remove (value As Object) Implements IList.Remove" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Collections.IList.Remove(System::Object ^ value) = System::Collections::IList::Remove;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IList.Remove(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Workflow.ComponentModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">
          <see cref="T:System.Object" /> que se va a quitar de <see cref="T:System.Collections.IList" />.</param>
        <summary>Quita la primera aparición de un objeto específico de la interfaz <see cref="T:System.Collections.IList" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Los elementos que siguen al elemento eliminado ascienden hasta ocupar la posición vacante.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">
          <see cref="T:System.Collections.IList" /> es de solo lectura.  
  
 El objeto <see cref="T:System.Collections.IList" /> tiene un tamaño fijo.</exception>
      </Docs>
    </Member>
  </Members>
</Type>