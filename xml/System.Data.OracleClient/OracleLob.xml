<Type Name="OracleLob" FullName="System.Data.OracleClient.OracleLob">
  <Metadata><Meta Name="ms.openlocfilehash" Value="9b2639e239210ebe728a40503f974e5c84411b76" /><Meta Name="ms.sourcegitcommit" Value="1654a92bac785a221098172d9cacd405ceaac9b7" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="es-ES" /><Meta Name="ms.lasthandoff" Value="12/01/2018" /><Meta Name="ms.locfileid" Value="52740628" /></Metadata><TypeSignature Language="C#" Value="public sealed class OracleLob : System.IO.Stream, ICloneable, System.Data.SqlTypes.INullable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit OracleLob extends System.IO.Stream implements class System.Data.SqlTypes.INullable, class System.ICloneable, class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:System.Data.OracleClient.OracleLob" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class OracleLob&#xA;Inherits Stream&#xA;Implements ICloneable, INullable" />
  <TypeSignature Language="C++ CLI" Value="public ref class OracleLob sealed : System::IO::Stream, ICloneable, System::Data::SqlTypes::INullable" />
  <TypeSignature Language="F#" Value="type OracleLob = class&#xA;    inherit Stream&#xA;    interface ICloneable&#xA;    interface IDisposable&#xA;    interface INullable" />
  <AssemblyInfo>
    <AssemblyName>System.Data.OracleClient</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.IO.Stream</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Data.SqlTypes.INullable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.ICloneable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>Representa un tipo de datos <see langword="LOB" /> (objeto binario grande) almacenado en un servidor Oracle. Esta clase no puede heredarse.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un <xref:System.Data.OracleClient.OracleLob> difiere un <xref:System.Data.OracleClient.OracleBFile> en que los datos se almacenan en el servidor en lugar de en un archivo físico en el sistema operativo. También puede ser un objeto de lectura y escritura, a diferencia de un <xref:System.Data.OracleClient.OracleBFile>, que siempre es de solo lectura.  
  
 Un <xref:System.Data.OracleClient.OracleLob> puede ser uno de estos <xref:System.Data.OracleClient.OracleType> tipos de datos.  
  
|Tipo de datos de OracleType|Descripción|  
|--------------------------|-----------------|  
|`Blob`|Oracle `BLOB` tipo de datos que contiene datos binarios con un tamaño máximo de 4 gigabytes (GB). Se asigna a una <xref:System.Array> de tipo <xref:System.Byte>.|  
|`Clob`|Oracle `CLOB` tipo de datos que contiene datos de caracteres, según el carácter predeterminado se establece en el servidor, con un tamaño máximo de 4 GB. Se asigna a <xref:System.String>.|  
|`NClob`|Oracle `NCLOB` tipo de datos que contiene datos de caracteres, según el juego en el servidor con un tamaño máximo de 4 GB de caracteres nacional. Se asigna a <xref:System.String>.|  
  
 Un desarrollador de aplicaciones .NET puede recuperar el Oracle `LOB` los valores en tipos de datos básicos. NET, como <xref:System.Array> de tipo <xref:System.Byte> y <xref:System.String>, o el especializado <xref:System.Data.OracleClient.OracleLob> tipo de datos. El <xref:System.Data.OracleClient.OracleLob> clase admite leer y escribir en Oracle `LOB` en la base de datos de Oracle.  
  
 Los siguientes son las principales características de un <xref:System.Data.OracleClient.OracleLob> tipo de datos que se diferencian de los tipos de datos básicos. NET:  
  
-   Después de recuperar el Oracle `LOB` valor de la base de datos de Oracle en el <xref:System.Data.OracleClient.OracleLob> (clase), puede cambiar el `LOB` datos en una transacción abierta y los cambios se reflejan directamente a la base de datos. Si recupera Oracle `LOB` valor en un <xref:System.Array> de tipo <xref:System.Byte> o <xref:System.String> y actualizar estas matrices, los cambios no se reflejan en la base de datos.  
  
-   Cuando se usa el <xref:System.Data.OracleClient.OracleLob> clase para tener acceso a un fragmento de un `LOB` valor, solo se pasará ese fragmento de la base de datos de Oracle al cliente. Cuando se usa el <xref:System.Data.OracleClient.OracleDataReader.GetChars%2A> método para acceder a un fragmento de un `LOB` valor, todo el contenido del valor se pasa desde la base de datos de Oracle al cliente.  
  
 Para obtener un <xref:System.Data.OracleClient.OracleLob> de objeto, llame a la <xref:System.Data.OracleClient.OracleDataReader.GetOracleLob%2A> método.  
  
 Puede construir un <xref:System.Data.OracleClient.OracleLob> que es NULL con este formato:  
  
```  
OracleLob myLob = OracleLob.Null;  
```  
  
 Esta técnica se usa principalmente para probar si un `LOB` devuelto desde el servidor es NULL, como se muestra en este ejemplo:  
  
```  
If(myLob == OracleLob.Null)  
```  
  
 Un valor NULL `LOB` se comporta de forma similar a cero bytes `LOB` que <xref:System.Data.OracleClient.OracleLob.Read%2A> se realiza correctamente y siempre devuelve cero bytes.  
  
 Seleccionar un `LOB` devuelve la columna que contiene un valor null <xref:System.Data.OracleClient.OracleLob.Null>.  
  
 Debe iniciar una transacción antes de obtener un archivo temporal `LOB`. En caso contrario, el <xref:System.Data.OracleClient.OracleDataReader> puede producir un error al obtener datos posteriormente.  
  
 También puede abrir un archivo temporal `LOB` en Oracle mediante una llamada a la DBMS_LOB. Sistema CREATETEMPORARY procedimiento almacenado y enlace un `LOB` parámetro de salida. En el lado cliente, un archivo temporal `LOB` se comporta como una tabla base `LOB`. Por ejemplo, para actualizar temporal `LOB`, debe incluirse en una transacción.  
  
 En el ejemplo de C# siguiente se muestra cómo abrir un archivo temporal `LOB`.  
  
```  
OracleConnection connection = new OracleConnection("server=MyServer; integrated security=yes;");  
connection.Open();  
OracleTransaction transaction = connection.BeginTransaction();  
OracleCommand command = connection.CreateCommand();  
command.Transaction = transaction;  
command.CommandText = "declare xx blob; begin dbms_lob.createtemporary(xx, false, 0); :tempblob := xx; end;";  
command.Parameters.Add(new OracleParameter("tempblob", OracleType.Blob)).Direction = ParameterDirection.Output;  
command.ExecuteNonQuery();  
OracleLob tempLob = (OracleLob)command.Parameters[0].Value;  
byte[] tempbuff = new byte[10000];  
tempLob.BeginBatch(OracleLobOpenMode.ReadWrite);  
tempLob.Write(tempbuff,0,tempbuff.Length);  
tempLob.EndBatch();  
command.Parameters.Clear();  
command.CommandText = "MyTable.MyProc";  
command.CommandType = CommandType.StoredProcedure;    
command.Parameters.Add(new OracleParameter("ImportDoc", OracleType.Blob)).Value = tempLob;  
command.ExecuteNonQuery();  
transaction.Commit();  
connection.Close  
```  
  
> [!NOTE]
>  Heredadas <xref:System.IO.Stream.WriteByte%2A> método produce un error si se usa con datos de caracteres y un <xref:System.InvalidOperationException> se produce. Use el método <xref:System.Data.OracleClient.OracleLob.Write%2A> en su lugar.  
>   
>  Temporal `LOB`s son solo cierra cuando se cierra la conexión, pero con la agrupación y bajo carga, temporal `LOB`no se cierran. Esto se puede resolver mediante la eliminación temporal `LOB`, invocando `tempLob.Dispose()`.  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public void Append (System.Data.OracleClient.OracleLob source);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Append(class System.Data.OracleClient.OracleLob source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.OracleClient.OracleLob.Append(System.Data.OracleClient.OracleLob)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Append (source As OracleLob)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Append(System::Data::OracleClient::OracleLob ^ source);" />
      <MemberSignature Language="F#" Value="member this.Append : System.Data.OracleClient.OracleLob -&gt; unit" Usage="oracleLob.Append source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.OracleClient</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Data.OracleClient.OracleLob" />
      </Parameters>
      <Docs>
        <param name="source"><see langword="LOB" /> del que se van a anexar datos.</param>
        <summary>Anexa datos del <see langword="LOB" /> especificado al <see langword="LOB" /> actual.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para escribir en el `LOB`, debe recuperar el `LOB` mediante la cláusula FOR UPDATE en la instrucción SELECT de SQL y debe tener una transacción local iniciada.  
  
 Todos los datos del origen de `LOB` se anexa al final de la actual `LOB`. La posición de ninguno `LOB` se evalúa ni se puede cambiar durante este proceso.  
  
 Los tipos de datos subyacente siempre deben ser el mismo. Por ejemplo, si va a anexar una <xref:System.Data.OracleClient.OracleType.NClob>, el destino <xref:System.Data.OracleClient.OracleLob> también debe ser un <xref:System.Data.OracleClient.OracleType.NClob>.  
  
> [!NOTE]
>  En esta versión, una operación de escritura a solo lectura `LOB` podría realizarse correctamente, pero no actualiza el `LOB` en el servidor. En este caso, sin embargo, copia local de la `LOB` se actualiza. Por lo tanto, más adelante, leer las operaciones en el <xref:System.Data.OracleClient.OracleLob> objeto podría devolver los resultados de la operación de escritura.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El objeto <see cref="T:System.Data.OracleClient.OracleLob" /> de origen es nulo.</exception>
        <exception cref="T:System.InvalidOperationException">El objeto <see cref="T:System.Data.OracleClient.OracleLob" /> de origen es null o la conexión está cerrada.</exception>
        <exception cref="T:System.ObjectDisposedException">El objeto <see cref="T:System.Data.OracleClient.OracleLob" /> de origen estaba cerrado o desechado.</exception>
        <exception cref="T:System.Data.OracleClient.OracleException">Se produjo un error de Oracle.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginBatch">
      <AssemblyInfo>
        <AssemblyName>System.Data.OracleClient</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Evita que se activen los desencadenadores en el servidor mientras se realizan varias operaciones de escritura.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginBatch">
      <MemberSignature Language="C#" Value="public void BeginBatch ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void BeginBatch() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.OracleClient.OracleLob.BeginBatch" />
      <MemberSignature Language="VB.NET" Value="Public Sub BeginBatch ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void BeginBatch();" />
      <MemberSignature Language="F#" Value="member this.BeginBatch : unit -&gt; unit" Usage="oracleLob.BeginBatch " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.OracleClient</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Evita que se activen los desencadenadores en el servidor mientras se realizan varias operaciones de lectura.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se abre el `LOB` en <xref:System.Data.OracleClient.OracleLobOpenMode.ReadOnly> modo; por lo tanto, el `LOB` sólo se pueden leer desde, no se escriben en, hasta que la llamada correspondiente a <xref:System.Data.OracleClient.OracleLob.EndBatch%2A>. Para realizar operaciones de escritura por lotes en el `LOB`, llame a <xref:System.Data.OracleClient.OracleLob.BeginBatch%2A> con <xref:System.Data.OracleClient.OracleLobOpenMode.ReadWrite>.  
  
 Una llamada a <xref:System.Data.OracleClient.OracleLob.BeginBatch%2A> más de una vez en la misma transacción actualmente produce Oracle "ORA-22293: LOB ya está abierto en la misma transacción" error. Además, si se puede obtener el `LOB` usando otra <xref:System.Data.OracleClient.OracleDataReader>, y el llamador original no ha llamado el <xref:System.Data.OracleClient.OracleLob.EndBatch%2A> se genera el método, el mismo error. Por lo tanto, debe llamar a la <xref:System.Data.OracleClient.OracleLob.EndBatch%2A> método cuando haya terminado con el <xref:System.Data.OracleClient.OracleLob>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">La conexión está cerrada.</exception>
        <exception cref="T:System.ObjectDisposedException">El objeto estaba cerrado o desechado.</exception>
        <exception cref="T:System.Data.OracleClient.OracleException">Se produjo un error de Oracle.</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginBatch">
      <MemberSignature Language="C#" Value="public void BeginBatch (System.Data.OracleClient.OracleLobOpenMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void BeginBatch(valuetype System.Data.OracleClient.OracleLobOpenMode mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.OracleClient.OracleLob.BeginBatch(System.Data.OracleClient.OracleLobOpenMode)" />
      <MemberSignature Language="VB.NET" Value="Public Sub BeginBatch (mode As OracleLobOpenMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void BeginBatch(System::Data::OracleClient::OracleLobOpenMode mode);" />
      <MemberSignature Language="F#" Value="member this.BeginBatch : System.Data.OracleClient.OracleLobOpenMode -&gt; unit" Usage="oracleLob.BeginBatch mode" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.OracleClient</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="mode" Type="System.Data.OracleClient.OracleLobOpenMode" />
      </Parameters>
      <Docs>
        <param name="mode">Modo (uno de los valores de <see cref="T:System.Data.OracleClient.OracleLobOpenMode" />) en el que se puede obtener acceso a <see langword="LOB" /> entre esta llamada a <see cref="M:System.Data.OracleClient.OracleLob.BeginBatch(System.Data.OracleClient.OracleLobOpenMode)" /> y la correspondiente llamada a <see cref="M:System.Data.OracleClient.OracleLob.EndBatch" />.</param>
        <summary>Evita que se activen los desencadenadores del servidor mientras se realizan varias operaciones de lectura y escritura en el modo de acceso especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para escribir en el `LOB`, debe recuperar el `LOB` mediante la cláusula FOR UPDATE en la instrucción SELECT de SQL y debe tener una transacción local iniciada.  
  
 Una llamada a <xref:System.Data.OracleClient.OracleLob.BeginBatch%2A> más de una vez en la misma transacción actualmente produce Oracle "ORA-22293: LOB ya está abierto en la misma transacción" error. Además, si se puede obtener el `LOB` usando otra <xref:System.Data.OracleClient.OracleDataReader>, y el llamador original no ha llamado el <xref:System.Data.OracleClient.OracleLob.EndBatch%2A> se genera el método, el mismo error. Por lo tanto, debe llamar a la <xref:System.Data.OracleClient.OracleLob.EndBatch%2A> método cuando haya terminado con el <xref:System.Data.OracleClient.OracleLob>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">La conexión está cerrada.</exception>
        <exception cref="T:System.ObjectDisposedException">El objeto estaba cerrado o desechado.</exception>
        <exception cref="T:System.Data.OracleClient.OracleException">Se produjo un error de Oracle.</exception>
      </Docs>
    </Member>
    <Member MemberName="CanRead">
      <MemberSignature Language="C#" Value="public override bool CanRead { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanRead" />
      <MemberSignature Language="DocId" Value="P:System.Data.OracleClient.OracleLob.CanRead" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property CanRead As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool CanRead { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanRead : bool" Usage="System.Data.OracleClient.OracleLob.CanRead" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.OracleClient</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene un valor que indica si se puede leer la secuencia <see langword="LOB" />.</summary>
        <value><see langword="true" /> si la secuencia <see langword="LOB" /> permite la lectura; en caso contrario, <see langword="false" /> si hay un <see langword="LOB" /> cerrado o desechado.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CanSeek">
      <MemberSignature Language="C#" Value="public override bool CanSeek { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanSeek" />
      <MemberSignature Language="DocId" Value="P:System.Data.OracleClient.OracleLob.CanSeek" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property CanSeek As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool CanSeek { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanSeek : bool" Usage="System.Data.OracleClient.OracleLob.CanSeek" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.OracleClient</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene un valor que indica si se pueden realizar operaciones de búsqueda hacia delante y hacia atrás.</summary>
        <value><see langword="false" /> si <see langword="LOB" /> está cerrado o se ha desechado; en caso contrario, <see langword="true" />. Siempre es <see langword="true" /> para <see cref="F:System.Data.OracleClient.OracleLob.Null" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CanWrite">
      <MemberSignature Language="C#" Value="public override bool CanWrite { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanWrite" />
      <MemberSignature Language="DocId" Value="P:System.Data.OracleClient.OracleLob.CanWrite" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property CanWrite As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool CanWrite { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanWrite : bool" Usage="System.Data.OracleClient.OracleLob.CanWrite" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.OracleClient</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Devuelve siempre un valor true, independientemente de si <see langword="LOB" /> admite o no la escritura.</summary>
        <value>Siempre <see langword="true" />, con independencia de que un <see langword="LOB" /> abierto o no desechado admita o no la escritura; <see langword="false" /> si <see langword="LOB" /> está cerrado o se ha desechado.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para escribir en el `LOB`, debe recuperar el `LOB` mediante la cláusula FOR UPDATE en la instrucción SQL SELECT y debe haber iniciado una transacción local.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ChunkSize">
      <MemberSignature Language="C#" Value="public int ChunkSize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 ChunkSize" />
      <MemberSignature Language="DocId" Value="P:System.Data.OracleClient.OracleLob.ChunkSize" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ChunkSize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int ChunkSize { int get(); };" />
      <MemberSignature Language="F#" Value="member this.ChunkSize : int" Usage="System.Data.OracleClient.OracleLob.ChunkSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.OracleClient</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene un valor que indica el número mínimo de bytes que se van a recuperar del servidor o se van a enviar a él durante una operación de lectura y escritura.</summary>
        <value>Número mínimo de bytes que se van a recuperar o enviar.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El valor devuelto por la <xref:System.Data.OracleClient.OracleLob.ChunkSize%2A> propiedad no es una configuración del proveedor de datos de .NET Framework para Oracle. En su lugar, es el valor que Oracle Call Interface (OCI) que se usa al comunicarse con el servidor. Use <xref:System.Data.OracleClient.OracleLob.ChunkSize%2A> para asegurarse de que los fragmentos del cliente tienen el mismo tamaño. Leer o escribir en fragmentos más pequeños no almacena datos en caché y hace que menos optimizado ida y vuelta al servidor, porque no se recibe o se envía un paquete completo.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">La conexión está cerrada.</exception>
        <exception cref="T:System.ObjectDisposedException">El objeto estaba cerrado o desechado.</exception>
        <exception cref="T:System.Data.OracleClient.OracleException">Se produjo un error de Oracle.</exception>
      </Docs>
    </Member>
    <Member MemberName="Clone">
      <MemberSignature Language="C#" Value="public object Clone ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object Clone() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.OracleClient.OracleLob.Clone" />
      <MemberSignature Language="VB.NET" Value="Public Function Clone () As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ Clone();" />
      <MemberSignature Language="F#" Value="abstract member Clone : unit -&gt; obj&#xA;override this.Clone : unit -&gt; obj" Usage="oracleLob.Clone " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ICloneable.Clone</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Data.OracleClient</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Crea un nuevo objeto <see cref="T:System.Data.OracleClient.OracleLob" /> que hace referencia al mismo <see langword="LOB" /> de Oracle que el objeto <see cref="T:System.Data.OracleClient.OracleLob" /> original.</summary>
        <returns>Nuevo objeto <see cref="T:System.Data.OracleClient.OracleLob" /> que hace referencia al mismo <see langword="LOB" /> de Oracle que el objeto <see cref="T:System.Data.OracleClient.OracleLob" /> original.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Las propiedades del nuevo <xref:System.Data.OracleClient.OracleLob> objeto inicialmente tiene los mismos valores que las del objeto original. Sin embargo, después de la <xref:System.Data.OracleClient.OracleLob.Clone%2A> está completa, cada uno de ellos <xref:System.Data.OracleClient.OracleLob> es independiente del otro objeto. Por ejemplo, cambiar el valor de la <xref:System.Data.OracleClient.OracleLob.Position%2A> propiedad en el original <xref:System.Data.OracleClient.OracleLob> no cambia el valor de <xref:System.Data.OracleClient.OracleLob.Position%2A> en la copia.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">La conexión está cerrada.</exception>
        <exception cref="T:System.ObjectDisposedException">El objeto estaba cerrado o desechado.</exception>
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public override void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.OracleClient.OracleLob.Close" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Close ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void Close();" />
      <MemberSignature Language="F#" Value="override this.Close : unit -&gt; unit" Usage="oracleLob.Close " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.OracleClient</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Cierra la secuencia actual y libera todos los recursos asociados a la secuencia.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Connection">
      <MemberSignature Language="C#" Value="public System.Data.OracleClient.OracleConnection Connection { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Data.OracleClient.OracleConnection Connection" />
      <MemberSignature Language="DocId" Value="P:System.Data.OracleClient.OracleLob.Connection" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Connection As OracleConnection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Data::OracleClient::OracleConnection ^ Connection { System::Data::OracleClient::OracleConnection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Connection : System.Data.OracleClient.OracleConnection" Usage="System.Data.OracleClient.OracleLob.Connection" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.OracleClient</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.OracleClient.OracleConnection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene el objeto <see cref="T:System.Data.OracleClient.OracleConnection" /> que utiliza esta instancia de <see cref="T:System.Data.OracleClient.OracleLob" />.</summary>
        <value>Conexión a un origen de datos.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException">El objeto estaba cerrado o desechado.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="CopyTo">
      <AssemblyInfo>
        <AssemblyName>System.Data.OracleClient</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Realiza una copia de este objeto <see cref="T:System.Data.OracleClient.OracleLob" /> en un objeto <see cref="T:System.Data.OracleClient.OracleLob" /> de destino.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public long CopyTo (System.Data.OracleClient.OracleLob destination);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int64 CopyTo(class System.Data.OracleClient.OracleLob destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.OracleClient.OracleLob.CopyTo(System.Data.OracleClient.OracleLob)" />
      <MemberSignature Language="VB.NET" Value="Public Function CopyTo (destination As OracleLob) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; long CopyTo(System::Data::OracleClient::OracleLob ^ destination);" />
      <MemberSignature Language="F#" Value="override this.CopyTo : System.Data.OracleClient.OracleLob -&gt; int64" Usage="oracleLob.CopyTo destination" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.OracleClient</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.Data.OracleClient.OracleLob" />
      </Parameters>
      <Docs>
        <param name="destination"><see cref="T:System.Data.OracleClient.OracleLob" /> de destino.</param>
        <summary>Realiza una copia de este objeto <see cref="T:System.Data.OracleClient.OracleLob" /> en un objeto <see cref="T:System.Data.OracleClient.OracleLob" /> de destino.</summary>
        <returns>Número de bytes que se han copiado. No se incluyen los bytes de relleno.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Los tipos de datos subyacente siempre deben ser el mismo. Por ejemplo, si va a copiar desde un <xref:System.Data.OracleClient.OracleType.NClob>, el destino <xref:System.Data.OracleClient.OracleLob> también debe ser un <xref:System.Data.OracleClient.OracleType.NClob>.  
  
 Si el desplazamiento de destino es más allá del final del destino de `LOB`, el `LOB` que se va a copiar los datos que se extiende. El espacio entre el final de la `LOB` y el desplazamiento de destino más allá del final se rellena con ceros para `BLOB` tipos de datos y espacios para `CLOB` y `NCLOB` tipos de datos.  
  
 Para escribir en el `LOB`, debe recuperar el `LOB` mediante la cláusula FOR UPDATE en la instrucción SELECT de SQL y debe tener una transacción local iniciada.  
  
> [!NOTE]
>  En esta versión, una operación de escritura a solo lectura `LOB` es posible que se realice correctamente, pero no actualizan el `LOB` en el servidor. En este caso, sin embargo, copia local de la `LOB` se actualizará. Por lo tanto, más adelante, leer las operaciones en el <xref:System.Data.OracleClient.OracleLob> objeto podría devolver los resultados de la operación de escritura.  
>   
>  El `CopyTo` método no borra el contenido del destino `OracleLob` antes de realizar la operación de copia.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El objeto <see cref="T:System.Data.OracleClient.OracleLob" /> especificado en el parámetro <paramref name="destination" /> es null.</exception>
        <exception cref="T:System.InvalidOperationException">La operación no está dentro de una transacción, el objeto <see cref="T:System.Data.OracleClient.OracleLob" /> es null, o la conexión está cerrada.</exception>
        <exception cref="T:System.Data.OracleClient.OracleException">Se produjo un error de Oracle.</exception>
      </Docs>
    </Member>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public long CopyTo (System.Data.OracleClient.OracleLob destination, long destinationOffset);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int64 CopyTo(class System.Data.OracleClient.OracleLob destination, int64 destinationOffset) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.OracleClient.OracleLob.CopyTo(System.Data.OracleClient.OracleLob,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Function CopyTo (destination As OracleLob, destinationOffset As Long) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; long CopyTo(System::Data::OracleClient::OracleLob ^ destination, long destinationOffset);" />
      <MemberSignature Language="F#" Value="override this.CopyTo : System.Data.OracleClient.OracleLob * int64 -&gt; int64" Usage="oracleLob.CopyTo (destination, destinationOffset)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.OracleClient</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.Data.OracleClient.OracleLob" />
        <Parameter Name="destinationOffset" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="destination"><see cref="T:System.Data.OracleClient.OracleLob" /> de destino.</param>
        <param name="destinationOffset">Posición de desplazamiento en la que se va a copiar. Para los tipos de datos <see langword="CLOB" /> y <see langword="NCLOB" />, debe ser un número par de bytes.</param>
        <summary>Copia datos de este objeto <see cref="T:System.Data.OracleClient.OracleLob" /> en un objeto <see cref="T:System.Data.OracleClient.OracleLob" /> de destino con la cantidad de datos especificada.</summary>
        <returns>Número de bytes que se han copiado. No se incluyen los bytes de relleno.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Los tipos de datos subyacente siempre deben ser el mismo. Por ejemplo, si va a copiar desde un <xref:System.Data.OracleClient.OracleType.NClob>, el destino <xref:System.Data.OracleClient.OracleLob> también debe ser un <xref:System.Data.OracleClient.OracleType.NClob>.  
  
 Si el desplazamiento de destino es más allá del final del destino de `LOB`, el `LOB` que se va a copiar los datos que se extiende. El espacio entre el final de `LOB` y desplazamiento de destino más allá del final se rellena con ceros para `BLOB` tipos de datos y espacios para `CLOB` y `NCLOB` tipos de datos.  
  
 Para escribir en el `LOB`, debe recuperar el `LOB` mediante la cláusula FOR UPDATE en la instrucción SELECT de SQL y debe tener una transacción local iniciada.  
  
> [!NOTE]
>  En esta versión, una operación de escritura a solo lectura `LOB` podría realizarse correctamente, pero no actualiza el `LOB` en el servidor. En este caso, sin embargo, copia local de la `LOB` se actualiza. Por lo tanto, más adelante, leer las operaciones en el <xref:System.Data.OracleClient.OracleLob> objeto podría devolver los resultados de la operación de escritura.  
>   
>  El `CopyTo` método no borra el contenido del destino `OracleLob` antes de realizar la operación de copia.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El objeto <see cref="T:System.Data.OracleClient.OracleLob" /> especificado en el parámetro <paramref name="destination" /> es null.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Un valor especificado en el parámetro <paramref name="destinationOffset" /> es menor que cero o mayor que 4 gigabytes.  
  
O bien 
Un valor especificado en el parámetro <paramref name="destinationOffset" /> para un tipo de datos <see langword="CLOB" /> o <see langword="NCLOB" /> no es par.  
  
O bien 
Debe especificar los tipos de datos <see langword="CLOB" /> y <see langword="NCLOB" /> como un número par de bytes.</exception>
        <exception cref="T:System.InvalidOperationException">La operación no está dentro de una transacción, el objeto <see cref="T:System.Data.OracleClient.OracleLob" /> es null, o la conexión está cerrada.</exception>
        <exception cref="T:System.Data.OracleClient.OracleException">Se produjo un error de Oracle.</exception>
      </Docs>
    </Member>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public long CopyTo (long sourceOffset, System.Data.OracleClient.OracleLob destination, long destinationOffset, long amount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int64 CopyTo(int64 sourceOffset, class System.Data.OracleClient.OracleLob destination, int64 destinationOffset, int64 amount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.OracleClient.OracleLob.CopyTo(System.Int64,System.Data.OracleClient.OracleLob,System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Function CopyTo (sourceOffset As Long, destination As OracleLob, destinationOffset As Long, amount As Long) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; long CopyTo(long sourceOffset, System::Data::OracleClient::OracleLob ^ destination, long destinationOffset, long amount);" />
      <MemberSignature Language="F#" Value="override this.CopyTo : int64 * System.Data.OracleClient.OracleLob * int64 * int64 -&gt; int64" Usage="oracleLob.CopyTo (sourceOffset, destination, destinationOffset, amount)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.OracleClient</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceOffset" Type="System.Int64" />
        <Parameter Name="destination" Type="System.Data.OracleClient.OracleLob" />
        <Parameter Name="destinationOffset" Type="System.Int64" />
        <Parameter Name="amount" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="sourceOffset">Desplazamiento del que se va a copiar. Para los tipos de datos <see langword="CLOB" /> y <see langword="NCLOB" />, debe ser un número par.</param>
        <param name="destination">El destino <see langword="OracleLob" /><see cref="N:System.Data.OracleClient" />.</param>
        <param name="destinationOffset">Posición de desplazamiento de destino en la que se va a copiar. Para los tipos de datos <see langword="CLOB" /> y <see langword="NCLOB" />, debe ser un número par.</param>
        <param name="amount">Cantidad de datos, en bytes que se va a copiar. Para los tipos de datos <see langword="CLOB" /> y <see langword="NCLOB" />, debe ser un número par.</param>
        <summary>Realiza una copia desde este objeto <see cref="T:System.Data.OracleClient.OracleLob" /> en un objeto <see cref="T:System.Data.OracleClient.OracleLob" /> de destino con la cantidad de datos especificada, y la posición de desplazamiento de origen.</summary>
        <returns>Número de bytes que se han copiado. No se incluyen los bytes de relleno.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Los tipos de datos subyacente siempre deben ser el mismo. Por ejemplo, si va a copiar desde un <xref:System.Data.OracleClient.OracleType.NClob>, el destino <xref:System.Data.OracleClient.OracleLob> también debe ser un <xref:System.Data.OracleClient.OracleType.NClob>.  
  
 Si el desplazamiento de destino es más allá del final del destino de `LOB`, el `LOB` que se va a copiar los datos que se extiende. El espacio entre el final de `LOB` y desplazamiento de destino más allá del final se rellena con ceros para `BLOB` tipos de datos y espacios para `CLOB` y `NCLOB` tipos de datos.  
  
 Para escribir en el `LOB`, debe recuperar el `LOB` mediante la cláusula FOR UPDATE en la instrucción SELECT de SQL y debe tener una transacción local iniciada.  
  
> [!NOTE]
>  En esta versión, una operación de escritura a solo lectura `LOB` podría realizarse correctamente, pero no actualiza el `LOB` en el servidor. En este caso, sin embargo, copia local de la `LOB` se actualiza. Por lo tanto, más adelante, leer las operaciones en el <xref:System.Data.OracleClient.OracleLob> objeto podría devolver los resultados de la operación de escritura.  
>   
>  El `CopyTo` método no borra el contenido del destino `OracleLob` antes de realizar la operación de copia.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El objeto <see cref="T:System.Data.OracleClient.OracleLob" /> especificado en el parámetro <paramref name="destination" /> es null.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Un valor especificado en el parámetro <paramref name="amount" />, <paramref name="sourceOffset" /> o <paramref name="destinationOffset" /> es menor que cero o mayor que 4 gigabytes.  
  
O bien 
Un valor especificado en el parámetro <paramref name="amount" />, <paramref name="sourceOffset" /> o <paramref name="destinationOffset" /> para un tipo de datos <see langword="CLOB" /> o <see langword="NCLOB" /> no es par.</exception>
        <exception cref="T:System.InvalidOperationException">La operación no está dentro de una transacción, el objeto <see cref="T:System.Data.OracleClient.OracleLob" /> es null, o la conexión está cerrada.</exception>
        <exception cref="T:System.Data.OracleClient.OracleException">Se produjo un error de Oracle.</exception>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.OracleClient.OracleLob.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberSignature Language="F#" Value="abstract member Dispose : unit -&gt; unit&#xA;override this.Dispose : unit -&gt; unit" Usage="oracleLob.Dispose " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Data.OracleClient</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Libera los recursos utilizados por este objeto.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected override void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.OracleClient.OracleLob.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void Dispose(bool disposing);" />
      <MemberSignature Language="F#" Value="override this.Dispose : bool -&gt; unit" Usage="oracleLob.Dispose disposing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.OracleClient</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="EndBatch">
      <MemberSignature Language="C#" Value="public void EndBatch ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EndBatch() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.OracleClient.OracleLob.EndBatch" />
      <MemberSignature Language="VB.NET" Value="Public Sub EndBatch ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EndBatch();" />
      <MemberSignature Language="F#" Value="member this.EndBatch : unit -&gt; unit" Usage="oracleLob.EndBatch " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.OracleClient</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Permite que se activen de nuevo los desencadenadores en el servidor después de que se hayan realizado varias operaciones de escritura.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Llame a la <xref:System.Data.OracleClient.OracleLob.BeginBatch%2A> método antes de empezar a realizar las operaciones de escritura en el <xref:System.Data.OracleClient.OracleLob>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">La conexión está cerrada.</exception>
        <exception cref="T:System.ObjectDisposedException">El objeto estaba cerrado o desechado.</exception>
        <exception cref="T:System.Data.OracleClient.OracleException">Se produjo un error de Oracle.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Erase">
      <AssemblyInfo>
        <AssemblyName>System.Data.OracleClient</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Borra datos de este objeto <see cref="T:System.Data.OracleClient.OracleLob" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Erase">
      <MemberSignature Language="C#" Value="public long Erase ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int64 Erase() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.OracleClient.OracleLob.Erase" />
      <MemberSignature Language="VB.NET" Value="Public Function Erase () As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; long Erase();" />
      <MemberSignature Language="F#" Value="member this.Erase : unit -&gt; int64" Usage="oracleLob.Erase " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.OracleClient</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Borra todos los datos de este objeto <see cref="T:System.Data.OracleClient.OracleLob" />.</summary>
        <returns>Número de bytes que se borran.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.OracleClient.OracleLob.Erase%2A> no trunca los datos. El `LOB` longitud sigue siendo el mismo para un `BLOB` tipo de datos, y los datos borrados se reemplazan por 0 x 00. `CLOB` y `NCLOB` tipos de datos se reemplazan por espacios.  
  
 Para escribir en el `LOB`, debe recuperar el `LOB` mediante la cláusula FOR UPDATE en la instrucción SELECT de SQL y debe tener una transacción local iniciada.  
  
> [!NOTE]
>  En esta versión, una operación de escritura a solo lectura `LOB` podría realizarse correctamente, pero no actualiza el `LOB` en el servidor. En este caso, sin embargo, copia local de la `LOB` se actualiza. Por lo tanto, más adelante, leer las operaciones en el <xref:System.Data.OracleClient.OracleLob> objeto podría devolver los resultados de la operación de escritura.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">La operación no está dentro de una transacción, el objeto <see cref="T:System.Data.OracleClient.OracleLob" /> es null, o la conexión está cerrada.</exception>
        <exception cref="T:System.ObjectDisposedException">El objeto estaba cerrado o desechado.</exception>
        <exception cref="T:System.Data.OracleClient.OracleException">Se produjo un error de Oracle.</exception>
      </Docs>
    </Member>
    <Member MemberName="Erase">
      <MemberSignature Language="C#" Value="public long Erase (long offset, long amount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int64 Erase(int64 offset, int64 amount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.OracleClient.OracleLob.Erase(System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Function Erase (offset As Long, amount As Long) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; long Erase(long offset, long amount);" />
      <MemberSignature Language="F#" Value="member this.Erase : int64 * int64 -&gt; int64" Usage="oracleLob.Erase (offset, amount)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.OracleClient</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="offset" Type="System.Int64" />
        <Parameter Name="amount" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="offset">Posición de desplazamiento de la que se va a borrar. Para los tipos de datos <see langword="CLOB" /> y <see langword="NCLOB" />, debe ser un número par.</param>
        <param name="amount">Cantidad de datos, en bytes, que se va a borrar. Para los tipos de datos <see langword="CLOB" /> y <see langword="NCLOB" />, debe ser un número par.</param>
        <summary>Borra la cantidad de datos especificada de este objeto <see cref="T:System.Data.OracleClient.OracleLob" />.</summary>
        <returns>Número de bytes que se borran.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La suma de los valores de la `offset` y `amount` parámetros pueden ser mayores que el tamaño de la <xref:System.Data.OracleClient.OracleLob>. Por lo tanto, al especificar un valor mayor que el devuelto por la <xref:System.Data.OracleClient.OracleLob.Length%2A> propiedad se realiza correctamente; sin embargo <xref:System.Data.OracleClient.OracleLob.Erase%2A> borra solo al final de la <xref:System.Data.OracleClient.OracleLob>. (De forma similar, si se pasa un valor negativo a `offset`, <xref:System.Data.OracleClient.OracleLob.Erase%2A> se realizará correctamente, pero sólo borrará empezando desde el principio de la <xref:System.Data.OracleClient.OracleLob>.) Este comportamiento es diferente de la <xref:System.Data.OracleClient.OracleLob.Read%2A> y <xref:System.Data.OracleClient.OracleLob.Write%2A> métodos y ofrece la ventaja de poder borrar todos los datos del valor especificada por `offset` sin realizar un ida y vuelta adicional en el servidor para comprobar el tamaño real.  
  
 <xref:System.Data.OracleClient.OracleLob.Erase%2A> no trunca los datos. El `LOB` longitud sigue siendo el mismo para un `BLOB` tipo de datos, y los datos borrados se reemplazan por 0 x 00. `CLOB` y `NCLOB` tipos de datos se reemplazan por espacios.  
  
 Para escribir en el `LOB`, debe recuperar el `LOB` mediante la cláusula FOR UPDATE en la instrucción SELECT de SQL y debe tener una transacción local iniciada.  
  
> [!NOTE]
>  En esta versión, una operación de escritura a solo lectura `LOB` podría realizarse correctamente, pero no actualiza el `LOB` en el servidor. En este caso, sin embargo, copia local de la `LOB` se actualiza. Por lo tanto, más adelante, leer las operaciones en el <xref:System.Data.OracleClient.OracleLob> objeto podría devolver los resultados de la operación de escritura.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">La operación no está dentro de una transacción, el objeto <see cref="T:System.Data.OracleClient.OracleLob" /> es null, o la conexión está cerrada.</exception>
        <exception cref="T:System.ObjectDisposedException">El objeto estaba cerrado o desechado.</exception>
        <exception cref="T:System.Data.OracleClient.OracleException">Se produjo un error de Oracle.</exception>
      </Docs>
    </Member>
    <Member MemberName="Flush">
      <MemberSignature Language="C#" Value="public override void Flush ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Flush() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.OracleClient.OracleLob.Flush" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Flush ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void Flush();" />
      <MemberSignature Language="F#" Value="override this.Flush : unit -&gt; unit" Usage="oracleLob.Flush " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.OracleClient</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>No se admite en la actualidad.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 En esta versión, este método no es funcional.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsBatched">
      <MemberSignature Language="C#" Value="public bool IsBatched { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsBatched" />
      <MemberSignature Language="DocId" Value="P:System.Data.OracleClient.OracleLob.IsBatched" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsBatched As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsBatched { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsBatched : bool" Usage="System.Data.OracleClient.OracleLob.IsBatched" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.OracleClient</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene un valor que indica si una aplicación ha llamado al método <see cref="M:System.Data.OracleClient.OracleLob.BeginBatch" />.</summary>
        <value><see langword="true" /> si la aplicación ha llamado al método <see cref="M:System.Data.OracleClient.OracleLob.BeginBatch" />; en caso contrario, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cuando se usa un servidor de Oracle 8.0.5, Oracle "ORA-00600: código de error interno" se produce la excepción.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Data.OracleClient.OracleException">Se produjo un error de Oracle.</exception>
      </Docs>
    </Member>
    <Member MemberName="IsNull">
      <MemberSignature Language="C#" Value="public bool IsNull { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsNull" />
      <MemberSignature Language="DocId" Value="P:System.Data.OracleClient.OracleLob.IsNull" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsNull As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsNull { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsNull : bool" Usage="System.Data.OracleClient.OracleLob.IsNull" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Data.SqlTypes.INullable.IsNull</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Data.OracleClient</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene un valor que indica si el objeto <see cref="T:System.Data.OracleClient.OracleLob" /> es una secuencia <see cref="F:System.Data.OracleClient.OracleBFile.Null" />.</summary>
        <value><see langword="true" /> si <see cref="T:System.Data.OracleClient.OracleLob" /> es una secuencia <see cref="F:System.Data.OracleClient.OracleBFile.Null" />; en caso contrario, <see langword="false" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsTemporary">
      <MemberSignature Language="C#" Value="public bool IsTemporary { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsTemporary" />
      <MemberSignature Language="DocId" Value="P:System.Data.OracleClient.OracleLob.IsTemporary" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsTemporary As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsTemporary { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsTemporary : bool" Usage="System.Data.OracleClient.OracleLob.IsTemporary" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.OracleClient</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene un valor que indica si <see cref="T:System.Data.OracleClient.OracleLob" /> es un <see langword="LOB" /> temporal.</summary>
        <value>Es <see langword="true" /> si <see cref="T:System.Data.OracleClient.OracleLob" /> es un <see langword="LOB" /> temporal; en caso contrario, es <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 En el ejemplo siguiente se muestra cómo crear un archivo temporal `LOB`.  
  
```  
OracleConnection connection = new OracleConnection("server=MyServer; integrated security=yes;");  
connection.Open();  
OracleTransaction transaction = connection.BeginTransaction();  
OracleCommand command = connection.CreateCommand();  
command.Transaction = transaction;  
command.CommandText = "declare xx blob; begin dbms_lob.createtemporary(xx, false, 0); :tempblob := xx; end;";  
command.Parameters.Add(new OracleParameter("tempblob", OracleType.Blob)).Direction = ParameterDirection.Output;  
command.ExecuteNonQuery();  
OracleLob tempLob = (OracleLob)command.Parameters[0].Value;  
tempLob.BeginBatch(OracleLobOpenMode.ReadWrite);  
tempLob.Write(tempbuff,0,tempbuff.Length);  
tempLob.EndBatch();  
command.Parameters.Clear();  
command.CommandText = "MyTable.MyProc";  
command.CommandType = CommandType.StoredProcedure;    
command.Parameters.Add(new OracleParameter("ImportDoc", OracleType.Blob)).Value = tempLob;  
command.ExecuteNonQuery();  
transaction.Commit();  
connection.Close  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">La conexión está cerrada.</exception>
        <exception cref="T:System.ObjectDisposedException">El objeto estaba cerrado o desechado.</exception>
        <exception cref="T:System.Data.OracleClient.OracleException">Se produjo un error de Oracle.</exception>
      </Docs>
    </Member>
    <Member MemberName="Length">
      <MemberSignature Language="C#" Value="public override long Length { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 Length" />
      <MemberSignature Language="DocId" Value="P:System.Data.OracleClient.OracleLob.Length" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property Length As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property long Length { long get(); };" />
      <MemberSignature Language="F#" Value="member this.Length : int64" Usage="System.Data.OracleClient.OracleLob.Length" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.OracleClient</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene un valor que devuelve el tamaño de <see cref="T:System.Data.OracleClient.OracleLob" />.</summary>
        <value>Tamaño de <see cref="T:System.Data.OracleClient.OracleLob" /> en bytes.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El tamaño de la <xref:System.Data.OracleClient.OracleLob> siempre se devuelve en bytes para todos los tipos de datos.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">La conexión está cerrada.</exception>
        <exception cref="T:System.ObjectDisposedException">El objeto estaba cerrado o desechado.</exception>
        <exception cref="T:System.Data.OracleClient.OracleException">Se produjo un error de Oracle.</exception>
      </Docs>
    </Member>
    <Member MemberName="LobType">
      <MemberSignature Language="C#" Value="public System.Data.OracleClient.OracleType LobType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Data.OracleClient.OracleType LobType" />
      <MemberSignature Language="DocId" Value="P:System.Data.OracleClient.OracleLob.LobType" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property LobType As OracleType" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Data::OracleClient::OracleType LobType { System::Data::OracleClient::OracleType get(); };" />
      <MemberSignature Language="F#" Value="member this.LobType : System.Data.OracleClient.OracleType" Usage="System.Data.OracleClient.OracleLob.LobType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.OracleClient</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.OracleClient.OracleType</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene un valor que devuelve el tipo de datos <see langword="LOB" />.</summary>
        <value>Uno de los <see cref="T:System.Data.OracleClient.OracleType" /> <see langword="LOB" /> tipos de datos.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un <xref:System.Data.OracleClient.OracleLob> puede ser uno de los siguientes <xref:System.Data.OracleClient.OracleType> tipos de datos.  
  
|Tipo de datos de OracleType|Descripción|  
|--------------------------|-----------------|  
|`Blob`|Tipo de datos `BLOB` de Oracle que contiene datos binarios con un tamaño máximo de 4 gigabytes. Se asigna a una <xref:System.Array> de tipo <xref:System.Byte>.|  
|`Clob`|Tipo de datos `CLOB` de Oracle que contiene datos de caracteres, basados en el juego de caracteres predeterminado del servidor, con un tamaño máximo de 4 gigabytes. Se asigna a <xref:System.String>.|  
|`NClob`|Oracle `NCLOB` tipo de datos que contiene datos de caracteres, según el juego en el servidor con un tamaño máximo de 4 gigabytes de caracteres nacional. Se asigna a <xref:System.String>.|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Null">
      <MemberSignature Language="C#" Value="public static readonly System.Data.OracleClient.OracleLob Null;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Data.OracleClient.OracleLob Null" />
      <MemberSignature Language="DocId" Value="F:System.Data.OracleClient.OracleLob.Null" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Null As OracleLob " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Data::OracleClient::OracleLob ^ Null;" />
      <MemberSignature Language="F#" Value=" staticval mutable Null : System.Data.OracleClient.OracleLob" Usage="System.Data.OracleClient.OracleLob.Null" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.OracleClient</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.OracleClient.OracleLob</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Representa un objeto <see cref="T:System.Data.OracleClient.OracleLob" /> nulo.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Puede construir un <xref:System.Data.OracleClient.OracleLob> que es NULL con este formato:  
  
```  
OracleLob myLob = OracleLOB.Null;  
```  
  
 Esta técnica se usa principalmente para probar si un `LOB` devuelto desde el servidor es NULL, como se muestra en este ejemplo:  
  
```  
If(myLob == OracleLob.Null)  
```  
  
 Un valor NULL `LOB` se comporta de forma similar a un byte cero `LOB` que <xref:System.Data.OracleClient.OracleLob.Read%2A> se realiza correctamente y siempre devuelve cero bytes.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Position">
      <MemberSignature Language="C#" Value="public override long Position { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 Position" />
      <MemberSignature Language="DocId" Value="P:System.Data.OracleClient.OracleLob.Position" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property Position As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property long Position { long get(); void set(long value); };" />
      <MemberSignature Language="F#" Value="member this.Position : int64 with get, set" Usage="System.Data.OracleClient.OracleLob.Position" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.OracleClient</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene la actual posición de lectura en la secuencia <see cref="T:System.Data.OracleClient.OracleLob" />.</summary>
        <value>Posición actual en la secuencia <see cref="T:System.Data.OracleClient.OracleLob" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La secuencia debe admitir búsquedas obtener o establecer la posición. Use el <xref:System.Data.OracleClient.OracleLob.CanSeek%2A> propiedad para determinar si la secuencia admite búsquedas.  
  
 Se admite la búsqueda en cualquier ubicación más allá de la longitud de la secuencia. Busca una posición impar para `CLOB` y `NCLOB` también se admiten los tipos de datos. Para obtener más información, vea la sección Comentarios de la <xref:System.Data.OracleClient.OracleLob.Read%2A> propiedad.  
  
 El <xref:System.Data.OracleClient.OracleLob.Position%2A> propiedad no mantener un seguimiento del número de bytes de la secuencia que se han consumido, omitido, o ambos.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">La conexión está cerrada.</exception>
        <exception cref="T:System.ObjectDisposedException">El objeto estaba cerrado o desechado.</exception>
      </Docs>
    </Member>
    <Member MemberName="Read">
      <MemberSignature Language="C#" Value="public override int Read (byte[] buffer, int offset, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 Read(unsigned int8[] buffer, int32 offset, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.OracleClient.OracleLob.Read(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Read (buffer As Byte(), offset As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int Read(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int count);" />
      <MemberSignature Language="F#" Value="override this.Read : byte[] * int * int -&gt; int" Usage="oracleLob.Read (buffer, offset, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.OracleClient</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="buffer">Matriz de bytes. Cuando este método devuelve un valor, el búfer contiene la matriz de bytes especificada con valores entre <paramref name="offset" /> y (<paramref name="offset" /> + <paramref name="count" />) reemplazada por los bytes leídos desde el origen actual.</param>
        <param name="offset">Desplazamiento en bytes de base cero de <paramref name="buffer" /> donde se comienza a almacenar los datos leídos de la secuencia actual. Para los tipos de datos <see langword="CLOB" /> y <see langword="NCLOB" />, debe ser un número par.</param>
        <param name="count">Número máximo de bytes que se deben leer de la secuencia actual. Para los tipos de datos <see langword="CLOB" /> y <see langword="NCLOB" />, debe ser un número par.</param>
        <summary>Lee una secuencia de bytes en la secuencia <see cref="T:System.Data.OracleClient.OracleLob" /> actual y hace avanzar la posición dentro de la secuencia en función del número de bytes leídos.</summary>
        <returns>Número total de bytes leídos en el búfer. Puede ser menor que el número de bytes solicitado si dicho número de bytes no está disponible en la actualidad, o cero (0) si se alcanza el final de la secuencia.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Data.OracleClient.OracleLob.Read%2A> método lee un máximo de `count` secuencia de bytes del actual y los almacena en `buffer` comenzando por `offset`. La posición actual dentro de la secuencia se avanza por el número de bytes leídos; Sin embargo, si se produce una excepción, la posición actual dentro de la secuencia permanece sin cambios. <xref:System.Data.OracleClient.OracleLob.Read%2A> Devuelve el número de bytes leídos. El valor devuelto es cero, solo si la posición está al final de la secuencia. <xref:System.Data.OracleClient.OracleLob.Read%2A> se bloqueará hasta que se puede leer al menos un byte de datos, en caso de que no hay datos disponibles.<xref:System.Data.OracleClient.OracleLob.Read%2A> Devuelve 0 si se intenta leer desde un `LOB` cuando la posición actual está al final de `LOB`. <xref:System.Data.OracleClient.OracleLob.Read%2A> puede devolver menos bytes de los solicitados, incluso si no se alcanzó el final de la secuencia.  
  
 El proveedor de datos de .NET Framework para Oracle controla todo `CLOB` y `NCLOB` datos como Unicode. Por lo tanto, al tener acceso a `CLOB` y `NCLOB` tipos de datos, siempre se trabaja con el número de bytes, donde cada carácter es de 2 bytes. Por ejemplo, si una cadena de texto que contiene tres caracteres se guarda como un `NCLOB` en un servidor de Oracle donde el juego de caracteres es de 4 bytes por carácter, y realizar un `Read` operación, especifique la longitud de la cadena de 6 bytes, aunque es se almacenan como 12 bytes en el servidor.  
  
 En el ejemplo de C# siguiente se muestra cómo leer <xref:System.Data.OracleClient.OracleLob> objetos.  
  
```  
public static void ReadLobExample(OracleCommand command)  
{  
   int actual = 0;  
  
   //Select some data.  
   // Table Schema:  
   //  "CREATE TABLE TableWithLobs (a int, b BLOB, c CLOB, d NCLOB)";  
   //  "INSERT INTO TableWithLobs values (1, 'AA', 'AAA', N'AAAA')";  
   command.CommandText = "SELECT * FROM TableWithLobs";  
   OracleDataReader reader = command.ExecuteReader();  
   using(reader)  
   {  
      //Obtain the first row of data.  
      reader.Read();  
      //Obtain the LOBs (all 3 varieties).  
      OracleLob BLOB = reader.GetOracleLob(1);  
      OracleLob CLOB  = reader.GetOracleLob(2);  
      OracleLob NCLOB = reader.GetOracleLob(3);  
  
      //Example - Reading binary data (in chunks).  
      byte[] buffer = new byte[100];  
      while((actual = BLOB.Read(buffer, 0, buffer.Length)) >0)  
         Console.WriteLine(BLOB.LobType + ".Read(" + buffer + ", " + buffer.Length + ") => " + actual);  
  
      //Example - Reading CLOB/NCLOB data (in chunks).  
      //Note: You can read character data as raw Unicode bytes (using OracleLob.Read as in the above example).  
      //However, because the OracleLob object inherits directly from the.NET stream object,   
      //all the existing classes that manipluate streams can also be used. For example, the   
      //.NET StreamReader makes converting the raw bytes into actual characters easier.  
      StreamReader streamreader = new StreamReader(CLOB, Encoding.Unicode);  
      char[] cbuffer = new char[100];  
      while((actual = streamreader.Read(cbuffer, 0, cbuffer.Length)) >0)  
         Console.WriteLine(CLOB.LobType + ".Read(" + new string(cbuffer, 0, actual) + ", " + cbuffer.Length + ") => " + actual);  
  
      //Example - Reading data (all at once).  
      //You could use StreamReader.ReadToEnd to obtain all the string data,or simply  
      //call OracleLob.Value to obtain a contiguous allocation of all the data.  
      Console.WriteLine(NCLOB.LobType + ".Value => " + NCLOB.Value);  
   }  
}  
```  
  
 Puede construir un <xref:System.Data.OracleClient.OracleLob> que es NULL con este formato:  
  
```  
OracleLob myLob = OracleLob.Null;  
```  
  
 Esta técnica se usa principalmente para probar si un `LOB` devuelto desde el servidor es NULL, como se muestra en el ejemplo siguiente.  
  
```  
If(myLob == OracleLob.Null)  
```  
  
 Un valor NULL `LOB` se comporta de forma similar a un byte cero `LOB` que <xref:System.Data.OracleClient.OracleLob.Read%2A> se realiza correctamente y siempre devuelve cero bytes.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" /> es una referencia nula (<see langword="Nothing" /> en Visual Basic).</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Un valor del parámetro <paramref name="offset" /> o <paramref name="count" /> no es positivo.  
  
O bien 
La suma de los parámetros offset y count es mayor que la longitud del búfer.  
  
O bien 
Un valor especificado en el parámetro <paramref name="amount" /> u <paramref name="offset" /> es menor que cero o mayor que 4 gigabytes.</exception>
        <exception cref="T:System.InvalidOperationException">La operación no está dentro de una transacción, el objeto <see cref="T:System.Data.OracleClient.OracleLob" /> es null, o la conexión está cerrada.</exception>
        <exception cref="T:System.ObjectDisposedException">El objeto estaba cerrado o desechado.</exception>
        <exception cref="T:System.Data.OracleClient.OracleException">Se produjo un error de Oracle.</exception>
      </Docs>
    </Member>
    <Member MemberName="Seek">
      <MemberSignature Language="C#" Value="public override long Seek (long offset, System.IO.SeekOrigin origin);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int64 Seek(int64 offset, valuetype System.IO.SeekOrigin origin) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.OracleClient.OracleLob.Seek(System.Int64,System.IO.SeekOrigin)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Seek (offset As Long, origin As SeekOrigin) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override long Seek(long offset, System::IO::SeekOrigin origin);" />
      <MemberSignature Language="F#" Value="override this.Seek : int64 * System.IO.SeekOrigin -&gt; int64" Usage="oracleLob.Seek (offset, origin)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.OracleClient</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="offset" Type="System.Int64" />
        <Parameter Name="origin" Type="System.IO.SeekOrigin" />
      </Parameters>
      <Docs>
        <param name="offset">Desplazamiento de bytes con respecto al origen. Si <paramref name="offset" /> es negativo, la nueva posición precede a la posición especificada por <paramref name="origin" /> en función del número de bytes especificado mediante <paramref name="offset" />. Si <paramref name="offset" /> es cero, la nueva posición es la especificada por <paramref name="origin" />. Si <paramref name="offset" /> es positivo, la nueva posición sigue a la posición especificada por <paramref name="origin" /> en función del número de bytes indicado mediante <paramref name="offset" />.</param>
        <param name="origin">Valor de tipo <see cref="T:System.IO.SeekOrigin" /> que indica el punto de referencia utilizado para obtener la nueva posición.</param>
        <summary>Establece la posición en la secuencia <see cref="T:System.Data.OracleClient.OracleLob" /> actual.</summary>
        <returns>La nueva posición dentro de la secuencia actual.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si `offset` es negativo, la nueva posición debe preceder a la posición especificada por `origin` por el número de bytes especificado por `offset`. Si `offset` es cero, la nueva posición debe ser la posición especificada por `origin`. Si `offset` es positivo, la nueva posición debe seguir la posición especificada por `origin` por el número de bytes especificado por `offset`.  
  
 Se admite la búsqueda en cualquier ubicación más allá de la longitud de la secuencia. Busca una posición impar para `CLOB` y `NCLOB` también se admiten los tipos de datos. Para obtener más información, vea la sección Comentarios de la <xref:System.Data.OracleClient.OracleLob.Read%2A> propiedad.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">El parámetro <paramref name="origin" /> no contiene un valor válido.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">La posición resultante supera la longitud del valor.</exception>
        <exception cref="T:System.ObjectDisposedException">El objeto <see cref="T:System.Data.OracleClient.OracleLob" /> estaba cerrado o desechado.</exception>
        <exception cref="T:System.Data.OracleClient.OracleException">Se produjo un error de Oracle.</exception>
      </Docs>
    </Member>
    <Member MemberName="SetLength">
      <MemberSignature Language="C#" Value="public override void SetLength (long value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void SetLength(int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.OracleClient.OracleLob.SetLength(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub SetLength (value As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void SetLength(long value);" />
      <MemberSignature Language="F#" Value="override this.SetLength : int64 -&gt; unit" Usage="oracleLob.SetLength value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.OracleClient</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="value">Longitud deseada de la secuencia <see cref="T:System.Data.OracleClient.OracleLob" /> en bytes. Para los tipos de datos <see langword="CLOB" /> y <see langword="NCLOB" />, debe ser un número par.</param>
        <summary>Establece la longitud de la secuencia <see cref="T:System.Data.OracleClient.OracleLob" /> en un valor menor que la longitud actual.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un intento para aumentar la longitud de la <xref:System.Data.OracleClient.OracleLob> se produce un error de secuencia y devuelve "mensaje: ORA-22926: especifica la longitud de recorte es mayor que la longitud del valor LOB actual" desde el servidor de Oracle.  
  
 Una secuencia debe admitir operaciones de escritura y de búsqueda para <xref:System.Data.OracleClient.OracleLob.SetLength%2A> a función.  
  
 El proveedor de datos de .NET Framework para Oracle controla todo `CLOB` y `NCLOB` datos como Unicode. Por lo tanto, al tener acceso a `CLOB` y `NCLOB` tipos de datos, siempre se trabaja con el número de bytes, donde cada carácter es de 2 bytes. Por ejemplo, si una cadena de texto que contiene tres caracteres se guarda como un `NCLOB` en un servidor de Oracle donde el juego de caracteres es de 4 bytes por carácter, y realizar un `SetLength` operación, especifique la longitud de la cadena de 6 bytes, aunque es se almacenan como 12 bytes en el servidor.  
  
 Para escribir en el `LOB`, debe recuperar el `LOB` mediante la cláusula FOR UPDATE en la instrucción SELECT de SQL y debe tener una transacción local iniciada.  
  
> [!NOTE]
>  Una operación de escritura a solo lectura `LOB` podría realizarse correctamente, pero no actualiza el `LOB` en el servidor. En este caso, sin embargo, copia local de la `LOB` se actualiza. Por lo tanto, más adelante, leer las operaciones en el <xref:System.Data.OracleClient.OracleLob> objeto podría devolver los resultados de la operación de escritura.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Un valor especificado en el parámetro <paramref name="value" /> para un tipo de datos <see langword="CLOB" /> o <see langword="NCLOB" /> no es par.  
  
O bien 
Un valor especificado en el parámetro <paramref name="value" /> es menor que cero o mayor que 4 gigabytes.</exception>
        <exception cref="T:System.InvalidOperationException">La operación no está dentro de una transacción, el objeto <see cref="T:System.Data.OracleClient.OracleLob" /> es null, o la conexión está cerrada.</exception>
        <exception cref="T:System.ObjectDisposedException">El objeto estaba cerrado o desechado.</exception>
        <exception cref="T:System.Data.OracleClient.OracleException">Se produjo un error de Oracle.</exception>
      </Docs>
    </Member>
    <Member MemberName="Value">
      <MemberSignature Language="C#" Value="public object Value { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object Value" />
      <MemberSignature Language="DocId" Value="P:System.Data.OracleClient.OracleLob.Value" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Value As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ Value { System::Object ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Value : obj" Usage="System.Data.OracleClient.OracleLob.Value" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.OracleClient</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene el valor de secuencia de Common Language Runtime que equivale al valor subyacente.</summary>
        <value>Para <see cref="F:System.Data.OracleClient.OracleType.Blob" />, una matriz de tipo <see langword="Byte[]" />. Para <see cref="F:System.Data.OracleClient.OracleType.Clob" /> y <see cref="F:System.Data.OracleClient.OracleType.NClob" />, es <see langword="String" />. Para datos nulos, es <see cref="T:System.DBNull" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para <xref:System.Data.OracleClient.OracleType.Blob> tipos de datos, <xref:System.Data.OracleClient.OracleLob.Value%2A> devuelve todos los datos subyacentes como una matriz de tipo contigua `Byte[]`. Para <xref:System.Data.OracleClient.OracleType.Clob> y <xref:System.Data.OracleClient.OracleType.NClob> tipos de datos, <xref:System.Data.OracleClient.OracleLob.Value%2A> devuelve todos los datos como un `String` tipo de datos. Para datos nulos, <xref:System.Data.OracleClient.OracleLob.Value%2A> devuelve <xref:System.DBNull>. Comparando los valores devueltos, se puede distinguir entre datos vacíos, datos nulos y datos.  
  
> [!NOTE]
>  Una ventaja de utilizar `LOB` tipos de datos es la capacidad de recuperar grandes cantidades de datos en fragmentos en el cliente. Sin embargo, cuando usa <xref:System.Data.OracleClient.OracleLob.Value%2A>, obtener todos los datos de la `LOB` columna como un bloque contiguo, lo que puede aumentar considerablemente la sobrecarga de la aplicación.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">El objeto estaba cerrado o desechado.</exception>
        <exception cref="T:System.Data.OracleClient.OracleException">Se produjo un error de Oracle.</exception>
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public override void Write (byte[] buffer, int offset, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Write(unsigned int8[] buffer, int32 offset, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.OracleClient.OracleLob.Write(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Write (buffer As Byte(), offset As Integer, count As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void Write(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int count);" />
      <MemberSignature Language="F#" Value="override this.Write : byte[] * int * int -&gt; unit" Usage="oracleLob.Write (buffer, offset, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.OracleClient</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="buffer">Matriz de bytes. Este método copia el número de bytes especificado en <paramref name="count" /> desde <paramref name="buffer" /> hasta la secuencia actual.</param>
        <param name="offset">Desplazamiento en bytes de base cero en la <paramref name="buffer" /> en la que se comienzan a copiar los bytes en la secuencia actual. Para los tipos de datos <see langword="CLOB" /> y <see langword="NCLOB" />, debe ser un número par.</param>
        <param name="count">Número de bytes que se deben escribir en la secuencia actual. Para los tipos de datos <see langword="CLOB" /> y <see langword="NCLOB" />, debe ser un número par.</param>
        <summary>Escribe una secuencia de bytes en la secuencia <see cref="T:System.Data.OracleClient.OracleLob" /> actual y hace avanzar la posición actual dentro de la secuencia en el número de bytes especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si la operación de escritura se realiza correctamente, hace avanzar la posición dentro de la secuencia en el número de bytes escritos. Si se produce una excepción, no se cambia la posición dentro de la secuencia.  
  
 Escribir más allá del final de `LOB` se permite y amplía el `LOB` por el número de bytes escritos.  
  
 El proveedor de datos de .NET Framework para Oracle controla todo `CLOB` y `NCLOB` datos como Unicode. Por lo tanto, al tener acceso a `CLOB` y `NCLOB` tipos de datos, siempre se trabaja con el número de bytes, donde cada carácter es de 2 bytes. Por ejemplo, si una cadena de texto que contiene tres caracteres se guarda como un `NCLOB` en un servidor de Oracle donde el juego de caracteres es de 4 bytes por carácter, y realizar un `Write` operación, especifique la longitud de la cadena de 6 bytes, aunque es se almacenan como 12 bytes en el servidor.  
  
 Para escribir en el `LOB`, debe recuperar el `LOB` mediante la cláusula FOR UPDATE en la instrucción SELECT de SQL y debe tener una transacción local iniciada.  
  
 En el ejemplo de C# siguiente se muestra cómo se escriben en <xref:System.Data.OracleClient.OracleLob> objetos.  
  
```  
public static void WriteLobExample(OracleCommand command)  
{  
   //Note: Updating LOB data requires a transaction.  
   command.Transaction = command.Connection.BeginTransaction();  
   //Select some data.  
   //    Table Schema:  
   //        "CREATE TABLE tablewithlobs (a int, b BLOB, c BLOB)";  
   //        "INSERT INTO tablewithlobs values (1, 'AA', 'AAA')";  
   command.CommandText = "SELECT * FROM TableWithLobs FOR UPDATE";  
   OracleDataReader reader = command.ExecuteReader();  
   using(reader)  
   {  
      //Obtain the first row of data.  
      reader.Read();  
      //Obtain both LOBs.  
      OracleLob BLOB1    = reader.GetOracleLob(1);  
      OracleLob BLOB2    = reader.GetOracleLob(2);  
      //Perform any desired operations on the LOB, (read, position, and so on).  
      //...  
      //Example - Writing binary data (directly to the backend).  
      //To write, you can use any of the stream classes, or write raw binary data using   
      //the OracleLob write method. Writing character vs. binary is the same;  
      //however note that character is always in terms of Unicode byte counts  
      //(for example: even number of bytes - 2 bytes for every Unicode character).  
      byte[] buffer = new byte[100];  
      buffer[0] = 0xCC;  
      buffer[1] = 0xDD;  
      BLOB1.Write(buffer, 0, 2);  
      BLOB1.Position = 0;  
      Console.WriteLine(BLOB1.LobType + ".Write(" + buffer + ", 0, 2) => " + BLOB1.Value);  
  
      //Example - Copying data into another LOB.  
      long actual = BLOB1.CopyTo(BLOB2);  
      Console.WriteLine(BLOB1.LobType + ".CopyTo(" + BLOB2.Value + ") => " + actual);  
  
      //Commit the transaction now that everything succeeded.  
      //Note: On error, Transaction.Dispose is called (from the using statement)  
      //and will automatically roll-back the pending transaction.  
      command.Transaction.Commit();  
   }  
}  
```  
  
> [!NOTE]
>  Una operación de escritura a solo lectura `LOB` podría realizarse correctamente, pero no actualiza el `LOB` en el servidor. En este caso, sin embargo, copia local de la `LOB` se actualiza. Por lo tanto, más adelante, leer las operaciones en el <xref:System.Data.OracleClient.OracleLob> objeto podría devolver los resultados de la operación de escritura.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El parámetro <paramref name="buffer" /> es una referencia nula (<see langword="Nothing" /> en Visual Basic).</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Un valor del parámetro <paramref name="offset" /> o <paramref name="count" /> no es positivo.  
  
O bien 
La suma de los parámetros <paramref name="offset" /> y <paramref name="count" /> es mayor que la longitud de <paramref name="buffer" />.  
  
O bien 
Un valor especificado en el parámetro <paramref name="count" /> u <paramref name="offset" /> es menor que cero o mayor que 4 gigabytes.  
  
O bien 
Debe especificar los tipos de datos <see langword="CLOB" /> y <see langword="NCLOB" /> como un número par de bytes.</exception>
        <exception cref="T:System.InvalidOperationException">La operación no está dentro de una transacción, el objeto <see cref="T:System.Data.OracleClient.OracleLob" /> es null, o la conexión está cerrada.</exception>
        <exception cref="T:System.ObjectDisposedException">El objeto estaba cerrado o desechado.</exception>
        <exception cref="T:System.Data.OracleClient.OracleException">Se produjo un error de Oracle.</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteByte">
      <MemberSignature Language="C#" Value="public override void WriteByte (byte value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void WriteByte(unsigned int8 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.OracleClient.OracleLob.WriteByte(System.Byte)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub WriteByte (value As Byte)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void WriteByte(System::Byte value);" />
      <MemberSignature Language="F#" Value="override this.WriteByte : byte -&gt; unit" Usage="oracleLob.WriteByte value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.OracleClient</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Byte" />
      </Parameters>
      <Docs>
        <param name="value">Byte que se debe escribir en la secuencia.</param>
        <summary>Escribe un byte en la posición actual de la secuencia <see cref="T:System.Data.OracleClient.OracleLob" /> y avanza la posición de la secuencia en un byte.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si la operación de escritura se realiza correctamente, hace avanzar la posición dentro de la secuencia en un byte. Si se produce una excepción, no se cambia la posición dentro de la secuencia.  
  
 Escribir más allá del final de la `LOB` se permite y amplía el `LOB` en un byte.  
  
 Para escribir en el `LOB`, debe recuperar el `LOB` mediante la cláusula FOR UPDATE en la instrucción SELECT de SQL y debe tener una transacción local iniciada.  
  
> [!NOTE]
>  Una operación de escritura a solo lectura `LOB` podría realizarse correctamente, pero no actualiza el `LOB` en el servidor. En este caso, sin embargo, copia local de la `LOB` se actualiza. Por lo tanto, más adelante, leer las operaciones en el <xref:System.Data.OracleClient.OracleLob> objeto podría devolver los resultados de la operación de escritura.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>