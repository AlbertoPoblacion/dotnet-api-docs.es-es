<Type Name="GCSettings" FullName="System.Runtime.GCSettings">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="8ec6350c6c19f45b4b097a5ec933a1a05725cb84" />
    <Meta Name="ms.sourcegitcommit" Value="6a0b904069161bbaec4ffd02aa7d9cf38c61e72e" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="es-ES" />
    <Meta Name="ms.lasthandoff" Value="06/24/2018" />
    <Meta Name="ms.locfileid" Value="36533176" />
  </Metadata>
  <TypeSignature Language="C#" Value="public static class GCSettings" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract sealed beforefieldinit GCSettings extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Runtime.GCSettings" />
  <TypeSignature Language="VB.NET" Value="Public Class GCSettings" />
  <TypeSignature Language="C++ CLI" Value="public ref class GCSettings abstract sealed" />
  <TypeSignature Language="F#" Value="type GCSettings = class" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Specifies the garbage collection settings for the current process.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use la <xref:System.Runtime.GCSettings.IsServerGC%2A> propiedad para determinar si está habilitada la recolección de elementos no utilizados de servidor para el proceso actual.  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName="IsServerGC">
      <MemberSignature Language="C#" Value="public static bool IsServerGC { get; }" />
      <MemberSignature Language="ILAsm" Value=".property bool IsServerGC" />
      <MemberSignature Language="DocId" Value="P:System.Runtime.GCSettings.IsServerGC" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property IsServerGC As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool IsServerGC { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsServerGC : bool" Usage="System.Runtime.GCSettings.IsServerGC" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets a value that indicates whether server garbage collection is enabled.</summary>
        <value>
          <see langword="true" /> si está activada la recolección de elementos no utilizados; en caso contrario, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para obtener información acerca de la recolección de elementos no utilizados de servidor, vea la sección "Recopilación de elementos no utilizados de estación de trabajo y servidor" en [aspectos básicos de la recopilación de elementos no utilizados](~/docs/standard/garbage-collection/fundamentals.md).  
  
 Si no está habilitada la recolección de elementos no utilizados de servidor, colección de elementos no utilizados de estación de trabajo está en vigor (con o sin recolección simultánea). Recolección de elementos no utilizados de servidor solo está disponible en equipos con varios procesadores.  
  
 Un host no administrado puede solicitar la recolección de elementos no utilizados de servidor, y la solicitud del host reemplaza el archivo de configuración. Si el host no especifica el tipo de recolección de elementos, puede usar un archivo de configuración para especificar la recolección de elementos no utilizados de servidor. Esta opción solo es válida en el archivo de configuración de la aplicación, no en el archivo de configuración de máquina (consulte [configurar aplicaciones](http://msdn.microsoft.com/library/86bd26d3-737e-4484-9782-19b17f34cd1f)). En el ejemplo siguiente se muestra el contenido de un archivo de configuración de aplicación de ejemplo que habilita la recolección de elementos no utilizados de servidor.  
  
```  
<configuration>  
  <runtime>  
    <gcServer enabled="true" />  
  </runtime>  
</configuration>  
```  
  
   
  
## Examples  
 En el ejemplo siguiente se indica si está usando el equipo host de servidor o la colección de elementos no utilizados de estación de trabajo.  
  
 [!code-csharp[Environment.IsServerGC#1](~/samples/snippets/csharp/VS_Snippets_CLR/environment.IsServerGC/CS/isg.cs#1)]
 [!code-vb[Environment.IsServerGC#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/environment.IsServerGC/VB/isg.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LargeObjectHeapCompactionMode">
      <MemberSignature Language="C#" Value="public static System.Runtime.GCLargeObjectHeapCompactionMode LargeObjectHeapCompactionMode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property valuetype System.Runtime.GCLargeObjectHeapCompactionMode LargeObjectHeapCompactionMode" />
      <MemberSignature Language="DocId" Value="P:System.Runtime.GCSettings.LargeObjectHeapCompactionMode" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property LargeObjectHeapCompactionMode As GCLargeObjectHeapCompactionMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Runtime::GCLargeObjectHeapCompactionMode LargeObjectHeapCompactionMode { System::Runtime::GCLargeObjectHeapCompactionMode get(); void set(System::Runtime::GCLargeObjectHeapCompactionMode value); };" />
      <MemberSignature Language="F#" Value="member this.LargeObjectHeapCompactionMode : System.Runtime.GCLargeObjectHeapCompactionMode with get, set" Usage="System.Runtime.GCSettings.LargeObjectHeapCompactionMode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.GCLargeObjectHeapCompactionMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>[Supported in the .NET Framework 4.5.1 and later versions]  Gets or sets a value that indicates whether a full blocking garbage collection compacts the large object heap (LOH).</summary>
        <value>Uno de los valores de enumeración que indica si una recolección de elementos no utilizados de bloqueo completa compacta el LOH.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El montón de objeto grande se usa para asignar memoria para objetos grandes (como matrices) que requieren más de 85.000 bytes. Debido al impacto de rendimiento de copiar grandes bloques de memoria, el recolector de elementos no utilizados normalmente barre el montón de objeto grande, lo que implica la creación de una lista de las ubicaciones de memoria que fueron ocupada por objetos muertos y que se puede reutilizar para satisfacer las solicitudes futuras para asignación de memoria para los objetos grandes. Sin embargo, en aplicaciones que hacen una uso de dicho MONTÓN para almacenar objetos transitorios, la fragmentación puede afectar adversamente también rendimiento de memoria. En este caso, es posible utilizar el <xref:System.Runtime.GCSettings.LargeObjectHeapCompactionMode%2A> propiedad compactar el montón de objeto grande en lugar de simplemente barrido durante una recolección de elementos no utilizados.  
  
 El valor predeterminado de la <xref:System.Runtime.GCSettings.LargeObjectHeapCompactionMode%2A> propiedad es <xref:System.Runtime.GCLargeObjectHeapCompactionMode.Default?displayProperty=nameWithType>, lo que indica que no se compacta el montón de objeto grande durante las recolecciones de elementos no utilizados. Si asigna un valor de la propiedad <xref:System.Runtime.GCLargeObjectHeapCompactionMode.CompactOnce?displayProperty=nameWithType>, se compacta el montón de objeto grande durante la recolección de elementos no utilizados de bloqueo completo siguiente y se restablece el valor de propiedad en <xref:System.Runtime.GCLargeObjectHeapCompactionMode.Default?displayProperty=nameWithType>.  
  
> [!NOTE]
>  No están bloqueando las recolecciones de elementos no utilizados de fondo. Esto significa que, si establece la <xref:System.Runtime.GCSettings.LargeObjectHeapCompactionMode%2A> propiedad <xref:System.Runtime.GCLargeObjectHeapCompactionMode.CompactOnce?displayProperty=nameWithType>, una generación de fondo 2 colecciones que se producen posteriormente no compacta el montón de objeto grande. Solo la primera generación bloqueo 2 colección compacta el LOH.  
  
 Después de la <xref:System.Runtime.GCSettings.LargeObjectHeapCompactionMode%2A> propiedad está establecida en <xref:System.Runtime.GCLargeObjectHeapCompactionMode.CompactOnce?displayProperty=nameWithType>, la siguiente recolección de elementos no utilizados de bloqueo completa (y la compactación de dicho MONTÓN) se produce en un momento futuro indeterminado. También puede compactar el montón de objeto grande inmediatamente mediante código similar al siguiente:  
  
 [!code-csharp[System.Runtime.GCSettings#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.runtime.gcsettings/cs/lohcompactionmode1.cs#1)]
 [!code-vb[System.Runtime.GCSettings#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.runtime.gcsettings/vb/lohcompactionmode1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Runtime.GCLargeObjectHeapCompactionMode" />
      </Docs>
    </Member>
    <Member MemberName="LatencyMode">
      <MemberSignature Language="C#" Value="public static System.Runtime.GCLatencyMode LatencyMode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property valuetype System.Runtime.GCLatencyMode LatencyMode" />
      <MemberSignature Language="DocId" Value="P:System.Runtime.GCSettings.LatencyMode" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property LatencyMode As GCLatencyMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Runtime::GCLatencyMode LatencyMode { System::Runtime::GCLatencyMode get(); void set(System::Runtime::GCLatencyMode value); };" />
      <MemberSignature Language="F#" Value="member this.LatencyMode : System.Runtime.GCLatencyMode with get, set" Usage="System.Runtime.GCSettings.LatencyMode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.GCLatencyMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the current latency mode for garbage collection.</summary>
        <value>Uno de los valores de enumeración que especifica el modo de latencia.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Puede reducir el nivel de tendencia a la intrusión de la recolección en la aplicación estableciendo el <xref:System.Runtime.GCLatencyMode> a <xref:System.Runtime.GCLatencyMode.LowLatency> durante las operaciones críticas. Después de que estas operaciones finalizan, vuelva a un modo de latencia superior para que se pueden reclamar más objetos para aumentar la memoria.  
  
 Por lo general, establezca el valor de la <xref:System.Runtime.GCSettings.LatencyMode%2A> propiedad para definir el modo de latencia del recolector de elementos no utilizados. Sin embargo, no se puede establecer el modo de latencia ninguna región de GC asignando el <xref:System.Runtime.GCLatencyMode.NoGCRegion?displayProperty=nameWithType> valor de enumeración para la <xref:System.Runtime.GCSettings.LatencyMode%2A> propiedad. En su lugar, se llama a la <xref:System.GC.TryStartNoGCRegion%2A?displayProperty=nameWithType> método para iniciar el modo de latencia ninguna región de GC y se llama a la <xref:System.GC.EndNoGCRegion%2A?displayProperty=nameWithType> a terminar.  
  
 Vea [modos de latencia](~/docs/standard/garbage-collection/latency.md) para obtener una explicación de cómo afectan los valores de configuración en tiempo de ejecución para la recolección al valor predeterminado de la <xref:System.Runtime.GCLatencyMode> enumeración.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">The <see cref="P:System.Runtime.GCSettings.LatencyMode" /> property is being set to an invalid value.  -or-  The <see cref="P:System.Runtime.GCSettings.LatencyMode" /> property cannot be set to <see cref="F:System.Runtime.GCLatencyMode.NoGCRegion" />.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Requiere plena confianza para el llamador inmediato. Este miembro no puede usarse por código de confianza parcial o transparente.</permission>
      </Docs>
    </Member>
  </Members>
</Type>