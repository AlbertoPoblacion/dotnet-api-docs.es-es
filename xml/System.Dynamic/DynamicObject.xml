<Type Name="DynamicObject" FullName="System.Dynamic.DynamicObject">
  <Metadata><Meta Name="ms.openlocfilehash" Value="ba4618ed283635784b6afb23ea13d5f3d0bb7852" /><Meta Name="ms.sourcegitcommit" Value="c0c07dbd19cd7017243f9ac36915755f79bc8da6" /><Meta Name="ms.translationtype" Value="HT" /><Meta Name="ms.contentlocale" Value="es-ES" /><Meta Name="ms.lasthandoff" Value="11/27/2018" /><Meta Name="ms.locfileid" Value="52372282" /></Metadata><TypeSignature Language="C#" Value="public class DynamicObject : System.Dynamic.IDynamicMetaObjectProvider" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable beforefieldinit DynamicObject extends System.Object implements class System.Dynamic.IDynamicMetaObjectProvider" />
  <TypeSignature Language="DocId" Value="T:System.Dynamic.DynamicObject" />
  <TypeSignature Language="VB.NET" Value="Public Class DynamicObject&#xA;Implements IDynamicMetaObjectProvider" />
  <TypeSignature Language="C++ CLI" Value="public ref class DynamicObject : System::Dynamic::IDynamicMetaObjectProvider" />
  <TypeSignature Language="F#" Value="type DynamicObject = class&#xA;    interface IDynamicMetaObjectProvider" />
  <AssemblyInfo>
    <AssemblyName>System.Dynamic.Runtime</AssemblyName>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Core</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Linq.Expressions</AssemblyName>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Dynamic.IDynamicMetaObjectProvider</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Proporciona una clase base para especificar el comportamiento dinámico en tiempo de ejecución. Esta clase se debe heredar; no se puede crear una instancia de la clase directamente.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La `DynamicObject` clase le permite definir qué operaciones se pueden realizar en objetos dinámicos y cómo realizar esas operaciones. Por ejemplo, puede definir lo que sucede al intentar obtener o establecer una propiedad de objeto, llamar a un método o realizar operaciones matemáticas estándar como la suma o multiplicación.  
  
 Esta clase puede ser útil si desea crear un protocolo más conveniente para una biblioteca. Por ejemplo, si los usuarios de su biblioteca tienen que utilizar una sintaxis como `Scriptobj.SetProperty("Count", 1)`, puede proporcionar la capacidad de usar la sintaxis de mucho más sencilla, como `scriptobj.Count = 1`.  
  
 No se puede crear directamente una instancia de la `DynamicObject` clase. Para implementar el comportamiento dinámico, es posible que desee heredar el `DynamicObject` clase e invalidar los métodos necesarios. Por ejemplo, si tiene solo las operaciones para establecer y obtener propiedades, simplemente puede invalidar el <xref:System.Dynamic.DynamicObject.TrySetMember%2A> y <xref:System.Dynamic.DynamicObject.TryGetMember%2A> métodos.  
  
 En C#, para habilitar el comportamiento dinámico para las instancias de clases derivadas de la `DynamicObject` (clase), debe usar el `dynamic` palabra clave. Para obtener más información, vea [Uso del tipo dynamic](~/docs/csharp/programming-guide/types/using-type-dynamic.md).  
  
 En Visual Basic, se admiten operaciones dinámicas mediante el enlace en tiempo de ejecución. Para obtener más información, consulte [temprana y enlace tardío](https://msdn.microsoft.com/library/d6ff7f1e-b94f-4205-ab8d-5cfa91758724).  
  
 En el ejemplo de código siguiente se muestra cómo crear una instancia de una clase que se deriva el `DynamicObject` clase.  
  
```csharp  
public class SampleDynamicObject : DynamicObject {}  
//...  
dynamic sampleObject = new SampleDynamicObject ();  
```  
  
```vb  
Public Class SampleDynamicObject   
    Inherits DynamicObject  
'...  
Dim sampleObject As Object = New SampleDynamicObject()  
```  
  
 También puede agregar sus propios miembros a las clases derivadas de la `DynamicObject` clase. Si su clase define propiedades y también invalida la <xref:System.Dynamic.DynamicObject.TrySetMember%2A> método, dynamic language runtime (DLR) usa primero el enlazador del lenguaje para buscar una definición estática de una propiedad en la clase. Si no hay ninguna propiedad de este tipo, DLR llama a la <xref:System.Dynamic.DynamicObject.TrySetMember%2A> método.  
  
 El `DynamicObject` clase implementa la interfaz DLR <xref:System.Dynamic.IDynamicMetaObjectProvider>, lo que permite compartir instancias de la `DynamicObject` clase entre los lenguajes que admiten el modelo de interoperabilidad DLR. Por ejemplo, puede crear una instancia de la `DynamicObject` clase en C# y, a continuación, páselo a una función de IronPython. Para obtener más información, consulte [Dynamic Language Runtime Overview](~/docs/framework/reflection-and-codedom/dynamic-language-runtime-overview.md).  
  
> [!NOTE]
>  Si tiene un escenario simple en el que se necesita un objeto que solo puede agregar y quitar miembros en tiempo de ejecución, pero que no es necesario definir operaciones específicas y no tiene miembros estáticos, utilice el <xref:System.Dynamic.ExpandoObject> clase.  
>   
>  Si tiene un escenario más avanzado en el que necesita definir cómo los objetos dinámicos de participar en el protocolo de interoperabilidad, o que necesita para administrar el almacenamiento en caché de la distribución dinámica rápida DLR, cree su propia implementación de la <xref:System.Dynamic.IDynamicMetaObjectProvider> interfaz.  
  
   
  
## Examples  
 Suponga que desea proporcionar una sintaxis alternativa para tener acceso a los valores en un diccionario, así que, en lugar de escribir `sampleDictionary["Text"] = "Sample text"` (`sampleDictionary("Text") = "Sample text"` en Visual Basic), puede escribir `sampleDictionary.Text = "Sample text"`. Además, desea que esta sintaxis entre mayúsculas y minúsculas, por lo que `sampleDictionary.Text` es equivalente a `sampleDictionary.text`.  
  
 En el ejemplo de código siguiente se muestra el `DynamicDictionary` (clase), que se deriva el `DynamicObject` clase. El `DynamicDictionary` clase contiene un objeto de la `Dictionary<string, object>` tipo (`Dictionary(Of String, Object)` en Visual Basic) para almacenar los pares clave-valor e invalida el <xref:System.Dynamic.DynamicObject.TrySetMember%2A> y <xref:System.Dynamic.DynamicObject.TryGetMember%2A> métodos para admitir la nueva sintaxis. También proporciona un `Count` contiene la propiedad, que muestra cuántos propiedades dinámicas en el diccionario.  
  
 [!code-csharp[System.Dynamic.DynamicObject#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.dynamic.dynamicobject/cs/program.cs#1)]
 [!code-vb[System.Dynamic.DynamicObject#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.dynamic.dynamicobject/vb/module1.vb#1)]  
  
 Para obtener más ejemplos, vea [crear contenedores con DynamicObject](https://go.microsoft.com/fwlink/?LinkId=169008) en el blog de C# preguntas más frecuentes.  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected DynamicObject ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Dynamic.DynamicObject.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; DynamicObject();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Dynamic.Runtime</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>Permite a los tipos derivados inicializar una nueva instancia del tipo <see cref="T:System.Dynamic.DynamicObject" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 No se puede crear directamente una instancia de la <xref:System.Dynamic.DynamicObject> clase. Para implementar el comportamiento dinámico, debe heredar de la <xref:System.Dynamic.DynamicObject> clase e invalidar los métodos necesarios.  
  
 En C#, para habilitar el comportamiento dinámico para las instancias de las clases derivadas de la <xref:System.Dynamic.DynamicObject> (clase), debe usar el `dynamic` palabra clave. Para obtener más información, vea [Uso del tipo dynamic](~/docs/csharp/programming-guide/types/using-type-dynamic.md).  
  
 En Visual Basic, se admiten operaciones dinámicas mediante el enlace en tiempo de ejecución. Para obtener más información, consulte [temprana y enlace tardío](https://msdn.microsoft.com/library/d6ff7f1e-b94f-4205-ab8d-5cfa91758724).  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra cómo crear una instancia de las clases que se derivan de la <xref:System.Dynamic.DynamicObject> clase.  
  
```csharp  
public class SampleDynamicObject : DynamicObject {}  
//...  
dynamic sampleObject = new SampleDynamicObject ();  
```  
  
```vb  
Public Class SampleDynamicObject   
    Inherits DynamicObject  
'...  
Dim sampleObject As Object = New SampleDynamicObject()  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetDynamicMemberNames">
      <MemberSignature Language="C#" Value="public virtual System.Collections.Generic.IEnumerable&lt;string&gt; GetDynamicMemberNames ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.Generic.IEnumerable`1&lt;string&gt; GetDynamicMemberNames() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Dynamic.DynamicObject.GetDynamicMemberNames" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetDynamicMemberNames () As IEnumerable(Of String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Collections::Generic::IEnumerable&lt;System::String ^&gt; ^ GetDynamicMemberNames();" />
      <MemberSignature Language="F#" Value="abstract member GetDynamicMemberNames : unit -&gt; seq&lt;string&gt;&#xA;override this.GetDynamicMemberNames : unit -&gt; seq&lt;string&gt;" Usage="dynamicObject.GetDynamicMemberNames " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Dynamic.Runtime</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Devuelve la enumeración de todos los nombres de miembro dinámicos.</summary>
        <returns>Secuencia que contiene nombres de miembros dinámicos.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método existe solo con fines de depuración.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetMetaObject">
      <MemberSignature Language="C#" Value="public virtual System.Dynamic.DynamicMetaObject GetMetaObject (System.Linq.Expressions.Expression parameter);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Dynamic.DynamicMetaObject GetMetaObject(class System.Linq.Expressions.Expression parameter) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Dynamic.DynamicObject.GetMetaObject(System.Linq.Expressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetMetaObject (parameter As Expression) As DynamicMetaObject" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Dynamic::DynamicMetaObject ^ GetMetaObject(System::Linq::Expressions::Expression ^ parameter);" />
      <MemberSignature Language="F#" Value="abstract member GetMetaObject : System.Linq.Expressions.Expression -&gt; System.Dynamic.DynamicMetaObject&#xA;override this.GetMetaObject : System.Linq.Expressions.Expression -&gt; System.Dynamic.DynamicMetaObject" Usage="dynamicObject.GetMetaObject parameter" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Dynamic.IDynamicMetaObjectProvider.GetMetaObject(System.Linq.Expressions.Expression)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Dynamic.Runtime</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Dynamic.DynamicMetaObject</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="parameter" Type="System.Linq.Expressions.Expression" />
      </Parameters>
      <Docs>
        <param name="parameter">Expresión que representa el objeto <see cref="T:System.Dynamic.DynamicMetaObject" /> que se va a enviar a los métodos virtuales dinámicos.</param>
        <summary>Proporciona un objeto <see cref="T:System.Dynamic.DynamicMetaObject" /> que envía a los métodos virtuales dinámicos. El objeto se puede encapsular dentro de otro objeto <see cref="T:System.Dynamic.DynamicMetaObject" /> para proporcionar un comportamiento personalizado para acciones individuales. Este método admite la infraestructura de Dynamic Language Runtime para los implementadores de lenguaje y no está pensado para que se use directamente en el código.</summary>
        <returns>Objeto de tipo <see cref="T:System.Dynamic.DynamicMetaObject" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryBinaryOperation">
      <MemberSignature Language="C#" Value="public virtual bool TryBinaryOperation (System.Dynamic.BinaryOperationBinder binder, object arg, out object result);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool TryBinaryOperation(class System.Dynamic.BinaryOperationBinder binder, object arg, [out] object&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Dynamic.DynamicObject.TryBinaryOperation(System.Dynamic.BinaryOperationBinder,System.Object,System.Object@)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function TryBinaryOperation (binder As BinaryOperationBinder, arg As Object, ByRef result As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool TryBinaryOperation(System::Dynamic::BinaryOperationBinder ^ binder, System::Object ^ arg, [Runtime::InteropServices::Out] System::Object ^ % result);" />
      <MemberSignature Language="F#" Value="abstract member TryBinaryOperation : System.Dynamic.BinaryOperationBinder * obj *  -&gt; bool&#xA;override this.TryBinaryOperation : System.Dynamic.BinaryOperationBinder * obj *  -&gt; bool" Usage="dynamicObject.TryBinaryOperation (binder, arg, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Dynamic.Runtime</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="binder" Type="System.Dynamic.BinaryOperationBinder" />
        <Parameter Name="arg" Type="System.Object" />
        <Parameter Name="result" Type="System.Object" RefType="out" />
      </Parameters>
      <Docs>
        <param name="binder">Proporciona información sobre la operación binaria. La propiedad <c>binder.Operation</c> devuelve un objeto <see cref="T:System.Linq.Expressions.ExpressionType" />. Por ejemplo, para la instrucción <c>sum = first + second</c>, donde <c>first</c> y <c>second</c> se derivan de la clase <see langword="DynamicObject" />, <c>binder.Operation</c> devuelve <c>ExpressionType.Add</c>.</param>
        <param name="arg">Operando derecho de la operación binaria. Por ejemplo, para la instrucción <c>sum = first + second</c>, donde <c>first</c> y <c>second</c> se derivan de la clase <see langword="DynamicObject" />, <paramref name="arg" /> es igual a <c>second</c>.</param>
        <param name="result">Resultado de la operación binaria.</param>
        <summary>Proporciona la implementación de operaciones binarias. Las clases derivadas de la clase <see cref="T:System.Dynamic.DynamicObject" /> pueden invalidar este método para especificar un comportamiento dinámico para operaciones como la suma o la multiplicación.</summary>
        <returns><see langword="true" /> si la operación es correcta; de lo contrario, <see langword="false" />. Si este método devuelve <see langword="false" />, el enlazador del lenguaje en tiempo de ejecución determina el comportamiento. (En la mayoría de los casos, se inicia una excepción específica del lenguaje en tiempo de ejecución).</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Las clases derivadas de la <xref:System.Dynamic.DynamicObject> clase puede invalidar este método para especificar cómo se debe realizar las operaciones binarias para un objeto dinámico. Cuando no se reemplaza el método, el enlazador del lenguaje en tiempo de ejecución determina el comportamiento. (En la mayoría de los casos, se inicia una excepción específica del lenguaje en tiempo de ejecución).  
  
 Este método se llama cuando tiene operaciones binarias como suma o multiplicación. Por ejemplo, si la <xref:System.Dynamic.DynamicObject.TryBinaryOperation%2A> se invalida el método, se invoca automáticamente para instrucciones como `sum = first + second` o `multiply = first*second`, donde `first` se deriva el `DynamicObject` clase.  
  
 Puede obtener información sobre el tipo de la operación binaria mediante el `Operation` propiedad de la `binder` parámetro.  
  
 Si el objeto dinámico solo se usa en C# y Visual Basic, el `binder.Operation` propiedad puede tener uno de los siguientes valores de la <xref:System.Linq.Expressions.ExpressionType> enumeración. Sin embargo, en otros lenguajes, como IronPython o IronRuby, puede tener otros valores.
  
|Valor|Descripción|C#|Visual Basic|  
|-----------|-----------------|---------|------------------|  
|`Add`|Una operación de suma sin comprobación de desbordamiento, para operandos numéricos.|`a + b`|`a + b`|  
|`AddAssign`|Una operación de asignación compuesta de suma sin comprobación de desbordamiento, para operandos numéricos.|`a += b`|No se admite.|  
|`And`|Bit a bit `AND` operación.|`a & b`|`a And b`|  
|`AndAssign`|Bit a bit `AND` operación de asignación compuesta.|`a &= b`|No se admite.|  
|`Divide`|Una operación de división aritmética.|`a / b`|`a / b`|  
|`DivideAssign`|Una operación de asignación compuesta de división aritmética.|`a /= b`|No se admite.|  
|`ExclusiveOr`|Bit a bit `XOR` operación.|`a ^ b`|`a Xor b`|  
|`ExclusiveOrAssign`|Bit a bit `XOR` operación de asignación compuesta.|`a ^= b`|No se admite.|  
|`GreaterThan`|Una comparación "mayor que".|`a > b`|`a > b`|  
|`GreaterThanOrEqual`|Una comparación "mayor o igual a".|`a >= b`|No se admite.|  
|`LeftShift`|Una operación de desplazamiento a la izquierda bit a bit.|`a << b`|`a << b`|  
|`LeftShiftAssign`|Una operación de asignación compuesta de desplazamiento a la izquierda bit a bit.|`a <<= b`|No se admite.|  
|`LessThan`|Una comparación "menor que".|`a < b`|`a < b`|  
|`LessThanOrEqual`|Una comparación "menor o igual que".|`a <= b`|No se admite.|  
|`Modulo`|Una operación de resto aritmético.|`a % b`|`a Mod b`|  
|`ModuloAssign`|Operación de asignación compuesta y resto aritmético.|`a %= b`|No se admite.|  
|`Multiply`|Una operación de multiplicación sin comprobación de desbordamiento, para operandos numéricos.|`a * b`|`a * b`|  
|`MultiplyAssign`|Una operación de asignación compuesta de multiplicación sin comprobación de desbordamiento, para operandos numéricos.|`a *= b`|No se admite.|  
|`NotEqual`|Una comparación de desigualdad.|`a != b`|`a <> b`|  
|`Or`|Bit a bit o lógica `OR` operación.|`a &#124; b`|`a Or b`|  
|`OrAssign`|Bit a bit o lógica `OR` asignación compuesta.|`a &#124;= b`|No se admite.|  
|`Power`|Una operación matemática de elevar un número a una potencia.|No se admite.|`a ^ b`|  
|`RightShift`|Una operación de desplazamiento a la derecha bit a bit.|`a >> b`|`a >> b`|  
|`RightShiftAssign`|Una operación de asignación compuesta de desplazamiento a la derecha bit a bit.|`a >>= b`|No se admite.|  
|`Subtract`|Una operación de resta sin comprobación de desbordamiento, para operandos numéricos.|`a - b`|`a - b`|  
|`SubtractAssign`|Una operación de asignación compuesta de resta sin comprobación de desbordamiento, para operandos numéricos.|`a -= b`|No se admite.|  
  
> [!NOTE]
>  Para implementar `OrElse` (`a || b`) y `AndAlso` (`a && b`) las operaciones para objetos dinámicos en C#, puede desear implementar tanto el <xref:System.Dynamic.DynamicObject.TryUnaryOperation%2A> método y el <xref:System.Dynamic.DynamicObject.TryBinaryOperation%2A> método.  
>   
>  El `OrElse` consta de operación de unario `IsTrue` operación y el archivo binario `Or` operación. El `Or` se realiza solo si el resultado de la `IsTrue` operación es `false`.  
>   
>  El `AndAlso` consta de operación de unario `IsFalse` operación y el archivo binario `And` operación. El `And` se realiza solo si el resultado de la `IsFalse` operación es `false`.  
  
   
  
## Examples  
 Suponga que necesita una estructura de datos para almacenar representaciones numéricas y textuales de números, y desea definir las operaciones matemáticas básicas como la suma o resta de este tipo de datos.  
  
 En el ejemplo de código siguiente se muestra el `DynamicNumber` (clase), que se deriva el <xref:System.Dynamic.DynamicObject> clase. `DynamicNumber` invalida el <xref:System.Dynamic.DynamicObject.TryBinaryOperation%2A> método para habilitar las operaciones matemáticas. También invalida la <xref:System.Dynamic.DynamicObject.TrySetMember%2A> y <xref:System.Dynamic.DynamicObject.TryGetMember%2A> métodos para habilitar el acceso a los elementos.  
  
 En este ejemplo, se admiten solo las operaciones de suma y resta. Si se intenta escribir una instrucción como `resultNumber = firstNumber*secondNumber`, se produce una excepción en tiempo de ejecución.  
  
 [!code-csharp[System.Dynamic.DynamicObject#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.dynamic.dynamicobject/cs/program.cs#2)]
 [!code-vb[System.Dynamic.DynamicObject#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.dynamic.dynamicobject/vb/module1.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TryConvert">
      <MemberSignature Language="C#" Value="public virtual bool TryConvert (System.Dynamic.ConvertBinder binder, out object result);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool TryConvert(class System.Dynamic.ConvertBinder binder, [out] object&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Dynamic.DynamicObject.TryConvert(System.Dynamic.ConvertBinder,System.Object@)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function TryConvert (binder As ConvertBinder, ByRef result As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool TryConvert(System::Dynamic::ConvertBinder ^ binder, [Runtime::InteropServices::Out] System::Object ^ % result);" />
      <MemberSignature Language="F#" Value="abstract member TryConvert : System.Dynamic.ConvertBinder *  -&gt; bool&#xA;override this.TryConvert : System.Dynamic.ConvertBinder *  -&gt; bool" Usage="dynamicObject.TryConvert (binder, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Dynamic.Runtime</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="binder" Type="System.Dynamic.ConvertBinder" />
        <Parameter Name="result" Type="System.Object" RefType="out" />
      </Parameters>
      <Docs>
        <param name="binder">Proporciona información sobre la operación de conversión. La propiedad <c>binder.Type</c> proporciona el tipo en el que se debe convertir el objeto. Por ejemplo, para la instrucción <c>(String)sampleObject</c> en C# (<c>CType(sampleObject, Type)</c> en Visual Basic), donde <c>sampleObject</c> es una instancia de la clase derivada de la clase <see cref="T:System.Dynamic.DynamicObject" />, <c>binder.Type</c> devuelve el tipo <see cref="T:System.String" />. La propiedad <c>binder.Explicit</c> proporciona información sobre el tipo de conversión que se produce. Devuelve <see langword="true" /> para la conversión explícita y <see langword="false" /> para la conversión implícita.</param>
        <param name="result">Resultado de la operación de conversión de tipos.</param>
        <summary>Proporciona la implementación de las operaciones de conversión de tipos. Las clases derivadas de la clase <see cref="T:System.Dynamic.DynamicObject" /> pueden invalidar este método para especificar el comportamiento dinámico de las operaciones que convierten un objeto de un tipo a otro.</summary>
        <returns><see langword="true" /> si la operación es correcta; de lo contrario, <see langword="false" />. Si este método devuelve <see langword="false" />, el enlazador del lenguaje en tiempo de ejecución determina el comportamiento. (En la mayoría de los casos, se inicia una excepción específica del lenguaje en tiempo de ejecución).</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Las clases derivadas de la <xref:System.Dynamic.DynamicObject> clase puede invalidar este método para especificar cómo se debe realizar una conversión de tipos para un objeto dinámico. Cuando no se reemplaza el método, el enlazador del lenguaje en tiempo de ejecución determina el comportamiento. (En la mayoría de los casos, se inicia una excepción específica del lenguaje en tiempo de ejecución).  
  
 En C#, si se invalida este método, se invoca automáticamente cuando haya una conversión explícita o implícita, como se muestra en el ejemplo de código siguiente.  
  
 En Visual Basic, se admite solo la conversión explícita. Si invalida este método, llame a él mediante el <xref:Microsoft.VisualBasic.Conversion.CTypeDynamic%2A> o <xref:Microsoft.VisualBasic.Conversion.CTypeDynamic%2A> funciones.  
  
```csharp  
// Explicit conversion.  
String sampleExplicit = (String)sampleObject;  
// Implicit conversion.  
String sampleImplicit = sampleObject;  
```  
  
```vb  
// Explicit conversion - first variant.  
Dim testExplicit1 = CTypeDynamic(Of String)(sampleObject)  
// Explicit conversion - second variant.  
Dim testExplicit2 = CTypeDynamic(sampleObject, GetType(String))  
```  
  
   
  
## Examples  
 Suponga que necesita una estructura de datos para almacenar representaciones numéricas y textuales de números, y desea definir conversiones de esta estructura de datos para las cadenas y enteros.  
  
 En el ejemplo de código siguiente se muestra el `DynamicNumber` (clase), que se deriva el <xref:System.Dynamic.DynamicObject> clase. `DynamicNumber` invalida el <xref:System.Dynamic.DynamicObject.TryConvert%2A> método para habilitar la conversión de tipos. También invalida la <xref:System.Dynamic.DynamicObject.TrySetMember%2A> y <xref:System.Dynamic.DynamicObject.TryGetMember%2A> métodos para habilitar el acceso a los elementos de datos.  
  
 En este ejemplo, se admite solo la conversión a cadenas y enteros. Si se intenta convertir un objeto en cualquier otro tipo, se produce una excepción en tiempo de ejecución.  
  
 [!code-csharp[System.Dynamic.DynamicObject#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.dynamic.dynamicobject/cs/program.cs#3)]
 [!code-vb[System.Dynamic.DynamicObject#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.dynamic.dynamicobject/vb/module1.vb#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TryCreateInstance">
      <MemberSignature Language="C#" Value="public virtual bool TryCreateInstance (System.Dynamic.CreateInstanceBinder binder, object[] args, out object result);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool TryCreateInstance(class System.Dynamic.CreateInstanceBinder binder, object[] args, [out] object&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Dynamic.DynamicObject.TryCreateInstance(System.Dynamic.CreateInstanceBinder,System.Object[],System.Object@)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function TryCreateInstance (binder As CreateInstanceBinder, args As Object(), ByRef result As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool TryCreateInstance(System::Dynamic::CreateInstanceBinder ^ binder, cli::array &lt;System::Object ^&gt; ^ args, [Runtime::InteropServices::Out] System::Object ^ % result);" />
      <MemberSignature Language="F#" Value="abstract member TryCreateInstance : System.Dynamic.CreateInstanceBinder * obj[] *  -&gt; bool&#xA;override this.TryCreateInstance : System.Dynamic.CreateInstanceBinder * obj[] *  -&gt; bool" Usage="dynamicObject.TryCreateInstance (binder, args, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Dynamic.Runtime</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="binder" Type="System.Dynamic.CreateInstanceBinder" />
        <Parameter Name="args" Type="System.Object[]" />
        <Parameter Name="result" Type="System.Object" RefType="out" />
      </Parameters>
      <Docs>
        <param name="binder">Proporciona información sobre la operación de inicialización.</param>
        <param name="args">Argumentos que se pasan al objeto durante la inicialización. Por ejemplo, para la operación <c>new SampleType(100)</c>, donde <c>SampleType</c> es el tipo derivado de la clase <see cref="T:System.Dynamic.DynamicObject" />, <c>args[0]</c> es igual que 100.</param>
        <param name="result">Resultado de la inicialización.</param>
        <summary>Proporciona la implementación de las operaciones que inicializan una nueva instancia de un objeto dinámico. Este método no está pensado para su uso en C# o Visual Basic.</summary>
        <returns><see langword="true" /> si la operación es correcta; de lo contrario, <see langword="false" />. Si este método devuelve <see langword="false" />, el enlazador del lenguaje en tiempo de ejecución determina el comportamiento. (En la mayoría de los casos, se inicia una excepción específica del lenguaje en tiempo de ejecución).</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Las clases derivadas de la <xref:System.Dynamic.DynamicObject> clase puede invalidar este método para especificar cómo se debe inicializar una nueva instancia del objeto dinámico. Cuando no se reemplaza el método, el enlazador del lenguaje en tiempo de ejecución determina el comportamiento. (En la mayoría de los casos, se inicia una excepción específica del lenguaje en tiempo de ejecución).  
  
 Los compiladores de Visual Basic y C# nunca emiten código para usar este método porque no admiten tipos de primera clase. Este método está pensado para los idiomas que admiten la inicialización de objetos dinámicos mediante sintaxis similar a `dynamic new`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TryDeleteIndex">
      <MemberSignature Language="C#" Value="public virtual bool TryDeleteIndex (System.Dynamic.DeleteIndexBinder binder, object[] indexes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool TryDeleteIndex(class System.Dynamic.DeleteIndexBinder binder, object[] indexes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Dynamic.DynamicObject.TryDeleteIndex(System.Dynamic.DeleteIndexBinder,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function TryDeleteIndex (binder As DeleteIndexBinder, indexes As Object()) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool TryDeleteIndex(System::Dynamic::DeleteIndexBinder ^ binder, cli::array &lt;System::Object ^&gt; ^ indexes);" />
      <MemberSignature Language="F#" Value="abstract member TryDeleteIndex : System.Dynamic.DeleteIndexBinder * obj[] -&gt; bool&#xA;override this.TryDeleteIndex : System.Dynamic.DeleteIndexBinder * obj[] -&gt; bool" Usage="dynamicObject.TryDeleteIndex (binder, indexes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Dynamic.Runtime</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="binder" Type="System.Dynamic.DeleteIndexBinder" />
        <Parameter Name="indexes" Type="System.Object[]" />
      </Parameters>
      <Docs>
        <param name="binder">Proporciona información sobre la eliminación.</param>
        <param name="indexes">Índices que se van a eliminar.</param>
        <summary>Proporciona la implementación de las operaciones que eliminan un objeto por índice. Este método no está pensado para su uso en C# o Visual Basic.</summary>
        <returns><see langword="true" /> si la operación es correcta; de lo contrario, <see langword="false" />. Si este método devuelve <see langword="false" />, el enlazador del lenguaje en tiempo de ejecución determina el comportamiento. (En la mayoría de los casos, se inicia una excepción específica del lenguaje en tiempo de ejecución).</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Las clases derivadas de la <xref:System.Dynamic.DynamicObject> clase puede invalidar este método para especificar cómo se debería eliminar un valor que tiene un índice especificado. Cuando no se reemplaza el método, el enlazador del lenguaje en tiempo de ejecución determina el comportamiento. (En la mayoría de los casos, se inicia una excepción específica del lenguaje en tiempo de ejecución).  
  
 Los compiladores de Visual Basic y C# nunca emiten código para usar este método porque no admiten este tipo de operación. Este método está pensado para los idiomas que admiten la sintaxis para eliminar los objetos por índice, como `del sampleObject[1,2]` en Python.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TryDeleteMember">
      <MemberSignature Language="C#" Value="public virtual bool TryDeleteMember (System.Dynamic.DeleteMemberBinder binder);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool TryDeleteMember(class System.Dynamic.DeleteMemberBinder binder) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Dynamic.DynamicObject.TryDeleteMember(System.Dynamic.DeleteMemberBinder)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function TryDeleteMember (binder As DeleteMemberBinder) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool TryDeleteMember(System::Dynamic::DeleteMemberBinder ^ binder);" />
      <MemberSignature Language="F#" Value="abstract member TryDeleteMember : System.Dynamic.DeleteMemberBinder -&gt; bool&#xA;override this.TryDeleteMember : System.Dynamic.DeleteMemberBinder -&gt; bool" Usage="dynamicObject.TryDeleteMember binder" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Dynamic.Runtime</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="binder" Type="System.Dynamic.DeleteMemberBinder" />
      </Parameters>
      <Docs>
        <param name="binder">Proporciona información sobre la eliminación.</param>
        <summary>Proporciona la implementación de las operaciones que eliminan un miembro de objeto. Este método no está pensado para su uso en C# o Visual Basic.</summary>
        <returns><see langword="true" /> si la operación es correcta; de lo contrario, <see langword="false" />. Si este método devuelve <see langword="false" />, el enlazador del lenguaje en tiempo de ejecución determina el comportamiento. (En la mayoría de los casos, se inicia una excepción específica del lenguaje en tiempo de ejecución).</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Las clases derivadas de la <xref:System.Dynamic.DynamicObject> clase puede invalidar este método para especificar cómo se debería eliminar un miembro de objeto. Cuando no se reemplaza este método, el enlazador del lenguaje en tiempo de ejecución determina el comportamiento. (En la mayoría de los casos, se inicia una excepción específica del lenguaje en tiempo de ejecución).  
  
 Los compiladores de Visual Basic y C# nunca emiten código para usar este método porque no admiten este tipo de operación. Este método está pensado para los idiomas que admiten la sintaxis para eliminar miembros, como `del sampleObject.SampleMember` en Python.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TryGetIndex">
      <MemberSignature Language="C#" Value="public virtual bool TryGetIndex (System.Dynamic.GetIndexBinder binder, object[] indexes, out object result);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool TryGetIndex(class System.Dynamic.GetIndexBinder binder, object[] indexes, [out] object&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Dynamic.DynamicObject.TryGetIndex(System.Dynamic.GetIndexBinder,System.Object[],System.Object@)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function TryGetIndex (binder As GetIndexBinder, indexes As Object(), ByRef result As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool TryGetIndex(System::Dynamic::GetIndexBinder ^ binder, cli::array &lt;System::Object ^&gt; ^ indexes, [Runtime::InteropServices::Out] System::Object ^ % result);" />
      <MemberSignature Language="F#" Value="abstract member TryGetIndex : System.Dynamic.GetIndexBinder * obj[] *  -&gt; bool&#xA;override this.TryGetIndex : System.Dynamic.GetIndexBinder * obj[] *  -&gt; bool" Usage="dynamicObject.TryGetIndex (binder, indexes, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Dynamic.Runtime</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="binder" Type="System.Dynamic.GetIndexBinder" />
        <Parameter Name="indexes" Type="System.Object[]" />
        <Parameter Name="result" Type="System.Object" RefType="out" />
      </Parameters>
      <Docs>
        <param name="binder">Proporciona información sobre la operación.</param>
        <param name="indexes">Índices que se usan en la operación. Por ejemplo, para la operación <c>sampleObject[3]</c> en C# (<c>sampleObject(3)</c> en Visual Basic), donde <c>sampleObject</c> se deriva de la clase <see langword="DynamicObject" />, <c>indexes[0]</c> es igual que 3.</param>
        <param name="result">Resultado de la operación de índice.</param>
        <summary>Proporciona la implementación de las operaciones que obtienen un valor por índice. Las clases derivadas de la clase <see cref="T:System.Dynamic.DynamicObject" /> pueden invalidar este método para especificar un comportamiento dinámico para las operaciones de indización.</summary>
        <returns><see langword="true" /> si la operación es correcta; de lo contrario, <see langword="false" />. Si este método devuelve <see langword="false" />, el enlazador del lenguaje en tiempo de ejecución determina el comportamiento. (En la mayoría de los casos, se inicia una excepción en tiempo de ejecución).</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Las clases derivadas de la <xref:System.Dynamic.DynamicObject> clase puede invalidar este método para especificar cómo obtener un valor de índice se debe realizar para un objeto dinámico. Cuando no se reemplaza el método, el enlazador del lenguaje en tiempo de ejecución determina el comportamiento. (En la mayoría de los casos, se inicia una excepción en tiempo de ejecución).  
  
 Si se invalida este método, se invoca automáticamente cuando haya una operación como `sampleObject[3]` en C# o `sampleObject(3)` en Visual Basic, donde `sampleObject` se deriva el <xref:System.Dynamic.DynamicObject> clase.  
  
   
  
## Examples  
 Suponga que desea crear un objeto en el que las propiedades pueden ser acceder mediante nombres como `Property0`, `Property1`, y así sucesivamente, o por índice, por lo que, por ejemplo, `sampleObject.Property0` es equivalente a `sampleObject[0]` en C# o `sampleObject(0)` en Visual Basic.  
  
 En el ejemplo de código siguiente se muestra el `SampleDynamicObject` (clase), que se deriva el <xref:System.Dynamic.DynamicObject> clase. El `SampleDynamicObject` clase contiene un objeto de la `Dictionary<string, object>` tipo (`Dictionary(Of String, Object)` en Visual Basic) para almacenar los pares clave-valor. `SampleDynamicObject` invalida el <xref:System.Dynamic.DynamicObject.TrySetIndex%2A> y <xref:System.Dynamic.DynamicObject.TryGetIndex%2A> métodos para habilitar el acceso por índice. Invalida el <xref:System.Dynamic.DynamicObject.TrySetMember%2A> y <xref:System.Dynamic.DynamicObject.TryGetMember%2A> métodos para habilitar el acceso por nombre de propiedad.  
  
 [!code-csharp[System.Dynamic.DynamicObject#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.dynamic.dynamicobject/cs/program.cs#4)]
 [!code-vb[System.Dynamic.DynamicObject#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.dynamic.dynamicobject/vb/module1.vb#4)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TryGetMember">
      <MemberSignature Language="C#" Value="public virtual bool TryGetMember (System.Dynamic.GetMemberBinder binder, out object result);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool TryGetMember(class System.Dynamic.GetMemberBinder binder, [out] object&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Dynamic.DynamicObject.TryGetMember(System.Dynamic.GetMemberBinder,System.Object@)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function TryGetMember (binder As GetMemberBinder, ByRef result As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool TryGetMember(System::Dynamic::GetMemberBinder ^ binder, [Runtime::InteropServices::Out] System::Object ^ % result);" />
      <MemberSignature Language="F#" Value="abstract member TryGetMember : System.Dynamic.GetMemberBinder *  -&gt; bool&#xA;override this.TryGetMember : System.Dynamic.GetMemberBinder *  -&gt; bool" Usage="dynamicObject.TryGetMember (binder, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Dynamic.Runtime</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="binder" Type="System.Dynamic.GetMemberBinder" />
        <Parameter Name="result" Type="System.Object" RefType="out" />
      </Parameters>
      <Docs>
        <param name="binder">Proporciona información sobre el objeto que llamó a la operación dinámica. La propiedad <c>binder.Name</c> proporciona el nombre del miembro en el que se realiza la operación dinámica. Por ejemplo, para la instrucción <c>Console.WriteLine(sampleObject.SampleProperty)</c>, donde <c>sampleObject</c> es una instancia de la clase derivada de la clase <see cref="T:System.Dynamic.DynamicObject" />, <c>binder.Name</c> devuelve "SampleProperty". La propiedad <c>binder.IgnoreCase</c> especifica si el nombre de miembro distingue mayúsculas de minúsculas.</param>
        <param name="result">Resultado de la operación Get. Por ejemplo, si se llama al método para una propiedad, se puede asignar el valor de la propiedad a <paramref name="result" />.</param>
        <summary>Proporciona la implementación de las operaciones que obtienen valores de miembro. Las clases derivadas de la clase <see cref="T:System.Dynamic.DynamicObject" /> pueden invalidar este método para especificar un comportamiento dinámico para operaciones como obtener el valor de una propiedad.</summary>
        <returns><see langword="true" /> si la operación es correcta; de lo contrario, <see langword="false" />. Si este método devuelve <see langword="false" />, el enlazador del lenguaje en tiempo de ejecución determina el comportamiento. (En la mayoría de los casos, se inicia una excepción en tiempo de ejecución).</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Las clases derivadas de la <xref:System.Dynamic.DynamicObject> clase puede invalidar este método para especificar cómo se deben realizar las operaciones que obtienen valores de miembro para un objeto dinámico. Cuando no se reemplaza el método, el enlazador del lenguaje en tiempo de ejecución determina el comportamiento. (En la mayoría de los casos, se inicia una excepción en tiempo de ejecución).  
  
 Este método se llama cuando tiene instrucciones como `Console.WriteLine(sampleObject.SampleProperty)`, donde `sampleObject` es una instancia de la clase derivada de la <xref:System.Dynamic.DynamicObject> clase.  
  
 También puede agregar sus propios miembros a las clases derivadas de la `DynamicObject` clase. Si su clase define propiedades y también invalida la <xref:System.Dynamic.DynamicObject.TrySetMember%2A> método, dynamic language runtime (DLR) usa primero el enlazador del lenguaje para buscar una definición estática de una propiedad en la clase. Si no hay ninguna propiedad de este tipo, DLR llama a la <xref:System.Dynamic.DynamicObject.TrySetMember%2A> método.  
  
   
  
## Examples  
 Suponga que desea proporcionar una sintaxis alternativa para tener acceso a los valores en un diccionario, así que, en lugar de escribir `sampleDictionary["Text"] = "Sample text"` (`sampleDictionary("Text") = "Sample text"` en Visual Basic), puede escribir `sampleDictionary.Text = "Sample text"`. Además, esta sintaxis debe ser entre mayúsculas y minúsculas, por lo que `sampleDictionary.Text` es equivalente a `sampleDictionary.text`.  
  
 En el ejemplo de código siguiente se muestra el `DynamicDictionary` (clase), que se deriva el <xref:System.Dynamic.DynamicObject> clase. El `DynamicDictionary` clase contiene un objeto de la `Dictionary<string, object>` tipo (`Dictionary(Of String, Object)` en Visual Basic) para almacenar los pares clave-valor e invalida el <xref:System.Dynamic.DynamicObject.TrySetMember%2A> y <xref:System.Dynamic.DynamicObject.TryGetMember%2A> métodos para admitir la nueva sintaxis. También proporciona un `Count` contiene la propiedad, que muestra cuántos propiedades dinámicas en el diccionario.  
  
 [!code-csharp[System.Dynamic.DynamicObject#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.dynamic.dynamicobject/cs/program.cs#1)]
 [!code-vb[System.Dynamic.DynamicObject#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.dynamic.dynamicobject/vb/module1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TryInvoke">
      <MemberSignature Language="C#" Value="public virtual bool TryInvoke (System.Dynamic.InvokeBinder binder, object[] args, out object result);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool TryInvoke(class System.Dynamic.InvokeBinder binder, object[] args, [out] object&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Dynamic.DynamicObject.TryInvoke(System.Dynamic.InvokeBinder,System.Object[],System.Object@)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function TryInvoke (binder As InvokeBinder, args As Object(), ByRef result As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool TryInvoke(System::Dynamic::InvokeBinder ^ binder, cli::array &lt;System::Object ^&gt; ^ args, [Runtime::InteropServices::Out] System::Object ^ % result);" />
      <MemberSignature Language="F#" Value="abstract member TryInvoke : System.Dynamic.InvokeBinder * obj[] *  -&gt; bool&#xA;override this.TryInvoke : System.Dynamic.InvokeBinder * obj[] *  -&gt; bool" Usage="dynamicObject.TryInvoke (binder, args, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Dynamic.Runtime</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="binder" Type="System.Dynamic.InvokeBinder" />
        <Parameter Name="args" Type="System.Object[]" />
        <Parameter Name="result" Type="System.Object" RefType="out" />
      </Parameters>
      <Docs>
        <param name="binder">Proporciona información sobre la operación de invocación.</param>
        <param name="args">Argumentos que se pasan al objeto durante la operación de invocación. Por ejemplo, para la operación <c>sampleObject(100)</c>, donde <c>sampleObject</c> se deriva de la clase <see cref="T:System.Dynamic.DynamicObject" />, <c>args[0]</c> es igual que 100.</param>
        <param name="result">Resultado de la invocación de objeto.</param>
        <summary>Proporciona la implementación para las operaciones que invocan un objeto. Las clases derivadas de la clase <see cref="T:System.Dynamic.DynamicObject" /> pueden invalidar este método para especificar un comportamiento dinámico para operaciones como invocar un objeto o un delegado.</summary>
        <returns><see langword="true" /> si la operación es correcta; de lo contrario, <see langword="false" />. Si este método devuelve <see langword="false" />, el enlazador del lenguaje en tiempo de ejecución determina el comportamiento. (En la mayoría de los casos, se inicia una excepción específica del lenguaje en tiempo de ejecución).</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Las clases derivadas de la <xref:System.Dynamic.DynamicObject> clase puede invalidar este método para especificar cómo se deben realizar las operaciones que invocan un objeto para un objeto dinámico. Cuando no se reemplaza el método, el enlazador del lenguaje en tiempo de ejecución determina el comportamiento. (En la mayoría de los casos, se inicia una excepción en tiempo de ejecución).  
  
 Si se invalida este método, se invoca automáticamente cuando haya una operación como `sampleObject(100)`, donde `sampleObject` se deriva el <xref:System.Dynamic.DynamicObject> clase.  
  
 Se admite la operación para invocar un objeto en C#, pero no en Visual Basic. El compilador de Visual Basic nunca emite código para usar este método y el lenguaje Visual Basic no admite la sintaxis similar a `sampleObject(100)`.  
  
   
  
## Examples  
 Suponga que necesita una estructura de datos para almacenar representaciones numéricas y textuales de números. Desea poder especificar individualmente el valor para cada propiedad y poder inicializar todas las propiedades de una sola instrucción.  
  
 En el ejemplo de código siguiente se muestra el `DynamicNumber` (clase), que se deriva el <xref:System.Dynamic.DynamicObject> clase. `DynamicNumber` invalida el <xref:System.Dynamic.DynamicObject.TryInvoke%2A> método para habilitar la inicialización de todas las propiedades al mismo tiempo. También invalida la <xref:System.Dynamic.DynamicObject.TrySetMember%2A> y <xref:System.Dynamic.DynamicObject.TryGetMember%2A> métodos para habilitar el acceso a las propiedades de objeto individuales.  
  
 [!code-csharp[System.Dynamic.DynamicObject#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.dynamic.dynamicobject/cs/program.cs#5)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TryInvokeMember">
      <MemberSignature Language="C#" Value="public virtual bool TryInvokeMember (System.Dynamic.InvokeMemberBinder binder, object[] args, out object result);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool TryInvokeMember(class System.Dynamic.InvokeMemberBinder binder, object[] args, [out] object&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Dynamic.DynamicObject.TryInvokeMember(System.Dynamic.InvokeMemberBinder,System.Object[],System.Object@)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function TryInvokeMember (binder As InvokeMemberBinder, args As Object(), ByRef result As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool TryInvokeMember(System::Dynamic::InvokeMemberBinder ^ binder, cli::array &lt;System::Object ^&gt; ^ args, [Runtime::InteropServices::Out] System::Object ^ % result);" />
      <MemberSignature Language="F#" Value="abstract member TryInvokeMember : System.Dynamic.InvokeMemberBinder * obj[] *  -&gt; bool&#xA;override this.TryInvokeMember : System.Dynamic.InvokeMemberBinder * obj[] *  -&gt; bool" Usage="dynamicObject.TryInvokeMember (binder, args, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Dynamic.Runtime</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="binder" Type="System.Dynamic.InvokeMemberBinder" />
        <Parameter Name="args" Type="System.Object[]" />
        <Parameter Name="result" Type="System.Object" RefType="out" />
      </Parameters>
      <Docs>
        <param name="binder">Proporciona información sobre la operación dinámica. La propiedad <c>binder.Name</c> proporciona el nombre del miembro en el que se realiza la operación dinámica. Por ejemplo, para la instrucción <c>sampleObject.SampleMethod(100)</c>, donde <c>sampleObject</c> es una instancia de la clase derivada de la clase <see cref="T:System.Dynamic.DynamicObject" />, <c>binder.Name</c> devuelve "SampleMethod". La propiedad <c>binder.IgnoreCase</c> especifica si el nombre de miembro distingue mayúsculas de minúsculas.</param>
        <param name="args">Argumentos que se pasan al miembro de objeto durante la operación de invocación. Por ejemplo, para la instrucción <c>sampleObject.SampleMethod(100)</c>, donde <c>sampleObject</c> se deriva de la clase <see cref="T:System.Dynamic.DynamicObject" />, <c>args[0]</c> es igual que 100.</param>
        <param name="result">Resultado de la invocación del miembro.</param>
        <summary>Proporciona la implementación de las operaciones que invocan un miembro. Las clases derivadas de la clase <see cref="T:System.Dynamic.DynamicObject" /> pueden invalidar este método para especificar un comportamiento dinámico para operaciones como llamar a un método.</summary>
        <returns><see langword="true" /> si la operación es correcta; de lo contrario, <see langword="false" />. Si este método devuelve <see langword="false" />, el enlazador del lenguaje en tiempo de ejecución determina el comportamiento. (En la mayoría de los casos, se inicia una excepción específica del lenguaje en tiempo de ejecución).</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Las clases derivadas de la <xref:System.Dynamic.DynamicObject> clase puede invalidar este método para especificar cómo se deben realizar las operaciones que invocan un miembro de objeto para un objeto dinámico. Cuando no se reemplaza el método, el enlazador del lenguaje en tiempo de ejecución determina el comportamiento. (En la mayoría de los casos, se inicia una excepción específica del lenguaje en tiempo de ejecución).  
  
 Si se invalida este método, se invoca automáticamente cuando se realiza una operación como `sampleObject.SampleMethod(100)`, donde `sampleObject` se deriva el `DynamicObject` clase.  
  
 También puede agregar sus propios métodos a las clases que se derivan de la <xref:System.Dynamic.DynamicObject> clase. Por ejemplo, si invalida el <xref:System.Dynamic.DynamicObject.TryInvokeMember%2A> método, el sistema de distribución dinámica primero intenta determinar si el método especificado existe en la clase. Si no se encuentra el método, usa el <xref:System.Dynamic.DynamicObject.TryInvokeMember%2A> implementación.  
  
 Este método no admite `ref` y `out` parámetros. Todos los parámetros en el `args` matriz se pasan por valor.  
  
   
  
## Examples  
 Suponga que desea proporcionar una sintaxis alternativa para tener acceso a los valores en un diccionario, así que, en lugar de escribir `sampleDictionary["Text"] = "Sample text"` (`sampleDictionary("Text") = "Sample text"` en Visual Basic), puede escribir `sampleDictionary.Text = "Sample text"`. Además, desea poder llamar a todos los métodos de diccionario estándar en este diccionario.  
  
 En el ejemplo de código siguiente se muestra el `DynamicDictionary` (clase), que se deriva el <xref:System.Dynamic.DynamicObject> clase. El `DynamicDictionary` clase contiene un objeto de la `Dictionary<string, object>` tipo (`Dictionary(Of String, Object)` en Visual Basic) para almacenar los pares clave-valor. Invalida el <xref:System.Dynamic.DynamicObject.TryInvokeMember%2A> método para admitir los métodos de la <xref:System.Collections.Generic.Dictionary%602> clase e invalida el <xref:System.Dynamic.DynamicObject.TrySetMember%2A> y <xref:System.Dynamic.DynamicObject.TryGetMember%2A> métodos para admitir la nueva sintaxis. También proporciona un `Print` método, que imprime todos los valores y las claves del diccionario.  
  
 [!code-csharp[System.Dynamic.DynamicObject#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.dynamic.dynamicobject/cs/program.cs#6)]
 [!code-vb[System.Dynamic.DynamicObject#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.dynamic.dynamicobject/vb/module1.vb#6)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TrySetIndex">
      <MemberSignature Language="C#" Value="public virtual bool TrySetIndex (System.Dynamic.SetIndexBinder binder, object[] indexes, object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool TrySetIndex(class System.Dynamic.SetIndexBinder binder, object[] indexes, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Dynamic.DynamicObject.TrySetIndex(System.Dynamic.SetIndexBinder,System.Object[],System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function TrySetIndex (binder As SetIndexBinder, indexes As Object(), value As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool TrySetIndex(System::Dynamic::SetIndexBinder ^ binder, cli::array &lt;System::Object ^&gt; ^ indexes, System::Object ^ value);" />
      <MemberSignature Language="F#" Value="abstract member TrySetIndex : System.Dynamic.SetIndexBinder * obj[] * obj -&gt; bool&#xA;override this.TrySetIndex : System.Dynamic.SetIndexBinder * obj[] * obj -&gt; bool" Usage="dynamicObject.TrySetIndex (binder, indexes, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Dynamic.Runtime</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="binder" Type="System.Dynamic.SetIndexBinder" />
        <Parameter Name="indexes" Type="System.Object[]" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="binder">Proporciona información sobre la operación.</param>
        <param name="indexes">Índices que se usan en la operación. Por ejemplo, para la operación <c>sampleObject[3] = 10</c> en C# (<c>sampleObject(3) = 10</c> en Visual Basic), donde <c>sampleObject</c> se deriva de la clase <see cref="T:System.Dynamic.DynamicObject" />, <c>indexes[0]</c> es igual que 3.</param>
        <param name="value">Valor que se establece en el objeto que tiene el índice especificado. Por ejemplo, para la operación <c>sampleObject[3] = 10</c> en C# (<c>sampleObject(3) = 10</c> en Visual Basic), donde <c>sampleObject</c> se deriva de la clase <see cref="T:System.Dynamic.DynamicObject" />, <paramref name="value" /> es igual a 10.</param>
        <summary>Proporciona la implementación de las operaciones que establecen un valor por índice. Las clases derivadas de la clase <see cref="T:System.Dynamic.DynamicObject" /> pueden invalidar este método para especificar el comportamiento dinámico de las operaciones que tienen acceso a los objetos por un índice especificado.</summary>
        <returns><see langword="true" /> si la operación es correcta; de lo contrario, <see langword="false" />. Si este método devuelve <see langword="false" />, el enlazador del lenguaje en tiempo de ejecución determina el comportamiento. (En la mayoría de los casos, se inicia una excepción específica del lenguaje en tiempo de ejecución).</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Las clases derivadas de la <xref:System.Dynamic.DynamicObject> clase puede invalidar este método para especificar cómo se deben realizar las operaciones que tienen acceso a un objeto por índice para un objeto dinámico. Cuando no se reemplaza el método, el enlazador del lenguaje en tiempo de ejecución determina el comportamiento. (En la mayoría de los casos, se inicia una excepción específica del lenguaje en tiempo de ejecución).  
  
 Si se invalida este método, se invoca automáticamente cuando haya una operación como `sampleObject[3] = 10` en C# o `sampleObject(3) = 10` en Visual Basic, donde `sampleObject` se deriva el <xref:System.Dynamic.DynamicObject> clase.  
  
   
  
## Examples  
 Suponga que desea crear un objeto en el que las propiedades pueden ser acceder mediante nombres como `Property0`, `Property1`, y así sucesivamente, o por índice, por lo que, por ejemplo, `sampleObject.Property0` es equivalente a `sampleObject[0]` en C# o `sampleObject(0)` en Visual Basic.  
  
 En el ejemplo de código siguiente se muestra el `SampleDynamicObject` (clase), que se deriva el <xref:System.Dynamic.DynamicObject> clase. El `SampleDynamicObject` clase contiene un objeto de la `Dictionary<string, object>` tipo (`Dictionary(Of String, Object)` en Visual Basic) para almacenar los pares clave-valor. `SampleDynamicObject` invalida el <xref:System.Dynamic.DynamicObject.TrySetIndex%2A> y <xref:System.Dynamic.DynamicObject.TryGetIndex%2A> métodos para habilitar el acceso por índice. Invalida el <xref:System.Dynamic.DynamicObject.TrySetMember%2A> y <xref:System.Dynamic.DynamicObject.TryGetMember%2A> métodos para habilitar el acceso por nombre de propiedad.  
  
 [!code-csharp[System.Dynamic.DynamicObject#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.dynamic.dynamicobject/cs/program.cs#4)]
 [!code-vb[System.Dynamic.DynamicObject#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.dynamic.dynamicobject/vb/module1.vb#4)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TrySetMember">
      <MemberSignature Language="C#" Value="public virtual bool TrySetMember (System.Dynamic.SetMemberBinder binder, object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool TrySetMember(class System.Dynamic.SetMemberBinder binder, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Dynamic.DynamicObject.TrySetMember(System.Dynamic.SetMemberBinder,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function TrySetMember (binder As SetMemberBinder, value As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool TrySetMember(System::Dynamic::SetMemberBinder ^ binder, System::Object ^ value);" />
      <MemberSignature Language="F#" Value="abstract member TrySetMember : System.Dynamic.SetMemberBinder * obj -&gt; bool&#xA;override this.TrySetMember : System.Dynamic.SetMemberBinder * obj -&gt; bool" Usage="dynamicObject.TrySetMember (binder, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Dynamic.Runtime</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="binder" Type="System.Dynamic.SetMemberBinder" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="binder">Proporciona información sobre el objeto que llamó a la operación dinámica. La propiedad <c>binder.Name</c> proporciona el nombre del miembro al que se asigna el valor. Por ejemplo, para la instrucción <c>sampleObject.SampleProperty = "Test"</c>, donde <c>sampleObject</c> es una instancia de la clase derivada de la clase <see cref="T:System.Dynamic.DynamicObject" />, <c>binder.Name</c> devuelve "SampleProperty". La propiedad <c>binder.IgnoreCase</c> especifica si el nombre de miembro distingue mayúsculas de minúsculas.</param>
        <param name="value">Valor que se va a establecer para el miembro. Por ejemplo, para <c>sampleObject.SampleProperty = "Test"</c>, donde <c>sampleObject</c> es una instancia de la clase derivada de la clase <see cref="T:System.Dynamic.DynamicObject" />, <paramref name="value" /> es "Test".</param>
        <summary>Proporciona la implementación de las operaciones que establecen valores de miembro. Las clases derivadas de la clase <see cref="T:System.Dynamic.DynamicObject" /> pueden invalidar este método para especificar un comportamiento dinámico para operaciones como establecer el valor de una propiedad.</summary>
        <returns><see langword="true" /> si la operación es correcta; de lo contrario, <see langword="false" />. Si este método devuelve <see langword="false" />, el enlazador del lenguaje en tiempo de ejecución determina el comportamiento. (En la mayoría de los casos, se inicia una excepción específica del lenguaje en tiempo de ejecución).</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Las clases derivadas de la <xref:System.Dynamic.DynamicObject> clase puede invalidar este método para especificar cómo se deben realizar las operaciones que establecen un valor a un miembro de un objeto dinámico. Cuando no se reemplaza el método, el enlazador del lenguaje en tiempo de ejecución determina el comportamiento. (En la mayoría de los casos, se inicia una excepción específica del lenguaje en tiempo de ejecución).  
  
 Este método se llama cuando tiene instrucciones como `sampleObject.SampleProperty = "Test"`, donde `sampleObject` es una instancia de la clase que se deriva el <xref:System.Dynamic.DynamicObject> clase.  
  
 También puede agregar sus propios miembros a las clases derivadas de la `DynamicObject` clase. Si su clase define propiedades y también invalida la <xref:System.Dynamic.DynamicObject.TrySetMember%2A> método, dynamic language runtime (DLR) usa primero el enlazador del lenguaje para buscar una definición estática de una propiedad en la clase. Si no hay ninguna propiedad de este tipo, DLR llama a la <xref:System.Dynamic.DynamicObject.TrySetMember%2A> método.  
  
   
  
## Examples  
 Suponga que desea proporcionar una sintaxis alternativa para tener acceso a los valores en un diccionario, así que, en lugar de escribir `sampleDictionary["Text"] = "Sample text"` (`sampleDictionary("Text") = "Sample text"` en Visual Basic), puede escribir `sampleDictionary.Text = "Sample text"`. Además, esta sintaxis debe ser entre mayúsculas y minúsculas, por lo que `sampleDictionary.Text` es equivalente a `sampleDictionary.text`.  
  
 En el ejemplo de código siguiente se muestra el `DynamicDictionary` (clase), que se deriva el <xref:System.Dynamic.DynamicObject> clase. El `DynamicDictionary` clase contiene un objeto de la `Dictionary<string, object>` tipo (`Dictionary(Of String, Object)` en Visual Basic) para almacenar los pares clave-valor e invalida el <xref:System.Dynamic.DynamicObject.TrySetMember%2A> y <xref:System.Dynamic.DynamicObject.TryGetMember%2A> métodos para admitir la nueva sintaxis. También proporciona un `Count` contiene la propiedad, que muestra cuántos propiedades dinámicas en el diccionario.  
  
 [!code-csharp[System.Dynamic.DynamicObject#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.dynamic.dynamicobject/cs/program.cs#1)]
 [!code-vb[System.Dynamic.DynamicObject#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.dynamic.dynamicobject/vb/module1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TryUnaryOperation">
      <MemberSignature Language="C#" Value="public virtual bool TryUnaryOperation (System.Dynamic.UnaryOperationBinder binder, out object result);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool TryUnaryOperation(class System.Dynamic.UnaryOperationBinder binder, [out] object&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Dynamic.DynamicObject.TryUnaryOperation(System.Dynamic.UnaryOperationBinder,System.Object@)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function TryUnaryOperation (binder As UnaryOperationBinder, ByRef result As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool TryUnaryOperation(System::Dynamic::UnaryOperationBinder ^ binder, [Runtime::InteropServices::Out] System::Object ^ % result);" />
      <MemberSignature Language="F#" Value="abstract member TryUnaryOperation : System.Dynamic.UnaryOperationBinder *  -&gt; bool&#xA;override this.TryUnaryOperation : System.Dynamic.UnaryOperationBinder *  -&gt; bool" Usage="dynamicObject.TryUnaryOperation (binder, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Dynamic.Runtime</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="binder" Type="System.Dynamic.UnaryOperationBinder" />
        <Parameter Name="result" Type="System.Object" RefType="out" />
      </Parameters>
      <Docs>
        <param name="binder">Proporciona información sobre la operación unaria. La propiedad <c>binder.Operation</c> devuelve un objeto <see cref="T:System.Linq.Expressions.ExpressionType" />. Por ejemplo, para la instrucción <c>negativeNumber = -number</c>, donde <c>number</c> se deriva de la clase <see langword="DynamicObject" />, <c>binder.Operation</c> devuelve "Negate".</param>
        <param name="result">Resultado de la operación unaria.</param>
        <summary>Proporciona la implementación de operaciones unarias. Las clases derivadas de la clase <see cref="T:System.Dynamic.DynamicObject" /> pueden invalidar este método para especificar el comportamiento dinámico de operaciones como negación, incremento o decremento.</summary>
        <returns><see langword="true" /> si la operación es correcta; de lo contrario, <see langword="false" />. Si este método devuelve <see langword="false" />, el enlazador del lenguaje en tiempo de ejecución determina el comportamiento. (En la mayoría de los casos, se inicia una excepción específica del lenguaje en tiempo de ejecución).</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Las clases derivadas de la <xref:System.Dynamic.DynamicObject> clase puede invalidar este método para especificar cómo se deberían realizar operaciones unarias para un objeto dinámico. Cuando no se reemplaza el método, el enlazador del lenguaje en tiempo de ejecución determina el comportamiento. (En la mayoría de los casos, se inicia una excepción específica del lenguaje en tiempo de ejecución).  
  
 Este método se llama cuando tiene operaciones unarias como negación, incremento o decremento. Por ejemplo, si la <xref:System.Dynamic.DynamicObject.TryUnaryOperation%2A> método se invalide, este método se invoca automáticamente para instrucciones como `negativeNumber = -number`, donde `number` se deriva el <xref:System.Dynamic.DynamicObject> clase.  
  
 Puede obtener información sobre el tipo de la operación unaria mediante el `Operation` propiedad de la `binder` parámetro.  
  
 Si el objeto dinámico solo se usa en C# y Visual Basic, el `binder.Operation` propiedad puede tener uno de los siguientes valores de la <xref:System.Linq.Expressions.ExpressionType> enumeración. Sin embargo, en otros lenguajes, como IronPython o IronRuby, puede tener otros valores.
  
|Valor|Descripción|C#|Visual Basic|  
|-----------|-----------------|---------|------------------|  
|`Decrement`|Una operación de decremento unario.|`a--`|No se admite.|  
|`Increment`|Una operación de incremento unario.|`a++`|No se admite.|  
|`Negate`|Una negación aritmética.|`-a`|`-a`|  
|`Not`|Una negación lógica.|`!a`|`Not a`|  
|`OnesComplement`|Una los complemento.|`~a`|No se admite.|  
|`IsFalse`|Un valor de la condición es false.|`a && b`|No se admite.|  
|`IsTrue`|Un valor de la condición es true.|`a &#124;&#124; b`|No se admite.|  
|`UnaryPlus`|Unario más.|`+a`|`+a`|  
  
> [!NOTE]
>  Para implementar `OrElse` (`a || b`) y `AndAlso` (`a && b`) las operaciones para objetos dinámicos en C#, puede desear implementar tanto el <xref:System.Dynamic.DynamicObject.TryUnaryOperation%2A> método y el <xref:System.Dynamic.DynamicObject.TryBinaryOperation%2A> método.  
>   
>  El `OrElse` consta de operación de unario `IsTrue` operación y el archivo binario `Or` operación. El `Or` se realiza solo si el resultado de la `IsTrue` operación es `false`.  
>   
>  El `AndAlso` consta de operación de unario `IsFalse` operación y el archivo binario `And` operación. El `And` se realiza solo si el resultado de la `IsFalse` operación es `false`.  
  
   
  
## Examples  
 Suponga que necesita una estructura de datos para almacenar representaciones numéricas y textuales de los números, y desea definir una operación de negación matemática para tales datos.  
  
 En el ejemplo de código siguiente se muestra el `DynamicNumber` (clase), que se deriva el <xref:System.Dynamic.DynamicObject> clase. `DynamicNumber` invalida el <xref:System.Dynamic.DynamicObject.TryUnaryOperation%2A> método para habilitar la operación de negación matemática. Es también invalida la <xref:System.Dynamic.DynamicObject.TrySetMember%2A> y <xref:System.Dynamic.DynamicObject.TryGetMember%2A> métodos para habilitar el acceso a los elementos.  
  
 En este ejemplo, se admite solo la operación de negación matemática. Si se intenta escribir una instrucción como `negativeNumber = +number`, se produce una excepción en tiempo de ejecución.  
  
 [!code-csharp[System.Dynamic.DynamicObject#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.dynamic.dynamicobject/cs/program.cs#7)]
 [!code-vb[System.Dynamic.DynamicObject#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.dynamic.dynamicobject/vb/module1.vb#7)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>