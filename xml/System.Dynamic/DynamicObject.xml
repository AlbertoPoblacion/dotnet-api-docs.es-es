<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="DynamicObject.xml" source-language="en-US" target-language="es-ES">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-15c36f0" tool-company="Microsoft" />
      <xliffext:skl_file_name xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">02cd5861-7ce2-4a82-b358-31f8435a0ac5048b7221c8f650af7e40e1fc748386ee05216b4b.skl</xliffext:skl_file_name>
      <xliffext:version xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">1.2</xliffext:version>
      <xliffext:ms.openlocfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">048b7221c8f650af7e40e1fc748386ee05216b4b</xliffext:ms.openlocfilehash>
      <xliffext:ms.sourcegitcommit xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b</xliffext:ms.sourcegitcommit>
      <xliffext:ms.lasthandoff xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">04/03/2018</xliffext:ms.lasthandoff>
      <xliffext:moniker_ids xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">netcore-1.0,netcore-1.1,netcore-2.0,netcore-2.1,netframework-4.5.1,netframework-4.5.2,netframework-4.5,netframework-4.6.1,netframework-4.6.2,netframework-4.6,netframework-4.7.1,netframework-4.7,netstandard-2.0,xamarinandroid-7.1,xamarinios-10.8,xamarinmac-3.0</xliffext:moniker_ids>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve" uid="T:System.Dynamic.DynamicObject">
          <source>Provides a base class for specifying dynamic behavior at run time.</source>
          <target state="translated">Proporciona una clase base para especificar el comportamiento dinámico en tiempo de ejecución.</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve" uid="T:System.Dynamic.DynamicObject">
          <source>This class must be inherited from; you cannot instantiate it directly.</source>
          <target state="translated">Esta clase se debe heredar; no se puede crear una instancia de la clase directamente.</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Dynamic.DynamicObject">
          <source>The <ph id="ph1">`DynamicObject`</ph> class enables you to define which operations can be performed on dynamic objects and how to perform those operations.</source>
          <target state="translated">La <ph id="ph1">`DynamicObject`</ph> clase le permite definir qué operaciones se pueden realizar en objetos dinámicos y cómo realizar esas operaciones.</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Dynamic.DynamicObject">
          <source>For example, you can define what happens when you try to get or set an object property, call a method, or perform standard mathematical operations such as addition and multiplication.</source>
          <target state="translated">Por ejemplo, puede definir lo que ocurre al intentar obtener o establecer una propiedad de objeto, llama a un método o realizar operaciones matemáticas estándar, como suma y multiplicación.</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Dynamic.DynamicObject">
          <source>This class can be useful if you want to create a more convenient protocol for a library.</source>
          <target state="translated">Esta clase puede ser útil si desea crear un protocolo más conveniente para una biblioteca.</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Dynamic.DynamicObject">
          <source>For example, if users of your library have to use syntax like <ph id="ph1">`Scriptobj.SetProperty("Count", 1)`</ph>, you can provide the ability to use much simpler syntax, like <ph id="ph2">`scriptobj.Count = 1`</ph>.</source>
          <target state="translated">Por ejemplo, si los usuarios de la biblioteca tienen que utilizar una sintaxis como <ph id="ph1">`Scriptobj.SetProperty("Count", 1)`</ph>, puede proporcionar la capacidad de usar la sintaxis de mucho más sencilla, como <ph id="ph2">`scriptobj.Count = 1`</ph>.</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Dynamic.DynamicObject">
          <source>You cannot directly create an instance of the <ph id="ph1">`DynamicObject`</ph> class.</source>
          <target state="translated">No se puede crear directamente una instancia de la <ph id="ph1">`DynamicObject`</ph> clase.</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Dynamic.DynamicObject">
          <source>To implement the dynamic behavior, you may want to inherit from the <ph id="ph1">`DynamicObject`</ph> class and override necessary methods.</source>
          <target state="translated">Para implementar el comportamiento dinámico, puede que desee heredar de la <ph id="ph1">`DynamicObject`</ph> clase e invalidar los métodos necesarios.</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Dynamic.DynamicObject">
          <source>For example, if you need only operations for setting and getting properties, you can override just the <ph id="ph1">&lt;xref:System.Dynamic.DynamicObject.TrySetMember%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Dynamic.DynamicObject.TryGetMember%2A&gt;</ph> methods.</source>
          <target state="translated">Por ejemplo, si necesita que solo las operaciones para establecer y obtener propiedades, simplemente puede invalidar la <ph id="ph1">&lt;xref:System.Dynamic.DynamicObject.TrySetMember%2A&gt;</ph> y <ph id="ph2">&lt;xref:System.Dynamic.DynamicObject.TryGetMember%2A&gt;</ph> métodos.</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Dynamic.DynamicObject">
          <source>In C#, to enable dynamic behavior for instances of classes derived from the <ph id="ph1">`DynamicObject`</ph> class, you must use the <ph id="ph2">`dynamic`</ph> keyword.</source>
          <target state="translated">En C#, para habilitar el comportamiento dinámico para las instancias de clases derivadas de la <ph id="ph1">`DynamicObject`</ph> (clase), debe utilizar el <ph id="ph2">`dynamic`</ph> palabra clave.</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Dynamic.DynamicObject">
          <source>For more information, see <bpt id="p1">[</bpt>Using Type dynamic<ept id="p1">](~/docs/csharp/programming-guide/types/using-type-dynamic.md)</ept>.</source>
          <target state="translated">Para obtener más información, vea <bpt id="p1">[</bpt>Uso del tipo dynamic<ept id="p1">](~/docs/csharp/programming-guide/types/using-type-dynamic.md)</ept>.</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Dynamic.DynamicObject">
          <source>In Visual Basic, dynamic operations are supported by late binding.</source>
          <target state="translated">En Visual Basic, se admiten las operaciones dinámicas mediante el enlace de tiempo de ejecución.</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Dynamic.DynamicObject">
          <source>For more information, see <bpt id="p1">[</bpt>Early and Late Binding<ept id="p1">](http://msdn.microsoft.com/library/d6ff7f1e-b94f-4205-ab8d-5cfa91758724)</ept>.</source>
          <target state="translated">Para obtener más información, consulte <bpt id="p1">[</bpt>Early and Late Binding<ept id="p1">](http://msdn.microsoft.com/library/d6ff7f1e-b94f-4205-ab8d-5cfa91758724)</ept>.</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Dynamic.DynamicObject">
          <source>The following code example demonstrates how to create an instance of a class that is derived from the <ph id="ph1">`DynamicObject`</ph> class.</source>
          <target state="translated">En el ejemplo de código siguiente se muestra cómo crear una instancia de una clase que se deriva de la <ph id="ph1">`DynamicObject`</ph> clase.</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Dynamic.DynamicObject">
          <source>You can also add your own members to classes derived from the <ph id="ph1">`DynamicObject`</ph> class.</source>
          <target state="translated">También puede agregar sus propios miembros a clases derivadas de la <ph id="ph1">`DynamicObject`</ph> clase.</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Dynamic.DynamicObject">
          <source>If your class defines properties and also overrides the <ph id="ph1">&lt;xref:System.Dynamic.DynamicObject.TrySetMember%2A&gt;</ph> method, the dynamic language runtime (DLR) first uses the language binder to look for a static definition of a property in the class.</source>
          <target state="translated">Si su clase define propiedades y también invalida la <ph id="ph1">&lt;xref:System.Dynamic.DynamicObject.TrySetMember%2A&gt;</ph> método, dynamic language runtime (DLR) usa primero el enlazador del lenguaje para buscar una definición estática de una propiedad en la clase.</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Dynamic.DynamicObject">
          <source>If there is no such property, the DLR calls the <ph id="ph1">&lt;xref:System.Dynamic.DynamicObject.TrySetMember%2A&gt;</ph> method.</source>
          <target state="translated">Si no hay ninguna propiedad de este tipo, DLR llama el <ph id="ph1">&lt;xref:System.Dynamic.DynamicObject.TrySetMember%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Dynamic.DynamicObject">
          <source>The <ph id="ph1">`DynamicObject`</ph> class implements the DLR interface <ph id="ph2">&lt;xref:System.Dynamic.IDynamicMetaObjectProvider&gt;</ph>, which enables you to share instances of the <ph id="ph3">`DynamicObject`</ph> class between languages that support the DLR interoperability model.</source>
          <target state="translated">El <ph id="ph1">`DynamicObject`</ph> clase implementa la interfaz DLR <ph id="ph2">&lt;xref:System.Dynamic.IDynamicMetaObjectProvider&gt;</ph>, lo que permite compartir instancias de la <ph id="ph3">`DynamicObject`</ph> clase entre los lenguajes que admiten el modelo de interoperabilidad DLR.</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Dynamic.DynamicObject">
          <source>For example, you can create an instance of the <ph id="ph1">`DynamicObject`</ph> class in C# and then pass it to an IronPython function.</source>
          <target state="translated">Por ejemplo, puede crear una instancia de la <ph id="ph1">`DynamicObject`</ph> de clases en C# y, a continuación, se pasa a una función de IronPython.</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Dynamic.DynamicObject">
          <source>For more information, see <bpt id="p1">[</bpt>Dynamic Language Runtime Overview<ept id="p1">](~/docs/framework/reflection-and-codedom/dynamic-language-runtime-overview.md)</ept>.</source>
          <target state="translated">Para obtener más información, consulte <bpt id="p1">[</bpt>Dynamic Language Runtime Overview<ept id="p1">](~/docs/framework/reflection-and-codedom/dynamic-language-runtime-overview.md)</ept>.</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Dynamic.DynamicObject">
          <source>If you have a simple scenario in which you need an object that can only add and remove members at run time but that does not need to define specific operations and does not have static members, use the <ph id="ph1">&lt;xref:System.Dynamic.ExpandoObject&gt;</ph> class.</source>
          <target state="translated">Si tiene un escenario simple en el que se necesita un objeto que solo puede agregar y quitar miembros en tiempo de ejecución, pero que no es necesario definir las operaciones concretas y no tiene miembros estáticos, utilice la <ph id="ph1">&lt;xref:System.Dynamic.ExpandoObject&gt;</ph> clase.</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Dynamic.DynamicObject">
          <source>If you have a more advanced scenario in which you need to define how dynamic objects participate in the interoperability protocol, or you need to manage DLR fast dynamic dispatch caching, create your own implementation of the <ph id="ph1">&lt;xref:System.Dynamic.IDynamicMetaObjectProvider&gt;</ph> interface.</source>
          <target state="translated">Si tiene un escenario más avanzado en el que debe definir cómo los objetos dinámicos participan en el protocolo de interoperabilidad, o debe administrar el almacenamiento en caché de la distribución dinámica rápida DLR, cree su propia implementación de la <ph id="ph1">&lt;xref:System.Dynamic.IDynamicMetaObjectProvider&gt;</ph> interfaz.</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Dynamic.DynamicObject">
          <source>Assume that you want to provide alternative syntax for accessing values in a dictionary, so that instead of writing <ph id="ph1">`sampleDictionary["Text"] = "Sample text"`</ph> (<ph id="ph2">`sampleDictionary("Text") = "Sample text"`</ph> in Visual Basic), you can write <ph id="ph3">`sampleDictionary.Text = "Sample text"`</ph>.</source>
          <target state="translated">Suponga que desea proporcionar una sintaxis alternativa para tener acceso a valores de dictionary, así que, en lugar de escribir <ph id="ph1">`sampleDictionary["Text"] = "Sample text"`</ph> (<ph id="ph2">`sampleDictionary("Text") = "Sample text"`</ph> en Visual Basic), puede escribir <ph id="ph3">`sampleDictionary.Text = "Sample text"`</ph>.</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Dynamic.DynamicObject">
          <source>Also, you want this syntax to be case-insensitive, so that <ph id="ph1">`sampleDictionary.Text`</ph> is equivalent to <ph id="ph2">`sampleDictionary.text`</ph>.</source>
          <target state="translated">Además, le interesará esta sintaxis para distinguir mayúsculas de minúsculas, por lo que <ph id="ph1">`sampleDictionary.Text`</ph> es equivalente a <ph id="ph2">`sampleDictionary.text`</ph>.</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Dynamic.DynamicObject">
          <source>The following code example demonstrates the <ph id="ph1">`DynamicDictionary`</ph> class, which is derived from the <ph id="ph2">`DynamicObject`</ph> class.</source>
          <target state="translated">En el ejemplo de código siguiente se muestra la <ph id="ph1">`DynamicDictionary`</ph> (clase), que se deriva de la <ph id="ph2">`DynamicObject`</ph> clase.</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Dynamic.DynamicObject">
          <source>The <ph id="ph1">`DynamicDictionary`</ph> class contains an object of the <ph id="ph2">`Dictionary&lt;string, object&gt;`</ph> type (<ph id="ph3">`Dictionary(Of String, Object)`</ph> in Visual Basic) to store the key-value pairs, and overrides the <ph id="ph4">&lt;xref:System.Dynamic.DynamicObject.TrySetMember%2A&gt;</ph> and <ph id="ph5">&lt;xref:System.Dynamic.DynamicObject.TryGetMember%2A&gt;</ph> methods to support the new syntax.</source>
          <target state="translated">El <ph id="ph1">`DynamicDictionary`</ph> clase contiene un objeto de la <ph id="ph2">`Dictionary&lt;string, object&gt;`</ph> tipo (<ph id="ph3">`Dictionary(Of String, Object)`</ph> en Visual Basic) para almacenar los pares clave-valor e invalida el <ph id="ph4">&lt;xref:System.Dynamic.DynamicObject.TrySetMember%2A&gt;</ph> y <ph id="ph5">&lt;xref:System.Dynamic.DynamicObject.TryGetMember%2A&gt;</ph> métodos para admitir la nueva sintaxis.</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Dynamic.DynamicObject">
          <source>It also provides a <ph id="ph1">`Count`</ph> property, which shows how many dynamic properties the dictionary contains.</source>
          <target state="translated">También proporciona un <ph id="ph1">`Count`</ph> contiene la propiedad, que muestra el número de propiedades dinámicas en el diccionario.</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Dynamic.DynamicObject">
          <source>For more examples, see <bpt id="p1">[</bpt>Creating Wrappers with DynamicObject<ept id="p1">](http://go.microsoft.com/fwlink/?LinkId=169008)</ept> on the C# Frequently Asked Questions blog.</source>
          <target state="translated">Para obtener más ejemplos, vea <bpt id="p1">[</bpt>crear contenedores con DynamicObject<ept id="p1">](http://go.microsoft.com/fwlink/?LinkId=169008)</ept> en el blog de C# preguntas más frecuentes.</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve" uid="M:System.Dynamic.DynamicObject.#ctor">
          <source>Enables derived types to initialize a new instance of the <ph id="ph1">&lt;see cref="T:System.Dynamic.DynamicObject" /&gt;</ph> type.</source>
          <target state="translated">Permite a los tipos derivados inicializar una nueva instancia del tipo <ph id="ph1">&lt;see cref="T:System.Dynamic.DynamicObject" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Dynamic.DynamicObject.#ctor">
          <source>You cannot directly create an instance of the <ph id="ph1">&lt;xref:System.Dynamic.DynamicObject&gt;</ph> class.</source>
          <target state="translated">No se puede crear directamente una instancia de la <ph id="ph1">&lt;xref:System.Dynamic.DynamicObject&gt;</ph> clase.</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Dynamic.DynamicObject.#ctor">
          <source>To implement dynamic behavior, you have to inherit from the <ph id="ph1">&lt;xref:System.Dynamic.DynamicObject&gt;</ph> class and override necessary methods.</source>
          <target state="translated">Para implementar el comportamiento dinámico, tiene que heredan de la <ph id="ph1">&lt;xref:System.Dynamic.DynamicObject&gt;</ph> clase e invalidar los métodos necesarios.</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Dynamic.DynamicObject.#ctor">
          <source>In C#, to enable dynamic behavior for instances of the classes derived from the <ph id="ph1">&lt;xref:System.Dynamic.DynamicObject&gt;</ph> class, you must use the <ph id="ph2">`dynamic`</ph> keyword.</source>
          <target state="translated">En C#, para habilitar el comportamiento dinámico para las instancias de las clases derivadas de la <ph id="ph1">&lt;xref:System.Dynamic.DynamicObject&gt;</ph> (clase), debe utilizar el <ph id="ph2">`dynamic`</ph> palabra clave.</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Dynamic.DynamicObject.#ctor">
          <source>For more information, see <bpt id="p1">[</bpt>Using Type dynamic<ept id="p1">](~/docs/csharp/programming-guide/types/using-type-dynamic.md)</ept>.</source>
          <target state="translated">Para obtener más información, vea <bpt id="p1">[</bpt>Uso del tipo dynamic<ept id="p1">](~/docs/csharp/programming-guide/types/using-type-dynamic.md)</ept>.</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Dynamic.DynamicObject.#ctor">
          <source>In Visual Basic, dynamic operations are supported by late binding.</source>
          <target state="translated">En Visual Basic, se admiten las operaciones dinámicas mediante el enlace de tiempo de ejecución.</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Dynamic.DynamicObject.#ctor">
          <source>For more information, see <bpt id="p1">[</bpt>Early and Late Binding<ept id="p1">](http://msdn.microsoft.com/library/d6ff7f1e-b94f-4205-ab8d-5cfa91758724)</ept>.</source>
          <target state="translated">Para obtener más información, consulte <bpt id="p1">[</bpt>Early and Late Binding<ept id="p1">](http://msdn.microsoft.com/library/d6ff7f1e-b94f-4205-ab8d-5cfa91758724)</ept>.</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Dynamic.DynamicObject.#ctor">
          <source>The following code example demonstrates how to create an instance of classes that are derived from the <ph id="ph1">&lt;xref:System.Dynamic.DynamicObject&gt;</ph> class.</source>
          <target state="translated">En el ejemplo de código siguiente se muestra cómo crear una instancia de las clases que se derivan de la <ph id="ph1">&lt;xref:System.Dynamic.DynamicObject&gt;</ph> clase.</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve" uid="M:System.Dynamic.DynamicObject.GetDynamicMemberNames">
          <source>Returns the enumeration of all dynamic member names.</source>
          <target state="translated">Devuelve la enumeración de todos los nombres de miembro dinámicos.</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve" uid="M:System.Dynamic.DynamicObject.GetDynamicMemberNames">
          <source>A sequence that contains dynamic member names.</source>
          <target state="translated">Secuencia que contiene nombres de miembros dinámicos.</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Dynamic.DynamicObject.GetDynamicMemberNames">
          <source>This method exists for debugging purposes only.</source>
          <target state="translated">Este método no existe para fines de depuración solamente.</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve" uid="M:System.Dynamic.DynamicObject.GetMetaObject(System.Linq.Expressions.Expression)">
          <source>The expression that represents <ph id="ph1">&lt;see cref="T:System.Dynamic.DynamicMetaObject" /&gt;</ph> to dispatch to the dynamic virtual methods.</source>
          <target state="translated">Expresión que representa el objeto <ph id="ph1">&lt;see cref="T:System.Dynamic.DynamicMetaObject" /&gt;</ph> que se va a enviar a los métodos virtuales dinámicos.</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve" uid="M:System.Dynamic.DynamicObject.GetMetaObject(System.Linq.Expressions.Expression)">
          <source>Provides a <ph id="ph1">&lt;see cref="T:System.Dynamic.DynamicMetaObject" /&gt;</ph> that dispatches to the dynamic virtual methods.</source>
          <target state="translated">Proporciona un objeto <ph id="ph1">&lt;see cref="T:System.Dynamic.DynamicMetaObject" /&gt;</ph> que envía a los métodos virtuales dinámicos.</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve" uid="M:System.Dynamic.DynamicObject.GetMetaObject(System.Linq.Expressions.Expression)">
          <source>The object can be encapsulated inside another <ph id="ph1">&lt;see cref="T:System.Dynamic.DynamicMetaObject" /&gt;</ph> to provide custom behavior for individual actions.</source>
          <target state="translated">El objeto se puede encapsular dentro de otro objeto <ph id="ph1">&lt;see cref="T:System.Dynamic.DynamicMetaObject" /&gt;</ph> para proporcionar un comportamiento personalizado para acciones individuales.</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve" uid="M:System.Dynamic.DynamicObject.GetMetaObject(System.Linq.Expressions.Expression)">
          <source>This method supports the Dynamic Language Runtime infrastructure for language implementers and it is not intended to be used directly from your code.</source>
          <target state="translated">Este método admite la infraestructura de Dynamic Language Runtime para los implementadores de lenguaje y no está pensado para que se use directamente en el código.</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve" uid="M:System.Dynamic.DynamicObject.GetMetaObject(System.Linq.Expressions.Expression)">
          <source>An object of the <ph id="ph1">&lt;see cref="T:System.Dynamic.DynamicMetaObject" /&gt;</ph> type.</source>
          <target state="translated">Objeto de tipo <ph id="ph1">&lt;see cref="T:System.Dynamic.DynamicMetaObject" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve" uid="M:System.Dynamic.DynamicObject.TryBinaryOperation(System.Dynamic.BinaryOperationBinder,System.Object,System.Object@)">
          <source>Provides information about the binary operation.</source>
          <target state="translated">Proporciona información sobre la operación binaria.</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve" uid="M:System.Dynamic.DynamicObject.TryBinaryOperation(System.Dynamic.BinaryOperationBinder,System.Object,System.Object@)">
          <source>The <bpt id="p1">&lt;c&gt;</bpt>binder.Operation<ept id="p1">&lt;/c&gt;</ept> property returns an <ph id="ph1">&lt;see cref="T:System.Linq.Expressions.ExpressionType" /&gt;</ph> object.</source>
          <target state="translated">La propiedad <bpt id="p1">&lt;c&gt;</bpt>binder.Operation<ept id="p1">&lt;/c&gt;</ept> devuelve un objeto <ph id="ph1">&lt;see cref="T:System.Linq.Expressions.ExpressionType" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve" uid="M:System.Dynamic.DynamicObject.TryBinaryOperation(System.Dynamic.BinaryOperationBinder,System.Object,System.Object@)">
          <source>For example, for the <bpt id="p1">&lt;c&gt;</bpt>sum = first + second<ept id="p1">&lt;/c&gt;</ept> statement, where <bpt id="p2">&lt;c&gt;</bpt>first<ept id="p2">&lt;/c&gt;</ept> and <bpt id="p3">&lt;c&gt;</bpt>second<ept id="p3">&lt;/c&gt;</ept> are derived from the <ph id="ph1">&lt;see langword="DynamicObject" /&gt;</ph> class, <bpt id="p4">&lt;c&gt;</bpt>binder.Operation<ept id="p4">&lt;/c&gt;</ept> returns <bpt id="p5">&lt;c&gt;</bpt>ExpressionType.Add<ept id="p5">&lt;/c&gt;</ept>.</source>
          <target state="translated">Por ejemplo, para la instrucción <bpt id="p1">&lt;c&gt;</bpt>sum = first + second<ept id="p1">&lt;/c&gt;</ept>, donde <bpt id="p2">&lt;c&gt;</bpt>first<ept id="p2">&lt;/c&gt;</ept> y <bpt id="p3">&lt;c&gt;</bpt>second<ept id="p3">&lt;/c&gt;</ept> se derivan de la clase <ph id="ph1">&lt;see langword="DynamicObject" /&gt;</ph>, <bpt id="p4">&lt;c&gt;</bpt>binder.Operation<ept id="p4">&lt;/c&gt;</ept> devuelve <bpt id="p5">&lt;c&gt;</bpt>ExpressionType.Add<ept id="p5">&lt;/c&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve" uid="M:System.Dynamic.DynamicObject.TryBinaryOperation(System.Dynamic.BinaryOperationBinder,System.Object,System.Object@)">
          <source>The right operand for the binary operation.</source>
          <target state="translated">Operando derecho de la operación binaria.</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve" uid="M:System.Dynamic.DynamicObject.TryBinaryOperation(System.Dynamic.BinaryOperationBinder,System.Object,System.Object@)">
          <source>For example, for the <bpt id="p1">&lt;c&gt;</bpt>sum = first + second<ept id="p1">&lt;/c&gt;</ept> statement, where <bpt id="p2">&lt;c&gt;</bpt>first<ept id="p2">&lt;/c&gt;</ept> and <bpt id="p3">&lt;c&gt;</bpt>second<ept id="p3">&lt;/c&gt;</ept> are derived from the <ph id="ph1">&lt;see langword="DynamicObject" /&gt;</ph> class, <bpt id="p4">&lt;c&gt;</bpt>arg<ept id="p4">&lt;/c&gt;</ept> is equal to <bpt id="p5">&lt;c&gt;</bpt>second<ept id="p5">&lt;/c&gt;</ept>.</source>
          <target state="translated">Por ejemplo, para la instrucción <bpt id="p1">&lt;c&gt;</bpt>sum = first + second<ept id="p1">&lt;/c&gt;</ept>, donde <bpt id="p2">&lt;c&gt;</bpt>first<ept id="p2">&lt;/c&gt;</ept> y <bpt id="p3">&lt;c&gt;</bpt>second<ept id="p3">&lt;/c&gt;</ept> se derivan de la clase <ph id="ph1">&lt;see langword="DynamicObject" /&gt;</ph>, <bpt id="p4">&lt;c&gt;</bpt>arg<ept id="p4">&lt;/c&gt;</ept> es igual que <bpt id="p5">&lt;c&gt;</bpt>second<ept id="p5">&lt;/c&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve" uid="M:System.Dynamic.DynamicObject.TryBinaryOperation(System.Dynamic.BinaryOperationBinder,System.Object,System.Object@)">
          <source>The result of the binary operation.</source>
          <target state="translated">Resultado de la operación binaria.</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve" uid="M:System.Dynamic.DynamicObject.TryBinaryOperation(System.Dynamic.BinaryOperationBinder,System.Object,System.Object@)">
          <source>Provides implementation for binary operations.</source>
          <target state="translated">Proporciona la implementación de operaciones binarias.</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve" uid="M:System.Dynamic.DynamicObject.TryBinaryOperation(System.Dynamic.BinaryOperationBinder,System.Object,System.Object@)">
          <source>Classes derived from the <ph id="ph1">&lt;see cref="T:System.Dynamic.DynamicObject" /&gt;</ph> class can override this method to specify dynamic behavior for operations such as addition and multiplication.</source>
          <target state="translated">Las clases derivadas de la clase <ph id="ph1">&lt;see cref="T:System.Dynamic.DynamicObject" /&gt;</ph> pueden invalidar este método para especificar un comportamiento dinámico para operaciones como la suma o la multiplicación.</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve" uid="M:System.Dynamic.DynamicObject.TryBinaryOperation(System.Dynamic.BinaryOperationBinder,System.Object,System.Object@)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the operation is successful; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> si la operación es correcta; de lo contrario, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve" uid="M:System.Dynamic.DynamicObject.TryBinaryOperation(System.Dynamic.BinaryOperationBinder,System.Object,System.Object@)">
          <source>If this method returns <ph id="ph1">&lt;see langword="false" /&gt;</ph>, the run-time binder of the language determines the behavior.</source>
          <target state="translated">Si este método devuelve <ph id="ph1">&lt;see langword="false" /&gt;</ph>, el enlazador del lenguaje en tiempo de ejecución determina el comportamiento.</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve" uid="M:System.Dynamic.DynamicObject.TryBinaryOperation(System.Dynamic.BinaryOperationBinder,System.Object,System.Object@)">
          <source>(In most cases, a language-specific run-time exception is thrown.)</source>
          <target state="translated">(En la mayoría de los casos, se inicia una excepción específica del lenguaje en tiempo de ejecución).</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Dynamic.DynamicObject.TryBinaryOperation(System.Dynamic.BinaryOperationBinder,System.Object,System.Object@)">
          <source>Classes derived from the <ph id="ph1">&lt;xref:System.Dynamic.DynamicObject&gt;</ph> class can override this method to specify how binary operations should be performed for a dynamic object.</source>
          <target state="translated">Las clases derivadas de la <ph id="ph1">&lt;xref:System.Dynamic.DynamicObject&gt;</ph> clase puede invalidar este método para especificar cómo se deben realizar las operaciones binarias para un objeto dinámico.</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Dynamic.DynamicObject.TryBinaryOperation(System.Dynamic.BinaryOperationBinder,System.Object,System.Object@)">
          <source>When the method is not overridden, the run-time binder of the language determines the behavior.</source>
          <target state="translated">Cuando no se reemplaza el método, el enlazador en tiempo de ejecución del lenguaje determina el comportamiento.</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Dynamic.DynamicObject.TryBinaryOperation(System.Dynamic.BinaryOperationBinder,System.Object,System.Object@)">
          <source>(In most cases, a language-specific run-time exception is thrown.)</source>
          <target state="translated">(En la mayoría de los casos, se inicia una excepción específica del lenguaje en tiempo de ejecución).</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Dynamic.DynamicObject.TryBinaryOperation(System.Dynamic.BinaryOperationBinder,System.Object,System.Object@)">
          <source>This method is called when you have binary operations such as addition or multiplication.</source>
          <target state="translated">Se llama a este método si tiene operaciones binarias como la suma o la multiplicación.</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Dynamic.DynamicObject.TryBinaryOperation(System.Dynamic.BinaryOperationBinder,System.Object,System.Object@)">
          <source>For example, if the <ph id="ph1">&lt;xref:System.Dynamic.DynamicObject.TryBinaryOperation%2A&gt;</ph> method is overridden, it is automatically invoked for statements like <ph id="ph2">`sum = first + second`</ph> or <ph id="ph3">`multiply = first*second`</ph>, where <ph id="ph4">`first`</ph> is derived from the <ph id="ph5">`DynamicObject`</ph> class.</source>
          <target state="translated">Por ejemplo, si la <ph id="ph1">&lt;xref:System.Dynamic.DynamicObject.TryBinaryOperation%2A&gt;</ph> se invalida el método, se invoca automáticamente para instrucciones como <ph id="ph2">`sum = first + second`</ph> o <ph id="ph3">`multiply = first*second`</ph>, donde <ph id="ph4">`first`</ph> se deriva de la <ph id="ph5">`DynamicObject`</ph> clase.</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Dynamic.DynamicObject.TryBinaryOperation(System.Dynamic.BinaryOperationBinder,System.Object,System.Object@)">
          <source>You can get information about the type of the binary operation by using the <ph id="ph1">`Operation`</ph> property of the <ph id="ph2">`binder`</ph> parameter.</source>
          <target state="translated">Puede obtener información sobre el tipo de la operación binaria mediante el <ph id="ph1">`Operation`</ph> propiedad de la <ph id="ph2">`binder`</ph> parámetro.</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Dynamic.DynamicObject.TryBinaryOperation(System.Dynamic.BinaryOperationBinder,System.Object,System.Object@)">
          <source>If your dynamic object is used only in C# and Visual Basic, the <ph id="ph1">`binder.Operation`</ph> property can have one of the following values from the <ph id="ph2">&lt;xref:System.Linq.Expressions.ExpressionType&gt;</ph> enumeration.</source>
          <target state="translated">Si el objeto dinámico solo se usa en C# y Visual Basic, la <ph id="ph1">`binder.Operation`</ph> propiedad puede tener uno de los siguientes valores de la <ph id="ph2">&lt;xref:System.Linq.Expressions.ExpressionType&gt;</ph> enumeración.</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Dynamic.DynamicObject.TryBinaryOperation(System.Dynamic.BinaryOperationBinder,System.Object,System.Object@)">
          <source>However, in other languages such as IronPython or IronRuby, you can have other values.</source>
          <target state="translated">Sin embargo, en otros lenguajes como IronPython o IronRuby, puede tener otros valores.</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Dynamic.DynamicObject.TryBinaryOperation(System.Dynamic.BinaryOperationBinder,System.Object,System.Object@)">
          <source>Value</source>
          <target state="translated">Valor</target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Dynamic.DynamicObject.TryBinaryOperation(System.Dynamic.BinaryOperationBinder,System.Object,System.Object@)">
          <source>Description</source>
          <target state="translated">Descripción</target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Dynamic.DynamicObject.TryBinaryOperation(System.Dynamic.BinaryOperationBinder,System.Object,System.Object@)">
          <source>C#</source>
          <target state="translated">C#</target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Dynamic.DynamicObject.TryBinaryOperation(System.Dynamic.BinaryOperationBinder,System.Object,System.Object@)">
          <source>Visual Basic</source>
          <target state="translated">Visual Basic</target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Dynamic.DynamicObject.TryBinaryOperation(System.Dynamic.BinaryOperationBinder,System.Object,System.Object@)">
          <source>An addition operation without overflow checking, for numeric operands.</source>
          <target state="translated">Una operación de suma sin comprobación de desbordamiento, para operandos numéricos.</target>       </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Dynamic.DynamicObject.TryBinaryOperation(System.Dynamic.BinaryOperationBinder,System.Object,System.Object@)">
          <source>An addition compound assignment operation without overflow checking, for numeric operands.</source>
          <target state="translated">Una operación de asignación compuesta de suma sin comprobación de desbordamiento, para operandos numéricos.</target>       </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Dynamic.DynamicObject.TryBinaryOperation(System.Dynamic.BinaryOperationBinder,System.Object,System.Object@)">
          <source>Not supported.</source>
          <target state="translated">No se admite.</target>       </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Dynamic.DynamicObject.TryBinaryOperation(System.Dynamic.BinaryOperationBinder,System.Object,System.Object@)">
          <source>A bitwise <ph id="ph1">`AND`</ph> operation.</source>
          <target state="translated">Un bit a bit <ph id="ph1">`AND`</ph> operación.</target>       </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Dynamic.DynamicObject.TryBinaryOperation(System.Dynamic.BinaryOperationBinder,System.Object,System.Object@)">
          <source>A bitwise <ph id="ph1">`AND`</ph> compound assignment operation.</source>
          <target state="translated">Un bit a bit <ph id="ph1">`AND`</ph> operación de asignación compuesta.</target>       </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Dynamic.DynamicObject.TryBinaryOperation(System.Dynamic.BinaryOperationBinder,System.Object,System.Object@)">
          <source>Not supported.</source>
          <target state="translated">No se admite.</target>       </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Dynamic.DynamicObject.TryBinaryOperation(System.Dynamic.BinaryOperationBinder,System.Object,System.Object@)">
          <source>An arithmetic division operation.</source>
          <target state="translated">Una operación de división aritmética.</target>       </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Dynamic.DynamicObject.TryBinaryOperation(System.Dynamic.BinaryOperationBinder,System.Object,System.Object@)">
          <source>An arithmetic division compound assignment operation.</source>
          <target state="translated">Una operación de asignación compuesta de división aritmética.</target>       </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Dynamic.DynamicObject.TryBinaryOperation(System.Dynamic.BinaryOperationBinder,System.Object,System.Object@)">
          <source>Not supported.</source>
          <target state="translated">No se admite.</target>       </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Dynamic.DynamicObject.TryBinaryOperation(System.Dynamic.BinaryOperationBinder,System.Object,System.Object@)">
          <source>A bitwise <ph id="ph1">`XOR`</ph> operation.</source>
          <target state="translated">Un bit a bit <ph id="ph1">`XOR`</ph> operación.</target>       </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Dynamic.DynamicObject.TryBinaryOperation(System.Dynamic.BinaryOperationBinder,System.Object,System.Object@)">
          <source>A bitwise <ph id="ph1">`XOR`</ph> compound assignment operation.</source>
          <target state="translated">Un bit a bit <ph id="ph1">`XOR`</ph> operación de asignación compuesta.</target>       </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Dynamic.DynamicObject.TryBinaryOperation(System.Dynamic.BinaryOperationBinder,System.Object,System.Object@)">
          <source>Not supported.</source>
          <target state="translated">No se admite.</target>       </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Dynamic.DynamicObject.TryBinaryOperation(System.Dynamic.BinaryOperationBinder,System.Object,System.Object@)">
          <source>A "greater than" comparison.</source>
          <target state="translated">Una comparación "mayor que".</target>       </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Dynamic.DynamicObject.TryBinaryOperation(System.Dynamic.BinaryOperationBinder,System.Object,System.Object@)">
          <source>A "greater than or equal to" comparison.</source>
          <target state="translated">Una comparación "mayor o igual que".</target>       </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Dynamic.DynamicObject.TryBinaryOperation(System.Dynamic.BinaryOperationBinder,System.Object,System.Object@)">
          <source>Not supported.</source>
          <target state="translated">No se admite.</target>       </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Dynamic.DynamicObject.TryBinaryOperation(System.Dynamic.BinaryOperationBinder,System.Object,System.Object@)">
          <source>A bitwise left-shift operation.</source>
          <target state="translated">Una operación de desplazamiento a la izquierda bit a bit.</target>       </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Dynamic.DynamicObject.TryBinaryOperation(System.Dynamic.BinaryOperationBinder,System.Object,System.Object@)">
          <source>A bitwise left-shift compound assignment operation.</source>
          <target state="translated">Una operación de asignación compuesta de desplazamiento a la izquierda bit a bit.</target>       </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Dynamic.DynamicObject.TryBinaryOperation(System.Dynamic.BinaryOperationBinder,System.Object,System.Object@)">
          <source>Not supported.</source>
          <target state="translated">No se admite.</target>       </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Dynamic.DynamicObject.TryBinaryOperation(System.Dynamic.BinaryOperationBinder,System.Object,System.Object@)">
          <source>A "less than" comparison.</source>
          <target state="translated">Una comparación "menor que".</target>       </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Dynamic.DynamicObject.TryBinaryOperation(System.Dynamic.BinaryOperationBinder,System.Object,System.Object@)">
          <source>A "less than or equal to" comparison.</source>
          <target state="translated">Una comparación "menor o igual que".</target>       </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Dynamic.DynamicObject.TryBinaryOperation(System.Dynamic.BinaryOperationBinder,System.Object,System.Object@)">
          <source>Not supported.</source>
          <target state="translated">No se admite.</target>       </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Dynamic.DynamicObject.TryBinaryOperation(System.Dynamic.BinaryOperationBinder,System.Object,System.Object@)">
          <source>An arithmetic remainder operation.</source>
          <target state="translated">Una operación de resto aritmética.</target>       </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Dynamic.DynamicObject.TryBinaryOperation(System.Dynamic.BinaryOperationBinder,System.Object,System.Object@)">
          <source>An arithmetic remainder compound assignment operation.</source>
          <target state="translated">Una operación de asignación compuesta de resto aritmética.</target>       </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Dynamic.DynamicObject.TryBinaryOperation(System.Dynamic.BinaryOperationBinder,System.Object,System.Object@)">
          <source>Not supported.</source>
          <target state="translated">No se admite.</target>       </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Dynamic.DynamicObject.TryBinaryOperation(System.Dynamic.BinaryOperationBinder,System.Object,System.Object@)">
          <source>A multiplication operation without overflow checking, for numeric operands.</source>
          <target state="translated">Una operación de multiplicación sin comprobación de desbordamiento, para operandos numéricos.</target>       </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Dynamic.DynamicObject.TryBinaryOperation(System.Dynamic.BinaryOperationBinder,System.Object,System.Object@)">
          <source>A multiplication compound assignment operation without overflow checking, for numeric operands.</source>
          <target state="translated">Una operación de asignación compuesta de multiplicación sin comprobación de desbordamiento, para operandos numéricos.</target>       </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Dynamic.DynamicObject.TryBinaryOperation(System.Dynamic.BinaryOperationBinder,System.Object,System.Object@)">
          <source>Not supported.</source>
          <target state="translated">No se admite.</target>       </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Dynamic.DynamicObject.TryBinaryOperation(System.Dynamic.BinaryOperationBinder,System.Object,System.Object@)">
          <source>An inequality comparison.</source>
          <target state="translated">Una comparación de desigualdad.</target>       </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Dynamic.DynamicObject.TryBinaryOperation(System.Dynamic.BinaryOperationBinder,System.Object,System.Object@)">
          <source>A bitwise or logical <ph id="ph1">`OR`</ph> operation.</source>
          <target state="translated">Un bit a bit o lógica <ph id="ph1">`OR`</ph> operación.</target>       </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Dynamic.DynamicObject.TryBinaryOperation(System.Dynamic.BinaryOperationBinder,System.Object,System.Object@)">
          <source>A bitwise or logical <ph id="ph1">`OR`</ph> compound assignment.</source>
          <target state="translated">Un bit a bit o lógica <ph id="ph1">`OR`</ph> asignación compuesta.</target>       </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Dynamic.DynamicObject.TryBinaryOperation(System.Dynamic.BinaryOperationBinder,System.Object,System.Object@)">
          <source>Not supported.</source>
          <target state="translated">No se admite.</target>       </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Dynamic.DynamicObject.TryBinaryOperation(System.Dynamic.BinaryOperationBinder,System.Object,System.Object@)">
          <source>A mathematical operation of raising a number to a power.</source>
          <target state="translated">Una operación matemática de elevar un número a una potencia.</target>       </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Dynamic.DynamicObject.TryBinaryOperation(System.Dynamic.BinaryOperationBinder,System.Object,System.Object@)">
          <source>Not supported.</source>
          <target state="translated">No se admite.</target>       </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Dynamic.DynamicObject.TryBinaryOperation(System.Dynamic.BinaryOperationBinder,System.Object,System.Object@)">
          <source>A bitwise right-shift operation.</source>
          <target state="translated">Una operación de desplazamiento a la derecha bit a bit.</target>       </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Dynamic.DynamicObject.TryBinaryOperation(System.Dynamic.BinaryOperationBinder,System.Object,System.Object@)">
          <source>A bitwise right-shift compound assignment operation.</source>
          <target state="translated">Una operación de asignación compuesta de desplazamiento a la derecha bit a bit.</target>       </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Dynamic.DynamicObject.TryBinaryOperation(System.Dynamic.BinaryOperationBinder,System.Object,System.Object@)">
          <source>Not supported.</source>
          <target state="translated">No se admite.</target>       </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Dynamic.DynamicObject.TryBinaryOperation(System.Dynamic.BinaryOperationBinder,System.Object,System.Object@)">
          <source>A subtraction operation without overflow checking, for numeric operands.</source>
          <target state="translated">Una operación de resta sin comprobación de desbordamiento, para operandos numéricos.</target>       </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Dynamic.DynamicObject.TryBinaryOperation(System.Dynamic.BinaryOperationBinder,System.Object,System.Object@)">
          <source>A subtraction compound assignment operation without overflow checking, for numeric operands.</source>
          <target state="translated">Una operación de asignación compuesta de resta sin comprobación de desbordamiento, para operandos numéricos.</target>       </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Dynamic.DynamicObject.TryBinaryOperation(System.Dynamic.BinaryOperationBinder,System.Object,System.Object@)">
          <source>Not supported.</source>
          <target state="translated">No se admite.</target>       </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Dynamic.DynamicObject.TryBinaryOperation(System.Dynamic.BinaryOperationBinder,System.Object,System.Object@)">
          <source>To implement <ph id="ph1">`OrElse`</ph> (<ph id="ph2">`a || b`</ph>) and <ph id="ph3">`AndAlso`</ph> (<ph id="ph4">`a &amp;&amp; b`</ph>) operations for dynamic objects in C#, you may want to implement both the <ph id="ph5">&lt;xref:System.Dynamic.DynamicObject.TryUnaryOperation%2A&gt;</ph> method and the <ph id="ph6">&lt;xref:System.Dynamic.DynamicObject.TryBinaryOperation%2A&gt;</ph> method.</source>
          <target state="translated">Para implementar <ph id="ph1">`OrElse`</ph> (<ph id="ph2">`a || b`</ph>) y <ph id="ph3">`AndAlso`</ph> (<ph id="ph4">`a &amp;&amp; b`</ph>) operaciones de objetos dinámicos en C#, puede que desee implementar tanto el <ph id="ph5">&lt;xref:System.Dynamic.DynamicObject.TryUnaryOperation%2A&gt;</ph> (método) y el <ph id="ph6">&lt;xref:System.Dynamic.DynamicObject.TryBinaryOperation%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Dynamic.DynamicObject.TryBinaryOperation(System.Dynamic.BinaryOperationBinder,System.Object,System.Object@)">
          <source>The <ph id="ph1">`OrElse`</ph> operation consists of the unary <ph id="ph2">`IsTrue`</ph> operation and the binary <ph id="ph3">`Or`</ph> operation.</source>
          <target state="translated">El <ph id="ph1">`OrElse`</ph> operación está formada por el operador unario <ph id="ph2">`IsTrue`</ph> operación y el archivo binario <ph id="ph3">`Or`</ph> operación.</target>       </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Dynamic.DynamicObject.TryBinaryOperation(System.Dynamic.BinaryOperationBinder,System.Object,System.Object@)">
          <source>The <ph id="ph1">`Or`</ph> operation is performed only if the result of the <ph id="ph2">`IsTrue`</ph> operation is <ph id="ph3">`false`</ph>.</source>
          <target state="translated">El <ph id="ph1">`Or`</ph> operación se realiza solo si el resultado de la <ph id="ph2">`IsTrue`</ph> operación es <ph id="ph3">`false`</ph>.</target>       </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Dynamic.DynamicObject.TryBinaryOperation(System.Dynamic.BinaryOperationBinder,System.Object,System.Object@)">
          <source>The <ph id="ph1">`AndAlso`</ph> operation consists of the unary <ph id="ph2">`IsFalse`</ph> operation and the binary <ph id="ph3">`And`</ph> operation.</source>
          <target state="translated">El <ph id="ph1">`AndAlso`</ph> operación está formada por el operador unario <ph id="ph2">`IsFalse`</ph> operación y el archivo binario <ph id="ph3">`And`</ph> operación.</target>       </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Dynamic.DynamicObject.TryBinaryOperation(System.Dynamic.BinaryOperationBinder,System.Object,System.Object@)">
          <source>The <ph id="ph1">`And`</ph> operation is performed only if the result of the <ph id="ph2">`IsFalse`</ph> operation is <ph id="ph3">`false`</ph>.</source>
          <target state="translated">El <ph id="ph1">`And`</ph> operación se realiza solo si el resultado de la <ph id="ph2">`IsFalse`</ph> operación es <ph id="ph3">`false`</ph>.</target>       </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Dynamic.DynamicObject.TryBinaryOperation(System.Dynamic.BinaryOperationBinder,System.Object,System.Object@)">
          <source>Assume that you need a data structure to store textual and numeric representations of numbers, and you want to define basic mathematical operations such as addition and subtraction for such data.</source>
          <target state="translated">Suponga que necesita una estructura de datos para almacenar representaciones numéricas y textuales de números, y desea definir operaciones matemáticas básicas como suma y resta para tales datos.</target>       </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Dynamic.DynamicObject.TryBinaryOperation(System.Dynamic.BinaryOperationBinder,System.Object,System.Object@)">
          <source>The following code example demonstrates the <ph id="ph1">`DynamicNumber`</ph> class, which is derived from the <ph id="ph2">&lt;xref:System.Dynamic.DynamicObject&gt;</ph> class.</source>
          <target state="translated">En el ejemplo de código siguiente se muestra la <ph id="ph1">`DynamicNumber`</ph> (clase), que se deriva de la <ph id="ph2">&lt;xref:System.Dynamic.DynamicObject&gt;</ph> clase.</target>       </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Dynamic.DynamicObject.TryBinaryOperation(System.Dynamic.BinaryOperationBinder,System.Object,System.Object@)">
          <source><ph id="ph1">`DynamicNumber`</ph> overrides the <ph id="ph2">&lt;xref:System.Dynamic.DynamicObject.TryBinaryOperation%2A&gt;</ph> method to enable mathematical operations.</source>
          <target state="translated"><ph id="ph1">`DynamicNumber`</ph> invalida el <ph id="ph2">&lt;xref:System.Dynamic.DynamicObject.TryBinaryOperation%2A&gt;</ph> método para habilitar las operaciones matemáticas.</target>       </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Dynamic.DynamicObject.TryBinaryOperation(System.Dynamic.BinaryOperationBinder,System.Object,System.Object@)">
          <source>It also overrides the <ph id="ph1">&lt;xref:System.Dynamic.DynamicObject.TrySetMember%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Dynamic.DynamicObject.TryGetMember%2A&gt;</ph> methods to enable access to the elements.</source>
          <target state="translated">También invalida la <ph id="ph1">&lt;xref:System.Dynamic.DynamicObject.TrySetMember%2A&gt;</ph> y <ph id="ph2">&lt;xref:System.Dynamic.DynamicObject.TryGetMember%2A&gt;</ph> métodos para habilitar el acceso a los elementos.</target>       </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Dynamic.DynamicObject.TryBinaryOperation(System.Dynamic.BinaryOperationBinder,System.Object,System.Object@)">
          <source>In this example, only addition and subtraction operations are supported.</source>
          <target state="translated">En este ejemplo, se admiten solo las operaciones de suma y resta.</target>       </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Dynamic.DynamicObject.TryBinaryOperation(System.Dynamic.BinaryOperationBinder,System.Object,System.Object@)">
          <source>If you try to write a statement like <ph id="ph1">`resultNumber = firstNumber*secondNumber`</ph>, a run-time exception is thrown.</source>
          <target state="translated">Si se intenta escribir una instrucción como <ph id="ph1">`resultNumber = firstNumber*secondNumber`</ph>, se produce una excepción de tiempo de ejecución.</target>       </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve" uid="M:System.Dynamic.DynamicObject.TryConvert(System.Dynamic.ConvertBinder,System.Object@)">
          <source>Provides information about the conversion operation.</source>
          <target state="translated">Proporciona información sobre la operación de conversión.</target>       </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve" uid="M:System.Dynamic.DynamicObject.TryConvert(System.Dynamic.ConvertBinder,System.Object@)">
          <source>The <bpt id="p1">&lt;c&gt;</bpt>binder.Type<ept id="p1">&lt;/c&gt;</ept> property provides the type to which the object must be converted.</source>
          <target state="translated">La propiedad <bpt id="p1">&lt;c&gt;</bpt>binder.Type<ept id="p1">&lt;/c&gt;</ept> proporciona el tipo en el que se debe convertir el objeto.</target>       </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve" uid="M:System.Dynamic.DynamicObject.TryConvert(System.Dynamic.ConvertBinder,System.Object@)">
          <source>For example, for the statement <bpt id="p1">&lt;c&gt;</bpt>(String)sampleObject<ept id="p1">&lt;/c&gt;</ept> in C# (<bpt id="p2">&lt;c&gt;</bpt>CType(sampleObject, Type)<ept id="p2">&lt;/c&gt;</ept> in Visual Basic), where <bpt id="p3">&lt;c&gt;</bpt>sampleObject<ept id="p3">&lt;/c&gt;</ept> is an instance of the class derived from the <ph id="ph1">&lt;see cref="T:System.Dynamic.DynamicObject" /&gt;</ph> class, <bpt id="p4">&lt;c&gt;</bpt>binder.Type<ept id="p4">&lt;/c&gt;</ept> returns the <ph id="ph2">&lt;see cref="T:System.String" /&gt;</ph> type.</source>
          <target state="translated">Por ejemplo, para la instrucción <bpt id="p1">&lt;c&gt;</bpt>(String)sampleObject<ept id="p1">&lt;/c&gt;</ept> en C# (<bpt id="p2">&lt;c&gt;</bpt>CType(sampleObject, Type)<ept id="p2">&lt;/c&gt;</ept> en Visual Basic), donde <bpt id="p3">&lt;c&gt;</bpt>sampleObject<ept id="p3">&lt;/c&gt;</ept> es una instancia de la clase derivada de la clase <ph id="ph1">&lt;see cref="T:System.Dynamic.DynamicObject" /&gt;</ph>, <bpt id="p4">&lt;c&gt;</bpt>binder.Type<ept id="p4">&lt;/c&gt;</ept> devuelve el tipo <ph id="ph2">&lt;see cref="T:System.String" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve" uid="M:System.Dynamic.DynamicObject.TryConvert(System.Dynamic.ConvertBinder,System.Object@)">
          <source>The <bpt id="p1">&lt;c&gt;</bpt>binder.Explicit<ept id="p1">&lt;/c&gt;</ept> property provides information about the kind of conversion that occurs.</source>
          <target state="translated">La propiedad <bpt id="p1">&lt;c&gt;</bpt>binder.Explicit<ept id="p1">&lt;/c&gt;</ept> proporciona información sobre el tipo de conversión que se produce.</target>       </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve" uid="M:System.Dynamic.DynamicObject.TryConvert(System.Dynamic.ConvertBinder,System.Object@)">
          <source>It returns <ph id="ph1">&lt;see langword="true" /&gt;</ph> for explicit conversion and <ph id="ph2">&lt;see langword="false" /&gt;</ph> for implicit conversion.</source>
          <target state="translated">Devuelve <ph id="ph1">&lt;see langword="true" /&gt;</ph> para la conversión explícita y <ph id="ph2">&lt;see langword="false" /&gt;</ph> para la conversión implícita.</target>       </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve" uid="M:System.Dynamic.DynamicObject.TryConvert(System.Dynamic.ConvertBinder,System.Object@)">
          <source>The result of the type conversion operation.</source>
          <target state="translated">Resultado de la operación de conversión de tipos.</target>       </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve" uid="M:System.Dynamic.DynamicObject.TryConvert(System.Dynamic.ConvertBinder,System.Object@)">
          <source>Provides implementation for type conversion operations.</source>
          <target state="translated">Proporciona la implementación de las operaciones de conversión de tipos.</target>       </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve" uid="M:System.Dynamic.DynamicObject.TryConvert(System.Dynamic.ConvertBinder,System.Object@)">
          <source>Classes derived from the <ph id="ph1">&lt;see cref="T:System.Dynamic.DynamicObject" /&gt;</ph> class can override this method to specify dynamic behavior for operations that convert an object from one type to another.</source>
          <target state="translated">Las clases derivadas de la clase <ph id="ph1">&lt;see cref="T:System.Dynamic.DynamicObject" /&gt;</ph> pueden invalidar este método para especificar el comportamiento dinámico de las operaciones que convierten un objeto de un tipo a otro.</target>       </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve" uid="M:System.Dynamic.DynamicObject.TryConvert(System.Dynamic.ConvertBinder,System.Object@)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the operation is successful; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> si la operación es correcta; de lo contrario, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve" uid="M:System.Dynamic.DynamicObject.TryConvert(System.Dynamic.ConvertBinder,System.Object@)">
          <source>If this method returns <ph id="ph1">&lt;see langword="false" /&gt;</ph>, the run-time binder of the language determines the behavior.</source>
          <target state="translated">Si este método devuelve <ph id="ph1">&lt;see langword="false" /&gt;</ph>, el enlazador del lenguaje en tiempo de ejecución determina el comportamiento.</target>       </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve" uid="M:System.Dynamic.DynamicObject.TryConvert(System.Dynamic.ConvertBinder,System.Object@)">
          <source>(In most cases, a language-specific run-time exception is thrown.)</source>
          <target state="translated">(En la mayoría de los casos, se inicia una excepción específica del lenguaje en tiempo de ejecución).</target>       </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Dynamic.DynamicObject.TryConvert(System.Dynamic.ConvertBinder,System.Object@)">
          <source>Classes derived from the <ph id="ph1">&lt;xref:System.Dynamic.DynamicObject&gt;</ph> class can override this method to specify how a type conversion should be performed for a dynamic object.</source>
          <target state="translated">Las clases derivadas de la <ph id="ph1">&lt;xref:System.Dynamic.DynamicObject&gt;</ph> clase puede invalidar este método para especificar cómo se debe realizar una conversión de tipos para un objeto dinámico.</target>       </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Dynamic.DynamicObject.TryConvert(System.Dynamic.ConvertBinder,System.Object@)">
          <source>When the method is not overridden, the run-time binder of the language determines the behavior.</source>
          <target state="translated">Cuando no se reemplaza el método, el enlazador en tiempo de ejecución del lenguaje determina el comportamiento.</target>       </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Dynamic.DynamicObject.TryConvert(System.Dynamic.ConvertBinder,System.Object@)">
          <source>(In most cases, a language-specific run-time exception is thrown.)</source>
          <target state="translated">(En la mayoría de los casos, se inicia una excepción específica del lenguaje en tiempo de ejecución).</target>       </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Dynamic.DynamicObject.TryConvert(System.Dynamic.ConvertBinder,System.Object@)">
          <source>In C#, if this method is overridden, it is automatically invoked when you have an explicit or implicit conversion, as shown in the code example below.</source>
          <target state="translated">En C#, si se invalida este método, se invoca automáticamente cuando haya una conversión explícita o implícita, como se muestra en el ejemplo de código siguiente.</target>       </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Dynamic.DynamicObject.TryConvert(System.Dynamic.ConvertBinder,System.Object@)">
          <source>In Visual Basic, only explicit conversion is supported.</source>
          <target state="translated">En Visual Basic, se admite solamente a la conversión explícita.</target>       </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Dynamic.DynamicObject.TryConvert(System.Dynamic.ConvertBinder,System.Object@)">
          <source>If you override this method, you call it by using the <ph id="ph1">&lt;xref:Microsoft.VisualBasic.Conversion.CTypeDynamic%2A&gt;</ph> or <ph id="ph2">&lt;xref:Microsoft.VisualBasic.Conversion.CTypeDynamic%2A&gt;</ph> functions.</source>
          <target state="translated">Si invalida este método, se llama mediante el uso de la <ph id="ph1">&lt;xref:Microsoft.VisualBasic.Conversion.CTypeDynamic%2A&gt;</ph> o <ph id="ph2">&lt;xref:Microsoft.VisualBasic.Conversion.CTypeDynamic%2A&gt;</ph> funciones.</target>       </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Dynamic.DynamicObject.TryConvert(System.Dynamic.ConvertBinder,System.Object@)">
          <source>Assume that you need a data structure to store textual and numeric representations of numbers, and you want to define conversions of this data structure to strings and integers.</source>
          <target state="translated">Suponga que necesita una estructura de datos para almacenar representaciones numéricas y textuales de números, y desea definir conversiones de esta estructura de datos para las cadenas y enteros.</target>       </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Dynamic.DynamicObject.TryConvert(System.Dynamic.ConvertBinder,System.Object@)">
          <source>The following code example demonstrates the <ph id="ph1">`DynamicNumber`</ph> class, which is derived from the <ph id="ph2">&lt;xref:System.Dynamic.DynamicObject&gt;</ph> class.</source>
          <target state="translated">En el ejemplo de código siguiente se muestra la <ph id="ph1">`DynamicNumber`</ph> (clase), que se deriva de la <ph id="ph2">&lt;xref:System.Dynamic.DynamicObject&gt;</ph> clase.</target>       </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Dynamic.DynamicObject.TryConvert(System.Dynamic.ConvertBinder,System.Object@)">
          <source><ph id="ph1">`DynamicNumber`</ph> overrides the <ph id="ph2">&lt;xref:System.Dynamic.DynamicObject.TryConvert%2A&gt;</ph> method to enable type conversion.</source>
          <target state="translated"><ph id="ph1">`DynamicNumber`</ph> invalida el <ph id="ph2">&lt;xref:System.Dynamic.DynamicObject.TryConvert%2A&gt;</ph> método para habilitar la conversión de tipo.</target>       </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Dynamic.DynamicObject.TryConvert(System.Dynamic.ConvertBinder,System.Object@)">
          <source>It also overrides the <ph id="ph1">&lt;xref:System.Dynamic.DynamicObject.TrySetMember%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Dynamic.DynamicObject.TryGetMember%2A&gt;</ph> methods to enable access to the data elements.</source>
          <target state="translated">También invalida la <ph id="ph1">&lt;xref:System.Dynamic.DynamicObject.TrySetMember%2A&gt;</ph> y <ph id="ph2">&lt;xref:System.Dynamic.DynamicObject.TryGetMember%2A&gt;</ph> métodos para habilitar el acceso a los elementos de datos.</target>       </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Dynamic.DynamicObject.TryConvert(System.Dynamic.ConvertBinder,System.Object@)">
          <source>In this example, only conversion to strings and integers is supported.</source>
          <target state="translated">En este ejemplo, se admite solamente a la conversión a cadenas y enteros.</target>       </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Dynamic.DynamicObject.TryConvert(System.Dynamic.ConvertBinder,System.Object@)">
          <source>If you try to convert an object to any other type, a run-time exception is thrown.</source>
          <target state="translated">Si intenta convertir un objeto en cualquier otro tipo, se produce una excepción en tiempo de ejecución.</target>       </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve" uid="M:System.Dynamic.DynamicObject.TryCreateInstance(System.Dynamic.CreateInstanceBinder,System.Object[],System.Object@)">
          <source>Provides information about the initialization operation.</source>
          <target state="translated">Proporciona información sobre la operación de inicialización.</target>       </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve" uid="M:System.Dynamic.DynamicObject.TryCreateInstance(System.Dynamic.CreateInstanceBinder,System.Object[],System.Object@)">
          <source>The arguments that are passed to the object during initialization.</source>
          <target state="translated">Argumentos que se pasan al objeto durante la inicialización.</target>       </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve" uid="M:System.Dynamic.DynamicObject.TryCreateInstance(System.Dynamic.CreateInstanceBinder,System.Object[],System.Object@)">
          <source>For example, for the <bpt id="p1">&lt;c&gt;</bpt>new SampleType(100)<ept id="p1">&lt;/c&gt;</ept> operation, where <bpt id="p2">&lt;c&gt;</bpt>SampleType<ept id="p2">&lt;/c&gt;</ept> is the type derived from the <ph id="ph1">&lt;see cref="T:System.Dynamic.DynamicObject" /&gt;</ph> class, <bpt id="p3">&lt;c&gt;</bpt>args[0]<ept id="p3">&lt;/c&gt;</ept> is equal to 100.</source>
          <target state="translated">Por ejemplo, para la operación <bpt id="p1">&lt;c&gt;</bpt>new SampleType(100)<ept id="p1">&lt;/c&gt;</ept>, donde <bpt id="p2">&lt;c&gt;</bpt>SampleType<ept id="p2">&lt;/c&gt;</ept> es el tipo derivado de la clase <ph id="ph1">&lt;see cref="T:System.Dynamic.DynamicObject" /&gt;</ph>, <bpt id="p3">&lt;c&gt;</bpt>args[0]<ept id="p3">&lt;/c&gt;</ept> es igual que 100.</target>       </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve" uid="M:System.Dynamic.DynamicObject.TryCreateInstance(System.Dynamic.CreateInstanceBinder,System.Object[],System.Object@)">
          <source>The result of the initialization.</source>
          <target state="translated">Resultado de la inicialización.</target>       </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve" uid="M:System.Dynamic.DynamicObject.TryCreateInstance(System.Dynamic.CreateInstanceBinder,System.Object[],System.Object@)">
          <source>Provides the implementation for operations that initialize a new instance of a dynamic object.</source>
          <target state="translated">Proporciona la implementación de las operaciones que inicializan una nueva instancia de un objeto dinámico.</target>       </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve" uid="M:System.Dynamic.DynamicObject.TryCreateInstance(System.Dynamic.CreateInstanceBinder,System.Object[],System.Object@)">
          <source>This method is not intended for use in C# or Visual Basic.</source>
          <target state="translated">Este método no está pensado para su uso en C# o Visual Basic.</target>       </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve" uid="M:System.Dynamic.DynamicObject.TryCreateInstance(System.Dynamic.CreateInstanceBinder,System.Object[],System.Object@)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the operation is successful; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> si la operación es correcta; de lo contrario, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve" uid="M:System.Dynamic.DynamicObject.TryCreateInstance(System.Dynamic.CreateInstanceBinder,System.Object[],System.Object@)">
          <source>If this method returns <ph id="ph1">&lt;see langword="false" /&gt;</ph>, the run-time binder of the language determines the behavior.</source>
          <target state="translated">Si este método devuelve <ph id="ph1">&lt;see langword="false" /&gt;</ph>, el enlazador del lenguaje en tiempo de ejecución determina el comportamiento.</target>       </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve" uid="M:System.Dynamic.DynamicObject.TryCreateInstance(System.Dynamic.CreateInstanceBinder,System.Object[],System.Object@)">
          <source>(In most cases, a language-specific run-time exception is thrown.)</source>
          <target state="translated">(En la mayoría de los casos, se inicia una excepción específica del lenguaje en tiempo de ejecución).</target>       </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Dynamic.DynamicObject.TryCreateInstance(System.Dynamic.CreateInstanceBinder,System.Object[],System.Object@)">
          <source>Classes derived from the <ph id="ph1">&lt;xref:System.Dynamic.DynamicObject&gt;</ph> class can override this method to specify how a new instance of the dynamic object should be initialized.</source>
          <target state="translated">Las clases derivadas de la <ph id="ph1">&lt;xref:System.Dynamic.DynamicObject&gt;</ph> clase puede invalidar este método para especificar cómo se debe inicializar una nueva instancia del objeto dinámico.</target>       </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Dynamic.DynamicObject.TryCreateInstance(System.Dynamic.CreateInstanceBinder,System.Object[],System.Object@)">
          <source>When the method is not overridden, the run-time binder of the language determines the behavior.</source>
          <target state="translated">Cuando no se reemplaza el método, el enlazador en tiempo de ejecución del lenguaje determina el comportamiento.</target>       </trans-unit>
        <trans-unit id="252" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Dynamic.DynamicObject.TryCreateInstance(System.Dynamic.CreateInstanceBinder,System.Object[],System.Object@)">
          <source>(In most cases, a language-specific run-time exception is thrown.)</source>
          <target state="translated">(En la mayoría de los casos, se inicia una excepción específica del lenguaje en tiempo de ejecución).</target>       </trans-unit>
        <trans-unit id="253" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Dynamic.DynamicObject.TryCreateInstance(System.Dynamic.CreateInstanceBinder,System.Object[],System.Object@)">
          <source>C# and Visual Basic compilers never emit code to use this method because they do not support first-class types.</source>
          <target state="translated">Compiladores C# y Visual Basic nunca emiten código para utilizar este método porque no admiten tipos de primera clase.</target>       </trans-unit>
        <trans-unit id="254" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Dynamic.DynamicObject.TryCreateInstance(System.Dynamic.CreateInstanceBinder,System.Object[],System.Object@)">
          <source>This method is intended for languages that support the initialization of dynamic objects by using syntax like <ph id="ph1">`dynamic new`</ph>.</source>
          <target state="translated">Este método está pensado para los lenguajes que admiten la inicialización de objetos dinámicos utilizando sintaxis como <ph id="ph1">`dynamic new`</ph>.</target>       </trans-unit>
        <trans-unit id="255" translate="yes" xml:space="preserve" uid="M:System.Dynamic.DynamicObject.TryDeleteIndex(System.Dynamic.DeleteIndexBinder,System.Object[])">
          <source>Provides information about the deletion.</source>
          <target state="translated">Proporciona información sobre la eliminación.</target>       </trans-unit>
        <trans-unit id="256" translate="yes" xml:space="preserve" uid="M:System.Dynamic.DynamicObject.TryDeleteIndex(System.Dynamic.DeleteIndexBinder,System.Object[])">
          <source>The indexes to be deleted.</source>
          <target state="translated">Índices que se van a eliminar.</target>       </trans-unit>
        <trans-unit id="257" translate="yes" xml:space="preserve" uid="M:System.Dynamic.DynamicObject.TryDeleteIndex(System.Dynamic.DeleteIndexBinder,System.Object[])">
          <source>Provides the implementation for operations that delete an object by index.</source>
          <target state="translated">Proporciona la implementación de las operaciones que eliminan un objeto por índice.</target>       </trans-unit>
        <trans-unit id="258" translate="yes" xml:space="preserve" uid="M:System.Dynamic.DynamicObject.TryDeleteIndex(System.Dynamic.DeleteIndexBinder,System.Object[])">
          <source>This method is not intended for use in C# or Visual Basic.</source>
          <target state="translated">Este método no está pensado para su uso en C# o Visual Basic.</target>       </trans-unit>
        <trans-unit id="259" translate="yes" xml:space="preserve" uid="M:System.Dynamic.DynamicObject.TryDeleteIndex(System.Dynamic.DeleteIndexBinder,System.Object[])">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the operation is successful; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> si la operación es correcta; de lo contrario, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="260" translate="yes" xml:space="preserve" uid="M:System.Dynamic.DynamicObject.TryDeleteIndex(System.Dynamic.DeleteIndexBinder,System.Object[])">
          <source>If this method returns <ph id="ph1">&lt;see langword="false" /&gt;</ph>, the run-time binder of the language determines the behavior.</source>
          <target state="translated">Si este método devuelve <ph id="ph1">&lt;see langword="false" /&gt;</ph>, el enlazador del lenguaje en tiempo de ejecución determina el comportamiento.</target>       </trans-unit>
        <trans-unit id="261" translate="yes" xml:space="preserve" uid="M:System.Dynamic.DynamicObject.TryDeleteIndex(System.Dynamic.DeleteIndexBinder,System.Object[])">
          <source>(In most cases, a language-specific run-time exception is thrown.)</source>
          <target state="translated">(En la mayoría de los casos, se inicia una excepción específica del lenguaje en tiempo de ejecución).</target>       </trans-unit>
        <trans-unit id="262" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Dynamic.DynamicObject.TryDeleteIndex(System.Dynamic.DeleteIndexBinder,System.Object[])">
          <source>Classes derived from the <ph id="ph1">&lt;xref:System.Dynamic.DynamicObject&gt;</ph> class can override this method to specify how a value that has a specified index should be deleted.</source>
          <target state="translated">Las clases derivadas de la <ph id="ph1">&lt;xref:System.Dynamic.DynamicObject&gt;</ph> clase puede invalidar este método para especificar cómo se debería eliminar un valor que tiene un índice especificado.</target>       </trans-unit>
        <trans-unit id="263" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Dynamic.DynamicObject.TryDeleteIndex(System.Dynamic.DeleteIndexBinder,System.Object[])">
          <source>When the method is not overridden, the run-time binder of the language determines the behavior.</source>
          <target state="translated">Cuando no se reemplaza el método, el enlazador en tiempo de ejecución del lenguaje determina el comportamiento.</target>       </trans-unit>
        <trans-unit id="264" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Dynamic.DynamicObject.TryDeleteIndex(System.Dynamic.DeleteIndexBinder,System.Object[])">
          <source>(In most cases, a language-specific run-time exception is thrown.)</source>
          <target state="translated">(En la mayoría de los casos, se inicia una excepción específica del lenguaje en tiempo de ejecución).</target>       </trans-unit>
        <trans-unit id="265" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Dynamic.DynamicObject.TryDeleteIndex(System.Dynamic.DeleteIndexBinder,System.Object[])">
          <source>C# and Visual Basic compilers never emit code to use this method because they do not support this kind of operation.</source>
          <target state="translated">Compiladores C# y Visual Basic nunca emiten código para utilizar este método porque no admiten este tipo de operación.</target>       </trans-unit>
        <trans-unit id="266" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Dynamic.DynamicObject.TryDeleteIndex(System.Dynamic.DeleteIndexBinder,System.Object[])">
          <source>This method is intended for languages that support syntax for deleting objects by index, such as <ph id="ph1">`del sampleObject[1,2]`</ph> in Python.</source>
          <target state="translated">Este método está pensado para lenguajes compatibles con sintaxis para eliminar objetos por índice, como <ph id="ph1">`del sampleObject[1,2]`</ph> en Python.</target>       </trans-unit>
        <trans-unit id="267" translate="yes" xml:space="preserve" uid="M:System.Dynamic.DynamicObject.TryDeleteMember(System.Dynamic.DeleteMemberBinder)">
          <source>Provides information about the deletion.</source>
          <target state="translated">Proporciona información sobre la eliminación.</target>       </trans-unit>
        <trans-unit id="268" translate="yes" xml:space="preserve" uid="M:System.Dynamic.DynamicObject.TryDeleteMember(System.Dynamic.DeleteMemberBinder)">
          <source>Provides the implementation for operations that delete an object member.</source>
          <target state="translated">Proporciona la implementación de las operaciones que eliminan un miembro de objeto.</target>       </trans-unit>
        <trans-unit id="269" translate="yes" xml:space="preserve" uid="M:System.Dynamic.DynamicObject.TryDeleteMember(System.Dynamic.DeleteMemberBinder)">
          <source>This method is not intended for use in C# or Visual Basic.</source>
          <target state="translated">Este método no está pensado para su uso en C# o Visual Basic.</target>       </trans-unit>
        <trans-unit id="270" translate="yes" xml:space="preserve" uid="M:System.Dynamic.DynamicObject.TryDeleteMember(System.Dynamic.DeleteMemberBinder)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the operation is successful; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> si la operación es correcta; de lo contrario, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="271" translate="yes" xml:space="preserve" uid="M:System.Dynamic.DynamicObject.TryDeleteMember(System.Dynamic.DeleteMemberBinder)">
          <source>If this method returns <ph id="ph1">&lt;see langword="false" /&gt;</ph>, the run-time binder of the language determines the behavior.</source>
          <target state="translated">Si este método devuelve <ph id="ph1">&lt;see langword="false" /&gt;</ph>, el enlazador del lenguaje en tiempo de ejecución determina el comportamiento.</target>       </trans-unit>
        <trans-unit id="272" translate="yes" xml:space="preserve" uid="M:System.Dynamic.DynamicObject.TryDeleteMember(System.Dynamic.DeleteMemberBinder)">
          <source>(In most cases, a language-specific run-time exception is thrown.)</source>
          <target state="translated">(En la mayoría de los casos, se inicia una excepción específica del lenguaje en tiempo de ejecución).</target>       </trans-unit>
        <trans-unit id="273" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Dynamic.DynamicObject.TryDeleteMember(System.Dynamic.DeleteMemberBinder)">
          <source>Classes derived from the <ph id="ph1">&lt;xref:System.Dynamic.DynamicObject&gt;</ph> class can override this method to specify how an object member should be deleted.</source>
          <target state="translated">Las clases derivadas de la <ph id="ph1">&lt;xref:System.Dynamic.DynamicObject&gt;</ph> clase puede invalidar este método para especificar cómo se debería eliminar un miembro de objeto.</target>       </trans-unit>
        <trans-unit id="274" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Dynamic.DynamicObject.TryDeleteMember(System.Dynamic.DeleteMemberBinder)">
          <source>When this method is not overridden, the run-time binder of the language determines the behavior.</source>
          <target state="translated">Cuando no se invalida este método, el enlazador en tiempo de ejecución del lenguaje determina el comportamiento.</target>       </trans-unit>
        <trans-unit id="275" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Dynamic.DynamicObject.TryDeleteMember(System.Dynamic.DeleteMemberBinder)">
          <source>(In most cases, a language-specific run-time exception is thrown.)</source>
          <target state="translated">(En la mayoría de los casos, se inicia una excepción específica del lenguaje en tiempo de ejecución).</target>       </trans-unit>
        <trans-unit id="276" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Dynamic.DynamicObject.TryDeleteMember(System.Dynamic.DeleteMemberBinder)">
          <source>C# and Visual Basic compilers never emit code to use this method because they do not support this kind of operation.</source>
          <target state="translated">Compiladores C# y Visual Basic nunca emiten código para utilizar este método porque no admiten este tipo de operación.</target>       </trans-unit>
        <trans-unit id="277" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Dynamic.DynamicObject.TryDeleteMember(System.Dynamic.DeleteMemberBinder)">
          <source>This method is intended for languages that support syntax for deleting members, such as <ph id="ph1">`del sampleObject.SampleMember`</ph> in Python.</source>
          <target state="translated">Este método está pensado para lenguajes compatibles con sintaxis para eliminar miembros, como <ph id="ph1">`del sampleObject.SampleMember`</ph> en Python.</target>       </trans-unit>
        <trans-unit id="278" translate="yes" xml:space="preserve" uid="M:System.Dynamic.DynamicObject.TryGetIndex(System.Dynamic.GetIndexBinder,System.Object[],System.Object@)">
          <source>Provides information about the operation.</source>
          <target state="translated">Proporciona información sobre la operación.</target>       </trans-unit>
        <trans-unit id="279" translate="yes" xml:space="preserve" uid="M:System.Dynamic.DynamicObject.TryGetIndex(System.Dynamic.GetIndexBinder,System.Object[],System.Object@)">
          <source>The indexes that are used in the operation.</source>
          <target state="translated">Índices que se usan en la operación.</target>       </trans-unit>
        <trans-unit id="280" translate="yes" xml:space="preserve" uid="M:System.Dynamic.DynamicObject.TryGetIndex(System.Dynamic.GetIndexBinder,System.Object[],System.Object@)">
          <source>For example, for the <bpt id="p1">&lt;c&gt;</bpt>sampleObject[3]<ept id="p1">&lt;/c&gt;</ept> operation in C# (<bpt id="p2">&lt;c&gt;</bpt>sampleObject(3)<ept id="p2">&lt;/c&gt;</ept> in Visual Basic), where <bpt id="p3">&lt;c&gt;</bpt>sampleObject<ept id="p3">&lt;/c&gt;</ept> is derived from the <ph id="ph1">&lt;see langword="DynamicObject" /&gt;</ph> class, <bpt id="p4">&lt;c&gt;</bpt>indexes[0]<ept id="p4">&lt;/c&gt;</ept> is equal to 3.</source>
          <target state="translated">Por ejemplo, para la operación <bpt id="p1">&lt;c&gt;</bpt>sampleObject[3]<ept id="p1">&lt;/c&gt;</ept> en C# (<bpt id="p2">&lt;c&gt;</bpt>sampleObject(3)<ept id="p2">&lt;/c&gt;</ept> en Visual Basic), donde <bpt id="p3">&lt;c&gt;</bpt>sampleObject<ept id="p3">&lt;/c&gt;</ept> se deriva de la clase <ph id="ph1">&lt;see langword="DynamicObject" /&gt;</ph>, <bpt id="p4">&lt;c&gt;</bpt>indexes[0]<ept id="p4">&lt;/c&gt;</ept> es igual que 3.</target>       </trans-unit>
        <trans-unit id="281" translate="yes" xml:space="preserve" uid="M:System.Dynamic.DynamicObject.TryGetIndex(System.Dynamic.GetIndexBinder,System.Object[],System.Object@)">
          <source>The result of the index operation.</source>
          <target state="translated">Resultado de la operación de índice.</target>       </trans-unit>
        <trans-unit id="282" translate="yes" xml:space="preserve" uid="M:System.Dynamic.DynamicObject.TryGetIndex(System.Dynamic.GetIndexBinder,System.Object[],System.Object@)">
          <source>Provides the implementation for operations that get a value by index.</source>
          <target state="translated">Proporciona la implementación de las operaciones que obtienen un valor por índice.</target>       </trans-unit>
        <trans-unit id="283" translate="yes" xml:space="preserve" uid="M:System.Dynamic.DynamicObject.TryGetIndex(System.Dynamic.GetIndexBinder,System.Object[],System.Object@)">
          <source>Classes derived from the <ph id="ph1">&lt;see cref="T:System.Dynamic.DynamicObject" /&gt;</ph> class can override this method to specify dynamic behavior for indexing operations.</source>
          <target state="translated">Las clases derivadas de la clase <ph id="ph1">&lt;see cref="T:System.Dynamic.DynamicObject" /&gt;</ph> pueden invalidar este método para especificar un comportamiento dinámico para las operaciones de indización.</target>       </trans-unit>
        <trans-unit id="284" translate="yes" xml:space="preserve" uid="M:System.Dynamic.DynamicObject.TryGetIndex(System.Dynamic.GetIndexBinder,System.Object[],System.Object@)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the operation is successful; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> si la operación es correcta; de lo contrario, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="285" translate="yes" xml:space="preserve" uid="M:System.Dynamic.DynamicObject.TryGetIndex(System.Dynamic.GetIndexBinder,System.Object[],System.Object@)">
          <source>If this method returns <ph id="ph1">&lt;see langword="false" /&gt;</ph>, the run-time binder of the language determines the behavior.</source>
          <target state="translated">Si este método devuelve <ph id="ph1">&lt;see langword="false" /&gt;</ph>, el enlazador del lenguaje en tiempo de ejecución determina el comportamiento.</target>       </trans-unit>
        <trans-unit id="286" translate="yes" xml:space="preserve" uid="M:System.Dynamic.DynamicObject.TryGetIndex(System.Dynamic.GetIndexBinder,System.Object[],System.Object@)">
          <source>(In most cases, a run-time exception is thrown.)</source>
          <target state="translated">(En la mayoría de los casos, se inicia una excepción en tiempo de ejecución).</target>       </trans-unit>
        <trans-unit id="287" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Dynamic.DynamicObject.TryGetIndex(System.Dynamic.GetIndexBinder,System.Object[],System.Object@)">
          <source>Classes derived from the <ph id="ph1">&lt;xref:System.Dynamic.DynamicObject&gt;</ph> class can override this method to specify how getting a value by index should be performed for a dynamic object.</source>
          <target state="translated">Las clases derivadas de la <ph id="ph1">&lt;xref:System.Dynamic.DynamicObject&gt;</ph> clase puede invalidar este método para especificar cómo obtener un valor por su índice se debe realizar para un objeto dinámico.</target>       </trans-unit>
        <trans-unit id="288" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Dynamic.DynamicObject.TryGetIndex(System.Dynamic.GetIndexBinder,System.Object[],System.Object@)">
          <source>When the method is not overridden, the run-time binder of the language determines the behavior.</source>
          <target state="translated">Cuando no se reemplaza el método, el enlazador en tiempo de ejecución del lenguaje determina el comportamiento.</target>       </trans-unit>
        <trans-unit id="289" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Dynamic.DynamicObject.TryGetIndex(System.Dynamic.GetIndexBinder,System.Object[],System.Object@)">
          <source>(In most cases, a run-time exception is thrown.)</source>
          <target state="translated">(En la mayoría de los casos, se inicia una excepción en tiempo de ejecución).</target>       </trans-unit>
        <trans-unit id="290" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Dynamic.DynamicObject.TryGetIndex(System.Dynamic.GetIndexBinder,System.Object[],System.Object@)">
          <source>If this method is overridden, it is automatically invoked when you have an operation like <ph id="ph1">`sampleObject[3]`</ph> in C# or <ph id="ph2">`sampleObject(3)`</ph> in Visual Basic, where <ph id="ph3">`sampleObject`</ph> is derived from the <ph id="ph4">&lt;xref:System.Dynamic.DynamicObject&gt;</ph> class.</source>
          <target state="translated">Si se invalida este método, se invoca automáticamente cuando haya una operación como <ph id="ph1">`sampleObject[3]`</ph> en C# o <ph id="ph2">`sampleObject(3)`</ph> en Visual Basic, donde <ph id="ph3">`sampleObject`</ph> se deriva de la <ph id="ph4">&lt;xref:System.Dynamic.DynamicObject&gt;</ph> clase.</target>       </trans-unit>
        <trans-unit id="291" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Dynamic.DynamicObject.TryGetIndex(System.Dynamic.GetIndexBinder,System.Object[],System.Object@)">
          <source>Assume that you want to create an object in which properties can be accessed either by names such as <ph id="ph1">`Property0`</ph>, <ph id="ph2">`Property1`</ph>, and so on, or by index, so that, for example, <ph id="ph3">`sampleObject.Property0`</ph> is equivalent to <ph id="ph4">`sampleObject[0]`</ph> in C# or <ph id="ph5">`sampleObject(0)`</ph> in Visual Basic.</source>
          <target state="translated">Suponga que desea crear un objeto en el que las propiedades pueden ser acceso mediante nombres como <ph id="ph1">`Property0`</ph>, <ph id="ph2">`Property1`</ph>, y así sucesivamente, o por índice, por lo que, por ejemplo, <ph id="ph3">`sampleObject.Property0`</ph> es equivalente a <ph id="ph4">`sampleObject[0]`</ph> en C# o <ph id="ph5">`sampleObject(0)`</ph> en Visual Basic.</target>       </trans-unit>
        <trans-unit id="292" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Dynamic.DynamicObject.TryGetIndex(System.Dynamic.GetIndexBinder,System.Object[],System.Object@)">
          <source>The following code example demonstrates the <ph id="ph1">`SampleDynamicObject`</ph> class, which is derived from the <ph id="ph2">&lt;xref:System.Dynamic.DynamicObject&gt;</ph> class.</source>
          <target state="translated">En el ejemplo de código siguiente se muestra la <ph id="ph1">`SampleDynamicObject`</ph> (clase), que se deriva de la <ph id="ph2">&lt;xref:System.Dynamic.DynamicObject&gt;</ph> clase.</target>       </trans-unit>
        <trans-unit id="293" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Dynamic.DynamicObject.TryGetIndex(System.Dynamic.GetIndexBinder,System.Object[],System.Object@)">
          <source>The <ph id="ph1">`SampleDynamicObject`</ph> class contains an object of the <ph id="ph2">`Dictionary&lt;string, object&gt;`</ph> type (<ph id="ph3">`Dictionary(Of String, Object)`</ph> in Visual Basic) to store the key-value pairs.</source>
          <target state="translated">El <ph id="ph1">`SampleDynamicObject`</ph> clase contiene un objeto de la <ph id="ph2">`Dictionary&lt;string, object&gt;`</ph> tipo (<ph id="ph3">`Dictionary(Of String, Object)`</ph> en Visual Basic) para almacenar los pares clave-valor.</target>       </trans-unit>
        <trans-unit id="294" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Dynamic.DynamicObject.TryGetIndex(System.Dynamic.GetIndexBinder,System.Object[],System.Object@)">
          <source><ph id="ph1">`SampleDynamicObject`</ph> overrides the <ph id="ph2">&lt;xref:System.Dynamic.DynamicObject.TrySetIndex%2A&gt;</ph> and <ph id="ph3">&lt;xref:System.Dynamic.DynamicObject.TryGetIndex%2A&gt;</ph> methods to enable access by index.</source>
          <target state="translated"><ph id="ph1">`SampleDynamicObject`</ph> invalida el <ph id="ph2">&lt;xref:System.Dynamic.DynamicObject.TrySetIndex%2A&gt;</ph> y <ph id="ph3">&lt;xref:System.Dynamic.DynamicObject.TryGetIndex%2A&gt;</ph> métodos para habilitar el acceso por índice.</target>       </trans-unit>
        <trans-unit id="295" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Dynamic.DynamicObject.TryGetIndex(System.Dynamic.GetIndexBinder,System.Object[],System.Object@)">
          <source>It overrides the <ph id="ph1">&lt;xref:System.Dynamic.DynamicObject.TrySetMember%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Dynamic.DynamicObject.TryGetMember%2A&gt;</ph> methods to enable access by property name.</source>
          <target state="translated">Reemplaza el <ph id="ph1">&lt;xref:System.Dynamic.DynamicObject.TrySetMember%2A&gt;</ph> y <ph id="ph2">&lt;xref:System.Dynamic.DynamicObject.TryGetMember%2A&gt;</ph> métodos para habilitar el acceso por nombre de propiedad.</target>       </trans-unit>
        <trans-unit id="296" translate="yes" xml:space="preserve" uid="M:System.Dynamic.DynamicObject.TryGetMember(System.Dynamic.GetMemberBinder,System.Object@)">
          <source>Provides information about the object that called the dynamic operation.</source>
          <target state="translated">Proporciona información sobre el objeto que llamó a la operación dinámica.</target>       </trans-unit>
        <trans-unit id="297" translate="yes" xml:space="preserve" uid="M:System.Dynamic.DynamicObject.TryGetMember(System.Dynamic.GetMemberBinder,System.Object@)">
          <source>The <bpt id="p1">&lt;c&gt;</bpt>binder.Name<ept id="p1">&lt;/c&gt;</ept> property provides the name of the member on which the dynamic operation is performed.</source>
          <target state="translated">La propiedad <bpt id="p1">&lt;c&gt;</bpt>binder.Name<ept id="p1">&lt;/c&gt;</ept> proporciona el nombre del miembro en el que se realiza la operación dinámica.</target>       </trans-unit>
        <trans-unit id="298" translate="yes" xml:space="preserve" uid="M:System.Dynamic.DynamicObject.TryGetMember(System.Dynamic.GetMemberBinder,System.Object@)">
          <source>For example, for the <bpt id="p1">&lt;c&gt;</bpt>Console.WriteLine(sampleObject.SampleProperty)<ept id="p1">&lt;/c&gt;</ept> statement, where <bpt id="p2">&lt;c&gt;</bpt>sampleObject<ept id="p2">&lt;/c&gt;</ept> is an instance of the class derived from the <ph id="ph1">&lt;see cref="T:System.Dynamic.DynamicObject" /&gt;</ph> class, <bpt id="p3">&lt;c&gt;</bpt>binder.Name<ept id="p3">&lt;/c&gt;</ept> returns "SampleProperty".</source>
          <target state="translated">Por ejemplo, para la instrucción <bpt id="p1">&lt;c&gt;</bpt>Console.WriteLine(sampleObject.SampleProperty)<ept id="p1">&lt;/c&gt;</ept>, donde <bpt id="p2">&lt;c&gt;</bpt>sampleObject<ept id="p2">&lt;/c&gt;</ept> es una instancia de la clase derivada de la clase <ph id="ph1">&lt;see cref="T:System.Dynamic.DynamicObject" /&gt;</ph>, <bpt id="p3">&lt;c&gt;</bpt>binder.Name<ept id="p3">&lt;/c&gt;</ept> devuelve "SampleProperty".</target>       </trans-unit>
        <trans-unit id="299" translate="yes" xml:space="preserve" uid="M:System.Dynamic.DynamicObject.TryGetMember(System.Dynamic.GetMemberBinder,System.Object@)">
          <source>The <bpt id="p1">&lt;c&gt;</bpt>binder.IgnoreCase<ept id="p1">&lt;/c&gt;</ept> property specifies whether the member name is case-sensitive.</source>
          <target state="translated">La propiedad <bpt id="p1">&lt;c&gt;</bpt>binder.IgnoreCase<ept id="p1">&lt;/c&gt;</ept> especifica si el nombre de miembro distingue mayúsculas de minúsculas.</target>       </trans-unit>
        <trans-unit id="300" translate="yes" xml:space="preserve" uid="M:System.Dynamic.DynamicObject.TryGetMember(System.Dynamic.GetMemberBinder,System.Object@)">
          <source>The result of the get operation.</source>
          <target state="translated">Resultado de la operación Get.</target>       </trans-unit>
        <trans-unit id="301" translate="yes" xml:space="preserve" uid="M:System.Dynamic.DynamicObject.TryGetMember(System.Dynamic.GetMemberBinder,System.Object@)">
          <source>For example, if the method is called for a property, you can assign the property value to <bpt id="p1">&lt;c&gt;</bpt>result<ept id="p1">&lt;/c&gt;</ept>.</source>
          <target state="translated">Por ejemplo, si se llama al método para una propiedad, se puede asignar el valor de la propiedad a <bpt id="p1">&lt;c&gt;</bpt>result<ept id="p1">&lt;/c&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="302" translate="yes" xml:space="preserve" uid="M:System.Dynamic.DynamicObject.TryGetMember(System.Dynamic.GetMemberBinder,System.Object@)">
          <source>Provides the implementation for operations that get member values.</source>
          <target state="translated">Proporciona la implementación de las operaciones que obtienen valores de miembro.</target>       </trans-unit>
        <trans-unit id="303" translate="yes" xml:space="preserve" uid="M:System.Dynamic.DynamicObject.TryGetMember(System.Dynamic.GetMemberBinder,System.Object@)">
          <source>Classes derived from the <ph id="ph1">&lt;see cref="T:System.Dynamic.DynamicObject" /&gt;</ph> class can override this method to specify dynamic behavior for operations such as getting a value for a property.</source>
          <target state="translated">Las clases derivadas de la clase <ph id="ph1">&lt;see cref="T:System.Dynamic.DynamicObject" /&gt;</ph> pueden invalidar este método para especificar un comportamiento dinámico para operaciones como obtener el valor de una propiedad.</target>       </trans-unit>
        <trans-unit id="304" translate="yes" xml:space="preserve" uid="M:System.Dynamic.DynamicObject.TryGetMember(System.Dynamic.GetMemberBinder,System.Object@)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the operation is successful; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> si la operación es correcta; de lo contrario, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="305" translate="yes" xml:space="preserve" uid="M:System.Dynamic.DynamicObject.TryGetMember(System.Dynamic.GetMemberBinder,System.Object@)">
          <source>If this method returns <ph id="ph1">&lt;see langword="false" /&gt;</ph>, the run-time binder of the language determines the behavior.</source>
          <target state="translated">Si este método devuelve <ph id="ph1">&lt;see langword="false" /&gt;</ph>, el enlazador del lenguaje en tiempo de ejecución determina el comportamiento.</target>       </trans-unit>
        <trans-unit id="306" translate="yes" xml:space="preserve" uid="M:System.Dynamic.DynamicObject.TryGetMember(System.Dynamic.GetMemberBinder,System.Object@)">
          <source>(In most cases, a run-time exception is thrown.)</source>
          <target state="translated">(En la mayoría de los casos, se inicia una excepción en tiempo de ejecución).</target>       </trans-unit>
        <trans-unit id="307" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Dynamic.DynamicObject.TryGetMember(System.Dynamic.GetMemberBinder,System.Object@)">
          <source>Classes derived from the <ph id="ph1">&lt;xref:System.Dynamic.DynamicObject&gt;</ph> class can override this method to specify how operations that get member values should be performed for a dynamic object.</source>
          <target state="translated">Las clases derivadas de la <ph id="ph1">&lt;xref:System.Dynamic.DynamicObject&gt;</ph> clase puede invalidar este método para especificar cómo se deben realizar las operaciones que obtienen valores de miembro para un objeto dinámico.</target>       </trans-unit>
        <trans-unit id="308" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Dynamic.DynamicObject.TryGetMember(System.Dynamic.GetMemberBinder,System.Object@)">
          <source>When the method is not overridden, the run-time binder of the language determines the behavior.</source>
          <target state="translated">Cuando no se reemplaza el método, el enlazador en tiempo de ejecución del lenguaje determina el comportamiento.</target>       </trans-unit>
        <trans-unit id="309" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Dynamic.DynamicObject.TryGetMember(System.Dynamic.GetMemberBinder,System.Object@)">
          <source>(In most cases, a run-time exception is thrown.)</source>
          <target state="translated">(En la mayoría de los casos, se inicia una excepción en tiempo de ejecución).</target>       </trans-unit>
        <trans-unit id="310" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Dynamic.DynamicObject.TryGetMember(System.Dynamic.GetMemberBinder,System.Object@)">
          <source>This method is called when you have statements like <ph id="ph1">`Console.WriteLine(sampleObject.SampleProperty)`</ph>, where <ph id="ph2">`sampleObject`</ph> is an instance of the class derived from the <ph id="ph3">&lt;xref:System.Dynamic.DynamicObject&gt;</ph> class.</source>
          <target state="translated">Se llama a este método si tiene instrucciones como <ph id="ph1">`Console.WriteLine(sampleObject.SampleProperty)`</ph>, donde <ph id="ph2">`sampleObject`</ph> es una instancia de la clase derivada de la <ph id="ph3">&lt;xref:System.Dynamic.DynamicObject&gt;</ph> clase.</target>       </trans-unit>
        <trans-unit id="311" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Dynamic.DynamicObject.TryGetMember(System.Dynamic.GetMemberBinder,System.Object@)">
          <source>You can also add your own members to classes derived from the <ph id="ph1">`DynamicObject`</ph> class.</source>
          <target state="translated">También puede agregar sus propios miembros a clases derivadas de la <ph id="ph1">`DynamicObject`</ph> clase.</target>       </trans-unit>
        <trans-unit id="312" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Dynamic.DynamicObject.TryGetMember(System.Dynamic.GetMemberBinder,System.Object@)">
          <source>If your class defines properties and also overrides the <ph id="ph1">&lt;xref:System.Dynamic.DynamicObject.TrySetMember%2A&gt;</ph> method, the dynamic language runtime (DLR) first uses the language binder to look for a static definition of a property in the class.</source>
          <target state="translated">Si su clase define propiedades y también invalida la <ph id="ph1">&lt;xref:System.Dynamic.DynamicObject.TrySetMember%2A&gt;</ph> método, dynamic language runtime (DLR) usa primero el enlazador del lenguaje para buscar una definición estática de una propiedad en la clase.</target>       </trans-unit>
        <trans-unit id="313" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Dynamic.DynamicObject.TryGetMember(System.Dynamic.GetMemberBinder,System.Object@)">
          <source>If there is no such property, the DLR calls the <ph id="ph1">&lt;xref:System.Dynamic.DynamicObject.TrySetMember%2A&gt;</ph> method.</source>
          <target state="translated">Si no hay ninguna propiedad de este tipo, DLR llama el <ph id="ph1">&lt;xref:System.Dynamic.DynamicObject.TrySetMember%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="314" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Dynamic.DynamicObject.TryGetMember(System.Dynamic.GetMemberBinder,System.Object@)">
          <source>Assume that you want to provide alternative syntax for accessing values in a dictionary, so that instead of writing <ph id="ph1">`sampleDictionary["Text"] = "Sample text"`</ph> (<ph id="ph2">`sampleDictionary("Text") = "Sample text"`</ph> in Visual Basic), you can write <ph id="ph3">`sampleDictionary.Text = "Sample text"`</ph>.</source>
          <target state="translated">Suponga que desea proporcionar una sintaxis alternativa para tener acceso a valores de dictionary, así que, en lugar de escribir <ph id="ph1">`sampleDictionary["Text"] = "Sample text"`</ph> (<ph id="ph2">`sampleDictionary("Text") = "Sample text"`</ph> en Visual Basic), puede escribir <ph id="ph3">`sampleDictionary.Text = "Sample text"`</ph>.</target>       </trans-unit>
        <trans-unit id="315" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Dynamic.DynamicObject.TryGetMember(System.Dynamic.GetMemberBinder,System.Object@)">
          <source>Also, this syntax must be case-insensitive, so that <ph id="ph1">`sampleDictionary.Text`</ph> is equivalent to <ph id="ph2">`sampleDictionary.text`</ph>.</source>
          <target state="translated">Además, esta sintaxis debe distinguir mayúsculas de minúsculas, por lo que <ph id="ph1">`sampleDictionary.Text`</ph> es equivalente a <ph id="ph2">`sampleDictionary.text`</ph>.</target>       </trans-unit>
        <trans-unit id="316" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Dynamic.DynamicObject.TryGetMember(System.Dynamic.GetMemberBinder,System.Object@)">
          <source>The following code example demonstrates the <ph id="ph1">`DynamicDictionary`</ph> class, which is derived from the <ph id="ph2">&lt;xref:System.Dynamic.DynamicObject&gt;</ph> class.</source>
          <target state="translated">En el ejemplo de código siguiente se muestra la <ph id="ph1">`DynamicDictionary`</ph> (clase), que se deriva de la <ph id="ph2">&lt;xref:System.Dynamic.DynamicObject&gt;</ph> clase.</target>       </trans-unit>
        <trans-unit id="317" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Dynamic.DynamicObject.TryGetMember(System.Dynamic.GetMemberBinder,System.Object@)">
          <source>The <ph id="ph1">`DynamicDictionary`</ph> class contains an object of the <ph id="ph2">`Dictionary&lt;string, object&gt;`</ph> type (<ph id="ph3">`Dictionary(Of String, Object)`</ph> in Visual Basic) to store the key-value pairs, and overrides the <ph id="ph4">&lt;xref:System.Dynamic.DynamicObject.TrySetMember%2A&gt;</ph> and <ph id="ph5">&lt;xref:System.Dynamic.DynamicObject.TryGetMember%2A&gt;</ph> methods to support the new syntax.</source>
          <target state="translated">El <ph id="ph1">`DynamicDictionary`</ph> clase contiene un objeto de la <ph id="ph2">`Dictionary&lt;string, object&gt;`</ph> tipo (<ph id="ph3">`Dictionary(Of String, Object)`</ph> en Visual Basic) para almacenar los pares clave-valor e invalida el <ph id="ph4">&lt;xref:System.Dynamic.DynamicObject.TrySetMember%2A&gt;</ph> y <ph id="ph5">&lt;xref:System.Dynamic.DynamicObject.TryGetMember%2A&gt;</ph> métodos para admitir la nueva sintaxis.</target>       </trans-unit>
        <trans-unit id="318" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Dynamic.DynamicObject.TryGetMember(System.Dynamic.GetMemberBinder,System.Object@)">
          <source>It also provides a <ph id="ph1">`Count`</ph> property, which shows how many dynamic properties the dictionary contains.</source>
          <target state="translated">También proporciona un <ph id="ph1">`Count`</ph> contiene la propiedad, que muestra el número de propiedades dinámicas en el diccionario.</target>       </trans-unit>
        <trans-unit id="319" translate="yes" xml:space="preserve" uid="M:System.Dynamic.DynamicObject.TryInvoke(System.Dynamic.InvokeBinder,System.Object[],System.Object@)">
          <source>Provides information about the invoke operation.</source>
          <target state="translated">Proporciona información sobre la operación de invocación.</target>       </trans-unit>
        <trans-unit id="320" translate="yes" xml:space="preserve" uid="M:System.Dynamic.DynamicObject.TryInvoke(System.Dynamic.InvokeBinder,System.Object[],System.Object@)">
          <source>The arguments that are passed to the object during the invoke operation.</source>
          <target state="translated">Argumentos que se pasan al objeto durante la operación de invocación.</target>       </trans-unit>
        <trans-unit id="321" translate="yes" xml:space="preserve" uid="M:System.Dynamic.DynamicObject.TryInvoke(System.Dynamic.InvokeBinder,System.Object[],System.Object@)">
          <source>For example, for the <bpt id="p1">&lt;c&gt;</bpt>sampleObject(100)<ept id="p1">&lt;/c&gt;</ept> operation, where <bpt id="p2">&lt;c&gt;</bpt>sampleObject<ept id="p2">&lt;/c&gt;</ept> is derived from the <ph id="ph1">&lt;see cref="T:System.Dynamic.DynamicObject" /&gt;</ph> class, <bpt id="p3">&lt;c&gt;</bpt>args[0]<ept id="p3">&lt;/c&gt;</ept> is equal to 100.</source>
          <target state="translated">Por ejemplo, para la operación <bpt id="p1">&lt;c&gt;</bpt>sampleObject(100)<ept id="p1">&lt;/c&gt;</ept>, donde <bpt id="p2">&lt;c&gt;</bpt>sampleObject<ept id="p2">&lt;/c&gt;</ept> se deriva de la clase <ph id="ph1">&lt;see cref="T:System.Dynamic.DynamicObject" /&gt;</ph>, <bpt id="p3">&lt;c&gt;</bpt>args[0]<ept id="p3">&lt;/c&gt;</ept> es igual que 100.</target>       </trans-unit>
        <trans-unit id="322" translate="yes" xml:space="preserve" uid="M:System.Dynamic.DynamicObject.TryInvoke(System.Dynamic.InvokeBinder,System.Object[],System.Object@)">
          <source>The result of the object invocation.</source>
          <target state="translated">Resultado de la invocación de objeto.</target>       </trans-unit>
        <trans-unit id="323" translate="yes" xml:space="preserve" uid="M:System.Dynamic.DynamicObject.TryInvoke(System.Dynamic.InvokeBinder,System.Object[],System.Object@)">
          <source>Provides the implementation for operations that invoke an object.</source>
          <target state="translated">Proporciona la implementación para las operaciones que invocan un objeto.</target>       </trans-unit>
        <trans-unit id="324" translate="yes" xml:space="preserve" uid="M:System.Dynamic.DynamicObject.TryInvoke(System.Dynamic.InvokeBinder,System.Object[],System.Object@)">
          <source>Classes derived from the <ph id="ph1">&lt;see cref="T:System.Dynamic.DynamicObject" /&gt;</ph> class can override this method to specify dynamic behavior for operations such as invoking an object or a delegate.</source>
          <target state="translated">Las clases derivadas de la clase <ph id="ph1">&lt;see cref="T:System.Dynamic.DynamicObject" /&gt;</ph> pueden invalidar este método para especificar un comportamiento dinámico para operaciones como invocar un objeto o un delegado.</target>       </trans-unit>
        <trans-unit id="325" translate="yes" xml:space="preserve" uid="M:System.Dynamic.DynamicObject.TryInvoke(System.Dynamic.InvokeBinder,System.Object[],System.Object@)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the operation is successful; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> si la operación es correcta; de lo contrario, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="326" translate="yes" xml:space="preserve" uid="M:System.Dynamic.DynamicObject.TryInvoke(System.Dynamic.InvokeBinder,System.Object[],System.Object@)">
          <source>If this method returns <ph id="ph1">&lt;see langword="false" /&gt;</ph>, the run-time binder of the language determines the behavior.</source>
          <target state="translated">Si este método devuelve <ph id="ph1">&lt;see langword="false" /&gt;</ph>, el enlazador del lenguaje en tiempo de ejecución determina el comportamiento.</target>       </trans-unit>
        <trans-unit id="327" translate="yes" xml:space="preserve" uid="M:System.Dynamic.DynamicObject.TryInvoke(System.Dynamic.InvokeBinder,System.Object[],System.Object@)">
          <source>(In most cases, a language-specific run-time exception is thrown.</source>
          <target state="translated">(En la mayoría de los casos, se inicia una excepción específica del lenguaje en tiempo de ejecución).</target>       </trans-unit>
        <trans-unit id="328" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Dynamic.DynamicObject.TryInvoke(System.Dynamic.InvokeBinder,System.Object[],System.Object@)">
          <source>Classes derived from the <ph id="ph1">&lt;xref:System.Dynamic.DynamicObject&gt;</ph> class can override this method to specify how operations that invoke an object should be performed for a dynamic object.</source>
          <target state="translated">Las clases derivadas de la <ph id="ph1">&lt;xref:System.Dynamic.DynamicObject&gt;</ph> clase puede invalidar este método para especificar cómo se deben realizar las operaciones que invocan un objeto para un objeto dinámico.</target>       </trans-unit>
        <trans-unit id="329" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Dynamic.DynamicObject.TryInvoke(System.Dynamic.InvokeBinder,System.Object[],System.Object@)">
          <source>When the method is not overridden, the run-time binder of the language determines the behavior.</source>
          <target state="translated">Cuando no se reemplaza el método, el enlazador en tiempo de ejecución del lenguaje determina el comportamiento.</target>       </trans-unit>
        <trans-unit id="330" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Dynamic.DynamicObject.TryInvoke(System.Dynamic.InvokeBinder,System.Object[],System.Object@)">
          <source>(In most cases, a run-time exception is thrown.)</source>
          <target state="translated">(En la mayoría de los casos, se inicia una excepción en tiempo de ejecución).</target>       </trans-unit>
        <trans-unit id="331" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Dynamic.DynamicObject.TryInvoke(System.Dynamic.InvokeBinder,System.Object[],System.Object@)">
          <source>If this method is overridden, it is automatically invoked when you have an operation like <ph id="ph1">`sampleObject(100)`</ph>, where <ph id="ph2">`sampleObject`</ph> is derived from the <ph id="ph3">&lt;xref:System.Dynamic.DynamicObject&gt;</ph> class.</source>
          <target state="translated">Si se invalida este método, se invoca automáticamente cuando haya una operación como <ph id="ph1">`sampleObject(100)`</ph>, donde <ph id="ph2">`sampleObject`</ph> se deriva de la <ph id="ph3">&lt;xref:System.Dynamic.DynamicObject&gt;</ph> clase.</target>       </trans-unit>
        <trans-unit id="332" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Dynamic.DynamicObject.TryInvoke(System.Dynamic.InvokeBinder,System.Object[],System.Object@)">
          <source>The operation for invoking an object is supported in C# but not in Visual Basic.</source>
          <target state="translated">La operación para invocar un objeto se admite en C#, pero no en Visual Basic.</target>       </trans-unit>
        <trans-unit id="333" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Dynamic.DynamicObject.TryInvoke(System.Dynamic.InvokeBinder,System.Object[],System.Object@)">
          <source>The Visual Basic compiler never emits code to use this method, and the Visual Basic language does not support syntax like <ph id="ph1">`sampleObject(100)`</ph>.</source>
          <target state="translated">El compilador de Visual Basic nunca emite código para usar este método y el lenguaje Visual Basic no admite una sintaxis como <ph id="ph1">`sampleObject(100)`</ph>.</target>       </trans-unit>
        <trans-unit id="334" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Dynamic.DynamicObject.TryInvoke(System.Dynamic.InvokeBinder,System.Object[],System.Object@)">
          <source>Assume that you need a data structure to store textual and numeric representations of numbers.</source>
          <target state="translated">Suponga que necesita una estructura de datos para almacenar representaciones numéricas y textuales de números.</target>       </trans-unit>
        <trans-unit id="335" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Dynamic.DynamicObject.TryInvoke(System.Dynamic.InvokeBinder,System.Object[],System.Object@)">
          <source>You want to be able to specify the value for each property individually and also to be able to initialize all properties in a single statement.</source>
          <target state="translated">Desea poder especificar el valor para cada propiedad individualmente y poder inicializar todas las propiedades de una única instrucción.</target>       </trans-unit>
        <trans-unit id="336" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Dynamic.DynamicObject.TryInvoke(System.Dynamic.InvokeBinder,System.Object[],System.Object@)">
          <source>The following code example demonstrates the <ph id="ph1">`DynamicNumber`</ph> class, which is derived from the <ph id="ph2">&lt;xref:System.Dynamic.DynamicObject&gt;</ph> class.</source>
          <target state="translated">En el ejemplo de código siguiente se muestra la <ph id="ph1">`DynamicNumber`</ph> (clase), que se deriva de la <ph id="ph2">&lt;xref:System.Dynamic.DynamicObject&gt;</ph> clase.</target>       </trans-unit>
        <trans-unit id="337" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Dynamic.DynamicObject.TryInvoke(System.Dynamic.InvokeBinder,System.Object[],System.Object@)">
          <source><ph id="ph1">`DynamicNumber`</ph> overrides the <ph id="ph2">&lt;xref:System.Dynamic.DynamicObject.TryInvoke%2A&gt;</ph> method to enable initialization of all properties at one time.</source>
          <target state="translated"><ph id="ph1">`DynamicNumber`</ph> invalida el <ph id="ph2">&lt;xref:System.Dynamic.DynamicObject.TryInvoke%2A&gt;</ph> método para habilitar la inicialización de todas las propiedades al mismo tiempo.</target>       </trans-unit>
        <trans-unit id="338" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Dynamic.DynamicObject.TryInvoke(System.Dynamic.InvokeBinder,System.Object[],System.Object@)">
          <source>It also overrides the <ph id="ph1">&lt;xref:System.Dynamic.DynamicObject.TrySetMember%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Dynamic.DynamicObject.TryGetMember%2A&gt;</ph> methods to enable access to individual object properties.</source>
          <target state="translated">También invalida la <ph id="ph1">&lt;xref:System.Dynamic.DynamicObject.TrySetMember%2A&gt;</ph> y <ph id="ph2">&lt;xref:System.Dynamic.DynamicObject.TryGetMember%2A&gt;</ph> métodos para habilitar el acceso a las propiedades de objeto individuales.</target>       </trans-unit>
        <trans-unit id="339" translate="yes" xml:space="preserve" uid="M:System.Dynamic.DynamicObject.TryInvokeMember(System.Dynamic.InvokeMemberBinder,System.Object[],System.Object@)">
          <source>Provides information about the dynamic operation.</source>
          <target state="translated">Proporciona información sobre la operación dinámica.</target>       </trans-unit>
        <trans-unit id="340" translate="yes" xml:space="preserve" uid="M:System.Dynamic.DynamicObject.TryInvokeMember(System.Dynamic.InvokeMemberBinder,System.Object[],System.Object@)">
          <source>The <bpt id="p1">&lt;c&gt;</bpt>binder.Name<ept id="p1">&lt;/c&gt;</ept> property provides the name of the member on which the dynamic operation is performed.</source>
          <target state="translated">La propiedad <bpt id="p1">&lt;c&gt;</bpt>binder.Name<ept id="p1">&lt;/c&gt;</ept> proporciona el nombre del miembro en el que se realiza la operación dinámica.</target>       </trans-unit>
        <trans-unit id="341" translate="yes" xml:space="preserve" uid="M:System.Dynamic.DynamicObject.TryInvokeMember(System.Dynamic.InvokeMemberBinder,System.Object[],System.Object@)">
          <source>For example, for the statement <bpt id="p1">&lt;c&gt;</bpt>sampleObject.SampleMethod(100)<ept id="p1">&lt;/c&gt;</ept>, where <bpt id="p2">&lt;c&gt;</bpt>sampleObject<ept id="p2">&lt;/c&gt;</ept> is an instance of the class derived from the <ph id="ph1">&lt;see cref="T:System.Dynamic.DynamicObject" /&gt;</ph> class, <bpt id="p3">&lt;c&gt;</bpt>binder.Name<ept id="p3">&lt;/c&gt;</ept> returns "SampleMethod".</source>
          <target state="translated">Por ejemplo, para la instrucción <bpt id="p1">&lt;c&gt;</bpt>sampleObject.SampleMethod(100)<ept id="p1">&lt;/c&gt;</ept>, donde <bpt id="p2">&lt;c&gt;</bpt>sampleObject<ept id="p2">&lt;/c&gt;</ept> es una instancia de la clase derivada de la clase <ph id="ph1">&lt;see cref="T:System.Dynamic.DynamicObject" /&gt;</ph>, <bpt id="p3">&lt;c&gt;</bpt>binder.Name<ept id="p3">&lt;/c&gt;</ept> devuelve "SampleMethod".</target>       </trans-unit>
        <trans-unit id="342" translate="yes" xml:space="preserve" uid="M:System.Dynamic.DynamicObject.TryInvokeMember(System.Dynamic.InvokeMemberBinder,System.Object[],System.Object@)">
          <source>The <bpt id="p1">&lt;c&gt;</bpt>binder.IgnoreCase<ept id="p1">&lt;/c&gt;</ept> property specifies whether the member name is case-sensitive.</source>
          <target state="translated">La propiedad <bpt id="p1">&lt;c&gt;</bpt>binder.IgnoreCase<ept id="p1">&lt;/c&gt;</ept> especifica si el nombre de miembro distingue mayúsculas de minúsculas.</target>       </trans-unit>
        <trans-unit id="343" translate="yes" xml:space="preserve" uid="M:System.Dynamic.DynamicObject.TryInvokeMember(System.Dynamic.InvokeMemberBinder,System.Object[],System.Object@)">
          <source>The arguments that are passed to the object member during the invoke operation.</source>
          <target state="translated">Argumentos que se pasan al miembro de objeto durante la operación de invocación.</target>       </trans-unit>
        <trans-unit id="344" translate="yes" xml:space="preserve" uid="M:System.Dynamic.DynamicObject.TryInvokeMember(System.Dynamic.InvokeMemberBinder,System.Object[],System.Object@)">
          <source>For example, for the statement <bpt id="p1">&lt;c&gt;</bpt>sampleObject.SampleMethod(100)<ept id="p1">&lt;/c&gt;</ept>, where <bpt id="p2">&lt;c&gt;</bpt>sampleObject<ept id="p2">&lt;/c&gt;</ept> is derived from the <ph id="ph1">&lt;see cref="T:System.Dynamic.DynamicObject" /&gt;</ph> class, <bpt id="p3">&lt;c&gt;</bpt>args[0]<ept id="p3">&lt;/c&gt;</ept> is equal to 100.</source>
          <target state="translated">Por ejemplo, para la instrucción <bpt id="p1">&lt;c&gt;</bpt>sampleObject.SampleMethod(100)<ept id="p1">&lt;/c&gt;</ept>, donde <bpt id="p2">&lt;c&gt;</bpt>sampleObject<ept id="p2">&lt;/c&gt;</ept> se deriva de la clase <ph id="ph1">&lt;see cref="T:System.Dynamic.DynamicObject" /&gt;</ph>, <bpt id="p3">&lt;c&gt;</bpt>args[0]<ept id="p3">&lt;/c&gt;</ept> es igual que 100.</target>       </trans-unit>
        <trans-unit id="345" translate="yes" xml:space="preserve" uid="M:System.Dynamic.DynamicObject.TryInvokeMember(System.Dynamic.InvokeMemberBinder,System.Object[],System.Object@)">
          <source>The result of the member invocation.</source>
          <target state="translated">Resultado de la invocación del miembro.</target>       </trans-unit>
        <trans-unit id="346" translate="yes" xml:space="preserve" uid="M:System.Dynamic.DynamicObject.TryInvokeMember(System.Dynamic.InvokeMemberBinder,System.Object[],System.Object@)">
          <source>Provides the implementation for operations that invoke a member.</source>
          <target state="translated">Proporciona la implementación de las operaciones que invocan un miembro.</target>       </trans-unit>
        <trans-unit id="347" translate="yes" xml:space="preserve" uid="M:System.Dynamic.DynamicObject.TryInvokeMember(System.Dynamic.InvokeMemberBinder,System.Object[],System.Object@)">
          <source>Classes derived from the <ph id="ph1">&lt;see cref="T:System.Dynamic.DynamicObject" /&gt;</ph> class can override this method to specify dynamic behavior for operations such as calling a method.</source>
          <target state="translated">Las clases derivadas de la clase <ph id="ph1">&lt;see cref="T:System.Dynamic.DynamicObject" /&gt;</ph> pueden invalidar este método para especificar un comportamiento dinámico para operaciones como llamar a un método.</target>       </trans-unit>
        <trans-unit id="348" translate="yes" xml:space="preserve" uid="M:System.Dynamic.DynamicObject.TryInvokeMember(System.Dynamic.InvokeMemberBinder,System.Object[],System.Object@)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the operation is successful; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> si la operación es correcta; de lo contrario, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="349" translate="yes" xml:space="preserve" uid="M:System.Dynamic.DynamicObject.TryInvokeMember(System.Dynamic.InvokeMemberBinder,System.Object[],System.Object@)">
          <source>If this method returns <ph id="ph1">&lt;see langword="false" /&gt;</ph>, the run-time binder of the language determines the behavior.</source>
          <target state="translated">Si este método devuelve <ph id="ph1">&lt;see langword="false" /&gt;</ph>, el enlazador del lenguaje en tiempo de ejecución determina el comportamiento.</target>       </trans-unit>
        <trans-unit id="350" translate="yes" xml:space="preserve" uid="M:System.Dynamic.DynamicObject.TryInvokeMember(System.Dynamic.InvokeMemberBinder,System.Object[],System.Object@)">
          <source>(In most cases, a language-specific run-time exception is thrown.)</source>
          <target state="translated">(En la mayoría de los casos, se inicia una excepción específica del lenguaje en tiempo de ejecución).</target>       </trans-unit>
        <trans-unit id="351" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Dynamic.DynamicObject.TryInvokeMember(System.Dynamic.InvokeMemberBinder,System.Object[],System.Object@)">
          <source>Classes derived from the <ph id="ph1">&lt;xref:System.Dynamic.DynamicObject&gt;</ph> class can override this method to specify how operations that invoke an object member should be performed for a dynamic object.</source>
          <target state="translated">Las clases derivadas de la <ph id="ph1">&lt;xref:System.Dynamic.DynamicObject&gt;</ph> clase puede invalidar este método para especificar cómo se deben realizar las operaciones que invocan un miembro de objeto para un objeto dinámico.</target>       </trans-unit>
        <trans-unit id="352" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Dynamic.DynamicObject.TryInvokeMember(System.Dynamic.InvokeMemberBinder,System.Object[],System.Object@)">
          <source>When the method is not overridden, the run-time binder of the language determines the behavior.</source>
          <target state="translated">Cuando no se reemplaza el método, el enlazador en tiempo de ejecución del lenguaje determina el comportamiento.</target>       </trans-unit>
        <trans-unit id="353" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Dynamic.DynamicObject.TryInvokeMember(System.Dynamic.InvokeMemberBinder,System.Object[],System.Object@)">
          <source>(In most cases, a language-specific run-time exception is thrown.)</source>
          <target state="translated">(En la mayoría de los casos, se inicia una excepción específica del lenguaje en tiempo de ejecución).</target>       </trans-unit>
        <trans-unit id="354" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Dynamic.DynamicObject.TryInvokeMember(System.Dynamic.InvokeMemberBinder,System.Object[],System.Object@)">
          <source>If this method is overridden, it is automatically invoked when you perform an operation like <ph id="ph1">`sampleObject.SampleMethod(100)`</ph>, where <ph id="ph2">`sampleObject`</ph> is derived from the <ph id="ph3">`DynamicObject`</ph> class.</source>
          <target state="translated">Si se invalida este método, se invoca automáticamente cuando se realiza una operación como <ph id="ph1">`sampleObject.SampleMethod(100)`</ph>, donde <ph id="ph2">`sampleObject`</ph> se deriva de la <ph id="ph3">`DynamicObject`</ph> clase.</target>       </trans-unit>
        <trans-unit id="355" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Dynamic.DynamicObject.TryInvokeMember(System.Dynamic.InvokeMemberBinder,System.Object[],System.Object@)">
          <source>You can also add your own methods to classes that are derived from the <ph id="ph1">&lt;xref:System.Dynamic.DynamicObject&gt;</ph> class.</source>
          <target state="translated">También puede agregar sus propios métodos para las clases que se derivan de la <ph id="ph1">&lt;xref:System.Dynamic.DynamicObject&gt;</ph> clase.</target>       </trans-unit>
        <trans-unit id="356" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Dynamic.DynamicObject.TryInvokeMember(System.Dynamic.InvokeMemberBinder,System.Object[],System.Object@)">
          <source>For example, if you override the <ph id="ph1">&lt;xref:System.Dynamic.DynamicObject.TryInvokeMember%2A&gt;</ph> method, the dynamic dispatch system first attempts to determine whether the specified method exists in the class.</source>
          <target state="translated">Por ejemplo, si invalida el <ph id="ph1">&lt;xref:System.Dynamic.DynamicObject.TryInvokeMember%2A&gt;</ph> método, el sistema de distribución dinámica intenta determinar primero si el método especificado existe en la clase.</target>       </trans-unit>
        <trans-unit id="357" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Dynamic.DynamicObject.TryInvokeMember(System.Dynamic.InvokeMemberBinder,System.Object[],System.Object@)">
          <source>If it does not find the method, it uses the <ph id="ph1">&lt;xref:System.Dynamic.DynamicObject.TryInvokeMember%2A&gt;</ph> implementation.</source>
          <target state="translated">Si no se encuentra el método, utiliza el <ph id="ph1">&lt;xref:System.Dynamic.DynamicObject.TryInvokeMember%2A&gt;</ph> implementación.</target>       </trans-unit>
        <trans-unit id="358" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Dynamic.DynamicObject.TryInvokeMember(System.Dynamic.InvokeMemberBinder,System.Object[],System.Object@)">
          <source>This method does not support <ph id="ph1">`ref`</ph> and <ph id="ph2">`out`</ph> parameters.</source>
          <target state="translated">Este método no es compatible con <ph id="ph1">`ref`</ph> y <ph id="ph2">`out`</ph> parámetros.</target>       </trans-unit>
        <trans-unit id="359" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Dynamic.DynamicObject.TryInvokeMember(System.Dynamic.InvokeMemberBinder,System.Object[],System.Object@)">
          <source>All parameters in the <ph id="ph1">`args`</ph> array are passed by value.</source>
          <target state="translated">Todos los parámetros de la <ph id="ph1">`args`</ph> matriz se pasan por valor.</target>       </trans-unit>
        <trans-unit id="360" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Dynamic.DynamicObject.TryInvokeMember(System.Dynamic.InvokeMemberBinder,System.Object[],System.Object@)">
          <source>Assume that you want to provide alternative syntax for accessing values in a dictionary, so that instead of writing <ph id="ph1">`sampleDictionary["Text"] = "Sample text"`</ph> (<ph id="ph2">`sampleDictionary("Text") = "Sample text"`</ph> in Visual Basic), you can write <ph id="ph3">`sampleDictionary.Text = "Sample text"`</ph>.</source>
          <target state="translated">Suponga que desea proporcionar una sintaxis alternativa para tener acceso a valores de dictionary, así que, en lugar de escribir <ph id="ph1">`sampleDictionary["Text"] = "Sample text"`</ph> (<ph id="ph2">`sampleDictionary("Text") = "Sample text"`</ph> en Visual Basic), puede escribir <ph id="ph3">`sampleDictionary.Text = "Sample text"`</ph>.</target>       </trans-unit>
        <trans-unit id="361" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Dynamic.DynamicObject.TryInvokeMember(System.Dynamic.InvokeMemberBinder,System.Object[],System.Object@)">
          <source>Also, you want to be able to call all the standard dictionary methods on this dictionary.</source>
          <target state="translated">Además, desea poder llamar a todos los métodos de diccionario estándar en este diccionario.</target>       </trans-unit>
        <trans-unit id="362" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Dynamic.DynamicObject.TryInvokeMember(System.Dynamic.InvokeMemberBinder,System.Object[],System.Object@)">
          <source>The following code example demonstrates the <ph id="ph1">`DynamicDictionary`</ph> class, which is derived from the <ph id="ph2">&lt;xref:System.Dynamic.DynamicObject&gt;</ph> class.</source>
          <target state="translated">En el ejemplo de código siguiente se muestra la <ph id="ph1">`DynamicDictionary`</ph> (clase), que se deriva de la <ph id="ph2">&lt;xref:System.Dynamic.DynamicObject&gt;</ph> clase.</target>       </trans-unit>
        <trans-unit id="363" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Dynamic.DynamicObject.TryInvokeMember(System.Dynamic.InvokeMemberBinder,System.Object[],System.Object@)">
          <source>The <ph id="ph1">`DynamicDictionary`</ph> class contains an object of the <ph id="ph2">`Dictionary&lt;string, object&gt;`</ph> type (<ph id="ph3">`Dictionary(Of String, Object)`</ph> in Visual Basic) to store the key-value pairs.</source>
          <target state="translated">El <ph id="ph1">`DynamicDictionary`</ph> clase contiene un objeto de la <ph id="ph2">`Dictionary&lt;string, object&gt;`</ph> tipo (<ph id="ph3">`Dictionary(Of String, Object)`</ph> en Visual Basic) para almacenar los pares clave-valor.</target>       </trans-unit>
        <trans-unit id="364" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Dynamic.DynamicObject.TryInvokeMember(System.Dynamic.InvokeMemberBinder,System.Object[],System.Object@)">
          <source>It overrides the <ph id="ph1">&lt;xref:System.Dynamic.DynamicObject.TryInvokeMember%2A&gt;</ph> method to support methods of the <ph id="ph2">&lt;xref:System.Collections.Generic.Dictionary%602&gt;</ph> class and overrides the <ph id="ph3">&lt;xref:System.Dynamic.DynamicObject.TrySetMember%2A&gt;</ph> and <ph id="ph4">&lt;xref:System.Dynamic.DynamicObject.TryGetMember%2A&gt;</ph> methods to support the new syntax.</source>
          <target state="translated">Reemplaza el <ph id="ph1">&lt;xref:System.Dynamic.DynamicObject.TryInvokeMember%2A&gt;</ph> método para admitir los métodos de la <ph id="ph2">&lt;xref:System.Collections.Generic.Dictionary%602&gt;</ph> clase e invalida el <ph id="ph3">&lt;xref:System.Dynamic.DynamicObject.TrySetMember%2A&gt;</ph> y <ph id="ph4">&lt;xref:System.Dynamic.DynamicObject.TryGetMember%2A&gt;</ph> métodos para admitir la nueva sintaxis.</target>       </trans-unit>
        <trans-unit id="365" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Dynamic.DynamicObject.TryInvokeMember(System.Dynamic.InvokeMemberBinder,System.Object[],System.Object@)">
          <source>It also provides a <ph id="ph1">`Print`</ph> method, which prints out all dictionary keys and values.</source>
          <target state="translated">También proporciona un <ph id="ph1">`Print`</ph> método, que imprime todos los valores y claves del diccionario.</target>       </trans-unit>
        <trans-unit id="366" translate="yes" xml:space="preserve" uid="M:System.Dynamic.DynamicObject.TrySetIndex(System.Dynamic.SetIndexBinder,System.Object[],System.Object)">
          <source>Provides information about the operation.</source>
          <target state="translated">Proporciona información sobre la operación.</target>       </trans-unit>
        <trans-unit id="367" translate="yes" xml:space="preserve" uid="M:System.Dynamic.DynamicObject.TrySetIndex(System.Dynamic.SetIndexBinder,System.Object[],System.Object)">
          <source>The indexes that are used in the operation.</source>
          <target state="translated">Índices que se usan en la operación.</target>       </trans-unit>
        <trans-unit id="368" translate="yes" xml:space="preserve" uid="M:System.Dynamic.DynamicObject.TrySetIndex(System.Dynamic.SetIndexBinder,System.Object[],System.Object)">
          <source>For example, for the <bpt id="p1">&lt;c&gt;</bpt>sampleObject[3] = 10<ept id="p1">&lt;/c&gt;</ept> operation in C# (<bpt id="p2">&lt;c&gt;</bpt>sampleObject(3) = 10<ept id="p2">&lt;/c&gt;</ept> in Visual Basic), where <bpt id="p3">&lt;c&gt;</bpt>sampleObject<ept id="p3">&lt;/c&gt;</ept> is derived from the <ph id="ph1">&lt;see cref="T:System.Dynamic.DynamicObject" /&gt;</ph> class, <bpt id="p4">&lt;c&gt;</bpt>indexes[0]<ept id="p4">&lt;/c&gt;</ept> is equal to 3.</source>
          <target state="translated">Por ejemplo, para la operación <bpt id="p1">&lt;c&gt;</bpt>sampleObject[3] = 10<ept id="p1">&lt;/c&gt;</ept> en C# (<bpt id="p2">&lt;c&gt;</bpt>sampleObject(3) = 10<ept id="p2">&lt;/c&gt;</ept> en Visual Basic), donde <bpt id="p3">&lt;c&gt;</bpt>sampleObject<ept id="p3">&lt;/c&gt;</ept> se deriva de la clase <ph id="ph1">&lt;see cref="T:System.Dynamic.DynamicObject" /&gt;</ph>, <bpt id="p4">&lt;c&gt;</bpt>indexes[0]<ept id="p4">&lt;/c&gt;</ept> es igual que 3.</target>       </trans-unit>
        <trans-unit id="369" translate="yes" xml:space="preserve" uid="M:System.Dynamic.DynamicObject.TrySetIndex(System.Dynamic.SetIndexBinder,System.Object[],System.Object)">
          <source>The value to set to the object that has the specified index.</source>
          <target state="translated">Valor que se establece en el objeto que tiene el índice especificado.</target>       </trans-unit>
        <trans-unit id="370" translate="yes" xml:space="preserve" uid="M:System.Dynamic.DynamicObject.TrySetIndex(System.Dynamic.SetIndexBinder,System.Object[],System.Object)">
          <source>For example, for the <bpt id="p1">&lt;c&gt;</bpt>sampleObject[3] = 10<ept id="p1">&lt;/c&gt;</ept> operation in C# (<bpt id="p2">&lt;c&gt;</bpt>sampleObject(3) = 10<ept id="p2">&lt;/c&gt;</ept> in Visual Basic), where <bpt id="p3">&lt;c&gt;</bpt>sampleObject<ept id="p3">&lt;/c&gt;</ept> is derived from the <ph id="ph1">&lt;see cref="T:System.Dynamic.DynamicObject" /&gt;</ph> class, <bpt id="p4">&lt;c&gt;</bpt>value<ept id="p4">&lt;/c&gt;</ept> is equal to 10.</source>
          <target state="translated">Por ejemplo, para la operación <bpt id="p1">&lt;c&gt;</bpt>sampleObject[3] = 10<ept id="p1">&lt;/c&gt;</ept> en C# (<bpt id="p2">&lt;c&gt;</bpt>sampleObject(3) = 10<ept id="p2">&lt;/c&gt;</ept> en Visual Basic), donde <bpt id="p3">&lt;c&gt;</bpt>sampleObject<ept id="p3">&lt;/c&gt;</ept> se deriva de la clase <ph id="ph1">&lt;see cref="T:System.Dynamic.DynamicObject" /&gt;</ph>, <bpt id="p4">&lt;c&gt;</bpt>value<ept id="p4">&lt;/c&gt;</ept> es igual que 10.</target>       </trans-unit>
        <trans-unit id="371" translate="yes" xml:space="preserve" uid="M:System.Dynamic.DynamicObject.TrySetIndex(System.Dynamic.SetIndexBinder,System.Object[],System.Object)">
          <source>Provides the implementation for operations that set a value by index.</source>
          <target state="translated">Proporciona la implementación de las operaciones que establecen un valor por índice.</target>       </trans-unit>
        <trans-unit id="372" translate="yes" xml:space="preserve" uid="M:System.Dynamic.DynamicObject.TrySetIndex(System.Dynamic.SetIndexBinder,System.Object[],System.Object)">
          <source>Classes derived from the <ph id="ph1">&lt;see cref="T:System.Dynamic.DynamicObject" /&gt;</ph> class can override this method to specify dynamic behavior for operations that access objects by a specified index.</source>
          <target state="translated">Las clases derivadas de la clase <ph id="ph1">&lt;see cref="T:System.Dynamic.DynamicObject" /&gt;</ph> pueden invalidar este método para especificar el comportamiento dinámico de las operaciones que tienen acceso a los objetos por un índice especificado.</target>       </trans-unit>
        <trans-unit id="373" translate="yes" xml:space="preserve" uid="M:System.Dynamic.DynamicObject.TrySetIndex(System.Dynamic.SetIndexBinder,System.Object[],System.Object)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the operation is successful; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> si la operación es correcta; de lo contrario, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="374" translate="yes" xml:space="preserve" uid="M:System.Dynamic.DynamicObject.TrySetIndex(System.Dynamic.SetIndexBinder,System.Object[],System.Object)">
          <source>If this method returns <ph id="ph1">&lt;see langword="false" /&gt;</ph>, the run-time binder of the language determines the behavior.</source>
          <target state="translated">Si este método devuelve <ph id="ph1">&lt;see langword="false" /&gt;</ph>, el enlazador del lenguaje en tiempo de ejecución determina el comportamiento.</target>       </trans-unit>
        <trans-unit id="375" translate="yes" xml:space="preserve" uid="M:System.Dynamic.DynamicObject.TrySetIndex(System.Dynamic.SetIndexBinder,System.Object[],System.Object)">
          <source>(In most cases, a language-specific run-time exception is thrown.</source>
          <target state="translated">(En la mayoría de los casos, se inicia una excepción específica del lenguaje en tiempo de ejecución).</target>       </trans-unit>
        <trans-unit id="376" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Dynamic.DynamicObject.TrySetIndex(System.Dynamic.SetIndexBinder,System.Object[],System.Object)">
          <source>Classes derived from the <ph id="ph1">&lt;xref:System.Dynamic.DynamicObject&gt;</ph> class can override this method to specify how operations that access an object by index should be performed for a dynamic object.</source>
          <target state="translated">Las clases derivadas de la <ph id="ph1">&lt;xref:System.Dynamic.DynamicObject&gt;</ph> clase puede invalidar este método para especificar cómo se deben realizar las operaciones que tienen acceso a un objeto por índice para un objeto dinámico.</target>       </trans-unit>
        <trans-unit id="377" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Dynamic.DynamicObject.TrySetIndex(System.Dynamic.SetIndexBinder,System.Object[],System.Object)">
          <source>When the method is not overridden, the run-time binder of the language determines the behavior.</source>
          <target state="translated">Cuando no se reemplaza el método, el enlazador en tiempo de ejecución del lenguaje determina el comportamiento.</target>       </trans-unit>
        <trans-unit id="378" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Dynamic.DynamicObject.TrySetIndex(System.Dynamic.SetIndexBinder,System.Object[],System.Object)">
          <source>(In most cases, a language-specific run-time exception is thrown.)</source>
          <target state="translated">(En la mayoría de los casos, se inicia una excepción específica del lenguaje en tiempo de ejecución).</target>       </trans-unit>
        <trans-unit id="379" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Dynamic.DynamicObject.TrySetIndex(System.Dynamic.SetIndexBinder,System.Object[],System.Object)">
          <source>If this method is overridden, it is automatically invoked when you have an operation like <ph id="ph1">`sampleObject[3] = 10`</ph> in C# or <ph id="ph2">`sampleObject(3) = 10`</ph> in Visual Basic, where <ph id="ph3">`sampleObject`</ph> is derived from the <ph id="ph4">&lt;xref:System.Dynamic.DynamicObject&gt;</ph> class.</source>
          <target state="translated">Si se invalida este método, se invoca automáticamente cuando haya una operación como <ph id="ph1">`sampleObject[3] = 10`</ph> en C# o <ph id="ph2">`sampleObject(3) = 10`</ph> en Visual Basic, donde <ph id="ph3">`sampleObject`</ph> se deriva de la <ph id="ph4">&lt;xref:System.Dynamic.DynamicObject&gt;</ph> clase.</target>       </trans-unit>
        <trans-unit id="380" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Dynamic.DynamicObject.TrySetIndex(System.Dynamic.SetIndexBinder,System.Object[],System.Object)">
          <source>Assume that you want to create an object in which properties can be accessed either by names such as <ph id="ph1">`Property0`</ph>, <ph id="ph2">`Property1`</ph>, and so on, or by index, so that, for example, <ph id="ph3">`sampleObject.Property0`</ph> is equivalent to <ph id="ph4">`sampleObject[0]`</ph> in C# or <ph id="ph5">`sampleObject(0)`</ph> in Visual Basic.</source>
          <target state="translated">Suponga que desea crear un objeto en el que las propiedades pueden ser acceso mediante nombres como <ph id="ph1">`Property0`</ph>, <ph id="ph2">`Property1`</ph>, y así sucesivamente, o por índice, por lo que, por ejemplo, <ph id="ph3">`sampleObject.Property0`</ph> es equivalente a <ph id="ph4">`sampleObject[0]`</ph> en C# o <ph id="ph5">`sampleObject(0)`</ph> en Visual Basic.</target>       </trans-unit>
        <trans-unit id="381" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Dynamic.DynamicObject.TrySetIndex(System.Dynamic.SetIndexBinder,System.Object[],System.Object)">
          <source>The following code example demonstrates the <ph id="ph1">`SampleDynamicObject`</ph> class, which is derived from the <ph id="ph2">&lt;xref:System.Dynamic.DynamicObject&gt;</ph> class.</source>
          <target state="translated">En el ejemplo de código siguiente se muestra la <ph id="ph1">`SampleDynamicObject`</ph> (clase), que se deriva de la <ph id="ph2">&lt;xref:System.Dynamic.DynamicObject&gt;</ph> clase.</target>       </trans-unit>
        <trans-unit id="382" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Dynamic.DynamicObject.TrySetIndex(System.Dynamic.SetIndexBinder,System.Object[],System.Object)">
          <source>The <ph id="ph1">`SampleDynamicObject`</ph> class contains an object of the <ph id="ph2">`Dictionary&lt;string, object&gt;`</ph> type (<ph id="ph3">`Dictionary(Of String, Object)`</ph> in Visual Basic) to store the key-value pairs.</source>
          <target state="translated">El <ph id="ph1">`SampleDynamicObject`</ph> clase contiene un objeto de la <ph id="ph2">`Dictionary&lt;string, object&gt;`</ph> tipo (<ph id="ph3">`Dictionary(Of String, Object)`</ph> en Visual Basic) para almacenar los pares clave-valor.</target>       </trans-unit>
        <trans-unit id="383" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Dynamic.DynamicObject.TrySetIndex(System.Dynamic.SetIndexBinder,System.Object[],System.Object)">
          <source><ph id="ph1">`SampleDynamicObject`</ph> overrides the <ph id="ph2">&lt;xref:System.Dynamic.DynamicObject.TrySetIndex%2A&gt;</ph> and <ph id="ph3">&lt;xref:System.Dynamic.DynamicObject.TryGetIndex%2A&gt;</ph> methods to enable access by index.</source>
          <target state="translated"><ph id="ph1">`SampleDynamicObject`</ph> invalida el <ph id="ph2">&lt;xref:System.Dynamic.DynamicObject.TrySetIndex%2A&gt;</ph> y <ph id="ph3">&lt;xref:System.Dynamic.DynamicObject.TryGetIndex%2A&gt;</ph> métodos para habilitar el acceso por índice.</target>       </trans-unit>
        <trans-unit id="384" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Dynamic.DynamicObject.TrySetIndex(System.Dynamic.SetIndexBinder,System.Object[],System.Object)">
          <source>It overrides the <ph id="ph1">&lt;xref:System.Dynamic.DynamicObject.TrySetMember%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Dynamic.DynamicObject.TryGetMember%2A&gt;</ph> methods to enable access by property name.</source>
          <target state="translated">Reemplaza el <ph id="ph1">&lt;xref:System.Dynamic.DynamicObject.TrySetMember%2A&gt;</ph> y <ph id="ph2">&lt;xref:System.Dynamic.DynamicObject.TryGetMember%2A&gt;</ph> métodos para habilitar el acceso por nombre de propiedad.</target>       </trans-unit>
        <trans-unit id="385" translate="yes" xml:space="preserve" uid="M:System.Dynamic.DynamicObject.TrySetMember(System.Dynamic.SetMemberBinder,System.Object)">
          <source>Provides information about the object that called the dynamic operation.</source>
          <target state="translated">Proporciona información sobre el objeto que llamó a la operación dinámica.</target>       </trans-unit>
        <trans-unit id="386" translate="yes" xml:space="preserve" uid="M:System.Dynamic.DynamicObject.TrySetMember(System.Dynamic.SetMemberBinder,System.Object)">
          <source>The <bpt id="p1">&lt;c&gt;</bpt>binder.Name<ept id="p1">&lt;/c&gt;</ept> property provides the name of the member to which the value is being assigned.</source>
          <target state="translated">La propiedad <bpt id="p1">&lt;c&gt;</bpt>binder.Name<ept id="p1">&lt;/c&gt;</ept> proporciona el nombre del miembro al que se asigna el valor.</target>       </trans-unit>
        <trans-unit id="387" translate="yes" xml:space="preserve" uid="M:System.Dynamic.DynamicObject.TrySetMember(System.Dynamic.SetMemberBinder,System.Object)">
          <source>For example, for the statement <bpt id="p1">&lt;c&gt;</bpt>sampleObject.SampleProperty = "Test"<ept id="p1">&lt;/c&gt;</ept>, where <bpt id="p2">&lt;c&gt;</bpt>sampleObject<ept id="p2">&lt;/c&gt;</ept> is an instance of the class derived from the <ph id="ph1">&lt;see cref="T:System.Dynamic.DynamicObject" /&gt;</ph> class, <bpt id="p3">&lt;c&gt;</bpt>binder.Name<ept id="p3">&lt;/c&gt;</ept> returns "SampleProperty".</source>
          <target state="translated">Por ejemplo, para la instrucción <bpt id="p1">&lt;c&gt;</bpt>sampleObject.SampleProperty = "Test"<ept id="p1">&lt;/c&gt;</ept>, donde <bpt id="p2">&lt;c&gt;</bpt>sampleObject<ept id="p2">&lt;/c&gt;</ept> es una instancia de la clase derivada de la clase <ph id="ph1">&lt;see cref="T:System.Dynamic.DynamicObject" /&gt;</ph>, <bpt id="p3">&lt;c&gt;</bpt>binder.Name<ept id="p3">&lt;/c&gt;</ept> devuelve "SampleProperty".</target>       </trans-unit>
        <trans-unit id="388" translate="yes" xml:space="preserve" uid="M:System.Dynamic.DynamicObject.TrySetMember(System.Dynamic.SetMemberBinder,System.Object)">
          <source>The <bpt id="p1">&lt;c&gt;</bpt>binder.IgnoreCase<ept id="p1">&lt;/c&gt;</ept> property specifies whether the member name is case-sensitive.</source>
          <target state="translated">La propiedad <bpt id="p1">&lt;c&gt;</bpt>binder.IgnoreCase<ept id="p1">&lt;/c&gt;</ept> especifica si el nombre de miembro distingue mayúsculas de minúsculas.</target>       </trans-unit>
        <trans-unit id="389" translate="yes" xml:space="preserve" uid="M:System.Dynamic.DynamicObject.TrySetMember(System.Dynamic.SetMemberBinder,System.Object)">
          <source>The value to set to the member.</source>
          <target state="translated">Valor que se va a establecer para el miembro.</target>       </trans-unit>
        <trans-unit id="390" translate="yes" xml:space="preserve" uid="M:System.Dynamic.DynamicObject.TrySetMember(System.Dynamic.SetMemberBinder,System.Object)">
          <source>For example, for <bpt id="p1">&lt;c&gt;</bpt>sampleObject.SampleProperty = "Test"<ept id="p1">&lt;/c&gt;</ept>, where <bpt id="p2">&lt;c&gt;</bpt>sampleObject<ept id="p2">&lt;/c&gt;</ept> is an instance of the class derived from the <ph id="ph1">&lt;see cref="T:System.Dynamic.DynamicObject" /&gt;</ph> class, the <bpt id="p3">&lt;c&gt;</bpt>value<ept id="p3">&lt;/c&gt;</ept> is "Test".</source>
          <target state="translated">Por ejemplo, para <bpt id="p1">&lt;c&gt;</bpt>sampleObject.SampleProperty = "Test"<ept id="p1">&lt;/c&gt;</ept>, donde <bpt id="p2">&lt;c&gt;</bpt>sampleObject<ept id="p2">&lt;/c&gt;</ept> es una instancia de la clase derivada de la clase <ph id="ph1">&lt;see cref="T:System.Dynamic.DynamicObject" /&gt;</ph>, <bpt id="p3">&lt;c&gt;</bpt>value<ept id="p3">&lt;/c&gt;</ept> es "Test".</target>       </trans-unit>
        <trans-unit id="391" translate="yes" xml:space="preserve" uid="M:System.Dynamic.DynamicObject.TrySetMember(System.Dynamic.SetMemberBinder,System.Object)">
          <source>Provides the implementation for operations that set member values.</source>
          <target state="translated">Proporciona la implementación de las operaciones que establecen valores de miembro.</target>       </trans-unit>
        <trans-unit id="392" translate="yes" xml:space="preserve" uid="M:System.Dynamic.DynamicObject.TrySetMember(System.Dynamic.SetMemberBinder,System.Object)">
          <source>Classes derived from the <ph id="ph1">&lt;see cref="T:System.Dynamic.DynamicObject" /&gt;</ph> class can override this method to specify dynamic behavior for operations such as setting a value for a property.</source>
          <target state="translated">Las clases derivadas de la clase <ph id="ph1">&lt;see cref="T:System.Dynamic.DynamicObject" /&gt;</ph> pueden invalidar este método para especificar un comportamiento dinámico para operaciones como establecer el valor de una propiedad.</target>       </trans-unit>
        <trans-unit id="393" translate="yes" xml:space="preserve" uid="M:System.Dynamic.DynamicObject.TrySetMember(System.Dynamic.SetMemberBinder,System.Object)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the operation is successful; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> si la operación es correcta; de lo contrario, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="394" translate="yes" xml:space="preserve" uid="M:System.Dynamic.DynamicObject.TrySetMember(System.Dynamic.SetMemberBinder,System.Object)">
          <source>If this method returns <ph id="ph1">&lt;see langword="false" /&gt;</ph>, the run-time binder of the language determines the behavior.</source>
          <target state="translated">Si este método devuelve <ph id="ph1">&lt;see langword="false" /&gt;</ph>, el enlazador del lenguaje en tiempo de ejecución determina el comportamiento.</target>       </trans-unit>
        <trans-unit id="395" translate="yes" xml:space="preserve" uid="M:System.Dynamic.DynamicObject.TrySetMember(System.Dynamic.SetMemberBinder,System.Object)">
          <source>(In most cases, a language-specific run-time exception is thrown.)</source>
          <target state="translated">(En la mayoría de los casos, se inicia una excepción específica del lenguaje en tiempo de ejecución).</target>       </trans-unit>
        <trans-unit id="396" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Dynamic.DynamicObject.TrySetMember(System.Dynamic.SetMemberBinder,System.Object)">
          <source>Classes derived from the <ph id="ph1">&lt;xref:System.Dynamic.DynamicObject&gt;</ph> class can override this method to specify how operations that set a value to a member should be performed for a dynamic object.</source>
          <target state="translated">Las clases derivadas de la <ph id="ph1">&lt;xref:System.Dynamic.DynamicObject&gt;</ph> clase puede invalidar este método para especificar cómo se deben realizar las operaciones que establecen un valor a un miembro para un objeto dinámico.</target>       </trans-unit>
        <trans-unit id="397" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Dynamic.DynamicObject.TrySetMember(System.Dynamic.SetMemberBinder,System.Object)">
          <source>When the method is not overridden, the run-time binder of the language determines the behavior.</source>
          <target state="translated">Cuando no se reemplaza el método, el enlazador en tiempo de ejecución del lenguaje determina el comportamiento.</target>       </trans-unit>
        <trans-unit id="398" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Dynamic.DynamicObject.TrySetMember(System.Dynamic.SetMemberBinder,System.Object)">
          <source>(In most cases, a language-specific run-time exception is thrown.)</source>
          <target state="translated">(En la mayoría de los casos, se inicia una excepción específica del lenguaje en tiempo de ejecución).</target>       </trans-unit>
        <trans-unit id="399" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Dynamic.DynamicObject.TrySetMember(System.Dynamic.SetMemberBinder,System.Object)">
          <source>This method is called when you have statements like <ph id="ph1">`sampleObject.SampleProperty = "Test"`</ph>, where <ph id="ph2">`sampleObject`</ph> is an instance of the class that is derived from the <ph id="ph3">&lt;xref:System.Dynamic.DynamicObject&gt;</ph> class.</source>
          <target state="translated">Se llama a este método si tiene instrucciones como <ph id="ph1">`sampleObject.SampleProperty = "Test"`</ph>, donde <ph id="ph2">`sampleObject`</ph> es una instancia de la clase que se deriva de la <ph id="ph3">&lt;xref:System.Dynamic.DynamicObject&gt;</ph> clase.</target>       </trans-unit>
        <trans-unit id="400" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Dynamic.DynamicObject.TrySetMember(System.Dynamic.SetMemberBinder,System.Object)">
          <source>You can also add your own members to classes derived from the <ph id="ph1">`DynamicObject`</ph> class.</source>
          <target state="translated">También puede agregar sus propios miembros a clases derivadas de la <ph id="ph1">`DynamicObject`</ph> clase.</target>       </trans-unit>
        <trans-unit id="401" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Dynamic.DynamicObject.TrySetMember(System.Dynamic.SetMemberBinder,System.Object)">
          <source>If your class defines properties and also overrides the <ph id="ph1">&lt;xref:System.Dynamic.DynamicObject.TrySetMember%2A&gt;</ph> method, the dynamic language runtime (DLR) first uses the language binder to look for a static definition of a property in the class.</source>
          <target state="translated">Si su clase define propiedades y también invalida la <ph id="ph1">&lt;xref:System.Dynamic.DynamicObject.TrySetMember%2A&gt;</ph> método, dynamic language runtime (DLR) usa primero el enlazador del lenguaje para buscar una definición estática de una propiedad en la clase.</target>       </trans-unit>
        <trans-unit id="402" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Dynamic.DynamicObject.TrySetMember(System.Dynamic.SetMemberBinder,System.Object)">
          <source>If there is no such property, the DLR calls the <ph id="ph1">&lt;xref:System.Dynamic.DynamicObject.TrySetMember%2A&gt;</ph> method.</source>
          <target state="translated">Si no hay ninguna propiedad de este tipo, DLR llama el <ph id="ph1">&lt;xref:System.Dynamic.DynamicObject.TrySetMember%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="403" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Dynamic.DynamicObject.TrySetMember(System.Dynamic.SetMemberBinder,System.Object)">
          <source>Assume that you want to provide alternative syntax for accessing values in a dictionary, so that instead of writing <ph id="ph1">`sampleDictionary["Text"] = "Sample text"`</ph> (<ph id="ph2">`sampleDictionary("Text") = "Sample text"`</ph> in Visual Basic), you can write <ph id="ph3">`sampleDictionary.Text = "Sample text"`</ph>.</source>
          <target state="translated">Suponga que desea proporcionar una sintaxis alternativa para tener acceso a valores de dictionary, así que, en lugar de escribir <ph id="ph1">`sampleDictionary["Text"] = "Sample text"`</ph> (<ph id="ph2">`sampleDictionary("Text") = "Sample text"`</ph> en Visual Basic), puede escribir <ph id="ph3">`sampleDictionary.Text = "Sample text"`</ph>.</target>       </trans-unit>
        <trans-unit id="404" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Dynamic.DynamicObject.TrySetMember(System.Dynamic.SetMemberBinder,System.Object)">
          <source>Also, this syntax must be case-insensitive, so that <ph id="ph1">`sampleDictionary.Text`</ph> is equivalent to <ph id="ph2">`sampleDictionary.text`</ph>.</source>
          <target state="translated">Además, esta sintaxis debe distinguir mayúsculas de minúsculas, por lo que <ph id="ph1">`sampleDictionary.Text`</ph> es equivalente a <ph id="ph2">`sampleDictionary.text`</ph>.</target>       </trans-unit>
        <trans-unit id="405" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Dynamic.DynamicObject.TrySetMember(System.Dynamic.SetMemberBinder,System.Object)">
          <source>The following code example demonstrates the <ph id="ph1">`DynamicDictionary`</ph> class, which is derived from the <ph id="ph2">&lt;xref:System.Dynamic.DynamicObject&gt;</ph> class.</source>
          <target state="translated">En el ejemplo de código siguiente se muestra la <ph id="ph1">`DynamicDictionary`</ph> (clase), que se deriva de la <ph id="ph2">&lt;xref:System.Dynamic.DynamicObject&gt;</ph> clase.</target>       </trans-unit>
        <trans-unit id="406" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Dynamic.DynamicObject.TrySetMember(System.Dynamic.SetMemberBinder,System.Object)">
          <source>The <ph id="ph1">`DynamicDictionary`</ph> class contains an object of the <ph id="ph2">`Dictionary&lt;string, object&gt;`</ph> type (<ph id="ph3">`Dictionary(Of String, Object)`</ph> in Visual Basic) to store the key-value pairs, and overrides the <ph id="ph4">&lt;xref:System.Dynamic.DynamicObject.TrySetMember%2A&gt;</ph> and <ph id="ph5">&lt;xref:System.Dynamic.DynamicObject.TryGetMember%2A&gt;</ph> methods to support the new syntax.</source>
          <target state="translated">El <ph id="ph1">`DynamicDictionary`</ph> clase contiene un objeto de la <ph id="ph2">`Dictionary&lt;string, object&gt;`</ph> tipo (<ph id="ph3">`Dictionary(Of String, Object)`</ph> en Visual Basic) para almacenar los pares clave-valor e invalida el <ph id="ph4">&lt;xref:System.Dynamic.DynamicObject.TrySetMember%2A&gt;</ph> y <ph id="ph5">&lt;xref:System.Dynamic.DynamicObject.TryGetMember%2A&gt;</ph> métodos para admitir la nueva sintaxis.</target>       </trans-unit>
        <trans-unit id="407" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Dynamic.DynamicObject.TrySetMember(System.Dynamic.SetMemberBinder,System.Object)">
          <source>It also provides a <ph id="ph1">`Count`</ph> property, which shows how many dynamic properties the dictionary contains.</source>
          <target state="translated">También proporciona un <ph id="ph1">`Count`</ph> contiene la propiedad, que muestra el número de propiedades dinámicas en el diccionario.</target>       </trans-unit>
        <trans-unit id="408" translate="yes" xml:space="preserve" uid="M:System.Dynamic.DynamicObject.TryUnaryOperation(System.Dynamic.UnaryOperationBinder,System.Object@)">
          <source>Provides information about the unary operation.</source>
          <target state="translated">Proporciona información sobre la operación unaria.</target>       </trans-unit>
        <trans-unit id="409" translate="yes" xml:space="preserve" uid="M:System.Dynamic.DynamicObject.TryUnaryOperation(System.Dynamic.UnaryOperationBinder,System.Object@)">
          <source>The <bpt id="p1">&lt;c&gt;</bpt>binder.Operation<ept id="p1">&lt;/c&gt;</ept> property returns an <ph id="ph1">&lt;see cref="T:System.Linq.Expressions.ExpressionType" /&gt;</ph> object.</source>
          <target state="translated">La propiedad <bpt id="p1">&lt;c&gt;</bpt>binder.Operation<ept id="p1">&lt;/c&gt;</ept> devuelve un objeto <ph id="ph1">&lt;see cref="T:System.Linq.Expressions.ExpressionType" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="410" translate="yes" xml:space="preserve" uid="M:System.Dynamic.DynamicObject.TryUnaryOperation(System.Dynamic.UnaryOperationBinder,System.Object@)">
          <source>For example, for the <bpt id="p1">&lt;c&gt;</bpt>negativeNumber = -number<ept id="p1">&lt;/c&gt;</ept> statement, where <bpt id="p2">&lt;c&gt;</bpt>number<ept id="p2">&lt;/c&gt;</ept> is derived from the <ph id="ph1">&lt;see langword="DynamicObject" /&gt;</ph> class, <bpt id="p3">&lt;c&gt;</bpt>binder.Operation<ept id="p3">&lt;/c&gt;</ept> returns "Negate".</source>
          <target state="translated">Por ejemplo, para la instrucción <bpt id="p1">&lt;c&gt;</bpt>negativeNumber = -number<ept id="p1">&lt;/c&gt;</ept>, donde <bpt id="p2">&lt;c&gt;</bpt>number<ept id="p2">&lt;/c&gt;</ept> se deriva de la clase <ph id="ph1">&lt;see langword="DynamicObject" /&gt;</ph>, <bpt id="p3">&lt;c&gt;</bpt>binder.Operation<ept id="p3">&lt;/c&gt;</ept> devuelve "Negate".</target>       </trans-unit>
        <trans-unit id="411" translate="yes" xml:space="preserve" uid="M:System.Dynamic.DynamicObject.TryUnaryOperation(System.Dynamic.UnaryOperationBinder,System.Object@)">
          <source>The result of the unary operation.</source>
          <target state="translated">Resultado de la operación unaria.</target>       </trans-unit>
        <trans-unit id="412" translate="yes" xml:space="preserve" uid="M:System.Dynamic.DynamicObject.TryUnaryOperation(System.Dynamic.UnaryOperationBinder,System.Object@)">
          <source>Provides implementation for unary operations.</source>
          <target state="translated">Proporciona la implementación de operaciones unarias.</target>       </trans-unit>
        <trans-unit id="413" translate="yes" xml:space="preserve" uid="M:System.Dynamic.DynamicObject.TryUnaryOperation(System.Dynamic.UnaryOperationBinder,System.Object@)">
          <source>Classes derived from the <ph id="ph1">&lt;see cref="T:System.Dynamic.DynamicObject" /&gt;</ph> class can override this method to specify dynamic behavior for operations such as negation, increment, or decrement.</source>
          <target state="translated">Las clases derivadas de la clase <ph id="ph1">&lt;see cref="T:System.Dynamic.DynamicObject" /&gt;</ph> pueden invalidar este método para especificar el comportamiento dinámico de operaciones como negación, incremento o decremento.</target>       </trans-unit>
        <trans-unit id="414" translate="yes" xml:space="preserve" uid="M:System.Dynamic.DynamicObject.TryUnaryOperation(System.Dynamic.UnaryOperationBinder,System.Object@)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the operation is successful; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> si la operación es correcta; de lo contrario, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="415" translate="yes" xml:space="preserve" uid="M:System.Dynamic.DynamicObject.TryUnaryOperation(System.Dynamic.UnaryOperationBinder,System.Object@)">
          <source>If this method returns <ph id="ph1">&lt;see langword="false" /&gt;</ph>, the run-time binder of the language determines the behavior.</source>
          <target state="translated">Si este método devuelve <ph id="ph1">&lt;see langword="false" /&gt;</ph>, el enlazador del lenguaje en tiempo de ejecución determina el comportamiento.</target>       </trans-unit>
        <trans-unit id="416" translate="yes" xml:space="preserve" uid="M:System.Dynamic.DynamicObject.TryUnaryOperation(System.Dynamic.UnaryOperationBinder,System.Object@)">
          <source>(In most cases, a language-specific run-time exception is thrown.)</source>
          <target state="translated">(En la mayoría de los casos, se inicia una excepción específica del lenguaje en tiempo de ejecución).</target>       </trans-unit>
        <trans-unit id="417" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Dynamic.DynamicObject.TryUnaryOperation(System.Dynamic.UnaryOperationBinder,System.Object@)">
          <source>Classes derived from the <ph id="ph1">&lt;xref:System.Dynamic.DynamicObject&gt;</ph> class can override this method to specify how unary operations should be performed for a dynamic object.</source>
          <target state="translated">Las clases derivadas de la <ph id="ph1">&lt;xref:System.Dynamic.DynamicObject&gt;</ph> clase puede invalidar este método para especificar cómo se deben realizar operaciones unarias para un objeto dinámico.</target>       </trans-unit>
        <trans-unit id="418" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Dynamic.DynamicObject.TryUnaryOperation(System.Dynamic.UnaryOperationBinder,System.Object@)">
          <source>When the method is not overridden, the run-time binder of the language determines the behavior.</source>
          <target state="translated">Cuando no se reemplaza el método, el enlazador en tiempo de ejecución del lenguaje determina el comportamiento.</target>       </trans-unit>
        <trans-unit id="419" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Dynamic.DynamicObject.TryUnaryOperation(System.Dynamic.UnaryOperationBinder,System.Object@)">
          <source>(In most cases, a language-specific run-time exception is thrown.)</source>
          <target state="translated">(En la mayoría de los casos, se inicia una excepción específica del lenguaje en tiempo de ejecución).</target>       </trans-unit>
        <trans-unit id="420" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Dynamic.DynamicObject.TryUnaryOperation(System.Dynamic.UnaryOperationBinder,System.Object@)">
          <source>This method is called when you have unary operations such as negation, increment, or decrement.</source>
          <target state="translated">Se llama a este método cuando tiene operaciones unarias como la negación, incremento o decremento.</target>       </trans-unit>
        <trans-unit id="421" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Dynamic.DynamicObject.TryUnaryOperation(System.Dynamic.UnaryOperationBinder,System.Object@)">
          <source>For example, if the <ph id="ph1">&lt;xref:System.Dynamic.DynamicObject.TryUnaryOperation%2A&gt;</ph> method is overridden, this method is automatically invoked for statements like <ph id="ph2">`negativeNumber = -number`</ph>, where <ph id="ph3">`number`</ph> is derived from the <ph id="ph4">&lt;xref:System.Dynamic.DynamicObject&gt;</ph> class.</source>
          <target state="translated">Por ejemplo, si la <ph id="ph1">&lt;xref:System.Dynamic.DynamicObject.TryUnaryOperation%2A&gt;</ph> método se invalida, este método se invoca automáticamente para instrucciones como <ph id="ph2">`negativeNumber = -number`</ph>, donde <ph id="ph3">`number`</ph> se deriva de la <ph id="ph4">&lt;xref:System.Dynamic.DynamicObject&gt;</ph> clase.</target>       </trans-unit>
        <trans-unit id="422" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Dynamic.DynamicObject.TryUnaryOperation(System.Dynamic.UnaryOperationBinder,System.Object@)">
          <source>You can get information about the type of the unary operation by using the <ph id="ph1">`Operation`</ph> property of the <ph id="ph2">`binder`</ph> parameter.</source>
          <target state="translated">Puede obtener información sobre el tipo de la operación unaria mediante la <ph id="ph1">`Operation`</ph> propiedad de la <ph id="ph2">`binder`</ph> parámetro.</target>       </trans-unit>
        <trans-unit id="423" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Dynamic.DynamicObject.TryUnaryOperation(System.Dynamic.UnaryOperationBinder,System.Object@)">
          <source>If your dynamic object is used only in C# and Visual Basic, the <ph id="ph1">`binder.Operation`</ph> property can have one of the following values from the <ph id="ph2">&lt;xref:System.Linq.Expressions.ExpressionType&gt;</ph> enumeration.</source>
          <target state="translated">Si el objeto dinámico solo se usa en C# y Visual Basic, la <ph id="ph1">`binder.Operation`</ph> propiedad puede tener uno de los siguientes valores de la <ph id="ph2">&lt;xref:System.Linq.Expressions.ExpressionType&gt;</ph> enumeración.</target>       </trans-unit>
        <trans-unit id="424" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Dynamic.DynamicObject.TryUnaryOperation(System.Dynamic.UnaryOperationBinder,System.Object@)">
          <source>However, in other languages such as IronPython or IronRuby, you can have other values.</source>
          <target state="translated">Sin embargo, en otros lenguajes como IronPython o IronRuby, puede tener otros valores.</target>       </trans-unit>
        <trans-unit id="425" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Dynamic.DynamicObject.TryUnaryOperation(System.Dynamic.UnaryOperationBinder,System.Object@)">
          <source>Value</source>
          <target state="translated">Valor</target>       </trans-unit>
        <trans-unit id="426" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Dynamic.DynamicObject.TryUnaryOperation(System.Dynamic.UnaryOperationBinder,System.Object@)">
          <source>Description</source>
          <target state="translated">Descripción</target>       </trans-unit>
        <trans-unit id="427" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Dynamic.DynamicObject.TryUnaryOperation(System.Dynamic.UnaryOperationBinder,System.Object@)">
          <source>C#</source>
          <target state="translated">C#</target>       </trans-unit>
        <trans-unit id="428" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Dynamic.DynamicObject.TryUnaryOperation(System.Dynamic.UnaryOperationBinder,System.Object@)">
          <source>Visual Basic</source>
          <target state="translated">Visual Basic</target>       </trans-unit>
        <trans-unit id="429" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Dynamic.DynamicObject.TryUnaryOperation(System.Dynamic.UnaryOperationBinder,System.Object@)">
          <source>A unary decrement operation.</source>
          <target state="translated">Una operación de decremento unario.</target>       </trans-unit>
        <trans-unit id="430" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Dynamic.DynamicObject.TryUnaryOperation(System.Dynamic.UnaryOperationBinder,System.Object@)">
          <source>Not supported.</source>
          <target state="translated">No se admite.</target>       </trans-unit>
        <trans-unit id="431" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Dynamic.DynamicObject.TryUnaryOperation(System.Dynamic.UnaryOperationBinder,System.Object@)">
          <source>A unary increment operation.</source>
          <target state="translated">Una operación de incremento unario.</target>       </trans-unit>
        <trans-unit id="432" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Dynamic.DynamicObject.TryUnaryOperation(System.Dynamic.UnaryOperationBinder,System.Object@)">
          <source>Not supported.</source>
          <target state="translated">No se admite.</target>       </trans-unit>
        <trans-unit id="433" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Dynamic.DynamicObject.TryUnaryOperation(System.Dynamic.UnaryOperationBinder,System.Object@)">
          <source>An arithmetic negation.</source>
          <target state="translated">Una negación aritmética.</target>       </trans-unit>
        <trans-unit id="434" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Dynamic.DynamicObject.TryUnaryOperation(System.Dynamic.UnaryOperationBinder,System.Object@)">
          <source>A logical negation.</source>
          <target state="translated">Una negación lógica.</target>       </trans-unit>
        <trans-unit id="435" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Dynamic.DynamicObject.TryUnaryOperation(System.Dynamic.UnaryOperationBinder,System.Object@)">
          <source>A ones complement.</source>
          <target state="translated">Una los complemento.</target>       </trans-unit>
        <trans-unit id="436" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Dynamic.DynamicObject.TryUnaryOperation(System.Dynamic.UnaryOperationBinder,System.Object@)">
          <source>Not supported.</source>
          <target state="translated">No se admite.</target>       </trans-unit>
        <trans-unit id="437" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Dynamic.DynamicObject.TryUnaryOperation(System.Dynamic.UnaryOperationBinder,System.Object@)">
          <source>A false condition value.</source>
          <target state="translated">Un valor de condición falsa.</target>       </trans-unit>
        <trans-unit id="438" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Dynamic.DynamicObject.TryUnaryOperation(System.Dynamic.UnaryOperationBinder,System.Object@)">
          <source>Not supported.</source>
          <target state="translated">No se admite.</target>       </trans-unit>
        <trans-unit id="439" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Dynamic.DynamicObject.TryUnaryOperation(System.Dynamic.UnaryOperationBinder,System.Object@)">
          <source>A true condition value.</source>
          <target state="translated">Un valor de la condición es true.</target>       </trans-unit>
        <trans-unit id="440" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Dynamic.DynamicObject.TryUnaryOperation(System.Dynamic.UnaryOperationBinder,System.Object@)">
          <source>Not supported.</source>
          <target state="translated">No se admite.</target>       </trans-unit>
        <trans-unit id="441" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Dynamic.DynamicObject.TryUnaryOperation(System.Dynamic.UnaryOperationBinder,System.Object@)">
          <source>A unary plus.</source>
          <target state="translated">Una suma unaria.</target>       </trans-unit>
        <trans-unit id="442" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Dynamic.DynamicObject.TryUnaryOperation(System.Dynamic.UnaryOperationBinder,System.Object@)">
          <source>To implement <ph id="ph1">`OrElse`</ph> (<ph id="ph2">`a || b`</ph>) and <ph id="ph3">`AndAlso`</ph> (<ph id="ph4">`a &amp;&amp; b`</ph>) operations for dynamic objects in C#, you may want to implement both the <ph id="ph5">&lt;xref:System.Dynamic.DynamicObject.TryUnaryOperation%2A&gt;</ph> method and the <ph id="ph6">&lt;xref:System.Dynamic.DynamicObject.TryBinaryOperation%2A&gt;</ph> method.</source>
          <target state="translated">Para implementar <ph id="ph1">`OrElse`</ph> (<ph id="ph2">`a || b`</ph>) y <ph id="ph3">`AndAlso`</ph> (<ph id="ph4">`a &amp;&amp; b`</ph>) operaciones de objetos dinámicos en C#, puede que desee implementar tanto el <ph id="ph5">&lt;xref:System.Dynamic.DynamicObject.TryUnaryOperation%2A&gt;</ph> (método) y el <ph id="ph6">&lt;xref:System.Dynamic.DynamicObject.TryBinaryOperation%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="443" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Dynamic.DynamicObject.TryUnaryOperation(System.Dynamic.UnaryOperationBinder,System.Object@)">
          <source>The <ph id="ph1">`OrElse`</ph> operation consists of the unary <ph id="ph2">`IsTrue`</ph> operation and the binary <ph id="ph3">`Or`</ph> operation.</source>
          <target state="translated">El <ph id="ph1">`OrElse`</ph> operación está formada por el operador unario <ph id="ph2">`IsTrue`</ph> operación y el archivo binario <ph id="ph3">`Or`</ph> operación.</target>       </trans-unit>
        <trans-unit id="444" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Dynamic.DynamicObject.TryUnaryOperation(System.Dynamic.UnaryOperationBinder,System.Object@)">
          <source>The <ph id="ph1">`Or`</ph> operation is performed only if the result of the <ph id="ph2">`IsTrue`</ph> operation is <ph id="ph3">`false`</ph>.</source>
          <target state="translated">El <ph id="ph1">`Or`</ph> operación se realiza solo si el resultado de la <ph id="ph2">`IsTrue`</ph> operación es <ph id="ph3">`false`</ph>.</target>       </trans-unit>
        <trans-unit id="445" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Dynamic.DynamicObject.TryUnaryOperation(System.Dynamic.UnaryOperationBinder,System.Object@)">
          <source>The <ph id="ph1">`AndAlso`</ph> operation consists of the unary <ph id="ph2">`IsFalse`</ph> operation and the binary <ph id="ph3">`And`</ph> operation.</source>
          <target state="translated">El <ph id="ph1">`AndAlso`</ph> operación está formada por el operador unario <ph id="ph2">`IsFalse`</ph> operación y el archivo binario <ph id="ph3">`And`</ph> operación.</target>       </trans-unit>
        <trans-unit id="446" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Dynamic.DynamicObject.TryUnaryOperation(System.Dynamic.UnaryOperationBinder,System.Object@)">
          <source>The <ph id="ph1">`And`</ph> operation is performed only if the result of the <ph id="ph2">`IsFalse`</ph> operation is <ph id="ph3">`false`</ph>.</source>
          <target state="translated">El <ph id="ph1">`And`</ph> operación se realiza solo si el resultado de la <ph id="ph2">`IsFalse`</ph> operación es <ph id="ph3">`false`</ph>.</target>       </trans-unit>
        <trans-unit id="447" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Dynamic.DynamicObject.TryUnaryOperation(System.Dynamic.UnaryOperationBinder,System.Object@)">
          <source>Assume that you need a data structure to store textual and numeric representations of numbers, and you want to define a mathematical negation operation for such data.</source>
          <target state="translated">Suponga que necesita una estructura de datos para almacenar representaciones numéricas y textuales de números, y desea definir una operación de negación matemática para tales datos.</target>       </trans-unit>
        <trans-unit id="448" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Dynamic.DynamicObject.TryUnaryOperation(System.Dynamic.UnaryOperationBinder,System.Object@)">
          <source>The following code example demonstrates the <ph id="ph1">`DynamicNumber`</ph> class, which is derived from the <ph id="ph2">&lt;xref:System.Dynamic.DynamicObject&gt;</ph> class.</source>
          <target state="translated">En el ejemplo de código siguiente se muestra la <ph id="ph1">`DynamicNumber`</ph> (clase), que se deriva de la <ph id="ph2">&lt;xref:System.Dynamic.DynamicObject&gt;</ph> clase.</target>       </trans-unit>
        <trans-unit id="449" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Dynamic.DynamicObject.TryUnaryOperation(System.Dynamic.UnaryOperationBinder,System.Object@)">
          <source><ph id="ph1">`DynamicNumber`</ph> overrides the <ph id="ph2">&lt;xref:System.Dynamic.DynamicObject.TryUnaryOperation%2A&gt;</ph> method to enable the mathematical negation operation.</source>
          <target state="translated"><ph id="ph1">`DynamicNumber`</ph> invalida el <ph id="ph2">&lt;xref:System.Dynamic.DynamicObject.TryUnaryOperation%2A&gt;</ph> método para habilitar la operación de negación matemática.</target>       </trans-unit>
        <trans-unit id="450" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Dynamic.DynamicObject.TryUnaryOperation(System.Dynamic.UnaryOperationBinder,System.Object@)">
          <source>Is also overrides the <ph id="ph1">&lt;xref:System.Dynamic.DynamicObject.TrySetMember%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Dynamic.DynamicObject.TryGetMember%2A&gt;</ph> methods to enable access to the elements.</source>
          <target state="translated">También es invalidaciones el <ph id="ph1">&lt;xref:System.Dynamic.DynamicObject.TrySetMember%2A&gt;</ph> y <ph id="ph2">&lt;xref:System.Dynamic.DynamicObject.TryGetMember%2A&gt;</ph> métodos para habilitar el acceso a los elementos.</target>       </trans-unit>
        <trans-unit id="451" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Dynamic.DynamicObject.TryUnaryOperation(System.Dynamic.UnaryOperationBinder,System.Object@)">
          <source>In this example, only the mathematical negation operation is supported.</source>
          <target state="translated">En este ejemplo, se admite la operación de negación matemática.</target>       </trans-unit>
        <trans-unit id="452" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Dynamic.DynamicObject.TryUnaryOperation(System.Dynamic.UnaryOperationBinder,System.Object@)">
          <source>If you try to write a statement like <ph id="ph1">`negativeNumber = +number`</ph>, a run-time exception occurs.</source>
          <target state="translated">Si se intenta escribir una instrucción como <ph id="ph1">`negativeNumber = +number`</ph>, se produce una excepción de tiempo de ejecución.</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>