<Type Name="EventWaitHandleSecurity" FullName="System.Security.AccessControl.EventWaitHandleSecurity">
  <Metadata><Meta Name="ms.openlocfilehash" Value="0ecc50a7c68e11d4c6b64171655beea35888492f" /><Meta Name="ms.sourcegitcommit" Value="0d6aa6694f157a08fe52cd25b4d9d3dcf913e812" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="es-ES" /><Meta Name="ms.lasthandoff" Value="10/12/2018" /><Meta Name="ms.locfileid" Value="49149041" /></Metadata><TypeSignature Language="C#" Value="public sealed class EventWaitHandleSecurity : System.Security.AccessControl.NativeObjectSecurity" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit EventWaitHandleSecurity extends System.Security.AccessControl.NativeObjectSecurity" />
  <TypeSignature Language="DocId" Value="T:System.Security.AccessControl.EventWaitHandleSecurity" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class EventWaitHandleSecurity&#xA;Inherits NativeObjectSecurity" />
  <TypeSignature Language="C++ CLI" Value="public ref class EventWaitHandleSecurity sealed : System::Security::AccessControl::NativeObjectSecurity" />
  <TypeSignature Language="F#" Value="type EventWaitHandleSecurity = class&#xA;    inherit NativeObjectSecurity" />
  <AssemblyInfo>
    <AssemblyName>System.Threading.AccessControl</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.2.0</AssemblyVersion>
    <AssemblyVersion>4.0.3.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Security.AccessControl.NativeObjectSecurity</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1">
      <AttributeName>System.Security.SecurityCritical</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Representa la seguridad de control de acceso de Windows aplicada a un identificador de espera de sistema con nombre. Esta clase no puede heredarse.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un <xref:System.Security.AccessControl.EventWaitHandleSecurity> objeto especifica acceso de derechos para el identificador de espera de un sistema con nombre y también especifica la manera en que se auditan los intentos de acceso. Derechos de acceso para el identificador de espera se expresan como reglas, con cada regla de acceso representada por un <xref:System.Security.AccessControl.EventWaitHandleAccessRule> objeto. Cada regla de auditoría se representa mediante un <xref:System.Security.AccessControl.EventWaitHandleAuditRule> objeto.  
  
 Esto refleja el sistema de seguridad de Windows subyacente, en el que cada objeto asegurable tiene a lo sumo un control lista de acceso discrecional (DACL) que controla el acceso al objeto protegido y, a lo sumo lista de control de acceso de un sistema (SACL) que especifica que el acceso se auditan los intentos. La DACL y SACL se ordenan las listas de entradas de control de acceso (ACE) que especifican el acceso y auditoría de los usuarios y grupos. Un <xref:System.Security.AccessControl.EventWaitHandleAccessRule> o <xref:System.Security.AccessControl.EventWaitHandleAuditRule> objeto podría representar más de una ACE.  
  
> [!NOTE]
>  Un <xref:System.Threading.EventWaitHandle> objeto puede representar un identificador de espera local o un sistema con el identificador de espera. Seguridad de control de acceso de Windows solo es significativa para los identificadores de espera del sistema con nombre.  
  
 El <xref:System.Security.AccessControl.EventWaitHandleSecurity>, <xref:System.Security.AccessControl.EventWaitHandleAccessRule>, y <xref:System.Security.AccessControl.EventWaitHandleAuditRule> clases ocultan los detalles de implementación de ACL y ACE. Le permiten pasar por alto los diferentes tipos ACE diecisiete y la complejidad de mantener correctamente la herencia y propagación de derechos de acceso. Estos objetos también están diseñados para evitar los errores de control de acceso comunes siguientes:  
  
-   Crear un descriptor de seguridad con una DACL null. Una referencia a una DACL null permite que cualquier usuario agregar reglas de acceso a un objeto, la posibilidad de crear un ataque de denegación de servicio. Un nuevo <xref:System.Security.AccessControl.EventWaitHandleSecurity> objeto comienza siempre con una DACL vacía que deniega el acceso a todos los usuarios.  
  
-   Infringir la clasificación canónica de ACE. Si no se mantiene la lista ACE en la DACL en el orden canónico, los usuarios inadvertidamente se podrían dar acceso al objeto protegido. Por ejemplo, los derechos de acceso denegado siempre deben aparecer antes que los derechos de acceso permitido. <xref:System.Security.AccessControl.EventWaitHandleSecurity> objetos mantienen internamente el orden correcto.  
  
-   Manipular las marcas de descriptor de seguridad, que deberían ser bajo el control del Administrador de recursos solo.  
  
-   Crear combinaciones no válidas de marcadores ACE.  
  
-   Manipular ACE heredadas. Herencia y propagación se controlan mediante el Administrador de recursos, en respuesta a cambios en las reglas de acceso y auditoría.  
  
-   Insertar ACE no tiene sentidas en las ACL.  
  
 Las únicas funciones no compatibles con los objetos de seguridad de .NET son actividades peligrosas que deben evitarse la mayoría de los desarrolladores de aplicaciones, como las siguientes:  
  
-   Tareas de bajo nivel que normalmente se realizan mediante el Administrador de recursos.  
  
-   Agregar o quitar entradas de control de acceso de maneras que no mantienen el orden canónico.  
  
 Para modificar la seguridad de control de acceso de Windows para un identificador de espera con nombre, utilice el <xref:System.Threading.EventWaitHandle.GetAccessControl%2A?displayProperty=nameWithType> método para obtener el <xref:System.Security.AccessControl.EventWaitHandleSecurity> objeto. Modificar el objeto de seguridad agregando y quitando las reglas y, a continuación, utilizar el <xref:System.Threading.EventWaitHandle.SetAccessControl%2A?displayProperty=nameWithType> método para volver a conectarlo.  
  
> [!IMPORTANT]
>  Cambios en un <xref:System.Security.AccessControl.EventWaitHandleSecurity> objeto no afectan a los niveles de acceso del identificador de espera con nombre hasta que llame a la <xref:System.Threading.EventWaitHandle.SetAccessControl%2A?displayProperty=nameWithType> método para asignar el objeto de seguridad modificado al identificador de espera con nombre.  
  
 Para copiar la seguridad de control de acceso del identificador de espera de una a otra, utilice el <xref:System.Threading.EventWaitHandle.GetAccessControl%2A?displayProperty=nameWithType> método para obtener un <xref:System.Security.AccessControl.EventWaitHandleSecurity> objeto que representa las reglas de acceso y auditoría para el primer identificador de espera y, a continuación, utilice el <xref:System.Threading.EventWaitHandle.SetAccessControl%2A?displayProperty=nameWithType> método o constructor que acepta un <xref:System.Security.AccessControl.EventWaitHandleSecurity> objeto, para asignar esas reglas al segundo identificador de espera.  
  
 Los usuarios con una inversión en el lenguaje de definición de descriptores de seguridad (SDDL) pueden usar el <xref:System.Security.AccessControl.ObjectSecurity.SetSecurityDescriptorSddlForm%2A> método para establecer reglas de acceso para un identificador de espera con nombre y el <xref:System.Security.AccessControl.ObjectSecurity.GetSecurityDescriptorSddlForm%2A> método para obtener una cadena que representa las reglas de acceso en formato SDDL. Esto no se recomienda para nuevo desarrollo.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra la separación entre <xref:System.Security.AccessControl.AccessControlType.Allow> reglas y <xref:System.Security.AccessControl.AccessControlType.Deny> reglas y muestra la combinación de derechos de reglas compatibles. El ejemplo se crea un <xref:System.Security.AccessControl.EventWaitHandleSecurity> objeto, agrega las reglas que conceden y deniegan derechos distintos para el usuario actual y muestra el par de reglas resultante. En el ejemplo, a continuación, permite nuevos derechos para el usuario actual y muestra el resultado, que muestra que los nuevos derechos se combinan con las existentes <xref:System.Security.AccessControl.AccessControlType.Allow> regla.  
  
> [!NOTE]
>  En este ejemplo no se adjunta el objeto de seguridad a un <xref:System.Threading.EventWaitHandle> objeto. Encontrará ejemplos donde se adjuntan los objetos de seguridad en <xref:System.Threading.EventWaitHandle.GetAccessControl%2A?displayProperty=nameWithType> y <xref:System.Threading.EventWaitHandle.SetAccessControl%2A?displayProperty=nameWithType>.  
  
 [!code-csharp[System.Security.AccessControl.EventWaitHandleSecurity.AddAccessRule#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Security.AccessControl.EventWaitHandleSecurity.AddAccessRule/CS/source.cs#1)]
 [!code-vb[System.Security.AccessControl.EventWaitHandleSecurity.AddAccessRule#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Security.AccessControl.EventWaitHandleSecurity.AddAccessRule/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Security.AccessControl.EventWaitHandleAccessRule" />
    <altmember cref="T:System.Security.AccessControl.EventWaitHandleAuditRule" />
    <altmember cref="T:System.Security.AccessControl.EventWaitHandleRights" />
    <altmember cref="M:System.Threading.EventWaitHandle.GetAccessControl" />
    <altmember cref="M:System.Threading.EventWaitHandle.SetAccessControl(System.Security.AccessControl.EventWaitHandleSecurity)" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public EventWaitHandleSecurity ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.AccessControl.EventWaitHandleSecurity.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; EventWaitHandleSecurity();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Security.AccessControl.EventWaitHandleSecurity" /> con valores predeterminados.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un nuevo <xref:System.Security.AccessControl.EventWaitHandleSecurity> objeto comienza siempre con una lista vacía de acceso discrecional (DACL), que se deniega el acceso a todos los usuarios.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Esta clase no se admite en Windows 98 ni en Windows Millennium Edition.</exception>
      </Docs>
    </Member>
    <Member MemberName="AccessRightType">
      <MemberSignature Language="C#" Value="public override Type AccessRightType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type AccessRightType" />
      <MemberSignature Language="DocId" Value="P:System.Security.AccessControl.EventWaitHandleSecurity.AccessRightType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property AccessRightType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property Type ^ AccessRightType { Type ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.AccessRightType : Type" Usage="System.Security.AccessControl.EventWaitHandleSecurity.AccessRightType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene el tipo de enumeración que la clase <see cref="T:System.Security.AccessControl.EventWaitHandleSecurity" /> utiliza para representar los derechos de acceso.</summary>
        <value>Objeto <see cref="T:System.Type" /> que representa la enumeración <see cref="T:System.Security.AccessControl.EventWaitHandleRights" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Las clases que derivan de la <xref:System.Security.AccessControl.ObjectSecurity> clase invalidación el <xref:System.Security.AccessControl.ObjectSecurity.AccessRightType%2A> propiedad y devuelva el tipo que se utilizan para representar los derechos de acceso. Cuando se trabaja con matrices o colecciones que contienen varios tipos de objetos de seguridad, use esta propiedad para determinar el tipo de enumeración correctos para utilizar con cada objeto de seguridad.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AccessRuleFactory">
      <MemberSignature Language="C#" Value="public override System.Security.AccessControl.AccessRule AccessRuleFactory (System.Security.Principal.IdentityReference identityReference, int accessMask, bool isInherited, System.Security.AccessControl.InheritanceFlags inheritanceFlags, System.Security.AccessControl.PropagationFlags propagationFlags, System.Security.AccessControl.AccessControlType type);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Security.AccessControl.AccessRule AccessRuleFactory(class System.Security.Principal.IdentityReference identityReference, int32 accessMask, bool isInherited, valuetype System.Security.AccessControl.InheritanceFlags inheritanceFlags, valuetype System.Security.AccessControl.PropagationFlags propagationFlags, valuetype System.Security.AccessControl.AccessControlType type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.AccessControl.EventWaitHandleSecurity.AccessRuleFactory(System.Security.Principal.IdentityReference,System.Int32,System.Boolean,System.Security.AccessControl.InheritanceFlags,System.Security.AccessControl.PropagationFlags,System.Security.AccessControl.AccessControlType)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Security::AccessControl::AccessRule ^ AccessRuleFactory(System::Security::Principal::IdentityReference ^ identityReference, int accessMask, bool isInherited, System::Security::AccessControl::InheritanceFlags inheritanceFlags, System::Security::AccessControl::PropagationFlags propagationFlags, System::Security::AccessControl::AccessControlType type);" />
      <MemberSignature Language="F#" Value="override this.AccessRuleFactory : System.Security.Principal.IdentityReference * int * bool * System.Security.AccessControl.InheritanceFlags * System.Security.AccessControl.PropagationFlags * System.Security.AccessControl.AccessControlType -&gt; System.Security.AccessControl.AccessRule" Usage="eventWaitHandleSecurity.AccessRuleFactory (identityReference, accessMask, isInherited, inheritanceFlags, propagationFlags, type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.AccessControl.AccessRule</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="identityReference" Type="System.Security.Principal.IdentityReference" />
        <Parameter Name="accessMask" Type="System.Int32" />
        <Parameter Name="isInherited" Type="System.Boolean" />
        <Parameter Name="inheritanceFlags" Type="System.Security.AccessControl.InheritanceFlags" />
        <Parameter Name="propagationFlags" Type="System.Security.AccessControl.PropagationFlags" />
        <Parameter Name="type" Type="System.Security.AccessControl.AccessControlType" />
      </Parameters>
      <Docs>
        <param name="identityReference">Objeto <see cref="T:System.Security.Principal.IdentityReference" /> que identifica al usuario o grupo al que se aplica la regla.</param>
        <param name="accessMask">Combinación de valores <see cref="T:System.Security.AccessControl.EventWaitHandleRights" /> bit a bit que especifica los derechos de acceso que se van a conceder o denegar, convertidos a un entero.</param>
        <param name="isInherited">No tiene sentido para los marcadores de espera con nombre porque no tienen ninguna jerarquía.</param>
        <param name="inheritanceFlags">No tiene sentido para los marcadores de espera con nombre porque no tienen ninguna jerarquía.</param>
        <param name="propagationFlags">No tiene sentido para los marcadores de espera con nombre porque no tienen ninguna jerarquía.</param>
        <param name="type">Uno de los valores de <see cref="T:System.Security.AccessControl.AccessControlType" /> que especifica si se conceden o deniegan los derechos.</param>
        <summary>Crea una nueva regla de control de acceso para el usuario indicado con los derechos de acceso, el control de acceso y los marcadores especificados.</summary>
        <returns>Objeto <see cref="T:System.Security.AccessControl.EventWaitHandleAccessRule" /> que representa los derechos indicados para el usuario especificado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La manera recomendada para crear reglas de control de acceso es utilizar los constructores de la <xref:System.Security.AccessControl.EventWaitHandleAccessRule> clase.  
  
> [!NOTE]
>  Aunque los indicadores de herencia y propagación tienen sentidos para los eventos con nombre, es posible especificarlos. No se recomienda porque lo innecesariamente complica el mantenimiento de reglas, por ejemplo al interferir con la combinación de reglas que estarían compatible.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="accessMask" />, <paramref name="inheritanceFlags" />, <paramref name="propagationFlags" /> o <paramref name="type" /> especifican un valor no válido.</exception>
        <exception cref="T:System.ArgumentNullException">El valor de <paramref name="identityReference" /> es <see langword="null" />.  
  
O bien 
 <paramref name="accessMask" /> es cero.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="identityReference" /> no es de tipo <see cref="T:System.Security.Principal.SecurityIdentifier" />, ni de un tipo que, como <see cref="T:System.Security.Principal.NTAccount" />, se pueda convertir al tipo <see cref="T:System.Security.Principal.SecurityIdentifier" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="AccessRuleType">
      <MemberSignature Language="C#" Value="public override Type AccessRuleType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type AccessRuleType" />
      <MemberSignature Language="DocId" Value="P:System.Security.AccessControl.EventWaitHandleSecurity.AccessRuleType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property AccessRuleType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property Type ^ AccessRuleType { Type ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.AccessRuleType : Type" Usage="System.Security.AccessControl.EventWaitHandleSecurity.AccessRuleType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene el tipo que utiliza la clase <see cref="T:System.Security.AccessControl.EventWaitHandleSecurity" /> para representar las reglas de acceso.</summary>
        <value>Objeto <see cref="T:System.Type" /> que representa la clase <see cref="T:System.Security.AccessControl.EventWaitHandleAccessRule" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Las clases que derivan de la <xref:System.Security.AccessControl.ObjectSecurity> clase invalidación el <xref:System.Security.AccessControl.ObjectSecurity.AccessRuleType%2A> propiedad y devuelva el tipo que se utilizan para representar las reglas de acceso. Cuando se trabaja con matrices o colecciones que contienen varios tipos de objetos de seguridad, use esta propiedad para determinar el tipo de regla de acceso correcto a utilizar con cada objeto de seguridad.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddAccessRule">
      <MemberSignature Language="C#" Value="public void AddAccessRule (System.Security.AccessControl.EventWaitHandleAccessRule rule);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddAccessRule(class System.Security.AccessControl.EventWaitHandleAccessRule rule) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.AccessControl.EventWaitHandleSecurity.AddAccessRule(System.Security.AccessControl.EventWaitHandleAccessRule)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddAccessRule (rule As EventWaitHandleAccessRule)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddAccessRule(System::Security::AccessControl::EventWaitHandleAccessRule ^ rule);" />
      <MemberSignature Language="F#" Value="override this.AddAccessRule : System.Security.AccessControl.EventWaitHandleAccessRule -&gt; unit" Usage="eventWaitHandleSecurity.AddAccessRule rule" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rule" Type="System.Security.AccessControl.EventWaitHandleAccessRule" />
      </Parameters>
      <Docs>
        <param name="rule">La regla de control de acceso que se va a agregar.</param>
        <summary>Busca una regla de control de acceso coincidente con la que se pueda combinar la nueva regla. Si no se encuentra ninguna, agrega la nueva regla.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Security.AccessControl.EventWaitHandleSecurity.AddAccessRule%2A> método busca las reglas con el mismo usuario o grupo y el mismo <xref:System.Security.AccessControl.AccessControlType> como `rule`. Si se encuentra ninguna, `rule` se agrega. Si se encuentra una regla de coincidencia, los derechos en `rule` se combinan con la regla existente.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra la separación entre <xref:System.Security.AccessControl.AccessControlType.Allow> reglas y <xref:System.Security.AccessControl.AccessControlType.Deny> reglas y muestra la combinación de derechos de reglas compatibles. El ejemplo se crea un <xref:System.Security.AccessControl.EventWaitHandleSecurity> objeto, agrega las reglas que conceden y deniegan derechos distintos para el usuario actual y muestra el par de reglas resultante. En el ejemplo, a continuación, permite nuevos derechos para el usuario actual y muestra el resultado, que muestra que los nuevos derechos se combinan con las existentes <xref:System.Security.AccessControl.AccessControlType.Allow> regla.  
  
> [!NOTE]
>  En este ejemplo no se adjunta el objeto de seguridad a un <xref:System.Threading.EventWaitHandle> objeto. Encontrará ejemplos donde se adjuntan los objetos de seguridad en <xref:System.Threading.EventWaitHandle.GetAccessControl%2A?displayProperty=nameWithType> y <xref:System.Threading.EventWaitHandle.SetAccessControl%2A?displayProperty=nameWithType>.  
  
 [!code-csharp[System.Security.AccessControl.EventWaitHandleSecurity.AddAccessRule#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Security.AccessControl.EventWaitHandleSecurity.AddAccessRule/CS/source.cs#1)]
 [!code-vb[System.Security.AccessControl.EventWaitHandleSecurity.AddAccessRule#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Security.AccessControl.EventWaitHandleSecurity.AddAccessRule/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El valor de <paramref name="rule" /> es <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="AddAuditRule">
      <MemberSignature Language="C#" Value="public void AddAuditRule (System.Security.AccessControl.EventWaitHandleAuditRule rule);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddAuditRule(class System.Security.AccessControl.EventWaitHandleAuditRule rule) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.AccessControl.EventWaitHandleSecurity.AddAuditRule(System.Security.AccessControl.EventWaitHandleAuditRule)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddAuditRule (rule As EventWaitHandleAuditRule)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddAuditRule(System::Security::AccessControl::EventWaitHandleAuditRule ^ rule);" />
      <MemberSignature Language="F#" Value="override this.AddAuditRule : System.Security.AccessControl.EventWaitHandleAuditRule -&gt; unit" Usage="eventWaitHandleSecurity.AddAuditRule rule" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rule" Type="System.Security.AccessControl.EventWaitHandleAuditRule" />
      </Parameters>
      <Docs>
        <param name="rule">La regla de auditoría que se va a agregar. El usuario especificado por esta regla determina la búsqueda.</param>
        <summary>Busca una regla de auditoría con la que se pueda combinar la nueva regla. Si no se encuentra ninguna, agrega la nueva regla.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Security.AccessControl.EventWaitHandleSecurity.AddAuditRule%2A> método busca las reglas con el mismo usuario o grupo que `rule`. Si se encuentra ninguna, `rule` se agrega. Si se encuentra una regla de coincidencia, las marcas en `rule` se combinan en una regla existente.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El valor de <paramref name="rule" /> es <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="AuditRuleFactory">
      <MemberSignature Language="C#" Value="public override System.Security.AccessControl.AuditRule AuditRuleFactory (System.Security.Principal.IdentityReference identityReference, int accessMask, bool isInherited, System.Security.AccessControl.InheritanceFlags inheritanceFlags, System.Security.AccessControl.PropagationFlags propagationFlags, System.Security.AccessControl.AuditFlags flags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Security.AccessControl.AuditRule AuditRuleFactory(class System.Security.Principal.IdentityReference identityReference, int32 accessMask, bool isInherited, valuetype System.Security.AccessControl.InheritanceFlags inheritanceFlags, valuetype System.Security.AccessControl.PropagationFlags propagationFlags, valuetype System.Security.AccessControl.AuditFlags flags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.AccessControl.EventWaitHandleSecurity.AuditRuleFactory(System.Security.Principal.IdentityReference,System.Int32,System.Boolean,System.Security.AccessControl.InheritanceFlags,System.Security.AccessControl.PropagationFlags,System.Security.AccessControl.AuditFlags)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Security::AccessControl::AuditRule ^ AuditRuleFactory(System::Security::Principal::IdentityReference ^ identityReference, int accessMask, bool isInherited, System::Security::AccessControl::InheritanceFlags inheritanceFlags, System::Security::AccessControl::PropagationFlags propagationFlags, System::Security::AccessControl::AuditFlags flags);" />
      <MemberSignature Language="F#" Value="override this.AuditRuleFactory : System.Security.Principal.IdentityReference * int * bool * System.Security.AccessControl.InheritanceFlags * System.Security.AccessControl.PropagationFlags * System.Security.AccessControl.AuditFlags -&gt; System.Security.AccessControl.AuditRule" Usage="eventWaitHandleSecurity.AuditRuleFactory (identityReference, accessMask, isInherited, inheritanceFlags, propagationFlags, flags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.AccessControl.AuditRule</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="identityReference" Type="System.Security.Principal.IdentityReference" />
        <Parameter Name="accessMask" Type="System.Int32" />
        <Parameter Name="isInherited" Type="System.Boolean" />
        <Parameter Name="inheritanceFlags" Type="System.Security.AccessControl.InheritanceFlags" />
        <Parameter Name="propagationFlags" Type="System.Security.AccessControl.PropagationFlags" />
        <Parameter Name="flags" Type="System.Security.AccessControl.AuditFlags" />
      </Parameters>
      <Docs>
        <param name="identityReference">Objeto <see cref="T:System.Security.Principal.IdentityReference" /> que identifica al usuario o grupo al que se aplica la regla.</param>
        <param name="accessMask">Combinación de valores <see cref="T:System.Security.AccessControl.EventWaitHandleRights" /> bit a bit que especifica los derechos de acceso que se van a auditar, convertidos a un entero.</param>
        <param name="isInherited">No tiene sentido para los marcadores de espera con nombre porque no tienen ninguna jerarquía.</param>
        <param name="inheritanceFlags">No tiene sentido para los marcadores de espera con nombre porque no tienen ninguna jerarquía.</param>
        <param name="propagationFlags">No tiene sentido para los marcadores de espera con nombre porque no tienen ninguna jerarquía.</param>
        <param name="flags">Una combinación bit a bit de valores <see cref="T:System.Security.AccessControl.AuditFlags" /> que especifica si el resultado de la operación auditada de acceso es de éxito, error o ambos.</param>
        <summary>Crea una nueva regla de auditoría, que especifica el usuario al que se aplica la regla, los derechos de acceso que se van a auditar y el resultado que desencadena la regla de auditoría.</summary>
        <returns>Objeto <see cref="T:System.Security.AccessControl.EventWaitHandleAuditRule" /> que representa la regla de auditoría indicada para el usuario especificado. El tipo de valor devuelto del método es la clase base, <see cref="T:System.Security.AccessControl.AuditRule" />, pero el valor devuelto se puede convertir sin ningún riesgo a la clase derivada.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La manera recomendada para crear las reglas de auditoría es utilizar los constructores de la <xref:System.Security.AccessControl.EventWaitHandleAuditRule> clase.  
  
> [!NOTE]
>  Aunque los indicadores de herencia y propagación tienen sentidos para los eventos con nombre, es posible especificarlos. No se recomienda porque lo innecesariamente complica el mantenimiento de reglas, por ejemplo al interferir con la combinación de reglas que estarían compatible.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="accessMask" />, <paramref name="inheritanceFlags" />, <paramref name="propagationFlags" /> o <paramref name="flags" /> especifican un valor no válido.</exception>
        <exception cref="T:System.ArgumentNullException">El valor de <paramref name="identityReference" /> es <see langword="null" />.  
  
O bien 
 <paramref name="accessMask" /> es cero.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="identityReference" /> no es de tipo <see cref="T:System.Security.Principal.SecurityIdentifier" />, ni de un tipo que, como <see cref="T:System.Security.Principal.NTAccount" />, se pueda convertir al tipo <see cref="T:System.Security.Principal.SecurityIdentifier" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="AuditRuleType">
      <MemberSignature Language="C#" Value="public override Type AuditRuleType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type AuditRuleType" />
      <MemberSignature Language="DocId" Value="P:System.Security.AccessControl.EventWaitHandleSecurity.AuditRuleType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property AuditRuleType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property Type ^ AuditRuleType { Type ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.AuditRuleType : Type" Usage="System.Security.AccessControl.EventWaitHandleSecurity.AuditRuleType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene el tipo que utiliza la clase <see cref="T:System.Security.AccessControl.EventWaitHandleSecurity" /> para representar las reglas de auditoría.</summary>
        <value>Objeto <see cref="T:System.Type" /> que representa la clase <see cref="T:System.Security.AccessControl.EventWaitHandleAuditRule" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Las clases que derivan de la <xref:System.Security.AccessControl.ObjectSecurity> clase invalidación el <xref:System.Security.AccessControl.ObjectSecurity.AuditRuleType%2A> propiedad y devuelva el tipo que se utilizan para representar los derechos de auditoría. Cuando se trabaja con matrices o colecciones que contienen varios tipos de objetos de seguridad, use esta propiedad para determinar el tipo de regla de auditoría correcta para utilizar con cada objeto de seguridad.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RemoveAccessRule">
      <MemberSignature Language="C#" Value="public bool RemoveAccessRule (System.Security.AccessControl.EventWaitHandleAccessRule rule);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool RemoveAccessRule(class System.Security.AccessControl.EventWaitHandleAccessRule rule) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.AccessControl.EventWaitHandleSecurity.RemoveAccessRule(System.Security.AccessControl.EventWaitHandleAccessRule)" />
      <MemberSignature Language="VB.NET" Value="Public Function RemoveAccessRule (rule As EventWaitHandleAccessRule) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool RemoveAccessRule(System::Security::AccessControl::EventWaitHandleAccessRule ^ rule);" />
      <MemberSignature Language="F#" Value="override this.RemoveAccessRule : System.Security.AccessControl.EventWaitHandleAccessRule -&gt; bool" Usage="eventWaitHandleSecurity.RemoveAccessRule rule" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rule" Type="System.Security.AccessControl.EventWaitHandleAccessRule" />
      </Parameters>
      <Docs>
        <param name="rule"><see cref="T:System.Security.AccessControl.EventWaitHandleAccessRule" /> que especifica el usuario y <see cref="T:System.Security.AccessControl.AccessControlType" /> que se va a buscar y un conjunto de marcadores de herencia y propagación con los que una regla coincidente, si se encuentra, debe ser compatible. Especifica los derechos que se van a quitar de la regla compatible, si se encuentra.</param>
        <summary>Busca una regla de control de acceso con el mismo usuario y <see cref="T:System.Security.AccessControl.AccessControlType" /> (conceder o denegar) que la regla de acceso especificada y con marcadores de herencia y propagación compatibles; si encuentra este tipo de regla, quita de ésta los derechos contenidos en la regla de acceso especificada.</summary>
        <returns><see langword="true" /> si se ha encontrado una regla compatible; en caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Actual <xref:System.Security.AccessControl.EventWaitHandleSecurity> se busca una regla que tenga el mismo usuario y el mismo <xref:System.Security.AccessControl.AccessControlType> valor como `rule`. Si no se encuentra ninguna de estas reglas, se realiza ninguna acción y el método devuelve `false`. Si se encuentran las reglas de coincidencia, se comprueban los marcadores de herencia y compatibilidad para la compatibilidad con las marcas especificadas en `rule`. Si se encuentra ninguna regla compatible, se realiza ninguna acción y el método devuelve `false`. Si se encuentra una regla con marcadores compatibles, los derechos especifican en `rule` se quitan de la regla compatible, y el método devuelve `true`. Si `rule` especifica los derechos no contenidos en la regla compatible, se realiza ninguna acción con respecto a dichos derechos. Si se quitan todos los derechos de la regla compatible, se quita la regla completa actual <xref:System.Security.AccessControl.EventWaitHandleSecurity> objeto.  
  
> [!IMPORTANT]
>  Aunque puede especificar los marcadores de herencia y propagación para las reglas de acceso de eventos, si se crean con el <xref:System.Security.AccessControl.EventWaitHandleSecurity.AccessRuleFactory%2A> método, no se recomienda. Herencia y propagación no tienen ningún significado para los eventos con nombre y realizan el mantenimiento de reglas de acceso más complicado.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra el uso de la <xref:System.Security.AccessControl.EventWaitHandleSecurity.RemoveAccessRule%2A> método para quitar los derechos de un <xref:System.Security.AccessControl.AccessControlType.Allow> de regla en un <xref:System.Security.AccessControl.EventWaitHandleSecurity> objeto. También muestra que otros derechos en `rule` se omiten.  
  
 El ejemplo se crea un <xref:System.Security.AccessControl.EventWaitHandleSecurity> de objeto y se agregan reglas que conceden y deniegan diferentes derechos para el usuario actual. Los derechos permiten incluir <xref:System.Security.AccessControl.EventWaitHandleRights.Modify>, <xref:System.Security.AccessControl.EventWaitHandleRights.ReadPermissions>, y <xref:System.Security.AccessControl.EventWaitHandleRights.Synchronize>. El ejemplo, a continuación, crea una nueva regla para el usuario actual, incluidos <xref:System.Security.AccessControl.EventWaitHandleRights.ReadPermissions> y <xref:System.Security.AccessControl.EventWaitHandleRights.TakeOwnership> derechos y utiliza esa regla con el <xref:System.Security.AccessControl.EventWaitHandleSecurity.RemoveAccessRule%2A> método para quitar <xref:System.Security.AccessControl.EventWaitHandleRights.ReadPermissions> desde el <xref:System.Security.AccessControl.AccessControlType.Allow> de regla en el <xref:System.Security.AccessControl.EventWaitHandleSecurity> objeto. El <xref:System.Security.AccessControl.EventWaitHandleRights.TakeOwnership> directamente en `rule` se omite.  
  
> [!NOTE]
>  En este ejemplo no se adjunta el objeto de seguridad a un <xref:System.Threading.EventWaitHandle> objeto. Encontrará ejemplos donde se adjuntan los objetos de seguridad en <xref:System.Threading.EventWaitHandle.GetAccessControl%2A?displayProperty=nameWithType> y <xref:System.Threading.EventWaitHandle.SetAccessControl%2A?displayProperty=nameWithType>.  
  
 [!code-csharp[System.Security.AccessControl.EventWaitHandleSecurity.RemoveAccessRule#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Security.AccessControl.EventWaitHandleSecurity.RemoveAccessRule/CS/source.cs#1)]
 [!code-vb[System.Security.AccessControl.EventWaitHandleSecurity.RemoveAccessRule#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Security.AccessControl.EventWaitHandleSecurity.RemoveAccessRule/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El valor de <paramref name="rule" /> es <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="RemoveAccessRuleAll">
      <MemberSignature Language="C#" Value="public void RemoveAccessRuleAll (System.Security.AccessControl.EventWaitHandleAccessRule rule);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RemoveAccessRuleAll(class System.Security.AccessControl.EventWaitHandleAccessRule rule) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.AccessControl.EventWaitHandleSecurity.RemoveAccessRuleAll(System.Security.AccessControl.EventWaitHandleAccessRule)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RemoveAccessRuleAll (rule As EventWaitHandleAccessRule)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RemoveAccessRuleAll(System::Security::AccessControl::EventWaitHandleAccessRule ^ rule);" />
      <MemberSignature Language="F#" Value="override this.RemoveAccessRuleAll : System.Security.AccessControl.EventWaitHandleAccessRule -&gt; unit" Usage="eventWaitHandleSecurity.RemoveAccessRuleAll rule" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rule" Type="System.Security.AccessControl.EventWaitHandleAccessRule" />
      </Parameters>
      <Docs>
        <param name="rule"><see cref="T:System.Security.AccessControl.EventWaitHandleAccessRule" /> que especifica el usuario y <see cref="T:System.Security.AccessControl.AccessControlType" /> que se va a buscar. Se pasa por alto cualquier derecho especificado por esta regla.</param>
        <summary>Busca todas las reglas de control de acceso con el mismo usuario y <see cref="T:System.Security.AccessControl.AccessControlType" /> (conceder o denegar) que la regla especificada y, si las encuentra, las quita.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Actual <xref:System.Security.AccessControl.EventWaitHandleSecurity> se busca en las reglas que tienen el mismo usuario y el mismo <xref:System.Security.AccessControl.AccessControlType> valor como `rule`. Los derechos especificados por `rule` se omiten al realizar esta búsqueda. Se quitan todas las reglas coincidentes. Si no se encuentra ninguna regla coincidente, se realiza ninguna acción.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra que el <xref:System.Security.AccessControl.EventWaitHandleSecurity.RemoveAccessRuleAll%2A> método quita todas las reglas que coinciden con el usuario y <xref:System.Security.AccessControl.AccessControlType>, omitiendo los derechos.  
  
 El ejemplo se crea un <xref:System.Security.AccessControl.EventWaitHandleSecurity> objeto, se agregan reglas que conceden y deniegan diferentes derechos para el usuario actual y, a continuación, combinan derechos adicionales en el <xref:System.Security.AccessControl.AccessControlType.Allow> regla. El ejemplo, a continuación, crea una nueva regla que permite al usuario actual tomar posesión y utiliza esa regla para quitar el <xref:System.Security.AccessControl.AccessControlType.Allow> regla desde el <xref:System.Security.AccessControl.EventWaitHandleSecurity> objeto.  
  
> [!NOTE]
>  En este ejemplo no se adjunta el objeto de seguridad a un <xref:System.Threading.EventWaitHandle> objeto. Encontrará ejemplos donde se adjuntan los objetos de seguridad en <xref:System.Threading.EventWaitHandle.GetAccessControl%2A?displayProperty=nameWithType> y <xref:System.Threading.EventWaitHandle.SetAccessControl%2A?displayProperty=nameWithType>.  
  
 [!code-csharp[System.Security.AccessControl.EventWaitHandleSecurity.RemoveAccessRuleAll#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Security.AccessControl.EventWaitHandleSecurity.RemoveAccessRuleAll/CS/source.cs#1)]
 [!code-vb[System.Security.AccessControl.EventWaitHandleSecurity.RemoveAccessRuleAll#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Security.AccessControl.EventWaitHandleSecurity.RemoveAccessRuleAll/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El valor de <paramref name="rule" /> es <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="RemoveAccessRuleSpecific">
      <MemberSignature Language="C#" Value="public void RemoveAccessRuleSpecific (System.Security.AccessControl.EventWaitHandleAccessRule rule);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RemoveAccessRuleSpecific(class System.Security.AccessControl.EventWaitHandleAccessRule rule) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.AccessControl.EventWaitHandleSecurity.RemoveAccessRuleSpecific(System.Security.AccessControl.EventWaitHandleAccessRule)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RemoveAccessRuleSpecific (rule As EventWaitHandleAccessRule)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RemoveAccessRuleSpecific(System::Security::AccessControl::EventWaitHandleAccessRule ^ rule);" />
      <MemberSignature Language="F#" Value="override this.RemoveAccessRuleSpecific : System.Security.AccessControl.EventWaitHandleAccessRule -&gt; unit" Usage="eventWaitHandleSecurity.RemoveAccessRuleSpecific rule" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rule" Type="System.Security.AccessControl.EventWaitHandleAccessRule" />
      </Parameters>
      <Docs>
        <param name="rule"><see cref="T:System.Security.AccessControl.EventWaitHandleAccessRule" /> que se va a quitar.</param>
        <summary>Busca una regla de control de acceso que coincida exactamente con la regla especificada y, si la encuentra, la quita.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La regla se quitarán solo si coincide exactamente con `rule` en todos los detalles, incluidas marcas. Otras reglas con el mismo usuario y <xref:System.Security.AccessControl.AccessControlType> no se ven afectados.  
  
> [!IMPORTANT]
>  Una regla representa una o más entradas de control de acceso (ACE) subyacentes y estas entradas se dividen o se combinan según sea necesario cuando se modifican las reglas de seguridad de acceso para un usuario. Por lo tanto, una regla que ya no exista en la forma concreta que tenía cuando se agregó y, en ese caso el <xref:System.Security.AccessControl.EventWaitHandleSecurity.RemoveAccessRuleSpecific%2A> método no puede quitarla.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra que el <xref:System.Security.AccessControl.EventWaitHandleSecurity.RemoveAccessRuleSpecific%2A> método requiere una coincidencia exacta para quitar una regla, y las reglas para permitir o denegar los derechos son independientes entre sí.  
  
 El ejemplo se crea un <xref:System.Security.AccessControl.EventWaitHandleSecurity> objeto, se agregan reglas que conceden y deniegan diferentes derechos para el usuario actual y, a continuación, combinan derechos adicionales en el <xref:System.Security.AccessControl.AccessControlType.Allow> regla de acceso. El ejemplo a continuación, pasa el original <xref:System.Security.AccessControl.AccessControlType.Allow> de regla para el <xref:System.Security.AccessControl.EventWaitHandleSecurity.RemoveAccessRuleSpecific%2A> método y muestra los resultados, que muestra que nada se ha eliminado. El ejemplo, a continuación, crea una regla que coincide con el <xref:System.Security.AccessControl.AccessControlType.Allow> de regla en el <xref:System.Security.AccessControl.EventWaitHandleSecurity> objeto y correctamente se usa el <xref:System.Security.AccessControl.EventWaitHandleSecurity.RemoveAccessRuleSpecific%2A> método para quitar la regla.  
  
> [!NOTE]
>  En este ejemplo no se adjunta el objeto de seguridad a un <xref:System.Threading.EventWaitHandle> objeto. Encontrará ejemplos donde se adjuntan los objetos de seguridad en <xref:System.Threading.EventWaitHandle.GetAccessControl%2A?displayProperty=nameWithType> y <xref:System.Threading.EventWaitHandle.SetAccessControl%2A?displayProperty=nameWithType>.  
  
 [!code-csharp[System.Security.AccessControl.EventWaitHandleSecurity.RemoveAccessRuleSpecific#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Security.AccessControl.EventWaitHandleSecurity.RemoveAccessRuleSpecific/CS/source.cs#1)]
 [!code-vb[System.Security.AccessControl.EventWaitHandleSecurity.RemoveAccessRuleSpecific#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Security.AccessControl.EventWaitHandleSecurity.RemoveAccessRuleSpecific/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El valor de <paramref name="rule" /> es <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="RemoveAuditRule">
      <MemberSignature Language="C#" Value="public bool RemoveAuditRule (System.Security.AccessControl.EventWaitHandleAuditRule rule);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool RemoveAuditRule(class System.Security.AccessControl.EventWaitHandleAuditRule rule) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.AccessControl.EventWaitHandleSecurity.RemoveAuditRule(System.Security.AccessControl.EventWaitHandleAuditRule)" />
      <MemberSignature Language="VB.NET" Value="Public Function RemoveAuditRule (rule As EventWaitHandleAuditRule) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool RemoveAuditRule(System::Security::AccessControl::EventWaitHandleAuditRule ^ rule);" />
      <MemberSignature Language="F#" Value="override this.RemoveAuditRule : System.Security.AccessControl.EventWaitHandleAuditRule -&gt; bool" Usage="eventWaitHandleSecurity.RemoveAuditRule rule" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rule" Type="System.Security.AccessControl.EventWaitHandleAuditRule" />
      </Parameters>
      <Docs>
        <param name="rule"><see cref="T:System.Security.AccessControl.EventWaitHandleAuditRule" /> que especifica el usuario que se va a buscar y un conjunto de marcadores de herencia y propagación con los que una regla coincidente, si se encuentra, debe ser compatible. Especifica los derechos que se van a quitar de la regla compatible, si se encuentra.</param>
        <summary>Busca una regla de auditoría con el mismo usuario que la regla especificada y con marcadores de herencia y propagación compatibles; si encuentra una regla compatible, quita de ésta los derechos contenidos en la regla especificada.</summary>
        <returns><see langword="true" /> si se ha encontrado una regla compatible; en caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Actual <xref:System.Security.AccessControl.EventWaitHandleSecurity> se busca una regla de auditoría que tenga el mismo usuario que `rule`. Si no se encuentra ninguna de estas reglas, se realiza ninguna acción y el método devuelve `false`. Si se encuentran las reglas de coincidencia, se comprueban los marcadores de herencia y compatibilidad para la compatibilidad con las marcas especificadas en `rule`. Si se encuentra ninguna regla compatible, se realiza ninguna acción y el método devuelve `false`. Si se encuentra una regla con marcadores compatibles, los derechos especifican en `rule` se quitan de la regla compatible, y el método devuelve `true`. Si `rule` especifica los derechos no contenidos en la regla compatible, se realiza ninguna acción con respecto a dichos derechos. Si se quitan todos los derechos de la regla compatible, se quita la regla completa actual <xref:System.Security.AccessControl.EventWaitHandleSecurity> objeto.  
  
> [!IMPORTANT]
>  Aunque puede especificar los marcadores de herencia y propagación para las reglas de auditoría de eventos, si se crean con el <xref:System.Security.AccessControl.EventWaitHandleSecurity.AuditRuleFactory%2A> método, no se recomienda. Herencia y propagación no tienen ningún significado para los eventos con nombre y realizan el mantenimiento de las reglas de auditoría más complicado.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El valor de <paramref name="rule" /> es <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="RemoveAuditRuleAll">
      <MemberSignature Language="C#" Value="public void RemoveAuditRuleAll (System.Security.AccessControl.EventWaitHandleAuditRule rule);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RemoveAuditRuleAll(class System.Security.AccessControl.EventWaitHandleAuditRule rule) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.AccessControl.EventWaitHandleSecurity.RemoveAuditRuleAll(System.Security.AccessControl.EventWaitHandleAuditRule)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RemoveAuditRuleAll (rule As EventWaitHandleAuditRule)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RemoveAuditRuleAll(System::Security::AccessControl::EventWaitHandleAuditRule ^ rule);" />
      <MemberSignature Language="F#" Value="override this.RemoveAuditRuleAll : System.Security.AccessControl.EventWaitHandleAuditRule -&gt; unit" Usage="eventWaitHandleSecurity.RemoveAuditRuleAll rule" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rule" Type="System.Security.AccessControl.EventWaitHandleAuditRule" />
      </Parameters>
      <Docs>
        <param name="rule"><see cref="T:System.Security.AccessControl.EventWaitHandleAuditRule" /> que especifica el usuario que se va a buscar. Se pasa por alto cualquier derecho especificado por esta regla.</param>
        <summary>Busca todas las reglas de auditoría con el mismo usuario que la regla especificada y, si las encuentra, las quita.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Actual <xref:System.Security.AccessControl.EventWaitHandleSecurity> se busca en las reglas de auditoría que tienen el mismo usuario que `rule`. Los derechos especificados por `rule` se omiten al realizar esta búsqueda. Se quitan todas las reglas coincidentes. Si no se encuentra ninguna regla coincidente, se realiza ninguna acción.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El valor de <paramref name="rule" /> es <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="RemoveAuditRuleSpecific">
      <MemberSignature Language="C#" Value="public void RemoveAuditRuleSpecific (System.Security.AccessControl.EventWaitHandleAuditRule rule);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RemoveAuditRuleSpecific(class System.Security.AccessControl.EventWaitHandleAuditRule rule) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.AccessControl.EventWaitHandleSecurity.RemoveAuditRuleSpecific(System.Security.AccessControl.EventWaitHandleAuditRule)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RemoveAuditRuleSpecific (rule As EventWaitHandleAuditRule)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RemoveAuditRuleSpecific(System::Security::AccessControl::EventWaitHandleAuditRule ^ rule);" />
      <MemberSignature Language="F#" Value="override this.RemoveAuditRuleSpecific : System.Security.AccessControl.EventWaitHandleAuditRule -&gt; unit" Usage="eventWaitHandleSecurity.RemoveAuditRuleSpecific rule" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rule" Type="System.Security.AccessControl.EventWaitHandleAuditRule" />
      </Parameters>
      <Docs>
        <param name="rule"><see cref="T:System.Security.AccessControl.EventWaitHandleAuditRule" /> que se va a quitar.</param>
        <summary>Busca una regla de auditoría que coincida exactamente con la regla especificada y, si la encuentra, la quita.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La regla se quitarán solo si coincide exactamente con `rule` en todos los detalles, incluidas marcas. No se ven afectadas otras reglas de auditoría para el mismo usuario.  
  
> [!IMPORTANT]
>  Una regla representa una o más entradas de control de acceso (ACE) subyacentes y estas entradas se dividen o se combinan según sea necesario cuando se modifican las reglas de seguridad de auditoría para un usuario. Por lo tanto, una regla que ya no exista en la forma concreta que tenía cuando se agregó y, en ese caso el <xref:System.Security.AccessControl.EventWaitHandleSecurity.RemoveAuditRuleSpecific%2A> método no puede quitarla.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El valor de <paramref name="rule" /> es <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ResetAccessRule">
      <MemberSignature Language="C#" Value="public void ResetAccessRule (System.Security.AccessControl.EventWaitHandleAccessRule rule);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ResetAccessRule(class System.Security.AccessControl.EventWaitHandleAccessRule rule) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.AccessControl.EventWaitHandleSecurity.ResetAccessRule(System.Security.AccessControl.EventWaitHandleAccessRule)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ResetAccessRule (rule As EventWaitHandleAccessRule)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ResetAccessRule(System::Security::AccessControl::EventWaitHandleAccessRule ^ rule);" />
      <MemberSignature Language="F#" Value="override this.ResetAccessRule : System.Security.AccessControl.EventWaitHandleAccessRule -&gt; unit" Usage="eventWaitHandleSecurity.ResetAccessRule rule" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rule" Type="System.Security.AccessControl.EventWaitHandleAccessRule" />
      </Parameters>
      <Docs>
        <param name="rule"><see cref="T:System.Security.AccessControl.EventWaitHandleAccessRule" /> que se va a agregar. El usuario especificado por esta regla determina las reglas que se van a quitar antes de agregar esta regla.</param>
        <summary>Quita todas las reglas de control de acceso con el mismo usuario que la regla especificada, independientemente de <see cref="T:System.Security.AccessControl.AccessControlType" />, y, a continuación, agrega la regla especificada.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si no hay ninguna regla de acceso cuyo usuario coincide con la regla especificada, `rule` se agrega.  
  
   
  
## Examples  
 El siguiente ejemplo de código muestra cómo el <xref:System.Security.AccessControl.EventWaitHandleSecurity.ResetAccessRule%2A> método reemplaza todas las reglas de usuario coincidentes con la regla especificada para la coincidencia.  
  
 El ejemplo se crea un <xref:System.Security.AccessControl.EventWaitHandleSecurity> de objeto y se agregan reglas que conceden y deniegan diferentes derechos para el usuario actual. El ejemplo, a continuación, crea una nueva regla que permite el control completo del usuario actual y usa el <xref:System.Security.AccessControl.EventWaitHandleSecurity.ResetAccessRule%2A> método para reemplazar dos de las reglas existentes con la nueva regla.  
  
> [!NOTE]
>  En este ejemplo no se adjunta el objeto de seguridad a un <xref:System.Threading.EventWaitHandle> objeto. Encontrará ejemplos donde se adjuntan los objetos de seguridad en <xref:System.Threading.EventWaitHandle.GetAccessControl%2A?displayProperty=nameWithType> y <xref:System.Threading.EventWaitHandle.SetAccessControl%2A?displayProperty=nameWithType>.  
  
 [!code-csharp[System.Security.AccessControl.EventWaitHandleSecurity.ResetAccessRule#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Security.AccessControl.EventWaitHandleSecurity.ResetAccessRule/CS/source.cs#1)]
 [!code-vb[System.Security.AccessControl.EventWaitHandleSecurity.ResetAccessRule#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Security.AccessControl.EventWaitHandleSecurity.ResetAccessRule/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El valor de <paramref name="rule" /> es <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="SetAccessRule">
      <MemberSignature Language="C#" Value="public void SetAccessRule (System.Security.AccessControl.EventWaitHandleAccessRule rule);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetAccessRule(class System.Security.AccessControl.EventWaitHandleAccessRule rule) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.AccessControl.EventWaitHandleSecurity.SetAccessRule(System.Security.AccessControl.EventWaitHandleAccessRule)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetAccessRule (rule As EventWaitHandleAccessRule)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetAccessRule(System::Security::AccessControl::EventWaitHandleAccessRule ^ rule);" />
      <MemberSignature Language="F#" Value="override this.SetAccessRule : System.Security.AccessControl.EventWaitHandleAccessRule -&gt; unit" Usage="eventWaitHandleSecurity.SetAccessRule rule" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rule" Type="System.Security.AccessControl.EventWaitHandleAccessRule" />
      </Parameters>
      <Docs>
        <param name="rule"><see cref="T:System.Security.AccessControl.EventWaitHandleAccessRule" /> que se va a agregar. El usuario y el objeto <see cref="T:System.Security.AccessControl.AccessControlType" /> de esta regla determinan las reglas que se van a quitar antes de agregar esta regla.</param>
        <summary>Quita todas las reglas de control de acceso con el mismo usuario y <see cref="T:System.Security.AccessControl.AccessControlType" /> (conceder o denegar) que la regla especificada y, a continuación, agrega la regla especificada.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si la regla especificada tiene <xref:System.Security.AccessControl.AccessControlType.Allow>, es el efecto de este método quitar todos los <xref:System.Security.AccessControl.AccessControlType.Allow> reglas para el usuario especificado, reemplazándolos por la regla especificada. Si la regla especificada tiene <xref:System.Security.AccessControl.AccessControlType.Deny>, todos los <xref:System.Security.AccessControl.AccessControlType.Deny> reglas para el usuario especificado se reemplazan por la regla especificada.  
  
 Si no hay ninguna regla cuyo usuario y <xref:System.Security.AccessControl.AccessControlType> coincide con la regla especificada, `rule` se agrega.  
  
   
  
## Examples  
 El siguiente ejemplo de código muestra cómo el <xref:System.Security.AccessControl.EventWaitHandleSecurity.SetAccessRule%2A> método quita todas las reglas que coinciden con el usuario y la <xref:System.Security.AccessControl.AccessControlType> de `rule`, reemplazarlos con `rule`.  
  
 El ejemplo se crea un <xref:System.Security.AccessControl.EventWaitHandleSecurity> de objeto y se agregan reglas que conceden y deniegan diferentes derechos para el usuario actual. El ejemplo, a continuación, crea una nueva regla que permite el control completo del usuario actual y usa el <xref:System.Security.AccessControl.EventWaitHandleSecurity.SetAccessRule%2A> método para reemplazar el existente <xref:System.Security.AccessControl.AccessControlType.Allow> regla con la nueva regla. No se ve afectada la regla que deniegue el acceso.  
  
> [!NOTE]
>  En este ejemplo no se adjunta el objeto de seguridad a un <xref:System.Threading.EventWaitHandle> objeto. Encontrará ejemplos donde se adjuntan los objetos de seguridad en <xref:System.Threading.EventWaitHandle.GetAccessControl%2A?displayProperty=nameWithType> y <xref:System.Threading.EventWaitHandle.SetAccessControl%2A?displayProperty=nameWithType>.  
  
 [!code-csharp[System.Security.AccessControl.EventWaitHandleSecurity.SetAccessRule#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Security.AccessControl.EventWaitHandleSecurity.SetAccessRule/CS/source.cs#1)]
 [!code-vb[System.Security.AccessControl.EventWaitHandleSecurity.SetAccessRule#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Security.AccessControl.EventWaitHandleSecurity.SetAccessRule/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El valor de <paramref name="rule" /> es <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="SetAuditRule">
      <MemberSignature Language="C#" Value="public void SetAuditRule (System.Security.AccessControl.EventWaitHandleAuditRule rule);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetAuditRule(class System.Security.AccessControl.EventWaitHandleAuditRule rule) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.AccessControl.EventWaitHandleSecurity.SetAuditRule(System.Security.AccessControl.EventWaitHandleAuditRule)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetAuditRule (rule As EventWaitHandleAuditRule)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetAuditRule(System::Security::AccessControl::EventWaitHandleAuditRule ^ rule);" />
      <MemberSignature Language="F#" Value="override this.SetAuditRule : System.Security.AccessControl.EventWaitHandleAuditRule -&gt; unit" Usage="eventWaitHandleSecurity.SetAuditRule rule" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rule" Type="System.Security.AccessControl.EventWaitHandleAuditRule" />
      </Parameters>
      <Docs>
        <param name="rule"><see cref="T:System.Security.AccessControl.EventWaitHandleAuditRule" /> que se va a agregar. El usuario especificado por esta regla determina las reglas que se van a quitar antes de agregar esta regla.</param>
        <summary>Quita todas las reglas de auditoría con el mismo usuario que la regla especificada, sin tener en cuenta el valor de <see cref="T:System.Security.AccessControl.AuditFlags" />, y, a continuación, agrega la regla especificada.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si no hay ninguna regla de auditoría cuyo usuario coincide con la regla especificada, `rule` se agrega.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El valor de <paramref name="rule" /> es <see langword="null" />.</exception>
      </Docs>
    </Member>
  </Members>
</Type>