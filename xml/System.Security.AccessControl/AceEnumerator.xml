<Type Name="AceEnumerator" FullName="System.Security.AccessControl.AceEnumerator">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="1e3c963e08072dced3419135e174fee2308be45f" />
    <Meta Name="ms.sourcegitcommit" Value="6a0b904069161bbaec4ffd02aa7d9cf38c61e72e" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="es-ES" />
    <Meta Name="ms.lasthandoff" Value="06/24/2018" />
    <Meta Name="ms.locfileid" Value="36533007" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class AceEnumerator : System.Collections.IEnumerator" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit AceEnumerator extends System.Object implements class System.Collections.IEnumerator" />
  <TypeSignature Language="DocId" Value="T:System.Security.AccessControl.AceEnumerator" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class AceEnumerator&#xA;Implements IEnumerator" />
  <TypeSignature Language="C++ CLI" Value="public ref class AceEnumerator sealed : System::Collections::IEnumerator" />
  <TypeSignature Language="F#" Value="type AceEnumerator = class&#xA;    interface IEnumerator" />
  <AssemblyInfo>
    <AssemblyName>System.Security.AccessControl</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Collections.IEnumerator</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>Proporciona la capacidad para recorrer en iteración las entradas de control de acceso (ACE) de una lista de control de acceso (ACL).</summary>
    <remarks>To be added.</remarks>
  </Docs>
  <Members>
    <Member MemberName="Current">
      <MemberSignature Language="C#" Value="public System.Security.AccessControl.GenericAce Current { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Security.AccessControl.GenericAce Current" />
      <MemberSignature Language="DocId" Value="P:System.Security.AccessControl.AceEnumerator.Current" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Current As GenericAce" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Security::AccessControl::GenericAce ^ Current { System::Security::AccessControl::GenericAce ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Current : System.Security.AccessControl.GenericAce" Usage="System.Security.AccessControl.AceEnumerator.Current" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.AccessControl.GenericAce</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene el elemento actual de la colección <see cref="T:System.Security.AccessControl.GenericAce" />. Esta propiedad obtiene la versión descriptiva de tipo del objeto.</summary>
        <value>Elemento actual de la colección <see cref="T:System.Security.AccessControl.GenericAce" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MoveNext">
      <MemberSignature Language="C#" Value="public bool MoveNext ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool MoveNext() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.AccessControl.AceEnumerator.MoveNext" />
      <MemberSignature Language="VB.NET" Value="Public Function MoveNext () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool MoveNext();" />
      <MemberSignature Language="F#" Value="abstract member MoveNext : unit -&gt; bool&#xA;override this.MoveNext : unit -&gt; bool" Usage="aceEnumerator.MoveNext " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IEnumerator.MoveNext</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Security.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Desplaza el enumerador al siguiente elemento de la colección <see cref="T:System.Security.AccessControl.GenericAce" />.</summary>
        <returns>
          <see langword="true" /> si el enumerador avanzó con éxito hasta el siguiente elemento; <see langword="false" /> si el enumerador alcanzó el final de la colección.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Después de crea un enumerador o después de llamar a la <xref:System.Security.AccessControl.AceEnumerator.Reset%2A> método, el enumerador se coloca antes del primer elemento de la colección y la primera llamada a la <xref:System.Security.AccessControl.AceEnumerator.MoveNext%2A> método desplaza el enumerador hasta el primer elemento de la colección.  
  
 Tras alcanzar el final de la colección, las siguientes llamadas a <xref:System.Security.AccessControl.AceEnumerator.MoveNext%2A> devolver `false` hasta <xref:System.Security.AccessControl.AceEnumerator.Reset%2A> se llama.  
  
 Un enumerador es válido mientras la colección no cambie. Si, como agregar, modificar o eliminar elementos, se realizan cambios a la colección, el enumerador queda invalidado permanentemente y la siguiente llamada a <xref:System.Security.AccessControl.AceEnumerator.MoveNext%2A> o <xref:System.Security.AccessControl.AceEnumerator.Reset%2A> produce una <xref:System.InvalidOperationException>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">La colección se modificó después de crear el enumerador.</exception>
      </Docs>
    </Member>
    <Member MemberName="Reset">
      <MemberSignature Language="C#" Value="public void Reset ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Reset() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.AccessControl.AceEnumerator.Reset" />
      <MemberSignature Language="VB.NET" Value="Public Sub Reset ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Reset();" />
      <MemberSignature Language="F#" Value="abstract member Reset : unit -&gt; unit&#xA;override this.Reset : unit -&gt; unit" Usage="aceEnumerator.Reset " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IEnumerator.Reset</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Security.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Establece el enumerador en su posición inicial, que es antes del primer elemento de la colección <see cref="T:System.Security.AccessControl.GenericAce" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un enumerador es válido mientras la colección no cambie. Si, como agregar, modificar o eliminar elementos, se realiza en la colección, el enumerador queda invalidado permanentemente y la siguiente llamada a la <xref:System.Security.AccessControl.AceEnumerator.MoveNext%2A> método o la <xref:System.Security.AccessControl.AceEnumerator.Reset%2A> método produce una <xref:System.InvalidOperationException>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">La colección se modificó después de crear el enumerador.</exception>
        <block subset="none" type="overrides">
          <para>Todas las llamadas a <see cref="M:System.Security.AccessControl.AceEnumerator.Reset" /> debe producir el mismo estado para el enumerador. La implementación preferida es mover el enumerador al principio de la colección, antes del primer elemento. Esto invalida el enumerador si la colección se ha modificado desde que se creó el enumerador, que es coherente con <see cref="M:System.Security.AccessControl.AceEnumerator.MoveNext" /> y <see cref="P:System.Security.AccessControl.AceEnumerator.Current" />.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IEnumerator.Current">
      <MemberSignature Language="C#" Value="object System.Collections.IEnumerator.Current { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object System.Collections.IEnumerator.Current" />
      <MemberSignature Language="DocId" Value="P:System.Security.AccessControl.AceEnumerator.System#Collections#IEnumerator#Current" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property Current As Object Implements IEnumerator.Current" />
      <MemberSignature Language="C++ CLI" Value="property System::Object ^ System.Collections.IEnumerator.Current { System::Object ^ get(); };" />
      <MemberSignature Language="F#" Usage="System.Security.AccessControl.AceEnumerator.System.Collections.IEnumerator.Current" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.IEnumerator.Current</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Security.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene el elemento actual de la colección.</summary>
        <value>Devuelve el elemento actual de la colección.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Después de crea un enumerador o después de llamar a la <xref:System.Security.AccessControl.AceEnumerator.Reset%2A> método, debe llamar a la <xref:System.Security.AccessControl.AceEnumerator.MoveNext%2A> método para adelantar el enumerador hasta el primer elemento de la colección antes de leer el valor de <xref:System.Security.AccessControl.AceEnumerator.System%23Collections%23IEnumerator%23Current%2A>; en caso contrario, <xref:System.Security.AccessControl.AceEnumerator.System%23Collections%23IEnumerator%23Current%2A> no está definido .  
  
 <xref:System.Security.AccessControl.AceEnumerator.System%23Collections%23IEnumerator%23Current%2A> también produce una excepción si la última llamada a <xref:System.Security.AccessControl.AceEnumerator.MoveNext%2A> devuelve `false`, lo que indica el final de la colección.  
  
 <xref:System.Security.AccessControl.AceEnumerator.System%23Collections%23IEnumerator%23Current%2A> no mueve la posición del enumerador y las llamadas consecutivas a <xref:System.Security.AccessControl.AceEnumerator.System%23Collections%23IEnumerator%23Current%2A> devuelven el mismo objeto hasta que <xref:System.Security.AccessControl.AceEnumerator.MoveNext%2A> o <xref:System.Security.AccessControl.AceEnumerator.Reset%2A> se llama.  
  
 Un enumerador es válido mientras la colección no cambie. Si, como agregar, modificar o eliminar elementos, se realizan cambios a la colección, el enumerador queda invalidado permanentemente y la siguiente llamada a <xref:System.Security.AccessControl.AceEnumerator.MoveNext%2A> o <xref:System.Security.AccessControl.AceEnumerator.Reset%2A> produce una <xref:System.InvalidOperationException>. Si la colección se modifica entre <xref:System.Security.AccessControl.AceEnumerator.MoveNext%2A> y <xref:System.Security.AccessControl.AceEnumerator.System%23Collections%23IEnumerator%23Current%2A>, <xref:System.Security.AccessControl.AceEnumerator.System%23Collections%23IEnumerator%23Current%2A> devuelve el elemento que está establecido, aunque el enumerador ya haya quedado invalidado.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">La colección se modificó después de crear el enumerador.</exception>
      </Docs>
    </Member>
  </Members>
</Type>