<Type Name="MutexSecurity" FullName="System.Security.AccessControl.MutexSecurity">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="0a1640539b41709302d5991a6d062195e7d75c41" />
    <Meta Name="ms.sourcegitcommit" Value="0ec122ee5f3681159b8460ab15b409fd6e3d3ae0" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="es-ES" />
    <Meta Name="ms.lasthandoff" Value="10/04/2018" />
    <Meta Name="ms.locfileid" Value="48635322" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class MutexSecurity : System.Security.AccessControl.NativeObjectSecurity" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit MutexSecurity extends System.Security.AccessControl.NativeObjectSecurity" />
  <TypeSignature Language="DocId" Value="T:System.Security.AccessControl.MutexSecurity" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class MutexSecurity&#xA;Inherits NativeObjectSecurity" />
  <TypeSignature Language="C++ CLI" Value="public ref class MutexSecurity sealed : System::Security::AccessControl::NativeObjectSecurity" />
  <TypeSignature Language="F#" Value="type MutexSecurity = class&#xA;    inherit NativeObjectSecurity" />
  <AssemblyInfo>
    <AssemblyName>System.Threading.AccessControl</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.2.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Security.AccessControl.NativeObjectSecurity</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1">
      <AttributeName>System.Security.SecurityCritical</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Representa la seguridad de control de acceso de Windows para una exclusión mutua con nombre. Esta clase no puede heredarse.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un <xref:System.Security.AccessControl.MutexSecurity> objeto especifica los derechos de acceso para una exclusión mutua del sistema con nombre y también especifica cómo se auditan los intentos de acceso. Derechos de acceso a la exclusión mutua se expresan como reglas, con cada regla de acceso representada por un <xref:System.Security.AccessControl.MutexAccessRule> objeto. Cada regla de auditoría se representa mediante un <xref:System.Security.AccessControl.MutexAuditRule> objeto.  
  
 Esto refleja el sistema de seguridad de Windows subyacente, en el que cada objeto asegurable tiene a lo sumo un control lista de acceso discrecional (DACL) que controla el acceso al objeto protegido y, a lo sumo lista de control de acceso de un sistema (SACL) que especifica que el acceso se auditan los intentos. La DACL y SACL se ordenan las listas de entradas de control de acceso (ACE) que especifican el acceso y auditoría de los usuarios y grupos. Un <xref:System.Security.AccessControl.MutexAccessRule> o <xref:System.Security.AccessControl.MutexAuditRule> objeto podría representar más de una ACE.  
  
> [!NOTE]
>  Un <xref:System.Threading.Mutex> objeto puede representar una exclusión mutua local o una exclusión mutua del sistema con nombre. Seguridad de control de acceso de Windows solo es significativa para las exclusiones mutuas del sistema con nombre.  
  
 El <xref:System.Security.AccessControl.MutexSecurity>, <xref:System.Security.AccessControl.MutexAccessRule>, y <xref:System.Security.AccessControl.MutexAuditRule> clases ocultan los detalles de implementación de ACL y ACE. Le permiten pasar por alto los diferentes tipos ACE diecisiete y la complejidad de mantener correctamente la herencia y propagación de derechos de acceso. Estos objetos también están diseñados para evitar los errores de control de acceso comunes siguientes:  
  
-   Crear un descriptor de seguridad con una DACL null. Una referencia a una DACL null permite que cualquier usuario agregar reglas de acceso a un objeto, la posibilidad de crear un ataque de denegación de servicio. Un nuevo <xref:System.Security.AccessControl.MutexSecurity> objeto comienza siempre con una DACL vacía que deniega el acceso a todos los usuarios.  
  
-   Infringir la clasificación canónica de ACE. Si no se mantiene la lista ACE en la DACL en el orden canónico, los usuarios inadvertidamente se podrían dar acceso al objeto protegido. Por ejemplo, los derechos de acceso denegado siempre deben aparecer antes que los derechos de acceso permitido. <xref:System.Security.AccessControl.MutexSecurity> objetos mantienen internamente el orden correcto.  
  
-   Manipular las marcas de descriptor de seguridad, que deberían ser bajo el control del Administrador de recursos solo.  
  
-   Crear combinaciones no válidas de marcadores ACE.  
  
-   Manipular ACE heredadas. Herencia y propagación se controlan mediante el Administrador de recursos, en respuesta a cambios en las reglas de acceso y auditoría.  
  
-   Insertar ACE no tiene sentidas en las ACL.  
  
 Las únicas funciones no compatibles con los objetos de seguridad de .NET son actividades peligrosas que deben evitarse la mayoría de los desarrolladores de aplicaciones, como las siguientes:  
  
-   Tareas de bajo nivel que normalmente se realizan mediante el Administrador de recursos.  
  
-   Agregar o quitar entradas de control de acceso de maneras que no mantienen el orden canónico.  
  
 Para modificar la seguridad de control de acceso de Windows para una exclusión mutua con nombre, utilice el <xref:System.Threading.Mutex.GetAccessControl%2A?displayProperty=nameWithType> método para obtener el <xref:System.Security.AccessControl.MutexSecurity> objeto. Modificar el objeto de seguridad agregando y quitando las reglas y, a continuación, utilizar el <xref:System.Threading.Mutex.SetAccessControl%2A?displayProperty=nameWithType> método para volver a conectarlo.  
  
> [!IMPORTANT]
>  Cambios en un <xref:System.Security.AccessControl.MutexSecurity> objeto no afectan a los niveles de acceso de la exclusión mutua con nombre hasta que llame a la <xref:System.Threading.Mutex.SetAccessControl%2A?displayProperty=nameWithType> método para asignar el objeto de seguridad modificado a la exclusión mutua con nombre.  
  
 Para copiar la seguridad de control de acceso de exclusión mutua de uno a otro, utilice el <xref:System.Threading.Mutex.GetAccessControl%2A?displayProperty=nameWithType> método para obtener un <xref:System.Security.AccessControl.MutexSecurity> objeto que representa las reglas de acceso y auditoría para la exclusión mutua primera y, a continuación, utilice el <xref:System.Threading.Mutex.SetAccessControl%2A?displayProperty=nameWithType> método o constructor que acepta un <xref:System.Security.AccessControl.MutexSecurity>objeto, para asignar esas reglas a la exclusión mutua del segundo.  
  
 Los usuarios con una inversión en el lenguaje de definición de descriptores de seguridad (SDDL) pueden usar el <xref:System.Security.AccessControl.ObjectSecurity.SetSecurityDescriptorSddlForm%2A> método para establecer reglas de acceso para una exclusión mutua con nombre y el <xref:System.Security.AccessControl.ObjectSecurity.GetSecurityDescriptorSddlForm%2A> método para obtener una cadena que representa las reglas de acceso en formato SDDL. Esto no se recomienda para nuevo desarrollo.  
  
> [!NOTE]
>  Seguridad en objetos de sincronización no es compatible con Windows 98 o Windows Millennium Edition.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra la separación entre <xref:System.Security.AccessControl.AccessControlType.Allow> reglas y <xref:System.Security.AccessControl.AccessControlType.Deny> reglas y muestra la combinación de derechos de reglas compatibles. El ejemplo se crea un <xref:System.Security.AccessControl.MutexSecurity> objeto, agrega las reglas que conceden y deniegan derechos distintos para el usuario actual y muestra el par de reglas resultante. En el ejemplo, a continuación, permite nuevos derechos para el usuario actual y muestra el resultado, que muestra que los nuevos derechos se combinan con las existentes <xref:System.Security.AccessControl.AccessControlType.Allow> regla.  
  
> [!NOTE]
>  En este ejemplo no se adjunta el objeto de seguridad a un <xref:System.Threading.Mutex> objeto. Encontrará ejemplos donde se adjuntan los objetos de seguridad en <xref:System.Threading.Mutex.GetAccessControl%2A?displayProperty=nameWithType> y <xref:System.Threading.Mutex.SetAccessControl%2A?displayProperty=nameWithType>.  
  
 [!code-csharp[System.Security.AccessControl.MutexSecurity.AddAccessRule#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Security.AccessControl.MutexSecurity.AddAccessRule/CS/source.cs#1)]
 [!code-vb[System.Security.AccessControl.MutexSecurity.AddAccessRule#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Security.AccessControl.MutexSecurity.AddAccessRule/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Security.AccessControl.MutexAccessRule" />
    <altmember cref="T:System.Security.AccessControl.MutexAuditRule" />
    <altmember cref="T:System.Security.AccessControl.MutexRights" />
    <altmember cref="M:System.Threading.Mutex.GetAccessControl" />
    <altmember cref="M:System.Threading.Mutex.SetAccessControl(System.Security.AccessControl.MutexSecurity)" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Threading.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Security.AccessControl.MutexSecurity" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public MutexSecurity ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.AccessControl.MutexSecurity.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; MutexSecurity();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Security.AccessControl.MutexSecurity" /> con valores predeterminados.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un nuevo <xref:System.Security.AccessControl.MutexSecurity> objeto comienza siempre con una lista vacía de acceso discrecional (DACL), que se deniega el acceso a todos los usuarios.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Esta clase no se admite en Windows 98 ni en Windows Millennium Edition.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public MutexSecurity (string name, System.Security.AccessControl.AccessControlSections includeSections);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string name, valuetype System.Security.AccessControl.AccessControlSections includeSections) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.AccessControl.MutexSecurity.#ctor(System.String,System.Security.AccessControl.AccessControlSections)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (name As String, includeSections As AccessControlSections)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; MutexSecurity(System::String ^ name, System::Security::AccessControl::AccessControlSections includeSections);" />
      <MemberSignature Language="F#" Value="new System.Security.AccessControl.MutexSecurity : string * System.Security.AccessControl.AccessControlSections -&gt; System.Security.AccessControl.MutexSecurity" Usage="new System.Security.AccessControl.MutexSecurity (name, includeSections)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="includeSections" Type="System.Security.AccessControl.AccessControlSections" />
      </Parameters>
      <Docs>
        <param name="name">El nombre de la exclusión mutua de sistema cuyas reglas de seguridad de control de acceso se recuperarán.</param>
        <param name="includeSections">Una combinación de marcadores <see cref="T:System.Security.AccessControl.AccessControlSections" /> que especifica las secciones que se van a recuperar.</param>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Security.AccessControl.MutexSecurity" /> con las secciones especificadas de las reglas de seguridad de control de acceso de la exclusión mutua de sistema con el nombre especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este constructor permite obtener la seguridad de control de acceso para una exclusión mutua del sistema con nombre sin crear primero un <xref:System.Threading.Mutex> objeto.  
  
 Debe tener precaución cuando se trabaja con objetos del sistema con nombre. Si hay un objeto del sistema denominado `name` que no es una exclusión mutua, se podría recuperar su seguridad de control de acceso.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.FileNotFoundException">No hay ningún objeto de sistema con el nombre especificado.</exception>
        <exception cref="T:System.NotSupportedException">Esta clase no se admite en Windows 98 ni en Windows Millennium Edition.</exception>
      </Docs>
    </Member>
    <Member MemberName="AccessRightType">
      <MemberSignature Language="C#" Value="public override Type AccessRightType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type AccessRightType" />
      <MemberSignature Language="DocId" Value="P:System.Security.AccessControl.MutexSecurity.AccessRightType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property AccessRightType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property Type ^ AccessRightType { Type ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.AccessRightType : Type" Usage="System.Security.AccessControl.MutexSecurity.AccessRightType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene la enumeración que la clase <see cref="T:System.Security.AccessControl.MutexSecurity" /> utiliza para representar los derechos de acceso.</summary>
        <value>Objeto <see cref="T:System.Type" /> que representa la enumeración <see cref="T:System.Security.AccessControl.MutexRights" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Las clases que derivan de la <xref:System.Security.AccessControl.ObjectSecurity> clase invalidación el <xref:System.Security.AccessControl.ObjectSecurity.AccessRightType%2A> propiedad y devuelva el tipo que se utilizan para representar los derechos de acceso. Cuando se trabaja con matrices o colecciones que contienen varios tipos de objetos de seguridad, use esta propiedad para determinar el tipo de enumeración correctos para utilizar con cada objeto de seguridad.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AccessRuleFactory">
      <MemberSignature Language="C#" Value="public override System.Security.AccessControl.AccessRule AccessRuleFactory (System.Security.Principal.IdentityReference identityReference, int accessMask, bool isInherited, System.Security.AccessControl.InheritanceFlags inheritanceFlags, System.Security.AccessControl.PropagationFlags propagationFlags, System.Security.AccessControl.AccessControlType type);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Security.AccessControl.AccessRule AccessRuleFactory(class System.Security.Principal.IdentityReference identityReference, int32 accessMask, bool isInherited, valuetype System.Security.AccessControl.InheritanceFlags inheritanceFlags, valuetype System.Security.AccessControl.PropagationFlags propagationFlags, valuetype System.Security.AccessControl.AccessControlType type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.AccessControl.MutexSecurity.AccessRuleFactory(System.Security.Principal.IdentityReference,System.Int32,System.Boolean,System.Security.AccessControl.InheritanceFlags,System.Security.AccessControl.PropagationFlags,System.Security.AccessControl.AccessControlType)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Security::AccessControl::AccessRule ^ AccessRuleFactory(System::Security::Principal::IdentityReference ^ identityReference, int accessMask, bool isInherited, System::Security::AccessControl::InheritanceFlags inheritanceFlags, System::Security::AccessControl::PropagationFlags propagationFlags, System::Security::AccessControl::AccessControlType type);" />
      <MemberSignature Language="F#" Value="override this.AccessRuleFactory : System.Security.Principal.IdentityReference * int * bool * System.Security.AccessControl.InheritanceFlags * System.Security.AccessControl.PropagationFlags * System.Security.AccessControl.AccessControlType -&gt; System.Security.AccessControl.AccessRule" Usage="mutexSecurity.AccessRuleFactory (identityReference, accessMask, isInherited, inheritanceFlags, propagationFlags, type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.AccessControl.AccessRule</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="identityReference" Type="System.Security.Principal.IdentityReference" />
        <Parameter Name="accessMask" Type="System.Int32" />
        <Parameter Name="isInherited" Type="System.Boolean" />
        <Parameter Name="inheritanceFlags" Type="System.Security.AccessControl.InheritanceFlags" />
        <Parameter Name="propagationFlags" Type="System.Security.AccessControl.PropagationFlags" />
        <Parameter Name="type" Type="System.Security.AccessControl.AccessControlType" />
      </Parameters>
      <Docs>
        <param name="identityReference">Objeto <see cref="T:System.Security.Principal.IdentityReference" /> que identifica al usuario o grupo al que se aplica la regla.</param>
        <param name="accessMask">Combinación de valores <see cref="T:System.Security.AccessControl.MutexRights" /> bit a bit que especifica los derechos de acceso que se van a conceder o denegar, convertidos a un entero.</param>
        <param name="isInherited">No tiene sentido para las exclusiones mutuas con nombre porque no tienen ninguna jerarquía.</param>
        <param name="inheritanceFlags">No tiene sentido para las exclusiones mutuas con nombre porque no tienen ninguna jerarquía.</param>
        <param name="propagationFlags">No tiene sentido para las exclusiones mutuas con nombre porque no tienen ninguna jerarquía.</param>
        <param name="type">Uno de los valores de <see cref="T:System.Security.AccessControl.AccessControlType" /> que especifica si se conceden o deniegan los derechos.</param>
        <summary>Crea una nueva regla de control de acceso para el usuario indicado con los derechos de acceso, el control de acceso y los marcadores especificados.</summary>
        <returns>Objeto <see cref="T:System.Security.AccessControl.MutexAccessRule" /> que representa los derechos indicados para el usuario especificado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La manera recomendada para crear reglas de control de acceso es utilizar los constructores de la <xref:System.Security.AccessControl.MutexAccessRule> clase.  
  
> [!NOTE]
>  Aunque los marcadores de herencia y propagación tienen sentidos para las exclusiones mutuas, es posible especificarlos. No se recomienda porque lo innecesariamente complica el mantenimiento de reglas, por ejemplo al interferir con la combinación de reglas que estarían compatible.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="accessMask" />, <paramref name="inheritanceFlags" />, <paramref name="propagationFlags" /> o <paramref name="type" /> especifican un valor no válido.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="identityReference" /> es <see langword="null" />.  
  
O bien 
 <paramref name="accessMask" /> es cero.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="identityReference" /> no es de tipo <see cref="T:System.Security.Principal.SecurityIdentifier" />, ni de un tipo que, como <see cref="T:System.Security.Principal.NTAccount" />, se pueda convertir al tipo <see cref="T:System.Security.Principal.SecurityIdentifier" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="AccessRuleType">
      <MemberSignature Language="C#" Value="public override Type AccessRuleType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type AccessRuleType" />
      <MemberSignature Language="DocId" Value="P:System.Security.AccessControl.MutexSecurity.AccessRuleType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property AccessRuleType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property Type ^ AccessRuleType { Type ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.AccessRuleType : Type" Usage="System.Security.AccessControl.MutexSecurity.AccessRuleType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene el tipo que utiliza la clase <see cref="T:System.Security.AccessControl.MutexSecurity" /> para representar las reglas de acceso.</summary>
        <value>Objeto <see cref="T:System.Type" /> que representa la clase <see cref="T:System.Security.AccessControl.MutexAccessRule" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Las clases que derivan de la <xref:System.Security.AccessControl.ObjectSecurity> clase invalidación el <xref:System.Security.AccessControl.ObjectSecurity.AccessRuleType%2A> propiedad y devuelva el tipo que se utilizan para representar las reglas de acceso. Cuando se trabaja con matrices o colecciones que contienen varios tipos de objetos de seguridad, use esta propiedad para determinar el tipo de regla de acceso correcto a utilizar con cada objeto de seguridad.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddAccessRule">
      <MemberSignature Language="C#" Value="public void AddAccessRule (System.Security.AccessControl.MutexAccessRule rule);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddAccessRule(class System.Security.AccessControl.MutexAccessRule rule) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.AccessControl.MutexSecurity.AddAccessRule(System.Security.AccessControl.MutexAccessRule)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddAccessRule (rule As MutexAccessRule)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddAccessRule(System::Security::AccessControl::MutexAccessRule ^ rule);" />
      <MemberSignature Language="F#" Value="override this.AddAccessRule : System.Security.AccessControl.MutexAccessRule -&gt; unit" Usage="mutexSecurity.AddAccessRule rule" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rule" Type="System.Security.AccessControl.MutexAccessRule" />
      </Parameters>
      <Docs>
        <param name="rule">La regla de control de acceso que se va a agregar.</param>
        <summary>Busca una regla de control de acceso coincidente con la que se pueda combinar la nueva regla. Si no se encuentra ninguna, agrega la nueva regla.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Security.AccessControl.MutexSecurity.AddAccessRule%2A> método busca las reglas con el mismo usuario o grupo y el mismo <xref:System.Security.AccessControl.AccessControlType> como `rule`. Si se encuentra ninguna, `rule` se agrega. Si se encuentra una regla de coincidencia, los derechos en `rule` se combinan con la regla existente.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra la separación entre <xref:System.Security.AccessControl.AccessControlType.Allow> reglas y <xref:System.Security.AccessControl.AccessControlType.Deny> reglas y muestra la combinación de derechos de reglas compatibles. El ejemplo se crea un <xref:System.Security.AccessControl.MutexSecurity> objeto, agrega las reglas que conceden y deniegan derechos distintos para el usuario actual y muestra el par de reglas resultante. En el ejemplo, a continuación, permite nuevos derechos para el usuario actual y muestra el resultado, que muestra que los nuevos derechos se combinan con las existentes <xref:System.Security.AccessControl.AccessControlType.Allow> regla.  
  
> [!NOTE]
>  En este ejemplo no se adjunta el objeto de seguridad a un <xref:System.Threading.Mutex> objeto. Encontrará ejemplos donde se adjuntan los objetos de seguridad en <xref:System.Threading.Mutex.GetAccessControl%2A?displayProperty=nameWithType> <xref:System.Threading.Mutex.SetAccessControl%2A?displayProperty=nameWithType>.  
  
 [!code-csharp[System.Security.AccessControl.MutexSecurity.AddAccessRule#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Security.AccessControl.MutexSecurity.AddAccessRule/CS/source.cs#1)]
 [!code-vb[System.Security.AccessControl.MutexSecurity.AddAccessRule#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Security.AccessControl.MutexSecurity.AddAccessRule/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="rule" /> es <see langword="null" />.</exception>
        <exception cref="T:System.Security.Principal.IdentityNotMappedException">
          <paramref name="rule" /> no se puede asignar a una identidad conocida.</exception>
      </Docs>
    </Member>
    <Member MemberName="AddAuditRule">
      <MemberSignature Language="C#" Value="public void AddAuditRule (System.Security.AccessControl.MutexAuditRule rule);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddAuditRule(class System.Security.AccessControl.MutexAuditRule rule) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.AccessControl.MutexSecurity.AddAuditRule(System.Security.AccessControl.MutexAuditRule)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddAuditRule (rule As MutexAuditRule)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddAuditRule(System::Security::AccessControl::MutexAuditRule ^ rule);" />
      <MemberSignature Language="F#" Value="override this.AddAuditRule : System.Security.AccessControl.MutexAuditRule -&gt; unit" Usage="mutexSecurity.AddAuditRule rule" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rule" Type="System.Security.AccessControl.MutexAuditRule" />
      </Parameters>
      <Docs>
        <param name="rule">La regla de auditoría que se va a agregar. El usuario especificado por esta regla determina la búsqueda.</param>
        <summary>Busca una regla de auditoría con la que se pueda combinar la nueva regla. Si no se encuentra ninguna, agrega la nueva regla.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Security.AccessControl.MutexSecurity.AddAuditRule%2A> método busca las reglas con el mismo usuario o grupo que `rule`. Si se encuentra ninguna, `rule` se agrega. Si se encuentra una regla de coincidencia, las marcas en `rule` se combinan en una regla existente.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AuditRuleFactory">
      <MemberSignature Language="C#" Value="public override System.Security.AccessControl.AuditRule AuditRuleFactory (System.Security.Principal.IdentityReference identityReference, int accessMask, bool isInherited, System.Security.AccessControl.InheritanceFlags inheritanceFlags, System.Security.AccessControl.PropagationFlags propagationFlags, System.Security.AccessControl.AuditFlags flags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Security.AccessControl.AuditRule AuditRuleFactory(class System.Security.Principal.IdentityReference identityReference, int32 accessMask, bool isInherited, valuetype System.Security.AccessControl.InheritanceFlags inheritanceFlags, valuetype System.Security.AccessControl.PropagationFlags propagationFlags, valuetype System.Security.AccessControl.AuditFlags flags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.AccessControl.MutexSecurity.AuditRuleFactory(System.Security.Principal.IdentityReference,System.Int32,System.Boolean,System.Security.AccessControl.InheritanceFlags,System.Security.AccessControl.PropagationFlags,System.Security.AccessControl.AuditFlags)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Security::AccessControl::AuditRule ^ AuditRuleFactory(System::Security::Principal::IdentityReference ^ identityReference, int accessMask, bool isInherited, System::Security::AccessControl::InheritanceFlags inheritanceFlags, System::Security::AccessControl::PropagationFlags propagationFlags, System::Security::AccessControl::AuditFlags flags);" />
      <MemberSignature Language="F#" Value="override this.AuditRuleFactory : System.Security.Principal.IdentityReference * int * bool * System.Security.AccessControl.InheritanceFlags * System.Security.AccessControl.PropagationFlags * System.Security.AccessControl.AuditFlags -&gt; System.Security.AccessControl.AuditRule" Usage="mutexSecurity.AuditRuleFactory (identityReference, accessMask, isInherited, inheritanceFlags, propagationFlags, flags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.AccessControl.AuditRule</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="identityReference" Type="System.Security.Principal.IdentityReference" />
        <Parameter Name="accessMask" Type="System.Int32" />
        <Parameter Name="isInherited" Type="System.Boolean" />
        <Parameter Name="inheritanceFlags" Type="System.Security.AccessControl.InheritanceFlags" />
        <Parameter Name="propagationFlags" Type="System.Security.AccessControl.PropagationFlags" />
        <Parameter Name="flags" Type="System.Security.AccessControl.AuditFlags" />
      </Parameters>
      <Docs>
        <param name="identityReference">Objeto <see cref="T:System.Security.Principal.IdentityReference" /> que identifica al usuario o grupo al que se aplica la regla.</param>
        <param name="accessMask">Combinación de valores <see cref="T:System.Security.AccessControl.MutexRights" /> bit a bit que especifica los derechos de acceso que se van a auditar, convertidos a un entero.</param>
        <param name="isInherited">No tiene sentido para los marcadores de espera con nombre porque no tienen ninguna jerarquía.</param>
        <param name="inheritanceFlags">No tiene sentido para los marcadores de espera con nombre porque no tienen ninguna jerarquía.</param>
        <param name="propagationFlags">No tiene sentido para los marcadores de espera con nombre porque no tienen ninguna jerarquía.</param>
        <param name="flags">Una combinación bit a bit de valores <see cref="T:System.Security.AccessControl.AuditFlags" /> que especifica si el resultado de la operación auditada de acceso es de éxito, error o ambos.</param>
        <summary>Crea una nueva regla de auditoría, que especifica el usuario al que se aplica la regla, los derechos de acceso que se van a auditar y el resultado que desencadena la regla de auditoría.</summary>
        <returns>Objeto <see cref="T:System.Security.AccessControl.MutexAuditRule" /> que representa la regla de auditoría indicada para el usuario especificado. El tipo de valor devuelto del método es la clase base, <see cref="T:System.Security.AccessControl.AuditRule" />, pero el valor devuelto se puede convertir sin ningún riesgo a la clase derivada.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La manera recomendada para crear las reglas de auditoría es utilizar los constructores de la <xref:System.Security.AccessControl.MutexAuditRule> clase.  
  
> [!NOTE]
>  Aunque los marcadores de herencia y propagación tienen sentidos para las exclusiones mutuas, es posible especificarlos. No se recomienda porque lo innecesariamente complica el mantenimiento de reglas, por ejemplo al interferir con la combinación de reglas que estarían compatible.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="accessMask" />, <paramref name="inheritanceFlags" />, <paramref name="propagationFlags" /> o <paramref name="flags" /> especifican un valor no válido.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="identityReference" /> es <see langword="null" />.  
  
O bien 
 <paramref name="accessMask" /> es cero.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="identityReference" /> no es de tipo <see cref="T:System.Security.Principal.SecurityIdentifier" />, ni de un tipo que, como <see cref="T:System.Security.Principal.NTAccount" />, se pueda convertir al tipo <see cref="T:System.Security.Principal.SecurityIdentifier" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="AuditRuleType">
      <MemberSignature Language="C#" Value="public override Type AuditRuleType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type AuditRuleType" />
      <MemberSignature Language="DocId" Value="P:System.Security.AccessControl.MutexSecurity.AuditRuleType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property AuditRuleType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property Type ^ AuditRuleType { Type ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.AuditRuleType : Type" Usage="System.Security.AccessControl.MutexSecurity.AuditRuleType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene el tipo que utiliza la clase <see cref="T:System.Security.AccessControl.MutexSecurity" /> para representar las reglas de auditoría.</summary>
        <value>Objeto <see cref="T:System.Type" /> que representa la clase <see cref="T:System.Security.AccessControl.MutexAuditRule" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Las clases que derivan de la <xref:System.Security.AccessControl.ObjectSecurity> clase invalidación el <xref:System.Security.AccessControl.ObjectSecurity.AuditRuleType%2A> propiedad y devuelva el tipo que se utilizan para representar los derechos de auditoría. Cuando se trabaja con matrices o colecciones que contienen varios tipos de objetos de seguridad, use esta propiedad para determinar el tipo de regla de auditoría correcta para utilizar con cada objeto de seguridad.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RemoveAccessRule">
      <MemberSignature Language="C#" Value="public bool RemoveAccessRule (System.Security.AccessControl.MutexAccessRule rule);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool RemoveAccessRule(class System.Security.AccessControl.MutexAccessRule rule) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.AccessControl.MutexSecurity.RemoveAccessRule(System.Security.AccessControl.MutexAccessRule)" />
      <MemberSignature Language="VB.NET" Value="Public Function RemoveAccessRule (rule As MutexAccessRule) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool RemoveAccessRule(System::Security::AccessControl::MutexAccessRule ^ rule);" />
      <MemberSignature Language="F#" Value="override this.RemoveAccessRule : System.Security.AccessControl.MutexAccessRule -&gt; bool" Usage="mutexSecurity.RemoveAccessRule rule" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rule" Type="System.Security.AccessControl.MutexAccessRule" />
      </Parameters>
      <Docs>
        <param name="rule">
          <see cref="T:System.Security.AccessControl.MutexAccessRule" /> que especifica el usuario y <see cref="T:System.Security.AccessControl.AccessControlType" /> que se va a buscar y un conjunto de marcadores de herencia y propagación con los que una regla coincidente, si se encuentra, debe ser compatible. Especifica los derechos que se van a quitar de la regla compatible, si se encuentra.</param>
        <summary>Busca una regla de control de acceso con el mismo usuario y <see cref="T:System.Security.AccessControl.AccessControlType" /> (conceder o denegar) que la regla especificada y con marcadores de herencia y propagación compatibles; si encuentra este tipo de regla, quita de ésta los derechos contenidos en la regla de acceso especificada.</summary>
        <returns>Es <see langword="true" /> si se ha encontrado una regla compatible; en caso contrario, es <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Actual <xref:System.Security.AccessControl.MutexSecurity> se busca una regla que tenga el mismo usuario y el mismo <xref:System.Security.AccessControl.AccessControlType> valor como `rule`. Si no se encuentra ninguna de estas reglas, se realiza ninguna acción y el método devuelve `false`. Si se encuentran las reglas de coincidencia, se comprueban los marcadores de herencia y compatibilidad para la compatibilidad con las marcas especificadas en `rule`. Si se encuentra ninguna regla compatible, se realiza ninguna acción y el método devuelve `false`. Si se encuentra una regla con marcadores compatibles, los derechos especifican en `rule` se quitan de la regla compatible, y el método devuelve `true`. Si `rule` especifica los derechos no contenidos en la regla compatible, se realiza ninguna acción con respecto a dichos derechos. Si se quitan todos los derechos de la regla compatible, se quita la regla completa actual <xref:System.Security.AccessControl.MutexSecurity> objeto.  
  
> [!IMPORTANT]
>  Aunque puede especificar si se crean con marcadores de herencia y propagación para las reglas de acceso de exclusión mutua, el <xref:System.Security.AccessControl.MutexSecurity.AccessRuleFactory%2A> método, no se recomienda. Herencia y propagación no tienen ningún significado para exclusiones mutuas y realizan el mantenimiento de reglas de acceso más complicado.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra el uso de la <xref:System.Security.AccessControl.MutexSecurity.RemoveAccessRule%2A> método para quitar los derechos de un <xref:System.Security.AccessControl.AccessControlType.Allow> de regla en un <xref:System.Security.AccessControl.MutexSecurity> objeto. También muestra que otros derechos en `rule` se omiten.  
  
 El ejemplo se crea un <xref:System.Security.AccessControl.MutexSecurity> de objeto y se agregan reglas que conceden y deniegan diferentes derechos para el usuario actual. Los derechos permiten incluir <xref:System.Security.AccessControl.MutexRights.Modify>, <xref:System.Security.AccessControl.MutexRights.ReadPermissions>, y <xref:System.Security.AccessControl.MutexRights.Synchronize>. El ejemplo, a continuación, crea una nueva regla para el usuario actual, incluidos <xref:System.Security.AccessControl.MutexRights.ReadPermissions> y <xref:System.Security.AccessControl.MutexRights.TakeOwnership> derechos y utiliza esa regla con el <xref:System.Security.AccessControl.MutexSecurity.RemoveAccessRule%2A> método para quitar <xref:System.Security.AccessControl.MutexRights.ReadPermissions> desde el <xref:System.Security.AccessControl.AccessControlType.Allow> de regla en el <xref:System.Security.AccessControl.MutexSecurity> objeto. El extraños <xref:System.Security.AccessControl.MutexRights.TakeOwnership> directamente en `rule` se omite.  
  
> [!NOTE]
>  En este ejemplo no se adjunta el objeto de seguridad a un <xref:System.Threading.Mutex> objeto. Encontrará ejemplos donde se adjuntan los objetos de seguridad en <xref:System.Threading.Mutex.GetAccessControl%2A?displayProperty=nameWithType> y <xref:System.Threading.Mutex.SetAccessControl%2A?displayProperty=nameWithType>.  
  
 [!code-csharp[System.Security.AccessControl.MutexSecurity.RemoveAccessRule#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Security.AccessControl.MutexSecurity.RemoveAccessRule/CS/source.cs#1)]
 [!code-vb[System.Security.AccessControl.MutexSecurity.RemoveAccessRule#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Security.AccessControl.MutexSecurity.RemoveAccessRule/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="rule" /> es <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="RemoveAccessRuleAll">
      <MemberSignature Language="C#" Value="public void RemoveAccessRuleAll (System.Security.AccessControl.MutexAccessRule rule);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RemoveAccessRuleAll(class System.Security.AccessControl.MutexAccessRule rule) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.AccessControl.MutexSecurity.RemoveAccessRuleAll(System.Security.AccessControl.MutexAccessRule)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RemoveAccessRuleAll (rule As MutexAccessRule)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RemoveAccessRuleAll(System::Security::AccessControl::MutexAccessRule ^ rule);" />
      <MemberSignature Language="F#" Value="override this.RemoveAccessRuleAll : System.Security.AccessControl.MutexAccessRule -&gt; unit" Usage="mutexSecurity.RemoveAccessRuleAll rule" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rule" Type="System.Security.AccessControl.MutexAccessRule" />
      </Parameters>
      <Docs>
        <param name="rule">
          <see cref="T:System.Security.AccessControl.MutexAccessRule" /> que especifica el usuario y <see cref="T:System.Security.AccessControl.AccessControlType" /> que se va a buscar. Se pasa por alto cualquier derecho especificado por esta regla.</param>
        <summary>Busca todas las reglas de control de acceso con el mismo usuario y <see cref="T:System.Security.AccessControl.AccessControlType" /> (conceder o denegar) que la regla especificada y, si las encuentra, las quita.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Actual <xref:System.Security.AccessControl.MutexSecurity> se busca el objeto para las reglas que tienen el mismo usuario y el mismo <xref:System.Security.AccessControl.AccessControlType> valor como `rule`. Los derechos especificados por `rule` se omiten al realizar esta búsqueda. Si no se encuentra ninguna regla coincidente, se realiza ninguna acción.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra que el <xref:System.Security.AccessControl.MutexSecurity.RemoveAccessRuleAll%2A> método quita todas las reglas que coinciden con el usuario y <xref:System.Security.AccessControl.AccessControlType>, omitiendo los derechos.  
  
 El ejemplo se crea un <xref:System.Security.AccessControl.MutexSecurity> objeto, se agregan reglas que conceden y deniegan diferentes derechos para el usuario actual y, a continuación, combinan derechos adicionales en el <xref:System.Security.AccessControl.AccessControlType.Allow> regla. El ejemplo, a continuación, crea una nueva regla que permite al usuario actual tomar posesión y utiliza esa regla para quitar el <xref:System.Security.AccessControl.AccessControlType.Allow> regla desde el <xref:System.Security.AccessControl.MutexSecurity> objeto.  
  
> [!NOTE]
>  En este ejemplo no se adjunta el objeto de seguridad a un <xref:System.Threading.Mutex> objeto. Encontrará ejemplos donde se adjuntan los objetos de seguridad en <xref:System.Threading.Mutex.GetAccessControl%2A?displayProperty=nameWithType> y <xref:System.Threading.Mutex.SetAccessControl%2A?displayProperty=nameWithType>.  
  
 [!code-csharp[System.Security.AccessControl.MutexSecurity.RemoveAccessRuleAll#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Security.AccessControl.MutexSecurity.RemoveAccessRuleAll/CS/source.cs#1)]
 [!code-vb[System.Security.AccessControl.MutexSecurity.RemoveAccessRuleAll#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Security.AccessControl.MutexSecurity.RemoveAccessRuleAll/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="rule" /> es <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="RemoveAccessRuleSpecific">
      <MemberSignature Language="C#" Value="public void RemoveAccessRuleSpecific (System.Security.AccessControl.MutexAccessRule rule);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RemoveAccessRuleSpecific(class System.Security.AccessControl.MutexAccessRule rule) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.AccessControl.MutexSecurity.RemoveAccessRuleSpecific(System.Security.AccessControl.MutexAccessRule)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RemoveAccessRuleSpecific (rule As MutexAccessRule)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RemoveAccessRuleSpecific(System::Security::AccessControl::MutexAccessRule ^ rule);" />
      <MemberSignature Language="F#" Value="override this.RemoveAccessRuleSpecific : System.Security.AccessControl.MutexAccessRule -&gt; unit" Usage="mutexSecurity.RemoveAccessRuleSpecific rule" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rule" Type="System.Security.AccessControl.MutexAccessRule" />
      </Parameters>
      <Docs>
        <param name="rule">
          <see cref="T:System.Security.AccessControl.MutexAccessRule" /> que se va a quitar.</param>
        <summary>Busca una regla de control de acceso que coincida exactamente con la regla especificada y, si la encuentra, la quita.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La regla se quitarán solo si coincide exactamente con `rule` en todos los detalles, incluidas marcas. Otras reglas con el mismo usuario y <xref:System.Security.AccessControl.AccessControlType> no se ven afectados.  
  
> [!IMPORTANT]
>  Una regla representa una o más entradas de control de acceso (ACE) subyacentes y estas entradas se dividen o se combinan según sea necesario cuando se modifican las reglas de seguridad de acceso para un usuario. Por lo tanto, una regla que ya no exista en la forma concreta que tenía cuando se agregó y, en ese caso el <xref:System.Security.AccessControl.MutexSecurity.RemoveAccessRuleSpecific%2A> método no puede quitarla.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra que el <xref:System.Security.AccessControl.MutexSecurity.RemoveAccessRuleSpecific%2A> método requiere una coincidencia exacta para quitar una regla, y las reglas para permitir o denegar los derechos son independientes entre sí.  
  
 El ejemplo se crea un <xref:System.Security.AccessControl.MutexSecurity> objeto, se agregan reglas que conceden y deniegan diferentes derechos para el usuario actual y, a continuación, combinan derechos adicionales en el <xref:System.Security.AccessControl.AccessControlType.Allow> regla de acceso. El ejemplo a continuación, pasa el original <xref:System.Security.AccessControl.AccessControlType.Allow> de regla para el <xref:System.Security.AccessControl.MutexSecurity.RemoveAccessRuleSpecific%2A> método y muestra los resultados, que muestra que nada se ha eliminado. El ejemplo, a continuación, crea una regla que coincide con el <xref:System.Security.AccessControl.AccessControlType.Allow> de regla en el <xref:System.Security.AccessControl.MutexSecurity> objeto y correctamente se usa el <xref:System.Security.AccessControl.MutexSecurity.RemoveAccessRuleSpecific%2A> método para quitar la regla.  
  
> [!NOTE]
>  En este ejemplo no se adjunta el objeto de seguridad a un <xref:System.Threading.Mutex> objeto. Encontrará ejemplos donde se adjuntan los objetos de seguridad en <xref:System.Threading.Mutex.GetAccessControl%2A?displayProperty=nameWithType> y <xref:System.Threading.Mutex.SetAccessControl%2A?displayProperty=nameWithType>.  
  
 [!code-csharp[System.Security.AccessControl.MutexSecurity.RemoveAccessRuleSpecific#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Security.AccessControl.MutexSecurity.RemoveAccessRuleSpecific/CS/source.cs#1)]
 [!code-vb[System.Security.AccessControl.MutexSecurity.RemoveAccessRuleSpecific#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Security.AccessControl.MutexSecurity.RemoveAccessRuleSpecific/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="rule" /> es <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="RemoveAuditRule">
      <MemberSignature Language="C#" Value="public bool RemoveAuditRule (System.Security.AccessControl.MutexAuditRule rule);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool RemoveAuditRule(class System.Security.AccessControl.MutexAuditRule rule) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.AccessControl.MutexSecurity.RemoveAuditRule(System.Security.AccessControl.MutexAuditRule)" />
      <MemberSignature Language="VB.NET" Value="Public Function RemoveAuditRule (rule As MutexAuditRule) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool RemoveAuditRule(System::Security::AccessControl::MutexAuditRule ^ rule);" />
      <MemberSignature Language="F#" Value="override this.RemoveAuditRule : System.Security.AccessControl.MutexAuditRule -&gt; bool" Usage="mutexSecurity.RemoveAuditRule rule" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rule" Type="System.Security.AccessControl.MutexAuditRule" />
      </Parameters>
      <Docs>
        <param name="rule">
          <see cref="T:System.Security.AccessControl.MutexAuditRule" /> que especifica el usuario que se va a buscar y un conjunto de marcadores de herencia y propagación con los que una regla coincidente, si se encuentra, debe ser compatible. Especifica los derechos que se van a quitar de la regla compatible, si se encuentra.</param>
        <summary>Busca una regla de control de auditoría con el mismo usuario que la regla especificada y con marcadores de herencia y propagación compatibles; si encuentra una regla compatible, quita de ésta los derechos contenidos en la regla especificada.</summary>
        <returns>
          <see langword="true" /> si se ha encontrado una regla compatible; en caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Actual <xref:System.Security.AccessControl.MutexSecurity> se busca una regla de auditoría que tenga el mismo usuario que `rule`. Si no se encuentra ninguna de estas reglas, se realiza ninguna acción y el método devuelve `false`. Si se encuentran las reglas de coincidencia, se comprueban los marcadores de herencia y compatibilidad para la compatibilidad con las marcas especificadas en `rule`. Si se encuentra ninguna regla compatible, se realiza ninguna acción y el método devuelve `false`. Si se encuentra una regla con marcadores compatibles, los derechos especifican en `rule` se quitan de la regla compatible, y el método devuelve `true`. Si `rule` especifica los derechos no contenidos en la regla compatible, se realiza ninguna acción con respecto a dichos derechos. Si se quitan todos los derechos de la regla compatible, se quita la regla completa actual <xref:System.Security.AccessControl.MutexSecurity> objeto.  
  
> [!IMPORTANT]
>  Aunque puede especificar si se crean con marcadores de herencia y propagación para las reglas de auditoría de exclusión mutua, el <xref:System.Security.AccessControl.MutexSecurity.AccessRuleFactory%2A> método, no se recomienda. Herencia y propagación no tienen ningún significado para exclusiones mutuas y realizan el mantenimiento de las reglas de auditoría más complicado.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="rule" /> es <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="RemoveAuditRuleAll">
      <MemberSignature Language="C#" Value="public void RemoveAuditRuleAll (System.Security.AccessControl.MutexAuditRule rule);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RemoveAuditRuleAll(class System.Security.AccessControl.MutexAuditRule rule) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.AccessControl.MutexSecurity.RemoveAuditRuleAll(System.Security.AccessControl.MutexAuditRule)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RemoveAuditRuleAll (rule As MutexAuditRule)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RemoveAuditRuleAll(System::Security::AccessControl::MutexAuditRule ^ rule);" />
      <MemberSignature Language="F#" Value="override this.RemoveAuditRuleAll : System.Security.AccessControl.MutexAuditRule -&gt; unit" Usage="mutexSecurity.RemoveAuditRuleAll rule" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rule" Type="System.Security.AccessControl.MutexAuditRule" />
      </Parameters>
      <Docs>
        <param name="rule">
          <see cref="T:System.Security.AccessControl.MutexAuditRule" /> que especifica el usuario que se va a buscar. Se pasa por alto cualquier derecho especificado por esta regla.</param>
        <summary>Busca todas las reglas de auditoría con el mismo usuario que la regla especificada y, si las encuentra, las quita.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Actual <xref:System.Security.AccessControl.MutexSecurity> se busca en las reglas de auditoría que tienen el mismo usuario que `rule`. Los derechos especificados por `rule` se omiten al realizar esta búsqueda. Se quitan todas las reglas coincidentes. Si no se encuentra ninguna regla coincidente, se realiza ninguna acción.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="rule" /> es <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="RemoveAuditRuleSpecific">
      <MemberSignature Language="C#" Value="public void RemoveAuditRuleSpecific (System.Security.AccessControl.MutexAuditRule rule);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RemoveAuditRuleSpecific(class System.Security.AccessControl.MutexAuditRule rule) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.AccessControl.MutexSecurity.RemoveAuditRuleSpecific(System.Security.AccessControl.MutexAuditRule)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RemoveAuditRuleSpecific (rule As MutexAuditRule)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RemoveAuditRuleSpecific(System::Security::AccessControl::MutexAuditRule ^ rule);" />
      <MemberSignature Language="F#" Value="override this.RemoveAuditRuleSpecific : System.Security.AccessControl.MutexAuditRule -&gt; unit" Usage="mutexSecurity.RemoveAuditRuleSpecific rule" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rule" Type="System.Security.AccessControl.MutexAuditRule" />
      </Parameters>
      <Docs>
        <param name="rule">
          <see cref="T:System.Security.AccessControl.MutexAuditRule" /> que se va a quitar.</param>
        <summary>Busca una regla de auditoría que coincida exactamente con la regla especificada y, si la encuentra, la quita.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La regla se quitarán solo si coincide exactamente con `rule` en todos los detalles, incluidas marcas. No se ven afectadas otras reglas de auditoría para el mismo usuario.  
  
> [!IMPORTANT]
>  Una regla representa una o más entradas de control de acceso (ACE) subyacentes y estas entradas se dividen o se combinan según sea necesario cuando se modifican las reglas de seguridad de auditoría para un usuario. Por lo tanto, una regla que ya no exista en la forma concreta que tenía cuando se agregó y, en ese caso el <xref:System.Security.AccessControl.MutexSecurity.RemoveAuditRuleSpecific%2A> método no puede quitarla.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="rule" /> es <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ResetAccessRule">
      <MemberSignature Language="C#" Value="public void ResetAccessRule (System.Security.AccessControl.MutexAccessRule rule);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ResetAccessRule(class System.Security.AccessControl.MutexAccessRule rule) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.AccessControl.MutexSecurity.ResetAccessRule(System.Security.AccessControl.MutexAccessRule)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ResetAccessRule (rule As MutexAccessRule)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ResetAccessRule(System::Security::AccessControl::MutexAccessRule ^ rule);" />
      <MemberSignature Language="F#" Value="override this.ResetAccessRule : System.Security.AccessControl.MutexAccessRule -&gt; unit" Usage="mutexSecurity.ResetAccessRule rule" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rule" Type="System.Security.AccessControl.MutexAccessRule" />
      </Parameters>
      <Docs>
        <param name="rule">
          <see cref="T:System.Security.AccessControl.MutexAccessRule" /> que se va a agregar. El usuario especificado por esta regla determina las reglas que se van a quitar antes de agregar esta regla.</param>
        <summary>Quita todas las reglas de control de acceso con el mismo usuario que la regla especificada, independientemente de <see cref="T:System.Security.AccessControl.AccessControlType" />, y, a continuación, agrega la regla especificada.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si no hay ninguna regla de acceso cuyo usuario coincide con la regla especificada, `rule` se agrega.  
  
   
  
## Examples  
 El siguiente ejemplo de código muestra cómo el <xref:System.Security.AccessControl.MutexSecurity.ResetAccessRule%2A> método reemplaza todas las reglas de usuario coincidentes con la regla especificada para la coincidencia.  
  
 El ejemplo se crea un <xref:System.Security.AccessControl.MutexSecurity> de objeto y se agregan reglas que conceden y deniegan diferentes derechos para el usuario actual. El ejemplo, a continuación, crea una nueva regla que permite el control completo del usuario actual y usa el <xref:System.Security.AccessControl.MutexSecurity.ResetAccessRule%2A> método para reemplazar dos de las reglas existentes con la nueva regla.  
  
> [!NOTE]
>  En este ejemplo no se adjunta el objeto de seguridad a un <xref:System.Threading.Mutex> objeto. Encontrará ejemplos donde se adjuntan los objetos de seguridad en <xref:System.Threading.Mutex.GetAccessControl%2A?displayProperty=nameWithType> y <xref:System.Threading.Mutex.SetAccessControl%2A?displayProperty=nameWithType>.  
  
 [!code-csharp[System.Security.AccessControl.MutexSecurity.ResetAccessRule#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Security.AccessControl.MutexSecurity.ResetAccessRule/CS/source.cs#1)]
 [!code-vb[System.Security.AccessControl.MutexSecurity.ResetAccessRule#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Security.AccessControl.MutexSecurity.ResetAccessRule/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="rule" /> es <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="SetAccessRule">
      <MemberSignature Language="C#" Value="public void SetAccessRule (System.Security.AccessControl.MutexAccessRule rule);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetAccessRule(class System.Security.AccessControl.MutexAccessRule rule) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.AccessControl.MutexSecurity.SetAccessRule(System.Security.AccessControl.MutexAccessRule)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetAccessRule (rule As MutexAccessRule)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetAccessRule(System::Security::AccessControl::MutexAccessRule ^ rule);" />
      <MemberSignature Language="F#" Value="override this.SetAccessRule : System.Security.AccessControl.MutexAccessRule -&gt; unit" Usage="mutexSecurity.SetAccessRule rule" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rule" Type="System.Security.AccessControl.MutexAccessRule" />
      </Parameters>
      <Docs>
        <param name="rule">
          <see cref="T:System.Security.AccessControl.MutexAccessRule" /> que se va a agregar. El usuario y el objeto <see cref="T:System.Security.AccessControl.AccessControlType" /> de esta regla determinan las reglas que se van a quitar antes de agregar esta regla.</param>
        <summary>Quita todas las reglas de control de acceso con el mismo usuario y <see cref="T:System.Security.AccessControl.AccessControlType" /> (conceder o denegar) que la regla especificada y, a continuación, agrega la regla especificada.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si la regla especificada tiene <xref:System.Security.AccessControl.AccessControlType.Allow>, es el efecto de este método quitar todos los <xref:System.Security.AccessControl.AccessControlType.Allow> reglas para el usuario especificado, reemplazándolos por la regla especificada. Si la regla especificada tiene <xref:System.Security.AccessControl.AccessControlType.Deny>, todos los <xref:System.Security.AccessControl.AccessControlType.Deny> reglas para el usuario especificado se reemplazan por la regla especificada.  
  
 Si no hay ninguna regla cuyo usuario y <xref:System.Security.AccessControl.AccessControlType> coincide con la regla especificada, `rule` se agrega.  
  
   
  
## Examples  
 El siguiente ejemplo de código muestra cómo el <xref:System.Security.AccessControl.MutexSecurity.SetAccessRule%2A> método quita todas las reglas que coinciden con el usuario y la <xref:System.Security.AccessControl.AccessControlType> de `rule`, reemplazarlos con `rule`.  
  
 El ejemplo se crea un <xref:System.Security.AccessControl.MutexSecurity> de objeto y se agregan reglas que conceden y deniegan diferentes derechos para el usuario actual. El ejemplo, a continuación, crea una nueva regla que permite el control completo del usuario actual y usa el <xref:System.Security.AccessControl.MutexSecurity.SetAccessRule%2A> regla con la nueva regla de permiso de método para reemplazar el existente. No se ve afectada la regla que deniegue el acceso.  
  
> [!NOTE]
>  En este ejemplo no se adjunta el objeto de seguridad a un <xref:System.Threading.Mutex> objeto. Encontrará ejemplos donde se adjuntan los objetos de seguridad en <xref:System.Threading.Mutex.GetAccessControl%2A?displayProperty=nameWithType> y <xref:System.Threading.Mutex.SetAccessControl%2A?displayProperty=nameWithType>.  
  
 [!code-csharp[System.Security.AccessControl.MutexSecurity.SetAccessRule#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Security.AccessControl.MutexSecurity.SetAccessRule/CS/source.cs#1)]
 [!code-vb[System.Security.AccessControl.MutexSecurity.SetAccessRule#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Security.AccessControl.MutexSecurity.SetAccessRule/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="rule" /> es <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="SetAuditRule">
      <MemberSignature Language="C#" Value="public void SetAuditRule (System.Security.AccessControl.MutexAuditRule rule);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetAuditRule(class System.Security.AccessControl.MutexAuditRule rule) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.AccessControl.MutexSecurity.SetAuditRule(System.Security.AccessControl.MutexAuditRule)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetAuditRule (rule As MutexAuditRule)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetAuditRule(System::Security::AccessControl::MutexAuditRule ^ rule);" />
      <MemberSignature Language="F#" Value="override this.SetAuditRule : System.Security.AccessControl.MutexAuditRule -&gt; unit" Usage="mutexSecurity.SetAuditRule rule" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rule" Type="System.Security.AccessControl.MutexAuditRule" />
      </Parameters>
      <Docs>
        <param name="rule">
          <see cref="T:System.Security.AccessControl.MutexAuditRule" /> que se va a agregar. El usuario especificado por esta regla determina las reglas que se van a quitar antes de agregar esta regla.</param>
        <summary>Quita todas las reglas de auditoría con el mismo usuario que la regla especificada, sin tener en cuenta el valor de <see cref="T:System.Security.AccessControl.AuditFlags" />, y, a continuación, agrega la regla especificada.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si no hay ninguna regla de auditoría cuyo usuario coincide con la regla especificada, `rule` se agrega.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="rule" /> es <see langword="null" />.</exception>
      </Docs>
    </Member>
  </Members>
</Type>