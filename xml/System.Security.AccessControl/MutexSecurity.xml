<Type Name="MutexSecurity" FullName="System.Security.AccessControl.MutexSecurity">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="32296db222ea6141fe27393ef3e6f899d0231f0f" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="es-ES" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
    <Meta Name="ms.locfileid" Value="30490679" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class MutexSecurity : System.Security.AccessControl.NativeObjectSecurity" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit MutexSecurity extends System.Security.AccessControl.NativeObjectSecurity" />
  <TypeSignature Language="DocId" Value="T:System.Security.AccessControl.MutexSecurity" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class MutexSecurity&#xA;Inherits NativeObjectSecurity" />
  <TypeSignature Language="C++ CLI" Value="public ref class MutexSecurity sealed : System::Security::AccessControl::NativeObjectSecurity" />
  <AssemblyInfo>
    <AssemblyName>System.Threading.AccessControl</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.2.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Security.AccessControl.NativeObjectSecurity</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Representa la seguridad de control de acceso de Windows para una exclusión mutua con nombre. Esta clase no puede heredarse.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un <xref:System.Security.AccessControl.MutexSecurity> objeto especifica los derechos de acceso para una exclusión mutua del sistema con nombre y también especifica cómo se auditan los intentos de acceso. Derechos de acceso a la exclusión mutua se expresan como reglas, con cada regla de acceso representada por un <xref:System.Security.AccessControl.MutexAccessRule> objeto. Cada regla de auditoría se representa mediante un <xref:System.Security.AccessControl.MutexAuditRule> objeto.  
  
 Esto refleja el sistema de seguridad subyacente de Windows, en el que cada objeto asegurable tiene al menos un control lista de acceso discrecional (DACL) que controla el acceso al objeto protegido y a lo sumo un acceso lista de control sistema (SACL) que especifica qué intentos de acceso se auditan. La lista DACL y SACL son listas ordenadas de entradas de control de acceso (ACE) que especifican el acceso y auditoría para usuarios y grupos. A <xref:System.Security.AccessControl.MutexAccessRule> o <xref:System.Security.AccessControl.MutexAuditRule> objeto podría representar más de una ACE.  
  
> [!NOTE]
>  Un <xref:System.Threading.Mutex> objeto puede representar una exclusión mutua local o una exclusión mutua del sistema con nombre. Seguridad de control de acceso de Windows sólo es significativa para las exclusiones mutuas del sistema con nombre.  
  
 El <xref:System.Security.AccessControl.MutexSecurity>, <xref:System.Security.AccessControl.MutexAccessRule>, y <xref:System.Security.AccessControl.MutexAuditRule> clases ocultan los detalles de implementación de ACL y ACE. Le permiten pasar por alto los distintos tipos ACE diecisiete y la complejidad de mantener correctamente la herencia y la propagación de derechos de acceso. Estos objetos también están diseñados para evitar los errores de control de acceso comunes siguientes:  
  
-   Crear un descriptor de seguridad con una DACL null. Una referencia nula a una DACL permite a cualquier usuario agregar reglas de acceso a un objeto, podría crear un ataque de denegación de servicio. Un nuevo <xref:System.Security.AccessControl.MutexSecurity> objeto siempre se inicia con una DACL vacía que deniega el acceso a todos los usuarios.  
  
-   Infringir la clasificación canónica de ACE. Si la lista ACE en la DACL no se mantiene en el orden canónico, los usuarios sin darse cuenta pueden concederse acceso al objeto protegido. Por ejemplo, los derechos de acceso denegado siempre deben aparecer antes que los derechos de acceso permitido. <xref:System.Security.AccessControl.MutexSecurity> objetos mantienen el orden interno correcto.  
  
-   La manipulación de marcas de descriptor de seguridad que deberían estar bajo el control del Administrador de recursos solo.  
  
-   Crear combinaciones no válidas de indicadores ACE.  
  
-   Manipular heredadas. Herencia y la propagación se controlan mediante el Administrador de recursos, en respuesta a los cambios realizados en las reglas de acceso y auditoría.  
  
-   Insertar ACE sin sentido en ACL.  
  
 Las únicas funciones no admitidas por los objetos de seguridad de .NET son actividades peligrosas que deben evitarse la mayoría de los desarrolladores de aplicaciones, como las siguientes:  
  
-   Tareas de bajo nivel que normalmente se realizan mediante el Administrador de recursos.  
  
-   Agregar o quitar entradas de control de acceso de maneras que no mantienen el orden canónico.  
  
 Para modificar la seguridad de control de acceso de Windows para una exclusión mutua con nombre, utilice el <xref:System.Threading.Mutex.GetAccessControl%2A?displayProperty=nameWithType> método para obtener la <xref:System.Security.AccessControl.MutexSecurity> objeto. Modificar el objeto de seguridad agregando y quitando las reglas y, a continuación, utilizar el <xref:System.Threading.Mutex.SetAccessControl%2A?displayProperty=nameWithType> método para adjuntarla.  
  
> [!IMPORTANT]
>  Cambios realizados en un <xref:System.Security.AccessControl.MutexSecurity> objeto no afectan a los niveles de acceso de la exclusión mutua con nombre hasta que llame a la <xref:System.Threading.Mutex.SetAccessControl%2A?displayProperty=nameWithType> método para asignar el objeto de seguridad alterado a la exclusión mutua con nombre.  
  
 Para copiar la seguridad de control de acceso de una exclusión mutua a otra, utilice la <xref:System.Threading.Mutex.GetAccessControl%2A?displayProperty=nameWithType> método para obtener un <xref:System.Security.AccessControl.MutexSecurity> objeto que representa las reglas de acceso y auditoría para la exclusión mutua primera y, a continuación, use la <xref:System.Threading.Mutex.SetAccessControl%2A?displayProperty=nameWithType> método o un constructor que acepta un <xref:System.Security.AccessControl.MutexSecurity> objeto, para asignar esas reglas a la exclusión mutua del segundo.  
  
 Los usuarios con una inversión en el lenguaje de definición de descriptores de seguridad (SDDL) pueden utilizar el <xref:System.Security.AccessControl.ObjectSecurity.SetSecurityDescriptorSddlForm%2A> método para establecer reglas de acceso para una exclusión mutua con nombre y el <xref:System.Security.AccessControl.ObjectSecurity.GetSecurityDescriptorSddlForm%2A> método para obtener una cadena que representa las reglas de acceso en formato SDDL. Esto no se recomienda para nuevo desarrollo.  
  
> [!NOTE]
>  No se admite la seguridad en objetos de sincronización de Windows 98 o Windows Millennium Edition.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra la separación entre <xref:System.Security.AccessControl.AccessControlType.Allow> reglas y <xref:System.Security.AccessControl.AccessControlType.Deny> reglas y muestra la combinación de derechos de reglas compatibles. El ejemplo se crea un <xref:System.Security.AccessControl.MutexSecurity> objeto, se agregan reglas que conceden y deniegan diferentes derechos al usuario actual y muestra el par de reglas resultante. En el ejemplo, a continuación, permite nuevos derechos para el usuario actual y muestra el resultado, que muestra que los nuevos derechos se combinan con las existentes <xref:System.Security.AccessControl.AccessControlType.Allow> regla.  
  
> [!NOTE]
>  Este ejemplo no adjunta el objeto de seguridad a un <xref:System.Threading.Mutex> objeto. Encontrará ejemplos donde se adjuntan objetos de seguridad en <xref:System.Threading.Mutex.GetAccessControl%2A?displayProperty=nameWithType> y <xref:System.Threading.Mutex.SetAccessControl%2A?displayProperty=nameWithType>.  
  
 [!code-csharp[System.Security.AccessControl.MutexSecurity.AddAccessRule#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Security.AccessControl.MutexSecurity.AddAccessRule/CS/source.cs#1)]
 [!code-vb[System.Security.AccessControl.MutexSecurity.AddAccessRule#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Security.AccessControl.MutexSecurity.AddAccessRule/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Security.AccessControl.MutexAccessRule" />
    <altmember cref="T:System.Security.AccessControl.MutexAuditRule" />
    <altmember cref="T:System.Security.AccessControl.MutexRights" />
    <altmember cref="M:System.Threading.Mutex.GetAccessControl" />
    <altmember cref="M:System.Threading.Mutex.SetAccessControl(System.Security.AccessControl.MutexSecurity)" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Threading.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Security.AccessControl.MutexSecurity" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public MutexSecurity ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.AccessControl.MutexSecurity.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; MutexSecurity();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Security.AccessControl.MutexSecurity" /> con valores predeterminados.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un nuevo <xref:System.Security.AccessControl.MutexSecurity> objeto siempre se inicia con una lista vacía de acceso discrecional (DACL), que se deniega el acceso a todos los usuarios.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Esta clase no se admite en Windows 98 ni en Windows Millennium Edition.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public MutexSecurity (string name, System.Security.AccessControl.AccessControlSections includeSections);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string name, valuetype System.Security.AccessControl.AccessControlSections includeSections) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.AccessControl.MutexSecurity.#ctor(System.String,System.Security.AccessControl.AccessControlSections)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (name As String, includeSections As AccessControlSections)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; MutexSecurity(System::String ^ name, System::Security::AccessControl::AccessControlSections includeSections);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="includeSections" Type="System.Security.AccessControl.AccessControlSections" />
      </Parameters>
      <Docs>
        <param name="name">El nombre de la exclusión mutua de sistema cuyas reglas de seguridad de control de acceso se recuperarán.</param>
        <param name="includeSections">Una combinación de marcadores <see cref="T:System.Security.AccessControl.AccessControlSections" /> que especifica las secciones que se van a recuperar.</param>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Security.AccessControl.MutexSecurity" /> con las secciones especificadas de las reglas de seguridad de control de acceso de la exclusión mutua de sistema con el nombre especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este constructor permite obtener la seguridad de control de acceso para una exclusión mutua del sistema con nombre sin crear primero un <xref:System.Threading.Mutex> objeto.  
  
 Debe tener precaución al trabajar con objetos del sistema con nombre. Si hay un objeto de sistema denominado `name` que no es una exclusión mutua, se podría recuperar su seguridad de control de acceso.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.FileNotFoundException">No hay ningún objeto de sistema con el nombre especificado.</exception>
        <exception cref="T:System.NotSupportedException">Esta clase no se admite en Windows 98 ni en Windows Millennium Edition.</exception>
      </Docs>
    </Member>
    <Member MemberName="AccessRightType">
      <MemberSignature Language="C#" Value="public override Type AccessRightType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type AccessRightType" />
      <MemberSignature Language="DocId" Value="P:System.Security.AccessControl.MutexSecurity.AccessRightType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property AccessRightType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property Type ^ AccessRightType { Type ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene la enumeración que la clase <see cref="T:System.Security.AccessControl.MutexSecurity" /> utiliza para representar los derechos de acceso.</summary>
        <value>Objeto <see cref="T:System.Type" /> que representa la enumeración <see cref="T:System.Security.AccessControl.MutexRights" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Las clases que derivan de la <xref:System.Security.AccessControl.ObjectSecurity> clase invalidación el <xref:System.Security.AccessControl.ObjectSecurity.AccessRightType%2A> propiedad y devuelven el tipo que utilizan para representar los derechos de acceso. Cuando se trabaja con matrices o colecciones que contienen varios tipos de objetos de seguridad, utilice esta propiedad para determinar el tipo de enumeración correctos para utilizar con cada objeto de seguridad.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AccessRuleFactory">
      <MemberSignature Language="C#" Value="public override System.Security.AccessControl.AccessRule AccessRuleFactory (System.Security.Principal.IdentityReference identityReference, int accessMask, bool isInherited, System.Security.AccessControl.InheritanceFlags inheritanceFlags, System.Security.AccessControl.PropagationFlags propagationFlags, System.Security.AccessControl.AccessControlType type);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Security.AccessControl.AccessRule AccessRuleFactory(class System.Security.Principal.IdentityReference identityReference, int32 accessMask, bool isInherited, valuetype System.Security.AccessControl.InheritanceFlags inheritanceFlags, valuetype System.Security.AccessControl.PropagationFlags propagationFlags, valuetype System.Security.AccessControl.AccessControlType type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.AccessControl.MutexSecurity.AccessRuleFactory(System.Security.Principal.IdentityReference,System.Int32,System.Boolean,System.Security.AccessControl.InheritanceFlags,System.Security.AccessControl.PropagationFlags,System.Security.AccessControl.AccessControlType)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Security::AccessControl::AccessRule ^ AccessRuleFactory(System::Security::Principal::IdentityReference ^ identityReference, int accessMask, bool isInherited, System::Security::AccessControl::InheritanceFlags inheritanceFlags, System::Security::AccessControl::PropagationFlags propagationFlags, System::Security::AccessControl::AccessControlType type);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.AccessControl.AccessRule</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="identityReference" Type="System.Security.Principal.IdentityReference" />
        <Parameter Name="accessMask" Type="System.Int32" />
        <Parameter Name="isInherited" Type="System.Boolean" />
        <Parameter Name="inheritanceFlags" Type="System.Security.AccessControl.InheritanceFlags" />
        <Parameter Name="propagationFlags" Type="System.Security.AccessControl.PropagationFlags" />
        <Parameter Name="type" Type="System.Security.AccessControl.AccessControlType" />
      </Parameters>
      <Docs>
        <param name="identityReference">Objeto <see cref="T:System.Security.Principal.IdentityReference" /> que identifica al usuario o grupo al que se aplica la regla.</param>
        <param name="accessMask">Combinación de valores <see cref="T:System.Security.AccessControl.MutexRights" /> bit a bit que especifica los derechos de acceso que se van a conceder o denegar, convertidos a un entero.</param>
        <param name="isInherited">No tiene sentido para las exclusiones mutuas con nombre porque no tienen ninguna jerarquía.</param>
        <param name="inheritanceFlags">No tiene sentido para las exclusiones mutuas con nombre porque no tienen ninguna jerarquía.</param>
        <param name="propagationFlags">No tiene sentido para las exclusiones mutuas con nombre porque no tienen ninguna jerarquía.</param>
        <param name="type">Uno de los valores de <see cref="T:System.Security.AccessControl.AccessControlType" /> que especifica si se conceden o deniegan los derechos.</param>
        <summary>Crea una nueva regla de control de acceso para el usuario indicado con los derechos de acceso, el control de acceso y los marcadores especificados.</summary>
        <returns>Objeto <see cref="T:System.Security.AccessControl.MutexAccessRule" /> que representa los derechos indicados para el usuario especificado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La manera recomendada de crear las reglas de control de acceso es utilizar los constructores de la <xref:System.Security.AccessControl.MutexAccessRule> clase.  
  
> [!NOTE]
>  Aunque los indicadores de herencia y propagación no tienen sentidos para las exclusiones mutuas, está siendo posible especificarlos. No se recomienda porque complica de manera innecesaria el mantenimiento de reglas, por ejemplo, interfiriendo con la combinación de reglas que de otro modo sería compatible.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="accessMask" />, <paramref name="inheritanceFlags" />, <paramref name="propagationFlags" /> o <paramref name="type" /> especifican un valor no válido.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="identityReference" /> es <see langword="null" />.  
  
 O bien  
  
 <paramref name="accessMask" /> es cero.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="identityReference" /> no es de tipo <see cref="T:System.Security.Principal.SecurityIdentifier" />, ni de un tipo que, como <see cref="T:System.Security.Principal.NTAccount" />, se pueda convertir al tipo <see cref="T:System.Security.Principal.SecurityIdentifier" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="AccessRuleType">
      <MemberSignature Language="C#" Value="public override Type AccessRuleType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type AccessRuleType" />
      <MemberSignature Language="DocId" Value="P:System.Security.AccessControl.MutexSecurity.AccessRuleType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property AccessRuleType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property Type ^ AccessRuleType { Type ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene el tipo que utiliza la clase <see cref="T:System.Security.AccessControl.MutexSecurity" /> para representar las reglas de acceso.</summary>
        <value>Objeto <see cref="T:System.Type" /> que representa la clase <see cref="T:System.Security.AccessControl.MutexAccessRule" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Las clases que derivan de la <xref:System.Security.AccessControl.ObjectSecurity> clase invalidación el <xref:System.Security.AccessControl.ObjectSecurity.AccessRuleType%2A> propiedad y devuelven el tipo que utilizan para representar las reglas de acceso. Cuando se trabaja con matrices o colecciones que contienen varios tipos de objetos de seguridad, utilice esta propiedad para determinar el tipo de regla de acceso correcto a utilizar con cada objeto de seguridad.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddAccessRule">
      <MemberSignature Language="C#" Value="public void AddAccessRule (System.Security.AccessControl.MutexAccessRule rule);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddAccessRule(class System.Security.AccessControl.MutexAccessRule rule) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.AccessControl.MutexSecurity.AddAccessRule(System.Security.AccessControl.MutexAccessRule)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddAccessRule (rule As MutexAccessRule)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddAccessRule(System::Security::AccessControl::MutexAccessRule ^ rule);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rule" Type="System.Security.AccessControl.MutexAccessRule" />
      </Parameters>
      <Docs>
        <param name="rule">La regla de control de acceso que se va a agregar.</param>
        <summary>Busca una regla de control de acceso coincidente con la que se pueda combinar la nueva regla. Si no se encuentra ninguna, agrega la nueva regla.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Security.AccessControl.MutexSecurity.AddAccessRule%2A> método busca las reglas con el mismo usuario o grupo y el mismo <xref:System.Security.AccessControl.AccessControlType> como `rule`. Si no se encuentra ninguno, `rule` se agrega. Si se encuentra una regla de coincidencia, los derechos en `rule` se combinan con la regla existente.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra la separación entre <xref:System.Security.AccessControl.AccessControlType.Allow> reglas y <xref:System.Security.AccessControl.AccessControlType.Deny> reglas y muestra la combinación de derechos de reglas compatibles. El ejemplo se crea un <xref:System.Security.AccessControl.MutexSecurity> objeto, se agregan reglas que conceden y deniegan diferentes derechos al usuario actual y muestra el par de reglas resultante. En el ejemplo, a continuación, permite nuevos derechos para el usuario actual y muestra el resultado, que muestra que los nuevos derechos se combinan con las existentes <xref:System.Security.AccessControl.AccessControlType.Allow> regla.  
  
> [!NOTE]
>  Este ejemplo no adjunta el objeto de seguridad a un <xref:System.Threading.Mutex> objeto. Encontrará ejemplos donde se adjuntan objetos de seguridad en <xref:System.Threading.Mutex.GetAccessControl%2A?displayProperty=nameWithType> <xref:System.Threading.Mutex.SetAccessControl%2A?displayProperty=nameWithType>.  
  
 [!code-csharp[System.Security.AccessControl.MutexSecurity.AddAccessRule#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Security.AccessControl.MutexSecurity.AddAccessRule/CS/source.cs#1)]
 [!code-vb[System.Security.AccessControl.MutexSecurity.AddAccessRule#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Security.AccessControl.MutexSecurity.AddAccessRule/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="rule" /> es <see langword="null" />.</exception>
        <exception cref="T:System.Security.Principal.IdentityNotMappedException">
          <paramref name="rule" /> no se puede asignar a una identidad conocida.</exception>
      </Docs>
    </Member>
    <Member MemberName="AddAuditRule">
      <MemberSignature Language="C#" Value="public void AddAuditRule (System.Security.AccessControl.MutexAuditRule rule);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddAuditRule(class System.Security.AccessControl.MutexAuditRule rule) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.AccessControl.MutexSecurity.AddAuditRule(System.Security.AccessControl.MutexAuditRule)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddAuditRule (rule As MutexAuditRule)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddAuditRule(System::Security::AccessControl::MutexAuditRule ^ rule);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rule" Type="System.Security.AccessControl.MutexAuditRule" />
      </Parameters>
      <Docs>
        <param name="rule">La regla de auditoría que se va a agregar. El usuario especificado por esta regla determina la búsqueda.</param>
        <summary>Busca una regla de auditoría con la que se pueda combinar la nueva regla. Si no se encuentra ninguna, agrega la nueva regla.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Security.AccessControl.MutexSecurity.AddAuditRule%2A> método busca las reglas con el mismo usuario o grupo como `rule`. Si no se encuentra ninguno, `rule` se agrega. Si se encuentra una regla de coincidencia, las marcas en `rule` se combinan en la regla existente.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AuditRuleFactory">
      <MemberSignature Language="C#" Value="public override System.Security.AccessControl.AuditRule AuditRuleFactory (System.Security.Principal.IdentityReference identityReference, int accessMask, bool isInherited, System.Security.AccessControl.InheritanceFlags inheritanceFlags, System.Security.AccessControl.PropagationFlags propagationFlags, System.Security.AccessControl.AuditFlags flags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Security.AccessControl.AuditRule AuditRuleFactory(class System.Security.Principal.IdentityReference identityReference, int32 accessMask, bool isInherited, valuetype System.Security.AccessControl.InheritanceFlags inheritanceFlags, valuetype System.Security.AccessControl.PropagationFlags propagationFlags, valuetype System.Security.AccessControl.AuditFlags flags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.AccessControl.MutexSecurity.AuditRuleFactory(System.Security.Principal.IdentityReference,System.Int32,System.Boolean,System.Security.AccessControl.InheritanceFlags,System.Security.AccessControl.PropagationFlags,System.Security.AccessControl.AuditFlags)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Security::AccessControl::AuditRule ^ AuditRuleFactory(System::Security::Principal::IdentityReference ^ identityReference, int accessMask, bool isInherited, System::Security::AccessControl::InheritanceFlags inheritanceFlags, System::Security::AccessControl::PropagationFlags propagationFlags, System::Security::AccessControl::AuditFlags flags);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.AccessControl.AuditRule</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="identityReference" Type="System.Security.Principal.IdentityReference" />
        <Parameter Name="accessMask" Type="System.Int32" />
        <Parameter Name="isInherited" Type="System.Boolean" />
        <Parameter Name="inheritanceFlags" Type="System.Security.AccessControl.InheritanceFlags" />
        <Parameter Name="propagationFlags" Type="System.Security.AccessControl.PropagationFlags" />
        <Parameter Name="flags" Type="System.Security.AccessControl.AuditFlags" />
      </Parameters>
      <Docs>
        <param name="identityReference">Objeto <see cref="T:System.Security.Principal.IdentityReference" /> que identifica al usuario o grupo al que se aplica la regla.</param>
        <param name="accessMask">Combinación de valores <see cref="T:System.Security.AccessControl.MutexRights" /> bit a bit que especifica los derechos de acceso que se van a auditar, convertidos a un entero.</param>
        <param name="isInherited">No tiene sentido para los marcadores de espera con nombre porque no tienen ninguna jerarquía.</param>
        <param name="inheritanceFlags">No tiene sentido para los marcadores de espera con nombre porque no tienen ninguna jerarquía.</param>
        <param name="propagationFlags">No tiene sentido para los marcadores de espera con nombre porque no tienen ninguna jerarquía.</param>
        <param name="flags">Una combinación bit a bit de valores <see cref="T:System.Security.AccessControl.AuditFlags" /> que especifica si el resultado de la operación auditada de acceso es de éxito, error o ambos.</param>
        <summary>Crea una nueva regla de auditoría, que especifica el usuario al que se aplica la regla, los derechos de acceso que se van a auditar y el resultado que desencadena la regla de auditoría.</summary>
        <returns>Objeto <see cref="T:System.Security.AccessControl.MutexAuditRule" /> que representa la regla de auditoría indicada para el usuario especificado. El tipo de valor devuelto del método es la clase base, <see cref="T:System.Security.AccessControl.AuditRule" />, pero el valor devuelto se puede convertir sin ningún riesgo a la clase derivada.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La manera recomendada para crear reglas de auditoría es utilizar los constructores de la <xref:System.Security.AccessControl.MutexAuditRule> clase.  
  
> [!NOTE]
>  Aunque los indicadores de herencia y propagación no tienen sentidos para las exclusiones mutuas, está siendo posible especificarlos. No se recomienda porque complica de manera innecesaria el mantenimiento de reglas, por ejemplo, interfiriendo con la combinación de reglas que de otro modo sería compatible.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="accessMask" />, <paramref name="inheritanceFlags" />, <paramref name="propagationFlags" /> o <paramref name="flags" /> especifican un valor no válido.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="identityReference" /> es <see langword="null" />.  
  
 O bien  
  
 <paramref name="accessMask" /> es cero.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="identityReference" /> no es de tipo <see cref="T:System.Security.Principal.SecurityIdentifier" />, ni de un tipo que, como <see cref="T:System.Security.Principal.NTAccount" />, se pueda convertir al tipo <see cref="T:System.Security.Principal.SecurityIdentifier" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="AuditRuleType">
      <MemberSignature Language="C#" Value="public override Type AuditRuleType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type AuditRuleType" />
      <MemberSignature Language="DocId" Value="P:System.Security.AccessControl.MutexSecurity.AuditRuleType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property AuditRuleType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property Type ^ AuditRuleType { Type ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene el tipo que utiliza la clase <see cref="T:System.Security.AccessControl.MutexSecurity" /> para representar las reglas de auditoría.</summary>
        <value>Objeto <see cref="T:System.Type" /> que representa la clase <see cref="T:System.Security.AccessControl.MutexAuditRule" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Las clases que derivan de la <xref:System.Security.AccessControl.ObjectSecurity> clase invalidación el <xref:System.Security.AccessControl.ObjectSecurity.AuditRuleType%2A> propiedad y devuelven el tipo que utilizan para representar los derechos de auditoría. Cuando se trabaja con matrices o colecciones que contienen varios tipos de objetos de seguridad, utilice esta propiedad para determinar el tipo de regla de auditoría correcta para utilizar con cada objeto de seguridad.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RemoveAccessRule">
      <MemberSignature Language="C#" Value="public bool RemoveAccessRule (System.Security.AccessControl.MutexAccessRule rule);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool RemoveAccessRule(class System.Security.AccessControl.MutexAccessRule rule) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.AccessControl.MutexSecurity.RemoveAccessRule(System.Security.AccessControl.MutexAccessRule)" />
      <MemberSignature Language="VB.NET" Value="Public Function RemoveAccessRule (rule As MutexAccessRule) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool RemoveAccessRule(System::Security::AccessControl::MutexAccessRule ^ rule);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rule" Type="System.Security.AccessControl.MutexAccessRule" />
      </Parameters>
      <Docs>
        <param name="rule">
          <see cref="T:System.Security.AccessControl.MutexAccessRule" /> que especifica el usuario y <see cref="T:System.Security.AccessControl.AccessControlType" /> que se va a buscar y un conjunto de marcadores de herencia y propagación con los que una regla coincidente, si se encuentra, debe ser compatible. Especifica los derechos que se van a quitar de la regla compatible, si se encuentra.</param>
        <summary>Busca una regla de control de acceso con el mismo usuario y <see cref="T:System.Security.AccessControl.AccessControlType" /> (conceder o denegar) que la regla especificada y con marcadores de herencia y propagación compatibles; si encuentra este tipo de regla, quita de ésta los derechos contenidos en la regla de acceso especificada.</summary>
        <returns>
          Es <see langword="true" /> si se ha encontrado una regla compatible; en caso contrario, es <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Actual <xref:System.Security.AccessControl.MutexSecurity> se busca una regla que tenga el mismo usuario y el mismo <xref:System.Security.AccessControl.AccessControlType> valor como `rule`. Si no se encuentra la regla se realiza ninguna acción y el método devuelve `false`. Si se encuentran las reglas de coincidencia, se comprueban sus marcas de herencia y la compatibilidad para la compatibilidad con las marcas especificadas en `rule`. Si se encuentra ninguna regla compatible, no se realiza ninguna acción y el método devuelve `false`. Si se encuentra una regla con indicadores compatibles, los permisos se especifican en `rule` se quitan de la regla compatible, y el método devuelve `true`. Si `rule` especifica derechos no contenidos en la regla compatible, no se realiza ninguna acción con respecto a dichos derechos. Si se quitan todos los derechos de la regla compatible, se quita la regla completa actual <xref:System.Security.AccessControl.MutexSecurity> objeto.  
  
> [!IMPORTANT]
>  Aunque puede especificar indicadores de herencia y propagación para las reglas de acceso de exclusión mutua, creándolos con el <xref:System.Security.AccessControl.MutexSecurity.AccessRuleFactory%2A> método, no se recomienda. Herencia y propagación no tienen ningún significado para las exclusiones mutuas con nombre y realizan el mantenimiento de reglas de acceso más complicado.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra el uso de la <xref:System.Security.AccessControl.MutexSecurity.RemoveAccessRule%2A> método para quitar derechos de un <xref:System.Security.AccessControl.AccessControlType.Allow> regla en un <xref:System.Security.AccessControl.MutexSecurity> objeto. También muestra que otros derechos en `rule` se omiten.  
  
 El ejemplo se crea un <xref:System.Security.AccessControl.MutexSecurity> de objeto y se agregan reglas que conceden y deniegan diferentes derechos al usuario actual. Los derechos permiten incluir <xref:System.Security.AccessControl.MutexRights.Modify>, <xref:System.Security.AccessControl.MutexRights.ReadPermissions>, y <xref:System.Security.AccessControl.MutexRights.Synchronize>. El ejemplo crea una nueva regla para el usuario actual, incluidos los <xref:System.Security.AccessControl.MutexRights.ReadPermissions> y <xref:System.Security.AccessControl.MutexRights.TakeOwnership> derechos y se utiliza esa regla con el <xref:System.Security.AccessControl.MutexSecurity.RemoveAccessRule%2A> método para quitar <xref:System.Security.AccessControl.MutexRights.ReadPermissions> desde el <xref:System.Security.AccessControl.AccessControlType.Allow> regla en el <xref:System.Security.AccessControl.MutexSecurity> objeto. El extraños <xref:System.Security.AccessControl.MutexRights.TakeOwnership> directamente en `rule` se omite.  
  
> [!NOTE]
>  Este ejemplo no adjunta el objeto de seguridad a un <xref:System.Threading.Mutex> objeto. Encontrará ejemplos donde se adjuntan objetos de seguridad en <xref:System.Threading.Mutex.GetAccessControl%2A?displayProperty=nameWithType> y <xref:System.Threading.Mutex.SetAccessControl%2A?displayProperty=nameWithType>.  
  
 [!code-csharp[System.Security.AccessControl.MutexSecurity.RemoveAccessRule#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Security.AccessControl.MutexSecurity.RemoveAccessRule/CS/source.cs#1)]
 [!code-vb[System.Security.AccessControl.MutexSecurity.RemoveAccessRule#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Security.AccessControl.MutexSecurity.RemoveAccessRule/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="rule" /> es <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="RemoveAccessRuleAll">
      <MemberSignature Language="C#" Value="public void RemoveAccessRuleAll (System.Security.AccessControl.MutexAccessRule rule);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RemoveAccessRuleAll(class System.Security.AccessControl.MutexAccessRule rule) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.AccessControl.MutexSecurity.RemoveAccessRuleAll(System.Security.AccessControl.MutexAccessRule)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RemoveAccessRuleAll (rule As MutexAccessRule)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RemoveAccessRuleAll(System::Security::AccessControl::MutexAccessRule ^ rule);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rule" Type="System.Security.AccessControl.MutexAccessRule" />
      </Parameters>
      <Docs>
        <param name="rule">
          <see cref="T:System.Security.AccessControl.MutexAccessRule" /> que especifica el usuario y <see cref="T:System.Security.AccessControl.AccessControlType" /> que se va a buscar. Se pasa por alto cualquier derecho especificado por esta regla.</param>
        <summary>Busca todas las reglas de control de acceso con el mismo usuario y <see cref="T:System.Security.AccessControl.AccessControlType" /> (conceder o denegar) que la regla especificada y, si las encuentra, las quita.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Actual <xref:System.Security.AccessControl.MutexSecurity> se buscan en el objeto para las reglas que tengan el mismo usuario y el mismo <xref:System.Security.AccessControl.AccessControlType> valor como `rule`. Los derechos especificados por `rule` se pasan por alto al realizar esta búsqueda. Si no se encuentra ninguna regla coincidente, se realiza ninguna acción.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra que la <xref:System.Security.AccessControl.MutexSecurity.RemoveAccessRuleAll%2A> método quita todas las reglas que coinciden con el usuario y <xref:System.Security.AccessControl.AccessControlType>, pasando por alto los derechos.  
  
 El ejemplo se crea un <xref:System.Security.AccessControl.MutexSecurity> objeto, se agregan reglas que conceden y deniegan diferentes derechos al usuario actual y, a continuación, combinan derechos adicionales en el <xref:System.Security.AccessControl.AccessControlType.Allow> regla. El ejemplo crea una nueva regla que permite al usuario actual tomar posesión y utiliza esa regla para quitar la <xref:System.Security.AccessControl.AccessControlType.Allow> regla a partir de la <xref:System.Security.AccessControl.MutexSecurity> objeto.  
  
> [!NOTE]
>  Este ejemplo no adjunta el objeto de seguridad a un <xref:System.Threading.Mutex> objeto. Encontrará ejemplos donde se adjuntan objetos de seguridad en <xref:System.Threading.Mutex.GetAccessControl%2A?displayProperty=nameWithType> y <xref:System.Threading.Mutex.SetAccessControl%2A?displayProperty=nameWithType>.  
  
 [!code-csharp[System.Security.AccessControl.MutexSecurity.RemoveAccessRuleAll#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Security.AccessControl.MutexSecurity.RemoveAccessRuleAll/CS/source.cs#1)]
 [!code-vb[System.Security.AccessControl.MutexSecurity.RemoveAccessRuleAll#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Security.AccessControl.MutexSecurity.RemoveAccessRuleAll/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="rule" /> es <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="RemoveAccessRuleSpecific">
      <MemberSignature Language="C#" Value="public void RemoveAccessRuleSpecific (System.Security.AccessControl.MutexAccessRule rule);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RemoveAccessRuleSpecific(class System.Security.AccessControl.MutexAccessRule rule) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.AccessControl.MutexSecurity.RemoveAccessRuleSpecific(System.Security.AccessControl.MutexAccessRule)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RemoveAccessRuleSpecific (rule As MutexAccessRule)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RemoveAccessRuleSpecific(System::Security::AccessControl::MutexAccessRule ^ rule);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rule" Type="System.Security.AccessControl.MutexAccessRule" />
      </Parameters>
      <Docs>
        <param name="rule">
          <see cref="T:System.Security.AccessControl.MutexAccessRule" /> que se va a quitar.</param>
        <summary>Busca una regla de control de acceso que coincida exactamente con la regla especificada y, si la encuentra, la quita.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La regla sólo se quita si coincide exactamente con `rule` en todos los detalles, incluidos los marcadores. Otras reglas con el mismo usuario y <xref:System.Security.AccessControl.AccessControlType> no se ven afectadas.  
  
> [!IMPORTANT]
>  Una regla representa una o más entradas de control de acceso (ACE) subyacente y estas entradas se dividen o se combinan según sea necesario cuando se modifican las reglas de seguridad de acceso para un usuario. Por lo tanto, una regla que ya no exista en la forma concreta que tenía cuando se agregó y, en ese caso el <xref:System.Security.AccessControl.MutexSecurity.RemoveAccessRuleSpecific%2A> método no puede quitarla.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra que el <xref:System.Security.AccessControl.MutexSecurity.RemoveAccessRuleSpecific%2A> método requiere una coincidencia exacta para quitar una regla, y que las reglas para permitir y denegar los derechos son independientes entre sí.  
  
 El ejemplo se crea un <xref:System.Security.AccessControl.MutexSecurity> objeto, se agregan reglas que conceden y deniegan diferentes derechos al usuario actual y, a continuación, combinan derechos adicionales en el <xref:System.Security.AccessControl.AccessControlType.Allow> regla de acceso. En el ejemplo a continuación, pasa el original <xref:System.Security.AccessControl.AccessControlType.Allow> regla para el <xref:System.Security.AccessControl.MutexSecurity.RemoveAccessRuleSpecific%2A> método y muestra los resultados, que muestra que no se elimina nada. El ejemplo, a continuación, crea una regla que coincide con el <xref:System.Security.AccessControl.AccessControlType.Allow> de regla en el <xref:System.Security.AccessControl.MutexSecurity> objeto y correctamente utiliza el <xref:System.Security.AccessControl.MutexSecurity.RemoveAccessRuleSpecific%2A> método para quitar la regla.  
  
> [!NOTE]
>  Este ejemplo no adjunta el objeto de seguridad a un <xref:System.Threading.Mutex> objeto. Encontrará ejemplos donde se adjuntan objetos de seguridad en <xref:System.Threading.Mutex.GetAccessControl%2A?displayProperty=nameWithType> y <xref:System.Threading.Mutex.SetAccessControl%2A?displayProperty=nameWithType>.  
  
 [!code-csharp[System.Security.AccessControl.MutexSecurity.RemoveAccessRuleSpecific#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Security.AccessControl.MutexSecurity.RemoveAccessRuleSpecific/CS/source.cs#1)]
 [!code-vb[System.Security.AccessControl.MutexSecurity.RemoveAccessRuleSpecific#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Security.AccessControl.MutexSecurity.RemoveAccessRuleSpecific/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="rule" /> es <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="RemoveAuditRule">
      <MemberSignature Language="C#" Value="public bool RemoveAuditRule (System.Security.AccessControl.MutexAuditRule rule);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool RemoveAuditRule(class System.Security.AccessControl.MutexAuditRule rule) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.AccessControl.MutexSecurity.RemoveAuditRule(System.Security.AccessControl.MutexAuditRule)" />
      <MemberSignature Language="VB.NET" Value="Public Function RemoveAuditRule (rule As MutexAuditRule) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool RemoveAuditRule(System::Security::AccessControl::MutexAuditRule ^ rule);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rule" Type="System.Security.AccessControl.MutexAuditRule" />
      </Parameters>
      <Docs>
        <param name="rule">
          <see cref="T:System.Security.AccessControl.MutexAuditRule" /> que especifica el usuario que se va a buscar y un conjunto de marcadores de herencia y propagación con los que una regla coincidente, si se encuentra, debe ser compatible. Especifica los derechos que se van a quitar de la regla compatible, si se encuentra.</param>
        <summary>Busca una regla de control de auditoría con el mismo usuario que la regla especificada y con marcadores de herencia y propagación compatibles; si encuentra una regla compatible, quita de ésta los derechos contenidos en la regla especificada.</summary>
        <returns>
          <see langword="true" /> si se ha encontrado una regla compatible; en caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Actual <xref:System.Security.AccessControl.MutexSecurity> de una regla de auditoría que tenga el mismo usuario que se buscan en `rule`. Si no se encuentra la regla se realiza ninguna acción y el método devuelve `false`. Si se encuentran las reglas de coincidencia, se comprueban sus marcas de herencia y la compatibilidad para la compatibilidad con las marcas especificadas en `rule`. Si se encuentra ninguna regla compatible, no se realiza ninguna acción y el método devuelve `false`. Si se encuentra una regla con indicadores compatibles, los permisos se especifican en `rule` se quitan de la regla compatible, y el método devuelve `true`. Si `rule` especifica derechos no contenidos en la regla compatible, no se realiza ninguna acción con respecto a dichos derechos. Si se quitan todos los derechos de la regla compatible, se quita la regla completa actual <xref:System.Security.AccessControl.MutexSecurity> objeto.  
  
> [!IMPORTANT]
>  Aunque puede especificar indicadores de herencia y propagación para las reglas de auditoría de exclusión mutua, creándolos con el <xref:System.Security.AccessControl.MutexSecurity.AccessRuleFactory%2A> método, no se recomienda. Herencia y propagación no tienen ningún significado para las exclusiones mutuas con nombre y realizan el mantenimiento de reglas de auditoría más complicado.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="rule" /> es <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="RemoveAuditRuleAll">
      <MemberSignature Language="C#" Value="public void RemoveAuditRuleAll (System.Security.AccessControl.MutexAuditRule rule);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RemoveAuditRuleAll(class System.Security.AccessControl.MutexAuditRule rule) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.AccessControl.MutexSecurity.RemoveAuditRuleAll(System.Security.AccessControl.MutexAuditRule)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RemoveAuditRuleAll (rule As MutexAuditRule)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RemoveAuditRuleAll(System::Security::AccessControl::MutexAuditRule ^ rule);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rule" Type="System.Security.AccessControl.MutexAuditRule" />
      </Parameters>
      <Docs>
        <param name="rule">
          <see cref="T:System.Security.AccessControl.MutexAuditRule" /> que especifica el usuario que se va a buscar. Se pasa por alto cualquier derecho especificado por esta regla.</param>
        <summary>Busca todas las reglas de auditoría con el mismo usuario que la regla especificada y, si las encuentra, las quita.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Actual <xref:System.Security.AccessControl.MutexSecurity> de reglas de auditoría que tienen el mismo usuario que se buscan en `rule`. Los derechos especificados por `rule` se pasan por alto al realizar esta búsqueda. Se quitan todas las reglas coincidentes. Si no se encuentra ninguna regla coincidente, se realiza ninguna acción.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="rule" /> es <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="RemoveAuditRuleSpecific">
      <MemberSignature Language="C#" Value="public void RemoveAuditRuleSpecific (System.Security.AccessControl.MutexAuditRule rule);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RemoveAuditRuleSpecific(class System.Security.AccessControl.MutexAuditRule rule) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.AccessControl.MutexSecurity.RemoveAuditRuleSpecific(System.Security.AccessControl.MutexAuditRule)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RemoveAuditRuleSpecific (rule As MutexAuditRule)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RemoveAuditRuleSpecific(System::Security::AccessControl::MutexAuditRule ^ rule);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rule" Type="System.Security.AccessControl.MutexAuditRule" />
      </Parameters>
      <Docs>
        <param name="rule">
          <see cref="T:System.Security.AccessControl.MutexAuditRule" /> que se va a quitar.</param>
        <summary>Busca una regla de auditoría que coincida exactamente con la regla especificada y, si la encuentra, la quita.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La regla sólo se quita si coincide exactamente con `rule` en todos los detalles, incluidos los marcadores. No se ven afectadas otras reglas de auditoría para el mismo usuario.  
  
> [!IMPORTANT]
>  Una regla representa una o más entradas de control de acceso (ACE) subyacente y estas entradas se dividen o se combinan según sea necesario cuando se modifican las reglas de seguridad de auditoría para un usuario. Por lo tanto, una regla que ya no exista en la forma concreta que tenía cuando se agregó y, en ese caso el <xref:System.Security.AccessControl.MutexSecurity.RemoveAuditRuleSpecific%2A> método no puede quitarla.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="rule" /> es <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ResetAccessRule">
      <MemberSignature Language="C#" Value="public void ResetAccessRule (System.Security.AccessControl.MutexAccessRule rule);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ResetAccessRule(class System.Security.AccessControl.MutexAccessRule rule) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.AccessControl.MutexSecurity.ResetAccessRule(System.Security.AccessControl.MutexAccessRule)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ResetAccessRule (rule As MutexAccessRule)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ResetAccessRule(System::Security::AccessControl::MutexAccessRule ^ rule);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rule" Type="System.Security.AccessControl.MutexAccessRule" />
      </Parameters>
      <Docs>
        <param name="rule">
          <see cref="T:System.Security.AccessControl.MutexAccessRule" /> que se va a agregar. El usuario especificado por esta regla determina las reglas que se van a quitar antes de agregar esta regla.</param>
        <summary>Quita todas las reglas de control de acceso con el mismo usuario que la regla especificada, independientemente de <see cref="T:System.Security.AccessControl.AccessControlType" />, y, a continuación, agrega la regla especificada.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si no hay ninguna regla de acceso cuyo usuario coincida con la regla especificada, `rule` se agrega.  
  
   
  
## Examples  
 El siguiente ejemplo de código muestra cómo el <xref:System.Security.AccessControl.MutexSecurity.ResetAccessRule%2A> método reemplaza todas las reglas de usuario coincidentes con la regla especificada para la búsqueda de coincidencias.  
  
 El ejemplo se crea un <xref:System.Security.AccessControl.MutexSecurity> de objeto y se agregan reglas que conceden y deniegan diferentes derechos al usuario actual. El ejemplo crea una nueva regla que permite el control completo al usuario actual y se utiliza el <xref:System.Security.AccessControl.MutexSecurity.ResetAccessRule%2A> método para reemplazar dos de las reglas existentes con la nueva regla.  
  
> [!NOTE]
>  Este ejemplo no adjunta el objeto de seguridad a un <xref:System.Threading.Mutex> objeto. Encontrará ejemplos donde se adjuntan objetos de seguridad en <xref:System.Threading.Mutex.GetAccessControl%2A?displayProperty=nameWithType> y <xref:System.Threading.Mutex.SetAccessControl%2A?displayProperty=nameWithType>.  
  
 [!code-csharp[System.Security.AccessControl.MutexSecurity.ResetAccessRule#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Security.AccessControl.MutexSecurity.ResetAccessRule/CS/source.cs#1)]
 [!code-vb[System.Security.AccessControl.MutexSecurity.ResetAccessRule#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Security.AccessControl.MutexSecurity.ResetAccessRule/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="rule" /> es <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="SetAccessRule">
      <MemberSignature Language="C#" Value="public void SetAccessRule (System.Security.AccessControl.MutexAccessRule rule);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetAccessRule(class System.Security.AccessControl.MutexAccessRule rule) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.AccessControl.MutexSecurity.SetAccessRule(System.Security.AccessControl.MutexAccessRule)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetAccessRule (rule As MutexAccessRule)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetAccessRule(System::Security::AccessControl::MutexAccessRule ^ rule);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rule" Type="System.Security.AccessControl.MutexAccessRule" />
      </Parameters>
      <Docs>
        <param name="rule">
          <see cref="T:System.Security.AccessControl.MutexAccessRule" /> que se va a agregar. El usuario y el objeto <see cref="T:System.Security.AccessControl.AccessControlType" /> de esta regla determinan las reglas que se van a quitar antes de agregar esta regla.</param>
        <summary>Quita todas las reglas de control de acceso con el mismo usuario y <see cref="T:System.Security.AccessControl.AccessControlType" /> (conceder o denegar) que la regla especificada y, a continuación, agrega la regla especificada.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si la regla especificada tiene <xref:System.Security.AccessControl.AccessControlType.Allow>, el efecto de este método es quitar todas <xref:System.Security.AccessControl.AccessControlType.Allow> reglas para el usuario especificado, reemplazarlos con la regla especificada. Si la regla especificada tiene <xref:System.Security.AccessControl.AccessControlType.Deny>todos los <xref:System.Security.AccessControl.AccessControlType.Deny> reglas para el usuario especificado se reemplazan con la regla especificada.  
  
 Si no hay ninguna regla cuyo usuario y <xref:System.Security.AccessControl.AccessControlType> coincide con la regla especificada, `rule` se agrega.  
  
   
  
## Examples  
 El siguiente ejemplo de código muestra cómo el <xref:System.Security.AccessControl.MutexSecurity.SetAccessRule%2A> método quita todas las reglas que coinciden con el usuario y la <xref:System.Security.AccessControl.AccessControlType> de `rule`, reemplazarlos con `rule`.  
  
 El ejemplo se crea un <xref:System.Security.AccessControl.MutexSecurity> de objeto y se agregan reglas que conceden y deniegan diferentes derechos al usuario actual. El ejemplo crea una nueva regla que permite el control completo al usuario actual y se utiliza el <xref:System.Security.AccessControl.MutexSecurity.SetAccessRule%2A> regla con la nueva regla de permiso de método para reemplazar el existente. No se ve afectada la regla que deniegue el acceso.  
  
> [!NOTE]
>  Este ejemplo no adjunta el objeto de seguridad a un <xref:System.Threading.Mutex> objeto. Encontrará ejemplos donde se adjuntan objetos de seguridad en <xref:System.Threading.Mutex.GetAccessControl%2A?displayProperty=nameWithType> y <xref:System.Threading.Mutex.SetAccessControl%2A?displayProperty=nameWithType>.  
  
 [!code-csharp[System.Security.AccessControl.MutexSecurity.SetAccessRule#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Security.AccessControl.MutexSecurity.SetAccessRule/CS/source.cs#1)]
 [!code-vb[System.Security.AccessControl.MutexSecurity.SetAccessRule#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Security.AccessControl.MutexSecurity.SetAccessRule/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="rule" /> es <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="SetAuditRule">
      <MemberSignature Language="C#" Value="public void SetAuditRule (System.Security.AccessControl.MutexAuditRule rule);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetAuditRule(class System.Security.AccessControl.MutexAuditRule rule) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.AccessControl.MutexSecurity.SetAuditRule(System.Security.AccessControl.MutexAuditRule)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetAuditRule (rule As MutexAuditRule)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetAuditRule(System::Security::AccessControl::MutexAuditRule ^ rule);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rule" Type="System.Security.AccessControl.MutexAuditRule" />
      </Parameters>
      <Docs>
        <param name="rule">
          <see cref="T:System.Security.AccessControl.MutexAuditRule" /> que se va a agregar. El usuario especificado por esta regla determina las reglas que se van a quitar antes de agregar esta regla.</param>
        <summary>Quita todas las reglas de auditoría con el mismo usuario que la regla especificada, sin tener en cuenta el valor de <see cref="T:System.Security.AccessControl.AuditFlags" />, y, a continuación, agrega la regla especificada.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si no hay ninguna regla de auditoría cuyo usuario coincida con la regla especificada, `rule` se agrega.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="rule" /> es <see langword="null" />.</exception>
      </Docs>
    </Member>
  </Members>
</Type>