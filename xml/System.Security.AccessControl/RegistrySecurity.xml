<Type Name="RegistrySecurity" FullName="System.Security.AccessControl.RegistrySecurity">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="84f41f468e014b74e8d8a648742d9005ce09ace4" />
    <Meta Name="ms.sourcegitcommit" Value="0d6aa6694f157a08fe52cd25b4d9d3dcf913e812" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="es-ES" />
    <Meta Name="ms.lasthandoff" Value="10/12/2018" />
    <Meta Name="ms.locfileid" Value="49142397" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class RegistrySecurity : System.Security.AccessControl.NativeObjectSecurity" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit RegistrySecurity extends System.Security.AccessControl.NativeObjectSecurity" />
  <TypeSignature Language="DocId" Value="T:System.Security.AccessControl.RegistrySecurity" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class RegistrySecurity&#xA;Inherits NativeObjectSecurity" />
  <TypeSignature Language="C++ CLI" Value="public ref class RegistrySecurity sealed : System::Security::AccessControl::NativeObjectSecurity" />
  <TypeSignature Language="F#" Value="type RegistrySecurity = class&#xA;    inherit NativeObjectSecurity" />
  <AssemblyInfo>
    <AssemblyName>Microsoft.Win32.Registry.AccessControl</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Security.AccessControl.NativeObjectSecurity</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1">
      <AttributeName>System.Security.SecurityCritical</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Representa la seguridad de control de acceso de Windows para una clave del Registro. Esta clase no puede heredarse.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un <xref:System.Security.AccessControl.RegistrySecurity> objeto especifica los derechos de acceso para una clave del registro y también especifica cómo se auditan los intentos de acceso. Derechos de acceso a la clave del registro se expresan como reglas, con cada regla de acceso representada por un <xref:System.Security.AccessControl.RegistryAccessRule> objeto. Cada regla de auditoría se representa mediante un <xref:System.Security.AccessControl.RegistryAuditRule> objeto.  
  
 Esto refleja el sistema de seguridad de Windows subyacente, en el que cada objeto asegurable tiene a lo sumo un control lista de acceso discrecional (DACL) que controla el acceso al objeto protegido y, a lo sumo lista de control de acceso de un sistema (SACL) que especifica que el acceso se auditan los intentos. La DACL y SACL se ordenan las listas de entradas de control de acceso (ACE) que especifican el acceso y auditoría de los usuarios y grupos. Un <xref:System.Security.AccessControl.RegistryAccessRule> o <xref:System.Security.AccessControl.RegistryAuditRule> objeto podría representar más de una ACE.  
  
> [!NOTE]
>  Seguridad de control de acceso de Windows sólo puede aplicarse a las claves del registro. No se puede aplicar a pares de clave/valor individuales almacenados en una clave.  
  
 El <xref:System.Security.AccessControl.RegistrySecurity>, <xref:System.Security.AccessControl.RegistryAccessRule>, y <xref:System.Security.AccessControl.RegistryAuditRule> clases ocultan los detalles de implementación de ACL y ACE. Le permiten pasar por alto los diferentes tipos ACE diecisiete y la complejidad de mantener correctamente la herencia y propagación de derechos de acceso. Estos objetos también están diseñados para evitar los errores de control de acceso comunes siguientes:  
  
-   Crear un descriptor de seguridad con una DACL null. Una referencia a una DACL null permite que cualquier usuario agregar reglas de acceso a un objeto, la posibilidad de crear un ataque de denegación de servicio. Un nuevo <xref:System.Security.AccessControl.RegistrySecurity> objeto comienza siempre con una DACL vacía que deniega el acceso a todos los usuarios.  
  
-   Infringir la clasificación canónica de ACE. Si no se mantiene la lista ACE en la DACL en el orden canónico, los usuarios inadvertidamente se podrían dar acceso al objeto protegido. Por ejemplo, los derechos de acceso denegado siempre deben aparecer antes que los derechos de acceso permitido. <xref:System.Security.AccessControl.RegistrySecurity> objetos mantienen internamente el orden correcto.  
  
-   Manipular las marcas de descriptor de seguridad, que deberían ser bajo el control del Administrador de recursos solo.  
  
-   Crear combinaciones no válidas de marcadores ACE.  
  
-   Manipular ACE heredadas. Herencia y propagación se controlan mediante el Administrador de recursos, en respuesta a cambios en las reglas de acceso y auditoría.  
  
-   Insertar ACE no tiene sentidas en las ACL.  
  
 Las únicas funciones no compatibles con los objetos de seguridad de .NET son actividades peligrosas que deben evitarse la mayoría de los desarrolladores de aplicaciones, como las siguientes:  
  
-   Tareas de bajo nivel que normalmente se realizan mediante el Administrador de recursos.  
  
-   Agregar o quitar entradas de control de acceso de maneras que no mantienen el orden canónico.  
  
 Para modificar la seguridad de control de acceso de Windows para una clave del registro, use el <xref:Microsoft.Win32.RegistryKey.GetAccessControl%2A?displayProperty=nameWithType> método para obtener el <xref:System.Security.AccessControl.RegistrySecurity> objeto. Modificar el objeto de seguridad agregando y quitando las reglas y, a continuación, utilizar el <xref:Microsoft.Win32.RegistryKey.SetAccessControl%2A?displayProperty=nameWithType> método para volver a conectarlo.  
  
> [!IMPORTANT]
>  Cambios en un <xref:System.Security.AccessControl.RegistrySecurity> objeto no afectan a los niveles de acceso de la clave del registro hasta que llame a la <xref:Microsoft.Win32.RegistryKey.SetAccessControl%2A?displayProperty=nameWithType> método para asignar el objeto de seguridad modificado a la clave del registro.  
  
 Para copiar la seguridad de control de acceso de clave del registro de una a otra, utilice el <xref:Microsoft.Win32.RegistryKey.GetAccessControl%2A?displayProperty=nameWithType> método para obtener un <xref:System.Security.AccessControl.RegistrySecurity> objeto que representa las reglas de acceso y auditoría para la primera clave del registro y, a continuación, utilice el <xref:Microsoft.Win32.RegistryKey.SetAccessControl%2A?displayProperty=nameWithType> método para asignar esas reglas a la segunda clave del registro. También puede asignar las reglas para una segunda clave del registro con un <xref:Microsoft.Win32.RegistryKey.OpenSubKey%2A?displayProperty=nameWithType> o <xref:Microsoft.Win32.RegistryKey.CreateSubKey%2A?displayProperty=nameWithType> método que toma un <xref:System.Security.AccessControl.RegistrySecurity> parámetro del objeto.  
  
 Los usuarios con una inversión en el lenguaje de definición de descriptores de seguridad (SDDL) pueden usar el <xref:System.Security.AccessControl.ObjectSecurity.SetSecurityDescriptorSddlForm%2A> método para establecer reglas de acceso para una clave del registro y el <xref:System.Security.AccessControl.ObjectSecurity.GetSecurityDescriptorSddlForm%2A> método para obtener una cadena que representa las reglas de acceso en formato SDDL. Esto no se recomienda para nuevo desarrollo.  
  
   
  
## Examples  
 Esta sección contiene dos ejemplos de código. El primer ejemplo muestra cómo las reglas se combinan compatibles cuando se agregan y quitan y la segunda muestra cómo afectan a marcadores de herencia y propagación de la adición y eliminación de reglas.  
  
 Ejemplo 1  
  
 El siguiente ejemplo de código muestra cómo el <xref:System.Security.AccessControl.RegistrySecurity.RemoveAccessRule%2A> método quita los derechos de una regla compatible y cómo el <xref:System.Security.AccessControl.RegistrySecurity.AddAccessRule%2A> método combina los derechos con reglas compatibles.  
  
 El ejemplo se crea un <xref:System.Security.AccessControl.RegistrySecurity> objeto y agrega una regla que permite al usuario actual <xref:System.Security.AccessControl.RegistryRights.ReadKey?displayProperty=nameWithType> derechos. El ejemplo, a continuación, crea una regla que concede al usuario <xref:System.Security.AccessControl.RegistryRights.SetValue?displayProperty=nameWithType>, con la misma herencia y derechos de propagación que la primera regla y usa el <xref:System.Security.AccessControl.RegistrySecurity.RemoveAccessRule%2A> método para quitar esta nueva regla de la <xref:System.Security.AccessControl.RegistrySecurity> objeto. <xref:System.Security.AccessControl.RegistryRights.SetValue> es un componente de <xref:System.Security.AccessControl.RegistryRights.ReadKey>, por lo que se quita de la regla compatible. Las reglas en el <xref:System.Security.AccessControl.RegistrySecurity> objeto se muestran los componentes restantes de <xref:System.Security.AccessControl.RegistryRights.ReadKey>.  
  
 El código de ejemplo, a continuación, llama a la <xref:System.Security.AccessControl.RegistrySecurity.AddAccessRule%2A> método para combinar el <xref:System.Security.AccessControl.RegistryRights.SetValue> botón derecho en la regla en el <xref:System.Security.AccessControl.RegistrySecurity> objeto.  
  
> [!NOTE]
>  En este ejemplo no se adjunta el objeto de seguridad a un <xref:Microsoft.Win32.RegistryKey> objeto. El segundo ejemplo de esta sección adjunta un objeto de seguridad, y también lo hacen los ejemplos <xref:Microsoft.Win32.RegistryKey.GetAccessControl%2A?displayProperty=nameWithType> y <xref:Microsoft.Win32.RegistryKey.SetAccessControl%2A?displayProperty=nameWithType>.  
  
 [!code-csharp[System.Security.AccessControl.RegistrySecurity.RemoveAccessRule#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Security.AccessControl.RegistrySecurity.RemoveAccessRule/CS/source.cs#1)]
 [!code-vb[System.Security.AccessControl.RegistrySecurity.RemoveAccessRule#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Security.AccessControl.RegistrySecurity.RemoveAccessRule/VB/source.vb#1)]  
  
 Ejemplo 2  
  
 El ejemplo de código siguiente muestra las reglas de acceso con herencia y propagación. El ejemplo se crea un <xref:System.Security.AccessControl.RegistrySecurity> objeto, a continuación, crea y agrega dos reglas que tienen el <xref:System.Security.AccessControl.InheritanceFlags.ContainerInherit> marca. La primera regla no tiene ninguna marca de propagación, mientras la segunda tiene <xref:System.Security.AccessControl.PropagationFlags.NoPropagateInherit> y <xref:System.Security.AccessControl.PropagationFlags.InheritOnly>.  
  
 El programa muestra las reglas en el <xref:System.Security.AccessControl.RegistrySecurity> objeto y, a continuación, utiliza el <xref:System.Security.AccessControl.RegistrySecurity> objeto va a crear una subclave. El programa crea a un elemento secundario de subclave y una una subclave y luego muestra la seguridad para cada subclave. Por último, el programa elimina las claves de prueba.  
  
 [!code-csharp[System.Security.AccessControl.RegistryAccessRule.ctor2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Security.AccessControl.RegistryAccessRule.ctor2/CS/source.cs#1)]
 [!code-vb[System.Security.AccessControl.RegistryAccessRule.ctor2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Security.AccessControl.RegistryAccessRule.ctor2/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public RegistrySecurity ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.AccessControl.RegistrySecurity.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; RegistrySecurity();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Security.AccessControl.RegistrySecurity" /> con valores predeterminados.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un nuevo <xref:System.Security.AccessControl.RegistrySecurity> objeto comienza siempre con una lista vacía de acceso discrecional (DACL), que se deniega el acceso a todos los usuarios.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AccessRightType">
      <MemberSignature Language="C#" Value="public override Type AccessRightType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type AccessRightType" />
      <MemberSignature Language="DocId" Value="P:System.Security.AccessControl.RegistrySecurity.AccessRightType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property AccessRightType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property Type ^ AccessRightType { Type ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.AccessRightType : Type" Usage="System.Security.AccessControl.RegistrySecurity.AccessRightType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene el tipo de enumeración que la clase <see cref="T:System.Security.AccessControl.RegistrySecurity" /> utiliza para representar los derechos de acceso.</summary>
        <value>Objeto <see cref="T:System.Type" /> que representa la enumeración <see cref="T:System.Security.AccessControl.RegistryRights" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Las clases que derivan de la <xref:System.Security.AccessControl.ObjectSecurity> clase invalidación el <xref:System.Security.AccessControl.ObjectSecurity.AccessRightType%2A> propiedad y devuelva el tipo que se utilizan para representar los derechos de acceso. Cuando se trabaja con matrices o colecciones que contienen varios tipos de objetos de seguridad, use esta propiedad para determinar el tipo de enumeración correctos para utilizar con cada objeto de seguridad.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AccessRuleFactory">
      <MemberSignature Language="C#" Value="public override System.Security.AccessControl.AccessRule AccessRuleFactory (System.Security.Principal.IdentityReference identityReference, int accessMask, bool isInherited, System.Security.AccessControl.InheritanceFlags inheritanceFlags, System.Security.AccessControl.PropagationFlags propagationFlags, System.Security.AccessControl.AccessControlType type);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Security.AccessControl.AccessRule AccessRuleFactory(class System.Security.Principal.IdentityReference identityReference, int32 accessMask, bool isInherited, valuetype System.Security.AccessControl.InheritanceFlags inheritanceFlags, valuetype System.Security.AccessControl.PropagationFlags propagationFlags, valuetype System.Security.AccessControl.AccessControlType type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.AccessControl.RegistrySecurity.AccessRuleFactory(System.Security.Principal.IdentityReference,System.Int32,System.Boolean,System.Security.AccessControl.InheritanceFlags,System.Security.AccessControl.PropagationFlags,System.Security.AccessControl.AccessControlType)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Security::AccessControl::AccessRule ^ AccessRuleFactory(System::Security::Principal::IdentityReference ^ identityReference, int accessMask, bool isInherited, System::Security::AccessControl::InheritanceFlags inheritanceFlags, System::Security::AccessControl::PropagationFlags propagationFlags, System::Security::AccessControl::AccessControlType type);" />
      <MemberSignature Language="F#" Value="override this.AccessRuleFactory : System.Security.Principal.IdentityReference * int * bool * System.Security.AccessControl.InheritanceFlags * System.Security.AccessControl.PropagationFlags * System.Security.AccessControl.AccessControlType -&gt; System.Security.AccessControl.AccessRule" Usage="registrySecurity.AccessRuleFactory (identityReference, accessMask, isInherited, inheritanceFlags, propagationFlags, type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.AccessControl.AccessRule</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="identityReference" Type="System.Security.Principal.IdentityReference" />
        <Parameter Name="accessMask" Type="System.Int32" />
        <Parameter Name="isInherited" Type="System.Boolean" />
        <Parameter Name="inheritanceFlags" Type="System.Security.AccessControl.InheritanceFlags" />
        <Parameter Name="propagationFlags" Type="System.Security.AccessControl.PropagationFlags" />
        <Parameter Name="type" Type="System.Security.AccessControl.AccessControlType" />
      </Parameters>
      <Docs>
        <param name="identityReference">Objeto <see cref="T:System.Security.Principal.IdentityReference" /> que identifica al usuario o grupo al que se aplica la regla.</param>
        <param name="accessMask">Combinación de valores <see cref="T:System.Security.AccessControl.RegistryRights" /> bit a bit que especifica los derechos de acceso que se van a conceder o denegar, convertidos a un entero.</param>
        <param name="isInherited">Un valor booleano que especifica si se hereda la regla.</param>
        <param name="inheritanceFlags">Una combinación bit a bit de valores <see cref="T:System.Security.AccessControl.InheritanceFlags" /> que especifica cómo las subclaves heredan la regla.</param>
        <param name="propagationFlags">Una combinación bit a bit de valores <see cref="T:System.Security.AccessControl.PropagationFlags" /> que modifican la manera en que las subclaves heredan la regla. No tiene sentido si el valor de <c>inheritanceFlags</c> es <see cref="F:System.Security.AccessControl.InheritanceFlags.None" />.</param>
        <param name="type">Uno de los valores de <see cref="T:System.Security.AccessControl.AccessControlType" /> que especifica si se conceden o deniegan los derechos.</param>
        <summary>Crea una nueva regla de control de acceso para el usuario indicado con los derechos de acceso, el control de acceso y los marcadores especificados.</summary>
        <returns>Objeto <see cref="T:System.Security.AccessControl.RegistryAccessRule" /> que representa los derechos indicados para el usuario especificado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La manera recomendada para crear reglas de control de acceso es utilizar los constructores de la <xref:System.Security.AccessControl.RegistryAccessRule> clase.  
  
> [!NOTE]
>  Aunque puede especificar el <xref:System.Security.AccessControl.InheritanceFlags.ObjectInherit?displayProperty=nameWithType> marca, no hay ningún punto de hacerlo. Para los fines de control de acceso, los pares nombre/valor de una subclave no son objetos independientes. Los derechos de acceso a los pares nombre/valor son controlados por los derechos de la subclave. Además, dado que todas las subclaves son contenedores (es decir, puede contener otras subclaves), no se ven afectadas por la <xref:System.Security.AccessControl.InheritanceFlags.ObjectInherit> marca. Por último, especificar el <xref:System.Security.AccessControl.InheritanceFlags.ObjectInherit> marca innecesariamente complica el mantenimiento de reglas, puesto que interfiere con la combinación normal de reglas compatibles.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="accessMask" />, <paramref name="inheritanceFlags" />, <paramref name="propagationFlags" /> o <paramref name="type" /> especifican un valor no válido.</exception>
        <exception cref="T:System.ArgumentNullException">El valor de <paramref name="identityReference" /> es <see langword="null" />.  
  
O bien 
 <paramref name="accessMask" /> es cero.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="identityReference" /> no es de tipo <see cref="T:System.Security.Principal.SecurityIdentifier" />, ni de un tipo que, como <see cref="T:System.Security.Principal.NTAccount" />, se pueda convertir al tipo <see cref="T:System.Security.Principal.SecurityIdentifier" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="AccessRuleType">
      <MemberSignature Language="C#" Value="public override Type AccessRuleType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type AccessRuleType" />
      <MemberSignature Language="DocId" Value="P:System.Security.AccessControl.RegistrySecurity.AccessRuleType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property AccessRuleType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property Type ^ AccessRuleType { Type ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.AccessRuleType : Type" Usage="System.Security.AccessControl.RegistrySecurity.AccessRuleType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene el tipo que utiliza la clase <see cref="T:System.Security.AccessControl.RegistrySecurity" /> para representar las reglas de acceso.</summary>
        <value>Objeto <see cref="T:System.Type" /> que representa la clase <see cref="T:System.Security.AccessControl.RegistryAccessRule" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Las clases que derivan de la <xref:System.Security.AccessControl.ObjectSecurity> clase invalidación el <xref:System.Security.AccessControl.ObjectSecurity.AccessRuleType%2A> propiedad y devuelva el tipo que se utilizan para representar las reglas de acceso. Cuando se trabaja con matrices o colecciones que contienen varios tipos de objetos de seguridad, use esta propiedad para determinar el tipo de regla de acceso correcto a utilizar con cada objeto de seguridad.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddAccessRule">
      <MemberSignature Language="C#" Value="public void AddAccessRule (System.Security.AccessControl.RegistryAccessRule rule);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddAccessRule(class System.Security.AccessControl.RegistryAccessRule rule) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.AccessControl.RegistrySecurity.AddAccessRule(System.Security.AccessControl.RegistryAccessRule)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddAccessRule (rule As RegistryAccessRule)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddAccessRule(System::Security::AccessControl::RegistryAccessRule ^ rule);" />
      <MemberSignature Language="F#" Value="override this.AddAccessRule : System.Security.AccessControl.RegistryAccessRule -&gt; unit" Usage="registrySecurity.AddAccessRule rule" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rule" Type="System.Security.AccessControl.RegistryAccessRule" />
      </Parameters>
      <Docs>
        <param name="rule">La regla de control de acceso que se va a agregar.</param>
        <summary>Busca un control de acceso coincidente con el que se pueda combinar la nueva regla. Si no se encuentra ninguna, agrega la nueva regla.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Security.AccessControl.RegistrySecurity.AddAccessRule%2A> método busca las reglas con el mismo usuario o grupo y el mismo <xref:System.Security.AccessControl.AccessControlType> como `rule`. Si se encuentra ninguna, `rule` se agrega. Si se encuentra una regla de coincidencia, los derechos en `rule` se combinan con la regla existente.  
  
 No se pueden combinar reglas si tienen marcadores de herencia diferente. Por ejemplo, si un usuario puede tener acceso de lectura sin marcadores de herencia y <xref:System.Security.AccessControl.RegistrySecurity.AddAccessRule%2A> se usa para agregar una regla que proporciona el acceso de escritura de usuario con herencia para subclaves (<xref:System.Security.AccessControl.InheritanceFlags.ContainerInherit?displayProperty=nameWithType>), no se pueden combinar las dos reglas.  
  
 Las reglas con diferentes <xref:System.Security.AccessControl.AccessControlType> valores nunca se combinan.  
  
 Las reglas expresan los permisos de la manera más económica. Por ejemplo, si un usuario tiene <xref:System.Security.AccessControl.RegistryRights.QueryValues>, <xref:System.Security.AccessControl.RegistryRights.Notify> y <xref:System.Security.AccessControl.RegistryRights.ReadPermissions> derechos y agregar una regla que permita <xref:System.Security.AccessControl.RegistryRights.EnumerateSubKeys> derechos, el usuario tiene todas las partes constituyentes de <xref:System.Security.AccessControl.RegistryRights.ReadKey> derechos. Si consulta los derechos del usuario, verá una regla que contenga <xref:System.Security.AccessControl.RegistryRights.ReadKey> derechos. De forma similar, si quita <xref:System.Security.AccessControl.RegistryRights.EnumerateSubKeys> derechos, los demás componentes del <xref:System.Security.AccessControl.RegistryRights.ReadKey> derechos volverá a aparecer.  
  
   
  
## Examples  
 El siguiente ejemplo de código crea las reglas de acceso del registro y las agrega a un <xref:System.Security.AccessControl.RegistrySecurity> se combina el objeto y muestra cómo las reglas que conceden y deniegan derechos permanecen separadas, mientras que las reglas compatibles del mismo tipo.  
  
> [!NOTE]
>  En este ejemplo no se adjunta el objeto de seguridad a un <xref:Microsoft.Win32.RegistryKey> objeto. Encontrará ejemplos donde se adjuntan los objetos de seguridad en <xref:Microsoft.Win32.RegistryKey.GetAccessControl%2A?displayProperty=nameWithType> y <xref:Microsoft.Win32.RegistryKey.SetAccessControl%2A?displayProperty=nameWithType>.  
  
 Encontrará un ejemplo de código que muestra marcadores de herencia y propagación en la <xref:System.Security.AccessControl.RegistryAccessRule> clase.  
  
 [!code-csharp[System.Security.AccessControl.RegistrySecurity.AddAccessRule#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Security.AccessControl.RegistrySecurity.AddAccessRule/CS/source.cs#1)]
 [!code-vb[System.Security.AccessControl.RegistrySecurity.AddAccessRule#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Security.AccessControl.RegistrySecurity.AddAccessRule/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El valor de <paramref name="rule" /> es <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="AddAuditRule">
      <MemberSignature Language="C#" Value="public void AddAuditRule (System.Security.AccessControl.RegistryAuditRule rule);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddAuditRule(class System.Security.AccessControl.RegistryAuditRule rule) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.AccessControl.RegistrySecurity.AddAuditRule(System.Security.AccessControl.RegistryAuditRule)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddAuditRule (rule As RegistryAuditRule)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddAuditRule(System::Security::AccessControl::RegistryAuditRule ^ rule);" />
      <MemberSignature Language="F#" Value="override this.AddAuditRule : System.Security.AccessControl.RegistryAuditRule -&gt; unit" Usage="registrySecurity.AddAuditRule rule" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rule" Type="System.Security.AccessControl.RegistryAuditRule" />
      </Parameters>
      <Docs>
        <param name="rule">La regla de auditoría que se va a agregar. El usuario especificado por esta regla determina la búsqueda.</param>
        <summary>Busca una regla de auditoría con la que se pueda combinar la nueva regla. Si no se encuentra ninguna, agrega la nueva regla.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Security.AccessControl.RegistrySecurity.AddAuditRule%2A> método busca las reglas con el mismo usuario o grupo que `rule`. Si se encuentra ninguna, `rule` se agrega. Si se encuentra una regla de coincidencia, las marcas en `rule` se combinan en una regla existente.  
  
 No se pueden combinar reglas si tienen marcadores de herencia diferente. Por ejemplo, si los intentos de escribir en una clave se auditan para un usuario determinado, sin marcadores de herencia y <xref:System.Security.AccessControl.RegistrySecurity.AddAuditRule%2A> se usa para agregar una regla que especifique que son intentos para cambiar los permisos que se auditarán para el mismo usuario, pero con herencia para las subclaves (<xref:System.Security.AccessControl.InheritanceFlags.ContainerInherit?displayProperty=nameWithType>), no se pueden combinar las dos reglas.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AuditRuleFactory">
      <MemberSignature Language="C#" Value="public override System.Security.AccessControl.AuditRule AuditRuleFactory (System.Security.Principal.IdentityReference identityReference, int accessMask, bool isInherited, System.Security.AccessControl.InheritanceFlags inheritanceFlags, System.Security.AccessControl.PropagationFlags propagationFlags, System.Security.AccessControl.AuditFlags flags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Security.AccessControl.AuditRule AuditRuleFactory(class System.Security.Principal.IdentityReference identityReference, int32 accessMask, bool isInherited, valuetype System.Security.AccessControl.InheritanceFlags inheritanceFlags, valuetype System.Security.AccessControl.PropagationFlags propagationFlags, valuetype System.Security.AccessControl.AuditFlags flags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.AccessControl.RegistrySecurity.AuditRuleFactory(System.Security.Principal.IdentityReference,System.Int32,System.Boolean,System.Security.AccessControl.InheritanceFlags,System.Security.AccessControl.PropagationFlags,System.Security.AccessControl.AuditFlags)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Security::AccessControl::AuditRule ^ AuditRuleFactory(System::Security::Principal::IdentityReference ^ identityReference, int accessMask, bool isInherited, System::Security::AccessControl::InheritanceFlags inheritanceFlags, System::Security::AccessControl::PropagationFlags propagationFlags, System::Security::AccessControl::AuditFlags flags);" />
      <MemberSignature Language="F#" Value="override this.AuditRuleFactory : System.Security.Principal.IdentityReference * int * bool * System.Security.AccessControl.InheritanceFlags * System.Security.AccessControl.PropagationFlags * System.Security.AccessControl.AuditFlags -&gt; System.Security.AccessControl.AuditRule" Usage="registrySecurity.AuditRuleFactory (identityReference, accessMask, isInherited, inheritanceFlags, propagationFlags, flags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.AccessControl.AuditRule</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="identityReference" Type="System.Security.Principal.IdentityReference" />
        <Parameter Name="accessMask" Type="System.Int32" />
        <Parameter Name="isInherited" Type="System.Boolean" />
        <Parameter Name="inheritanceFlags" Type="System.Security.AccessControl.InheritanceFlags" />
        <Parameter Name="propagationFlags" Type="System.Security.AccessControl.PropagationFlags" />
        <Parameter Name="flags" Type="System.Security.AccessControl.AuditFlags" />
      </Parameters>
      <Docs>
        <param name="identityReference">Objeto <see cref="T:System.Security.Principal.IdentityReference" /> que identifica al usuario o grupo al que se aplica la regla.</param>
        <param name="accessMask">Combinación de valores <see cref="T:System.Security.AccessControl.RegistryRights" /> bit a bit que especifica los derechos de acceso que se van a auditar, convertidos a un entero.</param>
        <param name="isInherited">Un valor booleano que especifica si se hereda la regla.</param>
        <param name="inheritanceFlags">Una combinación bit a bit de valores <see cref="T:System.Security.AccessControl.InheritanceFlags" /> que especifica cómo las subclaves heredan la regla.</param>
        <param name="propagationFlags">Una combinación bit a bit de valores <see cref="T:System.Security.AccessControl.PropagationFlags" /> que modifican la manera en que las subclaves heredan la regla. No tiene sentido si el valor de <c>inheritanceFlags</c> es <see cref="F:System.Security.AccessControl.InheritanceFlags.None" />.</param>
        <param name="flags">Una combinación bit a bit de valores <see cref="T:System.Security.AccessControl.AuditFlags" /> que especifica si el resultado de la operación auditada de acceso es de éxito, error o ambos.</param>
        <summary>Crea una nueva regla de auditoría, que especifica el usuario al que se aplica la regla, los derechos de acceso que se van a auditar, la herencia y propagación de la regla y el resultado que desencadena la regla.</summary>
        <returns>Un objeto <see cref="T:System.Security.AccessControl.RegistryAuditRule" /> que representa la regla de auditoría indicada para el usuario especificado, con los marcadores especificados. El tipo de valor devuelto del método es la clase base, <see cref="T:System.Security.AccessControl.AuditRule" />, pero el valor devuelto se puede convertir sin ningún riesgo a la clase derivada.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La manera recomendada para crear las reglas de auditoría es utilizar los constructores de la <xref:System.Security.AccessControl.RegistryAuditRule> clase.  
  
> [!NOTE]
>  Aunque puede especificar el <xref:System.Security.AccessControl.InheritanceFlags.ObjectInherit?displayProperty=nameWithType> marca, no hay ningún punto de hacerlo. Para los fines de control de auditoría, los pares nombre/valor de una subclave no son objetos independientes. Los derechos de auditoría para los pares nombre/valor son controlados por los derechos de la subclave. Además, dado que todas las subclaves son contenedores (es decir, puede contener otras subclaves), no se ven afectadas por la <xref:System.Security.AccessControl.InheritanceFlags.ObjectInherit> marca. Por último, especificar el <xref:System.Security.AccessControl.InheritanceFlags.ObjectInherit> marca innecesariamente complica el mantenimiento de reglas, puesto que interfiere con la combinación normal de reglas compatibles.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="accessMask" />, <paramref name="inheritanceFlags" />, <paramref name="propagationFlags" /> o <paramref name="flags" /> especifican un valor no válido.</exception>
        <exception cref="T:System.ArgumentNullException">El valor de <paramref name="identityReference" /> es <see langword="null" />.  
  
O bien 
 <paramref name="accessMask" /> es cero.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="identityReference" /> no es de tipo <see cref="T:System.Security.Principal.SecurityIdentifier" />, ni de un tipo que, como <see cref="T:System.Security.Principal.NTAccount" />, se pueda convertir al tipo <see cref="T:System.Security.Principal.SecurityIdentifier" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="AuditRuleType">
      <MemberSignature Language="C#" Value="public override Type AuditRuleType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type AuditRuleType" />
      <MemberSignature Language="DocId" Value="P:System.Security.AccessControl.RegistrySecurity.AuditRuleType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property AuditRuleType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property Type ^ AuditRuleType { Type ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.AuditRuleType : Type" Usage="System.Security.AccessControl.RegistrySecurity.AuditRuleType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene el tipo que utiliza la clase <see cref="T:System.Security.AccessControl.RegistrySecurity" /> para representar las reglas de auditoría.</summary>
        <value>Objeto <see cref="T:System.Type" /> que representa la clase <see cref="T:System.Security.AccessControl.RegistryAuditRule" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Las clases que derivan de la <xref:System.Security.AccessControl.ObjectSecurity> clase invalidación el <xref:System.Security.AccessControl.ObjectSecurity.AuditRuleType%2A> propiedad y devuelva el tipo que se utilizan para representar los derechos de auditoría. Cuando se trabaja con matrices o colecciones que contienen varios tipos de objetos de seguridad, use esta propiedad para determinar el tipo de regla de auditoría correcta para utilizar con cada objeto de seguridad.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RemoveAccessRule">
      <MemberSignature Language="C#" Value="public bool RemoveAccessRule (System.Security.AccessControl.RegistryAccessRule rule);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool RemoveAccessRule(class System.Security.AccessControl.RegistryAccessRule rule) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.AccessControl.RegistrySecurity.RemoveAccessRule(System.Security.AccessControl.RegistryAccessRule)" />
      <MemberSignature Language="VB.NET" Value="Public Function RemoveAccessRule (rule As RegistryAccessRule) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool RemoveAccessRule(System::Security::AccessControl::RegistryAccessRule ^ rule);" />
      <MemberSignature Language="F#" Value="override this.RemoveAccessRule : System.Security.AccessControl.RegistryAccessRule -&gt; bool" Usage="registrySecurity.RemoveAccessRule rule" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rule" Type="System.Security.AccessControl.RegistryAccessRule" />
      </Parameters>
      <Docs>
        <param name="rule">
          <see cref="T:System.Security.AccessControl.RegistryAccessRule" /> que especifica el usuario y <see cref="T:System.Security.AccessControl.AccessControlType" /> que se va a buscar y un conjunto de marcadores de herencia y propagación con los que una regla coincidente, si se encuentra, debe ser compatible. Especifica los derechos que se van a quitar de la regla compatible, si se encuentra.</param>
        <summary>Busca una regla de control de acceso con el mismo usuario y <see cref="T:System.Security.AccessControl.AccessControlType" /> (conceder o denegar) que la regla de acceso especificada y con marcadores de herencia y propagación compatibles; si encuentra este tipo de regla, quita de ésta los derechos contenidos en la regla de acceso especificada.</summary>
        <returns>Es <see langword="true" /> si se ha encontrado una regla compatible; en caso contrario, es <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Actual <xref:System.Security.AccessControl.RegistrySecurity> se busca una regla que tenga el mismo usuario y el mismo <xref:System.Security.AccessControl.AccessControlType> valor como `rule`. Si no se encuentra ninguna de estas reglas, se realiza ninguna acción y el método devuelve `false`. Si se encuentran las reglas de coincidencia, se comprueban los marcadores de herencia y compatibilidad para la compatibilidad con las marcas especificadas en `rule`. Si se encuentra ninguna regla compatible, se realiza ninguna acción y el método devuelve `false`. Si se encuentra una regla con marcadores compatibles, los derechos especifican en `rule` se quitan de la regla compatible, y el método devuelve `true`. Si `rule` especifica los derechos no contenidos en la regla compatible, se realiza ninguna acción con respecto a dichos derechos. Si se quitan todos los derechos de la regla compatible, se quita la regla completa actual <xref:System.Security.AccessControl.RegistrySecurity> objeto.  
  
   
  
## Examples  
 El siguiente ejemplo de código muestra cómo el <xref:System.Security.AccessControl.RegistrySecurity.RemoveAccessRule%2A> método quita los derechos de una regla compatible y cómo el <xref:System.Security.AccessControl.RegistrySecurity.AddAccessRule%2A> método combina los derechos con reglas compatibles.  
  
 El ejemplo se crea un <xref:System.Security.AccessControl.RegistrySecurity> objeto y agrega una regla que permite al usuario actual <xref:System.Security.AccessControl.RegistryRights.ReadKey?displayProperty=nameWithType> derechos. El ejemplo, a continuación, crea una regla que concede al usuario <xref:System.Security.AccessControl.RegistryRights.SetValue?displayProperty=nameWithType>, con la misma herencia y derechos de propagación que la primera regla y usa el <xref:System.Security.AccessControl.RegistrySecurity.RemoveAccessRule%2A> método para quitar esta nueva regla de la <xref:System.Security.AccessControl.RegistrySecurity> objeto. <xref:System.Security.AccessControl.RegistryRights.SetValue> es un componente de <xref:System.Security.AccessControl.RegistryRights.ReadKey>, por lo que se quita de la regla compatible. Las reglas en el <xref:System.Security.AccessControl.RegistrySecurity> objeto se muestran los componentes restantes de <xref:System.Security.AccessControl.RegistryRights.ReadKey>.  
  
 El código de ejemplo, a continuación, llama a la <xref:System.Security.AccessControl.RegistrySecurity.RemoveAccessRule%2A> método para combinar el <xref:System.Security.AccessControl.RegistryRights.SetValue> botón derecho en la regla en el <xref:System.Security.AccessControl.RegistrySecurity> objeto.  
  
> [!NOTE]
>  En este ejemplo no se adjunta el objeto de seguridad a un <xref:Microsoft.Win32.RegistryKey> objeto. El segundo ejemplo de esta sección adjunta un objeto de seguridad, y también lo hacen los ejemplos <xref:Microsoft.Win32.RegistryKey.GetAccessControl%2A?displayProperty=nameWithType> <xref:Microsoft.Win32.RegistryKey.SetAccessControl%2A?displayProperty=nameWithType>.  
  
 [!code-csharp[System.Security.AccessControl.RegistrySecurity.RemoveAccessRule#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Security.AccessControl.RegistrySecurity.RemoveAccessRule/CS/source.cs#1)]
 [!code-vb[System.Security.AccessControl.RegistrySecurity.RemoveAccessRule#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Security.AccessControl.RegistrySecurity.RemoveAccessRule/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El valor de <paramref name="rule" /> es <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="RemoveAccessRuleAll">
      <MemberSignature Language="C#" Value="public void RemoveAccessRuleAll (System.Security.AccessControl.RegistryAccessRule rule);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RemoveAccessRuleAll(class System.Security.AccessControl.RegistryAccessRule rule) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.AccessControl.RegistrySecurity.RemoveAccessRuleAll(System.Security.AccessControl.RegistryAccessRule)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RemoveAccessRuleAll (rule As RegistryAccessRule)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RemoveAccessRuleAll(System::Security::AccessControl::RegistryAccessRule ^ rule);" />
      <MemberSignature Language="F#" Value="override this.RemoveAccessRuleAll : System.Security.AccessControl.RegistryAccessRule -&gt; unit" Usage="registrySecurity.RemoveAccessRuleAll rule" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rule" Type="System.Security.AccessControl.RegistryAccessRule" />
      </Parameters>
      <Docs>
        <param name="rule">
          <see cref="T:System.Security.AccessControl.RegistryAccessRule" /> que especifica el usuario y <see cref="T:System.Security.AccessControl.AccessControlType" /> que se va a buscar. Se pasan por alto los derechos, los marcadores de herencia o los marcadores de propagación especificados por esta regla. </param>
        <summary>Busca todas las reglas de control de acceso con el mismo usuario y <see cref="T:System.Security.AccessControl.AccessControlType" /> (conceder o denegar) que la regla especificada y, si las encuentra, las quita.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Actual <xref:System.Security.AccessControl.RegistrySecurity> se busca en las reglas que tienen el mismo usuario y el mismo <xref:System.Security.AccessControl.AccessControlType> valor como `rule`. Los derechos, marcadores de herencia o marcadores de propagación especificados por `rule` se omiten al realizar esta búsqueda. Si no se encuentra ninguna regla coincidente, se realiza ninguna acción.  
  
 Por ejemplo, si un usuario tiene varias reglas que conceden derechos distintos con diferentes marcadores de herencia y propagación, puede quitar todas esas reglas mediante la creación de un <xref:System.Security.AccessControl.RegistryAccessRule> objeto que especifica el usuario y <xref:System.Security.AccessControl.AccessControlType.Allow?displayProperty=nameWithType>, con los derechos arbitrarios y las marcas, y pasar esa regla para el <xref:System.Security.AccessControl.RegistrySecurity.RemoveAccessRuleAll%2A> método.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra que el <xref:System.Security.AccessControl.RegistrySecurity.RemoveAccessRuleAll%2A> método quita todas las reglas que coinciden con el usuario y <xref:System.Security.AccessControl.AccessControlType>, omitiendo los derechos e indicadores.  
  
 El ejemplo se crea un <xref:System.Security.AccessControl.RegistrySecurity> de objeto y se agregan reglas que conceden y deniegan diferentes derechos para el usuario actual, con marcadores de herencia y propagación diferentes. El ejemplo, a continuación, crea una nueva regla que permite al usuario tomar posesión actual y pasa esa regla para el <xref:System.Security.AccessControl.RegistrySecurity.RemoveAccessRuleAll%2A> método para quitar las dos reglas que permiten el acceso.  
  
> [!NOTE]
>  En este ejemplo no se adjunta el objeto de seguridad a un <xref:Microsoft.Win32.RegistryKey> objeto. Consulte la <xref:Microsoft.Win32.RegistryKey.GetAccessControl%2A?displayProperty=nameWithType> método y el <xref:Microsoft.Win32.RegistryKey.SetAccessControl%2A?displayProperty=nameWithType> método.  
  
 [!code-csharp[System.Security.AccessControl.RegistrySecurity.RemoveAccessRuleAll#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Security.AccessControl.RegistrySecurity.RemoveAccessRuleAll/CS/source.cs#1)]
 [!code-vb[System.Security.AccessControl.RegistrySecurity.RemoveAccessRuleAll#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Security.AccessControl.RegistrySecurity.RemoveAccessRuleAll/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El valor de <paramref name="rule" /> es <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="RemoveAccessRuleSpecific">
      <MemberSignature Language="C#" Value="public void RemoveAccessRuleSpecific (System.Security.AccessControl.RegistryAccessRule rule);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RemoveAccessRuleSpecific(class System.Security.AccessControl.RegistryAccessRule rule) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.AccessControl.RegistrySecurity.RemoveAccessRuleSpecific(System.Security.AccessControl.RegistryAccessRule)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RemoveAccessRuleSpecific (rule As RegistryAccessRule)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RemoveAccessRuleSpecific(System::Security::AccessControl::RegistryAccessRule ^ rule);" />
      <MemberSignature Language="F#" Value="override this.RemoveAccessRuleSpecific : System.Security.AccessControl.RegistryAccessRule -&gt; unit" Usage="registrySecurity.RemoveAccessRuleSpecific rule" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rule" Type="System.Security.AccessControl.RegistryAccessRule" />
      </Parameters>
      <Docs>
        <param name="rule">
          <see cref="T:System.Security.AccessControl.RegistryAccessRule" /> que se va a quitar.</param>
        <summary>Busca una regla de control de acceso que coincida exactamente con la regla especificada y, si la encuentra, la quita.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La regla se quitarán solo si coincide exactamente con `rule` en todos los detalles, incluidas marcas. Otras reglas con el mismo usuario y <xref:System.Security.AccessControl.AccessControlType> no se ven afectados.  
  
> [!IMPORTANT]
>  Una regla representa una o más entradas de control de acceso (ACE) subyacentes y estas entradas se dividen o se combinan según sea necesario cuando se modifican las reglas de seguridad de acceso para un usuario. Por lo tanto, una regla que ya no exista en la forma concreta que tenía cuando se agregó y, en ese caso el <xref:System.Security.AccessControl.RegistrySecurity.RemoveAccessRuleSpecific%2A> método no puede quitarla.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra que el <xref:System.Security.AccessControl.RegistrySecurity.RemoveAccessRuleSpecific%2A> método quita una regla solo si coincide exactamente.  
  
 El ejemplo crea dos reglas que conceden derechos diferentes. Las reglas tienen marcadores de herencia y propagación compatibles, por lo que cuando se agrega la segunda regla se combina con la primera. El ejemplo llama a la <xref:System.Security.AccessControl.RegistrySecurity.RemoveAccessRuleSpecific%2A> método, especificando la primera regla, pero dado que se combinan las reglas no hay ninguna regla que coincida con. El ejemplo llama a la <xref:System.Security.AccessControl.RegistrySecurity.RemoveAccessRule%2A> método para quitar la segunda regla de la regla combinada y, por último, llama a la <xref:System.Security.AccessControl.RegistrySecurity.RemoveAccessRuleSpecific%2A> método para quitar la primera regla.  
  
> [!NOTE]
>  En este ejemplo no se adjunta el objeto de seguridad a un <xref:Microsoft.Win32.RegistryKey> objeto. Consulte la <xref:Microsoft.Win32.RegistryKey.GetAccessControl%2A?displayProperty=nameWithType> método y el <xref:Microsoft.Win32.RegistryKey.SetAccessControl%2A?displayProperty=nameWithType> método.  
  
 [!code-csharp[System.Security.AccessControl.RegistrySecurity.RemoveAccessRuleSpecific#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Security.AccessControl.RegistrySecurity.RemoveAccessRuleSpecific/CS/source.cs#1)]
 [!code-vb[System.Security.AccessControl.RegistrySecurity.RemoveAccessRuleSpecific#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Security.AccessControl.RegistrySecurity.RemoveAccessRuleSpecific/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El valor de <paramref name="rule" /> es <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="RemoveAuditRule">
      <MemberSignature Language="C#" Value="public bool RemoveAuditRule (System.Security.AccessControl.RegistryAuditRule rule);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool RemoveAuditRule(class System.Security.AccessControl.RegistryAuditRule rule) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.AccessControl.RegistrySecurity.RemoveAuditRule(System.Security.AccessControl.RegistryAuditRule)" />
      <MemberSignature Language="VB.NET" Value="Public Function RemoveAuditRule (rule As RegistryAuditRule) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool RemoveAuditRule(System::Security::AccessControl::RegistryAuditRule ^ rule);" />
      <MemberSignature Language="F#" Value="override this.RemoveAuditRule : System.Security.AccessControl.RegistryAuditRule -&gt; bool" Usage="registrySecurity.RemoveAuditRule rule" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rule" Type="System.Security.AccessControl.RegistryAuditRule" />
      </Parameters>
      <Docs>
        <param name="rule">
          <see cref="T:System.Security.AccessControl.RegistryAuditRule" /> que especifica el usuario que se va a buscar y un conjunto de marcadores de herencia y propagación con los que una regla coincidente, si se encuentra, debe ser compatible. Especifica los derechos que se van a quitar de la regla compatible, si se encuentra.</param>
        <summary>Busca una regla de control de auditoría con el mismo usuario que la regla especificada y con marcadores de herencia y propagación compatibles; si encuentra una regla compatible, quita de ésta los derechos contenidos en la regla especificada.</summary>
        <returns>
          <see langword="true" /> si se ha encontrado una regla compatible; en caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Actual <xref:System.Security.AccessControl.RegistrySecurity> se busca una regla de auditoría que tenga el mismo usuario que `rule`. Si no se encuentra ninguna de estas reglas, se realiza ninguna acción y el método devuelve `false`. Si se encuentran las reglas de coincidencia, se comprueban los marcadores de herencia y compatibilidad para la compatibilidad con las marcas especificadas en `rule`. Si se encuentra ninguna regla compatible, se realiza ninguna acción y el método devuelve `false`. Si se encuentra una regla con marcadores compatibles, los derechos especifican en `rule` se quitan de la regla compatible, y el método devuelve `true`. Si `rule` especifica los derechos no contenidos en la regla compatible, se realiza ninguna acción con respecto a dichos derechos. Si se quitan todos los derechos de la regla compatible, se quita la regla completa actual <xref:System.Security.AccessControl.RegistrySecurity> objeto.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El valor de <paramref name="rule" /> es <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="RemoveAuditRuleAll">
      <MemberSignature Language="C#" Value="public void RemoveAuditRuleAll (System.Security.AccessControl.RegistryAuditRule rule);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RemoveAuditRuleAll(class System.Security.AccessControl.RegistryAuditRule rule) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.AccessControl.RegistrySecurity.RemoveAuditRuleAll(System.Security.AccessControl.RegistryAuditRule)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RemoveAuditRuleAll (rule As RegistryAuditRule)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RemoveAuditRuleAll(System::Security::AccessControl::RegistryAuditRule ^ rule);" />
      <MemberSignature Language="F#" Value="override this.RemoveAuditRuleAll : System.Security.AccessControl.RegistryAuditRule -&gt; unit" Usage="registrySecurity.RemoveAuditRuleAll rule" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rule" Type="System.Security.AccessControl.RegistryAuditRule" />
      </Parameters>
      <Docs>
        <param name="rule">
          <see cref="T:System.Security.AccessControl.RegistryAuditRule" /> que especifica el usuario que se va a buscar. Se pasan por alto los derechos, los marcadores de herencia o los marcadores de propagación especificados por esta regla. </param>
        <summary>Busca todas las reglas de auditoría con el mismo usuario que la regla especificada y, si las encuentra, las quita.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Actual <xref:System.Security.AccessControl.RegistrySecurity> se busca en las reglas de auditoría que tienen el mismo usuario que `rule`. Los derechos, marcadores de herencia o marcadores de propagación especificados por `rule` se omiten al realizar esta búsqueda. Si no se encuentra ninguna regla coincidente, se realiza ninguna acción.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El valor de <paramref name="rule" /> es <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="RemoveAuditRuleSpecific">
      <MemberSignature Language="C#" Value="public void RemoveAuditRuleSpecific (System.Security.AccessControl.RegistryAuditRule rule);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RemoveAuditRuleSpecific(class System.Security.AccessControl.RegistryAuditRule rule) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.AccessControl.RegistrySecurity.RemoveAuditRuleSpecific(System.Security.AccessControl.RegistryAuditRule)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RemoveAuditRuleSpecific (rule As RegistryAuditRule)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RemoveAuditRuleSpecific(System::Security::AccessControl::RegistryAuditRule ^ rule);" />
      <MemberSignature Language="F#" Value="override this.RemoveAuditRuleSpecific : System.Security.AccessControl.RegistryAuditRule -&gt; unit" Usage="registrySecurity.RemoveAuditRuleSpecific rule" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rule" Type="System.Security.AccessControl.RegistryAuditRule" />
      </Parameters>
      <Docs>
        <param name="rule">
          <see cref="T:System.Security.AccessControl.RegistryAuditRule" /> que se va a quitar.</param>
        <summary>Busca una regla de auditoría que coincida exactamente con la regla especificada y, si la encuentra, la quita.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La regla se quitarán solo si coincide exactamente con `rule` en todos los detalles, incluidas marcas. No se ven afectadas otras reglas de auditoría para el mismo usuario.  
  
> [!IMPORTANT]
>  Una regla representa una o más entradas de control de acceso (ACE) subyacentes y estas entradas se dividen o se combinan según sea necesario cuando se modifican las reglas de seguridad de auditoría para un usuario. Por lo tanto, una regla que ya no exista en la forma concreta que tenía cuando se agregó y, en ese caso el <xref:System.Security.AccessControl.RegistrySecurity.RemoveAuditRuleSpecific%2A> método no puede quitarla.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El valor de <paramref name="rule" /> es <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ResetAccessRule">
      <MemberSignature Language="C#" Value="public void ResetAccessRule (System.Security.AccessControl.RegistryAccessRule rule);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ResetAccessRule(class System.Security.AccessControl.RegistryAccessRule rule) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.AccessControl.RegistrySecurity.ResetAccessRule(System.Security.AccessControl.RegistryAccessRule)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ResetAccessRule (rule As RegistryAccessRule)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ResetAccessRule(System::Security::AccessControl::RegistryAccessRule ^ rule);" />
      <MemberSignature Language="F#" Value="override this.ResetAccessRule : System.Security.AccessControl.RegistryAccessRule -&gt; unit" Usage="registrySecurity.ResetAccessRule rule" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rule" Type="System.Security.AccessControl.RegistryAccessRule" />
      </Parameters>
      <Docs>
        <param name="rule">
          <see cref="T:System.Security.AccessControl.RegistryAccessRule" /> que se va a agregar. El usuario especificado por esta regla determina las reglas que se van a quitar antes de agregar esta regla.</param>
        <summary>Quita todas las reglas de control de acceso con el mismo usuario que la regla especificada, independientemente de <see cref="T:System.Security.AccessControl.AccessControlType" />, y, a continuación, agrega la regla especificada.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si no hay ninguna regla de acceso cuyo usuario coincide con la regla especificada, `rule` se agrega.  
  
   
  
## Examples  
 El siguiente ejemplo de código muestra cómo el <xref:System.Security.AccessControl.RegistrySecurity.ResetAccessRule%2A> método reemplaza todas las reglas de usuario coincidentes con la regla especificada para la coincidencia.  
  
 El ejemplo se crea un <xref:System.Security.AccessControl.RegistrySecurity> de objeto y se agregan reglas que conceden y deniegan diferentes derechos para el usuario actual, con marcadores de herencia y propagación diferentes. El ejemplo, a continuación, crea una nueva regla que permite al usuario solo leer la clave actual y usa el <xref:System.Security.AccessControl.RegistrySecurity.ResetAccessRule%2A> método para quitar todas las reglas para el usuario y reemplazarlos por la nueva regla.  
  
> [!NOTE]
>  En este ejemplo no se adjunta el objeto de seguridad a un <xref:Microsoft.Win32.RegistryKey> objeto. Consulte la <xref:Microsoft.Win32.RegistryKey.GetAccessControl%2A?displayProperty=nameWithType> método y el <xref:Microsoft.Win32.RegistryKey.SetAccessControl%2A?displayProperty=nameWithType> método.  
  
 [!code-csharp[System.Security.AccessControl.RegistrySecurity.ResetAccessRule#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Security.AccessControl.RegistrySecurity.ResetAccessRule/CS/source.cs#1)]
 [!code-vb[System.Security.AccessControl.RegistrySecurity.ResetAccessRule#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Security.AccessControl.RegistrySecurity.ResetAccessRule/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetAccessRule">
      <MemberSignature Language="C#" Value="public void SetAccessRule (System.Security.AccessControl.RegistryAccessRule rule);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetAccessRule(class System.Security.AccessControl.RegistryAccessRule rule) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.AccessControl.RegistrySecurity.SetAccessRule(System.Security.AccessControl.RegistryAccessRule)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetAccessRule (rule As RegistryAccessRule)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetAccessRule(System::Security::AccessControl::RegistryAccessRule ^ rule);" />
      <MemberSignature Language="F#" Value="override this.SetAccessRule : System.Security.AccessControl.RegistryAccessRule -&gt; unit" Usage="registrySecurity.SetAccessRule rule" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rule" Type="System.Security.AccessControl.RegistryAccessRule" />
      </Parameters>
      <Docs>
        <param name="rule">
          <see cref="T:System.Security.AccessControl.RegistryAccessRule" /> que se va a agregar. El usuario y el objeto <see cref="T:System.Security.AccessControl.AccessControlType" /> de esta regla determinan las reglas que se van a quitar antes de agregar esta regla.</param>
        <summary>Quita todas las reglas de control de acceso con el mismo usuario y <see cref="T:System.Security.AccessControl.AccessControlType" /> (conceder o denegar) que la regla especificada y, a continuación, agrega la regla especificada.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si la regla especificada tiene <xref:System.Security.AccessControl.AccessControlType.Allow>, es el efecto de este método quitar todos los <xref:System.Security.AccessControl.AccessControlType.Allow> reglas para el usuario especificado, reemplazándolos por la regla especificada. Si la regla especificada tiene <xref:System.Security.AccessControl.AccessControlType.Deny>, todos los <xref:System.Security.AccessControl.AccessControlType.Deny> reglas para el usuario especificado se reemplazan por la regla especificada.  
  
 Si no hay ninguna regla cuyo usuario y <xref:System.Security.AccessControl.AccessControlType> coincide con la regla especificada, `rule` se agrega.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra que el <xref:System.Security.AccessControl.RegistrySecurity.SetAccessRule%2A> método quita todas las reglas que coinciden con el usuario y la <xref:System.Security.AccessControl.AccessControlType> de `rule`, omitiendo los derechos e indicadores y los reemplaza con `rule`.  
  
 El ejemplo se crea un <xref:System.Security.AccessControl.RegistrySecurity> de objeto y se agregan reglas que conceden y deniegan diferentes derechos para el usuario actual, con marcadores de herencia y propagación diferentes. El ejemplo, a continuación, crea una nueva regla que permite al usuario solo leer la clave actual y usa el <xref:System.Security.AccessControl.RegistrySecurity.SetAccessRule%2A> método para quitar las dos reglas que permiten el acceso y reemplazarlos por la nueva regla. No se ve afectada la regla que deniegue el acceso.  
  
> [!NOTE]
>  En este ejemplo no se adjunta el objeto de seguridad a un <xref:Microsoft.Win32.RegistryKey> objeto. Consulte la <xref:Microsoft.Win32.RegistryKey.GetAccessControl%2A?displayProperty=nameWithType> método y el <xref:Microsoft.Win32.RegistryKey.SetAccessControl%2A?displayProperty=nameWithType> método.  
  
 [!code-csharp[System.Security.AccessControl.RegistrySecurity.SetAccessRule#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Security.AccessControl.RegistrySecurity.SetAccessRule/CS/source.cs#1)]
 [!code-vb[System.Security.AccessControl.RegistrySecurity.SetAccessRule#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Security.AccessControl.RegistrySecurity.SetAccessRule/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El valor de <paramref name="rule" /> es <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="SetAuditRule">
      <MemberSignature Language="C#" Value="public void SetAuditRule (System.Security.AccessControl.RegistryAuditRule rule);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetAuditRule(class System.Security.AccessControl.RegistryAuditRule rule) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.AccessControl.RegistrySecurity.SetAuditRule(System.Security.AccessControl.RegistryAuditRule)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetAuditRule (rule As RegistryAuditRule)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetAuditRule(System::Security::AccessControl::RegistryAuditRule ^ rule);" />
      <MemberSignature Language="F#" Value="override this.SetAuditRule : System.Security.AccessControl.RegistryAuditRule -&gt; unit" Usage="registrySecurity.SetAuditRule rule" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rule" Type="System.Security.AccessControl.RegistryAuditRule" />
      </Parameters>
      <Docs>
        <param name="rule">
          <see cref="T:System.Security.AccessControl.RegistryAuditRule" /> que se va a agregar. El usuario especificado por esta regla determina las reglas que se van a quitar antes de agregar esta regla.</param>
        <summary>Quita todas las reglas de auditoría con el mismo usuario que la regla especificada, sin tener en cuenta el valor de <see cref="T:System.Security.AccessControl.AuditFlags" />, y, a continuación, agrega la regla especificada.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si no hay ninguna regla de auditoría cuyo usuario coincide con la regla especificada, `rule` se agrega.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El valor de <paramref name="rule" /> es <see langword="null" />.</exception>
      </Docs>
    </Member>
  </Members>
</Type>