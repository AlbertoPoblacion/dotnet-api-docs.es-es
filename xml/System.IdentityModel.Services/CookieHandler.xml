<Type Name="CookieHandler" FullName="System.IdentityModel.Services.CookieHandler">
  <Metadata><Meta Name="ms.openlocfilehash" Value="e234c79bb977b762d5493ec4745d5160bd1fccba" /><Meta Name="ms.sourcegitcommit" Value="16d2d159872fd213cae4b8f371d7ae9c8b027c89" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="es-ES" /><Meta Name="ms.lasthandoff" Value="11/17/2018" /><Meta Name="ms.locfileid" Value="51932640" /></Metadata><TypeSignature Language="C#" Value="public abstract class CookieHandler" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract beforefieldinit CookieHandler extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.IdentityModel.Services.CookieHandler" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class CookieHandler" />
  <TypeSignature Language="C++ CLI" Value="public ref class CookieHandler abstract" />
  <TypeSignature Language="F#" Value="type CookieHandler = class" />
  <AssemblyInfo>
    <AssemblyName>System.IdentityModel.Services</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Proporciona una clase base abstracta para leer, escribir, y eliminar las cookies de sesión en un cliente HTTP.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.IdentityModel.Services.SessionAuthenticationModule> (SAM) utiliza una instancia de la <xref:System.IdentityModel.Services.CookieHandler> clase para leer, escribir y eliminar la cookie o las cookies que contienen el <xref:System.IdentityModel.Tokens.SessionSecurityToken> en el cliente HTTP. La cookie (o las cookies, en el caso de que el token de sesión se divida en varias cookies) que contiene la sesión de símbolo (token) se conoce como la cookie de sesión.  
  
 Windows Identity Foundation (WIF) se distribuye con un controlador de cookies que llama el controlador de cookies fragmentado que implementa el <xref:System.IdentityModel.Services.ChunkedCookieHandler> clase. El controlador de cookies fragmentado divide el token de sesión a través de una o más cookies según un tamaño de fragmento especificado. Esto es para cumplir con las limitaciones de tamaño en cookies individuales impuestas por muchos exploradores.  
  
 Puede derivar de <xref:System.IdentityModel.Services.CookieHandler> para crear su propio controlador de cookies. Al hacerlo, se debe reemplazar el <xref:System.IdentityModel.Services.CookieHandler.DeleteCore%2A>, <xref:System.IdentityModel.Services.CookieHandler.ReadCore%2A>, y <xref:System.IdentityModel.Services.CookieHandler.WriteCore%2A> métodos para realizar el trabajo real de eliminar, leer y escribir la cookie de sesión. Estos métodos normalmente leen la cookie de la <xref:System.Web.HttpRequest.Cookies%2A?displayProperty=nameWithType> recopilación y escritura o eliminación de cookies por medio de la <xref:System.Web.HttpResponse.Cookies%2A?displayProperty=nameWithType> colección. La <xref:System.Web.HttpContext> objeto a través del cual se puede acceder a la solicitud y respuesta se proporciona como un parámetro para cada uno de estos métodos. Además de los métodos necesarios, opcionalmente, puede invalidar otras propiedades de los métodos virtuales expuestas por la <xref:System.IdentityModel.Services.CookieHandler> clase para personalizar el comportamiento de su controlador.  
  
 Varias propiedades expuestas por la <xref:System.IdentityModel.Services.CookieHandler> clase que especifican el comportamiento predeterminado y las propiedades de la cookie de sesión. El <xref:System.IdentityModel.Services.CookieHandler.Name%2A>, <xref:System.IdentityModel.Services.CookieHandler.Domain%2A>, y <xref:System.IdentityModel.Services.CookieHandler.Path%2A> propiedades proporcionar el nombre base para la cookie, el dominio en el que es válida y la ruta de acceso bajo la cual se almacena en el cliente. El <xref:System.IdentityModel.Services.CookieHandler.HideFromClientScript%2A> propiedad especifica si la cookie es accesible a los scripts del lado cliente. El <xref:System.IdentityModel.Services.CookieHandler.RequireSsl%2A> propiedad especifica si se debe transmitir la cookie solo a través de conexiones seguras (HTTPS). Si se establece, el <xref:System.IdentityModel.Services.CookieHandler.PersistentSessionLifetime%2A> propiedad se usa para establecer la hora de expiración para las sesiones persistentes, que es para las sesiones que siguen siendo válidas incluso después de cerrar el explorador. Todas estas propiedades tienen propiedades equivalentes que normalmente se establecen en subyacente <xref:System.Web.HttpCookie> objeto (u objetos) mediante los métodos "core" del controlador. Para obtener más información, consulte la documentación para cada propiedad.  
  
 El controlador de cookies que usa SAM se puede especificar en la configuración a través de la [ &lt;cookieHandler&gt; ](~/docs/framework/configure-apps/file-schema/windows-identity-foundation/cookiehandler.md) elemento. El controlador de cookies establecido por este elemento puede modificarse en un delegado de eventos para el <xref:System.IdentityModel.Services.FederatedAuthentication.FederationConfigurationCreated?displayProperty=nameWithType> eventos, o bien se puede establecer o acceder directamente a través del <xref:System.IdentityModel.Services.SessionAuthenticationModule.CookieHandler%2A?displayProperty=nameWithType> propiedad.  
  
   
  
## Examples  
 El ejemplo siguiente configura el SAM para usar un controlador de cookies personalizado del tipo `MyNamespace.MyCustomCookieHandler`.  
  
```xml  
<cookieHandler mode="Custom">  
    <customCookieHandler type="MyNamespace.MyCustomCookieHandler, MyAssembly" />  
</cookieHandler>  
```  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.IdentityModel.Services.ChunkedCookieHandler" />
    <related type="Article" href="https://msdn.microsoft.com/library/bfdc127f-8d94-4566-8bef-f583c6ae7398">&lt;cookieHandler&gt;</related>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected CookieHandler ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Services.CookieHandler.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; CookieHandler();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel.Services</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Se llama desde constructores de clases derivadas para inicializar la clase <see cref="T:System.IdentityModel.Services.CookieHandler" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Delete">
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel.Services</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Elimina una cookie.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Delete">
      <MemberSignature Language="C#" Value="public void Delete ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Delete() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Services.CookieHandler.Delete" />
      <MemberSignature Language="VB.NET" Value="Public Sub Delete ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Delete();" />
      <MemberSignature Language="F#" Value="member this.Delete : unit -&gt; unit" Usage="cookieHandler.Delete " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel.Services</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Elimina la cookie asociada con la solicitud actual que tiene el nombre, la ruta de acceso y el dominio predeterminados.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El nombre, dominio y ruta de acceso se especifican mediante el <xref:System.IdentityModel.Services.CookieHandler.Name%2A>, <xref:System.IdentityModel.Services.CookieHandler.Domain%2A>, y <xref:System.IdentityModel.Services.CookieHandler.Path%2A> propiedades. La solicitud se especifica mediante <xref:System.Web.HttpContext.Current%2A?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Delete">
      <MemberSignature Language="C#" Value="public void Delete (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Delete(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Services.CookieHandler.Delete(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Delete (name As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Delete(System::String ^ name);" />
      <MemberSignature Language="F#" Value="member this.Delete : string -&gt; unit" Usage="cookieHandler.Delete name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel.Services</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">El nombre de la cookie.</param>
        <summary>Elimina la cookie asociada con la solicitud actual que tiene el nombre especificado, y el dominio y la ruta de acceso predeterminados.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El dominio y la ruta de acceso especificadas por el <xref:System.IdentityModel.Services.CookieHandler.Domain%2A> y <xref:System.IdentityModel.Services.CookieHandler.Path%2A> propiedades. La solicitud se especifica mediante <xref:System.Web.HttpContext.Current%2A?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El valor de <paramref name="name" /> es <see langword="null" /> o está vacío.</exception>
      </Docs>
    </Member>
    <Member MemberName="Delete">
      <MemberSignature Language="C#" Value="public void Delete (System.Web.HttpContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Delete(class System.Web.HttpContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Services.CookieHandler.Delete(System.Web.HttpContext)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Delete (context As HttpContext)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Delete(System::Web::HttpContext ^ context);" />
      <MemberSignature Language="F#" Value="member this.Delete : System.Web.HttpContext -&gt; unit" Usage="cookieHandler.Delete context" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel.Services</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="context" Type="System.Web.HttpContext" />
      </Parameters>
      <Docs>
        <param name="context"><see cref="T:System.Web.HttpContext" /> de la solicitud.</param>
        <summary>Elimina la cookie asociada con la solicitud actual que tiene el nombre, la ruta de acceso y el dominio predeterminados.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El nombre, dominio y ruta de acceso se especifican mediante el <xref:System.IdentityModel.Services.CookieHandler.Name%2A>, <xref:System.IdentityModel.Services.CookieHandler.Domain%2A>, y <xref:System.IdentityModel.Services.CookieHandler.Path%2A> propiedades.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Delete">
      <MemberSignature Language="C#" Value="public void Delete (string name, System.Web.HttpContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Delete(string name, class System.Web.HttpContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Services.CookieHandler.Delete(System.String,System.Web.HttpContext)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Delete (name As String, context As HttpContext)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Delete(System::String ^ name, System::Web::HttpContext ^ context);" />
      <MemberSignature Language="F#" Value="member this.Delete : string * System.Web.HttpContext -&gt; unit" Usage="cookieHandler.Delete (name, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel.Services</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="context" Type="System.Web.HttpContext" />
      </Parameters>
      <Docs>
        <param name="name">El nombre de la cookie.</param>
        <param name="context"><see cref="T:System.Web.HttpContext" /> de la solicitud.</param>
        <summary>Elimina la cookie asociada con la solicitud especificada que tiene el nombre especificado, y el dominio y la ruta de acceso predeterminados.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El dominio y la ruta de acceso especificadas por el <xref:System.IdentityModel.Services.CookieHandler.Domain%2A> y <xref:System.IdentityModel.Services.CookieHandler.Path%2A> propiedades.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El valor de <paramref name="name" /> es <see langword="null" /> o está vacío.</exception>
      </Docs>
    </Member>
    <Member MemberName="Delete">
      <MemberSignature Language="C#" Value="public void Delete (string name, string path, string domain, System.Web.HttpContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Delete(string name, string path, string domain, class System.Web.HttpContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Services.CookieHandler.Delete(System.String,System.String,System.String,System.Web.HttpContext)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Delete (name As String, path As String, domain As String, context As HttpContext)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Delete(System::String ^ name, System::String ^ path, System::String ^ domain, System::Web::HttpContext ^ context);" />
      <MemberSignature Language="F#" Value="member this.Delete : string * string * string * System.Web.HttpContext -&gt; unit" Usage="cookieHandler.Delete (name, path, domain, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel.Services</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="domain" Type="System.String" />
        <Parameter Name="context" Type="System.Web.HttpContext" />
      </Parameters>
      <Docs>
        <param name="name">El nombre de la cookie.</param>
        <param name="path">La ruta de acceso de la cookie.</param>
        <param name="domain">Dominio de la cookie.</param>
        <param name="context"><see cref="T:System.Web.HttpContext" /> para la solicitud.</param>
        <summary>Elimina la cookie asociada con la solicitud especificada que tiene el nombre, la ruta de acceso y el dominio especificados.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">El valor de <paramref name="name" /> es <see langword="null" /> o está vacío.</exception>
      </Docs>
    </Member>
    <Member MemberName="DeleteCore">
      <MemberSignature Language="C#" Value="protected abstract void DeleteCore (string name, string path, string domain, System.Web.HttpContext context);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void DeleteCore(string name, string path, string domain, class System.Web.HttpContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Services.CookieHandler.DeleteCore(System.String,System.String,System.String,System.Web.HttpContext)" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Sub DeleteCore (name As String, path As String, domain As String, context As HttpContext)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract void DeleteCore(System::String ^ name, System::String ^ path, System::String ^ domain, System::Web::HttpContext ^ context);" />
      <MemberSignature Language="F#" Value="abstract member DeleteCore : string * string * string * System.Web.HttpContext -&gt; unit" Usage="cookieHandler.DeleteCore (name, path, domain, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel.Services</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="domain" Type="System.String" />
        <Parameter Name="context" Type="System.Web.HttpContext" />
      </Parameters>
      <Docs>
        <param name="name">Nombre de la cookie.</param>
        <param name="path">La ruta de acceso de la cookie.</param>
        <param name="domain">Dominio de la cookie.</param>
        <param name="context"><see cref="T:System.Web.HttpContext" /> de la solicitud.</param>
        <summary>Cuando se reemplaza en una clase derivada, elimina la cookie asociada a la solicitud especificada que tiene el nombre, el dominio y la ruta de acceso especificados.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se llama desde sobrecargado <xref:System.IdentityModel.Services.CookieHandler.Delete%2A> métodos para hacer el trabajo real de la eliminación de la cookie. El <xref:System.IdentityModel.Services.CookieHandler.Delete%2A> métodos garantizará que el nombre y ruta de acceso son cadenas de no vacío.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Debe invalidar este método. La implementación es depende totalmente del desarrollador. En el caso típico, las implementaciones de reemplazar la cookie especificada en el <see cref="P:System.Web.HttpResponse.Cookies" /> colección, con una cookie con <see langword="null" /> datos y un tiempo de expiración se establece anteriores a la hora actual; sin embargo, esto no es un requisito.</para></block>
      </Docs>
    </Member>
    <Member MemberName="Domain">
      <MemberSignature Language="C#" Value="public virtual string Domain { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Domain" />
      <MemberSignature Language="DocId" Value="P:System.IdentityModel.Services.CookieHandler.Domain" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property Domain As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ Domain { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Domain : string with get, set" Usage="System.IdentityModel.Services.CookieHandler.Domain" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel.Services</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece el dominio usado para las cookies.</summary>
        <value>Dominio usado para las cookies. El valor predeterminado es <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Corresponde a la propiedad <xref:System.Web.HttpCookie.Domain%2A?displayProperty=nameWithType>.  
  
 Se puede inicializar la propiedad especificando el `domain` atributo el [ &lt;cookieHandler&gt; ](~/docs/framework/configure-apps/file-schema/windows-identity-foundation/cookiehandler.md) elemento de configuración.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/bfdc127f-8d94-4566-8bef-f583c6ae7398">&lt;cookieHandler&gt;</related>
      </Docs>
    </Member>
    <Member MemberName="HideFromClientScript">
      <MemberSignature Language="C#" Value="public virtual bool HideFromClientScript { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool HideFromClientScript" />
      <MemberSignature Language="DocId" Value="P:System.IdentityModel.Services.CookieHandler.HideFromClientScript" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property HideFromClientScript As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool HideFromClientScript { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.HideFromClientScript : bool with get, set" Usage="System.IdentityModel.Services.CookieHandler.HideFromClientScript" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel.Services</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece un valor que indica si la cookie se debe ocultar del script cliente.</summary>
        <value><see langword="true" /> si la cookie debe estar oculta del script de cliente; si no, <see langword="false" />. El valor predeterminado es <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Controla si se genera el indicador "HttpOnly" en el encabezado Set-Cookie para las cookies escritas por el controlador. Algunos exploradores web respetan esta marca manteniendo el script de cliente de acceso al valor de cookie.  
  
 Esta propiedad se corresponde con el <xref:System.Web.HttpCookie.HttpOnly%2A?displayProperty=nameWithType> propiedad.  
  
 Se puede inicializar la propiedad especificando el `hideFromScript` atributo el [ &lt;cookieHandler&gt; ](~/docs/framework/configure-apps/file-schema/windows-identity-foundation/cookiehandler.md) elemento de configuración.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MatchCookiePath">
      <MemberSignature Language="C#" Value="public virtual string MatchCookiePath (Uri baseUri, Uri targetUri);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string MatchCookiePath(class System.Uri baseUri, class System.Uri targetUri) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Services.CookieHandler.MatchCookiePath(System.Uri,System.Uri)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function MatchCookiePath (baseUri As Uri, targetUri As Uri) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ MatchCookiePath(Uri ^ baseUri, Uri ^ targetUri);" />
      <MemberSignature Language="F#" Value="abstract member MatchCookiePath : Uri * Uri -&gt; string&#xA;override this.MatchCookiePath : Uri * Uri -&gt; string" Usage="cookieHandler.MatchCookiePath (baseUri, targetUri)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel.Services</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="baseUri" Type="System.Uri" />
        <Parameter Name="targetUri" Type="System.Uri" />
      </Parameters>
      <Docs>
        <param name="baseUri">Dirección URL base de la solicitud.</param>
        <param name="targetUri">URL que se va a comparar.</param>
        <summary>Si el dominio de destino está dentro del dominio de la cookie y la ruta de acceso de destino está dentro de la ruta de acceso de la cookie, coincide con el uso de mayúsculas y minúsculas de la parte de la ruta de acceso de la cookie.</summary>
        <returns>Devuelve <see cref="T:System.String" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public virtual string Name { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Name" />
      <MemberSignature Language="DocId" Value="P:System.IdentityModel.Services.CookieHandler.Name" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property Name As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ Name { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Name : string with get, set" Usage="System.IdentityModel.Services.CookieHandler.Name" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel.Services</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece el nombre base para las cookies escritas por el controlador.</summary>
        <value>El nombre base para usar las cookies. El valor predeterminado es "FedAuth".</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esta propiedad se corresponde con el <xref:System.Web.HttpCookie.Name%2A?displayProperty=nameWithType> propiedad.  
  
 Se puede inicializar la propiedad especificando el `name` atributo el [ &lt;cookieHandler&gt; ](~/docs/framework/configure-apps/file-schema/windows-identity-foundation/cookiehandler.md) elemento de configuración.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Se produce un intento de establecer un valor <see langword="null" /> o vacío.</exception>
      </Docs>
    </Member>
    <Member MemberName="Path">
      <MemberSignature Language="C#" Value="public virtual string Path { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Path" />
      <MemberSignature Language="DocId" Value="P:System.IdentityModel.Services.CookieHandler.Path" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property Path As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ Path { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Path : string with get, set" Usage="System.IdentityModel.Services.CookieHandler.Path" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel.Services</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece el valor de la ruta virtual para las cookies creadas por el controlador.</summary>
        <value>Ruta de acceso virtual. Valores predeterminados de la raíz de la aplicación ASP.NET.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esta propiedad se corresponde con el <xref:System.Web.HttpCookie.Path%2A?displayProperty=nameWithType> propiedad.  
  
 Se puede inicializar la propiedad especificando el `path` atributo el [ &lt;cookieHandler&gt; ](~/docs/framework/configure-apps/file-schema/windows-identity-foundation/cookiehandler.md) elemento de configuración.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Se produce un intento de establecer un valor <see langword="null" /> o vacío.</exception>
      </Docs>
    </Member>
    <Member MemberName="PersistentSessionLifetime">
      <MemberSignature Language="C#" Value="public virtual Nullable&lt;TimeSpan&gt; PersistentSessionLifetime { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Nullable`1&lt;valuetype System.TimeSpan&gt; PersistentSessionLifetime" />
      <MemberSignature Language="DocId" Value="P:System.IdentityModel.Services.CookieHandler.PersistentSessionLifetime" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property PersistentSessionLifetime As Nullable(Of TimeSpan)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property Nullable&lt;TimeSpan&gt; PersistentSessionLifetime { Nullable&lt;TimeSpan&gt; get(); void set(Nullable&lt;TimeSpan&gt; value); };" />
      <MemberSignature Language="F#" Value="member this.PersistentSessionLifetime : Nullable&lt;TimeSpan&gt; with get, set" Usage="System.IdentityModel.Services.CookieHandler.PersistentSessionLifetime" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel.Services</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.TimeSpan&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Duración de sesiones persistentes. Si es cero, siempre se usan sesiones transitorias.</summary>
        <value>Duración de sesión. El valor predeterminado es <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Vales para las sesiones persistentes se almacenan en cookies basada en archivos, lo que significa que el inicio de sesión continúe después de que se cierra y vuelve a abrir el explorador web.  
  
 Esta propiedad se usa para establecer el <xref:System.Web.HttpCookie.Expires%2A?displayProperty=nameWithType> propiedad.  
  
 Se puede inicializar la propiedad especificando el `persistentSessionLifetime` atributo el [ &lt;cookieHandler&gt; ](~/docs/framework/configure-apps/file-schema/windows-identity-foundation/cookiehandler.md) elemento de configuración.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Se especifica un valor que es menor que cero.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Read">
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel.Services</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Lee una cookie.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Read">
      <MemberSignature Language="C#" Value="public byte[] Read ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance unsigned int8[] Read() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Services.CookieHandler.Read" />
      <MemberSignature Language="VB.NET" Value="Public Function Read () As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::Byte&gt; ^ Read();" />
      <MemberSignature Language="F#" Value="member this.Read : unit -&gt; byte[]" Usage="cookieHandler.Read " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel.Services</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Lee la cookie asociada con la solicitud actual que tiene el nombre predeterminado.</summary>
        <returns>Valor de cookie o <see langword="null" /> si la cookie no se encontró.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El nombre de la cookie se especifica mediante el <xref:System.IdentityModel.Services.CookieHandler.Name%2A> propiedad. La solicitud se especifica por <xref:System.Web.HttpContext.Current%2A?displayProperty=nameWithType>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Read">
      <MemberSignature Language="C#" Value="public byte[] Read (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance unsigned int8[] Read(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Services.CookieHandler.Read(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function Read (name As String) As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::Byte&gt; ^ Read(System::String ^ name);" />
      <MemberSignature Language="F#" Value="member this.Read : string -&gt; byte[]" Usage="cookieHandler.Read name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel.Services</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Nombre de la cookie que se va a leer.</param>
        <summary>Lee la cookie asociada con la solicitud actual que tiene el nombre especificado.</summary>
        <returns>Valor de cookie o <see langword="null" /> si la cookie no se encontró.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La solicitud se especifica mediante <xref:System.Web.HttpContext.Current%2A?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">El valor de <paramref name="name" /> es <see langword="null" /> o está vacío.</exception>
      </Docs>
    </Member>
    <Member MemberName="Read">
      <MemberSignature Language="C#" Value="public byte[] Read (System.Web.HttpContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance unsigned int8[] Read(class System.Web.HttpContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Services.CookieHandler.Read(System.Web.HttpContext)" />
      <MemberSignature Language="VB.NET" Value="Public Function Read (context As HttpContext) As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::Byte&gt; ^ Read(System::Web::HttpContext ^ context);" />
      <MemberSignature Language="F#" Value="member this.Read : System.Web.HttpContext -&gt; byte[]" Usage="cookieHandler.Read context" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel.Services</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="context" Type="System.Web.HttpContext" />
      </Parameters>
      <Docs>
        <param name="context"><see cref="T:System.Web.HttpContext" /> de la solicitud.</param>
        <summary>Lee la cookie asociada con la solicitud actual que tiene el nombre, la ruta de acceso y el dominio predeterminados.</summary>
        <returns>Valor de cookie o <see langword="null" /> si la cookie no se encontró.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El nombre de la cookie se especifica mediante el <xref:System.IdentityModel.Services.CookieHandler.Name%2A> propiedad.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Read">
      <MemberSignature Language="C#" Value="public byte[] Read (string name, System.Web.HttpContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance unsigned int8[] Read(string name, class System.Web.HttpContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Services.CookieHandler.Read(System.String,System.Web.HttpContext)" />
      <MemberSignature Language="VB.NET" Value="Public Function Read (name As String, context As HttpContext) As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::Byte&gt; ^ Read(System::String ^ name, System::Web::HttpContext ^ context);" />
      <MemberSignature Language="F#" Value="member this.Read : string * System.Web.HttpContext -&gt; byte[]" Usage="cookieHandler.Read (name, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel.Services</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="context" Type="System.Web.HttpContext" />
      </Parameters>
      <Docs>
        <param name="name">Nombre de la cookie que se va a leer.</param>
        <param name="context"><see cref="T:System.Web.HttpContext" /> de la solicitud.</param>
        <summary>Lee la cookie asociada con la solicitud especificada que tiene el nombre especificado y el dominio y la ruta de acceso predeterminados.</summary>
        <returns>Valor de cookie o <see langword="null" /> si la cookie no se encontró.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException">El valor de <paramref name="name" /> es <see langword="null" /> o está vacío.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadCore">
      <MemberSignature Language="C#" Value="protected abstract byte[] ReadCore (string name, System.Web.HttpContext context);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance unsigned int8[] ReadCore(string name, class System.Web.HttpContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Services.CookieHandler.ReadCore(System.String,System.Web.HttpContext)" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Function ReadCore (name As String, context As HttpContext) As Byte()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract cli::array &lt;System::Byte&gt; ^ ReadCore(System::String ^ name, System::Web::HttpContext ^ context);" />
      <MemberSignature Language="F#" Value="abstract member ReadCore : string * System.Web.HttpContext -&gt; byte[]" Usage="cookieHandler.ReadCore (name, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel.Services</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="context" Type="System.Web.HttpContext" />
      </Parameters>
      <Docs>
        <param name="name">Nombre de la cookie.</param>
        <param name="context"><see cref="T:System.Web.HttpContext" /> de la solicitud.</param>
        <summary>Cuando se reemplaza en una clase derivada, lee la cookie que tiene el nombre especificado y que está asociada a la solicitud especificada.</summary>
        <returns>Valor de cookie o <see langword="null" /> si la cookie no se encontró.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se llama desde sobrecargado <xref:System.IdentityModel.Services.CookieHandler.Read%2A> métodos para hacer el trabajo real de leer la cookie. El <xref:System.IdentityModel.Services.CookieHandler.Read%2A> métodos garantizará que `name` es una cadena no vacía.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Debe invalidar este método. La implementación es depende totalmente del desarrollador. En el caso típico, las implementaciones de leen los datos de la cookie de la <see cref="P:System.Web.HttpRequest.Cookies" /> colección, sin embargo, esto no es un requisito.</para></block>
      </Docs>
    </Member>
    <Member MemberName="RequireSsl">
      <MemberSignature Language="C#" Value="public virtual bool RequireSsl { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool RequireSsl" />
      <MemberSignature Language="DocId" Value="P:System.IdentityModel.Services.CookieHandler.RequireSsl" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property RequireSsl As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool RequireSsl { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.RequireSsl : bool with get, set" Usage="System.IdentityModel.Services.CookieHandler.RequireSsl" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel.Services</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece un valor que especifica si la cookie se debe usar solo con SSL.</summary>
        <value>Es <see langword="true" /> si la cookie solo se debe usar en una conexión SSL; de lo contrario, es <see langword="false" />. El valor predeterminado es <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Controla si el marcador "Secure" en el encabezado Set-Cookie se genera para las cookies escritas. Si este valor es `true`, la sesión de las cookies solo estará disponibles a través de HTTPS.  
  
 Esta propiedad se corresponde con el <xref:System.Web.HttpCookie.Secure%2A?displayProperty=nameWithType> propiedad.  
  
 Se puede inicializar la propiedad especificando el `requireSSL` atributo el [ &lt;cookieHandler&gt; ](~/docs/framework/configure-apps/file-schema/windows-identity-foundation/cookiehandler.md) elemento de configuración.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Write">
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel.Services</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Escribe una cookie.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public void Write (byte[] value, bool isPersistent, DateTime tokenExpirationTime);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Write(unsigned int8[] value, bool isPersistent, valuetype System.DateTime tokenExpirationTime) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Services.CookieHandler.Write(System.Byte[],System.Boolean,System.DateTime)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Write (value As Byte(), isPersistent As Boolean, tokenExpirationTime As DateTime)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Write(cli::array &lt;System::Byte&gt; ^ value, bool isPersistent, DateTime tokenExpirationTime);" />
      <MemberSignature Language="F#" Value="member this.Write : byte[] * bool * DateTime -&gt; unit" Usage="cookieHandler.Write (value, isPersistent, tokenExpirationTime)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel.Services</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Byte[]" />
        <Parameter Name="isPersistent" Type="System.Boolean" />
        <Parameter Name="tokenExpirationTime" Type="System.DateTime" />
      </Parameters>
      <Docs>
        <param name="value">Valor de la cookie.</param>
        <param name="isPersistent"><see langword="true" /> si la cookie es persistente; <see langword="false" /> si la cookie es solo de sesión, es decir, solamente es válida hasta que se cierre el explorador del cliente.</param>
        <param name="tokenExpirationTime">Fecha de expiración para el token subyacente.</param>
        <summary>Escribe una cookie asociada a la solicitud actual que tiene el valor, la persistencia y la fecha de expiración especificados.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si el `isPersistent` parámetro es `false`, la hora de expiración de cookie se establece en <xref:System.DateTime.MinValue?displayProperty=nameWithType>. Si el `isPersistent` parámetro es `true`, la hora de expiración de cookie se establece en el valor de la <xref:System.IdentityModel.Services.CookieHandler.PersistentSessionLifetime%2A> propiedad si no es `null` o, si la <xref:System.IdentityModel.Services.CookieHandler.PersistentSessionLifetime%2A> propiedad es `null`, la hora de expiración se establece en el valor de la `tokenExpirationTime` parámetro.  
  
 El nombre de la cookie, el dominio y la ruta de acceso se especifican mediante el <xref:System.IdentityModel.Services.CookieHandler.Name%2A>, <xref:System.IdentityModel.Services.CookieHandler.Domain%2A>, y <xref:System.IdentityModel.Services.CookieHandler.Path%2A> propiedades. La solicitud se especifica por <xref:System.Web.HttpContext.Current%2A>. Si debe enviarse la cookie solo a través de SSL especificado por el <xref:System.IdentityModel.Services.CookieHandler.RequireSsl%2A> propiedad y si debe ocultarse la cookie de scripts de cliente especificado por el <xref:System.IdentityModel.Services.CookieHandler.HideFromClientScript%2A> propiedad.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El valor de <paramref name="value" /> es <see langword="null" /> o está vacío.</exception>
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public void Write (byte[] value, string name, DateTime expirationTime);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Write(unsigned int8[] value, string name, valuetype System.DateTime expirationTime) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Services.CookieHandler.Write(System.Byte[],System.String,System.DateTime)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Write (value As Byte(), name As String, expirationTime As DateTime)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Write(cli::array &lt;System::Byte&gt; ^ value, System::String ^ name, DateTime expirationTime);" />
      <MemberSignature Language="F#" Value="member this.Write : byte[] * string * DateTime -&gt; unit" Usage="cookieHandler.Write (value, name, expirationTime)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel.Services</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Byte[]" />
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="expirationTime" Type="System.DateTime" />
      </Parameters>
      <Docs>
        <param name="value">Valor de la cookie.</param>
        <param name="name">El nombre de la cookie.</param>
        <param name="expirationTime">La fecha de expiración de la cookie, o <see cref="F:System.DateTime.MinValue" /> para una cookie de sesión (de una sesión únicamente).</param>
        <summary>Escribe una cookie asociada a la solicitud actual que tiene el nombre, el valor y la fecha de expiración especificados.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El dominio de cookies y la ruta de acceso especificadas por el <xref:System.IdentityModel.Services.CookieHandler.Domain%2A> y <xref:System.IdentityModel.Services.CookieHandler.Path%2A> propiedades. La solicitud se especifica por <xref:System.Web.HttpContext.Current%2A?displayProperty=nameWithType>.  La solicitud se especifica por <xref:System.Web.HttpContext.Current%2A>. Si debe enviarse la cookie solo a través de SSL especificado por el <xref:System.IdentityModel.Services.CookieHandler.RequireSsl%2A> propiedad y si debe ocultarse la cookie de scripts de cliente especificado por el <xref:System.IdentityModel.Services.CookieHandler.HideFromClientScript%2A> propiedad.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El valor de <paramref name="value" /> es <see langword="null" /> o está vacío.</exception>
        <exception cref="T:System.ArgumentException">El valor de <paramref name="name" /> es <see langword="null" /> o está vacío.</exception>
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public void Write (byte[] value, string name, DateTime expirationTime, System.Web.HttpContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Write(unsigned int8[] value, string name, valuetype System.DateTime expirationTime, class System.Web.HttpContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Services.CookieHandler.Write(System.Byte[],System.String,System.DateTime,System.Web.HttpContext)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Write (value As Byte(), name As String, expirationTime As DateTime, context As HttpContext)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Write(cli::array &lt;System::Byte&gt; ^ value, System::String ^ name, DateTime expirationTime, System::Web::HttpContext ^ context);" />
      <MemberSignature Language="F#" Value="member this.Write : byte[] * string * DateTime * System.Web.HttpContext -&gt; unit" Usage="cookieHandler.Write (value, name, expirationTime, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel.Services</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Byte[]" />
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="expirationTime" Type="System.DateTime" />
        <Parameter Name="context" Type="System.Web.HttpContext" />
      </Parameters>
      <Docs>
        <param name="value">Valor de la cookie.</param>
        <param name="name">El nombre de la cookie.</param>
        <param name="expirationTime">La fecha de expiración de la cookie, o <see cref="F:System.DateTime.MinValue" /> para una cookie de sesión (de una sesión únicamente).</param>
        <param name="context"><see cref="T:System.Web.HttpContext" /> de la solicitud.</param>
        <summary>Escribe una cookie asociada a la solicitud especificada que tiene el nombre, el valor y la fecha de expiración especificados.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El dominio de cookies y la ruta de acceso especificadas por el <xref:System.IdentityModel.Services.CookieHandler.Domain%2A> y <xref:System.IdentityModel.Services.CookieHandler.Path%2A> propiedades. La solicitud se especifica por <xref:System.Web.HttpContext.Current%2A>. Si debe enviarse la cookie solo a través de SSL especificado por el <xref:System.IdentityModel.Services.CookieHandler.RequireSsl%2A> propiedad y si debe ocultarse la cookie de scripts de cliente especificado por el <xref:System.IdentityModel.Services.CookieHandler.HideFromClientScript%2A> propiedad.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El valor de <paramref name="value" /> es <see langword="null" /> o está vacío.</exception>
        <exception cref="T:System.ArgumentException">El valor de <paramref name="name" /> es <see langword="null" /> o está vacío.</exception>
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public void Write (byte[] value, string name, string path, string domain, DateTime expirationTime, bool requiresSsl, bool hideFromClientScript, System.Web.HttpContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Write(unsigned int8[] value, string name, string path, string domain, valuetype System.DateTime expirationTime, bool requiresSsl, bool hideFromClientScript, class System.Web.HttpContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Services.CookieHandler.Write(System.Byte[],System.String,System.String,System.String,System.DateTime,System.Boolean,System.Boolean,System.Web.HttpContext)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Write (value As Byte(), name As String, path As String, domain As String, expirationTime As DateTime, requiresSsl As Boolean, hideFromClientScript As Boolean, context As HttpContext)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Write(cli::array &lt;System::Byte&gt; ^ value, System::String ^ name, System::String ^ path, System::String ^ domain, DateTime expirationTime, bool requiresSsl, bool hideFromClientScript, System::Web::HttpContext ^ context);" />
      <MemberSignature Language="F#" Value="member this.Write : byte[] * string * string * string * DateTime * bool * bool * System.Web.HttpContext -&gt; unit" Usage="cookieHandler.Write (value, name, path, domain, expirationTime, requiresSsl, hideFromClientScript, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel.Services</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Byte[]" />
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="domain" Type="System.String" />
        <Parameter Name="expirationTime" Type="System.DateTime" />
        <Parameter Name="requiresSsl" Type="System.Boolean" />
        <Parameter Name="hideFromClientScript" Type="System.Boolean" />
        <Parameter Name="context" Type="System.Web.HttpContext" />
      </Parameters>
      <Docs>
        <param name="value">Valor de la cookie.</param>
        <param name="name">El nombre de la cookie.</param>
        <param name="path">La ruta de acceso de la cookie.</param>
        <param name="domain">Dominio de la cookie.</param>
        <param name="expirationTime">La fecha de expiración de la cookie, o <see cref="F:System.DateTime.MinValue" /> para una cookie de sesión (de una sesión únicamente).</param>
        <param name="requiresSsl">Es <see langword="true" /> si la cookie solo se debe usar en una conexión SSL; de lo contrario, es <see langword="false" />.</param>
        <param name="hideFromClientScript"><see langword="true" /> si la cookie debe estar oculta del script de cliente; si no, <see langword="false" />.</param>
        <param name="context"><see cref="T:System.Web.HttpContext" /> de la solicitud.</param>
        <summary>Escribe una cookie asociada a la solicitud especificada que tiene el nombre, el valor, el dominio, la ruta de acceso, la fecha de expiración y la visibilidad especificados.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">El valor de <paramref name="value" /> es <see langword="null" /> o está vacío.</exception>
        <exception cref="T:System.ArgumentException">El valor de <paramref name="name" /> es <see langword="null" /> o está vacío.</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteCore">
      <MemberSignature Language="C#" Value="protected abstract void WriteCore (byte[] value, string name, string path, string domain, DateTime expirationTime, bool secure, bool httpOnly, System.Web.HttpContext context);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void WriteCore(unsigned int8[] value, string name, string path, string domain, valuetype System.DateTime expirationTime, bool secure, bool httpOnly, class System.Web.HttpContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Services.CookieHandler.WriteCore(System.Byte[],System.String,System.String,System.String,System.DateTime,System.Boolean,System.Boolean,System.Web.HttpContext)" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Sub WriteCore (value As Byte(), name As String, path As String, domain As String, expirationTime As DateTime, secure As Boolean, httpOnly As Boolean, context As HttpContext)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract void WriteCore(cli::array &lt;System::Byte&gt; ^ value, System::String ^ name, System::String ^ path, System::String ^ domain, DateTime expirationTime, bool secure, bool httpOnly, System::Web::HttpContext ^ context);" />
      <MemberSignature Language="F#" Value="abstract member WriteCore : byte[] * string * string * string * DateTime * bool * bool * System.Web.HttpContext -&gt; unit" Usage="cookieHandler.WriteCore (value, name, path, domain, expirationTime, secure, httpOnly, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel.Services</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Byte[]" />
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="domain" Type="System.String" />
        <Parameter Name="expirationTime" Type="System.DateTime" />
        <Parameter Name="secure" Type="System.Boolean" />
        <Parameter Name="httpOnly" Type="System.Boolean" />
        <Parameter Name="context" Type="System.Web.HttpContext" />
      </Parameters>
      <Docs>
        <param name="value">Valor de la cookie.</param>
        <param name="name">El nombre de la cookie.</param>
        <param name="path">La ruta de acceso de la cookie.</param>
        <param name="domain">Dominio de la cookie.</param>
        <param name="expirationTime">La fecha de expiración de la cookie, o <see cref="F:System.DateTime.MinValue" /> para una cookie de sesión (de una sesión únicamente).</param>
        <param name="secure">Es <see langword="true" /> si la cookie solo se debe usar en una conexión SSL; de lo contrario, es <see langword="false" />.</param>
        <param name="httpOnly"><see langword="true" /> si la cookie debe estar oculta del script de cliente; si no, <see langword="false" />.</param>
        <param name="context"><see cref="T:System.Web.HttpContext" /> de la solicitud.</param>
        <summary>Cuando se reemplaza en una clase derivada, escribe una cookie asociada a la solicitud especificada que tiene el nombre, el valor, el dominio, la ruta de acceso, la fecha de expiración, la persistencia y la visibilidad especificados.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se llama desde sobrecargado <xref:System.IdentityModel.Services.CookieHandler.Write%2A> métodos para hacer el trabajo real de la escritura de la cookie. El <xref:System.IdentityModel.Services.CookieHandler.Write%2A> métodos garantizará que `value` es una matriz de bytes no vacía y que `name` y `path` son cadenas de valores no vacíos.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Debe invalidar este método. La implementación es depende totalmente del desarrollador. En el caso típico, las implementaciones de escribirán los datos de la cookie a la <see cref="P:System.Web.HttpResponse.Cookies" /> colección, sin embargo, esto no es un requisito. La mayoría de los parámetros del método se utilizan normalmente para establecer propiedades equivalentes en uno o varios <see cref="T:System.Web.HttpCookie" /> objetos.</para></block>
      </Docs>
    </Member>
  </Members>
</Type>