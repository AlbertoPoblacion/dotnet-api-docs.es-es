<Type Name="SessionAuthenticationModule" FullName="System.IdentityModel.Services.SessionAuthenticationModule">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="1289b28bb0b4bf053a1698a1a9adae95172abf08" />
    <Meta Name="ms.sourcegitcommit" Value="434f60616a9793fa8436744549fc856e94f7a648" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="es-ES" />
    <Meta Name="ms.lasthandoff" Value="08/25/2018" />
    <Meta Name="ms.locfileid" Value="39753180" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class SessionAuthenticationModule : System.IdentityModel.Services.HttpModuleBase" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit SessionAuthenticationModule extends System.IdentityModel.Services.HttpModuleBase" />
  <TypeSignature Language="DocId" Value="T:System.IdentityModel.Services.SessionAuthenticationModule" />
  <TypeSignature Language="VB.NET" Value="Public Class SessionAuthenticationModule&#xA;Inherits HttpModuleBase" />
  <TypeSignature Language="C++ CLI" Value="public ref class SessionAuthenticationModule : System::IdentityModel::Services::HttpModuleBase" />
  <TypeSignature Language="F#" Value="type SessionAuthenticationModule = class&#xA;    inherit HttpModuleBase" />
  <AssemblyInfo>
    <AssemblyName>System.IdentityModel.Services</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.IdentityModel.Services.HttpModuleBase</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Implementa un módulo de ASP.NET que procesa las cookies de sesión en escenarios de WS-Federation.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cuando está presente en la canalización ASP.NET, el <xref:System.IdentityModel.Services.SessionAuthenticationModule> (SAM) procesa las cookies de sesión en escenarios de WS-Federation. Usa el controlador de cookies especificado por el <xref:System.IdentityModel.Services.SessionAuthenticationModule.CookieHandler%2A> propiedad para leer la cookie de sesión sin procesar la solicitud HTTP y escribirlo en la respuesta HTTP. Usa el <xref:System.IdentityModel.Tokens.SessionSecurityTokenHandler> que está configurado para que una aplicación deserializar la cookie de sesión sin procesar en <xref:System.IdentityModel.Tokens.SessionSecurityToken> objetos. El token de seguridad de la sesión contiene las notificaciones (<xref:System.Security.Claims.Claim>) y principal (<xref:System.Security.Claims.ClaimsPrincipal>) asociado con la entidad para el que se sirve la solicitud.  
  
 El SAM agrega su <xref:System.IdentityModel.Services.SessionAuthenticationModule.OnAuthenticateRequest%2A> controlador de eventos para el <xref:System.Web.HttpApplication.AuthenticateRequest?displayProperty=nameWithType> eventos en la canalización de ASP.NET. Este controlador intercepta las solicitudes de inicio de sesión y, si hay una cookie de sesión, lo deserializa en un token de sesión y establece el <xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=nameWithType> y <xref:System.Web.HttpContext.User%2A?displayProperty=nameWithType> las propiedades de la entidad de seguridad de las notificaciones contenidas en el token de sesión. Invoca, algunos de los otros métodos expuestos por el SAM durante este proceso.  
  
 El <xref:System.IdentityModel.Services.SessionAuthenticationModule.SignOut%2A> método se puede invocar para cerrar la sesión del usuario de una sesión (por ejemplo, en un archivo de código subyacente SignOut.aspx.cs).  
  
 El SAM expone varios eventos que proporcionan acceso a su canalización de procesamiento. El <xref:System.IdentityModel.Services.SessionAuthenticationModule.SessionSecurityTokenReceived> y <xref:System.IdentityModel.Services.SessionAuthenticationModule.SessionSecurityTokenCreated> eventos le permiten modificar los tokens de sesión que se leen las cookies o se crean durante el procesamiento. Normalmente, esto se hace para agregar, quitar o transformar las notificaciones del token o para ajustar la hora de expiración. El <xref:System.IdentityModel.Services.SessionAuthenticationModule.SigningOut>, <xref:System.IdentityModel.Services.SessionAuthenticationModule.SignedOut>, y <xref:System.IdentityModel.Services.SessionAuthenticationModule.SignOutError> eventos proporcionan enlaces en el procesamiento de solicitudes de cierre de sesión. Para muchos escenarios, basta con agregar controladores para estos eventos, a menudo al archivo global.asax.cs, será suficiente.  
  
 Para escenarios más complicados, puede derivar de <xref:System.IdentityModel.Services.SessionAuthenticationModule> para implementar un SAM personalizado. Con este fin, muchos de los métodos que se invocan durante <xref:System.IdentityModel.Services.SessionAuthenticationModule.OnAuthenticateRequest%2A> y <xref:System.IdentityModel.Services.SessionAuthenticationModule.SignOut%2A> se exponen para que pueda proporcionar un comportamiento personalizado en las diferentes fases del ciclo de vida de procesamiento de la sesión.  
  
 Puede agregar el SAM en la canalización ASP.NET en un archivo de configuración agregándolo a los módulos HTTP bajo el `<system.webServer>` elemento para IIS 7 y versiones posteriores, o en el `<system.web>` (elemento) para las versiones anteriores a IIS 7. El controlador de cookies que usa SAM se puede configurar con el [ &lt;cookieHandler&gt; ](~/docs/framework/configure-apps/file-schema/windows-identity-foundation/cookiehandler.md) elemento.  
  
   
  
## Examples  
 [!code-csharp[WifSAM#1](~/samples/snippets/csharp/VS_Snippets_Misc/wifsam/cs/webapplication1/global.asax.cs#1)]  
  
 El siguiente XML muestra cómo configurar el SAM en la canalización de ASP.NET. Muchos otros elementos que se encuentran en una configuración típica se omiten aquí por razones de brevedad.  
  
```xml  
<configuration>  
  <system.webServer>  
    <modules>  
      <!--WIF 4.5 modules -->  
      <add name="SessionAuthenticationModule" type="System.IdentityModel.Services.SessionAuthenticationModule, System.IdentityModel.Services, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"/>  
      <add name="WsFederationAuthenticationModule" type="System.IdentityModel.Services.WSFederationAuthenticationModule, System.IdentityModel.Services, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"/>  
    </modules>  
  </system.webServer>  
</configuration>  
```  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public SessionAuthenticationModule ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Services.SessionAuthenticationModule.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; SessionAuthenticationModule();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel.Services</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.IdentityModel.Services.SessionAuthenticationModule" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.IdentityModel.Services.SessionAuthenticationModule.IsReferenceMode%2A> propiedad está establecida en `false` y <xref:System.IdentityModel.Services.SessionAuthenticationModule.CookieHandler%2A> propiedad se inicializa en una instancia predeterminada de la <xref:System.IdentityModel.Services.CookieHandlerElement.ChunkedCookieHandler%2A> clase.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AuthenticateSessionSecurityToken">
      <MemberSignature Language="C#" Value="public virtual void AuthenticateSessionSecurityToken (System.IdentityModel.Tokens.SessionSecurityToken sessionToken, bool writeCookie);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void AuthenticateSessionSecurityToken(class System.IdentityModel.Tokens.SessionSecurityToken sessionToken, bool writeCookie) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Services.SessionAuthenticationModule.AuthenticateSessionSecurityToken(System.IdentityModel.Tokens.SessionSecurityToken,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub AuthenticateSessionSecurityToken (sessionToken As SessionSecurityToken, writeCookie As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void AuthenticateSessionSecurityToken(System::IdentityModel::Tokens::SessionSecurityToken ^ sessionToken, bool writeCookie);" />
      <MemberSignature Language="F#" Value="abstract member AuthenticateSessionSecurityToken : System.IdentityModel.Tokens.SessionSecurityToken * bool -&gt; unit&#xA;override this.AuthenticateSessionSecurityToken : System.IdentityModel.Tokens.SessionSecurityToken * bool -&gt; unit" Usage="sessionAuthenticationModule.AuthenticateSessionSecurityToken (sessionToken, writeCookie)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel.Services</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sessionToken" Type="System.IdentityModel.Tokens.SessionSecurityToken" />
        <Parameter Name="writeCookie" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="sessionToken">El token de seguridad de sesión que se usará para autenticar la solicitud HTTP de entrada.</param>
        <param name="writeCookie">
          <see langword="true" /> para escribir la cookie de sesión; si no <see langword="false" />.</param>
        <summary>Autentica la solicitud entrante validando el token de entrada de la sesión. Cuando la validación se realiza correctamente, actualiza la entidad de seguridad de contexto y subproceso HTTP actual con el <see cref="T:System.IdentityModel.Tokens.SessionSecurityToken" /> especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.IdentityModel.Services.SessionAuthenticationModule.AuthenticateSessionSecurityToken%2A> se llama al método desde el <xref:System.IdentityModel.Services.SessionAuthenticationModule.OnAuthenticateRequest%2A> método. Llama a la <xref:System.IdentityModel.Services.SessionAuthenticationModule.SetPrincipalFromSessionToken%2A> método para validar el token entrante y actualice el <xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=nameWithType> y el <xref:System.Web.HttpContext.User%2A?displayProperty=nameWithType> propiedades. Si el `writeCookie` parámetro es `true`, el <xref:System.IdentityModel.Services.SessionAuthenticationModule.WriteSessionTokenToCookie%2A> se invoca el método para escribir el token de sesión en una cookie.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ContainsSessionTokenCookie">
      <MemberSignature Language="C#" Value="public bool ContainsSessionTokenCookie (System.Web.HttpCookieCollection httpCookieCollection);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ContainsSessionTokenCookie(class System.Web.HttpCookieCollection httpCookieCollection) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Services.SessionAuthenticationModule.ContainsSessionTokenCookie(System.Web.HttpCookieCollection)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ContainsSessionTokenCookie(System::Web::HttpCookieCollection ^ httpCookieCollection);" />
      <MemberSignature Language="F#" Value="member this.ContainsSessionTokenCookie : System.Web.HttpCookieCollection -&gt; bool" Usage="sessionAuthenticationModule.ContainsSessionTokenCookie httpCookieCollection" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel.Services</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="httpCookieCollection" Type="System.Web.HttpCookieCollection" />
      </Parameters>
      <Docs>
        <param name="httpCookieCollection">Colección de cookies donde se va a buscar.</param>
        <summary>Determina si una cookie de sesión está en la colección de cookies especificada.</summary>
        <returns>
          <see langword="true" /> si se encuentra una cookie de sesión; si no, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="httpCookieCollection" /> es null.</exception>
      </Docs>
    </Member>
    <Member MemberName="ContextSessionSecurityToken">
      <MemberSignature Language="C#" Value="public virtual System.IdentityModel.Tokens.SessionSecurityToken ContextSessionSecurityToken { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.IdentityModel.Tokens.SessionSecurityToken ContextSessionSecurityToken" />
      <MemberSignature Language="DocId" Value="P:System.IdentityModel.Services.SessionAuthenticationModule.ContextSessionSecurityToken" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property ContextSessionSecurityToken As SessionSecurityToken" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::IdentityModel::Tokens::SessionSecurityToken ^ ContextSessionSecurityToken { System::IdentityModel::Tokens::SessionSecurityToken ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ContextSessionSecurityToken : System.IdentityModel.Tokens.SessionSecurityToken" Usage="System.IdentityModel.Services.SessionAuthenticationModule.ContextSessionSecurityToken" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel.Services</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IdentityModel.Tokens.SessionSecurityToken</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene el <see cref="T:System.IdentityModel.Tokens.SessionSecurityToken" /> activo para el <see cref="T:System.Web.HttpContext" /> actual.</summary>
        <value>El token de seguridad de la sesión activa.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CookieHandler">
      <MemberSignature Language="C#" Value="public System.IdentityModel.Services.CookieHandler CookieHandler { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.IdentityModel.Services.CookieHandler CookieHandler" />
      <MemberSignature Language="DocId" Value="P:System.IdentityModel.Services.SessionAuthenticationModule.CookieHandler" />
      <MemberSignature Language="VB.NET" Value="Public Property CookieHandler As CookieHandler" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IdentityModel::Services::CookieHandler ^ CookieHandler { System::IdentityModel::Services::CookieHandler ^ get(); void set(System::IdentityModel::Services::CookieHandler ^ value); };" />
      <MemberSignature Language="F#" Value="member this.CookieHandler : System.IdentityModel.Services.CookieHandler with get, set" Usage="System.IdentityModel.Services.SessionAuthenticationModule.CookieHandler" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel.Services</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IdentityModel.Services.CookieHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene el controlador de cookies que se usa para leer, escribir y eliminar las cookies de sesión.</summary>
        <value>Controlador de cookies.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.IdentityModel.Services.SessionAuthenticationModule.CookieHandler%2A> se puede inicializar la propiedad por la <xref:System.IdentityModel.Services.SessionAuthenticationModule.InitializePropertiesFromConfiguration%2A> método. Este método inicializa la propiedad basándose en el controlador de cookies especificado en el <xref:System.IdentityModel.Services.Configuration.FederationConfiguration> objeto que se establece en el <xref:System.IdentityModel.Services.FederatedAuthentication.FederationConfiguration%2A?displayProperty=nameWithType> propiedad. Puede establecer el controlador de cookies en un archivo de configuración a través de la [ &lt;cookieHandler&gt; ](~/docs/framework/configure-apps/file-schema/windows-identity-foundation/cookiehandler.md) elemento.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.IdentityModel.Services.SessionAuthenticationModule.DeleteSessionTokenCookie" />
        <altmember cref="M:System.IdentityModel.Services.SessionAuthenticationModule.TryReadSessionTokenFromCookie(System.IdentityModel.Tokens.SessionSecurityToken@)" />
        <altmember cref="M:System.IdentityModel.Services.SessionAuthenticationModule.WriteSessionTokenToCookie(System.IdentityModel.Tokens.SessionSecurityToken)" />
      </Docs>
    </Member>
    <Member MemberName="CreateSessionSecurityToken">
      <MemberSignature Language="C#" Value="public System.IdentityModel.Tokens.SessionSecurityToken CreateSessionSecurityToken (System.Security.Claims.ClaimsPrincipal principal, string context, DateTime validFrom, DateTime validTo, bool isPersistent);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IdentityModel.Tokens.SessionSecurityToken CreateSessionSecurityToken(class System.Security.Claims.ClaimsPrincipal principal, string context, valuetype System.DateTime validFrom, valuetype System.DateTime validTo, bool isPersistent) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Services.SessionAuthenticationModule.CreateSessionSecurityToken(System.Security.Claims.ClaimsPrincipal,System.String,System.DateTime,System.DateTime,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateSessionSecurityToken (principal As ClaimsPrincipal, context As String, validFrom As DateTime, validTo As DateTime, isPersistent As Boolean) As SessionSecurityToken" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IdentityModel::Tokens::SessionSecurityToken ^ CreateSessionSecurityToken(System::Security::Claims::ClaimsPrincipal ^ principal, System::String ^ context, DateTime validFrom, DateTime validTo, bool isPersistent);" />
      <MemberSignature Language="F#" Value="member this.CreateSessionSecurityToken : System.Security.Claims.ClaimsPrincipal * string * DateTime * DateTime * bool -&gt; System.IdentityModel.Tokens.SessionSecurityToken" Usage="sessionAuthenticationModule.CreateSessionSecurityToken (principal, context, validFrom, validTo, isPersistent)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel.Services</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IdentityModel.Tokens.SessionSecurityToken</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="principal" Type="System.Security.Claims.ClaimsPrincipal" />
        <Parameter Name="context" Type="System.String" />
        <Parameter Name="validFrom" Type="System.DateTime" />
        <Parameter Name="validTo" Type="System.DateTime" />
        <Parameter Name="isPersistent" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="principal">La entidad de seguridad que se capturará en el token.</param>
        <param name="context">Una cadena de contexto definida por la aplicación.</param>
        <param name="validFrom">Primer instante en el que este token es válido.</param>
        <param name="validTo">Último instante en el que este token es válido.</param>
        <param name="isPersistent">
          <see langword="true" /> si el agente de usuario debe conservar el valor; si no, <see langword="false" />.</param>
        <summary>Crea un objeto <see cref="T:System.IdentityModel.Tokens.SessionSecurityToken" /> a partir de los parámetros especificados mediante el controlador de tokens de sesión configurado.</summary>
        <returns>El token de sesión.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException">No hay configurado ningún controlador de token de sesión válido. (No hay ningún <see cref="T:System.IdentityModel.Tokens.SessionSecurityTokenHandler" /> configurado en la propiedad <see cref="P:System.IdentityModel.Configuration.IdentityConfiguration.SecurityTokenHandlers" />.)</exception>
      </Docs>
    </Member>
    <Member MemberName="DeleteSessionTokenCookie">
      <MemberSignature Language="C#" Value="public void DeleteSessionTokenCookie ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DeleteSessionTokenCookie() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Services.SessionAuthenticationModule.DeleteSessionTokenCookie" />
      <MemberSignature Language="VB.NET" Value="Public Sub DeleteSessionTokenCookie ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DeleteSessionTokenCookie();" />
      <MemberSignature Language="F#" Value="member this.DeleteSessionTokenCookie : unit -&gt; unit" Usage="sessionAuthenticationModule.DeleteSessionTokenCookie " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel.Services</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Elimina la cookie de sesión y la quita de la memoria caché.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Elimina la cookie de sesión mediante el controlador de cookies especificado por el <xref:System.IdentityModel.Services.SessionAuthenticationModule.CookieHandler%2A> propiedad. Este método se llama durante el cierre de sesión mediante el <xref:System.IdentityModel.Services.SessionAuthenticationModule.SignOut%2A> método.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="InitializeModule">
      <MemberSignature Language="C#" Value="protected override void InitializeModule (System.Web.HttpApplication context);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void InitializeModule(class System.Web.HttpApplication context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Services.SessionAuthenticationModule.InitializeModule(System.Web.HttpApplication)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub InitializeModule (context As HttpApplication)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void InitializeModule(System::Web::HttpApplication ^ context);" />
      <MemberSignature Language="F#" Value="override this.InitializeModule : System.Web.HttpApplication -&gt; unit" Usage="sessionAuthenticationModule.InitializeModule context" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel.Services</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="context" Type="System.Web.HttpApplication" />
      </Parameters>
      <Docs>
        <param name="context">Objeto de aplicación HTTP que contiene este módulo.</param>
        <summary>Inicializa el módulo y se prepara para controlar eventos de su objeto de aplicación de [!INCLUDE[vstecasp](~/includes/vstecasp-md.md)] del módulo.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Agrega el <xref:System.IdentityModel.Services.SessionAuthenticationModule.OnAuthenticateRequest%2A> y <xref:System.IdentityModel.Services.SessionAuthenticationModule.OnPostAuthenticateRequest%2A> controladores a la <xref:System.Web.HttpApplication.AuthenticateRequest?displayProperty=nameWithType> y <xref:System.Web.HttpApplication.PostAuthenticateRequest?displayProperty=nameWithType> eventos del objeto de aplicación especificado por el `context` parámetro.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="InitializePropertiesFromConfiguration">
      <MemberSignature Language="C#" Value="protected override void InitializePropertiesFromConfiguration ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void InitializePropertiesFromConfiguration() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Services.SessionAuthenticationModule.InitializePropertiesFromConfiguration" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub InitializePropertiesFromConfiguration ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void InitializePropertiesFromConfiguration();" />
      <MemberSignature Language="F#" Value="override this.InitializePropertiesFromConfiguration : unit -&gt; unit" Usage="sessionAuthenticationModule.InitializePropertiesFromConfiguration " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel.Services</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Inicializa las propiedades del módulo basadas en definiciones en el archivo de configuración.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Inicializa el <xref:System.IdentityModel.Services.SessionAuthenticationModule.CookieHandler%2A> propiedad desde el controlador especificado en la configuración mediante el <xref:System.IdentityModel.Services.Configuration.FederationConfiguration?displayProperty=nameWithType> objeto que se establece en el <xref:System.IdentityModel.Services.FederatedAuthentication.FederationConfiguration%2A?displayProperty=nameWithType> propiedad. Puede especificar el controlador de cookies en un archivo de configuración a través de la [ &lt;cookieHandler&gt; ](~/docs/framework/configure-apps/file-schema/windows-identity-foundation/cookiehandler.md) elemento.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsReferenceMode">
      <MemberSignature Language="C#" Value="public bool IsReferenceMode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsReferenceMode" />
      <MemberSignature Language="DocId" Value="P:System.IdentityModel.Services.SessionAuthenticationModule.IsReferenceMode" />
      <MemberSignature Language="VB.NET" Value="Public Property IsReferenceMode As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsReferenceMode { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.IsReferenceMode : bool with get, set" Usage="System.IdentityModel.Services.SessionAuthenticationModule.IsReferenceMode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel.Services</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece un valor que especifica si la información de sesión (valores de notificación, etc.) debe almacenarse en la cookie de sesión o si el contenido de sesión debe almacenarse en el servidor, mediante la cookie para almacenar solo una referencia.</summary>
        <value>
          <see langword="true" /> si las cookies emitidas están en modo de referencia; si no, <see langword="false" />. El valor predeterminado es <see langword="false" />, que especifica que las cookies emitidas no están en modo de referencia.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 En el modo de referencia, el <xref:System.IdentityModel.Tokens.SessionSecurityToken> se almacenan en una caché del lado servidor (un objeto que se deriva de <xref:System.IdentityModel.Tokens.SessionSecurityTokenCache>). La cookie emitida solo contiene un identificador de contexto que se usa para recuperar el token de la memoria caché.  
  
> [!IMPORTANT]
>  Para que funcione en modo de referencia, Microsoft recomienda proporcionar un controlador para el <xref:System.IdentityModel.Services.WSFederationAuthenticationModule.SessionSecurityTokenCreated?displayProperty=nameWithType> eventos en el archivo global.asax.cs y la configuración de la <xref:System.IdentityModel.Tokens.SessionSecurityToken.IsReferenceMode%2A?displayProperty=nameWithType> propiedad en el token se pasa en el <xref:System.IdentityModel.Services.SessionSecurityTokenCreatedEventArgs.SessionToken%2A?displayProperty=nameWithType> propiedad. Así se asegurará de que el token de sesión funciona en modo de referencia para cada solicitud y mero establecimiento la <xref:System.IdentityModel.Services.SessionAuthenticationModule.IsReferenceMode%2A?displayProperty=nameWithType> propiedad en el módulo de autenticación de la sesión.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnAuthenticateRequest">
      <MemberSignature Language="C#" Value="protected virtual void OnAuthenticateRequest (object sender, EventArgs eventArgs);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnAuthenticateRequest(object sender, class System.EventArgs eventArgs) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Services.SessionAuthenticationModule.OnAuthenticateRequest(System.Object,System.EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnAuthenticateRequest(System::Object ^ sender, EventArgs ^ eventArgs);" />
      <MemberSignature Language="F#" Value="abstract member OnAuthenticateRequest : obj * EventArgs -&gt; unit&#xA;override this.OnAuthenticateRequest : obj * EventArgs -&gt; unit" Usage="sessionAuthenticationModule.OnAuthenticateRequest (sender, eventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel.Services</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sender" Type="System.Object" />
        <Parameter Name="eventArgs" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="sender">Origen del evento. Este debe ser un objeto <see cref="T:System.Web.HttpApplication" />.</param>
        <param name="eventArgs">Datos del evento.</param>
        <summary>Controla el evento <see cref="E:System.Web.HttpApplication.AuthenticateRequest" /> de canalización de [!INCLUDE[vstecasp](~/includes/vstecasp-md.md)] .</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método hace lo siguiente:  
  
1.  Invoca el <xref:System.IdentityModel.Services.SessionAuthenticationModule.TryReadSessionTokenFromCookie%2A> método para leer un <xref:System.IdentityModel.Tokens.SessionSecurityToken> de la cookie de sesión, si hay alguno.  
  
2.  Si una sesión de token de seguridad no se puede devolver (probablemente porque no se ha establecido una sesión), de lectura.  
  
3.  Invoca el <xref:System.IdentityModel.Services.SessionAuthenticationModule.OnSessionSecurityTokenReceived%2A> método para generar el <xref:System.IdentityModel.Services.SessionAuthenticationModule.SessionSecurityTokenReceived> eventos. Esto proporciona una oportunidad para el token que se leen de la cookie que se puede modificar o debe cancelarse la solicitud. El controlador también puede especificar que el token debe volver a enviarse, estableciendo el <xref:System.IdentityModel.Services.SessionSecurityTokenReceivedEventArgs.ReissueCookie%2A?displayProperty=nameWithType> propiedad.  
  
4.  Si el token es volver a emitirse, lo quita de la memoria caché e invoca el <xref:System.IdentityModel.Services.SessionAuthenticationModule.OnSessionSecurityTokenCreated%2A> método para generar el <xref:System.IdentityModel.Services.SessionAuthenticationModule.SessionSecurityTokenCreated> eventos. Esto proporciona la oportunidad para que el token que se va a volver a modificarse. También puede modificarse estableciendo el comportamiento vuelva a emitir el <xref:System.IdentityModel.Services.SessionSecurityTokenCreatedEventArgs.WriteSessionCookie%2A?displayProperty=nameWithType> propiedad en el controlador de eventos.  
  
5.  Invoca el <xref:System.IdentityModel.Services.SessionAuthenticationModule.AuthenticateSessionSecurityToken%2A> método para autenticar al usuario. Si es correcto, esto tiene el efecto de la configuración de la <xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=nameWithType> propiedad a la entidad que se encuentra en la <xref:System.IdentityModel.Tokens.SessionSecurityToken.ClaimsPrincipal%2A?displayProperty=nameWithType> propiedad del token entrante.  
  
6.  Si la sesión ha expirado, se invoca el <xref:System.IdentityModel.Services.SessionAuthenticationModule.SignOut%2A> método.  
  
 El <xref:System.IdentityModel.Services.SessionAuthenticationModule.OnAuthenticateRequest%2A> método se agrega a los controladores para la <xref:System.Web.HttpApplication.AuthenticateRequest?displayProperty=nameWithType> eventos en el <xref:System.IdentityModel.Services.SessionAuthenticationModule.InitializeModule%2A> método.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">No hay configurado ningún controlador de token de sesión válido. (No hay ningún <see cref="T:System.IdentityModel.Tokens.SessionSecurityTokenHandler" /> configurado en la propiedad <see cref="P:System.IdentityModel.Configuration.IdentityConfiguration.SecurityTokenHandlers" />.)</exception>
      </Docs>
    </Member>
    <Member MemberName="OnPostAuthenticateRequest">
      <MemberSignature Language="C#" Value="protected virtual void OnPostAuthenticateRequest (object sender, EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnPostAuthenticateRequest(object sender, class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Services.SessionAuthenticationModule.OnPostAuthenticateRequest(System.Object,System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnPostAuthenticateRequest (sender As Object, e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnPostAuthenticateRequest(System::Object ^ sender, EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnPostAuthenticateRequest : obj * EventArgs -&gt; unit&#xA;override this.OnPostAuthenticateRequest : obj * EventArgs -&gt; unit" Usage="sessionAuthenticationModule.OnPostAuthenticateRequest (sender, e)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel.Services</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sender" Type="System.Object" />
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="sender">Origen del evento. Este debe ser un objeto <see cref="T:System.Web.HttpApplication" />.</param>
        <param name="e">Datos del evento.</param>
        <summary>Controla el evento <see cref="E:System.Web.HttpApplication.PostAuthenticateRequest" /> de canalización de [!INCLUDE[vstecasp](~/includes/vstecasp-md.md)] .</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La implementación predeterminada está vacía.  
  
 El <xref:System.IdentityModel.Services.SessionAuthenticationModule.OnPostAuthenticateRequest%2A> controlador se agrega a los controladores para la <xref:System.Web.HttpApplication.PostAuthenticateRequest?displayProperty=nameWithType> eventos en el <xref:System.IdentityModel.Services.SessionAuthenticationModule.InitializeModule%2A> método.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnSessionSecurityTokenCreated">
      <MemberSignature Language="C#" Value="protected virtual void OnSessionSecurityTokenCreated (System.IdentityModel.Services.SessionSecurityTokenCreatedEventArgs args);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnSessionSecurityTokenCreated(class System.IdentityModel.Services.SessionSecurityTokenCreatedEventArgs args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Services.SessionAuthenticationModule.OnSessionSecurityTokenCreated(System.IdentityModel.Services.SessionSecurityTokenCreatedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnSessionSecurityTokenCreated (args As SessionSecurityTokenCreatedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnSessionSecurityTokenCreated(System::IdentityModel::Services::SessionSecurityTokenCreatedEventArgs ^ args);" />
      <MemberSignature Language="F#" Value="abstract member OnSessionSecurityTokenCreated : System.IdentityModel.Services.SessionSecurityTokenCreatedEventArgs -&gt; unit&#xA;override this.OnSessionSecurityTokenCreated : System.IdentityModel.Services.SessionSecurityTokenCreatedEventArgs -&gt; unit" Usage="sessionAuthenticationModule.OnSessionSecurityTokenCreated args" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel.Services</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="args" Type="System.IdentityModel.Services.SessionSecurityTokenCreatedEventArgs" />
      </Parameters>
      <Docs>
        <param name="args">Datos del evento.</param>
        <summary>Genera el evento <see cref="E:System.IdentityModel.Services.SessionAuthenticationModule.SessionSecurityTokenCreated" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se llama desde el <xref:System.IdentityModel.Services.SessionAuthenticationModule.OnAuthenticateRequest%2A> método.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnSessionSecurityTokenReceived">
      <MemberSignature Language="C#" Value="protected virtual void OnSessionSecurityTokenReceived (System.IdentityModel.Services.SessionSecurityTokenReceivedEventArgs args);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnSessionSecurityTokenReceived(class System.IdentityModel.Services.SessionSecurityTokenReceivedEventArgs args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Services.SessionAuthenticationModule.OnSessionSecurityTokenReceived(System.IdentityModel.Services.SessionSecurityTokenReceivedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnSessionSecurityTokenReceived (args As SessionSecurityTokenReceivedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnSessionSecurityTokenReceived(System::IdentityModel::Services::SessionSecurityTokenReceivedEventArgs ^ args);" />
      <MemberSignature Language="F#" Value="abstract member OnSessionSecurityTokenReceived : System.IdentityModel.Services.SessionSecurityTokenReceivedEventArgs -&gt; unit&#xA;override this.OnSessionSecurityTokenReceived : System.IdentityModel.Services.SessionSecurityTokenReceivedEventArgs -&gt; unit" Usage="sessionAuthenticationModule.OnSessionSecurityTokenReceived args" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel.Services</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="args" Type="System.IdentityModel.Services.SessionSecurityTokenReceivedEventArgs" />
      </Parameters>
      <Docs>
        <param name="args">Datos del evento.</param>
        <summary>Genera el evento <see cref="E:System.IdentityModel.Services.SessionAuthenticationModule.SessionSecurityTokenReceived" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se llama desde el <xref:System.IdentityModel.Services.SessionAuthenticationModule.OnAuthenticateRequest%2A> método.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnSignedOut">
      <MemberSignature Language="C#" Value="protected virtual void OnSignedOut (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnSignedOut(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Services.SessionAuthenticationModule.OnSignedOut(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnSignedOut (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnSignedOut(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnSignedOut : EventArgs -&gt; unit&#xA;override this.OnSignedOut : EventArgs -&gt; unit" Usage="sessionAuthenticationModule.OnSignedOut e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel.Services</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Datos del evento.</param>
        <summary>Genera el evento <see cref="E:System.IdentityModel.Services.SessionAuthenticationModule.SignedOut" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método se invoca desde el <xref:System.IdentityModel.Services.SessionAuthenticationModule.SignOut%2A> método después de que se ha realizado el cierre de sesión y se ha eliminado la cookie de sesión.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnSigningOut">
      <MemberSignature Language="C#" Value="protected virtual void OnSigningOut (System.IdentityModel.Services.SigningOutEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnSigningOut(class System.IdentityModel.Services.SigningOutEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Services.SessionAuthenticationModule.OnSigningOut(System.IdentityModel.Services.SigningOutEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnSigningOut (e As SigningOutEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnSigningOut(System::IdentityModel::Services::SigningOutEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnSigningOut : System.IdentityModel.Services.SigningOutEventArgs -&gt; unit&#xA;override this.OnSigningOut : System.IdentityModel.Services.SigningOutEventArgs -&gt; unit" Usage="sessionAuthenticationModule.OnSigningOut e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel.Services</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.IdentityModel.Services.SigningOutEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Datos del evento.</param>
        <summary>Genera el evento <see cref="E:System.IdentityModel.Services.SessionAuthenticationModule.SigningOut" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método se invoca desde el <xref:System.IdentityModel.Services.SessionAuthenticationModule.SignOut%2A> método para realizar el cierre de sesión. Se invoca antes de que se elimina la cookie de sesión.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnSignOutError">
      <MemberSignature Language="C#" Value="protected virtual void OnSignOutError (System.IdentityModel.Services.ErrorEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnSignOutError(class System.IdentityModel.Services.ErrorEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Services.SessionAuthenticationModule.OnSignOutError(System.IdentityModel.Services.ErrorEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnSignOutError (e As ErrorEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnSignOutError(System::IdentityModel::Services::ErrorEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnSignOutError : System.IdentityModel.Services.ErrorEventArgs -&gt; unit&#xA;override this.OnSignOutError : System.IdentityModel.Services.ErrorEventArgs -&gt; unit" Usage="sessionAuthenticationModule.OnSignOutError e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel.Services</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.IdentityModel.Services.ErrorEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Datos del evento.</param>
        <summary>Genera el evento <see cref="E:System.IdentityModel.Services.SessionAuthenticationModule.SignOutError" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método se invoca desde el <xref:System.IdentityModel.Services.SessionAuthenticationModule.SignOut%2A> método si se produce un error durante el cierre de sesión.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReadSessionTokenFromCookie">
      <MemberSignature Language="C#" Value="public System.IdentityModel.Tokens.SessionSecurityToken ReadSessionTokenFromCookie (byte[] sessionCookie);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IdentityModel.Tokens.SessionSecurityToken ReadSessionTokenFromCookie(unsigned int8[] sessionCookie) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Services.SessionAuthenticationModule.ReadSessionTokenFromCookie(System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Function ReadSessionTokenFromCookie (sessionCookie As Byte()) As SessionSecurityToken" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IdentityModel::Tokens::SessionSecurityToken ^ ReadSessionTokenFromCookie(cli::array &lt;System::Byte&gt; ^ sessionCookie);" />
      <MemberSignature Language="F#" Value="member this.ReadSessionTokenFromCookie : byte[] -&gt; System.IdentityModel.Tokens.SessionSecurityToken" Usage="sessionAuthenticationModule.ReadSessionTokenFromCookie sessionCookie" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel.Services</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IdentityModel.Tokens.SessionSecurityToken</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sessionCookie" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="sessionCookie">Cookie, sin formato, que contiene el token de la sesión.</param>
        <summary>Lee un <see cref="T:System.IdentityModel.Tokens.SessionSecurityToken" /> de la cookie de sesión especificada.</summary>
        <returns>El token de sesión leído de la cookie.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException">No hay configurado ningún controlador de token de sesión válido. (No hay ningún <see cref="T:System.IdentityModel.Tokens.SessionSecurityTokenHandler" /> configurado en la propiedad <see cref="P:System.IdentityModel.Configuration.IdentityConfiguration.SecurityTokenHandlers" />.)</exception>
      </Docs>
    </Member>
    <Member MemberName="SessionSecurityTokenCreated">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.IdentityModel.Services.SessionSecurityTokenCreatedEventArgs&gt; SessionSecurityTokenCreated;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.IdentityModel.Services.SessionSecurityTokenCreatedEventArgs&gt; SessionSecurityTokenCreated" />
      <MemberSignature Language="DocId" Value="E:System.IdentityModel.Services.SessionAuthenticationModule.SessionSecurityTokenCreated" />
      <MemberSignature Language="VB.NET" Value="Public Event SessionSecurityTokenCreated As EventHandler(Of SessionSecurityTokenCreatedEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler&lt;System::IdentityModel::Services::SessionSecurityTokenCreatedEventArgs ^&gt; ^ SessionSecurityTokenCreated;" />
      <MemberSignature Language="F#" Value="member this.SessionSecurityTokenCreated : EventHandler&lt;System.IdentityModel.Services.SessionSecurityTokenCreatedEventArgs&gt; " Usage="member this.SessionSecurityTokenCreated : System.EventHandler&lt;System.IdentityModel.Services.SessionSecurityTokenCreatedEventArgs&gt; " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel.Services</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.IdentityModel.Services.SessionSecurityTokenCreatedEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produce cuando se ha creado un token de seguridad de la sesión.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Puede usar este evento para modificar el token de seguridad de la sesión antes de que se escriban en una cookie.  
  
 El <xref:System.IdentityModel.Services.SessionAuthenticationModule.SessionSecurityTokenCreated> evento se genera desde el <xref:System.IdentityModel.Services.SessionAuthenticationModule.OnAuthenticateRequest%2A> método después de un token de sesión (<xref:System.IdentityModel.Tokens.SessionSecurityToken>) se ha creado. Esto sucede, por ejemplo, si un controlador de eventos para el <xref:System.IdentityModel.Services.SessionAuthenticationModule.SessionSecurityTokenReceived> eventos modifica el token.  
  
 Puede usar este evento para modificar las propiedades del token de sesión antes de que se pasa más a lo largo de la canalización y se usa para autenticar la entidad que realiza la solicitud (usuario).  
  
 En un controlador de eventos, puede tener acceso el token a través de la <xref:System.IdentityModel.Services.SessionSecurityTokenCreatedEventArgs.SessionToken%2A?displayProperty=nameWithType> propiedad. Después de modificar el token, puede asegurarse de que se escriben en la cookie estableciendo el <xref:System.IdentityModel.Services.SessionSecurityTokenCreatedEventArgs.WriteSessionCookie%2A?displayProperty=nameWithType> propiedad `true`. A diferencia, el <xref:System.IdentityModel.Services.SessionAuthenticationModule.SessionSecurityTokenCreated> eventos, <xref:System.IdentityModel.Services.SessionAuthenticationModule.SessionSecurityTokenCreated> no es un evento cancelable.  
  
   
  
## Examples  
 El código siguiente muestra un controlador para el <xref:System.IdentityModel.Services.SessionAuthenticationModule.SessionSecurityTokenCreated> evento implementado en el archivo global.asax.cs de una aplicación web ASP.NET. También debe agregar el controlador al evento. Un ejemplo más completo se muestra en el <xref:System.IdentityModel.Services.SessionAuthenticationModule> tema de información general.  
  
 [!code-csharp[WifSAM#6](~/samples/snippets/csharp/VS_Snippets_Misc/wifsam/cs/webapplication1/global.asax.cs#6)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SessionSecurityTokenReceived">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.IdentityModel.Services.SessionSecurityTokenReceivedEventArgs&gt; SessionSecurityTokenReceived;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.IdentityModel.Services.SessionSecurityTokenReceivedEventArgs&gt; SessionSecurityTokenReceived" />
      <MemberSignature Language="DocId" Value="E:System.IdentityModel.Services.SessionAuthenticationModule.SessionSecurityTokenReceived" />
      <MemberSignature Language="VB.NET" Value="Public Event SessionSecurityTokenReceived As EventHandler(Of SessionSecurityTokenReceivedEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler&lt;System::IdentityModel::Services::SessionSecurityTokenReceivedEventArgs ^&gt; ^ SessionSecurityTokenReceived;" />
      <MemberSignature Language="F#" Value="member this.SessionSecurityTokenReceived : EventHandler&lt;System.IdentityModel.Services.SessionSecurityTokenReceivedEventArgs&gt; " Usage="member this.SessionSecurityTokenReceived : System.EventHandler&lt;System.IdentityModel.Services.SessionSecurityTokenReceivedEventArgs&gt; " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel.Services</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.IdentityModel.Services.SessionSecurityTokenReceivedEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produce una vez leído un token de seguridad de la sesión de una cookie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.IdentityModel.Services.SessionAuthenticationModule.SessionSecurityTokenReceived> evento se genera desde el <xref:System.IdentityModel.Services.SessionAuthenticationModule.OnAuthenticateRequest%2A> método después de un token de sesión (<xref:System.IdentityModel.Tokens.SessionSecurityToken>) se ha leído correctamente desde la cookie de sesión.  
  
 Puede usar este evento para modificar las propiedades del token de sesión antes de que se pasa más a lo largo de la canalización y se usa para autenticar la entidad que realiza la solicitud (usuario). Uno de los escenarios más comunes implica la modificación de la hora de expiración de la sesión (accesible a través de la <xref:System.IdentityModel.Tokens.SessionSecurityToken.ValidTo%2A?displayProperty=nameWithType> propiedad) para invalidar el tiempo de expiración de sesión establecido en configuración a través de la `lifetime` atributo de la [ &lt;sessionTokenRequirement&gt; ](~/docs/framework/configure-apps/file-schema/windows-identity-foundation/sessiontokenrequirement.md) elemento. Al modificar esta propiedad en cada solicitud, puede implementar una sesión deslizante; es decir, una sesión en el que la duración se extiende a cada momento los accesos de usuario del sitio.  
  
 En un controlador de eventos, puede tener acceso el token a través de la <xref:System.IdentityModel.Services.SessionSecurityTokenReceivedEventArgs.SessionToken%2A?displayProperty=nameWithType> propiedad. Después de modificar el token, puede asegurarse de que se escriben en la cookie estableciendo el <xref:System.IdentityModel.Services.SessionSecurityTokenReceivedEventArgs.ReissueCookie%2A?displayProperty=nameWithType> a `true`. Por último, el <xref:System.IdentityModel.Services.SessionAuthenticationModule.SessionSecurityTokenReceived> evento es un evento cancelable, y puede establecer el <xref:System.ComponentModel.CancelEventArgs.Cancel%2A> propiedad de la <xref:System.IdentityModel.Services.SessionSecurityTokenReceivedEventArgs> para anular la operación de procesamiento de la solicitud.  
  
   
  
## Examples  
 El código siguiente muestra un controlador para el <xref:System.IdentityModel.Services.SessionAuthenticationModule.SessionSecurityTokenReceived> evento implementado en el archivo global.asax.cs de una aplicación web ASP.NET. También debe agregar el controlador al evento. Un ejemplo más completo se muestra en el <xref:System.IdentityModel.Services.SessionAuthenticationModule> tema de información general.  
  
 [!code-csharp[WifSAM#5](~/samples/snippets/csharp/VS_Snippets_Misc/wifsam/cs/webapplication1/global.asax.cs#5)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetPrincipalFromSessionToken">
      <MemberSignature Language="C#" Value="protected virtual void SetPrincipalFromSessionToken (System.IdentityModel.Tokens.SessionSecurityToken sessionSecurityToken);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void SetPrincipalFromSessionToken(class System.IdentityModel.Tokens.SessionSecurityToken sessionSecurityToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Services.SessionAuthenticationModule.SetPrincipalFromSessionToken(System.IdentityModel.Tokens.SessionSecurityToken)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void SetPrincipalFromSessionToken(System::IdentityModel::Tokens::SessionSecurityToken ^ sessionSecurityToken);" />
      <MemberSignature Language="F#" Value="abstract member SetPrincipalFromSessionToken : System.IdentityModel.Tokens.SessionSecurityToken -&gt; unit&#xA;override this.SetPrincipalFromSessionToken : System.IdentityModel.Tokens.SessionSecurityToken -&gt; unit" Usage="sessionAuthenticationModule.SetPrincipalFromSessionToken sessionSecurityToken" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel.Services</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sessionSecurityToken" Type="System.IdentityModel.Tokens.SessionSecurityToken" />
      </Parameters>
      <Docs>
        <param name="sessionSecurityToken">El token de sesión del que se va a establecer la entidad de seguridad.</param>
        <summary>Establece la entidad de seguridad de <see cref="T:System.Web.HttpContext" /> y <see cref="T:System.Threading.Thread" /> en la entidad de seguridad contenida en el token de sesión especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Invoca el <xref:System.IdentityModel.Services.SessionAuthenticationModule.ValidateSessionToken%2A> método y establece el <xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=nameWithType> propiedad y el <xref:System.Web.HttpContext.User%2A?displayProperty=nameWithType> propiedad en <xref:System.Web.HttpContext.Current%2A?displayProperty=nameWithType> utilizando las identidades que se devuelven.  
  
 Este método se llama desde el <xref:System.IdentityModel.Services.SessionAuthenticationModule.AuthenticateSessionSecurityToken%2A> método.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SignedOut">
      <MemberSignature Language="C#" Value="public event EventHandler SignedOut;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler SignedOut" />
      <MemberSignature Language="DocId" Value="E:System.IdentityModel.Services.SessionAuthenticationModule.SignedOut" />
      <MemberSignature Language="VB.NET" Value="Public Event SignedOut As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ SignedOut;" />
      <MemberSignature Language="F#" Value="member this.SignedOut : EventHandler " Usage="member this.SignedOut : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel.Services</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produce una vez ha cerrado sesión el usuario.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se genera desde el <xref:System.IdentityModel.Services.SessionAuthenticationModule.SignOut%2A> método justo después la <xref:System.IdentityModel.Services.SessionAuthenticationModule.DeleteSessionTokenCookie%2A> se invoca el método.  
  
 Este evento no se garantiza que se llama para cada sesión. Por ejemplo, es posible que se puede eliminar las cookies en el lado cliente, en cuyo caso, este evento nunca se generaría porque no hay ningún evento de servidor para eliminar la sesión.  
  
   
  
## Examples  
 El código siguiente muestra un controlador para el <xref:System.IdentityModel.Services.SessionAuthenticationModule.SignedOut> evento implementado en el archivo global.asax.cs de una aplicación web ASP.NET. También debe agregar el controlador al evento. Un ejemplo más completo se muestra en el <xref:System.IdentityModel.Services.SessionAuthenticationModule> tema de información general.  
  
 [!code-csharp[WifSAM#3](~/samples/snippets/csharp/VS_Snippets_Misc/wifsam/cs/webapplication1/global.asax.cs#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SigningOut">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.IdentityModel.Services.SigningOutEventArgs&gt; SigningOut;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.IdentityModel.Services.SigningOutEventArgs&gt; SigningOut" />
      <MemberSignature Language="DocId" Value="E:System.IdentityModel.Services.SessionAuthenticationModule.SigningOut" />
      <MemberSignature Language="VB.NET" Value="Public Event SigningOut As EventHandler(Of SigningOutEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler&lt;System::IdentityModel::Services::SigningOutEventArgs ^&gt; ^ SigningOut;" />
      <MemberSignature Language="F#" Value="member this.SigningOut : EventHandler&lt;System.IdentityModel.Services.SigningOutEventArgs&gt; " Usage="member this.SigningOut : System.EventHandler&lt;System.IdentityModel.Services.SigningOutEventArgs&gt; " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel.Services</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.IdentityModel.Services.SigningOutEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produce antes de eliminar la sesión de inicio.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se genera desde el <xref:System.IdentityModel.Services.SessionAuthenticationModule.SignOut%2A> método justo antes el <xref:System.IdentityModel.Services.SessionAuthenticationModule.DeleteSessionTokenCookie%2A> se invoca el método.  
  
 Este evento no se garantiza que se llama para cada sesión. Por ejemplo, es posible que se puede eliminar las cookies en el lado cliente, en cuyo caso, este evento nunca se generaría porque no hay ningún evento de servidor para eliminar la sesión.  
  
   
  
## Examples  
 El código siguiente muestra un controlador para el <xref:System.IdentityModel.Services.SessionAuthenticationModule.SigningOut> evento implementado en el archivo global.asax.cs de una aplicación web ASP.NET. También debe agregar el controlador al evento. Un ejemplo más completo se muestra en el <xref:System.IdentityModel.Services.SessionAuthenticationModule> tema de información general.  
  
 [!code-csharp[WifSAM#4](~/samples/snippets/csharp/VS_Snippets_Misc/wifsam/cs/webapplication1/global.asax.cs#4)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SignOut">
      <MemberSignature Language="C#" Value="public virtual void SignOut ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void SignOut() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Services.SessionAuthenticationModule.SignOut" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub SignOut ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void SignOut();" />
      <MemberSignature Language="F#" Value="abstract member SignOut : unit -&gt; unit&#xA;override this.SignOut : unit -&gt; unit" Usage="sessionAuthenticationModule.SignOut " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel.Services</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Cierra la sesión del usuario actual y genera los eventos asociados.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Invoca el <xref:System.IdentityModel.Services.SessionAuthenticationModule.OnSigningOut%2A>, <xref:System.IdentityModel.Services.SessionAuthenticationModule.DeleteSessionTokenCookie%2A>, y <xref:System.IdentityModel.Services.SessionAuthenticationModule.OnSignedOut%2A> métodos para realizar el cierre de sesión. Si se produce una excepción, el <xref:System.IdentityModel.Services.SessionAuthenticationModule.OnSignOutError%2A> método se invoca para provocar el <xref:System.IdentityModel.Services.SessionAuthenticationModule.SignOutError> eventos. Puede establecer el <xref:System.ComponentModel.CancelEventArgs.Cancel%2A> propiedad de la <xref:System.IdentityModel.Services.ErrorEventArgs> objeto pasa al controlador de eventos para este evento cancelar el cierre de sesión y evitar que la excepción se propaga al cliente.  
  
 Puede invalidar este método para agregar un comportamiento específico de la aplicación.  
  
   
  
## Examples  
 El código siguiente muestra el código para invocar la <xref:System.IdentityModel.Services.SessionAuthenticationModule.SignOut%2A> método desde una página SignOut.aspx (SignOut.aspx.cs) en una aplicación web ASP.NET. Un ejemplo más completo se muestra en el <xref:System.IdentityModel.Services.SessionAuthenticationModule> tema de información general.  
  
 [!code-csharp[WifSAM#7](~/samples/snippets/csharp/VS_Snippets_Misc/wifsam/cs/webapplication1/global.asax.cs#7)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SignOutError">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.IdentityModel.Services.ErrorEventArgs&gt; SignOutError;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.IdentityModel.Services.ErrorEventArgs&gt; SignOutError" />
      <MemberSignature Language="DocId" Value="E:System.IdentityModel.Services.SessionAuthenticationModule.SignOutError" />
      <MemberSignature Language="VB.NET" Value="Public Event SignOutError As EventHandler(Of ErrorEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler&lt;System::IdentityModel::Services::ErrorEventArgs ^&gt; ^ SignOutError;" />
      <MemberSignature Language="F#" Value="member this.SignOutError : EventHandler&lt;System.IdentityModel.Services.ErrorEventArgs&gt; " Usage="member this.SignOutError : System.EventHandler&lt;System.IdentityModel.Services.ErrorEventArgs&gt; " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel.Services</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.IdentityModel.Services.ErrorEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produce cuando hay un error durante el cierre de sesión.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se genera desde el <xref:System.IdentityModel.Services.SessionAuthenticationModule.SignOut%2A> método cuando se produce un error durante el cierre de sesión.  
  
 En un controlador de eventos, puede obtener la excepción que se produjo en el evento que se genera desde el <xref:System.IdentityModel.Services.ErrorEventArgs.Exception%2A?displayProperty=nameWithType> propiedad. Puede cancelar todo procesamiento subsiguiente de la excepción, que tiene el resultado de no propagar la excepción al cliente, estableciendo el <xref:System.ComponentModel.CancelEventArgs.Cancel%2A> propiedad de la <xref:System.IdentityModel.Services.ErrorEventArgs> a `true`.  
  
 Este evento no se garantiza que se llama para cada sesión. Por ejemplo, es posible que se puede eliminar las cookies en el lado cliente, en cuyo caso, este evento nunca se generaría porque no hay ningún evento de servidor para eliminar la sesión.  
  
   
  
## Examples  
 El código siguiente muestra un controlador para el <xref:System.IdentityModel.Services.SessionAuthenticationModule.SignOutError> evento implementado en el archivo global.asax.cs de una aplicación web ASP.NET. También debe agregar el controlador al evento. Un ejemplo más completo se muestra en el <xref:System.IdentityModel.Services.SessionAuthenticationModule> tema de información general.  
  
 [!code-csharp[WifSAM#2](~/samples/snippets/csharp/VS_Snippets_Misc/wifsam/cs/webapplication1/global.asax.cs#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TryReadSessionTokenFromCookie">
      <MemberSignature Language="C#" Value="public bool TryReadSessionTokenFromCookie (out System.IdentityModel.Tokens.SessionSecurityToken sessionToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryReadSessionTokenFromCookie([out] class System.IdentityModel.Tokens.SessionSecurityToken&amp; sessionToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Services.SessionAuthenticationModule.TryReadSessionTokenFromCookie(System.IdentityModel.Tokens.SessionSecurityToken@)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryReadSessionTokenFromCookie (ByRef sessionToken As SessionSecurityToken) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryReadSessionTokenFromCookie([Runtime::InteropServices::Out] System::IdentityModel::Tokens::SessionSecurityToken ^ % sessionToken);" />
      <MemberSignature Language="F#" Value="member this.TryReadSessionTokenFromCookie :  -&gt; bool" Usage="sessionAuthenticationModule.TryReadSessionTokenFromCookie sessionToken" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel.Services</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sessionToken" Type="System.IdentityModel.Tokens.SessionSecurityToken" RefType="out" />
      </Parameters>
      <Docs>
        <param name="sessionToken">Cuando este método vuelve, contiene el token de seguridad de sesión leído de la cookie de sesión.</param>
        <summary>Se intenta leer un <see cref="T:System.IdentityModel.Tokens.SessionSecurityToken" /> de una cookie de sesión y devuelve un valor que indica si la cookie de sesión se leyó correctamente.</summary>
        <returns>
          <see langword="true" /> si la cookie de sesión se leyó correctamente de la solicitud; si no, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Lee la cookie mediante el controlador de cookies que se configura en el <xref:System.IdentityModel.Services.SessionAuthenticationModule.CookieHandler%2A> propiedad y, a continuación, invoca el <xref:System.IdentityModel.Services.SessionAuthenticationModule.ReadSessionTokenFromCookie%2A> método para leer el token de la cookie.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ValidateSessionToken">
      <MemberSignature Language="C#" Value="protected System.Collections.ObjectModel.ReadOnlyCollection&lt;System.Security.Claims.ClaimsIdentity&gt; ValidateSessionToken (System.IdentityModel.Tokens.SessionSecurityToken sessionSecurityToken);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance class System.Collections.ObjectModel.ReadOnlyCollection`1&lt;class System.Security.Claims.ClaimsIdentity&gt; ValidateSessionToken(class System.IdentityModel.Tokens.SessionSecurityToken sessionSecurityToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Services.SessionAuthenticationModule.ValidateSessionToken(System.IdentityModel.Tokens.SessionSecurityToken)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; System::Collections::ObjectModel::ReadOnlyCollection&lt;System::Security::Claims::ClaimsIdentity ^&gt; ^ ValidateSessionToken(System::IdentityModel::Tokens::SessionSecurityToken ^ sessionSecurityToken);" />
      <MemberSignature Language="F#" Value="member this.ValidateSessionToken : System.IdentityModel.Tokens.SessionSecurityToken -&gt; System.Collections.ObjectModel.ReadOnlyCollection&lt;System.Security.Claims.ClaimsIdentity&gt;" Usage="sessionAuthenticationModule.ValidateSessionToken sessionSecurityToken" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel.Services</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ObjectModel.ReadOnlyCollection&lt;System.Security.Claims.ClaimsIdentity&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sessionSecurityToken" Type="System.IdentityModel.Tokens.SessionSecurityToken" />
      </Parameters>
      <Docs>
        <param name="sessionSecurityToken">Token que se va a validar.</param>
        <summary>Valida el <see cref="T:System.IdentityModel.Tokens.SessionSecurityToken" /> especificado y devuelve sus identidades.</summary>
        <returns>La colección de identidades contenidas en el token.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método se llama desde el <xref:System.IdentityModel.Services.SessionAuthenticationModule.AuthenticateSessionSecurityToken%2A> método. Invoca el <xref:System.IdentityModel.Tokens.SessionSecurityTokenHandler.ValidateToken%2A?displayProperty=nameWithType> método del controlador de token de sesión configurada para validar el token y extraer sus identidades.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IdentityModel.Services.FederatedSessionExpiredException">El token ha expirado.</exception>
        <exception cref="T:System.IdentityModel.Services.FederationException">La hora de inicio del token no es aún válida.</exception>
        <exception cref="T:System.InvalidOperationException">No hay configurado ningún controlador de token de sesión válido. (No hay ningún <see cref="T:System.IdentityModel.Tokens.SessionSecurityTokenHandler" /> configurado en la propiedad <see cref="P:System.IdentityModel.Configuration.IdentityConfiguration.SecurityTokenHandlers" />.)</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteSessionTokenToCookie">
      <MemberSignature Language="C#" Value="public void WriteSessionTokenToCookie (System.IdentityModel.Tokens.SessionSecurityToken sessionToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteSessionTokenToCookie(class System.IdentityModel.Tokens.SessionSecurityToken sessionToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Services.SessionAuthenticationModule.WriteSessionTokenToCookie(System.IdentityModel.Tokens.SessionSecurityToken)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteSessionTokenToCookie (sessionToken As SessionSecurityToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteSessionTokenToCookie(System::IdentityModel::Tokens::SessionSecurityToken ^ sessionToken);" />
      <MemberSignature Language="F#" Value="member this.WriteSessionTokenToCookie : System.IdentityModel.Tokens.SessionSecurityToken -&gt; unit" Usage="sessionAuthenticationModule.WriteSessionTokenToCookie sessionToken" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel.Services</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sessionToken" Type="System.IdentityModel.Tokens.SessionSecurityToken" />
      </Parameters>
      <Docs>
        <param name="sessionToken">Token de seguridad de la sesión que se va a escribir.</param>
        <summary>Escribe el <see cref="T:System.IdentityModel.Tokens.SessionSecurityToken" /> especificado en una cookie de sesión.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Escribe la cookie con el controlador de cookies que se configura en el <xref:System.IdentityModel.Services.SessionAuthenticationModule.CookieHandler%2A> propiedad.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="sessionToken" /> es <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">No hay configurado ningún controlador de token de sesión válido. (No hay ningún <see cref="T:System.IdentityModel.Tokens.SessionSecurityTokenHandler" /> configurado en la propiedad <see cref="P:System.IdentityModel.Configuration.IdentityConfiguration.SecurityTokenHandlers" />.)</exception>
      </Docs>
    </Member>
  </Members>
</Type>