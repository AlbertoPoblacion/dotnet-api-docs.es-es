<Type Name="ParallelLoopState" FullName="System.Threading.Tasks.ParallelLoopState">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="ce5700b68f4a6ba69f5224dd0dd9b977cbfc8288" />
    <Meta Name="ms.sourcegitcommit" Value="6a0b904069161bbaec4ffd02aa7d9cf38c61e72e" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="es-ES" />
    <Meta Name="ms.lasthandoff" Value="06/24/2018" />
    <Meta Name="ms.locfileid" Value="36407495" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class ParallelLoopState" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit ParallelLoopState extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Threading.Tasks.ParallelLoopState" />
  <TypeSignature Language="VB.NET" Value="Public Class ParallelLoopState" />
  <TypeSignature Language="C++ CLI" Value="public ref class ParallelLoopState" />
  <TypeSignature Language="F#" Value="type ParallelLoopState = class" />
  <AssemblyInfo>
    <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.3.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.Diagnostics.DebuggerDisplay("ShouldExitCurrentIteration = {ShouldExitCurrentIteration}")</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Habilita iteraciones de bucles paralelos para interactuar con otras iteraciones. La clase <see cref="T:System.Threading.Tasks.Parallel" /> proporciona una instancia de esta clase a cada bucle; no se pueden crear instancias en el código.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Tenga en cuenta que no se puede crear una instancia de esta clase. Se genera automáticamente el compilador como un argumento en una llamada a la <xref:System.Threading.Tasks.Parallel.For%2A?displayProperty=nameWithType> o <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> método. En este ejemplo se ilustra.  
  
 Construye como `for` y `foreach` (en C#) y `For` y `For Each` (en Visual Basic) se ejecutan secuencialmente desde el índice más bajo al más alto o desde el primer objeto de un conjunto a la última. En cambio, el <xref:System.Threading.Tasks.Parallel.For%2A?displayProperty=nameWithType> y <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> métodos no lo hace. Como individuales iteraciones del bucle se ejecutan en paralelo, pueden comenzar y terminar en cualquier orden. La <xref:System.Threading.Tasks.ParallelLoopState> clase permite individuales iteraciones de bucles paralelos para interactuar entre sí. La <xref:System.Threading.Tasks.ParallelLoopState> clase le permite:  
  
-   Salir de la iteración actual y evitar cualquier iteraciones adicionales se inicie mediante una llamada a la <xref:System.Threading.Tasks.ParallelLoopState.Stop%2A> método. Esto no afecta a las iteraciones que ya se han comenzado la ejecución.  
  
-   Evitar que se ejecuten mediante una llamada a las iteraciones con un índice mayor que el índice actual el <xref:System.Threading.Tasks.ParallelLoopState.Break%2A> método. Esto no afecta a las iteraciones que ya se han comenzado la ejecución.  
  
-   Determinar si se produjo una excepción en cualquier iteración del bucle al recuperar el valor de la <xref:System.Threading.Tasks.ParallelLoopState.IsExceptional%2A> propiedad.  
  
-   Determinar si alguna iteración del bucle llamó el <xref:System.Threading.Tasks.ParallelLoopState.Stop%2A> método al recuperar el valor de la <xref:System.Threading.Tasks.ParallelLoopState.IsStopped%2A> propiedad. Puede usar esta propiedad para devolver las iteraciones del bucle que se inició antes de llamar a la <xref:System.Threading.Tasks.ParallelLoopState.Stop%2A> método pero todavía se está ejecutando.  
  
-   Determinar si alguna iteración del bucle llamó el <xref:System.Threading.Tasks.ParallelLoopState.Break%2A> o <xref:System.Threading.Tasks.ParallelLoopState.Stop%2A> método o ha producido una excepción al recuperar el valor de la <xref:System.Threading.Tasks.ParallelLoopState.ShouldExitCurrentIteration%2A> propiedad.  
  
-   Salida de una iteración de ejecución prolongada cuyo índice es mayor que el índice de una iteración en la que se llamó a Break al recuperar el valor de la <xref:System.Threading.Tasks.ParallelLoopState.LowestBreakIteration%2A> propiedad.  
  
   
  
## Examples  
 En el ejemplo siguiente se ejecuta hasta 100 iteraciones de un bucle en paralelo. Se hace una pausa en cada iteración para un intervalo aleatorio entre 1 y 1000 milisegundos. Un valor generado aleatoriamente que se determina en qué iteración del bucle el <xref:System.Threading.Tasks.ParallelLoopState.Break%2A> se llama al método. Como la salida de muestra en el ejemplo, no existen iteraciones cuyo índice es mayor que el <xref:System.Threading.Tasks.ParallelLoopState.LowestBreakIteration%2A> inicio de valor de propiedad después de llamar a la <xref:System.Threading.Tasks.ParallelLoopState.Break%2A> método.  
  
 [!code-csharp[System.Threading.Tasks.ParallelLoopState#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.parallelloopstate/cs/break1.cs#2)]
 [!code-vb[System.Threading.Tasks.ParallelLoopState#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.parallelloopstate/vb/break1.vb#2)]  
  
 Dado que las iteraciones del bucle son probablemente se estén ejecutando cuando el <xref:System.Threading.Tasks.ParallelLoopState.Break%2A> se llama al método, las llamadas de cada iteración el <xref:System.Threading.Tasks.ParallelLoopState.ShouldExitCurrentIteration%2A> propiedad para comprobar si se llama a otra iteración el <xref:System.Threading.Tasks.ParallelLoopState.Break%2A> (método). Si el valor de propiedad es `true`, la iteración comprueba el valor de la <xref:System.Threading.Tasks.ParallelLoopState.LowestBreakIteration%2A> propiedad y, si es mayor que el valor de índice de la iteración actual, se devuelve inmediatamente.  
  
 ]]></format>
    </remarks>
    <threadsafe>Un <see cref="T:System.Threading.Tasks.ParallelLoopState" /> instancia está pensada para usarse solo en el cuerpo del bucle a la que se proporcionó una instancia.  No es seguro utilizar proporcionado <see cref="T:System.Threading.Tasks.ParallelLoopState" /> instancia después del bucle asociado finaliza, ni es seguro entregarla explícitamente a otros subprocesos y permitir que esos subprocesos acceso a él en cualquier momento.  Otra <see cref="T:System.Threading.Tasks.ParallelLoopState" /> instancia se proporcionará a cada subproceso implicado en un bucle.</threadsafe>
  </Docs>
  <Members>
    <Member MemberName="Break">
      <MemberSignature Language="C#" Value="public void Break ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Break() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.ParallelLoopState.Break" />
      <MemberSignature Language="VB.NET" Value="Public Sub Break ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Break();" />
      <MemberSignature Language="F#" Value="member this.Break : unit -&gt; unit" Usage="parallelLoopState.Break " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Comunica que el bucle <see cref="T:System.Threading.Tasks.Parallel" /> debe cesar la ejecución de iteraciones después de la iteración actual en cuanto pueda el sistema.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Tasks.ParallelLoopState.Break%2A> indica que no se deben ejecutar iteraciones después de la iteración actual. Eficazmente cancela cualquier iteraciones adicionales del bucle. Sin embargo, no impide que las iteraciones que ya se han comenzado la ejecución. Por ejemplo, si <xref:System.Threading.Tasks.ParallelLoopState.Break%2A> se llama desde la iteración número 100 de un bucle paralelo iterando desde 0 a 1.000, todas las iteraciones inferior a 100 deben seguir ejecutándose, pero las iteraciones de 101 a 1000 que aún no ha iniciado no son ejecutarse.  
  
 Para las iteraciones de ejecución prolongada que ya se estén ejecutando, <xref:System.Threading.Tasks.ParallelLoopState.Break%2A> establece la <xref:System.Threading.Tasks.ParallelLoopState.LowestBreakIteration%2A> propiedad al índice del iteración actual si el índice actual es menor que el valor actual de <xref:System.Threading.Tasks.ParallelLoopState.LowestBreakIteration%2A>. Para dejar de iteraciones cuyo índice es mayor que la iteración más baja de interrupción de ejecución de la competencia, debe hacer lo siguiente:  
  
1.  Compruebe si el <xref:System.Threading.Tasks.ParallelLoopState.ShouldExitCurrentIteration%2A> propiedad es `true`.  
  
2.  Salir de la iteración si el índice es mayor que la <xref:System.Threading.Tasks.ParallelLoopState.LowestBreakIteration%2A> valor de propiedad.  
  
 En este ejemplo se ilustra.  
  
 <xref:System.Threading.Tasks.ParallelLoopState.Break%2A> se emplea normalmente en algoritmos basados en búsquedas donde una ordenación está presente en el origen de datos.  
  
   
  
## Examples  
 En el ejemplo siguiente se ejecuta hasta 100 iteraciones de un bucle en paralelo. Se hace una pausa en cada iteración para un intervalo aleatorio entre 1 y 1000 milisegundos. Un valor generado aleatoriamente que se determina en qué iteración del bucle el <xref:System.Threading.Tasks.ParallelLoopState.Break%2A> se llama al método. Como la salida de muestra en el ejemplo, no existen iteraciones cuyo índice es mayor que el <xref:System.Threading.Tasks.ParallelLoopState.LowestBreakIteration%2A> inicio de valor de propiedad después de llamar a la <xref:System.Threading.Tasks.ParallelLoopState.Break%2A> método.  
  
 [!code-csharp[System.Threading.Tasks.ParallelLoopState#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.parallelloopstate/cs/break1.cs#2)]
 [!code-vb[System.Threading.Tasks.ParallelLoopState#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.parallelloopstate/vb/break1.vb#2)]  
  
 Dado que las iteraciones del bucle son probablemente se estén ejecutando cuando el <xref:System.Threading.Tasks.ParallelLoopState.Break%2A> se llama al método, las llamadas de cada iteración el <xref:System.Threading.Tasks.ParallelLoopState.ShouldExitCurrentIteration%2A> propiedad para comprobar si se llama a otra iteración el <xref:System.Threading.Tasks.ParallelLoopState.Break%2A> (método). Si el valor de propiedad es `true`, la iteración comprueba el valor de la <xref:System.Threading.Tasks.ParallelLoopState.LowestBreakIteration%2A> propiedad y, si es mayor que el valor de índice de la iteración actual, se devuelve inmediatamente.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">El método <see cref="M:System.Threading.Tasks.ParallelLoopState.Stop" /> se definió previamente. Las iteraciones del mismo bucle no pueden utilizar <see cref="M:System.Threading.Tasks.ParallelLoopState.Break" /> y <see cref="M:System.Threading.Tasks.ParallelLoopState.Stop" /> en combinación.</exception>
        <altmember cref="P:System.Threading.Tasks.ParallelLoopState.ShouldExitCurrentIteration" />
        <altmember cref="P:System.Threading.Tasks.ParallelLoopState.LowestBreakIteration" />
      </Docs>
    </Member>
    <Member MemberName="IsExceptional">
      <MemberSignature Language="C#" Value="public bool IsExceptional { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsExceptional" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.ParallelLoopState.IsExceptional" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsExceptional As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsExceptional { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsExceptional : bool" Usage="System.Threading.Tasks.ParallelLoopState.IsExceptional" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene si alguna iteración del bucle causó una excepción que la iteración no controló.</summary>
        <value>
          <see langword="true" /> si se produjo una excepción no controlada; en caso contrario, <see langword="false" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsStopped">
      <MemberSignature Language="C#" Value="public bool IsStopped { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsStopped" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.ParallelLoopState.IsStopped" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsStopped As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsStopped { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsStopped : bool" Usage="System.Threading.Tasks.ParallelLoopState.IsStopped" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene si alguna iteración del bucle llamó al método <see cref="M:System.Threading.Tasks.ParallelLoopState.Stop" />.</summary>
        <value>
          <see langword="true" /> si cualquier iteración detuvo el bucle llamando al método <see cref="M:System.Threading.Tasks.ParallelLoopState.Stop" />; en caso contrario, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para las iteraciones de ejecución prolongada del bucle, puede recuperar el valor de la <xref:System.Threading.Tasks.ParallelLoopState.IsStopped%2A> propiedad para determinar si las iteraciones del bucle que comenzó su ejecución antes de llamar a la <xref:System.Threading.Tasks.ParallelLoopState.Stop%2A> método todavía se está ejecutando. A continuación, puede utilizar el valor de la <xref:System.Threading.Tasks.ParallelLoopState.IsStopped%2A> propiedad para determinar si deben devolver inmediatamente o se ejecutan normalmente.  
  
   
  
## Examples  
 En el ejemplo siguiente se ejecuta hasta 10 000 iteraciones de un bucle en paralelo. Se hace una pausa en cada iteración para un intervalo aleatorio entre 1 y 1000 milisegundos. Un valor generado aleatoriamente que se determina en qué iteración del bucle el <xref:System.Threading.Tasks.ParallelLoopState.Stop%2A> se llama al método. Dado que las iteraciones del bucle son probablemente se estén ejecutando cuando el <xref:System.Threading.Tasks.ParallelLoopState.Stop%2A> llama el método, la expresión lambda llama el <xref:System.Threading.Tasks.ParallelLoopState.IsStopped%2A> método para comprobar si se llama a otra iteración el <xref:System.Threading.Tasks.ParallelLoopState.Stop%2A> (método). Si devuelve `true`, la iteración se devuelve inmediatamente.  
  
 [!code-csharp[System.Threading.Tasks.ParallelLoopState#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.parallelloopstate/cs/stop1.cs#1)]
 [!code-vb[System.Threading.Tasks.ParallelLoopState#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.parallelloopstate/vb/stop1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LowestBreakIteration">
      <MemberSignature Language="C#" Value="public Nullable&lt;long&gt; LowestBreakIteration { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Nullable`1&lt;int64&gt; LowestBreakIteration" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.ParallelLoopState.LowestBreakIteration" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property LowestBreakIteration As Nullable(Of Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Nullable&lt;long&gt; LowestBreakIteration { Nullable&lt;long&gt; get(); };" />
      <MemberSignature Language="F#" Value="member this.LowestBreakIteration : Nullable&lt;int64&gt;" Usage="System.Threading.Tasks.ParallelLoopState.LowestBreakIteration" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Int64&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene la iteración más baja del bucle desde el que se llamó a <see cref="M:System.Threading.Tasks.ParallelLoopState.Break" />.</summary>
        <value>Iteración más baja desde la que se llamó a <see cref="M:System.Threading.Tasks.ParallelLoopState.Break" />. En el caso de un bucle <see cref="M:System.Threading.Tasks.Parallel.ForEach``1(System.Collections.Concurrent.Partitioner{``0},System.Action{``0})" />, el valor está basado en un índice generado internamente.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Es posible que varias iteraciones de un bucle paralelo para llamar a la <xref:System.Threading.Tasks.ParallelLoopState.Break%2A> método. Si es así, este valor es el índice más pequeño de una iteración en la que llama <xref:System.Threading.Tasks.ParallelLoopState.Break%2A>. Si ninguna iteración del bucle llamó <xref:System.Threading.Tasks.ParallelLoopState.Break%2A>, esta propiedad devuelve `null`. Tenga en cuenta que el valor de propiedad no se ve afectado por las llamadas a la <xref:System.Threading.Tasks.ParallelLoopState.Stop%2A> método.  
  
 En las iteraciones de ejecución prolongada en que todas las iteraciones después de la iteración que llama el <xref:System.Threading.Tasks.ParallelLoopState.Break%2A> no necesita ejecutar el método, el <xref:System.Threading.Tasks.ParallelLoopState.LowestBreakIteration%2A> propiedad se usa para finalizar las iteraciones que comenzó su ejecución antes de llamar a la <xref:System.Threading.Tasks.ParallelLoopState.Break%2A> método. Para dejar de iteraciones cuyo índice es mayor que la iteración más baja de interrupción de ejecución de la competencia, debe hacer lo siguiente:  
  
1.  Compruebe si el <xref:System.Threading.Tasks.ParallelLoopState.ShouldExitCurrentIteration%2A> propiedad es `true`.  
  
2.  Salir de la iteración si el índice es mayor que la <xref:System.Threading.Tasks.ParallelLoopState.LowestBreakIteration%2A> valor de propiedad.  
  
 En este ejemplo se ilustra.  
  
   
  
## Examples  
 En el ejemplo siguiente se ejecuta hasta 100 iteraciones de un bucle en paralelo. Se hace una pausa en cada iteración para un intervalo aleatorio entre 1 y 1000 milisegundos. Un valor generado aleatoriamente que se determina en qué iteración del bucle el <xref:System.Threading.Tasks.ParallelLoopState.Break%2A> se llama al método. Esto evita que las iteraciones cuyo índice es mayor que el <xref:System.Threading.Tasks.ParallelLoopState.LowestBreakIteration%2A> valor de la propiedad de inicio después de la llamada a la <xref:System.Threading.Tasks.ParallelLoopState.Break%2A> método, pero no afecta a las iteraciones que ya han empezado a ejecutar. Para evitar que se complete, llama a cada iteración del <xref:System.Threading.Tasks.ParallelLoopState.ShouldExitCurrentIteration%2A> método para comprobar si se llama a otra iteración el <xref:System.Threading.Tasks.ParallelLoopState.Break%2A> método. Si es así, la iteración comprueba el valor de la <xref:System.Threading.Tasks.ParallelLoopState.LowestBreakIteration%2A> propiedad y, si es mayor que el valor de índice de la iteración actual, se devuelve inmediatamente.  
  
 [!code-csharp[System.Threading.Tasks.ParallelLoopState#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.parallelloopstate/cs/break1.cs#2)]
 [!code-vb[System.Threading.Tasks.ParallelLoopState#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.parallelloopstate/vb/break1.vb#2)]  
  
 Tenga en cuenta que, dado el <xref:System.Threading.Tasks.ParallelLoopState.LowestBreakIteration%2A> valor está fuera del ámbito fuera del bucle paralelo, debe asignarlo a una variable que es visible fuera del bucle si desea conservar su valor.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Threading.Tasks.ParallelLoopState.ShouldExitCurrentIteration" />
        <altmember cref="M:System.Threading.Tasks.ParallelLoopState.Break" />
      </Docs>
    </Member>
    <Member MemberName="ShouldExitCurrentIteration">
      <MemberSignature Language="C#" Value="public bool ShouldExitCurrentIteration { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ShouldExitCurrentIteration" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.ParallelLoopState.ShouldExitCurrentIteration" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ShouldExitCurrentIteration As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool ShouldExitCurrentIteration { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.ShouldExitCurrentIteration : bool" Usage="System.Threading.Tasks.ParallelLoopState.ShouldExitCurrentIteration" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene si la iteración actual del bucle debe salir basándose en las solicitudes realizadas por esta u otras iteraciones.</summary>
        <value>
          <see langword="true" /> si la iteración actual debería terminar; en caso contrario, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Threading.Tasks.ParallelLoopState.ShouldExitCurrentIteration%2A> propiedad está establecida en `true` en cualquiera de las condiciones siguientes:  
  
-   Una iteración de las llamadas de bucle <xref:System.Threading.Tasks.ParallelLoopState.Break%2A> o <xref:System.Threading.Tasks.ParallelLoopState.Stop%2A>.  
  
-   Una iteración del bucle produce una excepción.  
  
-   Se ha cancelado el bucle.  
  
 Cuando esta propiedad es `true`, la <xref:System.Threading.Tasks.Parallel> clase proactivamente intentará prohibir iteraciones adicionales del bucle inicien la ejecución. Sin embargo, puede haber casos donde es puede evitar que se inicien iteraciones adicionales.  
  
 También puede ser el caso de que una iteración de ejecución prolongada ya ha comenzado la ejecución. En tales casos, pueden comprobar explícitamente iteraciones el <xref:System.Threading.Tasks.ParallelLoopState.ShouldExitCurrentIteration%2A> propiedad y dejará de ejecución si la propiedad devuelve `true`.  
  
   
  
## Examples  
 En el ejemplo siguiente se ejecuta hasta 100 iteraciones de un bucle en paralelo. Se hace una pausa en cada iteración para un intervalo aleatorio entre 1 y 1000 milisegundos. Un valor generado aleatoriamente que se determina en qué iteración del bucle el <xref:System.Threading.Tasks.ParallelLoopState.Break%2A> se llama al método. Esto evita que las iteraciones cuyo índice es mayor que el <xref:System.Threading.Tasks.ParallelLoopState.LowestBreakIteration%2A> valor de la propiedad de inicio después de la llamada a la <xref:System.Threading.Tasks.ParallelLoopState.Break%2A> método, pero no afecta a las iteraciones que ya han empezado a ejecutar. Para evitar que se complete, llama a cada iteración del <xref:System.Threading.Tasks.ParallelLoopState.ShouldExitCurrentIteration%2A> método para comprobar si se llama a otra iteración el <xref:System.Threading.Tasks.ParallelLoopState.Break%2A> método. Si es así, la iteración comprueba el valor de la <xref:System.Threading.Tasks.ParallelLoopState.LowestBreakIteration%2A> propiedad y, si es mayor que el valor de índice de la iteración actual, se devuelve inmediatamente.  
  
 [!code-csharp[System.Threading.Tasks.ParallelLoopState#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.parallelloopstate/cs/break1.cs#2)]
 [!code-vb[System.Threading.Tasks.ParallelLoopState#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.parallelloopstate/vb/break1.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Threading.Tasks.ParallelLoopState.LowestBreakIteration" />
        <altmember cref="M:System.Threading.Tasks.ParallelLoopState.Break" />
        <altmember cref="M:System.Threading.Tasks.ParallelLoopState.Stop" />
      </Docs>
    </Member>
    <Member MemberName="Stop">
      <MemberSignature Language="C#" Value="public void Stop ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Stop() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.ParallelLoopState.Stop" />
      <MemberSignature Language="VB.NET" Value="Public Sub Stop ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Stop();" />
      <MemberSignature Language="F#" Value="member this.Stop : unit -&gt; unit" Usage="parallelLoopState.Stop " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Comunica que el bucle <see cref="T:System.Threading.Tasks.Parallel" /> debe cesar la ejecución en cuanto pueda el sistema.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Llamar a la <xref:System.Threading.Tasks.ParallelLoopState.Stop%2A> método indica que no se necesitan ejecutar las iteraciones del bucle que no haya iniciado todavía. Eficazmente cancela cualquier iteraciones adicionales del bucle. Sin embargo, no impide que las iteraciones que ya se han comenzado la ejecución.  
  
 Llamar a la <xref:System.Threading.Tasks.ParallelLoopState.Stop%2A> método hace la <xref:System.Threading.Tasks.ParallelLoopState.IsStopped%2A> propiedad para devolver `true` para alguna iteración del bucle que todavía se está ejecutando. Esto es especialmente útil para las iteraciones de ejecución prolongada, que pueden comprobar la <xref:System.Threading.Tasks.ParallelLoopState.IsStopped%2A> propiedad y salir pronto si su valor es `true`.  
  
 <xref:System.Threading.Tasks.ParallelLoopState.Stop%2A> se emplea normalmente en algoritmos basados en búsqueda, donde una vez un resultado de iteraciones se encuentra, ningún otras se necesitan ejecutar.  
  
   
  
## Examples  
 En el ejemplo siguiente se ejecuta hasta 10 000 iteraciones de un bucle en paralelo. Se hace una pausa en cada iteración para un intervalo aleatorio entre 1 y 1000 milisegundos. Un valor generado aleatoriamente que se determina en qué iteración del bucle el <xref:System.Threading.Tasks.ParallelLoopState.Stop%2A> se llama al método. Como se muestra en el resultado del ejemplo, no existen iteraciones ejecutarán después de llamar a la <xref:System.Threading.Tasks.ParallelLoopState.Stop%2A> método.  
  
 [!code-csharp[System.Threading.Tasks.ParallelLoopState#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.parallelloopstate/cs/stop1.cs#1)]
 [!code-vb[System.Threading.Tasks.ParallelLoopState#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.parallelloopstate/vb/stop1.vb#1)]  
  
 Dado que las iteraciones del bucle son probablemente se estén ejecutando cuando el <xref:System.Threading.Tasks.ParallelLoopState.Stop%2A> se llama al método, las llamadas de cada iteración el <xref:System.Threading.Tasks.ParallelLoopState.IsStopped%2A> método para comprobar si se llama a otra iteración el <xref:System.Threading.Tasks.ParallelLoopState.Stop%2A> método. Si devuelve `true`, la iteración se devuelve inmediatamente.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Se ha llamado anteriormente al método <see cref="M:System.Threading.Tasks.ParallelLoopState.Break" />. Las iteraciones del mismo bucle no pueden utilizar <see cref="M:System.Threading.Tasks.ParallelLoopState.Break" /> y <see cref="M:System.Threading.Tasks.ParallelLoopState.Stop" /> en combinación.</exception>
        <altmember cref="P:System.Threading.Tasks.ParallelLoopState.IsStopped" />
      </Docs>
    </Member>
  </Members>
</Type>