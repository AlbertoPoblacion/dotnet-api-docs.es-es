<Type Name="Parallel" FullName="System.Threading.Tasks.Parallel">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="9400e38d0e86f78825a1539468c98397e83c3420" />
    <Meta Name="ms.sourcegitcommit" Value="9e06b87bcfa4347dbbaaa4b3cc36b43b93b5badb" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="es-ES" />
    <Meta Name="ms.lasthandoff" Value="11/20/2018" />
    <Meta Name="ms.locfileid" Value="52236288" />
  </Metadata>
  <TypeSignature Language="C#" Value="public static class Parallel" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract sealed beforefieldinit Parallel extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Threading.Tasks.Parallel" />
  <TypeSignature Language="VB.NET" Value="Public Class Parallel" />
  <TypeSignature Language="C++ CLI" Value="public ref class Parallel abstract sealed" />
  <TypeSignature Language="F#" Value="type Parallel = class" />
  <AssemblyInfo>
    <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.3.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Proporciona compatibilidad con regiones y bucles paralelos.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La <xref:System.Threading.Tasks.Parallel> clase proporciona reemplazos en paralelo de datos basados en la biblioteca para operaciones comunes como bucles, para cada bucles y la ejecución de un conjunto de instrucciones.  
  
   
  
## Examples  
 Este ejemplo muestra varios enfoques para implementar un bucle paralelo mediante varias construcciones de lenguaje.  
  
 [!code-csharp[System.Threading.Tasks.Parallel#07](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.parallel/cs/parallelintro.cs#07)]
 [!code-vb[System.Threading.Tasks.Parallel#07](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.parallel/vb/parallelintro.vb#07)]  
  
 ]]></format>
    </remarks>
    <threadsafe>Todos los miembros públicos y protegidos de <see cref="T:System.Threading.Tasks.Parallel" /> son seguros para subprocesos y se pueden usar simultáneamente desde varios subprocesos.</threadsafe>
    <related type="Article" href="~/docs/standard/parallel-programming/data-parallelism-task-parallel-library.md">Paralelismo de datos (biblioteca TPL)</related>
    <related type="ExternalDocumentation" href="https://code.msdn.microsoft.com/Samples-for-Parallel-b4b76364">Ejemplos de programación paralela con .NET Framework</related>
  </Docs>
  <Members>
    <MemberGroup MemberName="For">
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Ejecuta un bucle <see langword="for" /> (<see langword="For" /> en Visual Basic) en el que es posible ejecutar iteraciones en paralelo.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="For">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult For (int fromInclusive, int toExclusive, Action&lt;int,System.Threading.Tasks.ParallelLoopState&gt; body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult For(int32 fromInclusive, int32 toExclusive, class System.Action`2&lt;int32, class System.Threading.Tasks.ParallelLoopState&gt; body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.For(System.Int32,System.Int32,System.Action{System.Int32,System.Threading.Tasks.ParallelLoopState})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function For (fromInclusive As Integer, toExclusive As Integer, body As Action(Of Integer, ParallelLoopState)) As ParallelLoopResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Tasks::ParallelLoopResult For(int fromInclusive, int toExclusive, Action&lt;int, System::Threading::Tasks::ParallelLoopState ^&gt; ^ body);" />
      <MemberSignature Language="F#" Value="static member For : int * int * Action&lt;int, System.Threading.Tasks.ParallelLoopState&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.For (fromInclusive, toExclusive, body)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fromInclusive" Type="System.Int32" />
        <Parameter Name="toExclusive" Type="System.Int32" />
        <Parameter Name="body" Type="System.Action&lt;System.Int32,System.Threading.Tasks.ParallelLoopState&gt;" />
      </Parameters>
      <Docs>
        <param name="fromInclusive">Índice inicial, inclusivo.</param>
        <param name="toExclusive">Índice final, exclusivo.</param>
        <param name="body">Delegado que se invoca una vez por cada iteración.</param>
        <summary>Ejecuta un bucle <see langword="for" /> (<see langword="For" /> en Visual Basic) donde se pueden ejecutar iteraciones en paralelo y el estado del bucle se puede supervisar y manipular.</summary>
        <returns>Estructura que contiene información sobre qué parte del bucle se completó.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El `body` delegado se invoca una vez para cada valor en el intervalo de iteración (`fromInclusive`, `toExclusive`). Se proporciona con dos argumentos:  
  
-   Un <xref:System.Int32> valor que representa el número de iteraciones.  
  
-   Un <xref:System.Threading.Tasks.ParallelLoopState> instancia que puede usarse para interrumpir el bucle prematuramente. El <xref:System.Threading.Tasks.ParallelLoopState> el compilador crea el objeto; no se puede crear una instancia en el código de usuario.  
  
 Una llamada a la <xref:System.Threading.Tasks.ParallelLoopState.Break%2A> informa al método el `for` operación que iteraciones después del actual no tienen que ejecutar. Sin embargo, todas las iteraciones antes de la actual uno todavía tendrá que será ejecutada si no lo han hecho ya.  
  
 Por lo tanto, una llamada a <xref:System.Threading.Tasks.ParallelLoopState.Break%2A> es similar al uso de una operación de salto dentro de un convencional `for` bucle en un lenguaje como C#, pero no es un sustituto perfecto: por ejemplo, no hay ninguna garantía de que las iteraciones después del actual no se iniciará sin duda ejecutar.  
  
 Si la ejecución de todas las iteraciones antes de que el actual no es necesario, use la <xref:System.Threading.Tasks.ParallelLoopState.Stop%2A> método en lugar de usar <xref:System.Threading.Tasks.ParallelLoopState.Break%2A>. Una llamada a <xref:System.Threading.Tasks.ParallelLoopState.Stop%2A> informa a la `for` bucle que puede abandonar todas las restantes iteraciones, independientemente de si antes o después de la iteración actual, dado que todos los necesarios ya se habrá cumplimentado trabajo. Sin embargo, como con <xref:System.Threading.Tasks.ParallelLoopState.Break%2A>, no hay ninguna garantía con respecto a que no se ejecutarán otras iteraciones.  
  
 Si un bucle finaliza prematuramente, el <xref:System.Threading.Tasks.ParallelLoopResult> estructura devuelta contendrá información relevante acerca de la finalización del bucle.  
  
 Si `fromInclusive` es mayor o igual que `toExclusive`, el método vuelve inmediatamente sin realizar ninguna iteración.  
  
   
  
## Examples  
 El ejemplo siguiente ejecuta hasta 100 iteraciones de un bucle en paralelo. Cada iteración se pausa durante un intervalo aleatorio entre 1 y 1000 milisegundos. Un valor generado aleatoriamente que se determina en qué iteración del bucle el <xref:System.Threading.Tasks.ParallelLoopState.Break%2A?displayProperty=nameWithType> se llama al método. Como la salida muestra el ejemplo, no hay iteraciones cuyo índice es mayor que el <xref:System.Threading.Tasks.ParallelLoopState.LowestBreakIteration%2A?displayProperty=nameWithType> inicio del valor de propiedad después de llamar a la <xref:System.Threading.Tasks.ParallelLoopState.Break%2A?displayProperty=nameWithType> método.  
  
 [!code-csharp[System.Threading.Tasks.ParallelLoopState#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.parallelloopstate/cs/break1.cs#2)]
 [!code-vb[System.Threading.Tasks.ParallelLoopState#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.parallelloopstate/vb/break1.vb#2)]  
  
 Porque todavía es posible que se ejecuta cuando las iteraciones del bucle el <xref:System.Threading.Tasks.ParallelLoopState.Break%2A?displayProperty=nameWithType> se llama al método, las llamadas de cada iteración del <xref:System.Threading.Tasks.ParallelLoopState.ShouldExitCurrentIteration%2A?displayProperty=nameWithType> propiedad para comprobar si se llama otra iteración el <xref:System.Threading.Tasks.ParallelLoopState.Break%2A?displayProperty=nameWithType> método. Si el valor de propiedad es `true`, la iteración comprueba el valor de la <xref:System.Threading.Tasks.ParallelLoopState.LowestBreakIteration%2A?displayProperty=nameWithType> propiedad y, si es mayor que el valor de índice de la iteración actual, se devuelve inmediatamente.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El argumento <paramref name="body" /> es <see langword="null" />.</exception>
        <exception cref="T:System.AggregateException">La excepción que contiene todas las excepciones individuales producidas en todos los subprocesos.</exception>
        <altmember cref="T:System.Threading.Tasks.ParallelLoopState" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)">Bucles paralelos</related>
      </Docs>
    </Member>
    <Member MemberName="For">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult For (int fromInclusive, int toExclusive, Action&lt;int&gt; body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult For(int32 fromInclusive, int32 toExclusive, class System.Action`1&lt;int32&gt; body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.For(System.Int32,System.Int32,System.Action{System.Int32})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function For (fromInclusive As Integer, toExclusive As Integer, body As Action(Of Integer)) As ParallelLoopResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Tasks::ParallelLoopResult For(int fromInclusive, int toExclusive, Action&lt;int&gt; ^ body);" />
      <MemberSignature Language="F#" Value="static member For : int * int * Action&lt;int&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.For (fromInclusive, toExclusive, body)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fromInclusive" Type="System.Int32" />
        <Parameter Name="toExclusive" Type="System.Int32" />
        <Parameter Name="body" Type="System.Action&lt;System.Int32&gt;" />
      </Parameters>
      <Docs>
        <param name="fromInclusive">Índice inicial, inclusivo.</param>
        <param name="toExclusive">Índice final, exclusivo.</param>
        <param name="body">Delegado que se invoca una vez por cada iteración.</param>
        <summary>Ejecuta un bucle <see langword="for" /> (<see langword="For" /> en Visual Basic) en el que es posible ejecutar iteraciones en paralelo.</summary>
        <returns>Estructura que contiene información sobre qué parte del bucle se completó.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El `body` delegado se invoca una vez para cada valor en el intervalo de iteración (`fromInclusive`, `toExclusive`). Se proporciona con el número de iteraciones (<xref:System.Int32>) como un parámetro.  
  
 Si `fromInclusive` es mayor o igual que `toExclusive`, el método vuelve inmediatamente sin realizar ninguna iteración.  
  
   
  
## Examples  
 En el ejemplo siguiente se usa el <xref:System.Threading.Tasks.Parallel.For%2A> método las 100 invocaciones de un delegado que genera los bytes aleatorios de los valores y calcula su suma.  
  
 [!code-csharp[System.Threading.Tasks.Parallel.For#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.parallel.for/cs/for1.cs#1)]
 [!code-vb[System.Threading.Tasks.Parallel.For#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.parallel.for/vb/for1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El argumento <paramref name="body" /> es <see langword="null" />.</exception>
        <exception cref="T:System.AggregateException">La excepción que contiene todas las excepciones individuales producidas en todos los subprocesos.</exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)">Bucles paralelos</related>
      </Docs>
    </Member>
    <Member MemberName="For">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult For (long fromInclusive, long toExclusive, Action&lt;long,System.Threading.Tasks.ParallelLoopState&gt; body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult For(int64 fromInclusive, int64 toExclusive, class System.Action`2&lt;int64, class System.Threading.Tasks.ParallelLoopState&gt; body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.For(System.Int64,System.Int64,System.Action{System.Int64,System.Threading.Tasks.ParallelLoopState})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function For (fromInclusive As Long, toExclusive As Long, body As Action(Of Long, ParallelLoopState)) As ParallelLoopResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Tasks::ParallelLoopResult For(long fromInclusive, long toExclusive, Action&lt;long, System::Threading::Tasks::ParallelLoopState ^&gt; ^ body);" />
      <MemberSignature Language="F#" Value="static member For : int64 * int64 * Action&lt;int64, System.Threading.Tasks.ParallelLoopState&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.For (fromInclusive, toExclusive, body)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fromInclusive" Type="System.Int64" />
        <Parameter Name="toExclusive" Type="System.Int64" />
        <Parameter Name="body" Type="System.Action&lt;System.Int64,System.Threading.Tasks.ParallelLoopState&gt;" />
      </Parameters>
      <Docs>
        <param name="fromInclusive">Índice inicial, inclusivo.</param>
        <param name="toExclusive">Índice final, exclusivo.</param>
        <param name="body">Delegado que se invoca una vez por cada iteración.</param>
        <summary>Ejecuta un bucle <see langword="for" /> (<see langword="For" /> en Visual Basic) con índices de 64 bits en el que es posible ejecutar iteraciones en paralelo, y el estado del bucle se puede supervisar y manipular.</summary>
        <returns>Estructura <see cref="T:System.Threading.Tasks.ParallelLoopResult" /> que contiene información sobre la parte completada del bucle.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El `body` delegado se invoca una vez para cada valor en el intervalo de iteración (`fromInclusive`, `toExclusive`). Se proporciona con los siguientes parámetros: el número de iteraciones (<xref:System.Int64>) y un <xref:System.Threading.Tasks.ParallelLoopState> instancia que puede utilizarse para interrumpir el bucle prematuramente.  
  
 Una llamada a la <xref:System.Threading.Tasks.ParallelLoopState.Break%2A> informa al método el `for` operación que iteraciones después del actual no tienen que ejecutarse, pero hacer todas las iteraciones antes del actual.  
  
 Por lo tanto, llamar a Break es similar al uso de una operación de salto dentro de un convencional `for` bucle en un lenguaje como C#, pero no es un sustituto perfecto: por ejemplo, no hay ninguna garantía de que las iteraciones después actual no se ejecutará sin duda.  
  
 Si la ejecución de todas las iteraciones antes de que el actual no es necesario, use la <xref:System.Threading.Tasks.ParallelLoopState.Stop%2A> método en lugar de usar <xref:System.Threading.Tasks.ParallelLoopState.Break%2A>. Una llamada a <xref:System.Threading.Tasks.ParallelLoopState.Stop%2A> informa a la `for` bucle que puede abandonar todas las restantes iteraciones, independientemente de si antes o después de la iteración actual, dado que todos los necesarios ya se habrá cumplimentado trabajo. Sin embargo, como con <xref:System.Threading.Tasks.ParallelLoopState.Break%2A>, no hay ninguna garantía con respecto a que no se ejecutarán otras iteraciones.  
  
 Si un bucle finaliza prematuramente, el <xref:System.Threading.Tasks.ParallelLoopResult> estructura devuelta contendrá información relevante acerca de la finalización del bucle.  
  
 Si `fromInclusive` es mayor o igual que `toExclusive`, a continuación, el método devuelve inmediatamente sin realizar ninguna iteración.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El argumento <paramref name="body" /> es <see langword="null" />.</exception>
        <exception cref="T:System.AggregateException">La excepción que contiene todas las excepciones individuales producidas en todos los subprocesos.</exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)">Bucles paralelos</related>
      </Docs>
    </Member>
    <Member MemberName="For">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult For (long fromInclusive, long toExclusive, Action&lt;long&gt; body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult For(int64 fromInclusive, int64 toExclusive, class System.Action`1&lt;int64&gt; body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.For(System.Int64,System.Int64,System.Action{System.Int64})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function For (fromInclusive As Long, toExclusive As Long, body As Action(Of Long)) As ParallelLoopResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Tasks::ParallelLoopResult For(long fromInclusive, long toExclusive, Action&lt;long&gt; ^ body);" />
      <MemberSignature Language="F#" Value="static member For : int64 * int64 * Action&lt;int64&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.For (fromInclusive, toExclusive, body)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fromInclusive" Type="System.Int64" />
        <Parameter Name="toExclusive" Type="System.Int64" />
        <Parameter Name="body" Type="System.Action&lt;System.Int64&gt;" />
      </Parameters>
      <Docs>
        <param name="fromInclusive">Índice inicial, inclusivo.</param>
        <param name="toExclusive">Índice final, exclusivo.</param>
        <param name="body">Delegado que se invoca una vez por cada iteración.</param>
        <summary>Ejecuta un bucle <see langword="for" /> (<see langword="For" /> en Visual Basic) con índices 64 bits en el que se pueden ejecutar iteraciones en paralelo.</summary>
        <returns>Estructura que contiene información sobre qué parte del bucle se completó.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El `body` delegado se invoca una vez para cada valor en el intervalo de iteración (`fromInclusive`, `toExclusive`). Se proporciona con el número de iteraciones (<xref:System.Int64>) como un parámetro.  
  
 Si `fromInclusive` es mayor o igual que `toExclusive`, el método vuelve inmediatamente sin realizar ninguna iteración.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El argumento <paramref name="body" /> es <see langword="null" />.</exception>
        <exception cref="T:System.AggregateException">La excepción que contiene todas las excepciones individuales producidas en todos los subprocesos.</exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)">Bucles paralelos</related>
      </Docs>
    </Member>
    <Member MemberName="For">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult For (int fromInclusive, int toExclusive, System.Threading.Tasks.ParallelOptions parallelOptions, Action&lt;int,System.Threading.Tasks.ParallelLoopState&gt; body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult For(int32 fromInclusive, int32 toExclusive, class System.Threading.Tasks.ParallelOptions parallelOptions, class System.Action`2&lt;int32, class System.Threading.Tasks.ParallelLoopState&gt; body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.For(System.Int32,System.Int32,System.Threading.Tasks.ParallelOptions,System.Action{System.Int32,System.Threading.Tasks.ParallelLoopState})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Tasks::ParallelLoopResult For(int fromInclusive, int toExclusive, System::Threading::Tasks::ParallelOptions ^ parallelOptions, Action&lt;int, System::Threading::Tasks::ParallelLoopState ^&gt; ^ body);" />
      <MemberSignature Language="F#" Value="static member For : int * int * System.Threading.Tasks.ParallelOptions * Action&lt;int, System.Threading.Tasks.ParallelLoopState&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.For (fromInclusive, toExclusive, parallelOptions, body)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fromInclusive" Type="System.Int32" />
        <Parameter Name="toExclusive" Type="System.Int32" />
        <Parameter Name="parallelOptions" Type="System.Threading.Tasks.ParallelOptions" />
        <Parameter Name="body" Type="System.Action&lt;System.Int32,System.Threading.Tasks.ParallelLoopState&gt;" />
      </Parameters>
      <Docs>
        <param name="fromInclusive">Índice inicial, inclusivo.</param>
        <param name="toExclusive">Índice final, exclusivo.</param>
        <param name="parallelOptions">Objeto que configura el comportamiento de esta operación.</param>
        <param name="body">Delegado que se invoca una vez por cada iteración.</param>
        <summary>Ejecuta un bucle <see langword="for" /> (<see langword="For" /> en Visual Basic) donde se pueden ejecutar iteraciones en paralelo y configurar opciones de bucle y el estado del bucle se puede supervisar y manipular.</summary>
        <returns>Estructura que contiene información sobre qué parte del bucle se completó.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El `body` delegado se invoca una vez para cada valor en el intervalo de iteración (`fromInclusive`, `toExclusive`). Se proporciona con los siguientes parámetros: el número de iteraciones (<xref:System.Int32>) y un <xref:System.Threading.Tasks.ParallelLoopState> instancia que puede utilizarse para interrumpir el bucle prematuramente.  
  
 Si `fromInclusive` es mayor o igual que `toExclusive`, el método vuelve inmediatamente sin realizar ninguna iteración.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OperationCanceledException">
          <see cref="T:System.Threading.CancellationToken" /> en el argumento <paramref name="parallelOptions" /> se cancela.</exception>
        <exception cref="T:System.ArgumentNullException">El argumento <paramref name="body" /> es <see langword="null" />.  
  
O bien 
El argumento <paramref name="parallelOptions" /> es <see langword="null" />.</exception>
        <exception cref="T:System.AggregateException">La excepción que contiene todas las excepciones individuales producidas en todos los subprocesos.</exception>
        <exception cref="T:System.ObjectDisposedException">El objeto <see cref="T:System.Threading.CancellationTokenSource" /> asociado a <see cref="T:System.Threading.CancellationToken" /> en el <paramref name="parallelOptions" /> se ha desechado.</exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)">Bucles paralelos</related>
      </Docs>
    </Member>
    <Member MemberName="For">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult For (int fromInclusive, int toExclusive, System.Threading.Tasks.ParallelOptions parallelOptions, Action&lt;int&gt; body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult For(int32 fromInclusive, int32 toExclusive, class System.Threading.Tasks.ParallelOptions parallelOptions, class System.Action`1&lt;int32&gt; body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.For(System.Int32,System.Int32,System.Threading.Tasks.ParallelOptions,System.Action{System.Int32})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Tasks::ParallelLoopResult For(int fromInclusive, int toExclusive, System::Threading::Tasks::ParallelOptions ^ parallelOptions, Action&lt;int&gt; ^ body);" />
      <MemberSignature Language="F#" Value="static member For : int * int * System.Threading.Tasks.ParallelOptions * Action&lt;int&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.For (fromInclusive, toExclusive, parallelOptions, body)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fromInclusive" Type="System.Int32" />
        <Parameter Name="toExclusive" Type="System.Int32" />
        <Parameter Name="parallelOptions" Type="System.Threading.Tasks.ParallelOptions" />
        <Parameter Name="body" Type="System.Action&lt;System.Int32&gt;" />
      </Parameters>
      <Docs>
        <param name="fromInclusive">Índice inicial, inclusivo.</param>
        <param name="toExclusive">Índice final, exclusivo.</param>
        <param name="parallelOptions">Objeto que configura el comportamiento de esta operación.</param>
        <param name="body">Delegado que se invoca una vez por cada iteración.</param>
        <summary>Ejecuta un bucle <see langword="for" /> (<see langword="For" /> en Visual Basic) en el que se pueden ejecutar iteraciones en paralelo y configurar las opciones de bucle.</summary>
        <returns>Estructura que contiene información sobre qué parte del bucle se completó.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El `body` delegado se invoca una vez para cada valor en el intervalo de iteración (`fromInclusive`, `toExclusive`). Se proporciona con el número de iteraciones (<xref:System.Int32>) como un parámetro.  
  
 Si `fromInclusive` es mayor o igual que `toExclusive`, a continuación, el método devuelve inmediatamente sin realizar ninguna iteración.  
  
   
  
## Examples  
 El ejemplo siguiente muestra cómo cancelar un bucle paralelo:  
  
 [!code-csharp[System.Threading.Tasks.Parallel#05](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.parallel/cs/parallelforcancel.cs#05)]
 [!code-vb[System.Threading.Tasks.Parallel#05](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.parallel/vb/parallelforcancel.vb#05)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OperationCanceledException">
          <see cref="T:System.Threading.CancellationToken" /> en el argumento <paramref name="parallelOptions" /> se cancela.</exception>
        <exception cref="T:System.ArgumentNullException">El argumento <paramref name="body" /> es <see langword="null" />.  
  
O bien 
El argumento <paramref name="parallelOptions" /> es <see langword="null" />.</exception>
        <exception cref="T:System.AggregateException">La excepción que contiene todas las excepciones individuales producidas en todos los subprocesos.</exception>
        <exception cref="T:System.ObjectDisposedException">El objeto <see cref="T:System.Threading.CancellationTokenSource" /> asociado a <see cref="T:System.Threading.CancellationToken" /> en el <paramref name="parallelOptions" /> se ha desechado.</exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)">Bucles paralelos</related>
      </Docs>
    </Member>
    <Member MemberName="For">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult For (long fromInclusive, long toExclusive, System.Threading.Tasks.ParallelOptions parallelOptions, Action&lt;long,System.Threading.Tasks.ParallelLoopState&gt; body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult For(int64 fromInclusive, int64 toExclusive, class System.Threading.Tasks.ParallelOptions parallelOptions, class System.Action`2&lt;int64, class System.Threading.Tasks.ParallelLoopState&gt; body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.For(System.Int64,System.Int64,System.Threading.Tasks.ParallelOptions,System.Action{System.Int64,System.Threading.Tasks.ParallelLoopState})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Tasks::ParallelLoopResult For(long fromInclusive, long toExclusive, System::Threading::Tasks::ParallelOptions ^ parallelOptions, Action&lt;long, System::Threading::Tasks::ParallelLoopState ^&gt; ^ body);" />
      <MemberSignature Language="F#" Value="static member For : int64 * int64 * System.Threading.Tasks.ParallelOptions * Action&lt;int64, System.Threading.Tasks.ParallelLoopState&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.For (fromInclusive, toExclusive, parallelOptions, body)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fromInclusive" Type="System.Int64" />
        <Parameter Name="toExclusive" Type="System.Int64" />
        <Parameter Name="parallelOptions" Type="System.Threading.Tasks.ParallelOptions" />
        <Parameter Name="body" Type="System.Action&lt;System.Int64,System.Threading.Tasks.ParallelLoopState&gt;" />
      </Parameters>
      <Docs>
        <param name="fromInclusive">Índice inicial, inclusivo.</param>
        <param name="toExclusive">Índice final, exclusivo.</param>
        <param name="parallelOptions">Objeto que configura el comportamiento de esta operación.</param>
        <param name="body">Delegado que se invoca una vez por cada iteración.</param>
        <summary>Ejecuta un bucle <see langword="for" /> (<see langword="For" /> en Visual Basic) con índices de 64 bits en el que es posible ejecutar iteraciones en paralelo y configurar opciones de bucle y el estado del bucle se puede supervisar y manipular.</summary>
        <returns>Estructura que contiene información sobre qué parte del bucle se completó.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El `body` delegado se invoca una vez para cada valor en el intervalo de iteración (`fromInclusive`, `toExclusive`). Se proporciona con los siguientes parámetros: el número de iteraciones (<xref:System.Int64>) y un <xref:System.Threading.Tasks.ParallelLoopState> instancia que puede utilizarse para interrumpir el bucle prematuramente.  
  
 Si `fromInclusive` es mayor o igual que `toExclusive`, el método vuelve inmediatamente sin realizar ninguna iteración.  
  
   
  
## Examples  
 El ejemplo siguiente muestra cómo usar el <xref:System.Threading.Tasks.Parallel.For%2A?displayProperty=nameWithType> método con un <xref:System.Threading.Tasks.ParallelOptions> objeto:  
  
 [!code-csharp[System.Threading.Tasks.Parallel#03](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.parallel/cs/parallelfor.cs#03)]
 [!code-vb[System.Threading.Tasks.Parallel#03](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.parallel/vb/parallelfor.vb#03)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OperationCanceledException">
          <see cref="T:System.Threading.CancellationToken" /> en el argumento <paramref name="parallelOptions" /> se cancela.</exception>
        <exception cref="T:System.ArgumentNullException">El argumento <paramref name="body" /> es <see langword="null" />.  
  
O bien 
El argumento <paramref name="parallelOptions" /> es <see langword="null" />.</exception>
        <exception cref="T:System.AggregateException">La excepción que contiene todas las excepciones individuales producidas en todos los subprocesos.</exception>
        <exception cref="T:System.ObjectDisposedException">El objeto <see cref="T:System.Threading.CancellationTokenSource" /> asociado a <see cref="T:System.Threading.CancellationToken" /> en el <paramref name="parallelOptions" /> se ha desechado.</exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)">Bucles paralelos</related>
      </Docs>
    </Member>
    <Member MemberName="For">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult For (long fromInclusive, long toExclusive, System.Threading.Tasks.ParallelOptions parallelOptions, Action&lt;long&gt; body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult For(int64 fromInclusive, int64 toExclusive, class System.Threading.Tasks.ParallelOptions parallelOptions, class System.Action`1&lt;int64&gt; body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.For(System.Int64,System.Int64,System.Threading.Tasks.ParallelOptions,System.Action{System.Int64})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Tasks::ParallelLoopResult For(long fromInclusive, long toExclusive, System::Threading::Tasks::ParallelOptions ^ parallelOptions, Action&lt;long&gt; ^ body);" />
      <MemberSignature Language="F#" Value="static member For : int64 * int64 * System.Threading.Tasks.ParallelOptions * Action&lt;int64&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.For (fromInclusive, toExclusive, parallelOptions, body)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fromInclusive" Type="System.Int64" />
        <Parameter Name="toExclusive" Type="System.Int64" />
        <Parameter Name="parallelOptions" Type="System.Threading.Tasks.ParallelOptions" />
        <Parameter Name="body" Type="System.Action&lt;System.Int64&gt;" />
      </Parameters>
      <Docs>
        <param name="fromInclusive">Índice inicial, inclusivo.</param>
        <param name="toExclusive">Índice final, exclusivo.</param>
        <param name="parallelOptions">Objeto que configura el comportamiento de esta operación.</param>
        <param name="body">Delegado que se invoca una vez por cada iteración.</param>
        <summary>Ejecuta un bucle <see langword="for" /> (<see langword="For" /> en Visual Basic) con índices de 64 bits en el que se pueden ejecutar iteraciones en paralelo y configurar opciones de bucle.</summary>
        <returns>Estructura que contiene información sobre qué parte del bucle se completó.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Admite índices de 64 bits. El `body` delegado se invoca una vez para cada valor en el intervalo de iteración (`fromInclusive`, `toExclusive`). Se proporciona con el número de iteraciones (<xref:System.Int64>) como un parámetro.  
  
 Si `fromInclusive` es mayor o igual que `toExclusive`, a continuación, el método devuelve inmediatamente sin realizar ninguna iteración.  
  
   
  
## Examples  
 El ejemplo siguiente muestra cómo usar <xref:System.Threading.Tasks.ParallelOptions> para especificar un programador de tareas personalizado:  
  
 [!code-csharp[System.Threading.Tasks.Parallel#06](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.parallel/cs/parallelforwithscheduler.cs#06)]
 [!code-vb[System.Threading.Tasks.Parallel#06](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.parallel/vb/parallelforwithscheduler.vb#06)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OperationCanceledException">
          <see cref="T:System.Threading.CancellationToken" /> en el argumento <paramref name="parallelOptions" /> se cancela.</exception>
        <exception cref="T:System.ArgumentNullException">El argumento <paramref name="body" /> es <see langword="null" />.  
  
O bien 
El argumento <paramref name="parallelOptions" /> es <see langword="null" />.</exception>
        <exception cref="T:System.AggregateException">La excepción que contiene todas las excepciones individuales producidas en todos los subprocesos.</exception>
        <exception cref="T:System.ObjectDisposedException">El objeto <see cref="T:System.Threading.CancellationTokenSource" /> asociado a <see cref="T:System.Threading.CancellationToken" /> en el <paramref name="parallelOptions" /> se ha desechado.</exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)">Bucles paralelos</related>
      </Docs>
    </Member>
    <Member MemberName="For&lt;TLocal&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult For&lt;TLocal&gt; (int fromInclusive, int toExclusive, Func&lt;TLocal&gt; localInit, Func&lt;int,System.Threading.Tasks.ParallelLoopState,TLocal,TLocal&gt; body, Action&lt;TLocal&gt; localFinally);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult For&lt;TLocal&gt;(int32 fromInclusive, int32 toExclusive, class System.Func`1&lt;!!TLocal&gt; localInit, class System.Func`4&lt;int32, class System.Threading.Tasks.ParallelLoopState, !!TLocal, !!TLocal&gt; body, class System.Action`1&lt;!!TLocal&gt; localFinally) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.For``1(System.Int32,System.Int32,System.Func{``0},System.Func{System.Int32,System.Threading.Tasks.ParallelLoopState,``0,``0},System.Action{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function For(Of TLocal) (fromInclusive As Integer, toExclusive As Integer, localInit As Func(Of TLocal), body As Func(Of Integer, ParallelLoopState, TLocal, TLocal), localFinally As Action(Of TLocal)) As ParallelLoopResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TLocal&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult For(int fromInclusive, int toExclusive, Func&lt;TLocal&gt; ^ localInit, Func&lt;int, System::Threading::Tasks::ParallelLoopState ^, TLocal, TLocal&gt; ^ body, Action&lt;TLocal&gt; ^ localFinally);" />
      <MemberSignature Language="F#" Value="static member For : int * int * Func&lt;'Local&gt; * Func&lt;int, System.Threading.Tasks.ParallelLoopState, 'Local, 'Local&gt; * Action&lt;'Local&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.For (fromInclusive, toExclusive, localInit, body, localFinally)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TLocal" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="fromInclusive" Type="System.Int32" />
        <Parameter Name="toExclusive" Type="System.Int32" />
        <Parameter Name="localInit" Type="System.Func&lt;TLocal&gt;" />
        <Parameter Name="body" Type="System.Func&lt;System.Int32,System.Threading.Tasks.ParallelLoopState,TLocal,TLocal&gt;" />
        <Parameter Name="localFinally" Type="System.Action&lt;TLocal&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TLocal">Tipo de los datos locales de subprocesos.</typeparam>
        <param name="fromInclusive">Índice inicial, inclusivo.</param>
        <param name="toExclusive">Índice final, exclusivo.</param>
        <param name="localInit">Delegado de función que devuelve el estado inicial de los datos locales de cada tarea.</param>
        <param name="body">Delegado que se invoca una vez por cada iteración.</param>
        <param name="localFinally">Delegado que realiza una acción final en el estado local de cada tarea.</param>
        <summary>Ejecuta un bucle <see langword="for" /> (<see langword="For" /> en Visual Basic) con datos locales del subproceso en el que es posible ejecutar iteraciones en paralelo y el estado del bucle se puede supervisar y manipular.</summary>
        <returns>Estructura que contiene información sobre qué parte del bucle se completó.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El `body` delegado se invoca una vez para cada valor en el intervalo de iteración (`fromInclusive`, `toExclusive`). Se proporciona con los siguientes parámetros: el número de iteraciones (<xref:System.Int32>), un <xref:System.Threading.Tasks.ParallelLoopState> instancia que puede utilizarse para salir del bucle prematuramente y algún estado local, que se puede compartir entre las iteraciones que se ejecutan en el mismo subproceso.  
  
 El `localInit` delegado se invoca una vez para cada tarea que participa en la ejecución del bucle y devuelve el estado local inicial para cada una de esas tareas. Estos estados iniciales se pasan a la primera `body` las invocaciones de cada tarea. A continuación, cada invocación de cuerpo subsiguiente devuelve un valor de estado posiblemente modificado que se pasa a la siguiente invocación de cuerpo. Por último, la última invocación de cuerpo en cada tarea devuelve un valor de estado que se pasa a la `localFinally` delegar. El `localFinally` delegado se invoca una vez por cada tarea para realizar una acción final en el estado local de cada tarea. Este delegado se podría invocar simultáneamente en varias tareas; por lo tanto, se debe sincronizar el acceso a cualquier variable compartida.  
  
 El <xref:System.Threading.Tasks.Parallel.For%2A?displayProperty=nameWithType> método puede usar más tareas que los subprocesos durante la vigencia de su ejecución, como las tareas existentes completadas y se reemplazan con nuevas tareas. Esto proporciona subyacente <xref:System.Threading.Tasks.TaskScheduler> objeto la oportunidad de agregar, cambiar o quitar los subprocesos que dan servicio el bucle.  
  
 Si `fromInclusive` es mayor o igual que `toExclusive`, a continuación, el método devuelve inmediatamente sin realizar ninguna iteración.  
  
 Para obtener un ejemplo que usa este método, consulte [Cómo: escribir un bucle Parallel.For con Variables locales de subproceso](~/docs/standard/parallel-programming/how-to-write-a-parallel-for-loop-with-thread-local-variables.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El argumento <paramref name="body" /> es <see langword="null" />.  
  
O bien 
El argumento <paramref name="localInit" /> es <see langword="null" />.  
  
O bien 
El argumento <paramref name="localFinally" /> es <see langword="null" />.</exception>
        <exception cref="T:System.AggregateException">La excepción que contiene todas las excepciones individuales producidas en todos los subprocesos.</exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)">Bucles paralelos</related>
      </Docs>
    </Member>
    <Member MemberName="For&lt;TLocal&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult For&lt;TLocal&gt; (long fromInclusive, long toExclusive, Func&lt;TLocal&gt; localInit, Func&lt;long,System.Threading.Tasks.ParallelLoopState,TLocal,TLocal&gt; body, Action&lt;TLocal&gt; localFinally);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult For&lt;TLocal&gt;(int64 fromInclusive, int64 toExclusive, class System.Func`1&lt;!!TLocal&gt; localInit, class System.Func`4&lt;int64, class System.Threading.Tasks.ParallelLoopState, !!TLocal, !!TLocal&gt; body, class System.Action`1&lt;!!TLocal&gt; localFinally) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.For``1(System.Int64,System.Int64,System.Func{``0},System.Func{System.Int64,System.Threading.Tasks.ParallelLoopState,``0,``0},System.Action{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function For(Of TLocal) (fromInclusive As Long, toExclusive As Long, localInit As Func(Of TLocal), body As Func(Of Long, ParallelLoopState, TLocal, TLocal), localFinally As Action(Of TLocal)) As ParallelLoopResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TLocal&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult For(long fromInclusive, long toExclusive, Func&lt;TLocal&gt; ^ localInit, Func&lt;long, System::Threading::Tasks::ParallelLoopState ^, TLocal, TLocal&gt; ^ body, Action&lt;TLocal&gt; ^ localFinally);" />
      <MemberSignature Language="F#" Value="static member For : int64 * int64 * Func&lt;'Local&gt; * Func&lt;int64, System.Threading.Tasks.ParallelLoopState, 'Local, 'Local&gt; * Action&lt;'Local&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.For (fromInclusive, toExclusive, localInit, body, localFinally)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TLocal" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="fromInclusive" Type="System.Int64" />
        <Parameter Name="toExclusive" Type="System.Int64" />
        <Parameter Name="localInit" Type="System.Func&lt;TLocal&gt;" />
        <Parameter Name="body" Type="System.Func&lt;System.Int64,System.Threading.Tasks.ParallelLoopState,TLocal,TLocal&gt;" />
        <Parameter Name="localFinally" Type="System.Action&lt;TLocal&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TLocal">Tipo de los datos locales de subprocesos.</typeparam>
        <param name="fromInclusive">Índice inicial, inclusivo.</param>
        <param name="toExclusive">Índice final, exclusivo.</param>
        <param name="localInit">Delegado de función que devuelve el estado inicial de los datos locales de cada tarea.</param>
        <param name="body">Delegado que se invoca una vez por cada iteración.</param>
        <param name="localFinally">Delegado que realiza una acción final en el estado local de cada tarea.</param>
        <summary>Ejecuta un bucle <see langword="for" /> (<see langword="For" /> en Visual Basic) con índices de 64 bits y datos locales del subproceso en el que es posible ejecutar iteraciones en paralelo y el estado del bucle se puede supervisar y manipular.</summary>
        <returns>Estructura que contiene información sobre qué parte del bucle se completó.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El `body` delegado se invoca una vez para cada valor en el intervalo de iteración (`fromInclusive`, `toExclusive`). Se proporciona con los siguientes parámetros: el número de iteraciones (<xref:System.Int64>), un <xref:System.Threading.Tasks.ParallelLoopState> instancia que puede utilizarse para salir del bucle prematuramente y algún estado local, que se puede compartir entre las iteraciones que se ejecutan en la misma tarea.  
  
 El `localInit` delegado se invoca una vez para cada tarea que participa en la ejecución del bucle y devuelve el estado local inicial para cada una de esas tareas. Estos estados iniciales se pasan a la primera `body` las invocaciones de cada tarea. A continuación, cada invocación de cuerpo subsiguiente devuelve un valor de estado posiblemente modificado que se pasa a la siguiente invocación de cuerpo. Por último, la última invocación de cuerpo en cada tarea devuelve un valor de estado que se pasa a la `localFinally` delegar. El `localFinally` delegado se invoca una vez por cada tarea para realizar una acción final en el estado local de cada tarea. Este delegado se podría invocar simultáneamente en varias tareas; por lo tanto, se debe sincronizar el acceso a cualquier variable compartida.  
  
 El <xref:System.Threading.Tasks.Parallel.For%2A?displayProperty=nameWithType> método puede usar más tareas que los subprocesos durante la vigencia de su ejecución, como las tareas existentes completadas y se reemplazan con nuevas tareas. Esto proporciona subyacente <xref:System.Threading.Tasks.TaskScheduler> objeto la oportunidad de agregar, cambiar o quitar los subprocesos que dan servicio el bucle.  
  
 Si `fromInclusive` es mayor o igual que `toExclusive`, a continuación, el método devuelve inmediatamente sin realizar ninguna iteración.  
  
 Para obtener un ejemplo que usa este método, consulte [Cómo: escribir un bucle Parallel.For con Variables locales de subproceso](~/docs/standard/parallel-programming/how-to-write-a-parallel-for-loop-with-thread-local-variables.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El argumento <paramref name="body" /> es <see langword="null" />.  
  
O bien 
El argumento <paramref name="localInit" /> es <see langword="null" />.  
  
O bien 
El argumento <paramref name="localFinally" /> es <see langword="null" />.</exception>
        <exception cref="T:System.AggregateException">La excepción que contiene todas las excepciones individuales producidas en todos los subprocesos.</exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)">Bucles paralelos</related>
      </Docs>
    </Member>
    <Member MemberName="For&lt;TLocal&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult For&lt;TLocal&gt; (int fromInclusive, int toExclusive, System.Threading.Tasks.ParallelOptions parallelOptions, Func&lt;TLocal&gt; localInit, Func&lt;int,System.Threading.Tasks.ParallelLoopState,TLocal,TLocal&gt; body, Action&lt;TLocal&gt; localFinally);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult For&lt;TLocal&gt;(int32 fromInclusive, int32 toExclusive, class System.Threading.Tasks.ParallelOptions parallelOptions, class System.Func`1&lt;!!TLocal&gt; localInit, class System.Func`4&lt;int32, class System.Threading.Tasks.ParallelLoopState, !!TLocal, !!TLocal&gt; body, class System.Action`1&lt;!!TLocal&gt; localFinally) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.For``1(System.Int32,System.Int32,System.Threading.Tasks.ParallelOptions,System.Func{``0},System.Func{System.Int32,System.Threading.Tasks.ParallelLoopState,``0,``0},System.Action{``0})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TLocal&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult For(int fromInclusive, int toExclusive, System::Threading::Tasks::ParallelOptions ^ parallelOptions, Func&lt;TLocal&gt; ^ localInit, Func&lt;int, System::Threading::Tasks::ParallelLoopState ^, TLocal, TLocal&gt; ^ body, Action&lt;TLocal&gt; ^ localFinally);" />
      <MemberSignature Language="F#" Value="static member For : int * int * System.Threading.Tasks.ParallelOptions * Func&lt;'Local&gt; * Func&lt;int, System.Threading.Tasks.ParallelLoopState, 'Local, 'Local&gt; * Action&lt;'Local&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.For (fromInclusive, toExclusive, parallelOptions, localInit, body, localFinally)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TLocal" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="fromInclusive" Type="System.Int32" />
        <Parameter Name="toExclusive" Type="System.Int32" />
        <Parameter Name="parallelOptions" Type="System.Threading.Tasks.ParallelOptions" />
        <Parameter Name="localInit" Type="System.Func&lt;TLocal&gt;" />
        <Parameter Name="body" Type="System.Func&lt;System.Int32,System.Threading.Tasks.ParallelLoopState,TLocal,TLocal&gt;" />
        <Parameter Name="localFinally" Type="System.Action&lt;TLocal&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TLocal">Tipo de los datos locales de subprocesos.</typeparam>
        <param name="fromInclusive">Índice inicial, inclusivo.</param>
        <param name="toExclusive">Índice final, exclusivo.</param>
        <param name="parallelOptions">Objeto que configura el comportamiento de esta operación.</param>
        <param name="localInit">Delegado de función que devuelve el estado inicial de los datos locales de cada tarea.</param>
        <param name="body">Delegado que se invoca una vez por cada iteración.</param>
        <param name="localFinally">Delegado que realiza una acción final en el estado local de cada tarea.</param>
        <summary>Ejecuta un bucle <see langword="for" /> (<see langword="For" /> en Visual Basic) con datos locales del subproceso en el que es posible ejecutar iteraciones en paralelo, se pueden configurar opciones de bucle y el estado del bucle se puede supervisar y manipular.</summary>
        <returns>Estructura que contiene información sobre qué parte del bucle se completó.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El `body` delegado se invoca una vez para cada valor en el intervalo de iteración (`fromInclusive`, `toExclusive`). Se proporciona con los siguientes parámetros: el número de iteraciones (<xref:System.Int32>), un <xref:System.Threading.Tasks.ParallelLoopState> instancia que puede utilizarse para salir del bucle prematuramente y algún estado local, que se puede compartir entre las iteraciones que se ejecutan en la misma tarea.  
  
 El `localInit` delegado se invoca una vez para cada tarea que participa en la ejecución del bucle y devuelve el estado local inicial para cada una de esas tareas. Estos estados iniciales se pasan a la primera `body` las invocaciones de cada tarea. A continuación, cada invocación de cuerpo subsiguiente devuelve un valor de estado posiblemente modificado que se pasa a la siguiente invocación de cuerpo. Por último, la última invocación de cuerpo en cada tarea devuelve un valor de estado que se pasa a la `localFinally` delegar. El `localFinally` delegado se invoca una vez por cada tarea para realizar una acción final en el estado local de cada tarea. Este delegado se puede invocar simultáneamente en varios subprocesos; por lo tanto, se debe sincronizar el acceso a cualquier variable compartida.  
  
 El <xref:System.Threading.Tasks.Parallel.For%2A?displayProperty=nameWithType> método puede usar más tareas que los subprocesos durante la vigencia de su ejecución, como las tareas existentes completadas y se reemplazan con nuevas tareas. Esto proporciona subyacente <xref:System.Threading.Tasks.TaskScheduler> objeto la oportunidad de agregar, cambiar o quitar los subprocesos que dan servicio el bucle.  
  
 Si `fromInclusive` es mayor o igual que `toExclusive`, a continuación, el método devuelve inmediatamente sin realizar ninguna iteración.  
  
   
  
## Examples  
 El ejemplo siguiente utiliza variables locales de subproceso para calcular la suma de los resultados de muchas operaciones largas. Este ejemplo limita el grado de paralelismo a cuatro.  
  
 [!code-csharp[System.Threading.Tasks.Parallel#04](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.parallel/cs/threadlocalforwithoptions.cs#04)]
 [!code-vb[System.Threading.Tasks.Parallel#04](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.parallel/vb/threadlocalforwithoptions.vb#04)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El argumento <paramref name="body" /> es <see langword="null" />.  
  
O bien 
El argumento <paramref name="localInit" /> es <see langword="null" />.  
  
O bien 
El argumento <paramref name="localFinally" /> es <see langword="null" />.  
  
O bien 
El argumento <paramref name="parallelOptions" /> es <see langword="null" />.</exception>
        <exception cref="T:System.OperationCanceledException">
          <see cref="T:System.Threading.CancellationToken" /> en el argumento <paramref name="parallelOptions" /> se cancela.</exception>
        <exception cref="T:System.ObjectDisposedException">El objeto <see cref="T:System.Threading.CancellationTokenSource" /> asociado a <see cref="T:System.Threading.CancellationToken" /> en el <paramref name="parallelOptions" /> se ha desechado.</exception>
        <exception cref="T:System.AggregateException">La excepción que contiene todas las excepciones individuales producidas en todos los subprocesos.</exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)">Bucles paralelos</related>
      </Docs>
    </Member>
    <Member MemberName="For&lt;TLocal&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult For&lt;TLocal&gt; (long fromInclusive, long toExclusive, System.Threading.Tasks.ParallelOptions parallelOptions, Func&lt;TLocal&gt; localInit, Func&lt;long,System.Threading.Tasks.ParallelLoopState,TLocal,TLocal&gt; body, Action&lt;TLocal&gt; localFinally);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult For&lt;TLocal&gt;(int64 fromInclusive, int64 toExclusive, class System.Threading.Tasks.ParallelOptions parallelOptions, class System.Func`1&lt;!!TLocal&gt; localInit, class System.Func`4&lt;int64, class System.Threading.Tasks.ParallelLoopState, !!TLocal, !!TLocal&gt; body, class System.Action`1&lt;!!TLocal&gt; localFinally) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.For``1(System.Int64,System.Int64,System.Threading.Tasks.ParallelOptions,System.Func{``0},System.Func{System.Int64,System.Threading.Tasks.ParallelLoopState,``0,``0},System.Action{``0})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TLocal&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult For(long fromInclusive, long toExclusive, System::Threading::Tasks::ParallelOptions ^ parallelOptions, Func&lt;TLocal&gt; ^ localInit, Func&lt;long, System::Threading::Tasks::ParallelLoopState ^, TLocal, TLocal&gt; ^ body, Action&lt;TLocal&gt; ^ localFinally);" />
      <MemberSignature Language="F#" Value="static member For : int64 * int64 * System.Threading.Tasks.ParallelOptions * Func&lt;'Local&gt; * Func&lt;int64, System.Threading.Tasks.ParallelLoopState, 'Local, 'Local&gt; * Action&lt;'Local&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.For (fromInclusive, toExclusive, parallelOptions, localInit, body, localFinally)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TLocal" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="fromInclusive" Type="System.Int64" />
        <Parameter Name="toExclusive" Type="System.Int64" />
        <Parameter Name="parallelOptions" Type="System.Threading.Tasks.ParallelOptions" />
        <Parameter Name="localInit" Type="System.Func&lt;TLocal&gt;" />
        <Parameter Name="body" Type="System.Func&lt;System.Int64,System.Threading.Tasks.ParallelLoopState,TLocal,TLocal&gt;" />
        <Parameter Name="localFinally" Type="System.Action&lt;TLocal&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TLocal">Tipo de los datos locales de subprocesos.</typeparam>
        <param name="fromInclusive">Índice inicial, inclusivo.</param>
        <param name="toExclusive">Índice final, exclusivo.</param>
        <param name="parallelOptions">Objeto que configura el comportamiento de esta operación.</param>
        <param name="localInit">Delegado de función que devuelve el estado inicial de los datos locales de cada subproceso.</param>
        <param name="body">Delegado que se invoca una vez por cada iteración.</param>
        <param name="localFinally">Delegado que realiza una acción final en el estado local de cada subproceso.</param>
        <summary>Ejecuta un bucle <see langword="for" /> (<see langword="For" /> en Visual Basic) con índices de 64 bits y datos locales del subproceso en el que es posible ejecutar iteraciones en paralelo, se pueden configurar opciones de bucle y el estado del bucle se puede supervisar y manipular.</summary>
        <returns>Estructura que contiene información sobre qué parte del bucle se completó.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El `body` delegado se invoca una vez para cada valor en el intervalo de iteración (`fromInclusive`, `toExclusive`). Se proporciona con los siguientes parámetros: el número de iteraciones (<xref:System.Int64>), un <xref:System.Threading.Tasks.ParallelLoopState> instancia que puede utilizarse para salir del bucle prematuramente y algún estado local, que se puede compartir entre las iteraciones que se ejecutan en el mismo subproceso.  
  
 El `localInit` delegado se invoca una vez para cada subproceso que participa en la ejecución del bucle y devuelve el estado local inicial para cada uno de esos subprocesos. Estos estados iniciales se pasan a la primera `body` invocaciones en cada subproceso. A continuación, cada invocación de cuerpo subsiguiente devuelve un valor de estado posiblemente modificado que se pasa a la siguiente invocación de cuerpo. Por último, la última invocación de cuerpo en cada subproceso devuelve un valor de estado que se pasa a la `localFinally` delegar. El `localFinally` delegado se invoca una vez por subproceso para realizar una acción final en el estado local de cada subproceso. Este delegado se puede invocar simultáneamente en varios subprocesos; por lo tanto, se debe sincronizar el acceso a cualquier variable compartida.  
  
 El <xref:System.Threading.Tasks.Parallel.For%2A?displayProperty=nameWithType> método puede usar más tareas que los subprocesos durante la vigencia de su ejecución, como las tareas existentes completadas y se reemplazan con nuevas tareas. Esto proporciona subyacente <xref:System.Threading.Tasks.TaskScheduler> objeto la oportunidad de agregar, cambiar o quitar los subprocesos que dan servicio el bucle.  
  
 Si `fromInclusive` es mayor o igual que `toExclusive`, a continuación, el método devuelve inmediatamente sin realizar ninguna iteración.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El argumento <paramref name="body" /> es <see langword="null" />.  
  
O bien 
El argumento <paramref name="localInit" /> es <see langword="null" />.  
  
O bien 
El argumento <paramref name="localFinally" /> es <see langword="null" />.  
  
O bien 
El argumento <paramref name="parallelOptions" /> es <see langword="null" />.</exception>
        <exception cref="T:System.OperationCanceledException">
          <see cref="T:System.Threading.CancellationToken" /> en el argumento <paramref name="parallelOptions" /> se cancela.</exception>
        <exception cref="T:System.ObjectDisposedException">El objeto <see cref="T:System.Threading.CancellationTokenSource" /> asociado a <see cref="T:System.Threading.CancellationToken" /> en el <paramref name="parallelOptions" /> se ha desechado.</exception>
        <exception cref="T:System.AggregateException">La excepción que contiene todas las excepciones individuales producidas en todos los subprocesos.</exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)">Bucles paralelos</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="ForEach&lt;TSource&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Ejecuta una operación <see langword="foreach" /> (<see langword="For Each " /> en Visual Basic) en la que es posible ejecutar iteraciones en paralelo.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ForEach&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt; (System.Collections.Concurrent.OrderablePartitioner&lt;TSource&gt; source, Action&lt;TSource,System.Threading.Tasks.ParallelLoopState,long&gt; body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt;(class System.Collections.Concurrent.OrderablePartitioner`1&lt;!!TSource&gt; source, class System.Action`3&lt;!!TSource, class System.Threading.Tasks.ParallelLoopState, int64&gt; body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.ForEach``1(System.Collections.Concurrent.OrderablePartitioner{``0},System.Action{``0,System.Threading.Tasks.ParallelLoopState,System.Int64})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ForEach(Of TSource) (source As OrderablePartitioner(Of TSource), body As Action(Of TSource, ParallelLoopState, Long)) As ParallelLoopResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult ForEach(System::Collections::Concurrent::OrderablePartitioner&lt;TSource&gt; ^ source, Action&lt;TSource, System::Threading::Tasks::ParallelLoopState ^, long&gt; ^ body);" />
      <MemberSignature Language="F#" Value="static member ForEach : System.Collections.Concurrent.OrderablePartitioner&lt;'Source&gt; * Action&lt;'Source, System.Threading.Tasks.ParallelLoopState, int64&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.ForEach (source, body)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Concurrent.OrderablePartitioner&lt;TSource&gt;" />
        <Parameter Name="body" Type="System.Action&lt;TSource,System.Threading.Tasks.ParallelLoopState,System.Int64&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Tipo de los elementos de <paramref name="source" />.</typeparam>
        <param name="source">Particionador ordenable que contiene el origen de datos original.</param>
        <param name="body">Delegado que se invoca una vez por cada iteración.</param>
        <summary>Ejecuta una operación <see langword="foreach" /> (<see langword="For Each" /> en Visual Basic) en <see cref="T:System.Collections.Concurrent.OrderablePartitioner`1" /> donde se pueden ejecutar iteraciones en paralelo, y el estado del bucle se puede supervisar y manipular.</summary>
        <returns>Estructura que contiene información sobre qué parte del bucle se completó.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esta sobrecarga se proporciona para escenarios donde desea invalidar el valor predeterminado de esquema de partición. Por ejemplo, cuerpos de bucle pequeños podrían beneficiarse del particionamiento del intervalo. El <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> método espera particionadores personalizados para admitir la creación de particiones dinámica. Para obtener más información, consulte [particionadores personalizados para PLINQ y TPL](~/docs/standard/parallel-programming/custom-partitioners-for-plinq-and-tpl.md) y [Cómo: implementar las particiones dinámicas](~/docs/standard/parallel-programming/how-to-implement-dynamic-partitions.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El argumento <paramref name="source" /> es <see langword="null" />.  
  
O bien 
El argumento <paramref name="body" /> es <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">La propiedad <see cref="P:System.Collections.Concurrent.Partitioner`1.SupportsDynamicPartitions" /> del particionador ordenable <paramref name="source" /> devuelve <see langword="false" />.  
  
O bien 
La propiedad <see cref="P:System.Collections.Concurrent.OrderablePartitioner`1.KeysNormalized" /> del particionador ordenable de origen devuelve <see langword="false" />.  
  
O bien 
Cualquier método en el particionador ordenable de origen devuelve <see langword="null" />.</exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)">Bucles paralelos</related>
      </Docs>
    </Member>
    <Member MemberName="ForEach&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt; (System.Collections.Concurrent.Partitioner&lt;TSource&gt; source, Action&lt;TSource,System.Threading.Tasks.ParallelLoopState&gt; body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt;(class System.Collections.Concurrent.Partitioner`1&lt;!!TSource&gt; source, class System.Action`2&lt;!!TSource, class System.Threading.Tasks.ParallelLoopState&gt; body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.ForEach``1(System.Collections.Concurrent.Partitioner{``0},System.Action{``0,System.Threading.Tasks.ParallelLoopState})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ForEach(Of TSource) (source As Partitioner(Of TSource), body As Action(Of TSource, ParallelLoopState)) As ParallelLoopResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult ForEach(System::Collections::Concurrent::Partitioner&lt;TSource&gt; ^ source, Action&lt;TSource, System::Threading::Tasks::ParallelLoopState ^&gt; ^ body);" />
      <MemberSignature Language="F#" Value="static member ForEach : System.Collections.Concurrent.Partitioner&lt;'Source&gt; * Action&lt;'Source, System.Threading.Tasks.ParallelLoopState&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.ForEach (source, body)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Concurrent.Partitioner&lt;TSource&gt;" />
        <Parameter Name="body" Type="System.Action&lt;TSource,System.Threading.Tasks.ParallelLoopState&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Tipo de los elementos de <paramref name="source" />.</typeparam>
        <param name="source">Particionador que contiene el origen de datos original.</param>
        <param name="body">Delegado que se invoca una vez por cada iteración.</param>
        <summary>Ejecuta una operación <see langword="foreach" /> (<see langword="For Each" /> en Visual Basic) en <see cref="T:System.Collections.Concurrent.Partitioner" /> donde se pueden ejecutar iteraciones en paralelo, y el estado del bucle se puede supervisar y manipular.</summary>
        <returns>Estructura que contiene información sobre qué parte del bucle se completó.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esta sobrecarga se proporciona para escenarios donde desea invalidar el valor predeterminado de esquema de partición. Por ejemplo, cuerpos de bucle pequeños podrían beneficiarse del particionamiento del intervalo. El <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> método espera particionadores personalizados para admitir la creación de particiones dinámica. Para obtener más información, consulte [particionadores personalizados para PLINQ y TPL](~/docs/standard/parallel-programming/custom-partitioners-for-plinq-and-tpl.md) y [Cómo: implementar las particiones dinámicas](~/docs/standard/parallel-programming/how-to-implement-dynamic-partitions.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El argumento <paramref name="source" /> es <see langword="null" />.  
  
O bien 
El argumento <paramref name="body" /> es <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">La propiedad <see cref="P:System.Collections.Concurrent.Partitioner`1.SupportsDynamicPartitions" /> del particionador <paramref name="source" /> devuelve <see langword="false" />.  
  
O bien 
Un método del particionador <paramref name="source" /> devuelve <see langword="null" />.  
  
O bien 
El método <see cref="M:System.Collections.Concurrent.Partitioner`1.GetPartitions(System.Int32)" /> del particionador <paramref name="source" /> no devuelve el número correcto de particiones.</exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)">Bucles paralelos</related>
      </Docs>
    </Member>
    <Member MemberName="ForEach&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt; (System.Collections.Concurrent.Partitioner&lt;TSource&gt; source, Action&lt;TSource&gt; body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt;(class System.Collections.Concurrent.Partitioner`1&lt;!!TSource&gt; source, class System.Action`1&lt;!!TSource&gt; body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.ForEach``1(System.Collections.Concurrent.Partitioner{``0},System.Action{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ForEach(Of TSource) (source As Partitioner(Of TSource), body As Action(Of TSource)) As ParallelLoopResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult ForEach(System::Collections::Concurrent::Partitioner&lt;TSource&gt; ^ source, Action&lt;TSource&gt; ^ body);" />
      <MemberSignature Language="F#" Value="static member ForEach : System.Collections.Concurrent.Partitioner&lt;'Source&gt; * Action&lt;'Source&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.ForEach (source, body)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Concurrent.Partitioner&lt;TSource&gt;" />
        <Parameter Name="body" Type="System.Action&lt;TSource&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Tipo de los elementos de <paramref name="source" />.</typeparam>
        <param name="source">Particionador que contiene el origen de datos original.</param>
        <param name="body">Delegado que se invoca una vez por cada iteración.</param>
        <summary>Ejecuta una operación <see langword="foreach" /> (<see langword="For Each" /> en Visual Basic) en <see cref="T:System.Collections.Concurrent.Partitioner" />, en la que es posible ejecutar iteraciones en paralelo.</summary>
        <returns>Estructura que contiene información sobre qué parte del bucle se completó.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esta sobrecarga se proporciona para escenarios donde desea invalidar el valor predeterminado de esquema de partición. Por ejemplo, cuerpos de bucle pequeños podrían beneficiarse del particionamiento del intervalo. El <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> método espera particionadores personalizados para admitir la creación de particiones dinámica. Para obtener más información, consulte [particionadores personalizados para PLINQ y TPL](~/docs/standard/parallel-programming/custom-partitioners-for-plinq-and-tpl.md) y [Cómo: implementar las particiones dinámicas](~/docs/standard/parallel-programming/how-to-implement-dynamic-partitions.md).  
  
   
  
## Examples  
 El ejemplo siguiente muestra cómo implementar un particionador de rango para su uso con <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType>:  
  
 [!code-csharp[System.Threading.Tasks.Parallel_RangePartitioners#01](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.parallel_rangepartitioners/cs/rangepartitioner.cs#01)]
 [!code-vb[System.Threading.Tasks.Parallel_RangePartitioners#01](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.parallel_rangepartitioners/vb/rangepart.vb#01)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El argumento <paramref name="source" /> es <see langword="null" />.  
  
O bien 
El argumento <paramref name="body" /> es <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">La propiedad <see cref="P:System.Collections.Concurrent.Partitioner`1.SupportsDynamicPartitions" /> del particionador <paramref name="source" /> devuelve <see langword="false" />.  
  
O bien 
La excepción que se produce cuando cualquier método del particionador <paramref name="source" /> devuelve <see langword="null" />.  
  
O bien 
El método <see cref="M:System.Collections.Concurrent.Partitioner`1.GetPartitions(System.Int32)" /> del particionador <paramref name="source" /> no devuelve el número correcto de particiones.</exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)">Bucles paralelos</related>
      </Docs>
    </Member>
    <Member MemberName="ForEach&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt; (System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Action&lt;TSource,System.Threading.Tasks.ParallelLoopState,long&gt; body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Action`3&lt;!!TSource, class System.Threading.Tasks.ParallelLoopState, int64&gt; body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.ForEach``1(System.Collections.Generic.IEnumerable{``0},System.Action{``0,System.Threading.Tasks.ParallelLoopState,System.Int64})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ForEach(Of TSource) (source As IEnumerable(Of TSource), body As Action(Of TSource, ParallelLoopState, Long)) As ParallelLoopResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult ForEach(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, Action&lt;TSource, System::Threading::Tasks::ParallelLoopState ^, long&gt; ^ body);" />
      <MemberSignature Language="F#" Value="static member ForEach : seq&lt;'Source&gt; * Action&lt;'Source, System.Threading.Tasks.ParallelLoopState, int64&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.ForEach (source, body)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" />
        <Parameter Name="body" Type="System.Action&lt;TSource,System.Threading.Tasks.ParallelLoopState,System.Int64&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Tipo de los datos del origen.</typeparam>
        <param name="source">Origen de datos enumerable.</param>
        <param name="body">Delegado que se invoca una vez por cada iteración.</param>
        <summary>Ejecuta una operación <see langword="foreach" /> (<see langword="For Each" /> en Visual Basic) con índices de 64 bits en <see cref="T:System.Collections.IEnumerable" /> donde se pueden ejecutar iteraciones en paralelo, y el estado del bucle se puede supervisar y manipular.</summary>
        <returns>Estructura que contiene información sobre qué parte del bucle se completó.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El `body` delegado se invoca una vez para cada elemento de la `source` enumerable. Se proporciona con los siguientes parámetros: el elemento actual, un <xref:System.Threading.Tasks.ParallelLoopState> instancia que puede utilizarse para salir del bucle prematuramente y el índice del elemento actual (<xref:System.Int64>).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El argumento <paramref name="source" /> es <see langword="null" />.  
  
O bien 
El argumento <paramref name="body" /> es <see langword="null" />.</exception>
        <exception cref="T:System.AggregateException">La excepción que contiene todas las excepciones individuales producidas en todos los subprocesos.</exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)">Bucles paralelos</related>
      </Docs>
    </Member>
    <Member MemberName="ForEach&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt; (System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Action&lt;TSource,System.Threading.Tasks.ParallelLoopState&gt; body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Action`2&lt;!!TSource, class System.Threading.Tasks.ParallelLoopState&gt; body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.ForEach``1(System.Collections.Generic.IEnumerable{``0},System.Action{``0,System.Threading.Tasks.ParallelLoopState})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ForEach(Of TSource) (source As IEnumerable(Of TSource), body As Action(Of TSource, ParallelLoopState)) As ParallelLoopResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult ForEach(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, Action&lt;TSource, System::Threading::Tasks::ParallelLoopState ^&gt; ^ body);" />
      <MemberSignature Language="F#" Value="static member ForEach : seq&lt;'Source&gt; * Action&lt;'Source, System.Threading.Tasks.ParallelLoopState&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.ForEach (source, body)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" />
        <Parameter Name="body" Type="System.Action&lt;TSource,System.Threading.Tasks.ParallelLoopState&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Tipo de los datos del origen.</typeparam>
        <param name="source">Origen de datos enumerable.</param>
        <param name="body">Delegado que se invoca una vez por cada iteración.</param>
        <summary>Ejecuta una operación <see langword="foreach" /> (<see langword="For Each" /> en Visual Basic) en <see cref="T:System.Collections.IEnumerable" /> donde se pueden ejecutar iteraciones en paralelo, y el estado del bucle se puede supervisar y manipular.</summary>
        <returns>Estructura que contiene información sobre qué parte del bucle se completó.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El `body` delegado se invoca una vez para cada elemento de la `source` enumerable. Se proporciona con los siguientes parámetros: el elemento actual y un <xref:System.Threading.Tasks.ParallelLoopState> instancia que puede utilizarse para interrumpir el bucle prematuramente.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El argumento <paramref name="source" /> es <see langword="null" />.  
  
O bien 
El argumento <paramref name="body" /> es <see langword="null" />.</exception>
        <exception cref="T:System.AggregateException">La excepción que contiene todas las excepciones individuales producidas en todos los subprocesos.</exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)">Bucles paralelos</related>
      </Docs>
    </Member>
    <Member MemberName="ForEach&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt; (System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Action&lt;TSource&gt; body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Action`1&lt;!!TSource&gt; body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.ForEach``1(System.Collections.Generic.IEnumerable{``0},System.Action{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ForEach(Of TSource) (source As IEnumerable(Of TSource), body As Action(Of TSource)) As ParallelLoopResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult ForEach(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, Action&lt;TSource&gt; ^ body);" />
      <MemberSignature Language="F#" Value="static member ForEach : seq&lt;'Source&gt; * Action&lt;'Source&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.ForEach (source, body)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" />
        <Parameter Name="body" Type="System.Action&lt;TSource&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Tipo de los datos del origen.</typeparam>
        <param name="source">Origen de datos enumerable.</param>
        <param name="body">Delegado que se invoca una vez por cada iteración.</param>
        <summary>Ejecuta una operación <see langword="foreach" /> (<see langword="For Each" /> en Visual Basic) en <see cref="T:System.Collections.IEnumerable" />, en la que es posible ejecutar iteraciones en paralelo.</summary>
        <returns>Estructura que contiene información sobre qué parte del bucle se completó.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El `body` delegado se invoca una vez para cada elemento de la `source` enumerable. Se proporciona con el elemento actual como un parámetro.  
  
   
  
## Examples  
 En el ejemplo siguiente se usa el <xref:System.Threading.Tasks.Parallel.ForEach%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Action%7B%60%600%7D%29> método para contar el número de caracteres que no sea un espacio en blanco en un archivo de texto y de las vocales. En este caso, el <xref:System.Threading.Tasks.ParallelLoopResult> se omite el valor devuelto por el método. Tenga en cuenta que, dado que las operaciones se pueden ejecutar en paralelo, debe asegurarse de que incrementar las variables de contador es una operación atómica, y que varios subprocesos no intentan acceder a las variables de contador simultáneamente. Para este propósito, el ejemplo se usa el `lock` instrucción (en C#) y el `SyncLock` instrucción (en Visual Basic).  
  
 [!code-csharp[System.Threading.Tasks.Parallel.ForEach#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.parallel.foreach/cs/foreach1.cs#1)]
 [!code-vb[System.Threading.Tasks.Parallel.ForEach#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.parallel.foreach/vb/foreach1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El argumento <paramref name="source" /> es <see langword="null" />.  
  
O bien 
El argumento <paramref name="body" /> es <see langword="null" />.</exception>
        <exception cref="T:System.AggregateException">La excepción que contiene todas las excepciones individuales producidas en todos los subprocesos.</exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)">Bucles paralelos</related>
      </Docs>
    </Member>
    <Member MemberName="ForEach&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt; (System.Collections.Concurrent.OrderablePartitioner&lt;TSource&gt; source, System.Threading.Tasks.ParallelOptions parallelOptions, Action&lt;TSource,System.Threading.Tasks.ParallelLoopState,long&gt; body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt;(class System.Collections.Concurrent.OrderablePartitioner`1&lt;!!TSource&gt; source, class System.Threading.Tasks.ParallelOptions parallelOptions, class System.Action`3&lt;!!TSource, class System.Threading.Tasks.ParallelLoopState, int64&gt; body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.ForEach``1(System.Collections.Concurrent.OrderablePartitioner{``0},System.Threading.Tasks.ParallelOptions,System.Action{``0,System.Threading.Tasks.ParallelLoopState,System.Int64})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult ForEach(System::Collections::Concurrent::OrderablePartitioner&lt;TSource&gt; ^ source, System::Threading::Tasks::ParallelOptions ^ parallelOptions, Action&lt;TSource, System::Threading::Tasks::ParallelLoopState ^, long&gt; ^ body);" />
      <MemberSignature Language="F#" Value="static member ForEach : System.Collections.Concurrent.OrderablePartitioner&lt;'Source&gt; * System.Threading.Tasks.ParallelOptions * Action&lt;'Source, System.Threading.Tasks.ParallelLoopState, int64&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.ForEach (source, parallelOptions, body)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Concurrent.OrderablePartitioner&lt;TSource&gt;" />
        <Parameter Name="parallelOptions" Type="System.Threading.Tasks.ParallelOptions" />
        <Parameter Name="body" Type="System.Action&lt;TSource,System.Threading.Tasks.ParallelLoopState,System.Int64&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Tipo de los elementos de <paramref name="source" />.</typeparam>
        <param name="source">Particionador ordenable que contiene el origen de datos original.</param>
        <param name="parallelOptions">Objeto que configura el comportamiento de esta operación.</param>
        <param name="body">Delegado que se invoca una vez por cada iteración.</param>
        <summary>Ejecuta una operación <see langword="foreach" /> (<see langword="For Each" /> en Visual Basic) en <see cref="T:System.Collections.Concurrent.OrderablePartitioner`1" /> donde se pueden ejecutar iteraciones en paralelo y configurar opciones de bucle, y el estado del bucle se puede supervisar y manipular.</summary>
        <returns>Estructura que contiene información sobre qué parte del bucle se completó.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esta sobrecarga se proporciona para escenarios donde desea invalidar el valor predeterminado de esquema de partición. Por ejemplo, cuerpos de bucle pequeños podrían beneficiarse del particionamiento del intervalo. El <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> método espera particionadores personalizados para admitir la creación de particiones dinámica. Para obtener más información, consulte [particionadores personalizados para PLINQ y TPL](~/docs/standard/parallel-programming/custom-partitioners-for-plinq-and-tpl.md) y [Cómo: implementar las particiones dinámicas](~/docs/standard/parallel-programming/how-to-implement-dynamic-partitions.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OperationCanceledException">
          <see cref="T:System.Threading.CancellationToken" /> en el argumento <paramref name="parallelOptions" /> se cancela</exception>
        <exception cref="T:System.ArgumentNullException">El argumento <paramref name="source" /> es <see langword="null" />.  
  
O bien 
El argumento <paramref name="parallelOptions" /> es <see langword="null" />.  
  
O bien 
El argumento <paramref name="body" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ObjectDisposedException">El objeto <see cref="T:System.Threading.CancellationTokenSource" /> asociado a <see cref="T:System.Threading.CancellationToken" /> en el <paramref name="parallelOptions" /> se ha desechado.</exception>
        <exception cref="T:System.InvalidOperationException">La propiedad <see cref="P:System.Collections.Concurrent.Partitioner`1.SupportsDynamicPartitions" /> del particionador ordenable <paramref name="source" /> devuelve <see langword="false" />.  
  
O bien 
La propiedad <see cref="P:System.Collections.Concurrent.OrderablePartitioner`1.KeysNormalized" /> del particionador ordenable <paramref name="source" /> devuelve <see langword="false" />.  
  
O bien 
La excepción que se produce cuando cualquier método del particionador ordenable <paramref name="source" /> devuelve <see langword="null" />.</exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)">Bucles paralelos</related>
      </Docs>
    </Member>
    <Member MemberName="ForEach&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt; (System.Collections.Concurrent.Partitioner&lt;TSource&gt; source, System.Threading.Tasks.ParallelOptions parallelOptions, Action&lt;TSource,System.Threading.Tasks.ParallelLoopState&gt; body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt;(class System.Collections.Concurrent.Partitioner`1&lt;!!TSource&gt; source, class System.Threading.Tasks.ParallelOptions parallelOptions, class System.Action`2&lt;!!TSource, class System.Threading.Tasks.ParallelLoopState&gt; body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.ForEach``1(System.Collections.Concurrent.Partitioner{``0},System.Threading.Tasks.ParallelOptions,System.Action{``0,System.Threading.Tasks.ParallelLoopState})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult ForEach(System::Collections::Concurrent::Partitioner&lt;TSource&gt; ^ source, System::Threading::Tasks::ParallelOptions ^ parallelOptions, Action&lt;TSource, System::Threading::Tasks::ParallelLoopState ^&gt; ^ body);" />
      <MemberSignature Language="F#" Value="static member ForEach : System.Collections.Concurrent.Partitioner&lt;'Source&gt; * System.Threading.Tasks.ParallelOptions * Action&lt;'Source, System.Threading.Tasks.ParallelLoopState&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.ForEach (source, parallelOptions, body)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Concurrent.Partitioner&lt;TSource&gt;" />
        <Parameter Name="parallelOptions" Type="System.Threading.Tasks.ParallelOptions" />
        <Parameter Name="body" Type="System.Action&lt;TSource,System.Threading.Tasks.ParallelLoopState&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Tipo de los elementos de <paramref name="source" />.</typeparam>
        <param name="source">Particionador que contiene el origen de datos original.</param>
        <param name="parallelOptions">Objeto que configura el comportamiento de esta operación.</param>
        <param name="body">Delegado que se invoca una vez por cada iteración.</param>
        <summary>Ejecuta una operación <see langword="foreach" /> (<see langword="For Each" /> en Visual Basic) en <see cref="T:System.Collections.Concurrent.Partitioner" /> donde se pueden ejecutar iteraciones en paralelo y configurar opciones de bucle, y el estado del bucle se puede supervisar y manipular.</summary>
        <returns>Estructura que contiene información sobre qué parte del bucle se completó.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esta sobrecarga se proporciona para escenarios donde desea invalidar el valor predeterminado de esquema de partición. Por ejemplo, cuerpos de bucle pequeños podrían beneficiarse del particionamiento del intervalo. El <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> método espera particionadores personalizados para admitir la creación de particiones dinámica. Para obtener más información, consulte [particionadores personalizados para PLINQ y TPL](~/docs/standard/parallel-programming/custom-partitioners-for-plinq-and-tpl.md) y [Cómo: implementar las particiones dinámicas](~/docs/standard/parallel-programming/how-to-implement-dynamic-partitions.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OperationCanceledException">
          <see cref="T:System.Threading.CancellationToken" /> en el argumento <paramref name="parallelOptions" /> se cancela.</exception>
        <exception cref="T:System.ObjectDisposedException">El objeto <see cref="T:System.Threading.CancellationTokenSource" /> asociado a <see cref="T:System.Threading.CancellationToken" /> en el <paramref name="parallelOptions" /> se ha desechado.</exception>
        <exception cref="T:System.ArgumentNullException">El argumento <paramref name="source" /> es <see langword="null" />.  
  
O bien 
El argumento <paramref name="parallelOptions" /> es <see langword="null" />.  
  
O bien 
El argumento <paramref name="body" /> es <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">La propiedad <see cref="P:System.Collections.Concurrent.Partitioner`1.SupportsDynamicPartitions" /> del particionador <paramref name="source" /> devuelve <see langword="false" />.  
  
O bien 
La excepción que se produce cuando cualquier método del particionador <paramref name="source" /> devuelve <see langword="null" />.</exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)">Bucles paralelos</related>
      </Docs>
    </Member>
    <Member MemberName="ForEach&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt; (System.Collections.Concurrent.Partitioner&lt;TSource&gt; source, System.Threading.Tasks.ParallelOptions parallelOptions, Action&lt;TSource&gt; body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt;(class System.Collections.Concurrent.Partitioner`1&lt;!!TSource&gt; source, class System.Threading.Tasks.ParallelOptions parallelOptions, class System.Action`1&lt;!!TSource&gt; body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.ForEach``1(System.Collections.Concurrent.Partitioner{``0},System.Threading.Tasks.ParallelOptions,System.Action{``0})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult ForEach(System::Collections::Concurrent::Partitioner&lt;TSource&gt; ^ source, System::Threading::Tasks::ParallelOptions ^ parallelOptions, Action&lt;TSource&gt; ^ body);" />
      <MemberSignature Language="F#" Value="static member ForEach : System.Collections.Concurrent.Partitioner&lt;'Source&gt; * System.Threading.Tasks.ParallelOptions * Action&lt;'Source&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.ForEach (source, parallelOptions, body)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Concurrent.Partitioner&lt;TSource&gt;" />
        <Parameter Name="parallelOptions" Type="System.Threading.Tasks.ParallelOptions" />
        <Parameter Name="body" Type="System.Action&lt;TSource&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Tipo de los elementos de <paramref name="source" />.</typeparam>
        <param name="source">Particionador que contiene el origen de datos original.</param>
        <param name="parallelOptions">Objeto que configura el comportamiento de esta operación.</param>
        <param name="body">Delegado que se invoca una vez por cada iteración.</param>
        <summary>Ejecuta una operación <see langword="foreach" /> (<see langword="For Each" /> en Visual Basic) en <see cref="T:System.Collections.Concurrent.Partitioner" /> donde se pueden ejecutar iteraciones en paralelo y configurar las opciones de bucle.</summary>
        <returns>Estructura que contiene información sobre qué parte del bucle se completó.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esta sobrecarga se proporciona para escenarios donde desea invalidar el valor predeterminado de esquema de partición. Por ejemplo, cuerpos de bucle pequeños podrían beneficiarse del particionamiento del intervalo. El <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> método espera particionadores personalizados para admitir la creación de particiones dinámica. Para obtener más información, consulte [particionadores personalizados para PLINQ y TPL](~/docs/standard/parallel-programming/custom-partitioners-for-plinq-and-tpl.md) y [Cómo: implementar las particiones dinámicas](~/docs/standard/parallel-programming/how-to-implement-dynamic-partitions.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OperationCanceledException">
          <see cref="T:System.Threading.CancellationToken" /> en el argumento <paramref name="parallelOptions" /> se cancela.</exception>
        <exception cref="T:System.ObjectDisposedException">El objeto <see cref="T:System.Threading.CancellationTokenSource" /> asociado a <see cref="T:System.Threading.CancellationToken" /> en el <paramref name="parallelOptions" /> se ha desechado.</exception>
        <exception cref="T:System.ArgumentNullException">El argumento <paramref name="source" /> es <see langword="null" />.  
  
O bien 
El argumento <paramref name="parallelOptions" /> es <see langword="null" />.  
  
O bien 
El argumento <paramref name="body" /> es <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">La propiedad <see cref="P:System.Collections.Concurrent.Partitioner`1.SupportsDynamicPartitions" /> del particionador <paramref name="source" /> devuelve <see langword="false" />.  
  
O bien 
La excepción que se produce cuando cualquier método del particionador <paramref name="source" /> devuelve <see langword="null" />.</exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)">Bucles paralelos</related>
      </Docs>
    </Member>
    <Member MemberName="ForEach&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt; (System.Collections.Generic.IEnumerable&lt;TSource&gt; source, System.Threading.Tasks.ParallelOptions parallelOptions, Action&lt;TSource,System.Threading.Tasks.ParallelLoopState,long&gt; body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Threading.Tasks.ParallelOptions parallelOptions, class System.Action`3&lt;!!TSource, class System.Threading.Tasks.ParallelLoopState, int64&gt; body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.ForEach``1(System.Collections.Generic.IEnumerable{``0},System.Threading.Tasks.ParallelOptions,System.Action{``0,System.Threading.Tasks.ParallelLoopState,System.Int64})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult ForEach(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, System::Threading::Tasks::ParallelOptions ^ parallelOptions, Action&lt;TSource, System::Threading::Tasks::ParallelLoopState ^, long&gt; ^ body);" />
      <MemberSignature Language="F#" Value="static member ForEach : seq&lt;'Source&gt; * System.Threading.Tasks.ParallelOptions * Action&lt;'Source, System.Threading.Tasks.ParallelLoopState, int64&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.ForEach (source, parallelOptions, body)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" />
        <Parameter Name="parallelOptions" Type="System.Threading.Tasks.ParallelOptions" />
        <Parameter Name="body" Type="System.Action&lt;TSource,System.Threading.Tasks.ParallelLoopState,System.Int64&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Tipo de los datos del origen.</typeparam>
        <param name="source">Origen de datos enumerable.</param>
        <param name="parallelOptions">Objeto que configura el comportamiento de esta operación.</param>
        <param name="body">Delegado que se invoca una vez por cada iteración.</param>
        <summary>Ejecuta una operación <see langword="foreach" /> (<see langword="For Each" /> in Visual Basic) con índices de 64 bits en <see cref="T:System.Collections.IEnumerable" /> donde se pueden ejecutar iteraciones en paralelo y configurar opciones de bucle, y el estado del bucle se puede supervisar y manipular.</summary>
        <returns>Estructura que contiene información sobre qué parte del bucle se completó.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El `body` delegado se invoca una vez para cada elemento de la `source` enumerable. Se proporciona con los siguientes parámetros: el elemento actual, un <xref:System.Threading.Tasks.ParallelLoopState> instancia que puede utilizarse para salir del bucle prematuramente y el índice del elemento actual (<xref:System.Int64>).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OperationCanceledException">
          <see cref="T:System.Threading.CancellationToken" /> en el argumento <paramref name="parallelOptions" /> se cancela</exception>
        <exception cref="T:System.ArgumentNullException">El argumento <paramref name="source" /> es <see langword="null" />.  
  
O bien 
El argumento <paramref name="parallelOptions" /> es <see langword="null" />.  
  
O bien 
El argumento <paramref name="body" /> es <see langword="null" />.</exception>
        <exception cref="T:System.AggregateException">La excepción que contiene todas las excepciones individuales producidas en todos los subprocesos.</exception>
        <exception cref="T:System.ObjectDisposedException">El objeto <see cref="T:System.Threading.CancellationTokenSource" /> asociado a <see cref="T:System.Threading.CancellationToken" /> en el <paramref name="parallelOptions" /> se ha desechado.</exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)">Bucles paralelos</related>
      </Docs>
    </Member>
    <Member MemberName="ForEach&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt; (System.Collections.Generic.IEnumerable&lt;TSource&gt; source, System.Threading.Tasks.ParallelOptions parallelOptions, Action&lt;TSource,System.Threading.Tasks.ParallelLoopState&gt; body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Threading.Tasks.ParallelOptions parallelOptions, class System.Action`2&lt;!!TSource, class System.Threading.Tasks.ParallelLoopState&gt; body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.ForEach``1(System.Collections.Generic.IEnumerable{``0},System.Threading.Tasks.ParallelOptions,System.Action{``0,System.Threading.Tasks.ParallelLoopState})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult ForEach(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, System::Threading::Tasks::ParallelOptions ^ parallelOptions, Action&lt;TSource, System::Threading::Tasks::ParallelLoopState ^&gt; ^ body);" />
      <MemberSignature Language="F#" Value="static member ForEach : seq&lt;'Source&gt; * System.Threading.Tasks.ParallelOptions * Action&lt;'Source, System.Threading.Tasks.ParallelLoopState&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.ForEach (source, parallelOptions, body)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" />
        <Parameter Name="parallelOptions" Type="System.Threading.Tasks.ParallelOptions" />
        <Parameter Name="body" Type="System.Action&lt;TSource,System.Threading.Tasks.ParallelLoopState&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Tipo de los datos del origen.</typeparam>
        <param name="source">Origen de datos enumerable.</param>
        <param name="parallelOptions">Objeto que configura el comportamiento de esta operación.</param>
        <param name="body">Delegado que se invoca una vez por cada iteración.</param>
        <summary>Ejecuta una operación <see langword="foreach" /> (<see langword="For Each" /> en Visual Basic) en <see cref="T:System.Collections.IEnumerable" /> donde se pueden ejecutar iteraciones en paralelo y configurar opciones de bucle, y el estado del bucle se puede supervisar y manipular.</summary>
        <returns>Estructura que contiene información sobre qué parte del bucle se completó.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El `body` delegado se invoca una vez para cada elemento de la `source` enumerable. Se proporciona con los siguientes parámetros: el elemento actual y un <xref:System.Threading.Tasks.ParallelLoopState> instancia que puede utilizarse para interrumpir el bucle prematuramente.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OperationCanceledException">
          <see cref="T:System.Threading.CancellationToken" /> en el argumento <paramref name="parallelOptions" /> se cancela</exception>
        <exception cref="T:System.ArgumentNullException">El argumento <paramref name="source" /> es <see langword="null" />.  
  
O bien 
El argumento <paramref name="parallelOptions" /> es <see langword="null" />.  
  
O bien 
El argumento <paramref name="body" /> es <see langword="null" />.</exception>
        <exception cref="T:System.AggregateException">La excepción que contiene todas las excepciones individuales producidas en todos los subprocesos.</exception>
        <exception cref="T:System.ObjectDisposedException">El objeto <see cref="T:System.Threading.CancellationTokenSource" /> asociado a <see cref="T:System.Threading.CancellationToken" /> en el <paramref name="parallelOptions" /> se ha desechado.</exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)">Bucles paralelos</related>
      </Docs>
    </Member>
    <Member MemberName="ForEach&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt; (System.Collections.Generic.IEnumerable&lt;TSource&gt; source, System.Threading.Tasks.ParallelOptions parallelOptions, Action&lt;TSource&gt; body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Threading.Tasks.ParallelOptions parallelOptions, class System.Action`1&lt;!!TSource&gt; body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.ForEach``1(System.Collections.Generic.IEnumerable{``0},System.Threading.Tasks.ParallelOptions,System.Action{``0})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult ForEach(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, System::Threading::Tasks::ParallelOptions ^ parallelOptions, Action&lt;TSource&gt; ^ body);" />
      <MemberSignature Language="F#" Value="static member ForEach : seq&lt;'Source&gt; * System.Threading.Tasks.ParallelOptions * Action&lt;'Source&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.ForEach (source, parallelOptions, body)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" />
        <Parameter Name="parallelOptions" Type="System.Threading.Tasks.ParallelOptions" />
        <Parameter Name="body" Type="System.Action&lt;TSource&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Tipo de los datos del origen.</typeparam>
        <param name="source">Origen de datos enumerable.</param>
        <param name="parallelOptions">Objeto que configura el comportamiento de esta operación.</param>
        <param name="body">Delegado que se invoca una vez por cada iteración.</param>
        <summary>Ejecuta una operación <see langword="foreach" /> (<see langword="For Each" /> en Visual Basic) en <see cref="T:System.Collections.IEnumerable" /> donde se pueden ejecutar iteraciones en paralelo y configurar las opciones de bucle.</summary>
        <returns>Estructura que contiene información sobre qué parte del bucle se completó.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El `body` delegado se invoca una vez para cada elemento de la `source` enumerable. Se proporciona con el elemento actual como un parámetro.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OperationCanceledException">
          <see cref="T:System.Threading.CancellationToken" /> en el argumento <paramref name="parallelOptions" /> se cancela</exception>
        <exception cref="T:System.ArgumentNullException">El argumento <paramref name="source" /> es <see langword="null" />.  
  
O bien 
El argumento <paramref name="parallelOptions" /> es <see langword="null" />.  
  
O bien 
El argumento <paramref name="body" /> es <see langword="null" />.</exception>
        <exception cref="T:System.AggregateException">La excepción que contiene todas las excepciones individuales producidas en todos los subprocesos.</exception>
        <exception cref="T:System.ObjectDisposedException">El objeto <see cref="T:System.Threading.CancellationTokenSource" /> asociado a <see cref="T:System.Threading.CancellationToken" /> en el <paramref name="parallelOptions" /> se ha desechado.</exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)">Bucles paralelos</related>
      </Docs>
    </Member>
    <Member MemberName="ForEach&lt;TSource,TLocal&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource,TLocal&gt; (System.Collections.Concurrent.OrderablePartitioner&lt;TSource&gt; source, Func&lt;TLocal&gt; localInit, Func&lt;TSource,System.Threading.Tasks.ParallelLoopState,long,TLocal,TLocal&gt; body, Action&lt;TLocal&gt; localFinally);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource, TLocal&gt;(class System.Collections.Concurrent.OrderablePartitioner`1&lt;!!TSource&gt; source, class System.Func`1&lt;!!TLocal&gt; localInit, class System.Func`5&lt;!!TSource, class System.Threading.Tasks.ParallelLoopState, int64, !!TLocal, !!TLocal&gt; body, class System.Action`1&lt;!!TLocal&gt; localFinally) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.ForEach``2(System.Collections.Concurrent.OrderablePartitioner{``0},System.Func{``1},System.Func{``0,System.Threading.Tasks.ParallelLoopState,System.Int64,``1,``1},System.Action{``1})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ForEach(Of TSource, TLocal) (source As OrderablePartitioner(Of TSource), localInit As Func(Of TLocal), body As Func(Of TSource, ParallelLoopState, Long, TLocal, TLocal), localFinally As Action(Of TLocal)) As ParallelLoopResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TLocal&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult ForEach(System::Collections::Concurrent::OrderablePartitioner&lt;TSource&gt; ^ source, Func&lt;TLocal&gt; ^ localInit, Func&lt;TSource, System::Threading::Tasks::ParallelLoopState ^, long, TLocal, TLocal&gt; ^ body, Action&lt;TLocal&gt; ^ localFinally);" />
      <MemberSignature Language="F#" Value="static member ForEach : System.Collections.Concurrent.OrderablePartitioner&lt;'Source&gt; * Func&lt;'Local&gt; * Func&lt;'Source, System.Threading.Tasks.ParallelLoopState, int64, 'Local, 'Local&gt; * Action&lt;'Local&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.ForEach (source, localInit, body, localFinally)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TLocal" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Concurrent.OrderablePartitioner&lt;TSource&gt;" />
        <Parameter Name="localInit" Type="System.Func&lt;TLocal&gt;" />
        <Parameter Name="body" Type="System.Func&lt;TSource,System.Threading.Tasks.ParallelLoopState,System.Int64,TLocal,TLocal&gt;" />
        <Parameter Name="localFinally" Type="System.Action&lt;TLocal&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Tipo de los elementos de <paramref name="source" />.</typeparam>
        <typeparam name="TLocal">Tipo de los datos locales de subprocesos.</typeparam>
        <param name="source">Particionador ordenable que contiene el origen de datos original.</param>
        <param name="localInit">Delegado de función que devuelve el estado inicial de los datos locales de cada tarea.</param>
        <param name="body">Delegado que se invoca una vez por cada iteración.</param>
        <param name="localFinally">Delegado que realiza una acción final en el estado local de cada tarea.</param>
        <summary>Ejecuta una operación <see langword="foreach" /> (<see langword="For Each" /> en Visual Basic) con datos locales del subproceso en <see cref="T:System.Collections.Concurrent.OrderablePartitioner`1" /> donde se pueden ejecutar iteraciones en paralelo y configurar opciones de bucle, y el estado del bucle se puede supervisar y manipular.</summary>
        <returns>Estructura que contiene información sobre qué parte del bucle se completó.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esta sobrecarga se proporciona para escenarios donde desea invalidar el valor predeterminado de esquema de partición. Por ejemplo, cuerpos de bucle pequeños podrían beneficiarse del particionamiento del intervalo. El <xref:System.Threading.Tasks.Parallel.ForEach%2A> método espera particionadores personalizados para admitir la creación de particiones dinámica. Para obtener más información, consulte [particionadores personalizados para PLINQ y TPL](~/docs/standard/parallel-programming/custom-partitioners-for-plinq-and-tpl.md) y [Cómo: implementar las particiones dinámicas](~/docs/standard/parallel-programming/how-to-implement-dynamic-partitions.md).  
  
 El `localInit` delegado se invoca una vez para cada tarea que participa en la ejecución del bucle y devuelve el estado local inicial para cada una de esas tareas. Estos estados iniciales se pasan a la primera `body` las invocaciones de cada tarea. A continuación, cada invocación de cuerpo subsiguiente devuelve un valor de estado posiblemente modificado que se pasa a la siguiente invocación de cuerpo. Por último, la última invocación de cuerpo en cada tarea devuelve un valor de estado que se pasa a la `localFinally` delegar. El `localFinally` delegado se invoca una vez por cada tarea para realizar una acción final en el estado local de cada tarea. Este delegado se podría invocar simultáneamente en varias tareas; por lo tanto, se debe sincronizar el acceso a cualquier variable compartida.  
  
 El <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> método puede usar más tareas que los subprocesos durante la vigencia de su ejecución, como las tareas existentes completadas y se reemplazan con nuevas tareas. Esto proporciona subyacente <xref:System.Threading.Tasks.TaskScheduler> objeto la oportunidad de agregar, cambiar o quitar los subprocesos que dan servicio el bucle.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El argumento <paramref name="source" /> es <see langword="null" />.  
  
O bien 
El argumento <paramref name="body" /> es <see langword="null" />.  
  
O bien 
El argumento <paramref name="localInit" /> es <see langword="null" />.  
  
O bien 
El argumento <paramref name="localFinally" /> es <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">La propiedad <see cref="P:System.Collections.Concurrent.Partitioner`1.SupportsDynamicPartitions" /> de <paramref name="source" /><see cref="T:System.Collections.Concurrent.Partitioner" /> devuelve <see langword="false" /> o el particionador devuelve particiones <see langword="null" />.</exception>
        <exception cref="T:System.AggregateException">La excepción que contiene todas las excepciones individuales producidas en todos los subprocesos.</exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)">Bucles paralelos</related>
      </Docs>
    </Member>
    <Member MemberName="ForEach&lt;TSource,TLocal&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource,TLocal&gt; (System.Collections.Concurrent.Partitioner&lt;TSource&gt; source, Func&lt;TLocal&gt; localInit, Func&lt;TSource,System.Threading.Tasks.ParallelLoopState,TLocal,TLocal&gt; body, Action&lt;TLocal&gt; localFinally);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource, TLocal&gt;(class System.Collections.Concurrent.Partitioner`1&lt;!!TSource&gt; source, class System.Func`1&lt;!!TLocal&gt; localInit, class System.Func`4&lt;!!TSource, class System.Threading.Tasks.ParallelLoopState, !!TLocal, !!TLocal&gt; body, class System.Action`1&lt;!!TLocal&gt; localFinally) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.ForEach``2(System.Collections.Concurrent.Partitioner{``0},System.Func{``1},System.Func{``0,System.Threading.Tasks.ParallelLoopState,``1,``1},System.Action{``1})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ForEach(Of TSource, TLocal) (source As Partitioner(Of TSource), localInit As Func(Of TLocal), body As Func(Of TSource, ParallelLoopState, TLocal, TLocal), localFinally As Action(Of TLocal)) As ParallelLoopResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TLocal&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult ForEach(System::Collections::Concurrent::Partitioner&lt;TSource&gt; ^ source, Func&lt;TLocal&gt; ^ localInit, Func&lt;TSource, System::Threading::Tasks::ParallelLoopState ^, TLocal, TLocal&gt; ^ body, Action&lt;TLocal&gt; ^ localFinally);" />
      <MemberSignature Language="F#" Value="static member ForEach : System.Collections.Concurrent.Partitioner&lt;'Source&gt; * Func&lt;'Local&gt; * Func&lt;'Source, System.Threading.Tasks.ParallelLoopState, 'Local, 'Local&gt; * Action&lt;'Local&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.ForEach (source, localInit, body, localFinally)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TLocal" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Concurrent.Partitioner&lt;TSource&gt;" />
        <Parameter Name="localInit" Type="System.Func&lt;TLocal&gt;" />
        <Parameter Name="body" Type="System.Func&lt;TSource,System.Threading.Tasks.ParallelLoopState,TLocal,TLocal&gt;" />
        <Parameter Name="localFinally" Type="System.Action&lt;TLocal&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Tipo de los elementos de <paramref name="source" />.</typeparam>
        <typeparam name="TLocal">Tipo de los datos locales de subprocesos.</typeparam>
        <param name="source">Particionador que contiene el origen de datos original.</param>
        <param name="localInit">Delegado de función que devuelve el estado inicial de los datos locales de cada tarea.</param>
        <param name="body">Delegado que se invoca una vez por cada iteración.</param>
        <param name="localFinally">Delegado que realiza una acción final en el estado local de cada tarea.</param>
        <summary>Ejecuta una operación <see langword="foreach" /> (<see langword="For Each" /> en Visual Basic) con datos locales del subproceso en <see cref="T:System.Collections.Concurrent.Partitioner" /> donde se pueden ejecutar iteraciones en paralelo, y el estado del bucle se puede supervisar y manipular.</summary>
        <returns>Estructura que contiene información sobre qué parte del bucle se completó.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esta sobrecarga se proporciona para escenarios donde desea invalidar el valor predeterminado de esquema de partición. Por ejemplo, cuerpos de bucle pequeños podrían beneficiarse del particionamiento del intervalo. El <xref:System.Threading.Tasks.Parallel.ForEach%2A> método espera particionadores personalizados para admitir la creación de particiones dinámica. Para obtener más información, consulte [particionadores personalizados para PLINQ y TPL](~/docs/standard/parallel-programming/custom-partitioners-for-plinq-and-tpl.md) y [Cómo: implementar las particiones dinámicas](~/docs/standard/parallel-programming/how-to-implement-dynamic-partitions.md).  
  
 El `localInit` delegado se invoca una vez para cada subproceso que participa en la ejecución del bucle y devuelve el estado local inicial para cada una de esas tareas. Estos estados iniciales se pasan a la primera `body` las invocaciones de cada tarea. A continuación, cada invocación de cuerpo subsiguiente devuelve un valor de estado posiblemente modificado que se pasa a la siguiente invocación de cuerpo. Por último, la última invocación de cuerpo en cada tarea devuelve un valor de estado que se pasa a la `localFinally` delegar. El `localFinally` delegado se invoca una vez por cada tarea para realizar una acción final en el estado local de cada tarea. Este delegado se podría invocar simultáneamente en varias tareas; por lo tanto, se debe sincronizar el acceso a cualquier variable compartida.  
  
 El <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> método puede usar más tareas que los subprocesos durante la vigencia de su ejecución, como las tareas existentes completadas y se reemplazan con nuevas tareas. Esto proporciona subyacente <xref:System.Threading.Tasks.TaskScheduler> objeto la oportunidad de agregar, cambiar o quitar los subprocesos que dan servicio el bucle.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El argumento <paramref name="source" /> es <see langword="null" />.  
  
O bien 
El argumento <paramref name="body" /> es <see langword="null" />.  
  
O bien 
El argumento <paramref name="localInit" /> es <see langword="null" />.  
  
O bien 
El argumento <paramref name="localFinally" /> es <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">La propiedad <see cref="P:System.Collections.Concurrent.Partitioner`1.SupportsDynamicPartitions" /> de <paramref name="source" /><see cref="T:System.Collections.Concurrent.Partitioner" /> devuelve <see langword="false" /> o el particionador devuelve particiones <see langword="null" />.</exception>
        <exception cref="T:System.AggregateException">La excepción que contiene todas las excepciones individuales producidas en todos los subprocesos.</exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)">Bucles paralelos</related>
      </Docs>
    </Member>
    <Member MemberName="ForEach&lt;TSource,TLocal&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource,TLocal&gt; (System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TLocal&gt; localInit, Func&lt;TSource,System.Threading.Tasks.ParallelLoopState,long,TLocal,TLocal&gt; body, Action&lt;TLocal&gt; localFinally);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource, TLocal&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`1&lt;!!TLocal&gt; localInit, class System.Func`5&lt;!!TSource, class System.Threading.Tasks.ParallelLoopState, int64, !!TLocal, !!TLocal&gt; body, class System.Action`1&lt;!!TLocal&gt; localFinally) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.ForEach``2(System.Collections.Generic.IEnumerable{``0},System.Func{``1},System.Func{``0,System.Threading.Tasks.ParallelLoopState,System.Int64,``1,``1},System.Action{``1})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ForEach(Of TSource, TLocal) (source As IEnumerable(Of TSource), localInit As Func(Of TLocal), body As Func(Of TSource, ParallelLoopState, Long, TLocal, TLocal), localFinally As Action(Of TLocal)) As ParallelLoopResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TLocal&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult ForEach(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, Func&lt;TLocal&gt; ^ localInit, Func&lt;TSource, System::Threading::Tasks::ParallelLoopState ^, long, TLocal, TLocal&gt; ^ body, Action&lt;TLocal&gt; ^ localFinally);" />
      <MemberSignature Language="F#" Value="static member ForEach : seq&lt;'Source&gt; * Func&lt;'Local&gt; * Func&lt;'Source, System.Threading.Tasks.ParallelLoopState, int64, 'Local, 'Local&gt; * Action&lt;'Local&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.ForEach (source, localInit, body, localFinally)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TLocal" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" />
        <Parameter Name="localInit" Type="System.Func&lt;TLocal&gt;" />
        <Parameter Name="body" Type="System.Func&lt;TSource,System.Threading.Tasks.ParallelLoopState,System.Int64,TLocal,TLocal&gt;" />
        <Parameter Name="localFinally" Type="System.Action&lt;TLocal&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Tipo de los datos del origen.</typeparam>
        <typeparam name="TLocal">Tipo de los datos locales de subprocesos.</typeparam>
        <param name="source">Origen de datos enumerable.</param>
        <param name="localInit">Delegado de función que devuelve el estado inicial de los datos locales de cada tarea.</param>
        <param name="body">Delegado que se invoca una vez por cada iteración.</param>
        <param name="localFinally">Delegado que realiza una acción final en el estado local de cada tarea.</param>
        <summary>Ejecuta una operación <see langword="foreach" /> (<see langword="For Each" /> en Visual Basic) con datos locales del subproceso en <see cref="T:System.Collections.IEnumerable" /> donde se pueden ejecutar iteraciones en paralelo, y el estado del bucle se puede supervisar y manipular.</summary>
        <returns>Estructura que contiene información sobre qué parte del bucle se completó.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El `body` delegado se invoca una vez para cada elemento de la `source` enumerable. Se proporciona con los siguientes parámetros: el elemento actual, un <xref:System.Threading.Tasks.ParallelLoopState> instancia que puede utilizarse para salir del bucle prematuramente, el índice del elemento actual (<xref:System.Int64>) y algún estado local, que se puede compartir entre las iteraciones que se ejecutan en el mismo subproceso.  
  
 El `localInit` delegado se invoca una vez para cada tarea que participa en la ejecución del bucle y devuelve el estado local inicial para cada una de esas tareas. Estos estados iniciales se pasan a la primera `body` las invocaciones de cada tarea. A continuación, cada invocación de cuerpo subsiguiente devuelve un valor de estado posiblemente modificado que se pasa a la siguiente invocación de cuerpo. Por último, la última invocación de cuerpo en cada tarea devuelve un valor de estado que se pasa a la `localFinally` delegar. El `localFinally` delegado se invoca una vez por cada tarea para realizar una acción final en el estado local de cada tarea. Este delegado se podría invocar simultáneamente en varias tareas; por lo tanto, se debe sincronizar el acceso a cualquier variable compartida.  
  
 El <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> método puede usar más tareas que los subprocesos durante la vigencia de su ejecución, como las tareas existentes completadas y se reemplazan con nuevas tareas. Esto proporciona subyacente <xref:System.Threading.Tasks.TaskScheduler> objeto la oportunidad de agregar, cambiar o quitar los subprocesos que dan servicio el bucle.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El argumento <paramref name="source" /> es <see langword="null" />.  
  
O bien 
El argumento <paramref name="body" /> es <see langword="null" />.  
  
O bien 
El argumento <paramref name="localInit" /> es <see langword="null" />.  
  
O bien 
El argumento <paramref name="localFinally" /> es <see langword="null" />.</exception>
        <exception cref="T:System.AggregateException">La excepción que contiene todas las excepciones individuales producidas en todos los subprocesos.</exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)">Bucles paralelos</related>
      </Docs>
    </Member>
    <Member MemberName="ForEach&lt;TSource,TLocal&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource,TLocal&gt; (System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TLocal&gt; localInit, Func&lt;TSource,System.Threading.Tasks.ParallelLoopState,TLocal,TLocal&gt; body, Action&lt;TLocal&gt; localFinally);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource, TLocal&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`1&lt;!!TLocal&gt; localInit, class System.Func`4&lt;!!TSource, class System.Threading.Tasks.ParallelLoopState, !!TLocal, !!TLocal&gt; body, class System.Action`1&lt;!!TLocal&gt; localFinally) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.ForEach``2(System.Collections.Generic.IEnumerable{``0},System.Func{``1},System.Func{``0,System.Threading.Tasks.ParallelLoopState,``1,``1},System.Action{``1})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ForEach(Of TSource, TLocal) (source As IEnumerable(Of TSource), localInit As Func(Of TLocal), body As Func(Of TSource, ParallelLoopState, TLocal, TLocal), localFinally As Action(Of TLocal)) As ParallelLoopResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TLocal&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult ForEach(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, Func&lt;TLocal&gt; ^ localInit, Func&lt;TSource, System::Threading::Tasks::ParallelLoopState ^, TLocal, TLocal&gt; ^ body, Action&lt;TLocal&gt; ^ localFinally);" />
      <MemberSignature Language="F#" Value="static member ForEach : seq&lt;'Source&gt; * Func&lt;'Local&gt; * Func&lt;'Source, System.Threading.Tasks.ParallelLoopState, 'Local, 'Local&gt; * Action&lt;'Local&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.ForEach (source, localInit, body, localFinally)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TLocal" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" />
        <Parameter Name="localInit" Type="System.Func&lt;TLocal&gt;" />
        <Parameter Name="body" Type="System.Func&lt;TSource,System.Threading.Tasks.ParallelLoopState,TLocal,TLocal&gt;" />
        <Parameter Name="localFinally" Type="System.Action&lt;TLocal&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Tipo de los datos del origen.</typeparam>
        <typeparam name="TLocal">Tipo de los datos locales de subprocesos.</typeparam>
        <param name="source">Origen de datos enumerable.</param>
        <param name="localInit">Delegado de función que devuelve el estado inicial de los datos locales de cada tarea.</param>
        <param name="body">Delegado que se invoca una vez por cada iteración.</param>
        <param name="localFinally">Delegado que realiza una acción final en el estado local de cada tarea.</param>
        <summary>Ejecuta una operación <see langword="foreach" /> (<see langword="For Each" /> en Visual Basic) con datos locales del subproceso en <see cref="T:System.Collections.IEnumerable" /> donde se pueden ejecutar iteraciones en paralelo, y el estado del bucle se puede supervisar y manipular.</summary>
        <returns>Estructura que contiene información sobre qué parte del bucle se completó.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El `body` delegado se invoca una vez para cada elemento de la `source` enumerable. Se proporciona con los siguientes parámetros: el elemento actual, un <xref:System.Threading.Tasks.ParallelLoopState> instancia que puede utilizarse para salir del bucle prematuramente y algún estado local, que se puede compartir entre las iteraciones que se ejecutan en el mismo subproceso.  
  
 El `localInit` delegado se invoca una vez para cada tarea que participa en la ejecución del bucle y devuelve el estado local inicial para cada una de esas tareas. Estos estados iniciales se pasan a la primera `body` las invocaciones de cada tarea. A continuación, cada invocación de cuerpo subsiguiente devuelve un valor de estado posiblemente modificado que se pasa a la siguiente invocación de cuerpo. Por último, la última invocación de cuerpo en cada tarea devuelve un valor de estado que se pasa a la `localFinally` delegar. El `localFinally` delegado se invoca una vez por subproceso para realizar una acción final en el estado local de cada tarea. Este delegado se podría invocar simultáneamente en varias tareas; por lo tanto, se debe sincronizar el acceso a cualquier variable compartida.  
  
 El <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> método puede usar más tareas que los subprocesos durante la vigencia de su ejecución, como las tareas existentes completadas y se reemplazan con nuevas tareas. Esto proporciona subyacente <xref:System.Threading.Tasks.TaskScheduler> objeto la oportunidad de agregar, cambiar o quitar los subprocesos que dan servicio el bucle.  
  
   
  
## Examples  
 El ejemplo siguiente muestra cómo usar un <xref:System.Threading.Tasks.Parallel.ForEach%2A> método con el estado local:  
  
 [!code-csharp[System.Threading.Tasks.Parallel#02](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.parallel/cs/parallelforeach.cs#02)]
 [!code-vb[System.Threading.Tasks.Parallel#02](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.parallel/vb/parallelforeach.vb#02)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El argumento <paramref name="source" /> es <see langword="null" />.  
  
O bien 
El argumento <paramref name="body" /> es <see langword="null" />.  
  
O bien 
El argumento <paramref name="localInit" /> es <see langword="null" />.  
  
O bien 
El argumento <paramref name="localFinally" /> es <see langword="null" />.</exception>
        <exception cref="T:System.AggregateException">La excepción que contiene todas las excepciones individuales producidas en todos los subprocesos.</exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)">Bucles paralelos</related>
      </Docs>
    </Member>
    <Member MemberName="ForEach&lt;TSource,TLocal&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource,TLocal&gt; (System.Collections.Concurrent.OrderablePartitioner&lt;TSource&gt; source, System.Threading.Tasks.ParallelOptions parallelOptions, Func&lt;TLocal&gt; localInit, Func&lt;TSource,System.Threading.Tasks.ParallelLoopState,long,TLocal,TLocal&gt; body, Action&lt;TLocal&gt; localFinally);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource, TLocal&gt;(class System.Collections.Concurrent.OrderablePartitioner`1&lt;!!TSource&gt; source, class System.Threading.Tasks.ParallelOptions parallelOptions, class System.Func`1&lt;!!TLocal&gt; localInit, class System.Func`5&lt;!!TSource, class System.Threading.Tasks.ParallelLoopState, int64, !!TLocal, !!TLocal&gt; body, class System.Action`1&lt;!!TLocal&gt; localFinally) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.ForEach``2(System.Collections.Concurrent.OrderablePartitioner{``0},System.Threading.Tasks.ParallelOptions,System.Func{``1},System.Func{``0,System.Threading.Tasks.ParallelLoopState,System.Int64,``1,``1},System.Action{``1})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TLocal&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult ForEach(System::Collections::Concurrent::OrderablePartitioner&lt;TSource&gt; ^ source, System::Threading::Tasks::ParallelOptions ^ parallelOptions, Func&lt;TLocal&gt; ^ localInit, Func&lt;TSource, System::Threading::Tasks::ParallelLoopState ^, long, TLocal, TLocal&gt; ^ body, Action&lt;TLocal&gt; ^ localFinally);" />
      <MemberSignature Language="F#" Value="static member ForEach : System.Collections.Concurrent.OrderablePartitioner&lt;'Source&gt; * System.Threading.Tasks.ParallelOptions * Func&lt;'Local&gt; * Func&lt;'Source, System.Threading.Tasks.ParallelLoopState, int64, 'Local, 'Local&gt; * Action&lt;'Local&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.ForEach (source, parallelOptions, localInit, body, localFinally)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TLocal" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Concurrent.OrderablePartitioner&lt;TSource&gt;" />
        <Parameter Name="parallelOptions" Type="System.Threading.Tasks.ParallelOptions" />
        <Parameter Name="localInit" Type="System.Func&lt;TLocal&gt;" />
        <Parameter Name="body" Type="System.Func&lt;TSource,System.Threading.Tasks.ParallelLoopState,System.Int64,TLocal,TLocal&gt;" />
        <Parameter Name="localFinally" Type="System.Action&lt;TLocal&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Tipo de los elementos de <paramref name="source" />.</typeparam>
        <typeparam name="TLocal">Tipo de los datos locales de subprocesos.</typeparam>
        <param name="source">Particionador ordenable que contiene el origen de datos original.</param>
        <param name="parallelOptions">Objeto que configura el comportamiento de esta operación.</param>
        <param name="localInit">Delegado de función que devuelve el estado inicial de los datos locales de cada tarea.</param>
        <param name="body">Delegado que se invoca una vez por cada iteración.</param>
        <param name="localFinally">Delegado que realiza una acción final en el estado local de cada tarea.</param>
        <summary>Ejecuta una operación <see langword="foreach" /> (<see langword="For Each" /> en Visual Basic) con índices de 64 bits y datos locales del subproceso en <see cref="T:System.Collections.Concurrent.OrderablePartitioner`1" /> donde se pueden ejecutar iteraciones en paralelo y configurar opciones de bucle, y el estado del bucle se puede supervisar y manipular.</summary>
        <returns>Estructura que contiene información sobre qué parte del bucle se completó.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esta sobrecarga se proporciona para escenarios donde desea invalidar el valor predeterminado de esquema de partición. Por ejemplo, cuerpos de bucle pequeños podrían beneficiarse del particionamiento del intervalo. El <xref:System.Threading.Tasks.Parallel.ForEach%2A> método espera particionadores personalizados para admitir la creación de particiones dinámica. Para obtener más información, consulte [particionadores personalizados para PLINQ y TPL](~/docs/standard/parallel-programming/custom-partitioners-for-plinq-and-tpl.md) y [Cómo: implementar las particiones dinámicas](~/docs/standard/parallel-programming/how-to-implement-dynamic-partitions.md).  
  
 El `localInit` delegado se invoca una vez para cada tarea que participa en la ejecución del bucle y devuelve el estado local inicial para cada una de esas tareas. Estos estados iniciales se pasan a la primera `body` las invocaciones de cada tarea. A continuación, cada invocación de cuerpo subsiguiente devuelve un valor de estado posiblemente modificado que se pasa a la siguiente invocación de cuerpo. Por último, la última invocación de cuerpo en cada subproceso devuelve un valor de estado que se pasa a la `localFinally` delegar. El `localFinally` delegado se invoca una vez por cada tarea para realizar una acción final en el estado local de cada tarea. Este delegado se podría invocar simultáneamente en varias tareas; por lo tanto, se debe sincronizar el acceso a cualquier variable compartida.  
  
 El <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> método puede usar más tareas que los subprocesos durante la vigencia de su ejecución, como las tareas existentes completadas y se reemplazan con nuevas tareas. Esto proporciona subyacente <xref:System.Threading.Tasks.TaskScheduler> objeto la oportunidad de agregar, cambiar o quitar los subprocesos que dan servicio el bucle.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El argumento <paramref name="source" /> es <see langword="null" />.  
  
O bien 
El argumento <paramref name="parallelOptions" /> es <see langword="null" />.  
  
O bien 
El argumento <paramref name="body" /> es <see langword="null" />.  
  
O bien 
El argumento <paramref name="localInit" /> o <paramref name="localFinally" /> es <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">La propiedad <see cref="P:System.Collections.Concurrent.Partitioner`1.SupportsDynamicPartitions" /> de <paramref name="source" /><see cref="T:System.Collections.Concurrent.Partitioner" /> devuelve <see langword="false" /> o el particionador devuelve particiones <see langword="null" />.</exception>
        <exception cref="T:System.AggregateException">La excepción que contiene todas las excepciones individuales producidas en todos los subprocesos.</exception>
        <exception cref="T:System.OperationCanceledException">
          <see cref="T:System.Threading.CancellationToken" /> en el argumento <paramref name="parallelOptions" /> se cancela.</exception>
        <exception cref="T:System.ObjectDisposedException">El objeto <see cref="T:System.Threading.CancellationTokenSource" /> asociado a <see cref="T:System.Threading.CancellationToken" /> en el <paramref name="parallelOptions" /> se ha desechado.</exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)">Bucles paralelos</related>
      </Docs>
    </Member>
    <Member MemberName="ForEach&lt;TSource,TLocal&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource,TLocal&gt; (System.Collections.Concurrent.Partitioner&lt;TSource&gt; source, System.Threading.Tasks.ParallelOptions parallelOptions, Func&lt;TLocal&gt; localInit, Func&lt;TSource,System.Threading.Tasks.ParallelLoopState,TLocal,TLocal&gt; body, Action&lt;TLocal&gt; localFinally);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource, TLocal&gt;(class System.Collections.Concurrent.Partitioner`1&lt;!!TSource&gt; source, class System.Threading.Tasks.ParallelOptions parallelOptions, class System.Func`1&lt;!!TLocal&gt; localInit, class System.Func`4&lt;!!TSource, class System.Threading.Tasks.ParallelLoopState, !!TLocal, !!TLocal&gt; body, class System.Action`1&lt;!!TLocal&gt; localFinally) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.ForEach``2(System.Collections.Concurrent.Partitioner{``0},System.Threading.Tasks.ParallelOptions,System.Func{``1},System.Func{``0,System.Threading.Tasks.ParallelLoopState,``1,``1},System.Action{``1})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TLocal&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult ForEach(System::Collections::Concurrent::Partitioner&lt;TSource&gt; ^ source, System::Threading::Tasks::ParallelOptions ^ parallelOptions, Func&lt;TLocal&gt; ^ localInit, Func&lt;TSource, System::Threading::Tasks::ParallelLoopState ^, TLocal, TLocal&gt; ^ body, Action&lt;TLocal&gt; ^ localFinally);" />
      <MemberSignature Language="F#" Value="static member ForEach : System.Collections.Concurrent.Partitioner&lt;'Source&gt; * System.Threading.Tasks.ParallelOptions * Func&lt;'Local&gt; * Func&lt;'Source, System.Threading.Tasks.ParallelLoopState, 'Local, 'Local&gt; * Action&lt;'Local&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.ForEach (source, parallelOptions, localInit, body, localFinally)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TLocal" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Concurrent.Partitioner&lt;TSource&gt;" />
        <Parameter Name="parallelOptions" Type="System.Threading.Tasks.ParallelOptions" />
        <Parameter Name="localInit" Type="System.Func&lt;TLocal&gt;" />
        <Parameter Name="body" Type="System.Func&lt;TSource,System.Threading.Tasks.ParallelLoopState,TLocal,TLocal&gt;" />
        <Parameter Name="localFinally" Type="System.Action&lt;TLocal&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Tipo de los elementos de <paramref name="source" />.</typeparam>
        <typeparam name="TLocal">Tipo de los datos locales de subprocesos.</typeparam>
        <param name="source">Particionador que contiene el origen de datos original.</param>
        <param name="parallelOptions">Objeto que configura el comportamiento de esta operación.</param>
        <param name="localInit">Delegado de función que devuelve el estado inicial de los datos locales de cada tarea.</param>
        <param name="body">Delegado que se invoca una vez por cada iteración.</param>
        <param name="localFinally">Delegado que realiza una acción final en el estado local de cada tarea.</param>
        <summary>Ejecuta una operación <see langword="foreach" /> (<see langword="For Each" /> en Visual Basic) con datos locales del subproceso en <see cref="T:System.Collections.Concurrent.Partitioner" /> donde se pueden ejecutar iteraciones en paralelo y configurar opciones de bucle, y el estado del bucle se puede supervisar y manipular.</summary>
        <returns>Estructura que contiene información sobre qué parte del bucle se completó.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esta sobrecarga se proporciona para escenarios donde desea invalidar el valor predeterminado de esquema de partición. Por ejemplo, cuerpos de bucle pequeños podrían beneficiarse del particionamiento del intervalo. El <xref:System.Threading.Tasks.Parallel.ForEach%2A> método espera particionadores personalizados para admitir la creación de particiones dinámica. Esta sobrecarga se proporciona para escenarios con cuerpos de bucle pequeños que podrían beneficiarse del particionamiento de intervalo estático. Los particionadores debe admitir las particiones dinámicas.  Para obtener más información, consulte [particionadores personalizados para PLINQ y TPL](~/docs/standard/parallel-programming/custom-partitioners-for-plinq-and-tpl.md) y [Cómo: implementar las particiones dinámicas](~/docs/standard/parallel-programming/how-to-implement-dynamic-partitions.md).  
  
 El `localInit` delegado se invoca una vez para cada tarea que participa en la ejecución del bucle y devuelve el estado local inicial para cada una de esas tareas. Estos estados iniciales se pasan a la primera `body` las invocaciones de cada tarea. A continuación, cada invocación de cuerpo subsiguiente devuelve un valor de estado posiblemente modificado que se pasa a la siguiente invocación de cuerpo. Por último, la última invocación de cuerpo en cada tarea devuelve un valor de estado que se pasa a la `localFinally` delegar. El `localFinally` delegado se invoca una vez por cada tarea para realizar una acción final en el estado local de cada tarea. Este delegado se podría invocar simultáneamente en varias tareas; por lo tanto, se debe sincronizar el acceso a cualquier variable compartida.  
  
 El <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> método puede usar más tareas que los subprocesos durante la vigencia de su ejecución, como las tareas existentes completadas y se reemplazan con nuevas tareas. Esto proporciona subyacente <xref:System.Threading.Tasks.TaskScheduler> objeto la oportunidad de agregar, cambiar o quitar los subprocesos que dan servicio el bucle.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El argumento <paramref name="source" /> es <see langword="null" />.  
  
O bien 
El argumento <paramref name="parallelOptions" /> es <see langword="null" />.  
  
O bien 
El argumento <paramref name="body" /> es <see langword="null" />.  
  
O bien 
El argumento <paramref name="localInit" /> es <see langword="null" />.  
  
O bien 
El argumento <paramref name="localFinally" /> es <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">La propiedad <see cref="P:System.Collections.Concurrent.Partitioner`1.SupportsDynamicPartitions" /> de <paramref name="source" /><see cref="T:System.Collections.Concurrent.Partitioner" /> devuelve <see langword="false" /> o el particionador devuelve particiones <see langword="null" />.</exception>
        <exception cref="T:System.AggregateException">La excepción que contiene todas las excepciones individuales producidas en todos los subprocesos.</exception>
        <exception cref="T:System.OperationCanceledException">
          <see cref="T:System.Threading.CancellationToken" /> en el argumento <paramref name="parallelOptions" /> se cancela.</exception>
        <exception cref="T:System.ObjectDisposedException">El objeto <see cref="T:System.Threading.CancellationTokenSource" /> asociado a <see cref="T:System.Threading.CancellationToken" /> en el <paramref name="parallelOptions" /> se ha desechado.</exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)">Bucles paralelos</related>
      </Docs>
    </Member>
    <Member MemberName="ForEach&lt;TSource,TLocal&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource,TLocal&gt; (System.Collections.Generic.IEnumerable&lt;TSource&gt; source, System.Threading.Tasks.ParallelOptions parallelOptions, Func&lt;TLocal&gt; localInit, Func&lt;TSource,System.Threading.Tasks.ParallelLoopState,long,TLocal,TLocal&gt; body, Action&lt;TLocal&gt; localFinally);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource, TLocal&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Threading.Tasks.ParallelOptions parallelOptions, class System.Func`1&lt;!!TLocal&gt; localInit, class System.Func`5&lt;!!TSource, class System.Threading.Tasks.ParallelLoopState, int64, !!TLocal, !!TLocal&gt; body, class System.Action`1&lt;!!TLocal&gt; localFinally) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.ForEach``2(System.Collections.Generic.IEnumerable{``0},System.Threading.Tasks.ParallelOptions,System.Func{``1},System.Func{``0,System.Threading.Tasks.ParallelLoopState,System.Int64,``1,``1},System.Action{``1})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TLocal&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult ForEach(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, System::Threading::Tasks::ParallelOptions ^ parallelOptions, Func&lt;TLocal&gt; ^ localInit, Func&lt;TSource, System::Threading::Tasks::ParallelLoopState ^, long, TLocal, TLocal&gt; ^ body, Action&lt;TLocal&gt; ^ localFinally);" />
      <MemberSignature Language="F#" Value="static member ForEach : seq&lt;'Source&gt; * System.Threading.Tasks.ParallelOptions * Func&lt;'Local&gt; * Func&lt;'Source, System.Threading.Tasks.ParallelLoopState, int64, 'Local, 'Local&gt; * Action&lt;'Local&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.ForEach (source, parallelOptions, localInit, body, localFinally)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TLocal" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" />
        <Parameter Name="parallelOptions" Type="System.Threading.Tasks.ParallelOptions" />
        <Parameter Name="localInit" Type="System.Func&lt;TLocal&gt;" />
        <Parameter Name="body" Type="System.Func&lt;TSource,System.Threading.Tasks.ParallelLoopState,System.Int64,TLocal,TLocal&gt;" />
        <Parameter Name="localFinally" Type="System.Action&lt;TLocal&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Tipo de los datos del origen.</typeparam>
        <typeparam name="TLocal">Tipo de los datos locales de subprocesos.</typeparam>
        <param name="source">Origen de datos enumerable.</param>
        <param name="parallelOptions">Objeto que configura el comportamiento de esta operación.</param>
        <param name="localInit">Delegado de función que devuelve el estado inicial de los datos locales de cada tarea.</param>
        <param name="body">Delegado que se invoca una vez por cada iteración.</param>
        <param name="localFinally">Delegado que realiza una acción final en el estado local de cada tarea.</param>
        <summary>Ejecuta una operación <see langword="foreach" /> (<see langword="For Each" /> en Visual Basic) con índices de 64 bits y datos locales del subproceso en <see cref="T:System.Collections.IEnumerable" /> donde se pueden ejecutar iteraciones en paralelo y configurar opciones de bucle, y el estado del bucle se puede supervisar y manipular.</summary>
        <returns>Estructura que contiene información sobre qué parte del bucle se completó.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El `body` delegado se invoca una vez para cada elemento de la `source` enumerable. Se proporciona con los siguientes parámetros: el elemento actual, un <xref:System.Threading.Tasks.ParallelLoopState> instancia que puede utilizarse para salir del bucle prematuramente, el índice del elemento actual (<xref:System.Int64>) y algún estado local, que se puede compartir entre las iteraciones que se ejecutan en el mismo subproceso.  
  
 El `localInit` delegado se invoca una vez para cada tarea que participa en la ejecución del bucle y devuelve el estado local inicial para cada una de esas tareas. Estos estados iniciales se pasan a la primera `body` las invocaciones de cada tarea. A continuación, cada invocación de cuerpo subsiguiente devuelve un valor de estado posiblemente modificado que se pasa a la siguiente invocación de cuerpo. Por último, la última invocación de cuerpo en cada tarea devuelve un valor de estado que se pasa a la `localFinally` delegar. El `localFinally` delegado se invoca una vez por subproceso para realizar una acción final en el estado local de cada tarea. Este delegado se podría invocar simultáneamente en varias tareas; por lo tanto, se debe sincronizar el acceso a cualquier variable compartida.  
  
 El <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> método puede usar más tareas que los subprocesos durante la vigencia de su ejecución, como las tareas existentes completadas y se reemplazan con nuevas tareas. Esto proporciona subyacente <xref:System.Threading.Tasks.TaskScheduler> objeto la oportunidad de agregar, cambiar o quitar los subprocesos que dan servicio el bucle.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El argumento <paramref name="source" /> es <see langword="null" />.  
  
O bien 
El argumento <paramref name="parallelOptions" /> es <see langword="null" />.  
  
O bien 
El argumento <paramref name="body" /> es <see langword="null" />.  
  
O bien 
El argumento <paramref name="localInit" /> es <see langword="null" />.  
  
O bien 
El argumento <paramref name="localFinally" /> es <see langword="null" />.</exception>
        <exception cref="T:System.OperationCanceledException">
          <see cref="T:System.Threading.CancellationToken" /> en el argumento <paramref name="parallelOptions" /> se cancela.</exception>
        <exception cref="T:System.ObjectDisposedException">El objeto <see cref="T:System.Threading.CancellationTokenSource" /> asociado a <see cref="T:System.Threading.CancellationToken" /> en el <paramref name="parallelOptions" /> se ha desechado.</exception>
        <exception cref="T:System.AggregateException">La excepción que contiene todas las excepciones individuales producidas en todos los subprocesos.</exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)">Bucles paralelos</related>
      </Docs>
    </Member>
    <Member MemberName="ForEach&lt;TSource,TLocal&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource,TLocal&gt; (System.Collections.Generic.IEnumerable&lt;TSource&gt; source, System.Threading.Tasks.ParallelOptions parallelOptions, Func&lt;TLocal&gt; localInit, Func&lt;TSource,System.Threading.Tasks.ParallelLoopState,TLocal,TLocal&gt; body, Action&lt;TLocal&gt; localFinally);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource, TLocal&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Threading.Tasks.ParallelOptions parallelOptions, class System.Func`1&lt;!!TLocal&gt; localInit, class System.Func`4&lt;!!TSource, class System.Threading.Tasks.ParallelLoopState, !!TLocal, !!TLocal&gt; body, class System.Action`1&lt;!!TLocal&gt; localFinally) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.ForEach``2(System.Collections.Generic.IEnumerable{``0},System.Threading.Tasks.ParallelOptions,System.Func{``1},System.Func{``0,System.Threading.Tasks.ParallelLoopState,``1,``1},System.Action{``1})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TLocal&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult ForEach(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, System::Threading::Tasks::ParallelOptions ^ parallelOptions, Func&lt;TLocal&gt; ^ localInit, Func&lt;TSource, System::Threading::Tasks::ParallelLoopState ^, TLocal, TLocal&gt; ^ body, Action&lt;TLocal&gt; ^ localFinally);" />
      <MemberSignature Language="F#" Value="static member ForEach : seq&lt;'Source&gt; * System.Threading.Tasks.ParallelOptions * Func&lt;'Local&gt; * Func&lt;'Source, System.Threading.Tasks.ParallelLoopState, 'Local, 'Local&gt; * Action&lt;'Local&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.ForEach (source, parallelOptions, localInit, body, localFinally)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TLocal" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" />
        <Parameter Name="parallelOptions" Type="System.Threading.Tasks.ParallelOptions" />
        <Parameter Name="localInit" Type="System.Func&lt;TLocal&gt;" />
        <Parameter Name="body" Type="System.Func&lt;TSource,System.Threading.Tasks.ParallelLoopState,TLocal,TLocal&gt;" />
        <Parameter Name="localFinally" Type="System.Action&lt;TLocal&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Tipo de los datos del origen.</typeparam>
        <typeparam name="TLocal">Tipo de los datos locales de subprocesos.</typeparam>
        <param name="source">Origen de datos enumerable.</param>
        <param name="parallelOptions">Objeto que configura el comportamiento de esta operación.</param>
        <param name="localInit">Delegado de función que devuelve el estado inicial de los datos locales de cada tarea.</param>
        <param name="body">Delegado que se invoca una vez por cada iteración.</param>
        <param name="localFinally">Delegado que realiza una acción final en el estado local de cada tarea.</param>
        <summary>Ejecuta una operación <see langword="foreach" /> (<see langword="For Each" /> en Visual Basic) con datos locales del subproceso en <see cref="T:System.Collections.IEnumerable" /> donde se pueden ejecutar iteraciones en paralelo y configurar opciones de bucle, y el estado del bucle se puede supervisar y manipular.</summary>
        <returns>Estructura que contiene información sobre qué parte del bucle se completó.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El `body` delegado se invoca una vez para cada elemento de la `source` enumerable. Se proporciona con los siguientes parámetros: el elemento actual, un <xref:System.Threading.Tasks.ParallelLoopState> instancia que puede utilizarse para salir del bucle prematuramente y algún estado local, que se puede compartir entre las iteraciones que se ejecutan en el mismo subproceso.  
  
 El `localInit` delegado se invoca una vez para cada tarea que participa en la ejecución del bucle y devuelve el estado local inicial para cada una de esas tareas. Estos estados iniciales se pasan a la primera `body` las invocaciones de cada tarea. A continuación, cada invocación de cuerpo subsiguiente devuelve un valor de estado posiblemente modificado que se pasa a la siguiente invocación de cuerpo. Por último, la última invocación de cuerpo en cada tarea devuelve un valor de estado que se pasa a la `localFinally` delegar. El `localFinally` delegado se invoca una vez por subproceso para realizar una acción final en el estado local de cada tarea. Este delegado se podría invocar simultáneamente en varias tareas; por lo tanto, se debe sincronizar el acceso a cualquier variable compartida.  
  
 El <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> método puede usar más tareas que los subprocesos durante la vigencia de su ejecución, como las tareas existentes completadas y se reemplazan con nuevas tareas. Esto proporciona subyacente <xref:System.Threading.Tasks.TaskScheduler> objeto la oportunidad de agregar, cambiar o quitar los subprocesos que dan servicio el bucle.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El argumento <paramref name="source" /> es <see langword="null" />.  
  
O bien 
El argumento <paramref name="parallelOptions" /> es <see langword="null" />.  
  
O bien 
El argumento <paramref name="body" /> es <see langword="null" />.  
  
O bien 
El argumento <paramref name="localInit" /> es <see langword="null" />.  
  
O bien 
El argumento <paramref name="localFinally" /> es <see langword="null" />.</exception>
        <exception cref="T:System.OperationCanceledException">
          <see cref="T:System.Threading.CancellationToken" /> en el argumento <paramref name="parallelOptions" /> se cancela.</exception>
        <exception cref="T:System.ObjectDisposedException">El objeto <see cref="T:System.Threading.CancellationTokenSource" /> asociado a <see cref="T:System.Threading.CancellationToken" /> en el <paramref name="parallelOptions" /> se ha desechado.</exception>
        <exception cref="T:System.AggregateException">La excepción que contiene todas las excepciones individuales producidas en todos los subprocesos.</exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)">Bucles paralelos</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Invoke">
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Ejecuta cada una de las acciones proporcionadas, posiblemente en paralelo.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Invoke">
      <MemberSignature Language="C#" Value="public static void Invoke (params Action[] actions);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Invoke(class System.Action[] actions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.Invoke(System.Action[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Invoke (ParamArray actions As Action())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Invoke(... cli::array &lt;Action ^&gt; ^ actions);" />
      <MemberSignature Language="F#" Value="static member Invoke : Action[] -&gt; unit" Usage="System.Threading.Tasks.Parallel.Invoke actions" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="actions" Type="System.Action[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="actions">Matriz de <see cref="T:System.Action" /> que se va a ejecutar.</param>
        <summary>Ejecuta cada una de las acciones proporcionadas, posiblemente en paralelo.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método puede utilizarse para ejecutar un conjunto de operaciones, potencialmente en paralelo.  
  
 Hay ninguna garantía sobre el orden en que se ejecutan las operaciones o si se ejecutan en paralelo. Este método no devuelve hasta que se ha completado cada una de las operaciones proporcionadas, independientemente de si se produce la finalización debido a la terminación normal o excepcional.  
  
 Para más información, consulte [How to: Use Parallel.Invoke to Execute Parallel Operations](~/docs/standard/parallel-programming/how-to-use-parallel-invoke-to-execute-parallel-operations.md) (Usar Parallel.Invoke para ejecutar operaciones paralelas).  
  
   
  
## Examples  
 Este ejemplo muestra cómo usar el <xref:System.Threading.Tasks.Parallel.Invoke%2A> método con otros métodos, delegados anónimos y expresiones lambda.  
  
 [!code-csharp[System.Threading.Tasks.Parallel#01](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.parallel/cs/parallelinvoke.cs#01)]
 [!code-vb[System.Threading.Tasks.Parallel#01](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.parallel/vb/parallelinvoke.vb#01)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El argumento <paramref name="actions" /> es <see langword="null" />.</exception>
        <exception cref="T:System.AggregateException">La excepción que se produce cuando cualquier acción de la matriz <paramref name="actions" /> produce una excepción.</exception>
        <exception cref="T:System.ArgumentException">La matriz <paramref name="actions" /> contiene un elemento <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Invoke">
      <MemberSignature Language="C#" Value="public static void Invoke (System.Threading.Tasks.ParallelOptions parallelOptions, params Action[] actions);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Invoke(class System.Threading.Tasks.ParallelOptions parallelOptions, class System.Action[] actions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.Invoke(System.Threading.Tasks.ParallelOptions,System.Action[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Invoke(System::Threading::Tasks::ParallelOptions ^ parallelOptions, ... cli::array &lt;Action ^&gt; ^ actions);" />
      <MemberSignature Language="F#" Value="static member Invoke : System.Threading.Tasks.ParallelOptions * Action[] -&gt; unit" Usage="System.Threading.Tasks.Parallel.Invoke (parallelOptions, actions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="parallelOptions" Type="System.Threading.Tasks.ParallelOptions" />
        <Parameter Name="actions" Type="System.Action[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="parallelOptions">Objeto que configura el comportamiento de esta operación.</param>
        <param name="actions">Matriz de acciones que se va a ejecutar.</param>
        <summary>Ejecuta todas las acciones proporcionadas, posiblemente en paralelo, a menos que el usuario cancele la operación.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método puede utilizarse para ejecutar un conjunto de operaciones, potencialmente en paralelo. El token de cancelación pasado con la <xref:System.Threading.Tasks.ParallelOptions> estructura permite que el llamador cancelar la operación completa. Para más información, consulte el tema sobre la [cancelación en subprocesos administrados](~/docs/standard/threading/cancellation-in-managed-threads.md).  
  
 Hay ninguna garantía sobre el orden en que se ejecutan las operaciones o si se ejecutan en paralelo. Este método no devuelve hasta que se ha completado cada una de las operaciones proporcionadas, independientemente de si se produce la finalización debido a la terminación normal o excepcional.  
  
 Para más información, consulte [How to: Use Parallel.Invoke to Execute Parallel Operations](~/docs/standard/parallel-programming/how-to-use-parallel-invoke-to-execute-parallel-operations.md) (Usar Parallel.Invoke para ejecutar operaciones paralelas).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OperationCanceledException">
          <see cref="T:System.Threading.CancellationToken" /> en el estado <paramref name="parallelOptions" /> está establecido.</exception>
        <exception cref="T:System.ArgumentNullException">El argumento <paramref name="actions" /> es <see langword="null" />.  
  
O bien 
El argumento <paramref name="parallelOptions" /> es <see langword="null" />.</exception>
        <exception cref="T:System.AggregateException">La excepción que se produce cuando cualquier acción de la matriz <paramref name="actions" /> produce una excepción.</exception>
        <exception cref="T:System.ArgumentException">La matriz <paramref name="actions" /> contiene un elemento <see langword="null" />.</exception>
        <exception cref="T:System.ObjectDisposedException">El objeto <see cref="T:System.Threading.CancellationTokenSource" /> asociado a <see cref="T:System.Threading.CancellationToken" /> en el <paramref name="parallelOptions" /> se ha desechado.</exception>
      </Docs>
    </Member>
  </Members>
</Type>