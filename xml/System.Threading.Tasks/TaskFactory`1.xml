<Type Name="TaskFactory&lt;TResult&gt;" FullName="System.Threading.Tasks.TaskFactory&lt;TResult&gt;">
  <Metadata><Meta Name="ms.openlocfilehash" Value="2bbeeeb5bf160353ac83c36cf8e6ef6f628a0c25" /><Meta Name="ms.sourcegitcommit" Value="bc24a3ba616ee1df8b858f9400cae4f058ea3a7e" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="es-ES" /><Meta Name="ms.lasthandoff" Value="06/19/2019" /><Meta Name="ms.locfileid" Value="67243445" /></Metadata><TypeSignature Language="C#" Value="public class TaskFactory&lt;TResult&gt;" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit TaskFactory`1&lt;TResult&gt; extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Threading.Tasks.TaskFactory`1" />
  <TypeSignature Language="VB.NET" Value="Public Class TaskFactory(Of TResult)" />
  <TypeSignature Language="C++ CLI" Value="generic &lt;typename TResult&gt;&#xA;public ref class TaskFactory" />
  <TypeSignature Language="F#" Value="type TaskFactory&lt;'Result&gt; = class" />
  <AssemblyInfo>
    <AssemblyName>System.Threading.Tasks</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <TypeParameters>
    <TypeParameter Name="TResult" />
  </TypeParameters>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <typeparam name="TResult">Valor devuelto de los objetos <see cref="T:System.Threading.Tasks.Task`1" /> creados por los métodos de esta clase.</typeparam>
    <summary>Proporciona compatibilidad para crear y programar objetos <see cref="T:System.Threading.Tasks.Task`1" />.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 .NET Framework proporciona dos factorías para crear y programar tareas:  
  
-   El <xref:System.Threading.Tasks.TaskFactory> (clase), que crea <xref:System.Threading.Tasks.Task> y <xref:System.Threading.Tasks.Task%601> objetos.  
  
-   El <xref:System.Threading.Tasks.TaskFactory%601> (clase), que crea <xref:System.Threading.Tasks.Task%601> objetos.  
  
 La <xref:System.Threading.Tasks.TaskFactory%601> clase le permite hacer lo siguiente:  
  
-   Crear una tarea e inícielo inmediatamente mediante una llamada a la <xref:System.Threading.Tasks.TaskFactory.StartNew%2A> método. Puede llamar a las sobrecargas de este método para crear y ejecutar una tarea que requiere argumentos no predeterminados.  
  
    > [!WARNING]
    >  A partir de la [!INCLUDE[net_v45](~/includes/net-v45-md.md)], el <xref:System.Threading.Tasks.Task.Run%2A?displayProperty=nameWithType> método proporciona la manera más fácil de crear una tarea no tiene valor predeterminado de los valores de configuración y la inicia inmediatamente.  
  
-   Crear una tarea que se inicia cuando se ha completado cualquiera de las tareas en una matriz mediante una llamada a la <xref:System.Threading.Tasks.TaskFactory.ContinueWhenAny%2A> o <xref:System.Threading.Tasks.TaskFactory.ContinueWhenAny%2A> método.  
  
-   Crear una tarea que se inicia cuando se hayan completado todas las tareas en una matriz mediante una llamada a la <xref:System.Threading.Tasks.TaskFactory.ContinueWhenAll%2A> o <xref:System.Threading.Tasks.TaskFactory.ContinueWhenAll%2A> método.  
  
 Estático <xref:System.Threading.Tasks.Task%601.Factory%2A?displayProperty=nameWithType> propiedad devuelve el valor predeterminado es <xref:System.Threading.Tasks.TaskFactory%601> objeto. También puede llamar a uno de los <xref:System.Threading.Tasks.TaskFactory%601> clase constructores para configurar el <xref:System.Threading.Tasks.Task%601> objetos que el <xref:System.Threading.Tasks.TaskFactory%601> crea la clase. En el ejemplo siguiente se configura un nuevo <xref:System.Threading.Tasks.TaskFactory%601> objeto para crear tareas que tienen un token de cancelación indicado, opciones de creación de tareas, las opciones de continuación y un programador de tareas personalizado.  
  
 [!code-csharp[TPL_Factories#2](~/samples/snippets/csharp/VS_Snippets_Misc/tpl_factories/cs/factoriestresult.cs#2)]
 [!code-vb[TPL_Factories#2](~/samples/snippets/visualbasic/VS_Snippets_Misc/tpl_factories/vb/factoriestresult.vb#2)]  
  
 En la mayoría de los casos, no es necesario crear una nueva instancia <xref:System.Threading.Tasks.TaskFactory%601> instancia. En su lugar, puede usar estático <xref:System.Threading.Tasks.Task%601.Factory%2A?displayProperty=nameWithType> propiedad, que devuelve un objeto de fábrica que utiliza valores predeterminados. A continuación, puede llamar a sus métodos para iniciar nuevas tareas o definir las continuaciones de tareas. Para obtener un ejemplo, vea el ejemplo.  
  
   
  
## Examples  
 En el ejemplo siguiente se usa estático <xref:System.Threading.Tasks.Task%601.Factory%2A> propiedad para realizar dos llamadas a la <xref:System.Threading.Tasks.TaskFactory%601.StartNew%2A?displayProperty=nameWithType> método. La primera tarea devuelve una matriz de cadenas que se rellena con los nombres de archivos en el directorio Mis documentos del usuario, mientras que el segundo devuelve una matriz de cadenas que se rellena con los nombres de los subdirectorios del directorio de Mis documentos del usuario. A continuación, llama el <xref:System.Threading.Tasks.TaskFactory.ContinueWhenAll%28System.Threading.Tasks.Task%5B%5D%2CSystem.Action%7BSystem.Threading.Tasks.Task%5B%5D%7D%29?displayProperty=nameWithType> método, que muestra información sobre el número de archivos y directorios en las matrices devueltas por las dos tareas una vez que haya completado la ejecución.  
  
 [!code-csharp[System.Threading.Tasks.Task.Factory#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.factory/cs/factory2.cs#2)]
 [!code-vb[System.Threading.Tasks.Task.Factory#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.factory/vb/factory2.vb#2)]  
  
 ]]></format>
    </remarks>
    <threadsafe>Todos los miembros públicos y protegidos de <see cref="T:System.Threading.Tasks.TaskFactory`1" /> son seguros para subprocesos y se pueden usar simultáneamente desde varios subprocesos.</threadsafe>
    <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">Biblioteca de procesamiento paralelo basado en tareas (TPL)</related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inicializa una instancia de <see cref="T:System.Threading.Tasks.TaskFactory`1" />.</summary>
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">Biblioteca de procesamiento paralelo basado en tareas (TPL)</related>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public TaskFactory ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory`1.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; TaskFactory();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inicializa una instancia de <see cref="T:System.Threading.Tasks.TaskFactory`1" /> con la configuración predeterminada.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este constructor crea un <xref:System.Threading.Tasks.TaskFactory%601> instancia con una configuración predeterminada. El <xref:System.Threading.Tasks.TaskCreationOptions> propiedad se inicializa en <xref:System.Threading.Tasks.TaskCreationOptions.None>, el <xref:System.Threading.Tasks.TaskContinuationOptions> propiedad se inicializa en <xref:System.Threading.Tasks.TaskContinuationOptions.None>y el <xref:System.Threading.Tasks.TaskScheduler> propiedad se inicializa en el programador actual (vea <xref:System.Threading.Tasks.TaskScheduler.Current%2A>).  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">Biblioteca de procesamiento paralelo basado en tareas (TPL)</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public TaskFactory (System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory`1.#ctor(System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; TaskFactory(System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="new System.Threading.Tasks.TaskFactory&lt;'Result&gt; : System.Threading.CancellationToken -&gt; System.Threading.Tasks.TaskFactory&lt;'Result&gt;" Usage="new System.Threading.Tasks.TaskFactory&lt;'Result&gt; cancellationToken" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="cancellationToken">Token de cancelación predeterminado que se asignará a las tareas creadas por este objeto <see cref="T:System.Threading.Tasks.TaskFactory" /> a menos que se especifique otro token de cancelación de forma explícita cuando se llama a los métodos de generador.</param>
        <summary>Inicializa una instancia de <see cref="T:System.Threading.Tasks.TaskFactory`1" /> con la configuración predeterminada.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este constructor crea un <xref:System.Threading.Tasks.TaskFactory%601> instancia con una configuración predeterminada. El <xref:System.Threading.Tasks.TaskCreationOptions> propiedad se inicializa en <xref:System.Threading.Tasks.TaskCreationOptions.None>, el <xref:System.Threading.Tasks.TaskContinuationOptions> propiedad se inicializa en <xref:System.Threading.Tasks.TaskContinuationOptions.None>y el <xref:System.Threading.Tasks.TaskScheduler> propiedad se inicializa en el programador actual (vea <xref:System.Threading.Tasks.TaskScheduler.Current%2A>).  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">Biblioteca de procesamiento paralelo basado en tareas (TPL)</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public TaskFactory (System.Threading.Tasks.TaskScheduler scheduler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Threading.Tasks.TaskScheduler scheduler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory`1.#ctor(System.Threading.Tasks.TaskScheduler)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (scheduler As TaskScheduler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; TaskFactory(System::Threading::Tasks::TaskScheduler ^ scheduler);" />
      <MemberSignature Language="F#" Value="new System.Threading.Tasks.TaskFactory&lt;'Result&gt; : System.Threading.Tasks.TaskScheduler -&gt; System.Threading.Tasks.TaskFactory&lt;'Result&gt;" Usage="new System.Threading.Tasks.TaskFactory&lt;'Result&gt; scheduler" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="scheduler" Type="System.Threading.Tasks.TaskScheduler" />
      </Parameters>
      <Docs>
        <param name="scheduler">Programador que se va a usar para programar las tareas creadas con este objeto <see cref="T:System.Threading.Tasks.TaskFactory`1" />. Un valor null indica que se debería usar el objeto <see cref="T:System.Threading.Tasks.TaskScheduler" /> actual.</param>
        <summary>Inicializa una instancia de <see cref="T:System.Threading.Tasks.TaskFactory`1" /> con la configuración especificada.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Con este constructor, el <xref:System.Threading.Tasks.TaskCreationOptions> propiedad se inicializa en <xref:System.Threading.Tasks.TaskCreationOptions.None>, el <xref:System.Threading.Tasks.TaskContinuationOptions> propiedad se inicializa en <xref:System.Threading.Tasks.TaskContinuationOptions.None>y el <xref:System.Threading.Tasks.TaskScheduler> propiedad se inicializa en `scheduler`, a menos que tenga `null`, en cuyo caso la propiedad se inicializa en el programador actual (vea <xref:System.Threading.Tasks.TaskScheduler.Current%2A>).  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Threading.Tasks.TaskScheduler" />
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">Biblioteca de procesamiento paralelo basado en tareas (TPL)</related>
        <related type="Article" href="~/docs/standard/parallel-programming/chaining-tasks-by-using-continuation-tasks.md">Encadenar tareas mediante tareas de continuación</related>
        <related type="Article" href="~/docs/standard/parallel-programming/task-cancellation.md">Cancelación de tareas</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public TaskFactory (System.Threading.Tasks.TaskCreationOptions creationOptions, System.Threading.Tasks.TaskContinuationOptions continuationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(valuetype System.Threading.Tasks.TaskCreationOptions creationOptions, valuetype System.Threading.Tasks.TaskContinuationOptions continuationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory`1.#ctor(System.Threading.Tasks.TaskCreationOptions,System.Threading.Tasks.TaskContinuationOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (creationOptions As TaskCreationOptions, continuationOptions As TaskContinuationOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; TaskFactory(System::Threading::Tasks::TaskCreationOptions creationOptions, System::Threading::Tasks::TaskContinuationOptions continuationOptions);" />
      <MemberSignature Language="F#" Value="new System.Threading.Tasks.TaskFactory&lt;'Result&gt; : System.Threading.Tasks.TaskCreationOptions * System.Threading.Tasks.TaskContinuationOptions -&gt; System.Threading.Tasks.TaskFactory&lt;'Result&gt;" Usage="new System.Threading.Tasks.TaskFactory&lt;'Result&gt; (creationOptions, continuationOptions)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="creationOptions" Type="System.Threading.Tasks.TaskCreationOptions" />
        <Parameter Name="continuationOptions" Type="System.Threading.Tasks.TaskContinuationOptions" />
      </Parameters>
      <Docs>
        <param name="creationOptions">Opciones predeterminadas que se van a usar al crear tareas con este objeto <see cref="T:System.Threading.Tasks.TaskFactory`1" />.</param>
        <param name="continuationOptions">Opciones predeterminadas que se van a usar al crear tareas de continuación con este objeto <see cref="T:System.Threading.Tasks.TaskFactory`1" />.</param>
        <summary>Inicializa una instancia de <see cref="T:System.Threading.Tasks.TaskFactory`1" /> con la configuración especificada.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Con este constructor, el <xref:System.Threading.Tasks.TaskCreationOptions> propiedad se inicializa en `creationOptions`, el <xref:System.Threading.Tasks.TaskContinuationOptions> propiedad se inicializa en `continuationOptions`y el <xref:System.Threading.Tasks.TaskScheduler> propiedad se inicializa en el programador actual (vea <xref:System.Threading.Tasks.TaskScheduler.Current%2A>).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="creationOptions" /> o <paramref name="continuationOptions" /> especifica un valor no válido.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">Biblioteca de procesamiento paralelo basado en tareas (TPL)</related>
        <related type="Article" href="~/docs/standard/parallel-programming/chaining-tasks-by-using-continuation-tasks.md">Encadenar tareas mediante tareas de continuación</related>
        <related type="Article" href="~/docs/standard/parallel-programming/task-cancellation.md">Cancelación de tareas</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public TaskFactory (System.Threading.CancellationToken cancellationToken, System.Threading.Tasks.TaskCreationOptions creationOptions, System.Threading.Tasks.TaskContinuationOptions continuationOptions, System.Threading.Tasks.TaskScheduler scheduler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(valuetype System.Threading.CancellationToken cancellationToken, valuetype System.Threading.Tasks.TaskCreationOptions creationOptions, valuetype System.Threading.Tasks.TaskContinuationOptions continuationOptions, class System.Threading.Tasks.TaskScheduler scheduler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory`1.#ctor(System.Threading.CancellationToken,System.Threading.Tasks.TaskCreationOptions,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; TaskFactory(System::Threading::CancellationToken cancellationToken, System::Threading::Tasks::TaskCreationOptions creationOptions, System::Threading::Tasks::TaskContinuationOptions continuationOptions, System::Threading::Tasks::TaskScheduler ^ scheduler);" />
      <MemberSignature Language="F#" Value="new System.Threading.Tasks.TaskFactory&lt;'Result&gt; : System.Threading.CancellationToken * System.Threading.Tasks.TaskCreationOptions * System.Threading.Tasks.TaskContinuationOptions * System.Threading.Tasks.TaskScheduler -&gt; System.Threading.Tasks.TaskFactory&lt;'Result&gt;" Usage="new System.Threading.Tasks.TaskFactory&lt;'Result&gt; (cancellationToken, creationOptions, continuationOptions, scheduler)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        <Parameter Name="creationOptions" Type="System.Threading.Tasks.TaskCreationOptions" />
        <Parameter Name="continuationOptions" Type="System.Threading.Tasks.TaskContinuationOptions" />
        <Parameter Name="scheduler" Type="System.Threading.Tasks.TaskScheduler" />
      </Parameters>
      <Docs>
        <param name="cancellationToken">Token de cancelación predeterminado que se asignará a las tareas creadas por este objeto <see cref="T:System.Threading.Tasks.TaskFactory" /> a menos que se especifique otro token de cancelación de forma explícita cuando se llama a los métodos de generador.</param>
        <param name="creationOptions">Opciones predeterminadas que se van a usar al crear tareas con este objeto <see cref="T:System.Threading.Tasks.TaskFactory`1" />.</param>
        <param name="continuationOptions">Opciones predeterminadas que se van a usar al crear tareas de continuación con este objeto <see cref="T:System.Threading.Tasks.TaskFactory`1" />.</param>
        <param name="scheduler">Programador predeterminado que se va a usar para programar las tareas creadas con <see cref="T:System.Threading.Tasks.TaskFactory`1" />. Un valor null indica que la propiedad <see cref="P:System.Threading.Tasks.TaskScheduler.Current" /> se debe utilizar.</param>
        <summary>Inicializa una instancia de <see cref="T:System.Threading.Tasks.TaskFactory`1" /> con la configuración especificada.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Con este constructor, el <xref:System.Threading.Tasks.TaskCreationOptions> propiedad se inicializa en `creationOptions`, el <xref:System.Threading.Tasks.TaskContinuationOptions> propiedad se inicializa en `continuationOptions`y el <xref:System.Threading.Tasks.TaskScheduler> propiedad se inicializa en `scheduler`, a menos que tenga `null`, en cuyo caso la propiedad se inicializa en el programador actual (vea <xref:System.Threading.Tasks.TaskScheduler.Current%2A>).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="creationOptions" /> o <paramref name="continuationOptions" /> especifica un valor no válido.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">Biblioteca de procesamiento paralelo basado en tareas (TPL)</related>
        <related type="Article" href="~/docs/standard/parallel-programming/chaining-tasks-by-using-continuation-tasks.md">Encadenar tareas mediante tareas de continuación</related>
        <related type="Article" href="~/docs/standard/parallel-programming/task-cancellation.md">Cancelación de tareas</related>
      </Docs>
    </Member>
    <Member MemberName="CancellationToken">
      <MemberSignature Language="C#" Value="public System.Threading.CancellationToken CancellationToken { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Threading.CancellationToken CancellationToken" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.TaskFactory`1.CancellationToken" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CancellationToken As CancellationToken" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Threading::CancellationToken CancellationToken { System::Threading::CancellationToken get(); };" />
      <MemberSignature Language="F#" Value="member this.CancellationToken : System.Threading.CancellationToken" Usage="System.Threading.Tasks.TaskFactory&lt;'Result&gt;.CancellationToken" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.CancellationToken</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene el token de cancelación predeterminado para este generador de tareas.</summary>
        <value>El token de cancelación predeterminado para este generador de tareas.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esta propiedad devuelve el token de cancelación predeterminado que se asignará a todas las tareas creadas por este generador, a menos que otro valor del token de cancelación se especifica explícitamente durante la llamada a los métodos de generador de tareas.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">Biblioteca de procesamiento paralelo basado en tareas (TPL)</related>
        <related type="Article" href="~/docs/standard/parallel-programming/using-tpl-with-other-asynchronous-patterns.md">Usar TPL con otros patrones asincrónicos</related>
      </Docs>
    </Member>
    <Member MemberName="ContinuationOptions">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.TaskContinuationOptions ContinuationOptions { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Threading.Tasks.TaskContinuationOptions ContinuationOptions" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.TaskFactory`1.ContinuationOptions" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ContinuationOptions As TaskContinuationOptions" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Threading::Tasks::TaskContinuationOptions ContinuationOptions { System::Threading::Tasks::TaskContinuationOptions get(); };" />
      <MemberSignature Language="F#" Value="member this.ContinuationOptions : System.Threading.Tasks.TaskContinuationOptions" Usage="System.Threading.Tasks.TaskFactory&lt;'Result&gt;.ContinuationOptions" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.TaskContinuationOptions</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene el valor de enumeración <see cref="T:System.Threading.Tasks.TaskContinuationOptions" /> para este generador de tareas.</summary>
        <value>Uno de los valores de enumeración que especifica las opciones de continuación predeterminadas para este generador de tareas.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esta propiedad devuelve el valor predeterminado de opciones de continuación para este generador. Se utilizará para crear todas las tareas de continuación a menos que se especifiquen explícitamente otras opciones durante las llamadas a métodos de este generador.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">Biblioteca de procesamiento paralelo basado en tareas (TPL)</related>
        <related type="Article" href="~/docs/standard/parallel-programming/using-tpl-with-other-asynchronous-patterns.md">Usar TPL con otros patrones asincrónicos</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="ContinueWhenAll">
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Crea una tarea de continuación que se iniciará cuando se complete el conjunto de tareas proporcionado.</summary>
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">Biblioteca de procesamiento paralelo basado en tareas (TPL)</related>
        <related type="Article" href="~/docs/standard/parallel-programming/chaining-tasks-by-using-continuation-tasks.md">Encadenar tareas mediante tareas de continuación</related>
        <related type="Article" href="~/docs/standard/parallel-programming/task-cancellation.md">Cancelación de tareas</related>
      </Docs>
    </MemberGroup>
    <Member MemberName="ContinueWhenAll">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; ContinueWhenAll (System.Threading.Tasks.Task[] tasks, Func&lt;System.Threading.Tasks.Task[],TResult&gt; continuationFunction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!TResult&gt; ContinueWhenAll(class System.Threading.Tasks.Task[] tasks, class System.Func`2&lt;class System.Threading.Tasks.Task[], !TResult&gt; continuationFunction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory`1.ContinueWhenAll(System.Threading.Tasks.Task[],System.Func{System.Threading.Tasks.Task[],`0})" />
      <MemberSignature Language="VB.NET" Value="Public Function ContinueWhenAll (tasks As Task(), continuationFunction As Func(Of Task(), TResult)) As Task(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task&lt;TResult&gt; ^ ContinueWhenAll(cli::array &lt;System::Threading::Tasks::Task ^&gt; ^ tasks, Func&lt;cli::array &lt;System::Threading::Tasks::Task ^&gt; ^, TResult&gt; ^ continuationFunction);" />
      <MemberSignature Language="F#" Value="member this.ContinueWhenAll : System.Threading.Tasks.Task[] * Func&lt;System.Threading.Tasks.Task[], 'Result&gt; -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="taskFactory.ContinueWhenAll (tasks, continuationFunction)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task[]" />
        <Parameter Name="continuationFunction" Type="System.Func&lt;System.Threading.Tasks.Task[],TResult&gt;" />
      </Parameters>
      <Docs>
        <param name="tasks">Matriz de las tareas a partir de las cuales se va a continuar.</param>
        <param name="continuationFunction">Delegado de función que se va a ejecutar asincrónicamente cuando se completen todas las tareas de la matriz <paramref name="tasks" />.</param>
        <summary>Crea una tarea de continuación que se iniciará cuando se complete el conjunto de tareas proporcionado.</summary>
        <returns>Nueva tarea de continuación.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cuando haya finalizado, una tarea está en uno de estos estados: <xref:System.Threading.Tasks.TaskStatus.RanToCompletion>, <xref:System.Threading.Tasks.TaskStatus.Faulted>, o <xref:System.Threading.Tasks.TaskStatus.Canceled> Estados.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Uno de los elementos de la matriz <paramref name="tasks" /> se ha eliminado.</exception>
        <exception cref="T:System.ArgumentNullException">La matriz <paramref name="tasks" /> es <see langword="null" />.  
  
O bien 
El valor de <paramref name="continuationFunction" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">La matriz <paramref name="tasks" /> contiene un valor null o está vacío.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">Biblioteca de procesamiento paralelo basado en tareas (TPL)</related>
        <related type="Article" href="~/docs/standard/parallel-programming/chaining-tasks-by-using-continuation-tasks.md">Encadenar tareas mediante tareas de continuación</related>
        <related type="Article" href="~/docs/standard/parallel-programming/task-cancellation.md">Cancelación de tareas</related>
      </Docs>
    </Member>
    <Member MemberName="ContinueWhenAll">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; ContinueWhenAll (System.Threading.Tasks.Task[] tasks, Func&lt;System.Threading.Tasks.Task[],TResult&gt; continuationFunction, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!TResult&gt; ContinueWhenAll(class System.Threading.Tasks.Task[] tasks, class System.Func`2&lt;class System.Threading.Tasks.Task[], !TResult&gt; continuationFunction, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory`1.ContinueWhenAll(System.Threading.Tasks.Task[],System.Func{System.Threading.Tasks.Task[],`0},System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task&lt;TResult&gt; ^ ContinueWhenAll(cli::array &lt;System::Threading::Tasks::Task ^&gt; ^ tasks, Func&lt;cli::array &lt;System::Threading::Tasks::Task ^&gt; ^, TResult&gt; ^ continuationFunction, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="member this.ContinueWhenAll : System.Threading.Tasks.Task[] * Func&lt;System.Threading.Tasks.Task[], 'Result&gt; * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="taskFactory.ContinueWhenAll (tasks, continuationFunction, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task[]" />
        <Parameter Name="continuationFunction" Type="System.Func&lt;System.Threading.Tasks.Task[],TResult&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="tasks">Matriz de las tareas a partir de las cuales se va a continuar.</param>
        <param name="continuationFunction">Delegado de función que se va a ejecutar asincrónicamente cuando se completen todas las tareas de la matriz <paramref name="tasks" />.</param>
        <param name="cancellationToken">Token de cancelación que se va a asignar a la nueva tarea de continuación.</param>
        <summary>Crea una tarea de continuación que se iniciará cuando se complete el conjunto de tareas proporcionado.</summary>
        <returns>Nueva tarea de continuación.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cuando haya finalizado, una tarea está en uno de estos estados: <xref:System.Threading.Tasks.TaskStatus.RanToCompletion>, <xref:System.Threading.Tasks.TaskStatus.Faulted>, o <xref:System.Threading.Tasks.TaskStatus.Canceled> Estados.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Uno de los elementos de la matriz <paramref name="tasks" /> se ha eliminado.  
  
O bien 
El <see cref="T:System.Threading.CancellationTokenSource" /> que creó <paramref name="cancellationToken" /> ya se ha eliminado.</exception>
        <exception cref="T:System.ArgumentNullException">La matriz <paramref name="tasks" /> está <see langword="null" />.  
  
O bien 
 <paramref name="continuationFunction" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">La matriz <paramref name="tasks" /> contiene un valor null o está vacío.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">Biblioteca de procesamiento paralelo basado en tareas (TPL)</related>
        <related type="Article" href="~/docs/standard/parallel-programming/chaining-tasks-by-using-continuation-tasks.md">Encadenar tareas mediante tareas de continuación</related>
        <related type="Article" href="~/docs/standard/parallel-programming/task-cancellation.md">Cancelación de tareas</related>
      </Docs>
    </Member>
    <Member MemberName="ContinueWhenAll">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; ContinueWhenAll (System.Threading.Tasks.Task[] tasks, Func&lt;System.Threading.Tasks.Task[],TResult&gt; continuationFunction, System.Threading.Tasks.TaskContinuationOptions continuationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!TResult&gt; ContinueWhenAll(class System.Threading.Tasks.Task[] tasks, class System.Func`2&lt;class System.Threading.Tasks.Task[], !TResult&gt; continuationFunction, valuetype System.Threading.Tasks.TaskContinuationOptions continuationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory`1.ContinueWhenAll(System.Threading.Tasks.Task[],System.Func{System.Threading.Tasks.Task[],`0},System.Threading.Tasks.TaskContinuationOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function ContinueWhenAll (tasks As Task(), continuationFunction As Func(Of Task(), TResult), continuationOptions As TaskContinuationOptions) As Task(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task&lt;TResult&gt; ^ ContinueWhenAll(cli::array &lt;System::Threading::Tasks::Task ^&gt; ^ tasks, Func&lt;cli::array &lt;System::Threading::Tasks::Task ^&gt; ^, TResult&gt; ^ continuationFunction, System::Threading::Tasks::TaskContinuationOptions continuationOptions);" />
      <MemberSignature Language="F#" Value="member this.ContinueWhenAll : System.Threading.Tasks.Task[] * Func&lt;System.Threading.Tasks.Task[], 'Result&gt; * System.Threading.Tasks.TaskContinuationOptions -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="taskFactory.ContinueWhenAll (tasks, continuationFunction, continuationOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task[]" />
        <Parameter Name="continuationFunction" Type="System.Func&lt;System.Threading.Tasks.Task[],TResult&gt;" />
        <Parameter Name="continuationOptions" Type="System.Threading.Tasks.TaskContinuationOptions" />
      </Parameters>
      <Docs>
        <param name="tasks">Matriz de las tareas a partir de las cuales se va a continuar.</param>
        <param name="continuationFunction">Delegado de función que se va a ejecutar asincrónicamente cuando se completen todas las tareas de la matriz <paramref name="tasks" />.</param>
        <param name="continuationOptions">Uno de los valores de enumeración que controla el comportamiento de la tarea de continuación creada. Los valores <see langword="NotOn*" /> y <see langword="OnlyOn*" /> no son válidos.</param>
        <summary>Crea una tarea de continuación que se iniciará cuando se complete el conjunto de tareas proporcionado.</summary>
        <returns>Nueva tarea de continuación.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cuando haya finalizado, una tarea está en uno de estos estados: <xref:System.Threading.Tasks.TaskStatus.RanToCompletion>, <xref:System.Threading.Tasks.TaskStatus.Faulted>, o <xref:System.Threading.Tasks.TaskStatus.Canceled> Estados.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Uno de los elementos de la matriz <paramref name="tasks" /> se ha eliminado.</exception>
        <exception cref="T:System.ArgumentNullException">La matriz <paramref name="tasks" /> está <see langword="null" />.  
  
O bien 
El argumento <paramref name="continuationFunction" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">El argumento <paramref name="continuationOptions" /> especifica un valor no válido.</exception>
        <exception cref="T:System.ArgumentException">La matriz <paramref name="tasks" /> contiene un valor null o está vacío.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">Biblioteca de procesamiento paralelo basado en tareas (TPL)</related>
        <related type="Article" href="~/docs/standard/parallel-programming/chaining-tasks-by-using-continuation-tasks.md">Encadenar tareas mediante tareas de continuación</related>
        <related type="Article" href="~/docs/standard/parallel-programming/task-cancellation.md">Cancelación de tareas</related>
      </Docs>
    </Member>
    <Member MemberName="ContinueWhenAll">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; ContinueWhenAll (System.Threading.Tasks.Task[] tasks, Func&lt;System.Threading.Tasks.Task[],TResult&gt; continuationFunction, System.Threading.CancellationToken cancellationToken, System.Threading.Tasks.TaskContinuationOptions continuationOptions, System.Threading.Tasks.TaskScheduler scheduler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!TResult&gt; ContinueWhenAll(class System.Threading.Tasks.Task[] tasks, class System.Func`2&lt;class System.Threading.Tasks.Task[], !TResult&gt; continuationFunction, valuetype System.Threading.CancellationToken cancellationToken, valuetype System.Threading.Tasks.TaskContinuationOptions continuationOptions, class System.Threading.Tasks.TaskScheduler scheduler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory`1.ContinueWhenAll(System.Threading.Tasks.Task[],System.Func{System.Threading.Tasks.Task[],`0},System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task&lt;TResult&gt; ^ ContinueWhenAll(cli::array &lt;System::Threading::Tasks::Task ^&gt; ^ tasks, Func&lt;cli::array &lt;System::Threading::Tasks::Task ^&gt; ^, TResult&gt; ^ continuationFunction, System::Threading::CancellationToken cancellationToken, System::Threading::Tasks::TaskContinuationOptions continuationOptions, System::Threading::Tasks::TaskScheduler ^ scheduler);" />
      <MemberSignature Language="F#" Value="member this.ContinueWhenAll : System.Threading.Tasks.Task[] * Func&lt;System.Threading.Tasks.Task[], 'Result&gt; * System.Threading.CancellationToken * System.Threading.Tasks.TaskContinuationOptions * System.Threading.Tasks.TaskScheduler -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="taskFactory.ContinueWhenAll (tasks, continuationFunction, cancellationToken, continuationOptions, scheduler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task[]" />
        <Parameter Name="continuationFunction" Type="System.Func&lt;System.Threading.Tasks.Task[],TResult&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        <Parameter Name="continuationOptions" Type="System.Threading.Tasks.TaskContinuationOptions" />
        <Parameter Name="scheduler" Type="System.Threading.Tasks.TaskScheduler" />
      </Parameters>
      <Docs>
        <param name="tasks">Matriz de las tareas a partir de las cuales se va a continuar.</param>
        <param name="continuationFunction">Delegado de función que se va a ejecutar asincrónicamente cuando se completen todas las tareas de la matriz <paramref name="tasks" />.</param>
        <param name="cancellationToken">Token de cancelación que se va a asignar a la nueva tarea de continuación.</param>
        <param name="continuationOptions">Uno de los valores de enumeración que controla el comportamiento de la tarea de continuación creada. Los valores <see langword="NotOn*" /> y <see langword="OnlyOn*" /> no son válidos.</param>
        <param name="scheduler">Programador que se usa para programar la tarea de continuación creada.</param>
        <summary>Crea una tarea de continuación que se iniciará cuando se complete el conjunto de tareas proporcionado.</summary>
        <returns>Nueva tarea de continuación.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cuando haya finalizado, una tarea está en uno de estos estados: <xref:System.Threading.Tasks.TaskStatus.RanToCompletion>, <xref:System.Threading.Tasks.TaskStatus.Faulted>, o <xref:System.Threading.Tasks.TaskStatus.Canceled> Estados.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">La matriz <paramref name="tasks" /> está <see langword="null" />.  
  
O bien 
El argumento <paramref name="continuationFunction" /> es <see langword="null" />.  
  
O bien 
El argumento <paramref name="scheduler" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">La matriz <paramref name="tasks" /> contiene un valor null o está vacío.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="continuationOptions" /> especifica un valor no válido.</exception>
        <exception cref="T:System.ObjectDisposedException">Uno de los elementos de la matriz <paramref name="tasks" /> se ha eliminado.  
  
O bien 
El <see cref="T:System.Threading.CancellationTokenSource" /> que creó <paramref name="cancellationToken" /> ya se ha eliminado.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">Biblioteca de procesamiento paralelo basado en tareas (TPL)</related>
        <related type="Article" href="~/docs/standard/parallel-programming/chaining-tasks-by-using-continuation-tasks.md">Encadenar tareas mediante tareas de continuación</related>
        <related type="Article" href="~/docs/standard/parallel-programming/task-cancellation.md">Cancelación de tareas</related>
      </Docs>
    </Member>
    <Member MemberName="ContinueWhenAll&lt;TAntecedentResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; ContinueWhenAll&lt;TAntecedentResult&gt; (System.Threading.Tasks.Task&lt;TAntecedentResult&gt;[] tasks, Func&lt;System.Threading.Tasks.Task&lt;TAntecedentResult&gt;[],TResult&gt; continuationFunction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!TResult&gt; ContinueWhenAll&lt;TAntecedentResult&gt;(class System.Threading.Tasks.Task`1&lt;!!TAntecedentResult&gt;[] tasks, class System.Func`2&lt;class System.Threading.Tasks.Task`1&lt;!!TAntecedentResult&gt;[], !TResult&gt; continuationFunction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory`1.ContinueWhenAll``1(System.Threading.Tasks.Task{``0}[],System.Func{System.Threading.Tasks.Task{``0}[],`0})" />
      <MemberSignature Language="VB.NET" Value="Public Function ContinueWhenAll(Of TAntecedentResult) (tasks As Task(Of TAntecedentResult)(), continuationFunction As Func(Of Task(Of TAntecedentResult)(), TResult)) As Task(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TAntecedentResult&gt;&#xA; System::Threading::Tasks::Task&lt;TResult&gt; ^ ContinueWhenAll(cli::array &lt;System::Threading::Tasks::Task&lt;TAntecedentResult&gt; ^&gt; ^ tasks, Func&lt;cli::array &lt;System::Threading::Tasks::Task&lt;TAntecedentResult&gt; ^&gt; ^, TResult&gt; ^ continuationFunction);" />
      <MemberSignature Language="F#" Value="member this.ContinueWhenAll : System.Threading.Tasks.Task&lt;'AntecedentResult&gt;[] * Func&lt;System.Threading.Tasks.Task&lt;'AntecedentResult&gt;[], 'Result&gt; -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="taskFactory.ContinueWhenAll (tasks, continuationFunction)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TAntecedentResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task&lt;TAntecedentResult&gt;[]" />
        <Parameter Name="continuationFunction" Type="System.Func&lt;System.Threading.Tasks.Task&lt;TAntecedentResult&gt;[],TResult&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TAntecedentResult">Tipo del resultado del parámetro <paramref name="tasks" /> precedente.</typeparam>
        <param name="tasks">Matriz de las tareas a partir de las cuales se va a continuar.</param>
        <param name="continuationFunction">Delegado de función que se va a ejecutar asincrónicamente cuando se completen todas las tareas de la matriz <paramref name="tasks" />.</param>
        <summary>Crea una tarea de continuación que se iniciará cuando se complete el conjunto de tareas proporcionado.</summary>
        <returns>Nueva tarea de continuación.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cuando haya finalizado, una tarea está en uno de estos estados: <xref:System.Threading.Tasks.TaskStatus.RanToCompletion>, <xref:System.Threading.Tasks.TaskStatus.Faulted>, o <xref:System.Threading.Tasks.TaskStatus.Canceled> Estados.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Uno de los elementos de la matriz <paramref name="tasks" /> se ha eliminado.</exception>
        <exception cref="T:System.ArgumentNullException">La matriz <paramref name="tasks" /> está <see langword="null" />.  
  
O bien 
El argumento <paramref name="continuationFunction" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">La matriz <paramref name="tasks" /> contiene un valor null o está vacío.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">Biblioteca de procesamiento paralelo basado en tareas (TPL)</related>
        <related type="Article" href="~/docs/standard/parallel-programming/chaining-tasks-by-using-continuation-tasks.md">Encadenar tareas mediante tareas de continuación</related>
        <related type="Article" href="~/docs/standard/parallel-programming/task-cancellation.md">Cancelación de tareas</related>
      </Docs>
    </Member>
    <Member MemberName="ContinueWhenAll&lt;TAntecedentResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; ContinueWhenAll&lt;TAntecedentResult&gt; (System.Threading.Tasks.Task&lt;TAntecedentResult&gt;[] tasks, Func&lt;System.Threading.Tasks.Task&lt;TAntecedentResult&gt;[],TResult&gt; continuationFunction, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!TResult&gt; ContinueWhenAll&lt;TAntecedentResult&gt;(class System.Threading.Tasks.Task`1&lt;!!TAntecedentResult&gt;[] tasks, class System.Func`2&lt;class System.Threading.Tasks.Task`1&lt;!!TAntecedentResult&gt;[], !TResult&gt; continuationFunction, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory`1.ContinueWhenAll``1(System.Threading.Tasks.Task{``0}[],System.Func{System.Threading.Tasks.Task{``0}[],`0},System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TAntecedentResult&gt;&#xA; System::Threading::Tasks::Task&lt;TResult&gt; ^ ContinueWhenAll(cli::array &lt;System::Threading::Tasks::Task&lt;TAntecedentResult&gt; ^&gt; ^ tasks, Func&lt;cli::array &lt;System::Threading::Tasks::Task&lt;TAntecedentResult&gt; ^&gt; ^, TResult&gt; ^ continuationFunction, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="member this.ContinueWhenAll : System.Threading.Tasks.Task&lt;'AntecedentResult&gt;[] * Func&lt;System.Threading.Tasks.Task&lt;'AntecedentResult&gt;[], 'Result&gt; * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="taskFactory.ContinueWhenAll (tasks, continuationFunction, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TAntecedentResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task&lt;TAntecedentResult&gt;[]" />
        <Parameter Name="continuationFunction" Type="System.Func&lt;System.Threading.Tasks.Task&lt;TAntecedentResult&gt;[],TResult&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <typeparam name="TAntecedentResult">Tipo del resultado del parámetro <paramref name="tasks" /> precedente.</typeparam>
        <param name="tasks">Matriz de las tareas a partir de las cuales se va a continuar.</param>
        <param name="continuationFunction">Delegado de función que se va a ejecutar asincrónicamente cuando se completen todas las tareas de la matriz <paramref name="tasks" />.</param>
        <param name="cancellationToken">Token de cancelación que se va a asignar a la nueva tarea de continuación.</param>
        <summary>Crea una tarea de continuación que se iniciará cuando se complete el conjunto de tareas proporcionado.</summary>
        <returns>Nueva tarea de continuación.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cuando haya finalizado, una tarea está en uno de estos estados: <xref:System.Threading.Tasks.TaskStatus.RanToCompletion>, <xref:System.Threading.Tasks.TaskStatus.Faulted>, o <xref:System.Threading.Tasks.TaskStatus.Canceled> Estados.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Uno de los elementos de la matriz <paramref name="tasks" /> se ha eliminado.  
  
O bien 
El <see cref="T:System.Threading.CancellationTokenSource" /> que creó <paramref name="cancellationToken" /> ya se ha eliminado.</exception>
        <exception cref="T:System.ArgumentNullException">La matriz <paramref name="tasks" /> está <see langword="null" />.  
  
O bien 
El argumento <paramref name="continuationFunction" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">La matriz <paramref name="tasks" /> contiene un valor null o está vacío.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">Biblioteca de procesamiento paralelo basado en tareas (TPL)</related>
        <related type="Article" href="~/docs/standard/parallel-programming/chaining-tasks-by-using-continuation-tasks.md">Encadenar tareas mediante tareas de continuación</related>
        <related type="Article" href="~/docs/standard/parallel-programming/task-cancellation.md">Cancelación de tareas</related>
      </Docs>
    </Member>
    <Member MemberName="ContinueWhenAll&lt;TAntecedentResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; ContinueWhenAll&lt;TAntecedentResult&gt; (System.Threading.Tasks.Task&lt;TAntecedentResult&gt;[] tasks, Func&lt;System.Threading.Tasks.Task&lt;TAntecedentResult&gt;[],TResult&gt; continuationFunction, System.Threading.Tasks.TaskContinuationOptions continuationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!TResult&gt; ContinueWhenAll&lt;TAntecedentResult&gt;(class System.Threading.Tasks.Task`1&lt;!!TAntecedentResult&gt;[] tasks, class System.Func`2&lt;class System.Threading.Tasks.Task`1&lt;!!TAntecedentResult&gt;[], !TResult&gt; continuationFunction, valuetype System.Threading.Tasks.TaskContinuationOptions continuationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory`1.ContinueWhenAll``1(System.Threading.Tasks.Task{``0}[],System.Func{System.Threading.Tasks.Task{``0}[],`0},System.Threading.Tasks.TaskContinuationOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function ContinueWhenAll(Of TAntecedentResult) (tasks As Task(Of TAntecedentResult)(), continuationFunction As Func(Of Task(Of TAntecedentResult)(), TResult), continuationOptions As TaskContinuationOptions) As Task(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TAntecedentResult&gt;&#xA; System::Threading::Tasks::Task&lt;TResult&gt; ^ ContinueWhenAll(cli::array &lt;System::Threading::Tasks::Task&lt;TAntecedentResult&gt; ^&gt; ^ tasks, Func&lt;cli::array &lt;System::Threading::Tasks::Task&lt;TAntecedentResult&gt; ^&gt; ^, TResult&gt; ^ continuationFunction, System::Threading::Tasks::TaskContinuationOptions continuationOptions);" />
      <MemberSignature Language="F#" Value="member this.ContinueWhenAll : System.Threading.Tasks.Task&lt;'AntecedentResult&gt;[] * Func&lt;System.Threading.Tasks.Task&lt;'AntecedentResult&gt;[], 'Result&gt; * System.Threading.Tasks.TaskContinuationOptions -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="taskFactory.ContinueWhenAll (tasks, continuationFunction, continuationOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TAntecedentResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task&lt;TAntecedentResult&gt;[]" />
        <Parameter Name="continuationFunction" Type="System.Func&lt;System.Threading.Tasks.Task&lt;TAntecedentResult&gt;[],TResult&gt;" />
        <Parameter Name="continuationOptions" Type="System.Threading.Tasks.TaskContinuationOptions" />
      </Parameters>
      <Docs>
        <typeparam name="TAntecedentResult">Tipo del resultado del parámetro <paramref name="tasks" /> precedente.</typeparam>
        <param name="tasks">Matriz de las tareas a partir de las cuales se va a continuar.</param>
        <param name="continuationFunction">Delegado de función que se va a ejecutar asincrónicamente cuando se completen todas las tareas de la matriz <paramref name="tasks" />.</param>
        <param name="continuationOptions">Uno de los valores de enumeración que controla el comportamiento de la tarea de continuación creada. Los valores <see langword="NotOn*" /> y <see langword="OnlyOn*" /> no son válidos.</param>
        <summary>Crea una tarea de continuación que se iniciará cuando se complete el conjunto de tareas proporcionado.</summary>
        <returns>Nueva tarea de continuación.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cuando haya finalizado, una tarea está en uno de estos estados: <xref:System.Threading.Tasks.TaskStatus.RanToCompletion>, <xref:System.Threading.Tasks.TaskStatus.Faulted>, o <xref:System.Threading.Tasks.TaskStatus.Canceled> Estados.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Uno de los elementos de la matriz <paramref name="tasks" /> se ha eliminado.</exception>
        <exception cref="T:System.ArgumentNullException">La matriz <paramref name="tasks" /> está <see langword="null" />.  
  
O bien 
El argumento <paramref name="continuationFunction" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">El argumento <paramref name="continuationOptions" /> especifica un valor no válido.</exception>
        <exception cref="T:System.ArgumentException">La matriz <paramref name="tasks" /> contiene un valor null o está vacío.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">Biblioteca de procesamiento paralelo basado en tareas (TPL)</related>
        <related type="Article" href="~/docs/standard/parallel-programming/chaining-tasks-by-using-continuation-tasks.md">Encadenar tareas mediante tareas de continuación</related>
        <related type="Article" href="~/docs/standard/parallel-programming/task-cancellation.md">Cancelación de tareas</related>
      </Docs>
    </Member>
    <Member MemberName="ContinueWhenAll&lt;TAntecedentResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; ContinueWhenAll&lt;TAntecedentResult&gt; (System.Threading.Tasks.Task&lt;TAntecedentResult&gt;[] tasks, Func&lt;System.Threading.Tasks.Task&lt;TAntecedentResult&gt;[],TResult&gt; continuationFunction, System.Threading.CancellationToken cancellationToken, System.Threading.Tasks.TaskContinuationOptions continuationOptions, System.Threading.Tasks.TaskScheduler scheduler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!TResult&gt; ContinueWhenAll&lt;TAntecedentResult&gt;(class System.Threading.Tasks.Task`1&lt;!!TAntecedentResult&gt;[] tasks, class System.Func`2&lt;class System.Threading.Tasks.Task`1&lt;!!TAntecedentResult&gt;[], !TResult&gt; continuationFunction, valuetype System.Threading.CancellationToken cancellationToken, valuetype System.Threading.Tasks.TaskContinuationOptions continuationOptions, class System.Threading.Tasks.TaskScheduler scheduler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory`1.ContinueWhenAll``1(System.Threading.Tasks.Task{``0}[],System.Func{System.Threading.Tasks.Task{``0}[],`0},System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TAntecedentResult&gt;&#xA; System::Threading::Tasks::Task&lt;TResult&gt; ^ ContinueWhenAll(cli::array &lt;System::Threading::Tasks::Task&lt;TAntecedentResult&gt; ^&gt; ^ tasks, Func&lt;cli::array &lt;System::Threading::Tasks::Task&lt;TAntecedentResult&gt; ^&gt; ^, TResult&gt; ^ continuationFunction, System::Threading::CancellationToken cancellationToken, System::Threading::Tasks::TaskContinuationOptions continuationOptions, System::Threading::Tasks::TaskScheduler ^ scheduler);" />
      <MemberSignature Language="F#" Value="member this.ContinueWhenAll : System.Threading.Tasks.Task&lt;'AntecedentResult&gt;[] * Func&lt;System.Threading.Tasks.Task&lt;'AntecedentResult&gt;[], 'Result&gt; * System.Threading.CancellationToken * System.Threading.Tasks.TaskContinuationOptions * System.Threading.Tasks.TaskScheduler -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="taskFactory.ContinueWhenAll (tasks, continuationFunction, cancellationToken, continuationOptions, scheduler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TAntecedentResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task&lt;TAntecedentResult&gt;[]" />
        <Parameter Name="continuationFunction" Type="System.Func&lt;System.Threading.Tasks.Task&lt;TAntecedentResult&gt;[],TResult&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        <Parameter Name="continuationOptions" Type="System.Threading.Tasks.TaskContinuationOptions" />
        <Parameter Name="scheduler" Type="System.Threading.Tasks.TaskScheduler" />
      </Parameters>
      <Docs>
        <typeparam name="TAntecedentResult">Tipo del resultado del parámetro <paramref name="tasks" /> precedente.</typeparam>
        <param name="tasks">Matriz de las tareas a partir de las cuales se va a continuar.</param>
        <param name="continuationFunction">Delegado de función que se va a ejecutar asincrónicamente cuando se completen todas las tareas de la matriz <paramref name="tasks" />.</param>
        <param name="cancellationToken">Token de cancelación que se va a asignar a la nueva tarea de continuación.</param>
        <param name="continuationOptions">Uno de los valores de enumeración que controla el comportamiento de la tarea de continuación creada. Los valores <see langword="NotOn*" /> y <see langword="OnlyOn*" /> no son válidos.</param>
        <param name="scheduler">Programador que se usa para programar la tarea de continuación creada.</param>
        <summary>Crea una tarea de continuación que se iniciará cuando se complete el conjunto de tareas proporcionado.</summary>
        <returns>Nueva tarea de continuación.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cuando haya finalizado, una tarea está en uno de estos estados: <xref:System.Threading.Tasks.TaskStatus.RanToCompletion>, <xref:System.Threading.Tasks.TaskStatus.Faulted>, o <xref:System.Threading.Tasks.TaskStatus.Canceled> Estados.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">La matriz <paramref name="tasks" /> está <see langword="null" />.  
  
O bien 
El argumento <paramref name="continuationFunction" /> es <see langword="null" />.  
  
O bien 
El argumento <paramref name="scheduler" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">La matriz <paramref name="tasks" /> contiene un valor null o está vacío.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">El argumento <paramref name="continuationOptions" /> especifica un valor no válido.</exception>
        <exception cref="T:System.ObjectDisposedException">Uno de los elementos de la matriz <paramref name="tasks" /> se ha eliminado.  
  
O bien 
El <see cref="T:System.Threading.CancellationTokenSource" /> que creó <paramref name="cancellationToken" /> ya se ha eliminado.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">Biblioteca de procesamiento paralelo basado en tareas (TPL)</related>
        <related type="Article" href="~/docs/standard/parallel-programming/chaining-tasks-by-using-continuation-tasks.md">Encadenar tareas mediante tareas de continuación</related>
        <related type="Article" href="~/docs/standard/parallel-programming/task-cancellation.md">Cancelación de tareas</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="ContinueWhenAny">
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Crea una tarea de continuación que se iniciará cuando se complete cualquier tarea del conjunto proporcionado.</summary>
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">Biblioteca de procesamiento paralelo basado en tareas (TPL)</related>
        <related type="Article" href="~/docs/standard/parallel-programming/chaining-tasks-by-using-continuation-tasks.md">Encadenar tareas mediante tareas de continuación</related>
        <related type="Article" href="~/docs/standard/parallel-programming/task-cancellation.md">Cancelación de tareas</related>
      </Docs>
    </MemberGroup>
    <Member MemberName="ContinueWhenAny">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; ContinueWhenAny (System.Threading.Tasks.Task[] tasks, Func&lt;System.Threading.Tasks.Task,TResult&gt; continuationFunction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!TResult&gt; ContinueWhenAny(class System.Threading.Tasks.Task[] tasks, class System.Func`2&lt;class System.Threading.Tasks.Task, !TResult&gt; continuationFunction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory`1.ContinueWhenAny(System.Threading.Tasks.Task[],System.Func{System.Threading.Tasks.Task,`0})" />
      <MemberSignature Language="VB.NET" Value="Public Function ContinueWhenAny (tasks As Task(), continuationFunction As Func(Of Task, TResult)) As Task(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task&lt;TResult&gt; ^ ContinueWhenAny(cli::array &lt;System::Threading::Tasks::Task ^&gt; ^ tasks, Func&lt;System::Threading::Tasks::Task ^, TResult&gt; ^ continuationFunction);" />
      <MemberSignature Language="F#" Value="member this.ContinueWhenAny : System.Threading.Tasks.Task[] * Func&lt;System.Threading.Tasks.Task, 'Result&gt; -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="taskFactory.ContinueWhenAny (tasks, continuationFunction)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task[]" />
        <Parameter Name="continuationFunction" Type="System.Func&lt;System.Threading.Tasks.Task,TResult&gt;" />
      </Parameters>
      <Docs>
        <param name="tasks">Matriz de tareas desde la que se va a continuar cuando se complete una tarea.</param>
        <param name="continuationFunction">Delegado de función que se va a ejecutar asincrónicamente cuando se complete una tarea de la matriz <paramref name="tasks" />.</param>
        <summary>Crea una tarea de continuación que se iniciará cuando se complete cualquier tarea del conjunto proporcionado.</summary>
        <returns>Nueva tarea de continuación.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cuando haya finalizado, una tarea está en uno de estos estados: <xref:System.Threading.Tasks.TaskStatus.RanToCompletion>, <xref:System.Threading.Tasks.TaskStatus.Faulted>, o <xref:System.Threading.Tasks.TaskStatus.Canceled> Estados.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Uno de los elementos de la matriz <paramref name="tasks" /> se ha eliminado.</exception>
        <exception cref="T:System.ArgumentNullException">La matriz <paramref name="tasks" /> está <see langword="null" />.  
  
O bien 
El argumento <paramref name="continuationFunction" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">La matriz <paramref name="tasks" /> contiene un valor null o está vacío.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">Biblioteca de procesamiento paralelo basado en tareas (TPL)</related>
        <related type="Article" href="~/docs/standard/parallel-programming/chaining-tasks-by-using-continuation-tasks.md">Encadenar tareas mediante tareas de continuación</related>
        <related type="Article" href="~/docs/standard/parallel-programming/task-cancellation.md">Cancelación de tareas</related>
      </Docs>
    </Member>
    <Member MemberName="ContinueWhenAny">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; ContinueWhenAny (System.Threading.Tasks.Task[] tasks, Func&lt;System.Threading.Tasks.Task,TResult&gt; continuationFunction, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!TResult&gt; ContinueWhenAny(class System.Threading.Tasks.Task[] tasks, class System.Func`2&lt;class System.Threading.Tasks.Task, !TResult&gt; continuationFunction, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory`1.ContinueWhenAny(System.Threading.Tasks.Task[],System.Func{System.Threading.Tasks.Task,`0},System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task&lt;TResult&gt; ^ ContinueWhenAny(cli::array &lt;System::Threading::Tasks::Task ^&gt; ^ tasks, Func&lt;System::Threading::Tasks::Task ^, TResult&gt; ^ continuationFunction, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="member this.ContinueWhenAny : System.Threading.Tasks.Task[] * Func&lt;System.Threading.Tasks.Task, 'Result&gt; * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="taskFactory.ContinueWhenAny (tasks, continuationFunction, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task[]" />
        <Parameter Name="continuationFunction" Type="System.Func&lt;System.Threading.Tasks.Task,TResult&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="tasks">Matriz de tareas desde la que se va a continuar cuando se complete una tarea.</param>
        <param name="continuationFunction">Delegado de función que se va a ejecutar asincrónicamente cuando se complete una tarea de la matriz <paramref name="tasks" />.</param>
        <param name="cancellationToken">Token de cancelación que se va a asignar a la nueva tarea de continuación.</param>
        <summary>Crea una tarea de continuación que se iniciará cuando se complete cualquier tarea del conjunto proporcionado.</summary>
        <returns>Nueva tarea de continuación.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cuando haya finalizado, una tarea está en uno de estos estados: <xref:System.Threading.Tasks.TaskStatus.RanToCompletion>, <xref:System.Threading.Tasks.TaskStatus.Faulted>, o <xref:System.Threading.Tasks.TaskStatus.Canceled> Estados.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Uno de los elementos de la matriz <paramref name="tasks" /> se ha eliminado.  
  
O bien 
El <see cref="T:System.Threading.CancellationTokenSource" /> que creó <paramref name="cancellationToken" /> ya se ha eliminado.</exception>
        <exception cref="T:System.ArgumentNullException">La matriz de <paramref name="tasks" /> es null.  
  
O bien 
El argumento <paramref name="continuationFunction" /> es null.</exception>
        <exception cref="T:System.ArgumentException">La matriz <paramref name="tasks" /> contiene un valor null.  
  
O bien 
La matriz <paramref name="tasks" /> está vacía.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">Biblioteca de procesamiento paralelo basado en tareas (TPL)</related>
        <related type="Article" href="~/docs/standard/parallel-programming/chaining-tasks-by-using-continuation-tasks.md">Encadenar tareas mediante tareas de continuación</related>
        <related type="Article" href="~/docs/standard/parallel-programming/task-cancellation.md">Cancelación de tareas</related>
      </Docs>
    </Member>
    <Member MemberName="ContinueWhenAny">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; ContinueWhenAny (System.Threading.Tasks.Task[] tasks, Func&lt;System.Threading.Tasks.Task,TResult&gt; continuationFunction, System.Threading.Tasks.TaskContinuationOptions continuationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!TResult&gt; ContinueWhenAny(class System.Threading.Tasks.Task[] tasks, class System.Func`2&lt;class System.Threading.Tasks.Task, !TResult&gt; continuationFunction, valuetype System.Threading.Tasks.TaskContinuationOptions continuationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory`1.ContinueWhenAny(System.Threading.Tasks.Task[],System.Func{System.Threading.Tasks.Task,`0},System.Threading.Tasks.TaskContinuationOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function ContinueWhenAny (tasks As Task(), continuationFunction As Func(Of Task, TResult), continuationOptions As TaskContinuationOptions) As Task(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task&lt;TResult&gt; ^ ContinueWhenAny(cli::array &lt;System::Threading::Tasks::Task ^&gt; ^ tasks, Func&lt;System::Threading::Tasks::Task ^, TResult&gt; ^ continuationFunction, System::Threading::Tasks::TaskContinuationOptions continuationOptions);" />
      <MemberSignature Language="F#" Value="member this.ContinueWhenAny : System.Threading.Tasks.Task[] * Func&lt;System.Threading.Tasks.Task, 'Result&gt; * System.Threading.Tasks.TaskContinuationOptions -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="taskFactory.ContinueWhenAny (tasks, continuationFunction, continuationOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task[]" />
        <Parameter Name="continuationFunction" Type="System.Func&lt;System.Threading.Tasks.Task,TResult&gt;" />
        <Parameter Name="continuationOptions" Type="System.Threading.Tasks.TaskContinuationOptions" />
      </Parameters>
      <Docs>
        <param name="tasks">Matriz de tareas desde la que se va a continuar cuando se complete una tarea.</param>
        <param name="continuationFunction">Delegado de función que se va a ejecutar asincrónicamente cuando se complete una tarea de la matriz <paramref name="tasks" />.</param>
        <param name="continuationOptions">Uno de los valores de enumeración que controla el comportamiento de la tarea de continuación creada. Los valores <see langword="NotOn*" /> y <see langword="OnlyOn*" /> no son válidos.</param>
        <summary>Crea una tarea de continuación que se iniciará cuando se complete cualquier tarea del conjunto proporcionado.</summary>
        <returns>Nueva tarea de continuación.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cuando haya finalizado, una tarea está en uno de estos estados: <xref:System.Threading.Tasks.TaskStatus.RanToCompletion>, <xref:System.Threading.Tasks.TaskStatus.Faulted>, o <xref:System.Threading.Tasks.TaskStatus.Canceled> Estados.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Uno de los elementos de la matriz <paramref name="tasks" /> se ha eliminado.</exception>
        <exception cref="T:System.ArgumentNullException">La matriz <paramref name="tasks" /> está <see langword="null" />.  
  
O bien 
El argumento <paramref name="continuationFunction" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">El argumento <paramref name="continuationOptions" /> especifica un valor de enumeración no válido.</exception>
        <exception cref="T:System.ArgumentException">La matriz <paramref name="tasks" /> contiene un valor null.  
  
O bien 
La matriz <paramref name="tasks" /> está vacía.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">Biblioteca de procesamiento paralelo basado en tareas (TPL)</related>
        <related type="Article" href="~/docs/standard/parallel-programming/chaining-tasks-by-using-continuation-tasks.md">Encadenar tareas mediante tareas de continuación</related>
        <related type="Article" href="~/docs/standard/parallel-programming/task-cancellation.md">Cancelación de tareas</related>
      </Docs>
    </Member>
    <Member MemberName="ContinueWhenAny">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; ContinueWhenAny (System.Threading.Tasks.Task[] tasks, Func&lt;System.Threading.Tasks.Task,TResult&gt; continuationFunction, System.Threading.CancellationToken cancellationToken, System.Threading.Tasks.TaskContinuationOptions continuationOptions, System.Threading.Tasks.TaskScheduler scheduler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!TResult&gt; ContinueWhenAny(class System.Threading.Tasks.Task[] tasks, class System.Func`2&lt;class System.Threading.Tasks.Task, !TResult&gt; continuationFunction, valuetype System.Threading.CancellationToken cancellationToken, valuetype System.Threading.Tasks.TaskContinuationOptions continuationOptions, class System.Threading.Tasks.TaskScheduler scheduler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory`1.ContinueWhenAny(System.Threading.Tasks.Task[],System.Func{System.Threading.Tasks.Task,`0},System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task&lt;TResult&gt; ^ ContinueWhenAny(cli::array &lt;System::Threading::Tasks::Task ^&gt; ^ tasks, Func&lt;System::Threading::Tasks::Task ^, TResult&gt; ^ continuationFunction, System::Threading::CancellationToken cancellationToken, System::Threading::Tasks::TaskContinuationOptions continuationOptions, System::Threading::Tasks::TaskScheduler ^ scheduler);" />
      <MemberSignature Language="F#" Value="member this.ContinueWhenAny : System.Threading.Tasks.Task[] * Func&lt;System.Threading.Tasks.Task, 'Result&gt; * System.Threading.CancellationToken * System.Threading.Tasks.TaskContinuationOptions * System.Threading.Tasks.TaskScheduler -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="taskFactory.ContinueWhenAny (tasks, continuationFunction, cancellationToken, continuationOptions, scheduler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task[]" />
        <Parameter Name="continuationFunction" Type="System.Func&lt;System.Threading.Tasks.Task,TResult&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        <Parameter Name="continuationOptions" Type="System.Threading.Tasks.TaskContinuationOptions" />
        <Parameter Name="scheduler" Type="System.Threading.Tasks.TaskScheduler" />
      </Parameters>
      <Docs>
        <param name="tasks">Matriz de tareas desde la que se va a continuar cuando se complete una tarea.</param>
        <param name="continuationFunction">Delegado de función que se va a ejecutar asincrónicamente cuando se complete una tarea de la matriz <paramref name="tasks" />.</param>
        <param name="cancellationToken">Token de cancelación que se va a asignar a la nueva tarea de continuación.</param>
        <param name="continuationOptions">Uno de los valores de enumeración que controla el comportamiento de la tarea de continuación creada. Los valores <see langword="NotOn*" /> y <see langword="OnlyOn*" /> no son válidos.</param>
        <param name="scheduler">Programador que se usa para programar la tarea de continuación creada.</param>
        <summary>Crea una tarea de continuación que se iniciará cuando se complete cualquier tarea del conjunto proporcionado.</summary>
        <returns>Nueva tarea de continuación.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cuando haya finalizado, una tarea está en uno de estos estados: <xref:System.Threading.Tasks.TaskStatus.RanToCompletion>, <xref:System.Threading.Tasks.TaskStatus.Faulted>, o <xref:System.Threading.Tasks.TaskStatus.Canceled> Estados.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">La matriz <paramref name="tasks" /> está <see langword="null" />.  
  
O bien 
El argumento <paramref name="continuationFunction" /> es <see langword="null" />.  
  
O bien 
El argumento <paramref name="scheduler" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">La matriz <paramref name="tasks" /> contiene un valor null.  
  
O bien 
La matriz <paramref name="tasks" /> está vacía.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">El argumento <paramref name="continuationOptions" /> especifica un valor <see cref="T:System.Threading.Tasks.TaskContinuationOptions" /> no válido.</exception>
        <exception cref="T:System.ObjectDisposedException">Uno de los elementos de la matriz <paramref name="tasks" /> se ha eliminado.  
  
O bien 
El <see cref="T:System.Threading.CancellationTokenSource" /> que creó <paramref name="cancellationToken" /> ya se ha eliminado.</exception>
        <altmember cref="T:System.Threading.Tasks.TaskScheduler" />
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">Biblioteca de procesamiento paralelo basado en tareas (TPL)</related>
        <related type="Article" href="~/docs/standard/parallel-programming/chaining-tasks-by-using-continuation-tasks.md">Encadenar tareas mediante tareas de continuación</related>
        <related type="Article" href="~/docs/standard/parallel-programming/task-cancellation.md">Cancelación de tareas</related>
      </Docs>
    </Member>
    <Member MemberName="ContinueWhenAny&lt;TAntecedentResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; ContinueWhenAny&lt;TAntecedentResult&gt; (System.Threading.Tasks.Task&lt;TAntecedentResult&gt;[] tasks, Func&lt;System.Threading.Tasks.Task&lt;TAntecedentResult&gt;,TResult&gt; continuationFunction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!TResult&gt; ContinueWhenAny&lt;TAntecedentResult&gt;(class System.Threading.Tasks.Task`1&lt;!!TAntecedentResult&gt;[] tasks, class System.Func`2&lt;class System.Threading.Tasks.Task`1&lt;!!TAntecedentResult&gt;, !TResult&gt; continuationFunction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory`1.ContinueWhenAny``1(System.Threading.Tasks.Task{``0}[],System.Func{System.Threading.Tasks.Task{``0},`0})" />
      <MemberSignature Language="VB.NET" Value="Public Function ContinueWhenAny(Of TAntecedentResult) (tasks As Task(Of TAntecedentResult)(), continuationFunction As Func(Of Task(Of TAntecedentResult), TResult)) As Task(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TAntecedentResult&gt;&#xA; System::Threading::Tasks::Task&lt;TResult&gt; ^ ContinueWhenAny(cli::array &lt;System::Threading::Tasks::Task&lt;TAntecedentResult&gt; ^&gt; ^ tasks, Func&lt;System::Threading::Tasks::Task&lt;TAntecedentResult&gt; ^, TResult&gt; ^ continuationFunction);" />
      <MemberSignature Language="F#" Value="member this.ContinueWhenAny : System.Threading.Tasks.Task&lt;'AntecedentResult&gt;[] * Func&lt;System.Threading.Tasks.Task&lt;'AntecedentResult&gt;, 'Result&gt; -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="taskFactory.ContinueWhenAny (tasks, continuationFunction)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TAntecedentResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task&lt;TAntecedentResult&gt;[]" />
        <Parameter Name="continuationFunction" Type="System.Func&lt;System.Threading.Tasks.Task&lt;TAntecedentResult&gt;,TResult&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TAntecedentResult">Tipo del resultado del parámetro <paramref name="tasks" /> precedente.</typeparam>
        <param name="tasks">Matriz de tareas desde la que se va a continuar cuando se complete una tarea.</param>
        <param name="continuationFunction">Delegado de función que se va a ejecutar asincrónicamente cuando se complete una tarea de la matriz <paramref name="tasks" />.</param>
        <summary>Crea una tarea de continuación que se iniciará cuando se complete cualquier tarea del conjunto proporcionado.</summary>
        <returns>Nuevo objeto <see cref="T:System.Threading.Tasks.Task`1" /> de continuación.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cuando haya finalizado, una tarea está en uno de estos estados: <xref:System.Threading.Tasks.TaskStatus.RanToCompletion>, <xref:System.Threading.Tasks.TaskStatus.Faulted>, o <xref:System.Threading.Tasks.TaskStatus.Canceled> Estados.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Uno de los elementos de la matriz <paramref name="tasks" /> se ha eliminado.</exception>
        <exception cref="T:System.ArgumentNullException">La matriz <paramref name="tasks" /> está <see langword="null" />.  
  
O bien 
El argumento <paramref name="continuationFunction" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">La matriz <paramref name="tasks" /> contiene un valor null.  
  
O bien 
La matriz <paramref name="tasks" /> está vacía.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">Biblioteca de procesamiento paralelo basado en tareas (TPL)</related>
        <related type="Article" href="~/docs/standard/parallel-programming/chaining-tasks-by-using-continuation-tasks.md">Encadenar tareas mediante tareas de continuación</related>
        <related type="Article" href="~/docs/standard/parallel-programming/task-cancellation.md">Cancelación de tareas</related>
      </Docs>
    </Member>
    <Member MemberName="ContinueWhenAny&lt;TAntecedentResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; ContinueWhenAny&lt;TAntecedentResult&gt; (System.Threading.Tasks.Task&lt;TAntecedentResult&gt;[] tasks, Func&lt;System.Threading.Tasks.Task&lt;TAntecedentResult&gt;,TResult&gt; continuationFunction, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!TResult&gt; ContinueWhenAny&lt;TAntecedentResult&gt;(class System.Threading.Tasks.Task`1&lt;!!TAntecedentResult&gt;[] tasks, class System.Func`2&lt;class System.Threading.Tasks.Task`1&lt;!!TAntecedentResult&gt;, !TResult&gt; continuationFunction, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory`1.ContinueWhenAny``1(System.Threading.Tasks.Task{``0}[],System.Func{System.Threading.Tasks.Task{``0},`0},System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TAntecedentResult&gt;&#xA; System::Threading::Tasks::Task&lt;TResult&gt; ^ ContinueWhenAny(cli::array &lt;System::Threading::Tasks::Task&lt;TAntecedentResult&gt; ^&gt; ^ tasks, Func&lt;System::Threading::Tasks::Task&lt;TAntecedentResult&gt; ^, TResult&gt; ^ continuationFunction, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="member this.ContinueWhenAny : System.Threading.Tasks.Task&lt;'AntecedentResult&gt;[] * Func&lt;System.Threading.Tasks.Task&lt;'AntecedentResult&gt;, 'Result&gt; * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="taskFactory.ContinueWhenAny (tasks, continuationFunction, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TAntecedentResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task&lt;TAntecedentResult&gt;[]" />
        <Parameter Name="continuationFunction" Type="System.Func&lt;System.Threading.Tasks.Task&lt;TAntecedentResult&gt;,TResult&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <typeparam name="TAntecedentResult">Tipo del resultado del parámetro <paramref name="tasks" /> precedente.</typeparam>
        <param name="tasks">Matriz de tareas desde la que se va a continuar cuando se complete una tarea.</param>
        <param name="continuationFunction">Delegado de función que se va a ejecutar asincrónicamente cuando se complete una tarea de la matriz <paramref name="tasks" />.</param>
        <param name="cancellationToken">Token de cancelación que se va a asignar a la nueva tarea de continuación.</param>
        <summary>Crea una tarea de continuación que se iniciará cuando se complete cualquier tarea del conjunto proporcionado.</summary>
        <returns>Nueva tarea de continuación.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cuando haya finalizado, una tarea está en uno de estos estados: <xref:System.Threading.Tasks.TaskStatus.RanToCompletion>, <xref:System.Threading.Tasks.TaskStatus.Faulted>, o <xref:System.Threading.Tasks.TaskStatus.Canceled> Estados.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Uno de los elementos de la matriz <paramref name="tasks" /> se ha eliminado.  
  
O bien 
El <see cref="T:System.Threading.CancellationTokenSource" /> que creó <paramref name="cancellationToken" /> ya se ha eliminado.</exception>
        <exception cref="T:System.ArgumentNullException">La matriz <paramref name="tasks" /> está <see langword="null" />.  
  
O bien 
El argumento <paramref name="continuationFunction" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">La matriz <paramref name="tasks" /> contiene un valor null.  
  
O bien 
La matriz <paramref name="tasks" /> está vacía.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">Biblioteca de procesamiento paralelo basado en tareas (TPL)</related>
        <related type="Article" href="~/docs/standard/parallel-programming/chaining-tasks-by-using-continuation-tasks.md">Encadenar tareas mediante tareas de continuación</related>
        <related type="Article" href="~/docs/standard/parallel-programming/task-cancellation.md">Cancelación de tareas</related>
      </Docs>
    </Member>
    <Member MemberName="ContinueWhenAny&lt;TAntecedentResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; ContinueWhenAny&lt;TAntecedentResult&gt; (System.Threading.Tasks.Task&lt;TAntecedentResult&gt;[] tasks, Func&lt;System.Threading.Tasks.Task&lt;TAntecedentResult&gt;,TResult&gt; continuationFunction, System.Threading.Tasks.TaskContinuationOptions continuationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!TResult&gt; ContinueWhenAny&lt;TAntecedentResult&gt;(class System.Threading.Tasks.Task`1&lt;!!TAntecedentResult&gt;[] tasks, class System.Func`2&lt;class System.Threading.Tasks.Task`1&lt;!!TAntecedentResult&gt;, !TResult&gt; continuationFunction, valuetype System.Threading.Tasks.TaskContinuationOptions continuationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory`1.ContinueWhenAny``1(System.Threading.Tasks.Task{``0}[],System.Func{System.Threading.Tasks.Task{``0},`0},System.Threading.Tasks.TaskContinuationOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function ContinueWhenAny(Of TAntecedentResult) (tasks As Task(Of TAntecedentResult)(), continuationFunction As Func(Of Task(Of TAntecedentResult), TResult), continuationOptions As TaskContinuationOptions) As Task(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TAntecedentResult&gt;&#xA; System::Threading::Tasks::Task&lt;TResult&gt; ^ ContinueWhenAny(cli::array &lt;System::Threading::Tasks::Task&lt;TAntecedentResult&gt; ^&gt; ^ tasks, Func&lt;System::Threading::Tasks::Task&lt;TAntecedentResult&gt; ^, TResult&gt; ^ continuationFunction, System::Threading::Tasks::TaskContinuationOptions continuationOptions);" />
      <MemberSignature Language="F#" Value="member this.ContinueWhenAny : System.Threading.Tasks.Task&lt;'AntecedentResult&gt;[] * Func&lt;System.Threading.Tasks.Task&lt;'AntecedentResult&gt;, 'Result&gt; * System.Threading.Tasks.TaskContinuationOptions -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="taskFactory.ContinueWhenAny (tasks, continuationFunction, continuationOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TAntecedentResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task&lt;TAntecedentResult&gt;[]" />
        <Parameter Name="continuationFunction" Type="System.Func&lt;System.Threading.Tasks.Task&lt;TAntecedentResult&gt;,TResult&gt;" />
        <Parameter Name="continuationOptions" Type="System.Threading.Tasks.TaskContinuationOptions" />
      </Parameters>
      <Docs>
        <typeparam name="TAntecedentResult">Tipo del resultado del parámetro <paramref name="tasks" /> precedente.</typeparam>
        <param name="tasks">Matriz de tareas desde la que se va a continuar cuando se complete una tarea.</param>
        <param name="continuationFunction">Delegado de función que se va a ejecutar asincrónicamente cuando se complete una tarea de la matriz <paramref name="tasks" />.</param>
        <param name="continuationOptions">Uno de los valores de enumeración que controla el comportamiento de la tarea de continuación creada. Los valores <see langword="NotOn*" /> y <see langword="OnlyOn*" /> no son válidos.</param>
        <summary>Crea una tarea de continuación que se iniciará cuando se complete cualquier tarea del conjunto proporcionado.</summary>
        <returns>Nuevo objeto <see cref="T:System.Threading.Tasks.Task`1" /> de continuación.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cuando haya finalizado, una tarea está en uno de estos estados: <xref:System.Threading.Tasks.TaskStatus.RanToCompletion>, <xref:System.Threading.Tasks.TaskStatus.Faulted>, o <xref:System.Threading.Tasks.TaskStatus.Canceled> Estados.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Uno de los elementos de la matriz <paramref name="tasks" /> se ha eliminado.</exception>
        <exception cref="T:System.ArgumentNullException">La matriz <paramref name="tasks" /> está <see langword="null" />.  
  
O bien 
El argumento <paramref name="continuationFunction" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">El argumento <paramref name="continuationOptions" /> especifica un valor de enumeración no válido.</exception>
        <exception cref="T:System.ArgumentException">La matriz <paramref name="tasks" /> contiene un valor null.  
  
O bien 
La matriz <paramref name="tasks" /> está vacía.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">Biblioteca de procesamiento paralelo basado en tareas (TPL)</related>
        <related type="Article" href="~/docs/standard/parallel-programming/chaining-tasks-by-using-continuation-tasks.md">Encadenar tareas mediante tareas de continuación</related>
        <related type="Article" href="~/docs/standard/parallel-programming/task-cancellation.md">Cancelación de tareas</related>
      </Docs>
    </Member>
    <Member MemberName="ContinueWhenAny&lt;TAntecedentResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; ContinueWhenAny&lt;TAntecedentResult&gt; (System.Threading.Tasks.Task&lt;TAntecedentResult&gt;[] tasks, Func&lt;System.Threading.Tasks.Task&lt;TAntecedentResult&gt;,TResult&gt; continuationFunction, System.Threading.CancellationToken cancellationToken, System.Threading.Tasks.TaskContinuationOptions continuationOptions, System.Threading.Tasks.TaskScheduler scheduler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!TResult&gt; ContinueWhenAny&lt;TAntecedentResult&gt;(class System.Threading.Tasks.Task`1&lt;!!TAntecedentResult&gt;[] tasks, class System.Func`2&lt;class System.Threading.Tasks.Task`1&lt;!!TAntecedentResult&gt;, !TResult&gt; continuationFunction, valuetype System.Threading.CancellationToken cancellationToken, valuetype System.Threading.Tasks.TaskContinuationOptions continuationOptions, class System.Threading.Tasks.TaskScheduler scheduler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory`1.ContinueWhenAny``1(System.Threading.Tasks.Task{``0}[],System.Func{System.Threading.Tasks.Task{``0},`0},System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TAntecedentResult&gt;&#xA; System::Threading::Tasks::Task&lt;TResult&gt; ^ ContinueWhenAny(cli::array &lt;System::Threading::Tasks::Task&lt;TAntecedentResult&gt; ^&gt; ^ tasks, Func&lt;System::Threading::Tasks::Task&lt;TAntecedentResult&gt; ^, TResult&gt; ^ continuationFunction, System::Threading::CancellationToken cancellationToken, System::Threading::Tasks::TaskContinuationOptions continuationOptions, System::Threading::Tasks::TaskScheduler ^ scheduler);" />
      <MemberSignature Language="F#" Value="member this.ContinueWhenAny : System.Threading.Tasks.Task&lt;'AntecedentResult&gt;[] * Func&lt;System.Threading.Tasks.Task&lt;'AntecedentResult&gt;, 'Result&gt; * System.Threading.CancellationToken * System.Threading.Tasks.TaskContinuationOptions * System.Threading.Tasks.TaskScheduler -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="taskFactory.ContinueWhenAny (tasks, continuationFunction, cancellationToken, continuationOptions, scheduler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TAntecedentResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task&lt;TAntecedentResult&gt;[]" />
        <Parameter Name="continuationFunction" Type="System.Func&lt;System.Threading.Tasks.Task&lt;TAntecedentResult&gt;,TResult&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        <Parameter Name="continuationOptions" Type="System.Threading.Tasks.TaskContinuationOptions" />
        <Parameter Name="scheduler" Type="System.Threading.Tasks.TaskScheduler" />
      </Parameters>
      <Docs>
        <typeparam name="TAntecedentResult">Tipo del resultado del parámetro <paramref name="tasks" /> precedente.</typeparam>
        <param name="tasks">Matriz de tareas desde la que se va a continuar cuando se complete una tarea.</param>
        <param name="continuationFunction">Delegado de función que se va a ejecutar asincrónicamente cuando se complete una tarea de la matriz <paramref name="tasks" />.</param>
        <param name="cancellationToken">Token de cancelación que se va a asignar a la nueva tarea de continuación.</param>
        <param name="continuationOptions">Uno de los valores de enumeración que controla el comportamiento de la tarea de continuación creada. Los valores <see langword="NotOn*" /> y <see langword="OnlyOn*" /> no son válidos.</param>
        <param name="scheduler">Objeto <see cref="T:System.Threading.Tasks.TaskScheduler" /> que se usa para programar el objeto <see cref="T:System.Threading.Tasks.Task`1" /> de continuación creado.</param>
        <summary>Crea una tarea de continuación que se iniciará cuando se complete cualquier tarea del conjunto proporcionado.</summary>
        <returns>Nuevo objeto <see cref="T:System.Threading.Tasks.Task`1" /> de continuación.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cuando haya finalizado, una tarea está en uno de estos estados: <xref:System.Threading.Tasks.TaskStatus.RanToCompletion>, <xref:System.Threading.Tasks.TaskStatus.Faulted>, o <xref:System.Threading.Tasks.TaskStatus.Canceled> Estados.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">La matriz <paramref name="tasks" /> está <see langword="null" />.  
  
O bien 
El argumento <paramref name="continuationFunction" /> es <see langword="null" />.  
  
O bien 
El argumento <paramref name="scheduler" /> es null.</exception>
        <exception cref="T:System.ArgumentException">La matriz <paramref name="tasks" /> contiene un valor null.  
  
O bien 
La matriz <paramref name="tasks" /> está vacía.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">El argumento <paramref name="continuationOptions" /> especifica un valor TaskContinuationOptions no válido.</exception>
        <exception cref="T:System.ObjectDisposedException">Uno de los elementos de la matriz <paramref name="tasks" /> se ha eliminado.  
  
O bien 
El <see cref="T:System.Threading.CancellationTokenSource" /> que creó <paramref name="cancellationToken" /> ya se ha eliminado.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">Biblioteca de procesamiento paralelo basado en tareas (TPL)</related>
        <related type="Article" href="~/docs/standard/parallel-programming/chaining-tasks-by-using-continuation-tasks.md">Encadenar tareas mediante tareas de continuación</related>
        <related type="Article" href="~/docs/standard/parallel-programming/task-cancellation.md">Cancelación de tareas</related>
      </Docs>
    </Member>
    <Member MemberName="CreationOptions">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.TaskCreationOptions CreationOptions { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Threading.Tasks.TaskCreationOptions CreationOptions" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.TaskFactory`1.CreationOptions" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CreationOptions As TaskCreationOptions" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Threading::Tasks::TaskCreationOptions CreationOptions { System::Threading::Tasks::TaskCreationOptions get(); };" />
      <MemberSignature Language="F#" Value="member this.CreationOptions : System.Threading.Tasks.TaskCreationOptions" Usage="System.Threading.Tasks.TaskFactory&lt;'Result&gt;.CreationOptions" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.TaskCreationOptions</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene el valor de enumeración <see cref="T:System.Threading.Tasks.TaskCreationOptions" /> para este generador de tareas.</summary>
        <value>Uno de los valores de enumeración que especifica las opciones de creación predeterminadas para este generador de tareas.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esta propiedad devuelve el valor predeterminado de opciones de creación de este generador. Se utilizará para crear todas las tareas, a menos que se especifiquen explícitamente otras opciones durante las llamadas a métodos de este generador.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">Biblioteca de procesamiento paralelo basado en tareas (TPL)</related>
        <related type="Article" href="~/docs/standard/parallel-programming/using-tpl-with-other-asynchronous-patterns.md">Usar TPL con otros patrones asincrónicos</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="FromAsync">
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Crea una nueva instancia de tarea.</summary>
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">Biblioteca de procesamiento paralelo basado en tareas (TPL)</related>
        <related type="Article" href="~/docs/standard/parallel-programming/using-tpl-with-other-asynchronous-patterns.md">Usar TPL con otros patrones asincrónicos</related>
      </Docs>
    </MemberGroup>
    <Member MemberName="FromAsync">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; FromAsync (IAsyncResult asyncResult, Func&lt;IAsyncResult,TResult&gt; endMethod);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!TResult&gt; FromAsync(class System.IAsyncResult asyncResult, class System.Func`2&lt;class System.IAsyncResult, !TResult&gt; endMethod) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory`1.FromAsync(System.IAsyncResult,System.Func{System.IAsyncResult,`0})" />
      <MemberSignature Language="VB.NET" Value="Public Function FromAsync (asyncResult As IAsyncResult, endMethod As Func(Of IAsyncResult, TResult)) As Task(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task&lt;TResult&gt; ^ FromAsync(IAsyncResult ^ asyncResult, Func&lt;IAsyncResult ^, TResult&gt; ^ endMethod);" />
      <MemberSignature Language="F#" Value="member this.FromAsync : IAsyncResult * Func&lt;IAsyncResult, 'Result&gt; -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="taskFactory.FromAsync (asyncResult, endMethod)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
        <Parameter Name="endMethod" Type="System.Func&lt;System.IAsyncResult,TResult&gt;" />
      </Parameters>
      <Docs>
        <param name="asyncResult">El objeto <see cref="T:System.IAsyncResult" /> que al completarse debería desencadenar el procesamiento del objeto <paramref name="endMethod" />.</param>
        <param name="endMethod">Delegado de función que procesa el objeto <paramref name="asyncResult" /> completado.</param>
        <summary>Crea una tarea que ejecuta una función del método End cuando se completa la interfaz <see cref="T:System.IAsyncResult" /> especificada.</summary>
        <returns>Objeto <see cref="T:System.Threading.Tasks.Task`1" /> que representa la operación asincrónica.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">El argumento <paramref name="asyncResult" /> es <see langword="null" />.  
  
O bien 
El argumento <paramref name="endMethod" /> es <see langword="null" />.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">Biblioteca de procesamiento paralelo basado en tareas (TPL)</related>
        <related type="Article" href="~/docs/standard/parallel-programming/using-tpl-with-other-asynchronous-patterns.md">Usar TPL con otros patrones asincrónicos</related>
      </Docs>
    </Member>
    <Member MemberName="FromAsync">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; FromAsync (Func&lt;AsyncCallback,object,IAsyncResult&gt; beginMethod, Func&lt;IAsyncResult,TResult&gt; endMethod, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!TResult&gt; FromAsync(class System.Func`3&lt;class System.AsyncCallback, object, class System.IAsyncResult&gt; beginMethod, class System.Func`2&lt;class System.IAsyncResult, !TResult&gt; endMethod, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory`1.FromAsync(System.Func{System.AsyncCallback,System.Object,System.IAsyncResult},System.Func{System.IAsyncResult,`0},System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function FromAsync (beginMethod As Func(Of AsyncCallback, Object, IAsyncResult), endMethod As Func(Of IAsyncResult, TResult), state As Object) As Task(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task&lt;TResult&gt; ^ FromAsync(Func&lt;AsyncCallback ^, System::Object ^, IAsyncResult ^&gt; ^ beginMethod, Func&lt;IAsyncResult ^, TResult&gt; ^ endMethod, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.FromAsync : Func&lt;AsyncCallback, obj, IAsyncResult&gt; * Func&lt;IAsyncResult, 'Result&gt; * obj -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="taskFactory.FromAsync (beginMethod, endMethod, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="beginMethod" Type="System.Func&lt;System.AsyncCallback,System.Object,System.IAsyncResult&gt;" />
        <Parameter Name="endMethod" Type="System.Func&lt;System.IAsyncResult,TResult&gt;" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="beginMethod">Delegado que comienza la operación asincrónica.</param>
        <param name="endMethod">Delegado que finaliza la operación asincrónica.</param>
        <param name="state">Objeto que contiene los datos que el delegado de <paramref name="beginMethod" /> va a usar.</param>
        <summary>Crea una tarea que representa un par de métodos Begin y End que se ajustan al modelo de programación asincrónica.</summary>
        <returns>Tarea creada que representa la operación asincrónica.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método produce cualquier excepción producida por el `beginMethod`. Excepciones para `endmethod` se produce cuando se espera en la tarea devuelta.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El argumento <paramref name="beginMethod" /> es <see langword="null" />.  
  
O bien 
El argumento <paramref name="endMethod" /> es <see langword="null" />.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">Biblioteca de procesamiento paralelo basado en tareas (TPL)</related>
        <related type="Article" href="~/docs/standard/parallel-programming/using-tpl-with-other-asynchronous-patterns.md">Usar TPL con otros patrones asincrónicos</related>
      </Docs>
    </Member>
    <Member MemberName="FromAsync">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; FromAsync (IAsyncResult asyncResult, Func&lt;IAsyncResult,TResult&gt; endMethod, System.Threading.Tasks.TaskCreationOptions creationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!TResult&gt; FromAsync(class System.IAsyncResult asyncResult, class System.Func`2&lt;class System.IAsyncResult, !TResult&gt; endMethod, valuetype System.Threading.Tasks.TaskCreationOptions creationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory`1.FromAsync(System.IAsyncResult,System.Func{System.IAsyncResult,`0},System.Threading.Tasks.TaskCreationOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function FromAsync (asyncResult As IAsyncResult, endMethod As Func(Of IAsyncResult, TResult), creationOptions As TaskCreationOptions) As Task(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task&lt;TResult&gt; ^ FromAsync(IAsyncResult ^ asyncResult, Func&lt;IAsyncResult ^, TResult&gt; ^ endMethod, System::Threading::Tasks::TaskCreationOptions creationOptions);" />
      <MemberSignature Language="F#" Value="member this.FromAsync : IAsyncResult * Func&lt;IAsyncResult, 'Result&gt; * System.Threading.Tasks.TaskCreationOptions -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="taskFactory.FromAsync (asyncResult, endMethod, creationOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
        <Parameter Name="endMethod" Type="System.Func&lt;System.IAsyncResult,TResult&gt;" />
        <Parameter Name="creationOptions" Type="System.Threading.Tasks.TaskCreationOptions" />
      </Parameters>
      <Docs>
        <param name="asyncResult">El objeto <see cref="T:System.IAsyncResult" /> que al completarse debería desencadenar el procesamiento del objeto <paramref name="endMethod" />.</param>
        <param name="endMethod">Delegado de función que procesa el objeto <paramref name="asyncResult" /> completado.</param>
        <param name="creationOptions">Uno de los valores de enumeración que controla el comportamiento de la tarea creada.</param>
        <summary>Crea una tarea que ejecuta una función del método End cuando se completa la interfaz <see cref="T:System.IAsyncResult" /> especificada.</summary>
        <returns>Tarea que representa la operación asincrónica.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">El argumento <paramref name="asyncResult" /> es <see langword="null" />.  
  
O bien 
El argumento <paramref name="endMethod" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">El argumento <paramref name="creationOptions" /> especifica un valor no válido.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">Biblioteca de procesamiento paralelo basado en tareas (TPL)</related>
        <related type="Article" href="~/docs/standard/parallel-programming/using-tpl-with-other-asynchronous-patterns.md">Usar TPL con otros patrones asincrónicos</related>
      </Docs>
    </Member>
    <Member MemberName="FromAsync">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; FromAsync (Func&lt;AsyncCallback,object,IAsyncResult&gt; beginMethod, Func&lt;IAsyncResult,TResult&gt; endMethod, object state, System.Threading.Tasks.TaskCreationOptions creationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!TResult&gt; FromAsync(class System.Func`3&lt;class System.AsyncCallback, object, class System.IAsyncResult&gt; beginMethod, class System.Func`2&lt;class System.IAsyncResult, !TResult&gt; endMethod, object state, valuetype System.Threading.Tasks.TaskCreationOptions creationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory`1.FromAsync(System.Func{System.AsyncCallback,System.Object,System.IAsyncResult},System.Func{System.IAsyncResult,`0},System.Object,System.Threading.Tasks.TaskCreationOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function FromAsync (beginMethod As Func(Of AsyncCallback, Object, IAsyncResult), endMethod As Func(Of IAsyncResult, TResult), state As Object, creationOptions As TaskCreationOptions) As Task(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task&lt;TResult&gt; ^ FromAsync(Func&lt;AsyncCallback ^, System::Object ^, IAsyncResult ^&gt; ^ beginMethod, Func&lt;IAsyncResult ^, TResult&gt; ^ endMethod, System::Object ^ state, System::Threading::Tasks::TaskCreationOptions creationOptions);" />
      <MemberSignature Language="F#" Value="member this.FromAsync : Func&lt;AsyncCallback, obj, IAsyncResult&gt; * Func&lt;IAsyncResult, 'Result&gt; * obj * System.Threading.Tasks.TaskCreationOptions -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="taskFactory.FromAsync (beginMethod, endMethod, state, creationOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="beginMethod" Type="System.Func&lt;System.AsyncCallback,System.Object,System.IAsyncResult&gt;" />
        <Parameter Name="endMethod" Type="System.Func&lt;System.IAsyncResult,TResult&gt;" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="creationOptions" Type="System.Threading.Tasks.TaskCreationOptions" />
      </Parameters>
      <Docs>
        <param name="beginMethod">Delegado que comienza la operación asincrónica.</param>
        <param name="endMethod">Delegado que finaliza la operación asincrónica.</param>
        <param name="state">Objeto que contiene los datos que el delegado de <paramref name="beginMethod" /> va a usar.</param>
        <param name="creationOptions">Uno de los valores de enumeración que controla el comportamiento de la tarea creada.</param>
        <summary>Crea una tarea que representa un par de métodos Begin y End que se ajustan al modelo de programación asincrónica.</summary>
        <returns>Objeto <see cref="T:System.Threading.Tasks.Task`1" /> creado que representa la operación asincrónica.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método produce cualquier excepción producida por el `beginMethod`. Excepciones para `endmethod` se produce cuando se espera en la tarea devuelta.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El argumento <paramref name="beginMethod" /> es <see langword="null" />.  
  
O bien 
El argumento <paramref name="endMethod" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">El argumento <paramref name="creationOptions" /> especifica un valor no válido.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">Biblioteca de procesamiento paralelo basado en tareas (TPL)</related>
        <related type="Article" href="~/docs/standard/parallel-programming/using-tpl-with-other-asynchronous-patterns.md">Usar TPL con otros patrones asincrónicos</related>
      </Docs>
    </Member>
    <Member MemberName="FromAsync">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; FromAsync (IAsyncResult asyncResult, Func&lt;IAsyncResult,TResult&gt; endMethod, System.Threading.Tasks.TaskCreationOptions creationOptions, System.Threading.Tasks.TaskScheduler scheduler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!TResult&gt; FromAsync(class System.IAsyncResult asyncResult, class System.Func`2&lt;class System.IAsyncResult, !TResult&gt; endMethod, valuetype System.Threading.Tasks.TaskCreationOptions creationOptions, class System.Threading.Tasks.TaskScheduler scheduler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory`1.FromAsync(System.IAsyncResult,System.Func{System.IAsyncResult,`0},System.Threading.Tasks.TaskCreationOptions,System.Threading.Tasks.TaskScheduler)" />
      <MemberSignature Language="VB.NET" Value="Public Function FromAsync (asyncResult As IAsyncResult, endMethod As Func(Of IAsyncResult, TResult), creationOptions As TaskCreationOptions, scheduler As TaskScheduler) As Task(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task&lt;TResult&gt; ^ FromAsync(IAsyncResult ^ asyncResult, Func&lt;IAsyncResult ^, TResult&gt; ^ endMethod, System::Threading::Tasks::TaskCreationOptions creationOptions, System::Threading::Tasks::TaskScheduler ^ scheduler);" />
      <MemberSignature Language="F#" Value="member this.FromAsync : IAsyncResult * Func&lt;IAsyncResult, 'Result&gt; * System.Threading.Tasks.TaskCreationOptions * System.Threading.Tasks.TaskScheduler -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="taskFactory.FromAsync (asyncResult, endMethod, creationOptions, scheduler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
        <Parameter Name="endMethod" Type="System.Func&lt;System.IAsyncResult,TResult&gt;" />
        <Parameter Name="creationOptions" Type="System.Threading.Tasks.TaskCreationOptions" />
        <Parameter Name="scheduler" Type="System.Threading.Tasks.TaskScheduler" />
      </Parameters>
      <Docs>
        <param name="asyncResult">El objeto <see cref="T:System.IAsyncResult" /> que al completarse debería desencadenar el procesamiento del objeto <paramref name="endMethod" />.</param>
        <param name="endMethod">Delegado de función que procesa el objeto <paramref name="asyncResult" /> completado.</param>
        <param name="creationOptions">Uno de los valores de enumeración que controla el comportamiento de la tarea creada.</param>
        <param name="scheduler">El programador de tareas que se usa para programar la tarea que ejecuta el método End.</param>
        <summary>Crea una tarea que ejecuta una función del método End cuando se completa la interfaz <see cref="T:System.IAsyncResult" /> especificada.</summary>
        <returns>Tarea creada que representa la operación asincrónica.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">El argumento <paramref name="asyncResult" /> es <see langword="null" />.  
  
O bien 
El argumento <paramref name="endMethod" /> es <see langword="null" />.  
  
O bien 
El argumento <paramref name="scheduler" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">El parámetro <paramref name="creationOptions" /> especifica un valor no válido.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">Biblioteca de procesamiento paralelo basado en tareas (TPL)</related>
        <related type="Article" href="~/docs/standard/parallel-programming/using-tpl-with-other-asynchronous-patterns.md">Usar TPL con otros patrones asincrónicos</related>
      </Docs>
    </Member>
    <Member MemberName="FromAsync&lt;TArg1&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; FromAsync&lt;TArg1&gt; (Func&lt;TArg1,AsyncCallback,object,IAsyncResult&gt; beginMethod, Func&lt;IAsyncResult,TResult&gt; endMethod, TArg1 arg1, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!TResult&gt; FromAsync&lt;TArg1&gt;(class System.Func`4&lt;!!TArg1, class System.AsyncCallback, object, class System.IAsyncResult&gt; beginMethod, class System.Func`2&lt;class System.IAsyncResult, !TResult&gt; endMethod, !!TArg1 arg1, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory`1.FromAsync``1(System.Func{``0,System.AsyncCallback,System.Object,System.IAsyncResult},System.Func{System.IAsyncResult,`0},``0,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function FromAsync(Of TArg1) (beginMethod As Func(Of TArg1, AsyncCallback, Object, IAsyncResult), endMethod As Func(Of IAsyncResult, TResult), arg1 As TArg1, state As Object) As Task(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TArg1&gt;&#xA; System::Threading::Tasks::Task&lt;TResult&gt; ^ FromAsync(Func&lt;TArg1, AsyncCallback ^, System::Object ^, IAsyncResult ^&gt; ^ beginMethod, Func&lt;IAsyncResult ^, TResult&gt; ^ endMethod, TArg1 arg1, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.FromAsync : Func&lt;'TArg1, AsyncCallback, obj, IAsyncResult&gt; * Func&lt;IAsyncResult, 'Result&gt; * 'TArg1 * obj -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="taskFactory.FromAsync (beginMethod, endMethod, arg1, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TArg1" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="beginMethod" Type="System.Func&lt;TArg1,System.AsyncCallback,System.Object,System.IAsyncResult&gt;" />
        <Parameter Name="endMethod" Type="System.Func&lt;System.IAsyncResult,TResult&gt;" />
        <Parameter Name="arg1" Type="TArg1" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <typeparam name="TArg1">Tipo del primer argumento que se pasa al delegado de <paramref name="beginMethod" />.</typeparam>
        <param name="beginMethod">Delegado que comienza la operación asincrónica.</param>
        <param name="endMethod">Delegado que finaliza la operación asincrónica.</param>
        <param name="arg1">Primer argumento que se pasa al delegado de <paramref name="beginMethod" />.</param>
        <param name="state">Objeto que contiene los datos que el delegado de <paramref name="beginMethod" /> va a usar.</param>
        <summary>Crea una tarea que representa un par de métodos Begin y End que se ajustan al modelo de programación asincrónica.</summary>
        <returns>Tarea creada que representa la operación asincrónica.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método produce cualquier excepción producida por el `beginMethod`. Excepciones para `endmethod` se produce cuando se espera en la tarea devuelta.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El argumento <paramref name="beginMethod" /> es <see langword="null" />.  
  
O bien 
El argumento <paramref name="endMethod" /> es <see langword="null" />.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">Biblioteca de procesamiento paralelo basado en tareas (TPL)</related>
        <related type="Article" href="~/docs/standard/parallel-programming/using-tpl-with-other-asynchronous-patterns.md">Usar TPL con otros patrones asincrónicos</related>
      </Docs>
    </Member>
    <Member MemberName="FromAsync&lt;TArg1&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; FromAsync&lt;TArg1&gt; (Func&lt;TArg1,AsyncCallback,object,IAsyncResult&gt; beginMethod, Func&lt;IAsyncResult,TResult&gt; endMethod, TArg1 arg1, object state, System.Threading.Tasks.TaskCreationOptions creationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!TResult&gt; FromAsync&lt;TArg1&gt;(class System.Func`4&lt;!!TArg1, class System.AsyncCallback, object, class System.IAsyncResult&gt; beginMethod, class System.Func`2&lt;class System.IAsyncResult, !TResult&gt; endMethod, !!TArg1 arg1, object state, valuetype System.Threading.Tasks.TaskCreationOptions creationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory`1.FromAsync``1(System.Func{``0,System.AsyncCallback,System.Object,System.IAsyncResult},System.Func{System.IAsyncResult,`0},``0,System.Object,System.Threading.Tasks.TaskCreationOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function FromAsync(Of TArg1) (beginMethod As Func(Of TArg1, AsyncCallback, Object, IAsyncResult), endMethod As Func(Of IAsyncResult, TResult), arg1 As TArg1, state As Object, creationOptions As TaskCreationOptions) As Task(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TArg1&gt;&#xA; System::Threading::Tasks::Task&lt;TResult&gt; ^ FromAsync(Func&lt;TArg1, AsyncCallback ^, System::Object ^, IAsyncResult ^&gt; ^ beginMethod, Func&lt;IAsyncResult ^, TResult&gt; ^ endMethod, TArg1 arg1, System::Object ^ state, System::Threading::Tasks::TaskCreationOptions creationOptions);" />
      <MemberSignature Language="F#" Value="member this.FromAsync : Func&lt;'TArg1, AsyncCallback, obj, IAsyncResult&gt; * Func&lt;IAsyncResult, 'Result&gt; * 'TArg1 * obj * System.Threading.Tasks.TaskCreationOptions -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="taskFactory.FromAsync (beginMethod, endMethod, arg1, state, creationOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TArg1" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="beginMethod" Type="System.Func&lt;TArg1,System.AsyncCallback,System.Object,System.IAsyncResult&gt;" />
        <Parameter Name="endMethod" Type="System.Func&lt;System.IAsyncResult,TResult&gt;" />
        <Parameter Name="arg1" Type="TArg1" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="creationOptions" Type="System.Threading.Tasks.TaskCreationOptions" />
      </Parameters>
      <Docs>
        <typeparam name="TArg1">Tipo del primer argumento que se pasa al delegado de <paramref name="beginMethod" />.</typeparam>
        <param name="beginMethod">Delegado que comienza la operación asincrónica.</param>
        <param name="endMethod">Delegado que finaliza la operación asincrónica.</param>
        <param name="arg1">Primer argumento que se pasa al delegado de <paramref name="beginMethod" />.</param>
        <param name="state">Objeto que contiene los datos que el delegado de <paramref name="beginMethod" /> va a usar.</param>
        <param name="creationOptions">Uno de los valores de enumeración que controla el comportamiento de la tarea creada.</param>
        <summary>Crea una tarea que representa un par de métodos Begin y End que se ajustan al modelo de programación asincrónica.</summary>
        <returns>Tarea creada que representa la operación asincrónica.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método produce cualquier excepción producida por el `beginMethod`. Excepciones para `endmethod` se produce cuando se espera en la tarea devuelta.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El argumento <paramref name="beginMethod" /> es <see langword="null" />.  
  
O bien 
El argumento <paramref name="endMethod" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">El parámetro <paramref name="creationOptions" /> especifica un valor no válido.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">Biblioteca de procesamiento paralelo basado en tareas (TPL)</related>
        <related type="Article" href="~/docs/standard/parallel-programming/using-tpl-with-other-asynchronous-patterns.md">Usar TPL con otros patrones asincrónicos</related>
      </Docs>
    </Member>
    <Member MemberName="FromAsync&lt;TArg1,TArg2&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; FromAsync&lt;TArg1,TArg2&gt; (Func&lt;TArg1,TArg2,AsyncCallback,object,IAsyncResult&gt; beginMethod, Func&lt;IAsyncResult,TResult&gt; endMethod, TArg1 arg1, TArg2 arg2, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!TResult&gt; FromAsync&lt;TArg1, TArg2&gt;(class System.Func`5&lt;!!TArg1, !!TArg2, class System.AsyncCallback, object, class System.IAsyncResult&gt; beginMethod, class System.Func`2&lt;class System.IAsyncResult, !TResult&gt; endMethod, !!TArg1 arg1, !!TArg2 arg2, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory`1.FromAsync``2(System.Func{``0,``1,System.AsyncCallback,System.Object,System.IAsyncResult},System.Func{System.IAsyncResult,`0},``0,``1,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function FromAsync(Of TArg1, TArg2) (beginMethod As Func(Of TArg1, TArg2, AsyncCallback, Object, IAsyncResult), endMethod As Func(Of IAsyncResult, TResult), arg1 As TArg1, arg2 As TArg2, state As Object) As Task(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TArg1, typename TArg2&gt;&#xA; System::Threading::Tasks::Task&lt;TResult&gt; ^ FromAsync(Func&lt;TArg1, TArg2, AsyncCallback ^, System::Object ^, IAsyncResult ^&gt; ^ beginMethod, Func&lt;IAsyncResult ^, TResult&gt; ^ endMethod, TArg1 arg1, TArg2 arg2, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.FromAsync : Func&lt;'TArg1, 'TArg2, AsyncCallback, obj, IAsyncResult&gt; * Func&lt;IAsyncResult, 'Result&gt; * 'TArg1 * 'TArg2 * obj -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="taskFactory.FromAsync (beginMethod, endMethod, arg1, arg2, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TArg1" />
        <TypeParameter Name="TArg2" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="beginMethod" Type="System.Func&lt;TArg1,TArg2,System.AsyncCallback,System.Object,System.IAsyncResult&gt;" />
        <Parameter Name="endMethod" Type="System.Func&lt;System.IAsyncResult,TResult&gt;" />
        <Parameter Name="arg1" Type="TArg1" />
        <Parameter Name="arg2" Type="TArg2" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <typeparam name="TArg1">Tipo del segundo argumento que se pasa al delegado de <paramref name="beginMethod" />.</typeparam>
        <typeparam name="TArg2">Tipo del primer argumento que se pasa al delegado de <paramref name="beginMethod" />.</typeparam>
        <param name="beginMethod">Delegado que comienza la operación asincrónica.</param>
        <param name="endMethod">Delegado que finaliza la operación asincrónica.</param>
        <param name="arg1">Primer argumento que se pasa al delegado de <paramref name="beginMethod" />.</param>
        <param name="arg2">Segundo argumento que se pasa al delegado de <paramref name="beginMethod" />.</param>
        <param name="state">Objeto que contiene los datos que el delegado de <paramref name="beginMethod" /> va a usar.</param>
        <summary>Crea una tarea que representa un par de métodos Begin y End que se ajustan al modelo de programación asincrónica.</summary>
        <returns>Tarea creada que representa la operación asincrónica.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método produce cualquier excepción producida por el `beginMethod`. Excepciones para `endmethod` se produce cuando se espera en la tarea devuelta.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El argumento <paramref name="beginMethod" /> es <see langword="null" />.  
  
O bien 
El argumento <paramref name="endMethod" /> es <see langword="null" />.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">Biblioteca de procesamiento paralelo basado en tareas (TPL)</related>
        <related type="Article" href="~/docs/standard/parallel-programming/using-tpl-with-other-asynchronous-patterns.md">Usar TPL con otros patrones asincrónicos</related>
      </Docs>
    </Member>
    <Member MemberName="FromAsync&lt;TArg1,TArg2&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; FromAsync&lt;TArg1,TArg2&gt; (Func&lt;TArg1,TArg2,AsyncCallback,object,IAsyncResult&gt; beginMethod, Func&lt;IAsyncResult,TResult&gt; endMethod, TArg1 arg1, TArg2 arg2, object state, System.Threading.Tasks.TaskCreationOptions creationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!TResult&gt; FromAsync&lt;TArg1, TArg2&gt;(class System.Func`5&lt;!!TArg1, !!TArg2, class System.AsyncCallback, object, class System.IAsyncResult&gt; beginMethod, class System.Func`2&lt;class System.IAsyncResult, !TResult&gt; endMethod, !!TArg1 arg1, !!TArg2 arg2, object state, valuetype System.Threading.Tasks.TaskCreationOptions creationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory`1.FromAsync``2(System.Func{``0,``1,System.AsyncCallback,System.Object,System.IAsyncResult},System.Func{System.IAsyncResult,`0},``0,``1,System.Object,System.Threading.Tasks.TaskCreationOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function FromAsync(Of TArg1, TArg2) (beginMethod As Func(Of TArg1, TArg2, AsyncCallback, Object, IAsyncResult), endMethod As Func(Of IAsyncResult, TResult), arg1 As TArg1, arg2 As TArg2, state As Object, creationOptions As TaskCreationOptions) As Task(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TArg1, typename TArg2&gt;&#xA; System::Threading::Tasks::Task&lt;TResult&gt; ^ FromAsync(Func&lt;TArg1, TArg2, AsyncCallback ^, System::Object ^, IAsyncResult ^&gt; ^ beginMethod, Func&lt;IAsyncResult ^, TResult&gt; ^ endMethod, TArg1 arg1, TArg2 arg2, System::Object ^ state, System::Threading::Tasks::TaskCreationOptions creationOptions);" />
      <MemberSignature Language="F#" Value="member this.FromAsync : Func&lt;'TArg1, 'TArg2, AsyncCallback, obj, IAsyncResult&gt; * Func&lt;IAsyncResult, 'Result&gt; * 'TArg1 * 'TArg2 * obj * System.Threading.Tasks.TaskCreationOptions -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="taskFactory.FromAsync (beginMethod, endMethod, arg1, arg2, state, creationOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TArg1" />
        <TypeParameter Name="TArg2" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="beginMethod" Type="System.Func&lt;TArg1,TArg2,System.AsyncCallback,System.Object,System.IAsyncResult&gt;" />
        <Parameter Name="endMethod" Type="System.Func&lt;System.IAsyncResult,TResult&gt;" />
        <Parameter Name="arg1" Type="TArg1" />
        <Parameter Name="arg2" Type="TArg2" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="creationOptions" Type="System.Threading.Tasks.TaskCreationOptions" />
      </Parameters>
      <Docs>
        <typeparam name="TArg1">Tipo del segundo argumento que se pasa al delegado de <paramref name="beginMethod" />.</typeparam>
        <typeparam name="TArg2">Tipo del primer argumento que se pasa al delegado de <paramref name="beginMethod" />.</typeparam>
        <param name="beginMethod">Delegado que comienza la operación asincrónica.</param>
        <param name="endMethod">Delegado que finaliza la operación asincrónica.</param>
        <param name="arg1">Primer argumento que se pasa al delegado de <paramref name="beginMethod" />.</param>
        <param name="arg2">Segundo argumento que se pasa al delegado de <paramref name="beginMethod" />.</param>
        <param name="state">Objeto que contiene los datos que el delegado de <paramref name="beginMethod" /> va a usar.</param>
        <param name="creationOptions">Un objeto que controla el comportamiento del objeto <see cref="T:System.Threading.Tasks.Task`1" />creado.</param>
        <summary>Crea una tarea que representa un par de métodos Begin y End que se ajustan al modelo de programación asincrónica.</summary>
        <returns>Tarea creada que representa la operación asincrónica.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método produce cualquier excepción producida por el `beginMethod`. Excepciones para `endmethod` se produce cuando se espera en la tarea devuelta.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El argumento <paramref name="beginMethod" /> es <see langword="null" />.  
  
O bien 
El argumento <paramref name="endMethod" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">El parámetro <paramref name="creationOptions" /> especifica un valor no válido.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">Biblioteca de procesamiento paralelo basado en tareas (TPL)</related>
        <related type="Article" href="~/docs/standard/parallel-programming/using-tpl-with-other-asynchronous-patterns.md">Usar TPL con otros patrones asincrónicos</related>
      </Docs>
    </Member>
    <Member MemberName="FromAsync&lt;TArg1,TArg2,TArg3&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; FromAsync&lt;TArg1,TArg2,TArg3&gt; (Func&lt;TArg1,TArg2,TArg3,AsyncCallback,object,IAsyncResult&gt; beginMethod, Func&lt;IAsyncResult,TResult&gt; endMethod, TArg1 arg1, TArg2 arg2, TArg3 arg3, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!TResult&gt; FromAsync&lt;TArg1, TArg2, TArg3&gt;(class System.Func`6&lt;!!TArg1, !!TArg2, !!TArg3, class System.AsyncCallback, object, class System.IAsyncResult&gt; beginMethod, class System.Func`2&lt;class System.IAsyncResult, !TResult&gt; endMethod, !!TArg1 arg1, !!TArg2 arg2, !!TArg3 arg3, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory`1.FromAsync``3(System.Func{``0,``1,``2,System.AsyncCallback,System.Object,System.IAsyncResult},System.Func{System.IAsyncResult,`0},``0,``1,``2,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function FromAsync(Of TArg1, TArg2, TArg3) (beginMethod As Func(Of TArg1, TArg2, TArg3, AsyncCallback, Object, IAsyncResult), endMethod As Func(Of IAsyncResult, TResult), arg1 As TArg1, arg2 As TArg2, arg3 As TArg3, state As Object) As Task(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TArg1, typename TArg2, typename TArg3&gt;&#xA; System::Threading::Tasks::Task&lt;TResult&gt; ^ FromAsync(Func&lt;TArg1, TArg2, TArg3, AsyncCallback ^, System::Object ^, IAsyncResult ^&gt; ^ beginMethod, Func&lt;IAsyncResult ^, TResult&gt; ^ endMethod, TArg1 arg1, TArg2 arg2, TArg3 arg3, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.FromAsync : Func&lt;'TArg1, 'TArg2, 'TArg3, AsyncCallback, obj, IAsyncResult&gt; * Func&lt;IAsyncResult, 'Result&gt; * 'TArg1 * 'TArg2 * 'TArg3 * obj -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="taskFactory.FromAsync (beginMethod, endMethod, arg1, arg2, arg3, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TArg1" />
        <TypeParameter Name="TArg2" />
        <TypeParameter Name="TArg3" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="beginMethod" Type="System.Func&lt;TArg1,TArg2,TArg3,System.AsyncCallback,System.Object,System.IAsyncResult&gt;" />
        <Parameter Name="endMethod" Type="System.Func&lt;System.IAsyncResult,TResult&gt;" />
        <Parameter Name="arg1" Type="TArg1" />
        <Parameter Name="arg2" Type="TArg2" />
        <Parameter Name="arg3" Type="TArg3" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <typeparam name="TArg1">Tipo del segundo argumento que se pasa al delegado de <paramref name="beginMethod" />.</typeparam>
        <typeparam name="TArg2">Tipo del tercer argumento que se pasa al delegado de <paramref name="beginMethod" />.</typeparam>
        <typeparam name="TArg3">Tipo del primer argumento que se pasa al delegado de <paramref name="beginMethod" />.</typeparam>
        <param name="beginMethod">Delegado que comienza la operación asincrónica.</param>
        <param name="endMethod">Delegado que finaliza la operación asincrónica.</param>
        <param name="arg1">Primer argumento que se pasa al delegado de <paramref name="beginMethod" />.</param>
        <param name="arg2">Segundo argumento que se pasa al delegado de <paramref name="beginMethod" />.</param>
        <param name="arg3">Tercer argumento que se pasa al delegado de <paramref name="beginMethod" />.</param>
        <param name="state">Objeto que contiene los datos que el delegado de <paramref name="beginMethod" /> va a usar.</param>
        <summary>Crea una tarea que representa un par de métodos Begin y End que se ajustan al modelo de programación asincrónica.</summary>
        <returns>Tarea creada que representa la operación asincrónica.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método produce cualquier excepción producida por el `beginMethod`. Excepciones para `endmethod` se produce cuando se espera en la tarea devuelta.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El argumento <paramref name="beginMethod" /> es <see langword="null" />.  
  
O bien 
El argumento <paramref name="endMethod" /> es <see langword="null" />.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">Biblioteca de procesamiento paralelo basado en tareas (TPL)</related>
        <related type="Article" href="~/docs/standard/parallel-programming/using-tpl-with-other-asynchronous-patterns.md">Usar TPL con otros patrones asincrónicos</related>
      </Docs>
    </Member>
    <Member MemberName="FromAsync&lt;TArg1,TArg2,TArg3&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; FromAsync&lt;TArg1,TArg2,TArg3&gt; (Func&lt;TArg1,TArg2,TArg3,AsyncCallback,object,IAsyncResult&gt; beginMethod, Func&lt;IAsyncResult,TResult&gt; endMethod, TArg1 arg1, TArg2 arg2, TArg3 arg3, object state, System.Threading.Tasks.TaskCreationOptions creationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!TResult&gt; FromAsync&lt;TArg1, TArg2, TArg3&gt;(class System.Func`6&lt;!!TArg1, !!TArg2, !!TArg3, class System.AsyncCallback, object, class System.IAsyncResult&gt; beginMethod, class System.Func`2&lt;class System.IAsyncResult, !TResult&gt; endMethod, !!TArg1 arg1, !!TArg2 arg2, !!TArg3 arg3, object state, valuetype System.Threading.Tasks.TaskCreationOptions creationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory`1.FromAsync``3(System.Func{``0,``1,``2,System.AsyncCallback,System.Object,System.IAsyncResult},System.Func{System.IAsyncResult,`0},``0,``1,``2,System.Object,System.Threading.Tasks.TaskCreationOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function FromAsync(Of TArg1, TArg2, TArg3) (beginMethod As Func(Of TArg1, TArg2, TArg3, AsyncCallback, Object, IAsyncResult), endMethod As Func(Of IAsyncResult, TResult), arg1 As TArg1, arg2 As TArg2, arg3 As TArg3, state As Object, creationOptions As TaskCreationOptions) As Task(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TArg1, typename TArg2, typename TArg3&gt;&#xA; System::Threading::Tasks::Task&lt;TResult&gt; ^ FromAsync(Func&lt;TArg1, TArg2, TArg3, AsyncCallback ^, System::Object ^, IAsyncResult ^&gt; ^ beginMethod, Func&lt;IAsyncResult ^, TResult&gt; ^ endMethod, TArg1 arg1, TArg2 arg2, TArg3 arg3, System::Object ^ state, System::Threading::Tasks::TaskCreationOptions creationOptions);" />
      <MemberSignature Language="F#" Value="member this.FromAsync : Func&lt;'TArg1, 'TArg2, 'TArg3, AsyncCallback, obj, IAsyncResult&gt; * Func&lt;IAsyncResult, 'Result&gt; * 'TArg1 * 'TArg2 * 'TArg3 * obj * System.Threading.Tasks.TaskCreationOptions -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="taskFactory.FromAsync (beginMethod, endMethod, arg1, arg2, arg3, state, creationOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TArg1" />
        <TypeParameter Name="TArg2" />
        <TypeParameter Name="TArg3" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="beginMethod" Type="System.Func&lt;TArg1,TArg2,TArg3,System.AsyncCallback,System.Object,System.IAsyncResult&gt;" />
        <Parameter Name="endMethod" Type="System.Func&lt;System.IAsyncResult,TResult&gt;" />
        <Parameter Name="arg1" Type="TArg1" />
        <Parameter Name="arg2" Type="TArg2" />
        <Parameter Name="arg3" Type="TArg3" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="creationOptions" Type="System.Threading.Tasks.TaskCreationOptions" />
      </Parameters>
      <Docs>
        <typeparam name="TArg1">Tipo del segundo argumento que se pasa al delegado de <paramref name="beginMethod" />.</typeparam>
        <typeparam name="TArg2">Tipo del tercer argumento que se pasa al delegado de <paramref name="beginMethod" />.</typeparam>
        <typeparam name="TArg3">Tipo del primer argumento que se pasa al delegado de <paramref name="beginMethod" />.</typeparam>
        <param name="beginMethod">Delegado que comienza la operación asincrónica.</param>
        <param name="endMethod">Delegado que finaliza la operación asincrónica.</param>
        <param name="arg1">Primer argumento que se pasa al delegado de <paramref name="beginMethod" />.</param>
        <param name="arg2">Segundo argumento que se pasa al delegado de <paramref name="beginMethod" />.</param>
        <param name="arg3">Tercer argumento que se pasa al delegado de <paramref name="beginMethod" />.</param>
        <param name="state">Objeto que contiene los datos que el delegado de <paramref name="beginMethod" /> va a usar.</param>
        <param name="creationOptions">Un objeto que controla el comportamiento de la tarea creada.</param>
        <summary>Crea una tarea que representa un par de métodos Begin y End que se ajustan al modelo de programación asincrónica.</summary>
        <returns>Tarea creada que representa la operación asincrónica.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método produce cualquier excepción producida por el `beginMethod`. Excepciones para `endmethod` se produce cuando se espera en la tarea devuelta.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El argumento <paramref name="beginMethod" /> es <see langword="null" />.  
  
O bien 
El argumento <paramref name="endMethod" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">El parámetro <paramref name="creationOptions" /> especifica un valor no válido.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">Biblioteca de procesamiento paralelo basado en tareas (TPL)</related>
        <related type="Article" href="~/docs/standard/parallel-programming/using-tpl-with-other-asynchronous-patterns.md">Usar TPL con otros patrones asincrónicos</related>
      </Docs>
    </Member>
    <Member MemberName="Scheduler">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.TaskScheduler Scheduler { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Threading.Tasks.TaskScheduler Scheduler" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.TaskFactory`1.Scheduler" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Scheduler As TaskScheduler" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Threading::Tasks::TaskScheduler ^ Scheduler { System::Threading::Tasks::TaskScheduler ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Scheduler : System.Threading.Tasks.TaskScheduler" Usage="System.Threading.Tasks.TaskFactory&lt;'Result&gt;.Scheduler" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.TaskScheduler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene el programador de tareas para este generador de tareas.</summary>
        <value>El programador de tareas para este generador de tareas.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esta propiedad devuelve al programador predeterminado para este generador. Se utilizará para programar todas las tareas, a menos que se especifique explícitamente otro programador durante las llamadas a métodos de este generador.  
  
 Si esta propiedad devuelve `null`, <xref:System.Threading.Tasks.TaskScheduler.Current%2A> se usará.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">Biblioteca de procesamiento paralelo basado en tareas (TPL)</related>
        <related type="Article" href="~/docs/standard/parallel-programming/using-tpl-with-other-asynchronous-patterns.md">Usar TPL con otros patrones asincrónicos</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="StartNew">
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Crea e inicia una tarea.</summary>
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">Biblioteca de procesamiento paralelo basado en tareas (TPL)</related>
        <related type="Article" href="~/docs/standard/parallel-programming/using-tpl-with-other-asynchronous-patterns.md">Usar TPL con otros patrones asincrónicos</related>
      </Docs>
    </MemberGroup>
    <Member MemberName="StartNew">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; StartNew (Func&lt;TResult&gt; function);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!TResult&gt; StartNew(class System.Func`1&lt;!TResult&gt; function) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory`1.StartNew(System.Func{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Function StartNew (function As Func(Of TResult)) As Task(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task&lt;TResult&gt; ^ StartNew(Func&lt;TResult&gt; ^ function);" />
      <MemberSignature Language="F#" Value="member this.StartNew : Func&lt;'Result&gt; -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="taskFactory.StartNew function" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="function" Type="System.Func&lt;TResult&gt;" />
      </Parameters>
      <Docs>
        <param name="function">Delegado de función que devuelve el resultado futuro que va a estar disponible a través de la tarea.</param>
        <summary>Crea e inicia una tarea.</summary>
        <returns>La tarea iniciada.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Una llamada a `StartNew` es funcionalmente equivalente a la creación de una tarea mediante uno de los <xref:System.Threading.Tasks.Task%601> constructores y llamadas a continuación, el <xref:System.Threading.Tasks.Task.Start%2A> método para programar su ejecución.  
  
 Sin embargo, a menos que la creación y la programación deben estar separados, `StartNew` es el enfoque recomendado para mayor simplicidad y rendimiento.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El argumento <paramref name="function" /> es <see langword="null" />.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">Biblioteca de procesamiento paralelo basado en tareas (TPL)</related>
        <related type="Article" href="~/docs/standard/parallel-programming/using-tpl-with-other-asynchronous-patterns.md">Usar TPL con otros patrones asincrónicos</related>
      </Docs>
    </Member>
    <Member MemberName="StartNew">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; StartNew (Func&lt;object,TResult&gt; function, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!TResult&gt; StartNew(class System.Func`2&lt;object, !TResult&gt; function, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory`1.StartNew(System.Func{System.Object,`0},System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function StartNew (function As Func(Of Object, TResult), state As Object) As Task(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task&lt;TResult&gt; ^ StartNew(Func&lt;System::Object ^, TResult&gt; ^ function, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.StartNew : Func&lt;obj, 'Result&gt; * obj -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="taskFactory.StartNew (function, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="function" Type="System.Func&lt;System.Object,TResult&gt;" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="function">Delegado de función que devuelve el resultado futuro que va a estar disponible a través de la tarea.</param>
        <param name="state">Objeto que contiene los datos que va a utilizar el delegado de <paramref name="function" />.</param>
        <summary>Crea e inicia una tarea.</summary>
        <returns>La tarea iniciada.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Una llamada a `StartNew` es funcionalmente equivalente a la creación de una tarea mediante uno de los <xref:System.Threading.Tasks.Task%601> constructores y, a continuación, que realiza la llamada la <xref:System.Threading.Tasks.Task.Start%2A> método para programar su ejecución.  
  
 Sin embargo, a menos que la creación y la programación deben estar separados, `StartNew` es el enfoque recomendado para mayor simplicidad y rendimiento.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El argumento <paramref name="function" /> es <see langword="null" />.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">Biblioteca de procesamiento paralelo basado en tareas (TPL)</related>
        <related type="Article" href="~/docs/standard/parallel-programming/using-tpl-with-other-asynchronous-patterns.md">Usar TPL con otros patrones asincrónicos</related>
      </Docs>
    </Member>
    <Member MemberName="StartNew">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; StartNew (Func&lt;TResult&gt; function, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!TResult&gt; StartNew(class System.Func`1&lt;!TResult&gt; function, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory`1.StartNew(System.Func{`0},System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task&lt;TResult&gt; ^ StartNew(Func&lt;TResult&gt; ^ function, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="member this.StartNew : Func&lt;'Result&gt; * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="taskFactory.StartNew (function, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="function" Type="System.Func&lt;TResult&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="function">Delegado de función que devuelve el resultado futuro que va a estar disponible a través de la tarea.</param>
        <param name="cancellationToken">Token de cancelación que se va a asignar a la nueva tarea.</param>
        <summary>Crea e inicia una tarea.</summary>
        <returns>La tarea iniciada.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Una llamada a `StartNew` es funcionalmente equivalente a la creación de una tarea mediante uno de los <xref:System.Threading.Tasks.Task%601> constructores y, a continuación, que realiza la llamada la <xref:System.Threading.Tasks.Task.Start%2A> método para programar su ejecución.  
  
 Sin embargo, a menos que la creación y la programación deben estar separados, `StartNew` es el enfoque recomendado para mayor simplicidad y rendimiento.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Ya se ha eliminado el origen de token de cancelación que ha creado <paramref name="cancellationToken" />.</exception>
        <exception cref="T:System.ArgumentNullException">El argumento <paramref name="function" /> es <see langword="null" />.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">Biblioteca de procesamiento paralelo basado en tareas (TPL)</related>
        <related type="Article" href="~/docs/standard/parallel-programming/using-tpl-with-other-asynchronous-patterns.md">Usar TPL con otros patrones asincrónicos</related>
      </Docs>
    </Member>
    <Member MemberName="StartNew">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; StartNew (Func&lt;TResult&gt; function, System.Threading.Tasks.TaskCreationOptions creationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!TResult&gt; StartNew(class System.Func`1&lt;!TResult&gt; function, valuetype System.Threading.Tasks.TaskCreationOptions creationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory`1.StartNew(System.Func{`0},System.Threading.Tasks.TaskCreationOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function StartNew (function As Func(Of TResult), creationOptions As TaskCreationOptions) As Task(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task&lt;TResult&gt; ^ StartNew(Func&lt;TResult&gt; ^ function, System::Threading::Tasks::TaskCreationOptions creationOptions);" />
      <MemberSignature Language="F#" Value="member this.StartNew : Func&lt;'Result&gt; * System.Threading.Tasks.TaskCreationOptions -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="taskFactory.StartNew (function, creationOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="function" Type="System.Func&lt;TResult&gt;" />
        <Parameter Name="creationOptions" Type="System.Threading.Tasks.TaskCreationOptions" />
      </Parameters>
      <Docs>
        <param name="function">Delegado de función que devuelve el resultado futuro que va a estar disponible a través de la tarea.</param>
        <param name="creationOptions">Uno de los valores de enumeración que controla el comportamiento de la tarea creada.</param>
        <summary>Crea e inicia una tarea.</summary>
        <returns>Objeto <see cref="T:System.Threading.Tasks.Task`1" /> iniciado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Una llamada a `StartNew` es funcionalmente equivalente a la creación de una tarea mediante uno de los <xref:System.Threading.Tasks.Task%601> constructores y, a continuación, que realiza la llamada la <xref:System.Threading.Tasks.Task.Start%2A> método para programar su ejecución.  
  
 Sin embargo, a menos que la creación y la programación deben estar separados, `StartNew` es el enfoque recomendado para mayor simplicidad y rendimiento.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El argumento <paramref name="function" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">El parámetro <paramref name="creationOptions" /> especifica un valor no válido.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">Biblioteca de procesamiento paralelo basado en tareas (TPL)</related>
        <related type="Article" href="~/docs/standard/parallel-programming/using-tpl-with-other-asynchronous-patterns.md">Usar TPL con otros patrones asincrónicos</related>
      </Docs>
    </Member>
    <Member MemberName="StartNew">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; StartNew (Func&lt;object,TResult&gt; function, object state, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!TResult&gt; StartNew(class System.Func`2&lt;object, !TResult&gt; function, object state, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory`1.StartNew(System.Func{System.Object,`0},System.Object,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task&lt;TResult&gt; ^ StartNew(Func&lt;System::Object ^, TResult&gt; ^ function, System::Object ^ state, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="member this.StartNew : Func&lt;obj, 'Result&gt; * obj * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="taskFactory.StartNew (function, state, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="function" Type="System.Func&lt;System.Object,TResult&gt;" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="function">Delegado de función que devuelve el resultado futuro que va a estar disponible a través de la tarea.</param>
        <param name="state">Objeto que contiene los datos que va a utilizar el delegado de <paramref name="function" />.</param>
        <param name="cancellationToken">Token de cancelación que se va a asignar a la nueva tarea.</param>
        <summary>Crea e inicia una tarea.</summary>
        <returns>La tarea iniciada.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Una llamada a `StartNew` es funcionalmente equivalente a la creación de una tarea mediante uno de los <xref:System.Threading.Tasks.Task%601> constructores y, a continuación, que realiza la llamada la <xref:System.Threading.Tasks.Task.Start%2A> método para programar su ejecución.  
  
 Sin embargo, a menos que la creación y la programación deben estar separados, `StartNew` es el enfoque recomendado para mayor simplicidad y rendimiento.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Ya se ha eliminado el origen de token de cancelación que ha creado <paramref name="cancellationToken" />.</exception>
        <exception cref="T:System.ArgumentNullException">El argumento <paramref name="function" /> es <see langword="null" />.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">Biblioteca de procesamiento paralelo basado en tareas (TPL)</related>
        <related type="Article" href="~/docs/standard/parallel-programming/using-tpl-with-other-asynchronous-patterns.md">Usar TPL con otros patrones asincrónicos</related>
      </Docs>
    </Member>
    <Member MemberName="StartNew">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; StartNew (Func&lt;object,TResult&gt; function, object state, System.Threading.Tasks.TaskCreationOptions creationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!TResult&gt; StartNew(class System.Func`2&lt;object, !TResult&gt; function, object state, valuetype System.Threading.Tasks.TaskCreationOptions creationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory`1.StartNew(System.Func{System.Object,`0},System.Object,System.Threading.Tasks.TaskCreationOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function StartNew (function As Func(Of Object, TResult), state As Object, creationOptions As TaskCreationOptions) As Task(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task&lt;TResult&gt; ^ StartNew(Func&lt;System::Object ^, TResult&gt; ^ function, System::Object ^ state, System::Threading::Tasks::TaskCreationOptions creationOptions);" />
      <MemberSignature Language="F#" Value="member this.StartNew : Func&lt;obj, 'Result&gt; * obj * System.Threading.Tasks.TaskCreationOptions -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="taskFactory.StartNew (function, state, creationOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="function" Type="System.Func&lt;System.Object,TResult&gt;" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="creationOptions" Type="System.Threading.Tasks.TaskCreationOptions" />
      </Parameters>
      <Docs>
        <param name="function">Delegado de función que devuelve el resultado futuro que va a estar disponible a través de la tarea.</param>
        <param name="state">Objeto que contiene los datos que va a utilizar el delegado de <paramref name="function" />.</param>
        <param name="creationOptions">Uno de los valores de enumeración que controla el comportamiento de la tarea creada.</param>
        <summary>Crea e inicia una tarea.</summary>
        <returns>La tarea iniciada.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Una llamada a `StartNew` es funcionalmente equivalente a la creación de una tarea mediante uno de los <xref:System.Threading.Tasks.Task%601> constructores y, a continuación, que realiza la llamada la <xref:System.Threading.Tasks.Task.Start%2A> método para programar su ejecución.  
  
 Sin embargo, a menos que la creación y la programación deben estar separados, `StartNew` es el enfoque recomendado para mayor simplicidad y rendimiento.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El argumento <paramref name="function" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">El parámetro <paramref name="creationOptions" /> especifica un valor no válido.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">Biblioteca de procesamiento paralelo basado en tareas (TPL)</related>
        <related type="Article" href="~/docs/standard/parallel-programming/using-tpl-with-other-asynchronous-patterns.md">Usar TPL con otros patrones asincrónicos</related>
      </Docs>
    </Member>
    <Member MemberName="StartNew">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; StartNew (Func&lt;TResult&gt; function, System.Threading.CancellationToken cancellationToken, System.Threading.Tasks.TaskCreationOptions creationOptions, System.Threading.Tasks.TaskScheduler scheduler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!TResult&gt; StartNew(class System.Func`1&lt;!TResult&gt; function, valuetype System.Threading.CancellationToken cancellationToken, valuetype System.Threading.Tasks.TaskCreationOptions creationOptions, class System.Threading.Tasks.TaskScheduler scheduler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory`1.StartNew(System.Func{`0},System.Threading.CancellationToken,System.Threading.Tasks.TaskCreationOptions,System.Threading.Tasks.TaskScheduler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task&lt;TResult&gt; ^ StartNew(Func&lt;TResult&gt; ^ function, System::Threading::CancellationToken cancellationToken, System::Threading::Tasks::TaskCreationOptions creationOptions, System::Threading::Tasks::TaskScheduler ^ scheduler);" />
      <MemberSignature Language="F#" Value="member this.StartNew : Func&lt;'Result&gt; * System.Threading.CancellationToken * System.Threading.Tasks.TaskCreationOptions * System.Threading.Tasks.TaskScheduler -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="taskFactory.StartNew (function, cancellationToken, creationOptions, scheduler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="function" Type="System.Func&lt;TResult&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        <Parameter Name="creationOptions" Type="System.Threading.Tasks.TaskCreationOptions" />
        <Parameter Name="scheduler" Type="System.Threading.Tasks.TaskScheduler" />
      </Parameters>
      <Docs>
        <param name="function">Delegado de función que devuelve el resultado futuro que va a estar disponible a través de la tarea.</param>
        <param name="cancellationToken">Token de cancelación que se va a asignar a la nueva tarea.</param>
        <param name="creationOptions">Uno de los valores de enumeración que controla el comportamiento de la tarea creada.</param>
        <param name="scheduler">Programador de tareas que se usó para programar la tarea creada.</param>
        <summary>Crea e inicia una tarea.</summary>
        <returns>La tarea iniciada.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Una llamada a `StartNew` es funcionalmente equivalente a la creación de una tarea mediante uno de los <xref:System.Threading.Tasks.Task%601> constructores y, a continuación, que realiza la llamada la <xref:System.Threading.Tasks.Task.Start%2A> método para programar su ejecución.  
  
 Sin embargo, a menos que la creación y la programación deben estar separados, `StartNew` es el enfoque recomendado para mayor simplicidad y rendimiento.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Ya se ha eliminado el origen de token de cancelación que ha creado <paramref name="cancellationToken" />.</exception>
        <exception cref="T:System.ArgumentNullException">El argumento <paramref name="function" /> es <see langword="null" />.  
  
O bien 
El argumento <paramref name="scheduler" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">El parámetro <paramref name="creationOptions" /> especifica un valor no válido.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">Biblioteca de procesamiento paralelo basado en tareas (TPL)</related>
        <related type="Article" href="~/docs/standard/parallel-programming/using-tpl-with-other-asynchronous-patterns.md">Usar TPL con otros patrones asincrónicos</related>
      </Docs>
    </Member>
    <Member MemberName="StartNew">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; StartNew (Func&lt;object,TResult&gt; function, object state, System.Threading.CancellationToken cancellationToken, System.Threading.Tasks.TaskCreationOptions creationOptions, System.Threading.Tasks.TaskScheduler scheduler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!TResult&gt; StartNew(class System.Func`2&lt;object, !TResult&gt; function, object state, valuetype System.Threading.CancellationToken cancellationToken, valuetype System.Threading.Tasks.TaskCreationOptions creationOptions, class System.Threading.Tasks.TaskScheduler scheduler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory`1.StartNew(System.Func{System.Object,`0},System.Object,System.Threading.CancellationToken,System.Threading.Tasks.TaskCreationOptions,System.Threading.Tasks.TaskScheduler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task&lt;TResult&gt; ^ StartNew(Func&lt;System::Object ^, TResult&gt; ^ function, System::Object ^ state, System::Threading::CancellationToken cancellationToken, System::Threading::Tasks::TaskCreationOptions creationOptions, System::Threading::Tasks::TaskScheduler ^ scheduler);" />
      <MemberSignature Language="F#" Value="member this.StartNew : Func&lt;obj, 'Result&gt; * obj * System.Threading.CancellationToken * System.Threading.Tasks.TaskCreationOptions * System.Threading.Tasks.TaskScheduler -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="taskFactory.StartNew (function, state, cancellationToken, creationOptions, scheduler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="function" Type="System.Func&lt;System.Object,TResult&gt;" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        <Parameter Name="creationOptions" Type="System.Threading.Tasks.TaskCreationOptions" />
        <Parameter Name="scheduler" Type="System.Threading.Tasks.TaskScheduler" />
      </Parameters>
      <Docs>
        <param name="function">Delegado de función que devuelve el resultado futuro que va a estar disponible a través de la tarea.</param>
        <param name="state">Objeto que contiene los datos que va a utilizar el delegado de <paramref name="function" />.</param>
        <param name="cancellationToken">Token de cancelación que se va a asignar a la nueva tarea.</param>
        <param name="creationOptions">Uno de los valores de enumeración que controla el comportamiento de la tarea creada.</param>
        <param name="scheduler">Programador de tareas que se usó para programar la tarea creada.</param>
        <summary>Crea e inicia una tarea.</summary>
        <returns>La tarea iniciada.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Una llamada a `StartNew` es funcionalmente equivalente a la creación de una tarea mediante uno de los <xref:System.Threading.Tasks.Task%601> constructores y, a continuación, que realiza la llamada la <xref:System.Threading.Tasks.Task.Start%2A> método para programar su ejecución.  
  
 Sin embargo, a menos que la creación y la programación deben estar separados, `StartNew` es el enfoque recomendado para mayor simplicidad y rendimiento.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Ya se ha eliminado el origen de token de cancelación que ha creado <paramref name="cancellationToken" />.</exception>
        <exception cref="T:System.ArgumentNullException">El argumento <paramref name="function" /> es <see langword="null" />.  
  
O bien 
El argumento <paramref name="scheduler" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">El parámetro <paramref name="creationOptions" /> especifica un valor no válido.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">Biblioteca de procesamiento paralelo basado en tareas (TPL)</related>
        <related type="Article" href="~/docs/standard/parallel-programming/using-tpl-with-other-asynchronous-patterns.md">Usar TPL con otros patrones asincrónicos</related>
      </Docs>
    </Member>
  </Members>
</Type>