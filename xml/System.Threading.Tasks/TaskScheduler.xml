<Type Name="TaskScheduler" FullName="System.Threading.Tasks.TaskScheduler">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="4d9adf13c8a7e851e5512c4b8b0e6ada78afa563" />
    <Meta Name="ms.sourcegitcommit" Value="6a0b904069161bbaec4ffd02aa7d9cf38c61e72e" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="es-ES" />
    <Meta Name="ms.lasthandoff" Value="06/24/2018" />
    <Meta Name="ms.locfileid" Value="36407625" />
  </Metadata>
  <TypeSignature Language="C#" Value="public abstract class TaskScheduler" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract beforefieldinit TaskScheduler extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Threading.Tasks.TaskScheduler" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class TaskScheduler" />
  <TypeSignature Language="C++ CLI" Value="public ref class TaskScheduler abstract" />
  <TypeSignature Language="F#" Value="type TaskScheduler = class" />
  <AssemblyInfo>
    <AssemblyName>System.Threading.Tasks</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.Diagnostics.DebuggerDisplay("Id={Id}")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Diagnostics.DebuggerTypeProxy(typeof(System.Threading.Tasks.TaskScheduler/SystemThreadingTasks_TaskSchedulerDebugView))</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Representa un objeto que administra el trabajo de bajo nivel de poner en cola tareas en los subprocesos.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Una instancia de la <xref:System.Threading.Tasks.TaskScheduler> clase representa un programador de tareas. Un programador de tareas asegura que se ejecuta el trabajo de una tarea.  
  
 El programador de tareas predeterminado está basado en el grupo de subprocesos .NET Framework 4, que proporciona robo de trabajo para el equilibrio de carga, inyección/retirada de subprocesos, a fin de obtener el máximo resultado y un buen rendimiento en general. Debería ser suficiente para la mayoría de los escenarios.  
  
 La <xref:System.Threading.Tasks.TaskScheduler> clase también actúa como el punto de extensión para toda la lógica de programación personalizable.  Esto incluye mecanismos como cómo programar una tarea para su ejecución y las tareas programadas cómo debe mostrarse a depuradores. Si necesita funcionalidad especial, puede crear a un programador personalizado y habilitarlo para tareas o consultas concretas.  
  
 En este tema:  
[El programador de tareas predeterminado y el grupo de subprocesos](#Default)  
 [La cola global frente a las colas locales](#Queues)  
 [Robo de trabajo](#Stealing)  
 [Tareas de larga duración](#LongRunning)  
 [Inclusión de tareas](#Inlining)  
[Especificar un contexto de sincronización](#Sync)  
  
<a name="Default"></a>   
## <a name="the-default-task-scheduler-and-the-thread-pool"></a>El programador de tareas predeterminado y el grupo de subprocesos  
 El programador predeterminado para el Task Parallel Library y PLINQ utiliza el grupo de subprocesos de .NET Framework, que se representa mediante el <xref:System.Threading.ThreadPool> (clase), poner en cola y ejecutar el trabajo. El grupo de subprocesos utiliza la información proporcionada por el <xref:System.Threading.Tasks.Task> tipo para admitir el paralelismo específico (unidades efímeras de trabajo) que las tareas y consultas paralelas a menudo representan.  
  
<a name="Queues"></a>   
### <a name="the-global-queue-vs-local-queues"></a>La cola global frente a las colas locales  
 El grupo de subprocesos mantiene la cola de subprocesos en cada dominio de aplicación de trabajo de un global FIFO (primero en salir). Cuando un programa llama la <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A?displayProperty=nameWithType> (o <xref:System.Threading.ThreadPool.UnsafeQueueUserWorkItem%2A?displayProperty=nameWithType>) método, el trabajo es poner en esta cola compartida y finalmente sale de la cola hacia el subproceso siguiente que está disponible. A partir de .NET Framework 4, esta cola se ha mejorado para usar un algoritmo sin bloqueo que se parece a la <xref:System.Collections.Concurrent.ConcurrentQueue%601> clase. Mediante esta implementación sin bloqueo, el grupo de subprocesos emplea menos tiempo en poner y sacar elementos de trabajo de las colas. Esta ventaja de rendimiento está disponible para todos los programas que usan el grupo de subprocesos.  
  
 Las tareas de nivel superior, que son tareas que no se crean en el contexto de otra tarea, se colocan en la cola global igual que cualquier otro elemento de trabajo. Sin embargo, las tareas anidadas o secundarias, que se crean en el contexto de otra tarea, se controlan de forma bastante distinta. Una tarea secundaria o anidada se coloca en una cola local que es específica del subproceso en el que la tarea primaria se está ejecutando. La tarea primaria puede ser una tarea de nivel superior o también puede ser el elemento secundario de otra tarea. Cuando este subproceso está listo para más trabajo, primero busca en la cola local. Si hay elementos de trabajo esperando, se puede tener acceso a ellos rápidamente. Se tiene acceso a las colas locales en el orden último en salir (LIFO) para conservar el emplazamiento en caché y reducir la contención. Para obtener más información acerca de las tareas secundarias y anidadas, vea [adjuntas y tareas secundarias desasociadas](~/docs/standard/parallel-programming/attached-and-detached-child-tasks.md).  
  
 El uso de colas locales no solo reduce la presión en la cola global, pero que también aprovecha las ventajas de la situación de los datos. Cola de elementos de trabajo en el equipo local con frecuencia las estructuras de datos de referencia que están físicamente cerca entre sí en la memoria. En estos casos, los datos ya están en la memoria caché después de la primera tarea se ha ejecutado y se puede obtener acceso rápidamente. Ambos [Parallel LINQ (PLINQ)](~/docs/standard/parallel-programming/parallel-linq-plinq.md) y <xref:System.Threading.Tasks.Parallel> clase usa tareas anidadas y tareas secundarias ampliamente y conseguir aumentos significativos de velocidad utilizando las colas de trabajo locales.  
  
<a name="Stealing"></a>   
### <a name="work-stealing"></a>Robo de trabajo  
 A partir de .NET Framework 4, el grupo de subprocesos también incluye un algoritmo de robo de trabajo para ayudar a asegurar que ningún subproceso esté inactivo mientras otros todavía tienen trabajo en sus colas. Cuando un subproceso ThreadPool está listo para más trabajo, examina primero el encabezado de la cola local, a continuación, en la cola global y después en las colas locales de otros subprocesos. Si encuentra un elemento de trabajo en la cola local de otro subproceso, aplica primero heurística para asegurarse de que puede ejecutar el trabajo eficazmente. Si es posible, quita de la cola el elemento de trabajo de la cola (en orden FIFO). Esto reduce la contención en cada cola local y mantiene la situación de los datos. Esta arquitectura permite el equilibrio de carga de grupo de subprocesos trabajar más eficazmente que en versiones anteriores.  
  
<a name="LongRunning"></a>   
### <a name="long-running-tasks"></a>Tareas de larga duración  
 Tal vez le interese evitar explícitamente que una tarea se coloque en una cola local. Por ejemplo, puede saber que un elemento de trabajo determinado se ejecutará durante un tiempo relativamente largo y es probable que bloquee el resto de los elementos de trabajo de la cola local. En este caso, puede especificar la opción <xref:System.Threading.Tasks.TaskCreationOptions?displayProperty=nameWithType>, que proporciona una sugerencia al programador que le indica que tal vez es necesario un subproceso adicional para que la tarea no bloquee el progreso de otros subprocesos o elementos de trabajo de la cola local. Mediante esta opción no el grupo de subprocesos por completo, incluidas las colas globales y locales.  
  
<a name="Inlining"></a>   
### <a name="task-inlining"></a>Inclusión de tareas  
 En algunos casos, cuando un <xref:System.Threading.Tasks.Task> se espera, se puede ejecutar sincrónicamente en el subproceso que realiza la operación de espera. Esto mejora el rendimiento evitando la necesidad de un subproceso adicional y usar en su lugar, el subproceso existente que se habría bloqueado en caso contrario. Para evitar errores de volver a entrar, inclusión de tareas solo se produce cuando el destino de la espera se encuentra en la cola local del subproceso pertinente.  
  
<a name="Sync"></a>   
## <a name="specifying-a-synchronization-context"></a>Especificar un contexto de sincronización  
 Puede utilizar el método <xref:System.Threading.Tasks.TaskScheduler.FromCurrentSynchronizationContext%2A?displayProperty=nameWithType> para especificar que una tarea se debería programar para ejecutarse en un subproceso determinado. Esto es útil en marcos como Windows Forms y Windows Presentation Foundation, donde el acceso a los objetos de interfaz de usuario está restringido a menudo para el código que se está ejecutando en el mismo subproceso en el que se creó el objeto UI.  
  
 En el ejemplo siguiente se usa el <xref:System.Threading.Tasks.TaskScheduler.FromCurrentSynchronizationContext%2A?displayProperty=nameWithType> método en una aplicación de Windows Presentation Foundation (WPF) para programar una tarea en el mismo subproceso donde se creó el control de interfaz de usuario.   En el ejemplo se crea un mosaico de imágenes que se seleccionan aleatoriamente de un directorio especificado. Los objetos WPF se utilizan para cargar y cambiar el tamaño de las imágenes. Los píxeles sin formato, a continuación, se pasan a una tarea que usa un <xref:System.Threading.Tasks.Parallel.For%2A> bucle para escribir los datos de píxeles en una matriz grande de un solo byte. Se necesita ninguna sincronización porque no hay dos mosaicos ocupa los mismos elementos de matriz. Los iconos también pueden escribirse en cualquier orden porque su posición se calcula independientemente de cualquier otro icono. La matriz de gran tamaño, a continuación, se pasa a una tarea que se ejecuta en el subproceso de interfaz de usuario, que se cargan los datos de píxeles en un control de imagen.  
  
 El ejemplo mueve los datos desde el subproceso de interfaz de usuario, se modifica mediante el uso de bucles paralelos y <xref:System.Threading.Tasks.Task> objetos y, a continuación, se pasa a una tarea que se ejecuta en el subproceso de interfaz de usuario. Este enfoque es útil cuando deba utilizar Task Parallel Library para realizar operaciones que no son compatibles con la API de WPF, o que no son suficientemente rápidos. Otra manera de crear un mosaico de la imagen en WPF es usar un <xref:System.Windows.Controls.WrapPanel?displayProperty=nameWithType> controlar y agregar imágenes a él. El <xref:System.Windows.Controls.WrapPanel> administra el trabajo de colocar los mosaicos. Sin embargo, este trabajo solo puede realizarse en el subproceso de interfaz de usuario.  
  
 [!code-csharp[TPL_SyncContext#01](~/samples/snippets/csharp/VS_Snippets_Misc/tpl_synccontext/cs/mainwindow.xaml.cs#01)]
 [!code-vb[TPL_SyncContext#01](~/samples/snippets/visualbasic/VS_Snippets_Misc/tpl_synccontext/vb/MainWindow.xaml.vb#01)]  
  
 Para crear el ejemplo, cree un proyecto de aplicación de WPF en Visual Studio y asígnele un nombre de su elección. A continuación, haga lo siguiente:  
  
1.  En la vista de diseño, arrastre un <xref:System.Windows.Controls.Image> controlar desde la **cuadro de herramientas** a la superficie de diseño. En la vista XAML, especificar la alineación horizontal como "Left". El tamaño no importa porque se redimensiona el control de forma dinámica en tiempo de ejecución. Acepte el nombre predeterminado, "image".  
  
2.  Arrastre un <xref:System.Windows.Controls.Button> controlar desde la **cuadro de herramientas** en la parte inferior izquierda de la ventana de la aplicación. Haga doble clic en el botón para agregar una <xref:System.Windows.Controls.Primitives.ButtonBase.Click> controlador de eventos. En la vista XAML, especifique la <xref:System.Windows.Controls.ContentControl.Content%2A> propiedad del botón como "Hacer que un mosaico" y especifica la alineación horizontal como "Left". Acepte el nombre predeterminado, "button".  
  
3.  Reemplace todo el contenido del archivo MainWindow.xaml.cs o MainWindow.xaml.vb por el código de este ejemplo. Asegúrese de que el nombre del área de trabajo coincide con el nombre del proyecto.  
  
4.  En el ejemplo se lee las imágenes JPEG de un directorio denominado C:\Users\Public\Pictures\Sample Pictures\\. Crear el directorio y coloque algunas imágenes en ella o cambiar la ruta de acceso para hacer referencia a cualquier otro directorio que contiene imágenes.  
  
 Este ejemplo tiene algunas limitaciones. Por ejemplo, se admiten imágenes de solo 32-bits por píxel; imágenes en otros formatos están dañadas por la <xref:System.Windows.Media.Imaging.BitmapImage> objeto durante la operación de cambio de tamaño. Además, las imágenes de origen deben mayores que el tamaño del mosaico. Como un ejercicio más extenso, puede agregar funcionalidad para controlar varios formatos de píxel y tamaños de archivo.  
  
   
  
## Examples  
 En el siguiente ejemplo se toma de la [ejemplos de programación en paralelo con .NET Framework 4](http://go.microsoft.com/fwlink/?LinkID=165717) en el sitio Web de MSDN Code Gallery.  Crea a un programador de tareas personalizado que limita el número de subprocesos utilizados por la aplicación. A continuación, inicia dos conjuntos de tareas y muestra información acerca de la tarea y el subproceso en el que se ejecuta la tarea.  
  
 [!code-csharp[TPL_Schedulers#02](~/samples/snippets/csharp/VS_Snippets_Misc/tpl_schedulers/cs/limitex1.cs#02)]
 [!code-vb[TPL_Schedulers#02](~/samples/snippets/visualbasic/VS_Snippets_Misc/tpl_schedulers/vb/module2.vb#02)]  
  
 Además, varios programadores de tareas de ejemplo están disponibles en la Galería de código: [ejemplos de programación en paralelo con .NET Framework 4](http://go.microsoft.com/fwlink/?LinkID=165717).  
  
 ]]></format>
    </remarks>
    <threadsafe>Todos los miembros de la abstracta <see cref="T:System.Threading.Tasks.TaskScheduler" /> tipo son seguros para subprocesos y se pueden usar desde varios subprocesos simultáneamente.</threadsafe>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected TaskScheduler ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskScheduler.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; TaskScheduler();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inicializa el <see cref="T:System.Threading.Tasks.TaskScheduler" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Current">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.TaskScheduler Current { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Threading.Tasks.TaskScheduler Current" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.TaskScheduler.Current" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property Current As TaskScheduler" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Threading::Tasks::TaskScheduler ^ Current { System::Threading::Tasks::TaskScheduler ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Current : System.Threading.Tasks.TaskScheduler" Usage="System.Threading.Tasks.TaskScheduler.Current" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.TaskScheduler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene el objeto <see cref="T:System.Threading.Tasks.TaskScheduler" /> asociado a la tarea que se está ejecutando actualmente.</summary>
        <value>Devuelve el objeto <see cref="T:System.Threading.Tasks.TaskScheduler" /> asociado a la tarea que se está ejecutando actualmente.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cuando no se llama desde dentro de una tarea, <xref:System.Threading.Tasks.TaskScheduler.Current%2A> devolverá el <xref:System.Threading.Tasks.TaskScheduler.Default%2A> programador.  
  
 Para obtener más información, vea <xref:System.Threading.Tasks.TaskScheduler>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Default">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.TaskScheduler Default { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Threading.Tasks.TaskScheduler Default" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.TaskScheduler.Default" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property Default As TaskScheduler" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Threading::Tasks::TaskScheduler ^ Default { System::Threading::Tasks::TaskScheduler ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Default : System.Threading.Tasks.TaskScheduler" Usage="System.Threading.Tasks.TaskScheduler.Default" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.TaskScheduler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene la instancia predeterminada de <see cref="T:System.Threading.Tasks.TaskScheduler" /> proporcionada por .NET Framework.</summary>
        <value>Devuelve la instancia predeterminada de <see cref="T:System.Threading.Tasks.TaskScheduler" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para obtener más información, consulte [programadores de tareas](http://msdn.microsoft.com/library/638f8ea5-21db-47a2-a934-86e1e961bf65).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FromCurrentSynchronizationContext">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.TaskScheduler FromCurrentSynchronizationContext ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.TaskScheduler FromCurrentSynchronizationContext() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskScheduler.FromCurrentSynchronizationContext" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FromCurrentSynchronizationContext () As TaskScheduler" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Tasks::TaskScheduler ^ FromCurrentSynchronizationContext();" />
      <MemberSignature Language="F#" Value="static member FromCurrentSynchronizationContext : unit -&gt; System.Threading.Tasks.TaskScheduler" Usage="System.Threading.Tasks.TaskScheduler.FromCurrentSynchronizationContext " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.TaskScheduler</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Crea un <see cref="T:System.Threading.Tasks.TaskScheduler" /> asociado con el <see cref="T:System.Threading.SynchronizationContext" /> actual.</summary>
        <returns>Un <see cref="T:System.Threading.Tasks.TaskScheduler" /> asociados con el <see cref="T:System.Threading.SynchronizationContext" /> actual, según lo determinado por <see cref="P:System.Threading.SynchronizationContext.Current" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Todos los <xref:System.Threading.Tasks.Task> instancias en cola para el valor devuelto programador que se va a ejecutar mediante una llamada a la <xref:System.Threading.SynchronizationContext.Post%2A> método en ese contexto.  
  
 Para obtener más información, consulte [programadores de tareas](http://msdn.microsoft.com/library/638f8ea5-21db-47a2-a934-86e1e961bf65).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">El SynchronizationContext actual no puede usarse como TaskScheduler.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetScheduledTasks">
      <MemberSignature Language="C#" Value="protected abstract System.Collections.Generic.IEnumerable&lt;System.Threading.Tasks.Task&gt; GetScheduledTasks ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Collections.Generic.IEnumerable`1&lt;class System.Threading.Tasks.Task&gt; GetScheduledTasks() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskScheduler.GetScheduledTasks" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Function GetScheduledTasks () As IEnumerable(Of Task)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract System::Collections::Generic::IEnumerable&lt;System::Threading::Tasks::Task ^&gt; ^ GetScheduledTasks();" />
      <MemberSignature Language="F#" Value="abstract member GetScheduledTasks : unit -&gt; seq&lt;System.Threading.Tasks.Task&gt;" Usage="taskScheduler.GetScheduledTasks " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Threading.Tasks.Task&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Solo por compatibilidad con el depurador, genera un enumerable de las instancias de <see cref="T:System.Threading.Tasks.Task" /> que se encuentran actualmente en la cola del programador a la espera de ser ejecutadas.</summary>
        <returns>Enumerable que permite a un depurador atravesar las tareas que se encuentran actualmente en la cola de este programador.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Una clase derivada de <xref:System.Threading.Tasks.TaskScheduler> implementa este método para admitir la integración con depuradores. .NET Framework solo invocará este método cuando el depurador solicita acceso a los datos. El enumerable devuelto se pueda recorrer por depuración utilidades para tener acceso a las tareas actualmente en cola en este programador, lo que permite al depurador proporcionar una representación de esta información en la interfaz de usuario.  
  
 Es importante tener en cuenta que, cuando se llama a este método, se bloquearán todos los demás subprocesos en el proceso. Por lo tanto, es importante evitar la sincronización con otros subprocesos que puede dar lugar al bloqueo. Si es necesaria la sincronización y no puede adquirir el bloqueo en este método, debería iniciar una excepción para que el depurador no se bloquea. En el ejemplo siguiente se muestra un posible enfoque en C#:  
  
```  
protected override IEnumerable<Task> GetScheduledTasks()  
{  
    bool lockTaken = false;  
    try  
    {  
        Monitor.TryEnter(_syncObj, ref lockTaken);  
        if (lockTaken)  
        {  
            return _tasks.ToArray();  
        }  
        else throw new NotSupportedException();  
    }  
    finally  
    {  
    if (lockTaken) Monitor.Exit(_syncObj);  
    }}  
```  
  
 Además, este método y el enumerable devuelto no debe modificar cualquier estado visible globalmente.  
  
 El enumerable no devuelto nunca debería ser null. Si no hay actualmente ninguna tarea en cola, debe devolverse un vacío enumerable en su lugar.  
  
 Los desarrolladores que están implementando depuradores personalizados no debe llamar directamente a este método, pero debe usar el método contenedor interna `GetScheduledTasksForDebugger` en su lugar: `internal Task[] GetScheduledTasksForDebugger()`. Este método contenedor devuelve una matriz de tareas en lugar de un enumerable. Para recuperar una lista de programadores activos, utilice el método interno `internal static TaskScheduler[] GetTaskSchedulersForDebugger()`. Este método estático devuelve una matriz de todos los activos <xref:System.Threading.Tasks.TaskScheduler> instancias. A continuación, puede usar `GetScheduledTasksForDebugger` en cada instancia del programador para recuperar su lista de tareas programadas.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Este programador no puede generar una lista de tareas en cola en este momento.</exception>
      </Docs>
    </Member>
    <Member MemberName="Id">
      <MemberSignature Language="C#" Value="public int Id { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Id" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.TaskScheduler.Id" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Id As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Id { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Id : int" Usage="System.Threading.Tasks.TaskScheduler.Id" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene el identificador único de este <see cref="T:System.Threading.Tasks.TaskScheduler" />.</summary>
        <value>Devuelve el identificador único de este objeto <see cref="T:System.Threading.Tasks.TaskScheduler" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para obtener más información, consulte [programadores de tareas](http://msdn.microsoft.com/library/638f8ea5-21db-47a2-a934-86e1e961bf65).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MaximumConcurrencyLevel">
      <MemberSignature Language="C#" Value="public virtual int MaximumConcurrencyLevel { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 MaximumConcurrencyLevel" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.TaskScheduler.MaximumConcurrencyLevel" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property MaximumConcurrencyLevel As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property int MaximumConcurrencyLevel { int get(); };" />
      <MemberSignature Language="F#" Value="member this.MaximumConcurrencyLevel : int" Usage="System.Threading.Tasks.TaskScheduler.MaximumConcurrencyLevel" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Indica el nivel de simultaneidad máximo admitido por este <see cref="T:System.Threading.Tasks.TaskScheduler" />.</summary>
        <value>Devuelve un entero que representa el nivel máximo de simultaneidad. El programador predeterminado devuelve <see cref="F:System.Int32.MaxValue" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para obtener más información, consulte [programadores de tareas](http://msdn.microsoft.com/library/638f8ea5-21db-47a2-a934-86e1e961bf65).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="QueueTask">
      <MemberSignature Language="C#" Value="protected internal abstract void QueueTask (System.Threading.Tasks.Task task);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void QueueTask(class System.Threading.Tasks.Task task) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskScheduler.QueueTask(System.Threading.Tasks.Task)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; abstract void QueueTask(System::Threading::Tasks::Task ^ task);" />
      <MemberSignature Language="F#" Value="abstract member QueueTask : System.Threading.Tasks.Task -&gt; unit" Usage="taskScheduler.QueueTask task" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="task" Type="System.Threading.Tasks.Task" />
      </Parameters>
      <Docs>
        <param name="task">Objeto <see cref="T:System.Threading.Tasks.Task" /> que se va a poner en la cola.</param>
        <summary>Pone un objeto <see cref="T:System.Threading.Tasks.Task" /> en la cola del programador.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Una clase derivada de <xref:System.Threading.Tasks.TaskScheduler> implementa este método para aceptar tareas que se programan en el programador.  
  
 Una implementación típica almacenaría la tarea en una estructura de datos interna, que se les preste servicio subprocesos que ejecutarían esas tareas en algún momento en el futuro.  
  
 Este método solo está pensado para ser llamado por .NET Framework y no se debe llamar directamente mediante la clase derivada. Esto es necesario para mantener la coherencia del sistema.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El argumento <paramref name="task" /> es null.</exception>
      </Docs>
    </Member>
    <Member MemberName="TryDequeue">
      <MemberSignature Language="C#" Value="protected internal virtual bool TryDequeue (System.Threading.Tasks.Task task);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance bool TryDequeue(class System.Threading.Tasks.Task task) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskScheduler.TryDequeue(System.Threading.Tasks.Task)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual bool TryDequeue(System::Threading::Tasks::Task ^ task);" />
      <MemberSignature Language="F#" Value="abstract member TryDequeue : System.Threading.Tasks.Task -&gt; bool&#xA;override this.TryDequeue : System.Threading.Tasks.Task -&gt; bool" Usage="taskScheduler.TryDequeue task" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="task" Type="System.Threading.Tasks.Task" />
      </Parameters>
      <Docs>
        <param name="task">Objeto <see cref="T:System.Threading.Tasks.Task" /> que se va a quitar de la cola.</param>
        <summary>Intenta quitar un objeto <see cref="T:System.Threading.Tasks.Task" /> de la cola de este programador.</summary>
        <returns>Valor booleano que indica si el argumento <paramref name="task" /> se quitó correctamente de la cola.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para obtener más información, consulte [programadores de tareas](http://msdn.microsoft.com/library/638f8ea5-21db-47a2-a934-86e1e961bf65).  
  
 Este método puede ejecutarse en un bloque finally; por lo tanto, debe devolver lo más rápido posible así que cualquier recursos como <xref:System.Threading.CancellationTokenRegistration> objetos pueden eliminarse de manera oportuna.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El argumento <paramref name="task" /> es null.</exception>
      </Docs>
    </Member>
    <Member MemberName="TryExecuteTask">
      <MemberSignature Language="C#" Value="protected bool TryExecuteTask (System.Threading.Tasks.Task task);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance bool TryExecuteTask(class System.Threading.Tasks.Task task) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskScheduler.TryExecuteTask(System.Threading.Tasks.Task)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; bool TryExecuteTask(System::Threading::Tasks::Task ^ task);" />
      <MemberSignature Language="F#" Value="member this.TryExecuteTask : System.Threading.Tasks.Task -&gt; bool" Usage="taskScheduler.TryExecuteTask task" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="task" Type="System.Threading.Tasks.Task" />
      </Parameters>
      <Docs>
        <param name="task">Objeto <see cref="T:System.Threading.Tasks.Task" /> que se va a ejecutar.</param>
        <summary>Intenta ejecutar el objeto <see cref="T:System.Threading.Tasks.Task" /> especificado en este programador.</summary>
        <returns>Valor booleano que es true si <paramref name="task" /> se ejecutó correctamente; de lo contrario, es false. Normalmente, los errores de ejecución son debidos a que la tarea ya se ha ejecutado anteriormente o está a punto de ser ejecutada por otro subproceso.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Las implementaciones del programador se proporcionan con <xref:System.Threading.Tasks.Task> instancias que se ejecute a través la <xref:System.Threading.Tasks.TaskScheduler.QueueTask%2A> método o la <xref:System.Threading.Tasks.TaskScheduler.TryExecuteTaskInline%2A> método. Cuando el programador considere oportunas ejecutar la tarea proporcionada, <xref:System.Threading.Tasks.TaskScheduler.TryExecuteTask%2A> debe utilizarse para hacerlo. TryExecuteTask controla todos los aspectos de la ejecución de una tarea, incluida la invocación de la acción, control de excepciones, administración de Estados y control del ciclo de vida.  
  
 <xref:System.Threading.Tasks.TaskScheduler.TryExecuteTask%2A> solo debe usarse para las tareas proporcionadas a este programador por la infraestructura de .NET Framework. No debe usarse para ejecutar tareas arbitrarias obtenidas a través de mecanismos personalizados.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">La <paramref name="task" /> no está asociada a este programador.</exception>
      </Docs>
    </Member>
    <Member MemberName="TryExecuteTaskInline">
      <MemberSignature Language="C#" Value="protected abstract bool TryExecuteTaskInline (System.Threading.Tasks.Task task, bool taskWasPreviouslyQueued);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool TryExecuteTaskInline(class System.Threading.Tasks.Task task, bool taskWasPreviouslyQueued) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskScheduler.TryExecuteTaskInline(System.Threading.Tasks.Task,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract bool TryExecuteTaskInline(System::Threading::Tasks::Task ^ task, bool taskWasPreviouslyQueued);" />
      <MemberSignature Language="F#" Value="abstract member TryExecuteTaskInline : System.Threading.Tasks.Task * bool -&gt; bool" Usage="taskScheduler.TryExecuteTaskInline (task, taskWasPreviouslyQueued)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="task" Type="System.Threading.Tasks.Task" />
        <Parameter Name="taskWasPreviouslyQueued" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="task">Objeto <see cref="T:System.Threading.Tasks.Task" /> que se va a ejecutar.</param>
        <param name="taskWasPreviouslyQueued">Valor booleano que indica si la tarea se ha puesto anteriormente en la cola. Si este parámetro es True, la tarea se ha puesto en la cola (programado) anteriormente; si su valor es False, la tarea no se ha puesto anteriormente en la cola y esta llamada se realiza para ejecutar la tarea insertada sin ponerla en la cola.</param>
        <summary>Determina si el objeto <see cref="T:System.Threading.Tasks.Task" /> especificado puede ejecutarse sincrónicamente en esta llamada y, en caso afirmativo, lo ejecuta.</summary>
        <returns>Valor booleano que indica si se ejecutó la tarea alineada.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Una clase derivada de <xref:System.Threading.Tasks.TaskScheduler> implementa esta función para admitir la ejecución de en línea de una tarea en un subproceso que inicia una espera en ese objeto de tarea. Ejecución en línea es opcional y se puede rechazar la solicitud devolviendo false. Sin embargo, las tareas más que puede ser entre líneas, mejor será el programador escalará. De hecho, un programador que inserte muy poca puede ser susceptible a los interbloqueos. Una implementación correcta debe asegurarse de que una solicitud que se ejecute bajo las directivas garantizadas por el programador pueda correctamente alineado. Por ejemplo, si un programador utiliza un subproceso dedicado para ejecutar las tareas, las solicitudes de inserción desde ese subproceso deben ejecutarse correctamente.  
  
 Si un programador decide realizar la ejecución en línea, deberá hacerlo mediante una llamada para el objeto TaskScheduler base <xref:System.Threading.Tasks.TaskScheduler.TryExecuteTask%2A> método con el objeto de tarea proporcionado, propagando el valor devuelto. También puede ser adecuado para el programador quitar una tarea insertada de sus estructuras de datos internas si decide aceptar la solicitud de inserción. Sin embargo, tenga en cuenta que en algunas circunstancias un programador se pedirá a en línea una tarea que no se proporcionó anteriormente a él con el <xref:System.Threading.Tasks.TaskScheduler.QueueTask%2A> método.  
  
 El programador derivado es responsable de asegurarse de que el subproceso que realiza la llamada es adecuado para ejecutar la tarea determinada en la medida de su propia programación y se refiere a las directivas de ejecución.  
  
 Para obtener más información, consulte [programadores de tareas](http://msdn.microsoft.com/library/638f8ea5-21db-47a2-a934-86e1e961bf65).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El argumento <paramref name="task" /> es null.</exception>
        <exception cref="T:System.InvalidOperationException">La <paramref name="task" /> ya se ejecutó.</exception>
      </Docs>
    </Member>
    <Member MemberName="UnobservedTaskException">
      <MemberSignature Language="C#" Value="public static event EventHandler&lt;System.Threading.Tasks.UnobservedTaskExceptionEventArgs&gt; UnobservedTaskException;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Threading.Tasks.UnobservedTaskExceptionEventArgs&gt; UnobservedTaskException" />
      <MemberSignature Language="DocId" Value="E:System.Threading.Tasks.TaskScheduler.UnobservedTaskException" />
      <MemberSignature Language="VB.NET" Value="Public Shared Custom Event UnobservedTaskException As EventHandler(Of UnobservedTaskExceptionEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static event EventHandler&lt;System::Threading::Tasks::UnobservedTaskExceptionEventArgs ^&gt; ^ UnobservedTaskException;" />
      <MemberSignature Language="F#" Value="member this.UnobservedTaskException : EventHandler&lt;System.Threading.Tasks.UnobservedTaskExceptionEventArgs&gt; " Usage="member this.UnobservedTaskException : System.EventHandler&lt;System.Threading.Tasks.UnobservedTaskExceptionEventArgs&gt; " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>add: System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>remove: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Threading.Tasks.UnobservedTaskExceptionEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produce cuando la excepción no observada de un error de la tarea está a punto de desencadenar la directiva de escalado de excepción que, de forma predeterminada, finalizaría el proceso.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este evento de todo el dominio de aplicación proporciona un mecanismo para evitar que la directiva de elevación de excepciones (que, de forma predeterminada, finaliza el proceso) de desencadenamiento.  
  
 Para facilitar a los desarrolladores a escribir código asincrónico basado en tareas, el [!INCLUDE[net_v45](~/includes/net-v45-md.md)] cambia el comportamiento de excepción predeterminado para las excepciones inadvertidas. Aunque todavía excepciones inadvertidas generan el <xref:System.Threading.Tasks.TaskScheduler.UnobservedTaskException> excepción, el proceso no termina de forma predeterminada. En su lugar, se controla la excepción en tiempo de ejecución después de que se genera el evento, independientemente de si la excepción ajusta a un controlador de eventos. Este comportamiento puede configurarse. A partir de la [!INCLUDE[net_v45](~/includes/net-v45-md.md)], puede usar el elemento de configuración para revertir al comportamiento de la [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)] y finalizar el proceso:  
  
```xml  
<configuration>   
   <runtime>   
      <ThrowUnobservedTaskExceptions enabled="true"/>   
   </runtime>   
</configuration>  
  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>