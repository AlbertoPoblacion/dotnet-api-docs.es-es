<Type Name="TaskScheduler" FullName="System.Threading.Tasks.TaskScheduler">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="f670671d10e88fb387d144258ea97f697634fc8d" />
    <Meta Name="ms.sourcegitcommit" Value="0ec122ee5f3681159b8460ab15b409fd6e3d3ae0" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="es-ES" />
    <Meta Name="ms.lasthandoff" Value="10/04/2018" />
    <Meta Name="ms.locfileid" Value="48765550" />
  </Metadata>
  <TypeSignature Language="C#" Value="public abstract class TaskScheduler" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract beforefieldinit TaskScheduler extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Threading.Tasks.TaskScheduler" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class TaskScheduler" />
  <TypeSignature Language="C++ CLI" Value="public ref class TaskScheduler abstract" />
  <TypeSignature Language="F#" Value="type TaskScheduler = class" />
  <AssemblyInfo>
    <AssemblyName>System.Threading.Tasks</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Diagnostics.DebuggerDisplay("Id={Id}")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Diagnostics.DebuggerTypeProxy(typeof(System.Threading.Tasks.TaskScheduler/SystemThreadingTasks_TaskSchedulerDebugView))</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Representa un objeto que administra el trabajo de bajo nivel de poner en cola tareas en los subprocesos.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Una instancia de la <xref:System.Threading.Tasks.TaskScheduler> clase representa un programador de tareas. Un programador de tareas asegura que se ejecuta el trabajo de una tarea.  
  
 El programador de tareas predeterminado está basado en el grupo de subprocesos .NET Framework 4, que proporciona robo de trabajo para el equilibrio de carga, inyección/retirada de subprocesos, a fin de obtener el máximo resultado y un buen rendimiento en general. Debería ser suficiente para la mayoría de los escenarios.  
  
 La <xref:System.Threading.Tasks.TaskScheduler> clase también actúa como el punto de extensión para toda la lógica de programación personalizable.  Esto incluye mecanismos, como cómo programar una tarea para su ejecución y las tareas programadas de cómo se debe exponer a los depuradores. Si necesita funcionalidad especial, puede crear a un programador personalizado y habilitarlo para tareas específicas o las consultas.  
  
 En este tema:  
[El programador de tareas predeterminado y el grupo de subprocesos](#Default)  
 [La cola global frente a las colas locales](#Queues)  
 [Robo de trabajo](#Stealing)  
 [Tareas de ejecución prolongada](#LongRunning)  
 [Inclusión de tareas](#Inlining)  
[Especifica un contexto de sincronización](#Sync)  
  
<a name="Default"></a>   
## <a name="the-default-task-scheduler-and-the-thread-pool"></a>El programador de tareas predeterminado y el grupo de subprocesos  
 El programador predeterminado para la biblioteca TPL y PLINQ usa el grupo de subprocesos de .NET Framework, que viene representado por la <xref:System.Threading.ThreadPool> (clase), para poner en cola y ejecutar el trabajo. El grupo de subprocesos usa la información suministrada por el <xref:System.Threading.Tasks.Task> tipo para admitir el paralelismo específico (unidades efímeras de trabajo) que en paralelo las tareas y las consultas a menudo representan de forma eficaz.  
  
<a name="Queues"></a>   
### <a name="the-global-queue-vs-local-queues"></a>La cola global frente a las colas locales  
 El grupo de subprocesos mantiene la cola de subprocesos en cada dominio de aplicación de trabajo de un global FIFO (primero en salir). Cada vez que un programa llama a la <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A?displayProperty=nameWithType> (o <xref:System.Threading.ThreadPool.UnsafeQueueUserWorkItem%2A?displayProperty=nameWithType>) método, el trabajo es poner en esta cola compartida y finalmente sale de la cola hacia el subproceso siguiente que está disponible. A partir de .NET Framework 4, esta cola se ha mejorado para usar un algoritmo sin bloqueo que se parezca a la <xref:System.Collections.Concurrent.ConcurrentQueue%601> clase. Mediante esta implementación sin bloqueo, el grupo de subprocesos emplea menos tiempo en poner y sacar elementos de trabajo de las colas. Esta ventaja de rendimiento está disponible para todos los programas que usan el grupo de subprocesos.  
  
 Las tareas de nivel superior, que son tareas que no se crean en el contexto de otra tarea, se colocan en la cola global igual que cualquier otro elemento de trabajo. Sin embargo, las tareas anidadas o secundarias, que se crean en el contexto de otra tarea, se controlan de forma bastante distinta. Una tarea secundaria o anidada se coloca en una cola local que es específica del subproceso en el que la tarea primaria se está ejecutando. La tarea primaria puede ser una tarea de nivel superior o también puede ser el elemento secundario de otra tarea. Cuando este subproceso está listo para más trabajo, primero busca en la cola local. Si hay elementos de trabajo esperando, se puede tener acceso a ellos rápidamente. Se tiene acceso a las colas locales en el orden último en salir (LIFO) para conservar la localidad de memoria caché y reducir la contención. Para obtener más información acerca de las tareas secundarias y anidadas, vea [adjuntas y tareas secundarias desasociadas](~/docs/standard/parallel-programming/attached-and-detached-child-tasks.md).  
  
 El uso de colas locales no sólo reduce la presión en la cola global, sino que también aprovecha las ventajas de la localidad de los datos. Los elementos de trabajo locales en cola con frecuencia las estructuras de datos de referencia que se encuentran físicamente próximos entre sí en memoria. En estos casos, los datos ya están en la memoria caché después de la primera tarea se ha ejecutado y se puede acceder rápidamente. Ambos [Parallel LINQ (PLINQ)](~/docs/standard/parallel-programming/parallel-linq-plinq.md) y <xref:System.Threading.Tasks.Parallel> ampliamente de clases usa tareas anidadas y tareas secundarias y conseguir aumentos significativos de velocidad mediante las colas de trabajo local.  
  
<a name="Stealing"></a>   
### <a name="work-stealing"></a>Robo de trabajo  
 A partir de .NET Framework 4, el grupo de subprocesos también incluye un algoritmo de robo de trabajo para ayudar a asegurarse de que no se encuentra ningún subproceso inactivo mientras otros todavía tienen trabajo en sus colas. Cuando un subproceso ThreadPool está listo para más trabajo, examina primero el encabezado de la cola local, a continuación, en la cola global y después en las colas locales de otros subprocesos. Si encuentra un elemento de trabajo en la cola local de otro subproceso, aplica primero heurística para asegurarse de que puede ejecutar el trabajo eficazmente. Si es posible, quita de la cola el elemento de trabajo de la cola (en orden FIFO). Esto reduce la contención en cada cola local y mantiene la situación de los datos. Esta arquitectura permite el equilibrio de carga de grupo de subprocesos funcione de manera más eficaz que versiones anteriores.  
  
<a name="LongRunning"></a>   
### <a name="long-running-tasks"></a>Tareas de ejecución prolongada  
 Tal vez le interese evitar explícitamente que una tarea se coloque en una cola local. Por ejemplo, puede saber que un elemento de trabajo determinado se ejecutará durante un tiempo relativamente largo y es probable que bloquee el resto de los elementos de trabajo de la cola local. En este caso, puede especificar la opción <xref:System.Threading.Tasks.TaskCreationOptions?displayProperty=nameWithType>, que proporciona una sugerencia al programador que le indica que tal vez es necesario un subproceso adicional para que la tarea no bloquee el progreso de otros subprocesos o elementos de trabajo de la cola local. Con esta opción evita el grupo de subprocesos por completo, incluidas las colas globales y locales.  
  
<a name="Inlining"></a>   
### <a name="task-inlining"></a>Inclusión de tareas  
 En algunos casos, cuando un <xref:System.Threading.Tasks.Task> se esperando, se puede ejecutar sincrónicamente en el subproceso que realiza la operación de espera. Esto mejora el rendimiento evitando la necesidad de un subproceso adicional y en su lugar utilizando el subproceso existente, que en caso contrario, se habría bloqueado. Para evitar errores debidos a la entrada reiterada, inclusión de tareas solo se produce cuando se encuentra el destino de la espera en cola local del subproceso pertinente.  
  
<a name="Sync"></a>   
## <a name="specifying-a-synchronization-context"></a>Especifica un contexto de sincronización  
 Puede utilizar el método <xref:System.Threading.Tasks.TaskScheduler.FromCurrentSynchronizationContext%2A?displayProperty=nameWithType> para especificar que una tarea se debería programar para ejecutarse en un subproceso determinado. Esto es útil en marcos como Windows Forms y Windows Presentation Foundation, donde el acceso a los objetos de interfaz de usuario está restringido a menudo para el código que se está ejecutando en el mismo subproceso en el que se creó el objeto UI.  
  
 En el ejemplo siguiente se usa el <xref:System.Threading.Tasks.TaskScheduler.FromCurrentSynchronizationContext%2A?displayProperty=nameWithType> método en una aplicación de Windows Presentation Foundation (WPF) para programar una tarea en el mismo subproceso donde se creó el control de interfaz de usuario.   En el ejemplo se crea un mosaico de imágenes que se seleccionan aleatoriamente de un directorio especificado. Los objetos de WPF se usan para cargar y cambiar el tamaño de las imágenes. Los píxeles sin procesar, a continuación, se pasan a una tarea que usa un <xref:System.Threading.Tasks.Parallel.For%2A> bucle para escribir los datos de píxeles en una matriz grande de un byte. Se necesita ninguna sincronización porque no hay dos iconos ocupan los mismos elementos de matriz. Los iconos también se pueden escribir en cualquier orden porque su posición se calcula independientemente de cualquier otro icono. La matriz de gran tamaño, a continuación, se pasa a una tarea que se ejecuta en el subproceso de interfaz de usuario, donde se cargan los datos de píxeles en un control de imagen.  
  
 El ejemplo mueve los datos fuera del subproceso de interfaz de usuario, lo modifica mediante el uso de bucles paralelos y <xref:System.Threading.Tasks.Task> objetos y, a continuación, se pasa a una tarea que se ejecuta en el subproceso de interfaz de usuario. Este enfoque es útil cuando tiene que usar la biblioteca TPL para realizar operaciones que no son compatibles con la API de WPF, o que no son lo suficientemente rápido. Otra forma de crear un mosaico de la imagen en WPF es usar un <xref:System.Windows.Controls.WrapPanel?displayProperty=nameWithType> controlar y agregar imágenes a él. El <xref:System.Windows.Controls.WrapPanel> controla el trabajo de colocar los iconos. Sin embargo, este trabajo solo puede realizarse en el subproceso de interfaz de usuario.  
  
 [!code-csharp[TPL_SyncContext#01](~/samples/snippets/csharp/VS_Snippets_Misc/tpl_synccontext/cs/mainwindow.xaml.cs#01)]
 [!code-vb[TPL_SyncContext#01](~/samples/snippets/visualbasic/VS_Snippets_Misc/tpl_synccontext/vb/MainWindow.xaml.vb#01)]  
  
 Para crear el ejemplo, cree un proyecto de aplicación de WPF en Visual Studio y asígnele un nombre de su elección. A continuación, haga lo siguiente:  
  
1.  En la vista Diseño, arrastre un <xref:System.Windows.Controls.Image> controlar desde la **cuadro de herramientas** a la superficie de diseño. En la vista XAML, especificar la alineación horizontal como "Left". El tamaño no importa porque el control se cambia el tamaño dinámicamente en tiempo de ejecución. Acepte el nombre predeterminado, "la imagen".  
  
2.  Arrastre un <xref:System.Windows.Controls.Button> controlar desde la **cuadro de herramientas** a la parte inferior izquierda de la ventana de la aplicación. Haga doble clic en el botón para agregar un <xref:System.Windows.Controls.Primitives.ButtonBase.Click> controlador de eventos. En la vista XAML, especifique el <xref:System.Windows.Controls.ContentControl.Content%2A> propiedad del botón como "Make un mosaico" y especifique la alineación horizontal como "Left". Acepte el nombre predeterminado, "button".  
  
3.  Reemplace todo el contenido del archivo MainWindow.xaml.cs o MainWindow.xaml.vb por el código de este ejemplo. Asegúrese de que el nombre del área de trabajo coincide con el nombre del proyecto.  
  
4.  El ejemplo lee las imágenes JPEG de un directorio denominado C:\Users\Public\Pictures\Sample Pictures\\. Cree el directorio y coloque algunas imágenes en ella o cambiar la ruta de acceso para hacer referencia a otro directorio que contiene imágenes.  
  
 En este ejemplo tiene algunas limitaciones. Por ejemplo, se admiten imágenes de sólo 32-bits por píxel; las imágenes en otros formatos están dañadas por la <xref:System.Windows.Media.Imaging.BitmapImage> objeto durante la operación de cambio de tamaño. Además, las imágenes de origen deben mayores que el tamaño del mosaico. Como ejercicio adicional, puede agregar funcionalidad para controlar varios formatos de píxel y tamaños de archivo.  
  
   
  
## Examples  
 En el siguiente ejemplo se toma de la [ejemplos de programación en paralelo con .NET Framework 4](http://go.microsoft.com/fwlink/?LinkID=165717) en el sitio Web de MSDN Code Gallery.  Crea a un programador de tareas personalizado que limita el número de subprocesos usados por la aplicación. A continuación, inicia dos conjuntos de tareas y muestra información acerca de la tarea y el subproceso en que se ejecuta la tarea.  
  
 [!code-csharp[TPL_Schedulers#02](~/samples/snippets/csharp/VS_Snippets_Misc/tpl_schedulers/cs/limitex1.cs#02)]
 [!code-vb[TPL_Schedulers#02](~/samples/snippets/visualbasic/VS_Snippets_Misc/tpl_schedulers/vb/module2.vb#02)]  
  
 Además, varios programadores de tareas de ejemplo están disponibles en la Galería de código: [ejemplos de programación en paralelo con .NET Framework 4](http://go.microsoft.com/fwlink/?LinkID=165717).  
  
 ]]></format>
    </remarks>
    <threadsafe>Todos los miembros de la abstracta <see cref="T:System.Threading.Tasks.TaskScheduler" /> tipo son seguros para subprocesos y se pueden usar desde varios subprocesos simultáneamente.</threadsafe>
    <altmember cref="T:System.Threading.Tasks.TaskScheduler" />
    <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">Biblioteca de procesamiento paralelo basado en tareas (TPL)</related>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected TaskScheduler ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskScheduler.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; TaskScheduler();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inicializa el <see cref="T:System.Threading.Tasks.TaskScheduler" />.</summary>
        <remarks>To be added.</remarks>
        <altmember cref="T:System.Threading.Tasks.TaskScheduler" />
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">Biblioteca de procesamiento paralelo basado en tareas (TPL)</related>
      </Docs>
    </Member>
    <Member MemberName="Current">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.TaskScheduler Current { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Threading.Tasks.TaskScheduler Current" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.TaskScheduler.Current" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property Current As TaskScheduler" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Threading::Tasks::TaskScheduler ^ Current { System::Threading::Tasks::TaskScheduler ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Current : System.Threading.Tasks.TaskScheduler" Usage="System.Threading.Tasks.TaskScheduler.Current" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.TaskScheduler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene el objeto <see cref="T:System.Threading.Tasks.TaskScheduler" /> asociado a la tarea que se está ejecutando actualmente.</summary>
        <value>Devuelve el objeto <see cref="T:System.Threading.Tasks.TaskScheduler" /> asociado a la tarea que se está ejecutando actualmente.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cuando no se llama desde dentro de una tarea, <xref:System.Threading.Tasks.TaskScheduler.Current%2A> devolverá el <xref:System.Threading.Tasks.TaskScheduler.Default%2A> programador.  
  
 Para obtener más información, vea <xref:System.Threading.Tasks.TaskScheduler>.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Threading.Tasks.TaskScheduler" />
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">Biblioteca de procesamiento paralelo basado en tareas (TPL)</related>
      </Docs>
    </Member>
    <Member MemberName="Default">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.TaskScheduler Default { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Threading.Tasks.TaskScheduler Default" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.TaskScheduler.Default" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property Default As TaskScheduler" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Threading::Tasks::TaskScheduler ^ Default { System::Threading::Tasks::TaskScheduler ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Default : System.Threading.Tasks.TaskScheduler" Usage="System.Threading.Tasks.TaskScheduler.Default" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.TaskScheduler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene la instancia predeterminada de <see cref="T:System.Threading.Tasks.TaskScheduler" /> proporcionada por .NET Framework.</summary>
        <value>Devuelve la instancia predeterminada de <see cref="T:System.Threading.Tasks.TaskScheduler" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para obtener más información, vea <xref:System.Threading.Tasks.TaskScheduler>.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Threading.Tasks.TaskScheduler" />
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">Biblioteca de procesamiento paralelo basado en tareas (TPL)</related>
      </Docs>
    </Member>
    <Member MemberName="Finalize">
      <MemberSignature Language="C#" Value="~TaskScheduler ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Finalize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskScheduler.Finalize" />
      <MemberSignature Language="VB.NET" Value="Finalize ()" />
      <MemberSignature Language="C++ CLI" Value="!TaskScheduler ()" />
      <MemberSignature Language="F#" Value="override this.Finalize : unit -&gt; unit" Usage="taskScheduler.Finalize " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Libera todos los recursos asociados a este programador.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="FromCurrentSynchronizationContext">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.TaskScheduler FromCurrentSynchronizationContext ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.TaskScheduler FromCurrentSynchronizationContext() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskScheduler.FromCurrentSynchronizationContext" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FromCurrentSynchronizationContext () As TaskScheduler" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Tasks::TaskScheduler ^ FromCurrentSynchronizationContext();" />
      <MemberSignature Language="F#" Value="static member FromCurrentSynchronizationContext : unit -&gt; System.Threading.Tasks.TaskScheduler" Usage="System.Threading.Tasks.TaskScheduler.FromCurrentSynchronizationContext " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.TaskScheduler</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Crea un <see cref="T:System.Threading.Tasks.TaskScheduler" /> asociado con el <see cref="T:System.Threading.SynchronizationContext" /> actual.</summary>
        <returns>Un <see cref="T:System.Threading.Tasks.TaskScheduler" /> asociados con el <see cref="T:System.Threading.SynchronizationContext" /> actual, según lo determinado por <see cref="P:System.Threading.SynchronizationContext.Current" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Todos los <xref:System.Threading.Tasks.Task> instancias en cola para el valor devuelto se ejecutará el programador mediante una llamada a la <xref:System.Threading.SynchronizationContext.Post%2A> método en ese contexto.  
  
 Para obtener más información, vea <xref:System.Threading.Tasks.TaskScheduler>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">El SynchronizationContext actual no puede usarse como TaskScheduler.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">Biblioteca de procesamiento paralelo basado en tareas (TPL)</related>
      </Docs>
    </Member>
    <Member MemberName="GetScheduledTasks">
      <MemberSignature Language="C#" Value="protected abstract System.Collections.Generic.IEnumerable&lt;System.Threading.Tasks.Task&gt; GetScheduledTasks ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Collections.Generic.IEnumerable`1&lt;class System.Threading.Tasks.Task&gt; GetScheduledTasks() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskScheduler.GetScheduledTasks" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Function GetScheduledTasks () As IEnumerable(Of Task)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract System::Collections::Generic::IEnumerable&lt;System::Threading::Tasks::Task ^&gt; ^ GetScheduledTasks();" />
      <MemberSignature Language="F#" Value="abstract member GetScheduledTasks : unit -&gt; seq&lt;System.Threading.Tasks.Task&gt;" Usage="taskScheduler.GetScheduledTasks " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-2.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Threading.Tasks.Task&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Solo por compatibilidad con el depurador, genera un enumerable de las instancias de <see cref="T:System.Threading.Tasks.Task" /> que se encuentran actualmente en la cola del programador a la espera de ser ejecutadas.</summary>
        <returns>Enumerable que permite a un depurador atravesar las tareas que se encuentran actualmente en la cola de este programador.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Una clase derivada de <xref:System.Threading.Tasks.TaskScheduler> implementa este método para admitir la integración con los depuradores. .NET Framework solo invocará este método cuando el depurador solicita acceso a los datos. El enumerable devuelto se puede atravesar por las utilidades para tener acceso a las tareas de depuración actualmente en la cola de este programador, habilitar el depurador para proporcionar una representación de esta información en la interfaz de usuario.  
  
 Es importante tener en cuenta que, cuando se llama a este método, se bloquearán todos los otros subprocesos del proceso. Por lo tanto, es importante evitar la sincronización con otros subprocesos que puede dar lugar al bloqueo. Si la sincronización es necesaria y no puede adquirir el bloqueo en este método, debe producir una excepción para que el depurador no se bloquea. El ejemplo siguiente muestra un posible enfoque en C#:  
  
```  
protected override IEnumerable<Task> GetScheduledTasks()  
{  
    bool lockTaken = false;  
    try  
    {  
        Monitor.TryEnter(_syncObj, ref lockTaken);  
        if (lockTaken)  
        {  
            return _tasks.ToArray();  
        }  
        else throw new NotSupportedException();  
    }  
    finally  
    {  
    if (lockTaken) Monitor.Exit(_syncObj);  
    }}  
```  
  
 Además, este método y el enumerable devuelto no debe modificar cualquier estado visible globalmente.  
  
 El enumerable no devuelto nunca debería ser null. Si no hay actualmente ninguna tarea en cola, se debe devolver en su lugar un enumerable vacío.  
  
 Los desarrolladores que están implementando los depuradores personalizados no debe llamar a este método directamente, pero debe usar el método de contenedor interna `GetScheduledTasksForDebugger` en su lugar: `internal Task[] GetScheduledTasksForDebugger()`. Este método contenedor devuelve una matriz de tareas en lugar de una colección enumerable. Para recuperar una lista de programadores activos, utilice el método interno `internal static TaskScheduler[] GetTaskSchedulersForDebugger()`. Este método estático devuelve una matriz de todos los activos <xref:System.Threading.Tasks.TaskScheduler> instancias. A continuación, puede usar `GetScheduledTasksForDebugger` en cada instancia del programador para recuperar su lista de tareas programadas.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Este programador no puede generar una lista de tareas en cola en este momento.</exception>
        <altmember cref="T:System.Threading.Tasks.TaskScheduler" />
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">Biblioteca de procesamiento paralelo basado en tareas (TPL)</related>
      </Docs>
    </Member>
    <Member MemberName="Id">
      <MemberSignature Language="C#" Value="public int Id { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Id" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.TaskScheduler.Id" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Id As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Id { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Id : int" Usage="System.Threading.Tasks.TaskScheduler.Id" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene el identificador único de este <see cref="T:System.Threading.Tasks.TaskScheduler" />.</summary>
        <value>Devuelve el identificador único de este objeto <see cref="T:System.Threading.Tasks.TaskScheduler" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para obtener más información, vea <xref:System.Threading.Tasks.TaskScheduler>.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Threading.Tasks.TaskScheduler" />
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">Biblioteca de procesamiento paralelo basado en tareas (TPL)</related>
      </Docs>
    </Member>
    <Member MemberName="MaximumConcurrencyLevel">
      <MemberSignature Language="C#" Value="public virtual int MaximumConcurrencyLevel { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 MaximumConcurrencyLevel" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.TaskScheduler.MaximumConcurrencyLevel" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property MaximumConcurrencyLevel As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property int MaximumConcurrencyLevel { int get(); };" />
      <MemberSignature Language="F#" Value="member this.MaximumConcurrencyLevel : int" Usage="System.Threading.Tasks.TaskScheduler.MaximumConcurrencyLevel" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Indica el nivel de simultaneidad máximo admitido por este <see cref="T:System.Threading.Tasks.TaskScheduler" />.</summary>
        <value>Devuelve un entero que representa el nivel máximo de simultaneidad. El programador predeterminado devuelve <see cref="F:System.Int32.MaxValue" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para obtener más información, vea <xref:System.Threading.Tasks.TaskScheduler>.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Threading.Tasks.TaskScheduler" />
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">Biblioteca de procesamiento paralelo basado en tareas (TPL)</related>
      </Docs>
    </Member>
    <Member MemberName="QueueTask">
      <MemberSignature Language="C#" Value="protected internal abstract void QueueTask (System.Threading.Tasks.Task task);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void QueueTask(class System.Threading.Tasks.Task task) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskScheduler.QueueTask(System.Threading.Tasks.Task)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; abstract void QueueTask(System::Threading::Tasks::Task ^ task);" />
      <MemberSignature Language="F#" Value="abstract member QueueTask : System.Threading.Tasks.Task -&gt; unit" Usage="taskScheduler.QueueTask task" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-2.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="task" Type="System.Threading.Tasks.Task" />
      </Parameters>
      <Docs>
        <param name="task">Objeto <see cref="T:System.Threading.Tasks.Task" /> que se va a poner en la cola.</param>
        <summary>Pone un objeto <see cref="T:System.Threading.Tasks.Task" /> en la cola del programador.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Una clase derivada de <xref:System.Threading.Tasks.TaskScheduler> implementa este método para aceptar tareas que se programan en el programador.  
  
 Una implementación típica almacenaría la tarea en una estructura de datos interna, que podría ser reparada por subprocesos que ejecutarían esas tareas en algún momento en el futuro.  
  
 Este método solo está pensado para ser llamado por .NET Framework y no debe llamarse directamente por la clase derivada. Esto es necesario para mantener la coherencia del sistema.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El argumento <paramref name="task" /> es null.</exception>
        <altmember cref="T:System.Threading.Tasks.TaskScheduler" />
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">Biblioteca de procesamiento paralelo basado en tareas (TPL)</related>
      </Docs>
    </Member>
    <Member MemberName="TryDequeue">
      <MemberSignature Language="C#" Value="protected internal virtual bool TryDequeue (System.Threading.Tasks.Task task);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance bool TryDequeue(class System.Threading.Tasks.Task task) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskScheduler.TryDequeue(System.Threading.Tasks.Task)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual bool TryDequeue(System::Threading::Tasks::Task ^ task);" />
      <MemberSignature Language="F#" Value="abstract member TryDequeue : System.Threading.Tasks.Task -&gt; bool&#xA;override this.TryDequeue : System.Threading.Tasks.Task -&gt; bool" Usage="taskScheduler.TryDequeue task" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-2.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="task" Type="System.Threading.Tasks.Task" />
      </Parameters>
      <Docs>
        <param name="task">Objeto <see cref="T:System.Threading.Tasks.Task" /> que se va a quitar de la cola.</param>
        <summary>Intenta quitar un objeto <see cref="T:System.Threading.Tasks.Task" /> de la cola de este programador.</summary>
        <returns>Valor booleano que indica si el argumento <paramref name="task" /> se quitó correctamente de la cola.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para obtener más información, vea <xref:System.Threading.Tasks.TaskScheduler>.  
  
 Este método se puede ejecutar en un bloque finally; por lo tanto, debe devolver tan pronto como sea posible hasta que cualquier recursos como <xref:System.Threading.CancellationTokenRegistration> objetos puedan eliminar de manera oportuna.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El argumento <paramref name="task" /> es null.</exception>
        <altmember cref="T:System.Threading.Tasks.TaskScheduler" />
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">Biblioteca de procesamiento paralelo basado en tareas (TPL)</related>
      </Docs>
    </Member>
    <Member MemberName="TryExecuteTask">
      <MemberSignature Language="C#" Value="protected bool TryExecuteTask (System.Threading.Tasks.Task task);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance bool TryExecuteTask(class System.Threading.Tasks.Task task) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskScheduler.TryExecuteTask(System.Threading.Tasks.Task)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; bool TryExecuteTask(System::Threading::Tasks::Task ^ task);" />
      <MemberSignature Language="F#" Value="member this.TryExecuteTask : System.Threading.Tasks.Task -&gt; bool" Usage="taskScheduler.TryExecuteTask task" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-2.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="task" Type="System.Threading.Tasks.Task" />
      </Parameters>
      <Docs>
        <param name="task">Objeto <see cref="T:System.Threading.Tasks.Task" /> que se va a ejecutar.</param>
        <summary>Intenta ejecutar el objeto <see cref="T:System.Threading.Tasks.Task" /> especificado en este programador.</summary>
        <returns>Valor booleano que es true si <paramref name="task" /> se ejecutó correctamente; de lo contrario, es false. Normalmente, los errores de ejecución son debidos a que la tarea ya se ha ejecutado anteriormente o está a punto de ser ejecutada por otro subproceso.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Las implementaciones del programador se proporcionan con <xref:System.Threading.Tasks.Task> instancias que se ejecutará a través la <xref:System.Threading.Tasks.TaskScheduler.QueueTask%2A> método o la <xref:System.Threading.Tasks.TaskScheduler.TryExecuteTaskInline%2A> método. Cuando el programador considere adecuado para ejecutar la tarea proporcionada, <xref:System.Threading.Tasks.TaskScheduler.TryExecuteTask%2A> debe usarse para hacerlo. TryExecuteTask controla todos los aspectos de la ejecución de una tarea, incluida la invocación de acción, control de excepciones, administración de Estados y control del ciclo de vida.  
  
 <xref:System.Threading.Tasks.TaskScheduler.TryExecuteTask%2A> solo debe usarse para las tareas proporcionadas a este programador por la infraestructura de .NET Framework. No debe usarse para ejecutar tareas arbitrarias obtenidas a través de mecanismos personalizados.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">La <paramref name="task" /> no está asociada a este programador.</exception>
        <altmember cref="T:System.Threading.Tasks.TaskScheduler" />
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">Biblioteca de procesamiento paralelo basado en tareas (TPL)</related>
      </Docs>
    </Member>
    <Member MemberName="TryExecuteTaskInline">
      <MemberSignature Language="C#" Value="protected abstract bool TryExecuteTaskInline (System.Threading.Tasks.Task task, bool taskWasPreviouslyQueued);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool TryExecuteTaskInline(class System.Threading.Tasks.Task task, bool taskWasPreviouslyQueued) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskScheduler.TryExecuteTaskInline(System.Threading.Tasks.Task,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract bool TryExecuteTaskInline(System::Threading::Tasks::Task ^ task, bool taskWasPreviouslyQueued);" />
      <MemberSignature Language="F#" Value="abstract member TryExecuteTaskInline : System.Threading.Tasks.Task * bool -&gt; bool" Usage="taskScheduler.TryExecuteTaskInline (task, taskWasPreviouslyQueued)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-2.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="task" Type="System.Threading.Tasks.Task" />
        <Parameter Name="taskWasPreviouslyQueued" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="task">Objeto <see cref="T:System.Threading.Tasks.Task" /> que se va a ejecutar.</param>
        <param name="taskWasPreviouslyQueued">Valor booleano que indica si la tarea se ha puesto anteriormente en la cola. Si este parámetro es True, la tarea se ha puesto en la cola (programado) anteriormente; si su valor es False, la tarea no se ha puesto anteriormente en la cola y esta llamada se realiza para ejecutar la tarea insertada sin ponerla en la cola.</param>
        <summary>Determina si el objeto <see cref="T:System.Threading.Tasks.Task" /> especificado puede ejecutarse sincrónicamente en esta llamada y, en caso afirmativo, lo ejecuta.</summary>
        <returns>Valor booleano que indica si se ejecutó la tarea alineada.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Una clase derivada de <xref:System.Threading.Tasks.TaskScheduler> implementa esta función para admitir la ejecución en línea de una tarea en un subproceso que inicia una espera en ese objeto de tarea. Ejecución insertada es opcional y se puede rechazar la solicitud y devuelve false. Sin embargo, las tareas más que pueden insertarse, mejor será el programador se escalará. De hecho, un programador que inlines demasiado poco puedan ser propensas a interbloqueos. Debe asegurarse de que una solicitud que se ejecuta bajo las directivas que se garantiza que el programador correctamente puede insertar una implementación apropiada. Por ejemplo, si un programador utiliza un subproceso dedicado para ejecutar tareas, las solicitudes de inserción desde ese subproceso deberían realizarse correctamente.  
  
 Si un programador decide llevar a cabo la ejecución en línea, deberá hacerlo mediante una llamada a la TaskScheduler base <xref:System.Threading.Tasks.TaskScheduler.TryExecuteTask%2A> método con el objeto de tarea proporcionado, propagando el valor devuelto. También puede ser adecuado para el programador quitar una tarea insertada de sus estructuras de datos internas si decide aceptar la solicitud de inserción. Sin embargo, tenga en cuenta que en algunas circunstancias un programador puede que se pida a una tarea que no se proporcionó anteriormente a él con el <xref:System.Threading.Tasks.TaskScheduler.QueueTask%2A> método.  
  
 El programador derivado es responsabilidad suya asegurarse de que el subproceso de llamada es adecuado para ejecutar la tarea determinada en cuanto a su propia programación y se refiere a las directivas de ejecución.  
  
 Para obtener más información, vea <xref:System.Threading.Tasks.TaskScheduler>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El argumento <paramref name="task" /> es null.</exception>
        <exception cref="T:System.InvalidOperationException">La <paramref name="task" /> ya se ejecutó.</exception>
        <altmember cref="T:System.Threading.Tasks.TaskScheduler" />
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">Biblioteca de procesamiento paralelo basado en tareas (TPL)</related>
      </Docs>
    </Member>
    <Member MemberName="UnobservedTaskException">
      <MemberSignature Language="C#" Value="public static event EventHandler&lt;System.Threading.Tasks.UnobservedTaskExceptionEventArgs&gt; UnobservedTaskException;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Threading.Tasks.UnobservedTaskExceptionEventArgs&gt; UnobservedTaskException" />
      <MemberSignature Language="DocId" Value="E:System.Threading.Tasks.TaskScheduler.UnobservedTaskException" />
      <MemberSignature Language="VB.NET" Value="Public Shared Custom Event UnobservedTaskException As EventHandler(Of UnobservedTaskExceptionEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static event EventHandler&lt;System::Threading::Tasks::UnobservedTaskExceptionEventArgs ^&gt; ^ UnobservedTaskException;" />
      <MemberSignature Language="F#" Value="member this.UnobservedTaskException : EventHandler&lt;System.Threading.Tasks.UnobservedTaskExceptionEventArgs&gt; " Usage="member this.UnobservedTaskException : System.EventHandler&lt;System.Threading.Tasks.UnobservedTaskExceptionEventArgs&gt; " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>add: System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>remove: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Threading.Tasks.UnobservedTaskExceptionEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produce cuando la excepción no observada de un error de la tarea está a punto de desencadenar la directiva de escalado de excepción que, de forma predeterminada, finalizaría el proceso.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este evento de todo el dominio de aplicación proporciona un mecanismo para evitar que la directiva de elevación de excepciones (que, de forma predeterminada, finaliza el proceso) de desencadenamiento.  
  
 Para facilitar a los desarrolladores escribir código asincrónico basado en tareas, el [!INCLUDE[net_v45](~/includes/net-v45-md.md)] cambia el comportamiento de excepción predeterminado para las excepciones no observadas. Aunque todavía excepciones no observadas elevar el <xref:System.Threading.Tasks.TaskScheduler.UnobservedTaskException> excepción, el proceso no finaliza de forma predeterminada. En su lugar, el tiempo de ejecución se controla la excepción después de que se genera el evento, independientemente de si un controlador de eventos observa la excepción. Este comportamiento se puede configurar. A partir de la [!INCLUDE[net_v45](~/includes/net-v45-md.md)], puede usar el elemento de configuración para revertir al comportamiento de la [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)] y terminar el proceso:  
  
```xml  
<configuration>   
   <runtime>   
      <ThrowUnobservedTaskExceptions enabled="true"/>   
   </runtime>   
</configuration>  
  
```  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">Biblioteca de procesamiento paralelo basado en tareas (TPL)</related>
        <related type="Article" href="~/docs/framework/configure-apps/file-schema/runtime/throwunobservedtaskexceptions-element.md">&lt;ThrowUnobservedTaskExceptions&gt; elemento</related>
      </Docs>
    </Member>
  </Members>
</Type>