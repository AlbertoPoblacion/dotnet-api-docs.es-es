<Type Name="Task" FullName="System.Threading.Tasks.Task">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="20607044e8a6b00e4cc3c8fd73a433891b7b588e" />
    <Meta Name="ms.sourcegitcommit" Value="6a0b904069161bbaec4ffd02aa7d9cf38c61e72e" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="es-ES" />
    <Meta Name="ms.lasthandoff" Value="06/24/2018" />
    <Meta Name="ms.locfileid" Value="36408239" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class Task : IAsyncResult, IDisposable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit Task extends System.Object implements class System.IAsyncResult, class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:System.Threading.Tasks.Task" />
  <TypeSignature Language="VB.NET" Value="Public Class Task&#xA;Implements IAsyncResult, IDisposable" />
  <TypeSignature Language="C++ CLI" Value="public ref class Task : IAsyncResult, IDisposable" />
  <TypeSignature Language="F#" Value="type Task = class&#xA;    interface IAsyncResult&#xA;    interface IDisposable" />
  <AssemblyInfo>
    <AssemblyName>System.Threading.Tasks</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IAsyncResult</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.Diagnostics.DebuggerDisplay("Id = {Id}, Status = {Status}, Method = {DebuggerDisplayMethodDescription}")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Diagnostics.DebuggerTypeProxy(typeof(System.Threading.Tasks.SystemThreadingTasks_TaskDebugView))</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Representa una operación asincrónica.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
   
## Remarks  
 La <xref:System.Threading.Tasks.Task> clase representa una única operación que no devuelve un valor y que normalmente se ejecuta de forma asincrónica. <xref:System.Threading.Tasks.Task> los objetos son uno de los componentes centrales de la [modelo asincrónico basado en tareas](~/docs/standard/asynchronous-programming-patterns/task-based-asynchronous-pattern-tap.md) inicialmente se introdujo en .NET Framework 4. Dado que el trabajo realizado por un <xref:System.Threading.Tasks.Task> objeto normalmente ejecuta de forma asincrónica en un subproceso del grupo en lugar de forma sincrónica en el subproceso de aplicación principal, puede usar el <xref:System.Threading.Tasks.Task.Status%2A> propiedad, así como el <xref:System.Threading.Tasks.Task.IsCanceled%2A>, <xref:System.Threading.Tasks.Task.IsCompleted%2A>, y <xref:System.Threading.Tasks.Task.IsFaulted%2A> propiedades para determinar el estado de una tarea. Normalmente, se utiliza una expresión lambda para especificar el trabajo que debe realizar la tarea.  
  
 Para las operaciones que devuelven valores, utilice la <xref:System.Threading.Tasks.Task%601> clase.  
  
 En esta sección:  
  
 [Ejemplos de creación de instancias de la tarea](#Instant)   
 [Crear y ejecutar una tarea](#Creating)   
 [Separación de ejecución y la creación de tareas](#Separating)   
 [Esperando a completar las tareas de uno o más](#WaitingForOne)   
 [Tareas y la referencia cultural](#Culture)   
 [Para los desarrolladores de depurador](#Debugger)  

 <a name="Instant"></a>     
## <a name="task-instantiation"></a>Creación de instancias de tarea  
 En el ejemplo siguiente se crea y ejecuta las cuatro tareas. Tres de las tareas se ejecutan una <xref:System.Action%601> delegado denominado `action`, que acepta un argumento de tipo <xref:System.Object>. Una cuarta tarea ejecuta una expresión lambda (un <xref:System.Action> delegar) que es definida insertada en la llamada al método de creación de tarea. Cada tarea se crea y se ejecuta de forma diferente:  
  
-   Tarea `t1` se crea una instancia mediante una llamada a un constructor de clase de tarea, pero se inicia mediante una llamada a su <xref:System.Threading.Tasks.Task.Start> método sólo después de la tarea `t2` se ha iniciado.  
  
-   Tarea `t2` se crea y se inicia en una única llamada al método mediante una llamada a la <xref:System.Threading.Tasks.TaskFactory.StartNew%28System.Action%7BSystem.Object%7D%2CSystem.Object%29?displayProperty=nameWithType> método.  
  
-   Tarea `t3` se crea y se inicia en una única llamada al método mediante una llamada a la <xref:System.Threading.Tasks.Task.Run%28System.Action%29> método.  
  
-   Tarea `t4` se ejecuta sincrónicamente en el subproceso principal mediante una llamada a la <xref:System.Threading.Tasks.Task.RunSynchronously> método.  
  
 Dado que tarea `t4` ejecuta de forma sincrónica, ejecuta en el subproceso de aplicación principal. Las tareas restantes asincrónicamente ejecutan normalmente en uno o más subprocesos del grupo de subprocesos.  
  
 [!code-csharp[System.Threading.Tasks.Task#01](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task/cs/startnew.cs#01)]
 [!code-vb[System.Threading.Tasks.Task#01](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task/vb/startnew.vb#01)] 
    
<a name="Creating"></a>   
## <a name="creating-and-executing-a-task"></a>Crear y ejecutar una tarea  
 <xref:System.Threading.Tasks.Task> pueden crear instancias en una variedad de formas. El enfoque más común, que está disponible a partir de la [!INCLUDE[net_v45](~/includes/net-v45-md.md)], consiste en llamar el método estático <xref:System.Threading.Tasks.Task.Run%2A> método. El <xref:System.Threading.Tasks.Task.Run%2A> método proporciona una manera sencilla de iniciar una tarea con los valores predeterminados y sin necesidad de parámetros adicionales. En el ejemplo siguiente se usa el <xref:System.Threading.Tasks.Task.Run%28System.Action%29> método para iniciar una tarea que se ejecuta un bucle y, a continuación, muestra el número de iteraciones del bucle:  
  
 [!code-csharp[System.Threading.Tasks.Task#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task/cs/run1.cs#6)]
 [!code-vb[System.Threading.Tasks.Task#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task/vb/run1.vb#6)]  
  
 Una alternativa y el método más común para iniciar una tarea [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)], es el método estático <xref:System.Threading.Tasks.TaskFactory.StartNew%2A?displayProperty=nameWithType> método. El <xref:System.Threading.Tasks.Task.Factory%2A?displayProperty=nameWithType> propiedad devuelve un <xref:System.Threading.Tasks.TaskFactory> objeto. Las sobrecargas de los <xref:System.Threading.Tasks.TaskFactory.StartNew%2A?displayProperty=nameWithType> método le permite especificar parámetros para pasar a las opciones de creación de tarea y un programador de tareas. En el ejemplo siguiente se usa el <xref:System.Threading.Tasks.TaskFactory.StartNew%2A?displayProperty=nameWithType> método para iniciar una tarea. Es funcionalmente equivalente al código en el ejemplo anterior.  
  
 [!code-csharp[System.Threading.Tasks.Task#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task/cs/startnew1.cs#7)]
 [!code-vb[System.Threading.Tasks.Task#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task/vb/startnew1.vb#7)]  
  
 Para obtener ejemplos más completos, vea [basado en tareas de programación asincrónica](~/docs/standard/parallel-programming/task-based-asynchronous-programming.md).  
  
<a name="Separating"></a>   
## <a name="separating-task-creation-and-execution"></a>Separación de ejecución y la creación de tareas  
 La <xref:System.Threading.Tasks.Task> clase también proporciona constructores que inicializan la tarea pero que no la programan para su ejecución. Por motivos de rendimiento, el <xref:System.Threading.Tasks.Task.Run%2A?displayProperty=nameWithType> o <xref:System.Threading.Tasks.TaskFactory.StartNew%2A?displayProperty=nameWithType> método es el mecanismo preferido para crear y programar tareas de cálculo, pero para escenarios donde deben estar separados la creación y la programación, puede usar los constructores y, a continuación, llamar a la <xref:System.Threading.Tasks.Task.Start%2A?displayProperty=nameWithType> método para programar la tarea para su ejecución en un momento posterior.  
  
<a name="WaitingForOne"></a>   
## <a name="waiting-for-one-or-more-tasks-to-complete"></a>Esperando a completar las tareas de uno o más  
 Las tareas normalmente se ejecutan asincrónicamente en un subproceso del grupo, por lo que el subproceso que crea e inicia la tarea continúa la ejecución tan pronto como se ha creado una instancia de la tarea. En algunos casos, cuando el subproceso que realiza la llamada es el subproceso de aplicación principal, la aplicación puede finalizar antes de cualquier la tarea que empiece la ejecución. En otros casos, la lógica de la aplicación puede requerir que el subproceso que realiza la llamada continuar la ejecución solo cuando una o más tareas ha completado su ejecución. Puede sincronizar la ejecución del subproceso que realiza la llamada y la asincrónica las tareas se inicia mediante una llamada a un `Wait` método para esperar una o más tareas se completen.  
  
 Para esperar a que una sola tarea para completar, puede llamar a su <xref:System.Threading.Tasks.Task.Wait%2A?displayProperty=nameWithType> método. Una llamada a la <xref:System.Threading.Tasks.Task.Wait%2A> método bloquea el subproceso que realiza la llamada hasta que la instancia de clase único ha completado su ejecución.  
  
 En el ejemplo siguiente se llama sin parámetros <xref:System.Threading.Tasks.Task.Wait> método incondicionalmente espere hasta que se complete una tarea. La tarea simula un trabajo mediante una llamada a la <xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType> método en modo de suspensión durante dos segundos.  
  
 [!code-csharp[System.Threading.Tasks.Task#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task/cs/Wait1.cs#8)]
 [!code-vb[System.Threading.Tasks.Task#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task/vb/Wait1.vb#8)]  
  
 También condicionalmente puede esperar de una tarea se complete. El <xref:System.Threading.Tasks.Task.Wait%28System.Int32%29> y <xref:System.Threading.Tasks.Task.Wait%28System.TimeSpan%29> métodos bloquean el subproceso que realiza la llamada hasta que finaliza la tarea o transcurre un intervalo de tiempo de espera, lo que ocurra primero. Puesto que el ejemplo siguiente inicia una tarea que se suspende durante dos segundos, pero define un valor de tiempo de espera de un segundo subproceso que realiza la llamada se bloquea hasta que expire el tiempo de espera y antes de la tarea ha completado su ejecución.  
  
 [!code-csharp[System.Threading.Tasks.Task#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task/cs/Wait2.cs#9)]
 [!code-vb[System.Threading.Tasks.Task#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task/vb/Wait2.vb#9)]  
  
 También puede proporcionar un token de cancelación mediante una llamada a la <xref:System.Threading.Tasks.Task.Wait%28System.Threading.CancellationToken%29> y <xref:System.Threading.Tasks.Task.Wait%28System.Int32%2CSystem.Threading.CancellationToken%29> métodos. Si el token <xref:System.Threading.CancellationToken.IsCancellationRequested%2A> propiedad es `true`, se cancele la espera; si es true mientras el <xref:System.Threading.Tasks.Task.Wait%2A> método termina.  
  
 En algunos casos, puede que desee esperar para que la primera de una serie de tareas ejecutándose completar, pero no la atención que la tarea lo es.  Para ello, puede llamar a una de las sobrecargas de los <xref:System.Threading.Tasks.Task.WaitAll%2A?displayProperty=nameWithType> método.  En el ejemplo siguiente se crea tres tareas, cada una de las cuales se suspende para determinar un intervalo mediante un generador de números aleatorios. El <xref:System.Threading.Tasks.Task.WaitAny%28System.Threading.Tasks.Task%5B%5D%29> método espera a que la primera tarea se complete. En el ejemplo, a continuación, muestra información sobre el estado de las tres tareas.  
  
 [!code-csharp[System.Threading.Tasks.Task#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task/cs/WhenAny1.cs#10)]
 [!code-vb[System.Threading.Tasks.Task#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task/vb/WaitAny1.vb#10)]  
  
 También puede esperar de una serie de tareas se completen mediante una llamada a todos los <xref:System.Threading.Tasks.Task.WaitAll%2A> método. En el ejemplo siguiente se crea diez tareas, espera a que todos los diez en completarse y, a continuación, muestra su estado.  
  
 [!code-csharp[System.Threading.Tasks.Task#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task/cs/WaitAll1.cs#11)]
 [!code-vb[System.Threading.Tasks.Task#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task/vb/WaitAll1.vb#11)]  
  
 Tenga en cuenta que, cuando se espera completar las tareas de uno o más, las excepciones producidas en las tareas en ejecución se propaguen en el subproceso que llama el `Wait` método, tal como se muestra en el ejemplo siguiente. Inicia 12 tareas, tres de los cuales finalizar con normalidad y tres que inician una excepción. De las seis tareas pendientes, tres se cancelan antes del inicio y tres se cancelan mientras se ejecutan. Las excepciones se producen el <xref:System.Threading.Tasks.Task.WaitAll%2A> llamada al método y se controlan un `try` / `catch` bloque.  
  
 [!code-csharp[System.Threading.Tasks.Task#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task/cs/WaitAll2.cs#12)]
 [!code-vb[System.Threading.Tasks.Task#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task/vb/WaitAll2.vb#12)]  
  
 Para obtener más información sobre el control de excepciones en las operaciones asincrónicas basadas en tareas, consulte [Exception Handling](~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md).  
  
<a name="Culture"></a>   
## <a name="tasks-and-culture"></a>Tareas y la referencia cultural  
 A partir de las aplicaciones de escritorio que tienen como destino el [!INCLUDE[net_v46](~/includes/net-v46-md.md)], la referencia cultural del subproceso que crea e invoca una tarea se convierte en parte del contexto del subproceso. Es decir, sin tener en cuenta la referencia cultural actual del subproceso en el que se ejecuta la tarea, la referencia cultural actual de la tarea es la referencia cultural del subproceso que realiza la llamada. Para las aplicaciones destinadas a versiones de .NET Framework anteriores a la [!INCLUDE[net_v46](~/includes/net-v46-md.md)], la referencia cultural de la tarea es la referencia cultural del subproceso en el que se ejecuta la tarea. Para obtener más información, vea la sección "Referencia cultural y operaciones asincrónicas basadas en tareas" en el <xref:System.Globalization.CultureInfo> tema.  
  
> [!NOTE]
>  Aplicaciones de la tienda siguen el tiempo de ejecución de Windows en la configuración y la obtención de la referencia cultural predeterminada.  
  
<a name="Debugger"></a>   
## <a name="for-debugger-developers"></a>Para los desarrolladores de depurador  
 Para los desarrolladores que implementan a depuradores personalizados, varios miembros privados e internos de la tarea pueden ser útiles (puede que éstos cambien de una versión a otra). El `m_taskId` campo actúa como el almacén de copia de seguridad para la <xref:System.Threading.Tasks.Task.Id%2A> propiedad, sin embargo acceso a este campo directamente desde un depurador puede ser más eficaz que si tuviera acceso el mismo valor a través del método de captador de la propiedad (la `s_taskIdCounter` contador es usa para recuperar el siguiente identificador disponible para una tarea). De forma similar, el `m_stateFlags` campo almacena información sobre la fase actual del ciclo de vida de la tarea, la información también es accesible a través de la <xref:System.Threading.Tasks.Task.Status%2A> propiedad. El `m_action` campo almacena una referencia al delegado de la tarea y el `m_stateObject` campo almacena el estado asincrónico pasado a la tarea por el desarrollador. Por último, para los depuradores que analizan marcos de pila, el `InternalWait` método proporciona un marcador potencial para cuando una tarea está entrando en una operación de espera.   
  
 ]]></format>
    </remarks>
    <threadsafe>Todos los miembros de <see cref="T:System.Threading.Tasks.Task" />, excepto para <see cref="M:System.Threading.Tasks.Task.Dispose" />, es seguro para subprocesos y pueden usar desde varios subprocesos simultáneamente.</threadsafe>
    <altmember cref="T:System.Threading.Tasks.Task`1" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inicializa un nuevo objeto <see cref="T:System.Threading.Tasks.Task" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Task (Action action);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Action action) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.#ctor(System.Action)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Task(Action ^ action);" />
      <MemberSignature Language="F#" Value="new System.Threading.Tasks.Task : Action -&gt; System.Threading.Tasks.Task" Usage="new System.Threading.Tasks.Task action" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="action" Type="System.Action" />
      </Parameters>
      <Docs>
        <param name="action">El delegado que representa el código que se va a ejecutar en la tarea.</param>
        <summary>Inicializa una nueva instancia de <see cref="T:System.Threading.Tasks.Task" /> con la acción especificada.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 En lugar de llamar a este constructor, la manera más común para crear instancias de un <xref:System.Threading.Tasks.Task> objeto e inicie una tarea consiste en llamar al estático <xref:System.Threading.Tasks.Task.Run%28System.Action%29?displayProperty=nameWithType> o <xref:System.Threading.Tasks.TaskFactory.StartNew%28System.Action%29?displayProperty=nameWithType> método. La única ventaja que ofrece este constructor es que permite la creación de instancias de objeto se separen de invocación de la tarea.  
  
   
  
## Examples  
 En el ejemplo siguiente se usa el <xref:System.Threading.Tasks.Task.%23ctor%28System.Action%29> constructor para crear tareas que recuperar los nombres de archivo en los directorios especificados. Todas las tareas de escriban los nombres de archivo en una sola <xref:System.Collections.Concurrent.ConcurrentBag%601> objeto. El ejemplo, a continuación, se llama la <xref:System.Threading.Tasks.Task.WaitAll%28System.Threading.Tasks.Task%5B%5D%29> método para asegurarse de que ha completado todas las tareas y, a continuación, muestra un recuento del número total de nombres de archivo que se escriben en el <xref:System.Collections.Concurrent.ConcurrentBag%601> objeto.  
  
 [!code-csharp[System.Threading.Tasks.Task.Ctor#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.ctor/cs/ctor1.cs#1)]
 [!code-vb[System.Threading.Tasks.Task.Ctor#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.ctor/vb/ctor1.vb#1)]  
  
 El ejemplo siguiente es idéntico, salvo que usa el <xref:System.Threading.Tasks.Task.Run%28System.Action%29> método para crear una instancia y ejecutar la tarea en una sola operación. El método devuelve el <xref:System.Threading.Tasks.Task> objeto que representa la tarea.  
  
 [!code-csharp[System.Threading.Tasks.Task.Run#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.run/cs/run2.cs#1)]
 [!code-vb[System.Threading.Tasks.Task.Run#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.run/vb/run2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El argumento <paramref name="action" /> es <see langword="null" />.</exception>
        <altmember cref="M:System.Threading.Tasks.Task.Run(System.Action)" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Task (Action action, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Action action, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.#ctor(System.Action,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Task(Action ^ action, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="new System.Threading.Tasks.Task : Action * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task" Usage="new System.Threading.Tasks.Task (action, cancellationToken)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="action" Type="System.Action" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="action">El delegado que representa el código que se va a ejecutar en la tarea.</param>
        <param name="cancellationToken">El <see cref="T:System.Threading.CancellationToken" /> que observará la nueva tarea.</param>
        <summary>Inicializa una nueva instancia de <see cref="T:System.Threading.Tasks.Task" /> con la acción y <see cref="T:System.Threading.CancellationToken" /> especificados.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 En lugar de llamar a este constructor, la manera más común para crear instancias de un <xref:System.Threading.Tasks.Task> objeto e inicie una tarea consiste en llamar al estático <xref:System.Threading.Tasks.Task.Run%28System.Action%2CSystem.Threading.CancellationToken%29?displayProperty=nameWithType> y <xref:System.Threading.Tasks.TaskFactory.StartNew%28System.Action%2CSystem.Threading.CancellationToken%29?displayProperty=nameWithType> métodos. La única ventaja que ofrece este constructor es que permite la creación de instancias de objeto se separen de invocación de la tarea.  
  
 Para obtener más información, consulte [paralelismo de tareas (Task Parallel Library)](~/docs/standard/parallel-programming/task-based-asynchronous-programming.md) y [cancelación en subprocesos administrados](~/docs/standard/threading/cancellation-in-managed-threads.md).  
  
   
  
## Examples  
 El ejemplo siguiente se llama el <xref:System.Threading.Tasks.Task.%23ctor%28System.Action%2CSystem.Threading.CancellationToken%29> constructor para crear una tarea que recorre en iteración los archivos en el directorio C:\Windows\System32. La expresión lambda llama el <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> método para agregar información sobre todos los archivos en un <xref:System.Collections.Generic.List%601> objeto. Cada tarea anidada invocado por desasociada el <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> bucle comprueba el estado del token de cancelación y, si se solicita la cancelación, llama a la <xref:System.Threading.CancellationToken.ThrowIfCancellationRequested%2A?displayProperty=nameWithType> método. El <xref:System.Threading.CancellationToken.ThrowIfCancellationRequested%2A?displayProperty=nameWithType> método inicie una excepción un <xref:System.OperationCanceledException> excepción que se controla en un `catch` bloquear cuando el subproceso que realiza la llamada llama la <xref:System.Threading.Tasks.Task.Wait%2A?displayProperty=nameWithType> método.  El <xref:System.Threading.Tasks.Task.Start%2A> , a continuación, se llama el método para iniciar la tarea.  
  
 [!code-csharp[System.Threading.Tasks.Task.ctor#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.ctor/cs/run4.cs#4)]
 [!code-vb[System.Threading.Tasks.Task.ctor#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.ctor/vb/run4.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">El <see cref="T:System.Threading.CancellationToken" /> proporcionado ya se ha eliminado.</exception>
        <exception cref="T:System.ArgumentNullException">El argumento de <paramref name="action" /> es nulo.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Task (Action action, System.Threading.Tasks.TaskCreationOptions creationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Action action, valuetype System.Threading.Tasks.TaskCreationOptions creationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.#ctor(System.Action,System.Threading.Tasks.TaskCreationOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Task(Action ^ action, System::Threading::Tasks::TaskCreationOptions creationOptions);" />
      <MemberSignature Language="F#" Value="new System.Threading.Tasks.Task : Action * System.Threading.Tasks.TaskCreationOptions -&gt; System.Threading.Tasks.Task" Usage="new System.Threading.Tasks.Task (action, creationOptions)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="action" Type="System.Action" />
        <Parameter Name="creationOptions" Type="System.Threading.Tasks.TaskCreationOptions" />
      </Parameters>
      <Docs>
        <param name="action">El delegado que representa el código que se va a ejecutar en la tarea.</param>
        <param name="creationOptions">El objeto <see cref="T:System.Threading.Tasks.TaskCreationOptions" /> que se usa para personalizar el comportamiento de la tarea.</param>
        <summary>Inicializa un nuevo objeto <see cref="T:System.Threading.Tasks.Task" /> con la acción y las opciones de creación especificadas.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 En lugar de llamar a este constructor, la manera más común para crear instancias de un <xref:System.Threading.Tasks.Task> objeto e inicie una tarea consiste en llamar al estático <xref:System.Threading.Tasks.TaskFactory.StartNew%28System.Action%2CSystem.Threading.Tasks.TaskCreationOptions%29?displayProperty=nameWithType> método. La única ventaja que ofrece este constructor es que permite la creación de instancias de objeto se separen de invocación de la tarea.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El argumento de <paramref name="action" /> es nulo.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">El argumento <paramref name="creationOptions" /> especifica un valor no válido para <see cref="T:System.Threading.Tasks.TaskCreationOptions" />.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Task (Action&lt;object&gt; action, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Action`1&lt;object&gt; action, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.#ctor(System.Action{System.Object},System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (action As Action(Of Object), state As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Task(Action&lt;System::Object ^&gt; ^ action, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="new System.Threading.Tasks.Task : Action&lt;obj&gt; * obj -&gt; System.Threading.Tasks.Task" Usage="new System.Threading.Tasks.Task (action, state)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="action" Type="System.Action&lt;System.Object&gt;" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="action">El delegado que representa el código que se va a ejecutar en la tarea.</param>
        <param name="state">Objeto que representa los datos que la acción va a usar.</param>
        <summary>Inicializa un nuevo objeto <see cref="T:System.Threading.Tasks.Task" /> con la acción y el estado especificados.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 En lugar de llamar a este constructor, la manera más común para crear instancias de un <xref:System.Threading.Tasks.Task> objeto e inicie una tarea consiste en llamar al estático <xref:System.Threading.Tasks.TaskFactory.StartNew%28System.Action%7BSystem.Object%7D%2CSystem.Object%29?displayProperty=nameWithType> método. La única ventaja que ofrece este constructor es que permite la creación de instancias de objeto se separen de invocación de la tarea.  
  
   
  
## Examples  
 En el ejemplo siguiente se define una matriz de palabras de letra de 6. Cada palabra, a continuación, se pasa como argumento a la <xref:System.Threading.Tasks.Task.%23ctor%28System.Action%7BSystem.Object%7D%2CSystem.Object%29> constructor, cuyo <xref:System.Action%601> delegado codifica los caracteres de la palabra, a continuación, muestra la palabra original y su versión codificado.  
  
 [!code-csharp[System.Threading.Tasks.Task.ctor#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.ctor/cs/startnew3.cs#3)]
 [!code-vb[System.Threading.Tasks.Task.ctor#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.ctor/vb/startnew3.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El argumento de <paramref name="action" /> es nulo.</exception>
        <altmember cref="M:System.Threading.Tasks.TaskFactory.StartNew(System.Action{System.Object},System.Object)" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Task (Action action, System.Threading.CancellationToken cancellationToken, System.Threading.Tasks.TaskCreationOptions creationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Action action, valuetype System.Threading.CancellationToken cancellationToken, valuetype System.Threading.Tasks.TaskCreationOptions creationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.#ctor(System.Action,System.Threading.CancellationToken,System.Threading.Tasks.TaskCreationOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Task(Action ^ action, System::Threading::CancellationToken cancellationToken, System::Threading::Tasks::TaskCreationOptions creationOptions);" />
      <MemberSignature Language="F#" Value="new System.Threading.Tasks.Task : Action * System.Threading.CancellationToken * System.Threading.Tasks.TaskCreationOptions -&gt; System.Threading.Tasks.Task" Usage="new System.Threading.Tasks.Task (action, cancellationToken, creationOptions)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="action" Type="System.Action" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        <Parameter Name="creationOptions" Type="System.Threading.Tasks.TaskCreationOptions" />
      </Parameters>
      <Docs>
        <param name="action">El delegado que representa el código que se va a ejecutar en la tarea.</param>
        <param name="cancellationToken">El <see cref="P:System.Threading.Tasks.TaskFactory.CancellationToken" /> que observará la nueva tarea.</param>
        <param name="creationOptions">El objeto <see cref="T:System.Threading.Tasks.TaskCreationOptions" /> que se usa para personalizar el comportamiento de la tarea.</param>
        <summary>Inicializa un nuevo objeto <see cref="T:System.Threading.Tasks.Task" /> con la acción y las opciones de creación especificadas.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 En lugar de llamar a este constructor, la manera más común para crear instancias de un <xref:System.Threading.Tasks.Task> objeto e inicie una tarea consiste en llamar al estático <xref:System.Threading.Tasks.TaskFactory.StartNew%28System.Action%2CSystem.Threading.CancellationToken%2CSystem.Threading.Tasks.TaskCreationOptions%2CSystem.Threading.Tasks.TaskScheduler%29?displayProperty=nameWithType> método. La única ventaja que ofrece este constructor es que permite la creación de instancias de objeto se separen de invocación de la tarea.  
  
 Para obtener más información, consulte [paralelismo de tareas (Task Parallel Library)](~/docs/standard/parallel-programming/task-based-asynchronous-programming.md) y [cancelación de tareas](~/docs/standard/parallel-programming/task-cancellation.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">El <see cref="T:System.Threading.CancellationTokenSource" /> que creó <paramref name="cancellationToken" /> ya se ha eliminado.</exception>
        <exception cref="T:System.ArgumentNullException">El argumento de <paramref name="action" /> es nulo.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">El argumento <paramref name="creationOptions" /> especifica un valor no válido para <see cref="T:System.Threading.Tasks.TaskCreationOptions" />.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Task (Action&lt;object&gt; action, object state, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Action`1&lt;object&gt; action, object state, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.#ctor(System.Action{System.Object},System.Object,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Task(Action&lt;System::Object ^&gt; ^ action, System::Object ^ state, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="new System.Threading.Tasks.Task : Action&lt;obj&gt; * obj * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task" Usage="new System.Threading.Tasks.Task (action, state, cancellationToken)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="action" Type="System.Action&lt;System.Object&gt;" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="action">El delegado que representa el código que se va a ejecutar en la tarea.</param>
        <param name="state">Objeto que representa los datos que la acción va a usar.</param>
        <param name="cancellationToken">
          <see cref="P:System.Threading.Tasks.TaskFactory.CancellationToken" /> que la nueva tarea observará.</param>
        <summary>Inicializa un nuevo objeto <see cref="T:System.Threading.Tasks.Task" /> con la acción, el estado y las opciones especificados.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 En lugar de llamar a este constructor, la manera más común para crear instancias de un <xref:System.Threading.Tasks.Task> objeto e inicie una tarea consiste en llamar al estático <xref:System.Threading.Tasks.TaskFactory.StartNew%28System.Action%7BSystem.Object%7D%2CSystem.Object%2CSystem.Threading.CancellationToken%29?displayProperty=nameWithType> método. La única ventaja que ofrece este constructor es que permite la creación de instancias de objeto se separen de invocación de la tarea.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">El <see cref="T:System.Threading.CancellationTokenSource" /> que creó <paramref name="cancellationToken" /> ya se ha eliminado.</exception>
        <exception cref="T:System.ArgumentNullException">El argumento de <paramref name="action" /> es nulo.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Task (Action&lt;object&gt; action, object state, System.Threading.Tasks.TaskCreationOptions creationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Action`1&lt;object&gt; action, object state, valuetype System.Threading.Tasks.TaskCreationOptions creationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.#ctor(System.Action{System.Object},System.Object,System.Threading.Tasks.TaskCreationOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (action As Action(Of Object), state As Object, creationOptions As TaskCreationOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Task(Action&lt;System::Object ^&gt; ^ action, System::Object ^ state, System::Threading::Tasks::TaskCreationOptions creationOptions);" />
      <MemberSignature Language="F#" Value="new System.Threading.Tasks.Task : Action&lt;obj&gt; * obj * System.Threading.Tasks.TaskCreationOptions -&gt; System.Threading.Tasks.Task" Usage="new System.Threading.Tasks.Task (action, state, creationOptions)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="action" Type="System.Action&lt;System.Object&gt;" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="creationOptions" Type="System.Threading.Tasks.TaskCreationOptions" />
      </Parameters>
      <Docs>
        <param name="action">El delegado que representa el código que se va a ejecutar en la tarea.</param>
        <param name="state">Objeto que representa los datos que la acción va a usar.</param>
        <param name="creationOptions">El objeto <see cref="T:System.Threading.Tasks.TaskCreationOptions" /> que se usa para personalizar el comportamiento de la tarea.</param>
        <summary>Inicializa un nuevo objeto <see cref="T:System.Threading.Tasks.Task" /> con la acción, el estado y las opciones especificados.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 En lugar de llamar a este constructor, la manera más común para crear instancias de un <xref:System.Threading.Tasks.Task> objeto e inicie una tarea consiste en llamar al estático <xref:System.Threading.Tasks.TaskFactory.StartNew%28System.Action%7BSystem.Object%7D%2CSystem.Object%2CSystem.Threading.Tasks.TaskCreationOptions%29?displayProperty=nameWithType> método. La única ventaja que ofrece este constructor es que permite la creación de instancias de objeto se separen de invocación de la tarea.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El argumento de <paramref name="action" /> es nulo.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">El argumento <paramref name="creationOptions" /> especifica un valor no válido para <see cref="T:System.Threading.Tasks.TaskCreationOptions" />.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Task (Action&lt;object&gt; action, object state, System.Threading.CancellationToken cancellationToken, System.Threading.Tasks.TaskCreationOptions creationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Action`1&lt;object&gt; action, object state, valuetype System.Threading.CancellationToken cancellationToken, valuetype System.Threading.Tasks.TaskCreationOptions creationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.#ctor(System.Action{System.Object},System.Object,System.Threading.CancellationToken,System.Threading.Tasks.TaskCreationOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Task(Action&lt;System::Object ^&gt; ^ action, System::Object ^ state, System::Threading::CancellationToken cancellationToken, System::Threading::Tasks::TaskCreationOptions creationOptions);" />
      <MemberSignature Language="F#" Value="new System.Threading.Tasks.Task : Action&lt;obj&gt; * obj * System.Threading.CancellationToken * System.Threading.Tasks.TaskCreationOptions -&gt; System.Threading.Tasks.Task" Usage="new System.Threading.Tasks.Task (action, state, cancellationToken, creationOptions)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="action" Type="System.Action&lt;System.Object&gt;" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        <Parameter Name="creationOptions" Type="System.Threading.Tasks.TaskCreationOptions" />
      </Parameters>
      <Docs>
        <param name="action">El delegado que representa el código que se va a ejecutar en la tarea.</param>
        <param name="state">Objeto que representa los datos que la acción va a usar.</param>
        <param name="cancellationToken">El <see cref="P:System.Threading.Tasks.TaskFactory.CancellationToken" /> que observará la nueva tarea.</param>
        <param name="creationOptions">El objeto <see cref="T:System.Threading.Tasks.TaskCreationOptions" /> que se usa para personalizar el comportamiento de la tarea.</param>
        <summary>Inicializa un nuevo objeto <see cref="T:System.Threading.Tasks.Task" /> con la acción, el estado y las opciones especificados.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 En lugar de llamar a este constructor, la manera más común para crear instancias de un <xref:System.Threading.Tasks.Task> objeto e inicie una tarea consiste en llamar al estático <xref:System.Threading.Tasks.TaskFactory.StartNew%28System.Action%7BSystem.Object%7D%2CSystem.Object%2CSystem.Threading.CancellationToken%2CSystem.Threading.Tasks.TaskCreationOptions%2CSystem.Threading.Tasks.TaskScheduler%29?displayProperty=nameWithType> método. La única ventaja que ofrece este constructor es que permite la creación de instancias de objeto se separen de invocación de la tarea.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">El <see cref="T:System.Threading.CancellationTokenSource" /> que creó <paramref name="cancellationToken" /> ya se ha eliminado.</exception>
        <exception cref="T:System.ArgumentNullException">El argumento de <paramref name="action" /> es nulo.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">El argumento <paramref name="creationOptions" /> especifica un valor no válido para <see cref="T:System.Threading.Tasks.TaskCreationOptions" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="AsyncState">
      <MemberSignature Language="C#" Value="public object AsyncState { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object AsyncState" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.Task.AsyncState" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property AsyncState As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ AsyncState { System::Object ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.AsyncState : obj" Usage="System.Threading.Tasks.Task.AsyncState" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.IAsyncResult.AsyncState</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene el objeto de estado que se proporcionó cuando se creó el objeto <see cref="T:System.Threading.Tasks.Task" />, o null si no se proporcionó ningún objeto de estado.</summary>
        <value>
          <see cref="T:System.Object" /> que representa los datos de estado que se pasaron a la tarea cuando se creó.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Convierta el objeto al tipo original para recuperar sus datos.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CompletedTask">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task CompletedTask { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Threading.Tasks.Task CompletedTask" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.Task.CompletedTask" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property CompletedTask As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Threading::Tasks::Task ^ CompletedTask { System::Threading::Tasks::Task ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.CompletedTask : System.Threading.Tasks.Task" Usage="System.Threading.Tasks.Task.CompletedTask" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene una tarea que ya ha finalizado correctamente.</summary>
        <value>La tarea terminó correctamente.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esta propiedad devuelve una tarea cuya <xref:System.Threading.Tasks.Task.Status%2A> propiedad está establecida en <xref:System.Threading.Tasks.TaskStatus.RanToCompletion>. Para crear la tarea que devuelve un valor y se ejecuta por completo, llame a la <xref:System.Threading.Tasks.Task.FromResult%2A> método.  
  
 Los intentos reiterados para recuperar el valor de esta propiedad no pueden devolver siempre la misma instancia.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Threading.Tasks.Task.FromResult``1(``0)" />
      </Docs>
    </Member>
    <Member MemberName="ConfigureAwait">
      <MemberSignature Language="C#" Value="public System.Runtime.CompilerServices.ConfiguredTaskAwaitable ConfigureAwait (bool continueOnCapturedContext);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Runtime.CompilerServices.ConfiguredTaskAwaitable ConfigureAwait(bool continueOnCapturedContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.ConfigureAwait(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function ConfigureAwait (continueOnCapturedContext As Boolean) As ConfiguredTaskAwaitable" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Runtime::CompilerServices::ConfiguredTaskAwaitable ConfigureAwait(bool continueOnCapturedContext);" />
      <MemberSignature Language="F#" Value="member this.ConfigureAwait : bool -&gt; System.Runtime.CompilerServices.ConfiguredTaskAwaitable" Usage="task.ConfigureAwait continueOnCapturedContext" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.CompilerServices.ConfiguredTaskAwaitable</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="continueOnCapturedContext" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="continueOnCapturedContext">Es <see langword="true" /> para intentar calcular las referencias de la continuación de nuevo al contexto original capturado; de lo contrario, es <see langword="false" />.</param>
        <summary>Configura un awaiter utilizado para esperar este objeto <see cref="T:System.Threading.Tasks.Task" />.</summary>
        <returns>Un objeto utilizado para esperar a esta tarea.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="ContinueWith">
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Crea una continuación que se ejecuta de manera asincrónica cuando se completa el objeto <see cref="T:System.Threading.Tasks.Task" /> de destino.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ContinueWith">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task ContinueWith (Action&lt;System.Threading.Tasks.Task&gt; continuationAction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task ContinueWith(class System.Action`1&lt;class System.Threading.Tasks.Task&gt; continuationAction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task})" />
      <MemberSignature Language="VB.NET" Value="Public Function ContinueWith (continuationAction As Action(Of Task)) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task ^ ContinueWith(Action&lt;System::Threading::Tasks::Task ^&gt; ^ continuationAction);" />
      <MemberSignature Language="F#" Value="member this.ContinueWith : Action&lt;System.Threading.Tasks.Task&gt; -&gt; System.Threading.Tasks.Task" Usage="task.ContinueWith continuationAction" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="continuationAction" Type="System.Action&lt;System.Threading.Tasks.Task&gt;" />
      </Parameters>
      <Docs>
        <param name="continuationAction">Acción que se va a ejecutar cuando se complete el objeto <see cref="T:System.Threading.Tasks.Task" />. Cuando se ejecute, al delegado se le pasará la tarea completada como un argumento.</param>
        <summary>Crea una continuación que se ejecuta de manera asincrónica cuando se completa el objeto <see cref="T:System.Threading.Tasks.Task" /> de destino.</summary>
        <returns>Nuevo objeto <see cref="T:System.Threading.Tasks.Task" /> de continuación.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El valor devuelto <xref:System.Threading.Tasks.Task> no se programará para su ejecución hasta que haya completado la tarea actual, si finaliza debido a ejecutarse hasta completarse correctamente, con errores debido a una excepción no controlada o se abandone al principio debido a la cancelación.  
  
   
  
## Examples  
 En el ejemplo siguiente se define una tarea que rellena una matriz con 100 aleatorio valores de fecha y hora. Usa el <xref:System.Threading.Tasks.Task.ContinueWith%28System.Action%7BSystem.Threading.Tasks.Task%7D%29> método para seleccionar la más antigua y los valores de fecha más recientes una vez que se completa la matriz.  
  
 [!code-csharp[System.Threading.Tasks.Task.ContinueWith#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.continuewith/cs/continuewith1.cs#1)]
 [!code-vb[System.Threading.Tasks.Task.ContinueWith#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.continuewith/vb/continuewith1.vb#1)]  
  
 Dado que una aplicación de consola puede finalizar antes de que se ejecuta la tarea de continuación, el <xref:System.Threading.Tasks.Task.Wait> método se llama para asegurarse de que la continuación termine de ejecutarse antes de los extremos de ejemplo.  
  
 Para obtener un ejemplo adicional, consulte [encadenar tareas mediante tareas de continuación](~/docs/standard/parallel-programming/chaining-tasks-by-using-continuation-tasks.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El argumento <paramref name="continuationAction" /> es <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task ContinueWith (Action&lt;System.Threading.Tasks.Task,object&gt; continuationAction, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task ContinueWith(class System.Action`2&lt;class System.Threading.Tasks.Task, object&gt; continuationAction, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task,System.Object},System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function ContinueWith (continuationAction As Action(Of Task, Object), state As Object) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task ^ ContinueWith(Action&lt;System::Threading::Tasks::Task ^, System::Object ^&gt; ^ continuationAction, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.ContinueWith : Action&lt;System.Threading.Tasks.Task, obj&gt; * obj -&gt; System.Threading.Tasks.Task" Usage="task.ContinueWith (continuationAction, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="continuationAction" Type="System.Action&lt;System.Threading.Tasks.Task,System.Object&gt;" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="continuationAction">Acción que se ejecutará cuando se complete la tarea. Cuando se ejecuta, se pasa al delegado la tarea completada y el objeto de estado proporcionado por el autor de la llamada como argumentos.</param>
        <param name="state">Objeto que representa los datos que la acción de continuación va a usar.</param>
        <summary>Crea una continuación que recibe información de estado proporcionada por el autor de la llamada y se ejecuta cuando el elemento <see cref="T:System.Threading.Tasks.Task" /> de destino se completa.</summary>
        <returns>Una tarea de continuación nueva.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El valor devuelto <xref:System.Threading.Tasks.Task> no se programará para su ejecución hasta que haya completado la tarea actual, si finaliza debido a ejecutarse hasta completarse correctamente, con errores debido a una excepción no controlada o salir al principio debido a la cancelación.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El argumento <paramref name="continuationAction" /> es <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task ContinueWith (Action&lt;System.Threading.Tasks.Task&gt; continuationAction, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task ContinueWith(class System.Action`1&lt;class System.Threading.Tasks.Task&gt; continuationAction, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task},System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task ^ ContinueWith(Action&lt;System::Threading::Tasks::Task ^&gt; ^ continuationAction, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="member this.ContinueWith : Action&lt;System.Threading.Tasks.Task&gt; * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task" Usage="task.ContinueWith (continuationAction, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="continuationAction" Type="System.Action&lt;System.Threading.Tasks.Task&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="continuationAction">Acción que se va a ejecutar cuando se complete el objeto <see cref="T:System.Threading.Tasks.Task" />. Cuando se ejecute, al delegado se le pasará la tarea completada como un argumento.</param>
        <param name="cancellationToken">
          <see cref="P:System.Threading.Tasks.TaskFactory.CancellationToken" /> que se va a asignar a la nueva tarea de continuación.</param>
        <summary>Crea una continuación que recibe un token de cancelación y se ejecuta de forma asincrónica cuando el elemento <see cref="T:System.Threading.Tasks.Task" /> de destino se completa.</summary>
        <returns>Nuevo objeto <see cref="T:System.Threading.Tasks.Task" /> de continuación.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El valor devuelto <xref:System.Threading.Tasks.Task> no se programará para su ejecución hasta que haya completado la tarea actual, si finaliza debido a ejecutarse hasta completarse correctamente, con errores debido a una excepción no controlada o se abandone al principio debido a la cancelación.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">El <see cref="T:System.Threading.CancellationTokenSource" /> que creó el token ya se ha eliminado.</exception>
        <exception cref="T:System.ArgumentNullException">El argumento de <paramref name="continuationAction" /> es nulo.</exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task ContinueWith (Action&lt;System.Threading.Tasks.Task&gt; continuationAction, System.Threading.Tasks.TaskContinuationOptions continuationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task ContinueWith(class System.Action`1&lt;class System.Threading.Tasks.Task&gt; continuationAction, valuetype System.Threading.Tasks.TaskContinuationOptions continuationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task},System.Threading.Tasks.TaskContinuationOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function ContinueWith (continuationAction As Action(Of Task), continuationOptions As TaskContinuationOptions) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task ^ ContinueWith(Action&lt;System::Threading::Tasks::Task ^&gt; ^ continuationAction, System::Threading::Tasks::TaskContinuationOptions continuationOptions);" />
      <MemberSignature Language="F#" Value="member this.ContinueWith : Action&lt;System.Threading.Tasks.Task&gt; * System.Threading.Tasks.TaskContinuationOptions -&gt; System.Threading.Tasks.Task" Usage="task.ContinueWith (continuationAction, continuationOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="continuationAction" Type="System.Action&lt;System.Threading.Tasks.Task&gt;" />
        <Parameter Name="continuationOptions" Type="System.Threading.Tasks.TaskContinuationOptions" />
      </Parameters>
      <Docs>
        <param name="continuationAction">Una acción que se ejecutará según el parámetro <c>continuationOptions</c> especificado. Cuando se ejecute, al delegado se le pasará la tarea completada como un argumento.</param>
        <param name="continuationOptions">Opciones para la programación y el comportamiento de la continuación. Incluye criterios, como <see cref="F:System.Threading.Tasks.TaskContinuationOptions.OnlyOnCanceled" />, y opciones de ejecución, como <see cref="F:System.Threading.Tasks.TaskContinuationOptions.ExecuteSynchronously" />.</param>
        <summary>Crea una continuación que se ejecuta cuando se completa la tarea de destino según el elemento <see cref="T:System.Threading.Tasks.TaskContinuationOptions" /> especificado.</summary>
        <returns>Nuevo objeto <see cref="T:System.Threading.Tasks.Task" /> de continuación.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El valor devuelto <xref:System.Threading.Tasks.Task> no se programará para su ejecución hasta que haya completado la tarea actual. Si especifican los criterios de continuación a través de la `continuationOptions` parámetro no se cumplen, se cancela la tarea de continuación en lugar de programarse.  
  
   
  
## Examples  
 En el ejemplo siguiente se muestra cómo utilizar <xref:System.Threading.Tasks.TaskContinuationOptions> para especificar que una tarea de continuación debe ejecutarse sincrónicamente cuando se complete la tarea anterior. (Si la tarea especificada ya se ha completado por el tiempo <xref:System.Threading.Tasks.Task.ContinueWith%2A> se llama, sincrónico se ejecutará a continuación en la llamada del subproceso <xref:System.Threading.Tasks.Task.ContinueWith%2A>.)  
  
```csharp  
  
public class TaskCounter  
{  
   private volatile int _count;  
  
   public void Track(Task t)  
   {  
      if (t == null) throw new ArgumentNullException("t");  
      Interlocked.Increment(ref _count);  
      t.ContinueWith(ct => Interlocked.Decrement(ref _count), TaskContinuationOptions.ExecuteSynchronously);  
   }  
  
   public int NumberOfActiveTasks { get { return _count; } }  
}  
  
```  
  
```vb  
  
Public Class TaskCounter  
   Private _count as Integer  
  
   Public Sub Track(ByVal t as Task)  
      If t is Nothing Then Throw New ArgumentNullException("t")  
      Interlocked.Increment(_count)  
      t.ContinueWith(Sub(ct)  
                        Interlocked.Decrement(_count)  
                     End Sub,  
                     TaskContinuationOptions.ExecuteSynchronously)  
   End Sub  
  
   Public ReadOnly Property NumberOfActiveTasks As Integer  
      Get  
         Return _count  
      End Get  
   End Property  
End Class  
  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El argumento de <paramref name="continuationAction" /> es nulo.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">El argumento <paramref name="continuationOptions" /> especifica un valor no válido para <see cref="T:System.Threading.Tasks.TaskContinuationOptions" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task ContinueWith (Action&lt;System.Threading.Tasks.Task&gt; continuationAction, System.Threading.Tasks.TaskScheduler scheduler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task ContinueWith(class System.Action`1&lt;class System.Threading.Tasks.Task&gt; continuationAction, class System.Threading.Tasks.TaskScheduler scheduler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task},System.Threading.Tasks.TaskScheduler)" />
      <MemberSignature Language="VB.NET" Value="Public Function ContinueWith (continuationAction As Action(Of Task), scheduler As TaskScheduler) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task ^ ContinueWith(Action&lt;System::Threading::Tasks::Task ^&gt; ^ continuationAction, System::Threading::Tasks::TaskScheduler ^ scheduler);" />
      <MemberSignature Language="F#" Value="member this.ContinueWith : Action&lt;System.Threading.Tasks.Task&gt; * System.Threading.Tasks.TaskScheduler -&gt; System.Threading.Tasks.Task" Usage="task.ContinueWith (continuationAction, scheduler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="continuationAction" Type="System.Action&lt;System.Threading.Tasks.Task&gt;" />
        <Parameter Name="scheduler" Type="System.Threading.Tasks.TaskScheduler" />
      </Parameters>
      <Docs>
        <param name="continuationAction">Acción que se va a ejecutar cuando se complete el objeto <see cref="T:System.Threading.Tasks.Task" />. Cuando se ejecute, al delegado se le pasará la tarea completada como un argumento.</param>
        <param name="scheduler">Objeto <see cref="T:System.Threading.Tasks.TaskScheduler" /> que se va a asociar a la tarea de continuación y se va a usar para su ejecución.</param>
        <summary>Crea una continuación que se ejecuta de manera asincrónica cuando se completa el objeto <see cref="T:System.Threading.Tasks.Task" /> de destino. La continuación usa un programador especificado.</summary>
        <returns>Nuevo objeto <see cref="T:System.Threading.Tasks.Task" /> de continuación.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El valor devuelto <xref:System.Threading.Tasks.Task> no se programará para su ejecución hasta que haya completado la tarea actual, si finaliza debido a ejecutarse hasta completarse correctamente, con errores debido a una excepción no controlada o se abandone al principio debido a la cancelación.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Se ha eliminado el objeto <see cref="T:System.Threading.Tasks.Task" />.</exception>
        <exception cref="T:System.ArgumentNullException">El argumento <paramref name="continuationAction" /> es <see langword="null" />.  -o bien- El argumento <paramref name="scheduler" /> es NULL.</exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task ContinueWith (Action&lt;System.Threading.Tasks.Task,object&gt; continuationAction, object state, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task ContinueWith(class System.Action`2&lt;class System.Threading.Tasks.Task, object&gt; continuationAction, object state, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task,System.Object},System.Object,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task ^ ContinueWith(Action&lt;System::Threading::Tasks::Task ^, System::Object ^&gt; ^ continuationAction, System::Object ^ state, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="member this.ContinueWith : Action&lt;System.Threading.Tasks.Task, obj&gt; * obj * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task" Usage="task.ContinueWith (continuationAction, state, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="continuationAction" Type="System.Action&lt;System.Threading.Tasks.Task,System.Object&gt;" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="continuationAction">Acción que se va a ejecutar cuando se complete el objeto <see cref="T:System.Threading.Tasks.Task" />. Cuando se ejecute, se pasarán al delegado la tarea completada y el objeto de estado proporcionado por el llamador como argumentos.</param>
        <param name="state">Objeto que representa los datos que la acción de continuación va a usar.</param>
        <param name="cancellationToken">
          <see cref="T:System.Threading.CancellationToken" /> que se va a asignar a la nueva tarea de continuación.</param>
        <summary>Crea una continuación que recibe información de estado proporcionada por el autor de la llamada y un token de cancelación y que se ejecuta de forma asincrónica cuando el elemento <see cref="T:System.Threading.Tasks.Task" /> de destino se completa.</summary>
        <returns>Nuevo objeto <see cref="T:System.Threading.Tasks.Task" /> de continuación.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El valor devuelto <xref:System.Threading.Tasks.Task> no se programará para su ejecución hasta que haya completado la tarea actual, si finaliza debido a ejecutarse hasta completarse correctamente, con errores debido a una excepción no controlada o se abandone al principio debido a la cancelación.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El argumento <paramref name="continuationAction" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ObjectDisposedException">El <see cref="T:System.Threading.CancellationToken" /> proporcionado ya se ha eliminado.</exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task ContinueWith (Action&lt;System.Threading.Tasks.Task,object&gt; continuationAction, object state, System.Threading.Tasks.TaskContinuationOptions continuationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task ContinueWith(class System.Action`2&lt;class System.Threading.Tasks.Task, object&gt; continuationAction, object state, valuetype System.Threading.Tasks.TaskContinuationOptions continuationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task,System.Object},System.Object,System.Threading.Tasks.TaskContinuationOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function ContinueWith (continuationAction As Action(Of Task, Object), state As Object, continuationOptions As TaskContinuationOptions) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task ^ ContinueWith(Action&lt;System::Threading::Tasks::Task ^, System::Object ^&gt; ^ continuationAction, System::Object ^ state, System::Threading::Tasks::TaskContinuationOptions continuationOptions);" />
      <MemberSignature Language="F#" Value="member this.ContinueWith : Action&lt;System.Threading.Tasks.Task, obj&gt; * obj * System.Threading.Tasks.TaskContinuationOptions -&gt; System.Threading.Tasks.Task" Usage="task.ContinueWith (continuationAction, state, continuationOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="continuationAction" Type="System.Action&lt;System.Threading.Tasks.Task,System.Object&gt;" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="continuationOptions" Type="System.Threading.Tasks.TaskContinuationOptions" />
      </Parameters>
      <Docs>
        <param name="continuationAction">Acción que se va a ejecutar cuando se complete el objeto <see cref="T:System.Threading.Tasks.Task" />. Cuando se ejecute, se pasarán al delegado la tarea completada y el objeto de estado proporcionado por el llamador como argumentos.</param>
        <param name="state">Objeto que representa los datos que la acción de continuación va a usar.</param>
        <param name="continuationOptions">Opciones para la programación y el comportamiento de la continuación. Incluye criterios, como <see cref="F:System.Threading.Tasks.TaskContinuationOptions.OnlyOnCanceled" />, y opciones de ejecución, como <see cref="F:System.Threading.Tasks.TaskContinuationOptions.ExecuteSynchronously" />.</param>
        <summary>Crea una continuación que recibe información de estado proporcionada por el autor de la llamada y se ejecuta cuando el elemento <see cref="T:System.Threading.Tasks.Task" /> de destino se completa. La continuación se ejecuta según un conjunto de condiciones especificadas.</summary>
        <returns>Nuevo objeto <see cref="T:System.Threading.Tasks.Task" /> de continuación.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El valor devuelto <xref:System.Threading.Tasks.Task> no se programará para su ejecución hasta que haya completado la tarea actual. Si especifican los criterios de continuación a través de la `continuationOptions` parámetro no se cumplen, se cancela la tarea de continuación en lugar de programarse.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El argumento <paramref name="continuationAction" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">El argumento <paramref name="continuationOptions" /> especifica un valor no válido para <see cref="T:System.Threading.Tasks.TaskContinuationOptions" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task ContinueWith (Action&lt;System.Threading.Tasks.Task,object&gt; continuationAction, object state, System.Threading.Tasks.TaskScheduler scheduler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task ContinueWith(class System.Action`2&lt;class System.Threading.Tasks.Task, object&gt; continuationAction, object state, class System.Threading.Tasks.TaskScheduler scheduler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task,System.Object},System.Object,System.Threading.Tasks.TaskScheduler)" />
      <MemberSignature Language="VB.NET" Value="Public Function ContinueWith (continuationAction As Action(Of Task, Object), state As Object, scheduler As TaskScheduler) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task ^ ContinueWith(Action&lt;System::Threading::Tasks::Task ^, System::Object ^&gt; ^ continuationAction, System::Object ^ state, System::Threading::Tasks::TaskScheduler ^ scheduler);" />
      <MemberSignature Language="F#" Value="member this.ContinueWith : Action&lt;System.Threading.Tasks.Task, obj&gt; * obj * System.Threading.Tasks.TaskScheduler -&gt; System.Threading.Tasks.Task" Usage="task.ContinueWith (continuationAction, state, scheduler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="continuationAction" Type="System.Action&lt;System.Threading.Tasks.Task,System.Object&gt;" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="scheduler" Type="System.Threading.Tasks.TaskScheduler" />
      </Parameters>
      <Docs>
        <param name="continuationAction">Acción que se va a ejecutar cuando se complete el objeto <see cref="T:System.Threading.Tasks.Task" />.  Cuando se ejecute, se pasarán al delegado la tarea completada y el objeto de estado proporcionado por el llamador como argumentos.</param>
        <param name="state">Objeto que representa los datos que la acción de continuación va a usar.</param>
        <param name="scheduler">Objeto <see cref="T:System.Threading.Tasks.TaskScheduler" /> que se va a asociar a la tarea de continuación y se va a usar para su ejecución.</param>
        <summary>Crea una continuación que recibe información de estado proporcionada por el autor de la llamada y se ejecuta de forma asincrónica cuando el elemento <see cref="T:System.Threading.Tasks.Task" /> de destino se completa. La continuación usa un programador especificado.</summary>
        <returns>Nuevo objeto <see cref="T:System.Threading.Tasks.Task" /> de continuación.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El valor devuelto <xref:System.Threading.Tasks.Task> no se programará para su ejecución hasta que haya completado la tarea actual, si finaliza debido a ejecutarse hasta completarse correctamente, con errores debido a una excepción no controlada o se abandone al principio debido a la cancelación.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El argumento <paramref name="scheduler" /> es <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task ContinueWith (Action&lt;System.Threading.Tasks.Task&gt; continuationAction, System.Threading.CancellationToken cancellationToken, System.Threading.Tasks.TaskContinuationOptions continuationOptions, System.Threading.Tasks.TaskScheduler scheduler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task ContinueWith(class System.Action`1&lt;class System.Threading.Tasks.Task&gt; continuationAction, valuetype System.Threading.CancellationToken cancellationToken, valuetype System.Threading.Tasks.TaskContinuationOptions continuationOptions, class System.Threading.Tasks.TaskScheduler scheduler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task},System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task ^ ContinueWith(Action&lt;System::Threading::Tasks::Task ^&gt; ^ continuationAction, System::Threading::CancellationToken cancellationToken, System::Threading::Tasks::TaskContinuationOptions continuationOptions, System::Threading::Tasks::TaskScheduler ^ scheduler);" />
      <MemberSignature Language="F#" Value="member this.ContinueWith : Action&lt;System.Threading.Tasks.Task&gt; * System.Threading.CancellationToken * System.Threading.Tasks.TaskContinuationOptions * System.Threading.Tasks.TaskScheduler -&gt; System.Threading.Tasks.Task" Usage="task.ContinueWith (continuationAction, cancellationToken, continuationOptions, scheduler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="continuationAction" Type="System.Action&lt;System.Threading.Tasks.Task&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        <Parameter Name="continuationOptions" Type="System.Threading.Tasks.TaskContinuationOptions" />
        <Parameter Name="scheduler" Type="System.Threading.Tasks.TaskScheduler" />
      </Parameters>
      <Docs>
        <param name="continuationAction">Una acción que se ejecutará según el parámetro <c>continuationOptions</c> especificado. Cuando se ejecute, al delegado se le pasará la tarea completada como un argumento.</param>
        <param name="cancellationToken">
          <see cref="P:System.Threading.Tasks.TaskFactory.CancellationToken" /> que se va a asignar a la nueva tarea de continuación.</param>
        <param name="continuationOptions">Opciones para la programación y el comportamiento de la continuación. Incluye criterios, como <see cref="F:System.Threading.Tasks.TaskContinuationOptions.OnlyOnCanceled" />, y opciones de ejecución, como <see cref="F:System.Threading.Tasks.TaskContinuationOptions.ExecuteSynchronously" />.</param>
        <param name="scheduler">Objeto <see cref="T:System.Threading.Tasks.TaskScheduler" /> que se va a asociar a la tarea de continuación y se va a usar para su ejecución.</param>
        <summary>Crea una continuación que se ejecuta cuando se completa la tarea de destino según el elemento <see cref="T:System.Threading.Tasks.TaskContinuationOptions" /> especificado. La continuación recibe un token de cancelación y usa un programador especificado.</summary>
        <returns>Nuevo objeto <see cref="T:System.Threading.Tasks.Task" /> de continuación.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El valor devuelto <xref:System.Threading.Tasks.Task> no se programará para su ejecución hasta que haya completado la tarea actual. Si los criterios especifican a través de la `continuationOptions` parámetro no se cumplen, se cancela la tarea de continuación en lugar de programarse.  
  
   
  
## Examples  
 El siguiente es un ejemplo del uso de ContinueWith para ejecutar el trabajo en segundo plano y el usuario de subprocesos de interfaz.  
  
```csharp  
  
private void Button1_Click(object sender, EventArgs e)  
{  
   var backgroundScheduler = TaskScheduler.Default;  
   var uiScheduler = TaskScheduler.FromCurrentSynchronizationContext();  
   Task.Factory.StartNew(delegate { DoBackgroundComputation(); },  
                         backgroundScheduler).  
   ContinueWith(delegate { UpdateUI(); }, uiScheduler).  
                ContinueWith(delegate { DoAnotherBackgroundComputation(); },  
                             backgroundScheduler).  
                ContinueWith(delegate { UpdateUIAgain(); }, uiScheduler);  
}  
  
```  
  
```vb  
  
Private Sub Button1_Click(ByVal sender As System.Object,   
                          ByVal e As System.EventArgs) Handles Button1.Click  
   Dim backgroundScheduler = TaskScheduler.Default  
   Dim uiScheduler = TaskScheduler.FromCurrentSynchronizationContext()  
  
   Task.Factory.StartNew(Sub()  
                           DoBackgroundComputation()  
                         End Sub, backgroundScheduler).ContinueWith(Sub(t)  
                            UpdateUI()  
                         End Sub, uiScheduler).ContinueWith(Sub(t)  
                            DoAnotherBackgroundComputation()  
                         End Sub, backgroundScheduler).ContinueWith(Sub(t)  
                            UpdateUIAgain()  
                         End Sub, uiScheduler)  
End Sub  
  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">El <see cref="T:System.Threading.CancellationTokenSource" /> que creó el token ya se ha eliminado.</exception>
        <exception cref="T:System.ArgumentNullException">El argumento de <paramref name="continuationAction" /> es nulo.  -o bien- El argumento <paramref name="scheduler" /> es NULL.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">El argumento <paramref name="continuationOptions" /> especifica un valor no válido para <see cref="T:System.Threading.Tasks.TaskContinuationOptions" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task ContinueWith (Action&lt;System.Threading.Tasks.Task,object&gt; continuationAction, object state, System.Threading.CancellationToken cancellationToken, System.Threading.Tasks.TaskContinuationOptions continuationOptions, System.Threading.Tasks.TaskScheduler scheduler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task ContinueWith(class System.Action`2&lt;class System.Threading.Tasks.Task, object&gt; continuationAction, object state, valuetype System.Threading.CancellationToken cancellationToken, valuetype System.Threading.Tasks.TaskContinuationOptions continuationOptions, class System.Threading.Tasks.TaskScheduler scheduler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task,System.Object},System.Object,System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task ^ ContinueWith(Action&lt;System::Threading::Tasks::Task ^, System::Object ^&gt; ^ continuationAction, System::Object ^ state, System::Threading::CancellationToken cancellationToken, System::Threading::Tasks::TaskContinuationOptions continuationOptions, System::Threading::Tasks::TaskScheduler ^ scheduler);" />
      <MemberSignature Language="F#" Value="member this.ContinueWith : Action&lt;System.Threading.Tasks.Task, obj&gt; * obj * System.Threading.CancellationToken * System.Threading.Tasks.TaskContinuationOptions * System.Threading.Tasks.TaskScheduler -&gt; System.Threading.Tasks.Task" Usage="task.ContinueWith (continuationAction, state, cancellationToken, continuationOptions, scheduler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="continuationAction" Type="System.Action&lt;System.Threading.Tasks.Task,System.Object&gt;" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        <Parameter Name="continuationOptions" Type="System.Threading.Tasks.TaskContinuationOptions" />
        <Parameter Name="scheduler" Type="System.Threading.Tasks.TaskScheduler" />
      </Parameters>
      <Docs>
        <param name="continuationAction">Acción que se va a ejecutar cuando se complete el objeto <see cref="T:System.Threading.Tasks.Task" />. Cuando se ejecute, se pasarán al delegado la tarea completada y el objeto de estado proporcionado por el llamador como argumentos.</param>
        <param name="state">Objeto que representa los datos que la acción de continuación va a usar.</param>
        <param name="cancellationToken">
          <see cref="T:System.Threading.CancellationToken" /> que se va a asignar a la nueva tarea de continuación.</param>
        <param name="continuationOptions">Opciones para la programación y el comportamiento de la continuación. Incluye criterios, como <see cref="F:System.Threading.Tasks.TaskContinuationOptions.OnlyOnCanceled" />, y opciones de ejecución, como <see cref="F:System.Threading.Tasks.TaskContinuationOptions.ExecuteSynchronously" />.</param>
        <param name="scheduler">Objeto <see cref="T:System.Threading.Tasks.TaskScheduler" /> que se va a asociar a la tarea de continuación y se va a usar para su ejecución.</param>
        <summary>Crea una continuación que recibe información de estado proporcionada por el autor de la llamada y un token de cancelación y que se ejecuta cuando el elemento <see cref="T:System.Threading.Tasks.Task" /> de destino se completa. La continuación se ejecuta según un conjunto de condiciones especificadas y usa un programador especificado.</summary>
        <returns>Nuevo objeto <see cref="T:System.Threading.Tasks.Task" /> de continuación.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El valor devuelto <xref:System.Threading.Tasks.Task> no se programará para su ejecución hasta que haya completado la tarea actual. Si los criterios especifican a través de la `continuationOptions` parámetro no se cumplen, se cancela la tarea de continuación en lugar de programarse.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El argumento <paramref name="scheduler" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">El argumento <paramref name="continuationOptions" /> especifica un valor no válido para <see cref="T:System.Threading.Tasks.TaskContinuationOptions" />.</exception>
        <exception cref="T:System.ObjectDisposedException">El <see cref="T:System.Threading.CancellationToken" /> proporcionado ya se ha eliminado.</exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; ContinueWith&lt;TResult&gt; (Func&lt;System.Threading.Tasks.Task,TResult&gt; continuationFunction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; ContinueWith&lt;TResult&gt;(class System.Func`2&lt;class System.Threading.Tasks.Task, !!TResult&gt; continuationFunction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,``0})" />
      <MemberSignature Language="VB.NET" Value="Public Function ContinueWith(Of TResult) (continuationFunction As Func(Of Task, TResult)) As Task(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; System::Threading::Tasks::Task&lt;TResult&gt; ^ ContinueWith(Func&lt;System::Threading::Tasks::Task ^, TResult&gt; ^ continuationFunction);" />
      <MemberSignature Language="F#" Value="member this.ContinueWith : Func&lt;System.Threading.Tasks.Task, 'Result&gt; -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="task.ContinueWith continuationFunction" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="continuationFunction" Type="System.Func&lt;System.Threading.Tasks.Task,TResult&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">Tipo de resultado generado por la continuación.</typeparam>
        <param name="continuationFunction">Función que se va a ejecutar cuando se complete el objeto <see cref="T:System.Threading.Tasks.Task`1" />. Cuando se ejecute, al delegado se le pasará la tarea completada como un argumento.</param>
        <summary>Crea una continuación que se ejecuta de forma asincrónica cuando el elemento <see cref="T:System.Threading.Tasks.Task`1" /> de destino se completa y devuelve un valor.</summary>
        <returns>Una tarea de continuación nueva.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El valor devuelto <xref:System.Threading.Tasks.Task%601> no se programará para su ejecución hasta que haya completado la tarea actual, si finaliza debido a ejecutarse hasta completarse correctamente, con errores debido a una excepción no controlada o se abandone al principio debido a la cancelación.  
  
   
  
## Examples  
 En el ejemplo siguiente se muestra cómo utilizar el método ContinueWith:  
  
 [!code-csharp[System.Threading.Tasks.Task#03](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task/cs/continuationsimple.cs#03)]
 [!code-vb[System.Threading.Tasks.Task#03](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task/vb/continuationsimple.vb#03)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Se ha eliminado el objeto <see cref="T:System.Threading.Tasks.Task" />.</exception>
        <exception cref="T:System.ArgumentNullException">El argumento de <paramref name="continuationFunction" /> es nulo.</exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; ContinueWith&lt;TResult&gt; (Func&lt;System.Threading.Tasks.Task,object,TResult&gt; continuationFunction, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; ContinueWith&lt;TResult&gt;(class System.Func`3&lt;class System.Threading.Tasks.Task, object, !!TResult&gt; continuationFunction, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,System.Object,``0},System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function ContinueWith(Of TResult) (continuationFunction As Func(Of Task, Object, TResult), state As Object) As Task(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; System::Threading::Tasks::Task&lt;TResult&gt; ^ ContinueWith(Func&lt;System::Threading::Tasks::Task ^, System::Object ^, TResult&gt; ^ continuationFunction, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.ContinueWith : Func&lt;System.Threading.Tasks.Task, obj, 'Result&gt; * obj -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="task.ContinueWith (continuationFunction, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="continuationFunction" Type="System.Func&lt;System.Threading.Tasks.Task,System.Object,TResult&gt;" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">Tipo de resultado generado por la continuación.</typeparam>
        <param name="continuationFunction">Función que se va a ejecutar cuando se complete el objeto <see cref="T:System.Threading.Tasks.Task" />. Cuando se ejecuta, se pasarán al delegado la tarea completada y el objeto de estado proporcionado por el llamador como argumentos.</param>
        <param name="state">Objeto que representa los datos que la función de continuación va a usar.</param>
        <summary>Crea una continuación que recibe información de estado proporcionada por el autor de la llamada y se ejecuta de forma asincrónica cuando el elemento <see cref="T:System.Threading.Tasks.Task" /> de destino se completa y devuelve un valor.</summary>
        <returns>Nuevo objeto <see cref="T:System.Threading.Tasks.Task`1" /> de continuación.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El valor devuelto <xref:System.Threading.Tasks.Task%601> no se programará para su ejecución hasta que haya completado la tarea actual, si finaliza debido a ejecutarse hasta completarse correctamente, con errores debido a una excepción no controlada o se abandone al principio debido a la cancelación.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El argumento <paramref name="continuationFunction" /> es <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; ContinueWith&lt;TResult&gt; (Func&lt;System.Threading.Tasks.Task,TResult&gt; continuationFunction, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; ContinueWith&lt;TResult&gt;(class System.Func`2&lt;class System.Threading.Tasks.Task, !!TResult&gt; continuationFunction, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,``0},System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; System::Threading::Tasks::Task&lt;TResult&gt; ^ ContinueWith(Func&lt;System::Threading::Tasks::Task ^, TResult&gt; ^ continuationFunction, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="member this.ContinueWith : Func&lt;System.Threading.Tasks.Task, 'Result&gt; * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="task.ContinueWith (continuationFunction, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="continuationFunction" Type="System.Func&lt;System.Threading.Tasks.Task,TResult&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">Tipo de resultado generado por la continuación.</typeparam>
        <param name="continuationFunction">Función que se va a ejecutar cuando se complete el objeto <see cref="T:System.Threading.Tasks.Task" />. Cuando se ejecute, al delegado se le pasará la tarea completada como un argumento.</param>
        <param name="cancellationToken">
          <see cref="P:System.Threading.Tasks.TaskFactory.CancellationToken" /> que se va a asignar a la nueva tarea de continuación.</param>
        <summary>Crea una continuación que se ejecuta de forma asincrónica cuando el elemento <see cref="T:System.Threading.Tasks.Task" /> de destino se completa y devuelve un valor. La continuación recibe un token de cancelación.</summary>
        <returns>Nuevo objeto <see cref="T:System.Threading.Tasks.Task`1" /> de continuación.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El valor devuelto <xref:System.Threading.Tasks.Task%601> no se programará para su ejecución hasta que haya completado la tarea actual, si finaliza debido a ejecutarse hasta completarse correctamente, con errores debido a una excepción no controlada o se abandone al principio debido a la cancelación.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Se ha eliminado el objeto <see cref="T:System.Threading.Tasks.Task" />.  -o bien- El <see cref="T:System.Threading.CancellationTokenSource" /> que creó el token ya se ha eliminado.</exception>
        <exception cref="T:System.ArgumentNullException">El argumento de <paramref name="continuationFunction" /> es nulo.</exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; ContinueWith&lt;TResult&gt; (Func&lt;System.Threading.Tasks.Task,TResult&gt; continuationFunction, System.Threading.Tasks.TaskContinuationOptions continuationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; ContinueWith&lt;TResult&gt;(class System.Func`2&lt;class System.Threading.Tasks.Task, !!TResult&gt; continuationFunction, valuetype System.Threading.Tasks.TaskContinuationOptions continuationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,``0},System.Threading.Tasks.TaskContinuationOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function ContinueWith(Of TResult) (continuationFunction As Func(Of Task, TResult), continuationOptions As TaskContinuationOptions) As Task(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; System::Threading::Tasks::Task&lt;TResult&gt; ^ ContinueWith(Func&lt;System::Threading::Tasks::Task ^, TResult&gt; ^ continuationFunction, System::Threading::Tasks::TaskContinuationOptions continuationOptions);" />
      <MemberSignature Language="F#" Value="member this.ContinueWith : Func&lt;System.Threading.Tasks.Task, 'Result&gt; * System.Threading.Tasks.TaskContinuationOptions -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="task.ContinueWith (continuationFunction, continuationOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="continuationFunction" Type="System.Func&lt;System.Threading.Tasks.Task,TResult&gt;" />
        <Parameter Name="continuationOptions" Type="System.Threading.Tasks.TaskContinuationOptions" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">Tipo de resultado generado por la continuación.</typeparam>
        <param name="continuationFunction">Una función que se ejecutará según las condiciones especificadas en <c>continuationOptions</c>. Cuando se ejecute, al delegado se le pasará la tarea completada como un argumento.</param>
        <param name="continuationOptions">Opciones para la programación y el comportamiento de la continuación. Incluye criterios, como <see cref="F:System.Threading.Tasks.TaskContinuationOptions.OnlyOnCanceled" />, y opciones de ejecución, como <see cref="F:System.Threading.Tasks.TaskContinuationOptions.ExecuteSynchronously" />.</param>
        <summary>Crea una continuación que se ejecuta según las opciones de continuación especificadas y devuelve un valor.</summary>
        <returns>Nuevo objeto <see cref="T:System.Threading.Tasks.Task`1" /> de continuación.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El valor devuelto <xref:System.Threading.Tasks.Task%601> no se programará para su ejecución hasta que haya completado la tarea actual. Si especifican los criterios de continuación a través de la `continuationOptions` parámetro no se cumplen, se cancela la tarea de continuación en lugar de programarse.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Se ha eliminado el objeto <see cref="T:System.Threading.Tasks.Task" />.</exception>
        <exception cref="T:System.ArgumentNullException">El argumento de <paramref name="continuationFunction" /> es nulo.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">El argumento <paramref name="continuationOptions" /> especifica un valor no válido para <see cref="T:System.Threading.Tasks.TaskContinuationOptions" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; ContinueWith&lt;TResult&gt; (Func&lt;System.Threading.Tasks.Task,TResult&gt; continuationFunction, System.Threading.Tasks.TaskScheduler scheduler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; ContinueWith&lt;TResult&gt;(class System.Func`2&lt;class System.Threading.Tasks.Task, !!TResult&gt; continuationFunction, class System.Threading.Tasks.TaskScheduler scheduler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,``0},System.Threading.Tasks.TaskScheduler)" />
      <MemberSignature Language="VB.NET" Value="Public Function ContinueWith(Of TResult) (continuationFunction As Func(Of Task, TResult), scheduler As TaskScheduler) As Task(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; System::Threading::Tasks::Task&lt;TResult&gt; ^ ContinueWith(Func&lt;System::Threading::Tasks::Task ^, TResult&gt; ^ continuationFunction, System::Threading::Tasks::TaskScheduler ^ scheduler);" />
      <MemberSignature Language="F#" Value="member this.ContinueWith : Func&lt;System.Threading.Tasks.Task, 'Result&gt; * System.Threading.Tasks.TaskScheduler -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="task.ContinueWith (continuationFunction, scheduler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="continuationFunction" Type="System.Func&lt;System.Threading.Tasks.Task,TResult&gt;" />
        <Parameter Name="scheduler" Type="System.Threading.Tasks.TaskScheduler" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">Tipo de resultado generado por la continuación.</typeparam>
        <param name="continuationFunction">Función que se va a ejecutar cuando se complete el objeto <see cref="T:System.Threading.Tasks.Task" />. Cuando se ejecute, al delegado se le pasará la tarea completada como un argumento.</param>
        <param name="scheduler">Objeto <see cref="T:System.Threading.Tasks.TaskScheduler" /> que se va a asociar a la tarea de continuación y se va a usar para su ejecución.</param>
        <summary>Crea una continuación que se ejecuta de forma asincrónica cuando el elemento <see cref="T:System.Threading.Tasks.Task" /> de destino se completa y devuelve un valor. La continuación usa un programador especificado.</summary>
        <returns>Nuevo objeto <see cref="T:System.Threading.Tasks.Task`1" /> de continuación.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El valor devuelto <xref:System.Threading.Tasks.Task%601> no se programará para su ejecución hasta que haya completado la tarea actual, si finaliza debido a ejecutarse hasta completarse correctamente, con errores debido a una excepción no controlada o se abandone al principio debido a la cancelación.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Se ha eliminado el objeto <see cref="T:System.Threading.Tasks.Task" />.</exception>
        <exception cref="T:System.ArgumentNullException">El argumento de <paramref name="continuationFunction" /> es nulo.  -o bien- El argumento <paramref name="scheduler" /> es NULL.</exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; ContinueWith&lt;TResult&gt; (Func&lt;System.Threading.Tasks.Task,object,TResult&gt; continuationFunction, object state, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; ContinueWith&lt;TResult&gt;(class System.Func`3&lt;class System.Threading.Tasks.Task, object, !!TResult&gt; continuationFunction, object state, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,System.Object,``0},System.Object,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; System::Threading::Tasks::Task&lt;TResult&gt; ^ ContinueWith(Func&lt;System::Threading::Tasks::Task ^, System::Object ^, TResult&gt; ^ continuationFunction, System::Object ^ state, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="member this.ContinueWith : Func&lt;System.Threading.Tasks.Task, obj, 'Result&gt; * obj * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="task.ContinueWith (continuationFunction, state, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="continuationFunction" Type="System.Func&lt;System.Threading.Tasks.Task,System.Object,TResult&gt;" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">Tipo de resultado generado por la continuación.</typeparam>
        <param name="continuationFunction">Función que se va a ejecutar cuando se complete el objeto <see cref="T:System.Threading.Tasks.Task" />. Cuando se ejecute, se pasarán al delegado la tarea completada y el objeto de estado proporcionado por el llamador como argumentos.</param>
        <param name="state">Objeto que representa los datos que la función de continuación va a usar.</param>
        <param name="cancellationToken">
          <see cref="T:System.Threading.CancellationToken" /> que se va a asignar a la nueva tarea de continuación.</param>
        <summary>Crea una continuación que se ejecuta de forma asincrónica cuando el elemento <see cref="T:System.Threading.Tasks.Task" /> de destino se completa y devuelve un valor. La continuación recibe información de estado proporcionada por el autor de la llamada y un token de cancelación.</summary>
        <returns>Nuevo objeto <see cref="T:System.Threading.Tasks.Task`1" /> de continuación.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El valor devuelto <xref:System.Threading.Tasks.Task%601> no se programará para su ejecución hasta que haya completado la tarea actual, si finaliza debido a ejecutarse hasta completarse correctamente, con errores debido a una excepción no controlada o se abandone al principio debido a la cancelación.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El argumento <paramref name="continuationFunction" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ObjectDisposedException">El <see cref="T:System.Threading.CancellationToken" /> proporcionado ya se ha eliminado.</exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; ContinueWith&lt;TResult&gt; (Func&lt;System.Threading.Tasks.Task,object,TResult&gt; continuationFunction, object state, System.Threading.Tasks.TaskContinuationOptions continuationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; ContinueWith&lt;TResult&gt;(class System.Func`3&lt;class System.Threading.Tasks.Task, object, !!TResult&gt; continuationFunction, object state, valuetype System.Threading.Tasks.TaskContinuationOptions continuationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,System.Object,``0},System.Object,System.Threading.Tasks.TaskContinuationOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function ContinueWith(Of TResult) (continuationFunction As Func(Of Task, Object, TResult), state As Object, continuationOptions As TaskContinuationOptions) As Task(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; System::Threading::Tasks::Task&lt;TResult&gt; ^ ContinueWith(Func&lt;System::Threading::Tasks::Task ^, System::Object ^, TResult&gt; ^ continuationFunction, System::Object ^ state, System::Threading::Tasks::TaskContinuationOptions continuationOptions);" />
      <MemberSignature Language="F#" Value="member this.ContinueWith : Func&lt;System.Threading.Tasks.Task, obj, 'Result&gt; * obj * System.Threading.Tasks.TaskContinuationOptions -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="task.ContinueWith (continuationFunction, state, continuationOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="continuationFunction" Type="System.Func&lt;System.Threading.Tasks.Task,System.Object,TResult&gt;" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="continuationOptions" Type="System.Threading.Tasks.TaskContinuationOptions" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">Tipo de resultado generado por la continuación.</typeparam>
        <param name="continuationFunction">Función que se va a ejecutar cuando se complete el objeto <see cref="T:System.Threading.Tasks.Task" />. Cuando se ejecute, se pasarán al delegado la tarea completada y el objeto de estado proporcionado por el llamador como argumentos.</param>
        <param name="state">Objeto que representa los datos que la función de continuación va a usar.</param>
        <param name="continuationOptions">Opciones para la programación y el comportamiento de la continuación. Incluye criterios, como <see cref="F:System.Threading.Tasks.TaskContinuationOptions.OnlyOnCanceled" />, y opciones de ejecución, como <see cref="F:System.Threading.Tasks.TaskContinuationOptions.ExecuteSynchronously" />.</param>
        <summary>Crea una continuación que se ejecuta según las opciones de continuación de la tarea especificadas cuando el elemento <see cref="T:System.Threading.Tasks.Task" /> de destino se completa. La continuación recibe información de estado proporcionada por el autor de la llamada.</summary>
        <returns>Nuevo objeto <see cref="T:System.Threading.Tasks.Task`1" /> de continuación.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El valor devuelto <xref:System.Threading.Tasks.Task%601> no se programará para su ejecución hasta que haya completado la tarea actual. Si especifican los criterios de continuación a través de la `continuationOptions` parámetro no se cumplen, se cancela la tarea de continuación en lugar de programarse.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El argumento <paramref name="continuationFunction" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">El argumento <paramref name="continuationOptions" /> especifica un valor no válido para <see cref="T:System.Threading.Tasks.TaskContinuationOptions" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; ContinueWith&lt;TResult&gt; (Func&lt;System.Threading.Tasks.Task,object,TResult&gt; continuationFunction, object state, System.Threading.Tasks.TaskScheduler scheduler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; ContinueWith&lt;TResult&gt;(class System.Func`3&lt;class System.Threading.Tasks.Task, object, !!TResult&gt; continuationFunction, object state, class System.Threading.Tasks.TaskScheduler scheduler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,System.Object,``0},System.Object,System.Threading.Tasks.TaskScheduler)" />
      <MemberSignature Language="VB.NET" Value="Public Function ContinueWith(Of TResult) (continuationFunction As Func(Of Task, Object, TResult), state As Object, scheduler As TaskScheduler) As Task(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; System::Threading::Tasks::Task&lt;TResult&gt; ^ ContinueWith(Func&lt;System::Threading::Tasks::Task ^, System::Object ^, TResult&gt; ^ continuationFunction, System::Object ^ state, System::Threading::Tasks::TaskScheduler ^ scheduler);" />
      <MemberSignature Language="F#" Value="member this.ContinueWith : Func&lt;System.Threading.Tasks.Task, obj, 'Result&gt; * obj * System.Threading.Tasks.TaskScheduler -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="task.ContinueWith (continuationFunction, state, scheduler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="continuationFunction" Type="System.Func&lt;System.Threading.Tasks.Task,System.Object,TResult&gt;" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="scheduler" Type="System.Threading.Tasks.TaskScheduler" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">Tipo de resultado generado por la continuación.</typeparam>
        <param name="continuationFunction">Función que se va a ejecutar cuando se complete el objeto <see cref="T:System.Threading.Tasks.Task" />.  Cuando se ejecute, se pasarán al delegado la tarea completada y el objeto de estado proporcionado por el llamador como argumentos.</param>
        <param name="state">Objeto que representa los datos que la función de continuación va a usar.</param>
        <param name="scheduler">Objeto <see cref="T:System.Threading.Tasks.TaskScheduler" /> que se va a asociar a la tarea de continuación y se va a usar para su ejecución.</param>
        <summary>Crea una continuación que se ejecuta de manera asincrónica cuando se completa el objeto <see cref="T:System.Threading.Tasks.Task" /> de destino. La continuación recibe información de estado proporcionada por el autor de la llamada y usa a un programador especificado.</summary>
        <returns>Nuevo objeto <see cref="T:System.Threading.Tasks.Task`1" /> de continuación.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El valor devuelto <xref:System.Threading.Tasks.Task%601> no se programará para su ejecución hasta que haya completado la tarea actual, si finaliza debido a ejecutarse hasta completarse correctamente, con errores debido a una excepción no controlada o se abandone al principio debido a la cancelación.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El argumento <paramref name="scheduler" /> es <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; ContinueWith&lt;TResult&gt; (Func&lt;System.Threading.Tasks.Task,TResult&gt; continuationFunction, System.Threading.CancellationToken cancellationToken, System.Threading.Tasks.TaskContinuationOptions continuationOptions, System.Threading.Tasks.TaskScheduler scheduler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; ContinueWith&lt;TResult&gt;(class System.Func`2&lt;class System.Threading.Tasks.Task, !!TResult&gt; continuationFunction, valuetype System.Threading.CancellationToken cancellationToken, valuetype System.Threading.Tasks.TaskContinuationOptions continuationOptions, class System.Threading.Tasks.TaskScheduler scheduler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,``0},System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; System::Threading::Tasks::Task&lt;TResult&gt; ^ ContinueWith(Func&lt;System::Threading::Tasks::Task ^, TResult&gt; ^ continuationFunction, System::Threading::CancellationToken cancellationToken, System::Threading::Tasks::TaskContinuationOptions continuationOptions, System::Threading::Tasks::TaskScheduler ^ scheduler);" />
      <MemberSignature Language="F#" Value="member this.ContinueWith : Func&lt;System.Threading.Tasks.Task, 'Result&gt; * System.Threading.CancellationToken * System.Threading.Tasks.TaskContinuationOptions * System.Threading.Tasks.TaskScheduler -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="task.ContinueWith (continuationFunction, cancellationToken, continuationOptions, scheduler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="continuationFunction" Type="System.Func&lt;System.Threading.Tasks.Task,TResult&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        <Parameter Name="continuationOptions" Type="System.Threading.Tasks.TaskContinuationOptions" />
        <Parameter Name="scheduler" Type="System.Threading.Tasks.TaskScheduler" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">Tipo de resultado generado por la continuación.</typeparam>
        <param name="continuationFunction">Una función que se ejecutará según el parámetro <c>continuationOptions</c> especificado. Cuando se ejecute, al delegado se le pasará la tarea completada como un argumento.</param>
        <param name="cancellationToken">
          <see cref="P:System.Threading.Tasks.TaskFactory.CancellationToken" /> que se va a asignar a la nueva tarea de continuación.</param>
        <param name="continuationOptions">Opciones para la programación y el comportamiento de la continuación. Incluye criterios, como <see cref="F:System.Threading.Tasks.TaskContinuationOptions.OnlyOnCanceled" />, y opciones de ejecución, como <see cref="F:System.Threading.Tasks.TaskContinuationOptions.ExecuteSynchronously" />.</param>
        <param name="scheduler">Objeto <see cref="T:System.Threading.Tasks.TaskScheduler" /> que se va a asociar a la tarea de continuación y se va a usar para su ejecución.</param>
        <summary>Crea una continuación que se ejecuta según las opciones de continuación especificadas y devuelve un valor. Se pasa un token de cancelación a la continuación y usa un programador especificado.</summary>
        <returns>Nuevo objeto <see cref="T:System.Threading.Tasks.Task`1" /> de continuación.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El valor devuelto <xref:System.Threading.Tasks.Task%601> no se programará para su ejecución hasta que haya completado la tarea actual. Si los criterios especifican a través de la `continuationOptions` parámetro no se cumplen, se cancela la tarea de continuación en lugar de programarse.  
  
   
  
## Examples  
 En el ejemplo siguiente se muestra cómo utilizar el método ContinueWith con opciones de continuación:  
  
 [!code-csharp[System.Threading.Tasks.Task#04](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task/cs/continuationoptions.cs#04)]
 [!code-vb[System.Threading.Tasks.Task#04](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task/vb/continuationoptions.vb#04)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Se ha eliminado el objeto <see cref="T:System.Threading.Tasks.Task" />.  -o bien- El <see cref="T:System.Threading.CancellationTokenSource" /> que creó el token ya se ha eliminado.</exception>
        <exception cref="T:System.ArgumentNullException">El argumento de <paramref name="continuationFunction" /> es nulo.  -o bien- El argumento <paramref name="scheduler" /> es NULL.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">El argumento <paramref name="continuationOptions" /> especifica un valor no válido para <see cref="T:System.Threading.Tasks.TaskContinuationOptions" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; ContinueWith&lt;TResult&gt; (Func&lt;System.Threading.Tasks.Task,object,TResult&gt; continuationFunction, object state, System.Threading.CancellationToken cancellationToken, System.Threading.Tasks.TaskContinuationOptions continuationOptions, System.Threading.Tasks.TaskScheduler scheduler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; ContinueWith&lt;TResult&gt;(class System.Func`3&lt;class System.Threading.Tasks.Task, object, !!TResult&gt; continuationFunction, object state, valuetype System.Threading.CancellationToken cancellationToken, valuetype System.Threading.Tasks.TaskContinuationOptions continuationOptions, class System.Threading.Tasks.TaskScheduler scheduler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,System.Object,``0},System.Object,System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; System::Threading::Tasks::Task&lt;TResult&gt; ^ ContinueWith(Func&lt;System::Threading::Tasks::Task ^, System::Object ^, TResult&gt; ^ continuationFunction, System::Object ^ state, System::Threading::CancellationToken cancellationToken, System::Threading::Tasks::TaskContinuationOptions continuationOptions, System::Threading::Tasks::TaskScheduler ^ scheduler);" />
      <MemberSignature Language="F#" Value="member this.ContinueWith : Func&lt;System.Threading.Tasks.Task, obj, 'Result&gt; * obj * System.Threading.CancellationToken * System.Threading.Tasks.TaskContinuationOptions * System.Threading.Tasks.TaskScheduler -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="task.ContinueWith (continuationFunction, state, cancellationToken, continuationOptions, scheduler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="continuationFunction" Type="System.Func&lt;System.Threading.Tasks.Task,System.Object,TResult&gt;" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        <Parameter Name="continuationOptions" Type="System.Threading.Tasks.TaskContinuationOptions" />
        <Parameter Name="scheduler" Type="System.Threading.Tasks.TaskScheduler" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">Tipo de resultado generado por la continuación.</typeparam>
        <param name="continuationFunction">Función que se va a ejecutar cuando se complete el objeto <see cref="T:System.Threading.Tasks.Task" />. Cuando se ejecute, se pasarán al delegado la tarea completada y el objeto de estado proporcionado por el llamador como argumentos.</param>
        <param name="state">Objeto que representa los datos que la función de continuación va a usar.</param>
        <param name="cancellationToken">El <see cref="T:System.Threading.CancellationToken" /> que se asignará a la nueva tarea de continuación.</param>
        <param name="continuationOptions">Opciones para la programación y el comportamiento de la continuación. Incluye criterios, como <see cref="F:System.Threading.Tasks.TaskContinuationOptions.OnlyOnCanceled" />, y opciones de ejecución, como <see cref="F:System.Threading.Tasks.TaskContinuationOptions.ExecuteSynchronously" />.</param>
        <param name="scheduler">Objeto <see cref="T:System.Threading.Tasks.TaskScheduler" /> que se va a asociar a la tarea de continuación y se va a usar para su ejecución.</param>
        <summary>Crea una continuación que se ejecuta según las opciones de continuación de la tarea especificadas cuando el elemento <see cref="T:System.Threading.Tasks.Task" /> de destino se completa y devuelve un valor. La continuación recibe información de estado proporcionada por el autor de la llamada y un token de cancelación y usa el programador especificado.</summary>
        <returns>Nuevo objeto <see cref="T:System.Threading.Tasks.Task`1" /> de continuación.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El valor devuelto <xref:System.Threading.Tasks.Task%601> no se programará para su ejecución hasta que haya completado la tarea actual. Si los criterios especifican a través de la `continuationOptions` parámetro no se cumplen, se cancela la tarea de continuación en lugar de programarse.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El argumento <paramref name="scheduler" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">El argumento <paramref name="continuationOptions" /> especifica un valor no válido para <see cref="T:System.Threading.Tasks.TaskContinuationOptions" />.</exception>
        <exception cref="T:System.ObjectDisposedException">El <see cref="T:System.Threading.CancellationToken" /> proporcionado ya se ha eliminado.</exception>
      </Docs>
    </Member>
    <Member MemberName="CreationOptions">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.TaskCreationOptions CreationOptions { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Threading.Tasks.TaskCreationOptions CreationOptions" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.Task.CreationOptions" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CreationOptions As TaskCreationOptions" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Threading::Tasks::TaskCreationOptions CreationOptions { System::Threading::Tasks::TaskCreationOptions get(); };" />
      <MemberSignature Language="F#" Value="member this.CreationOptions : System.Threading.Tasks.TaskCreationOptions" Usage="System.Threading.Tasks.Task.CreationOptions" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.TaskCreationOptions</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene el objeto <see cref="T:System.Threading.Tasks.TaskCreationOptions" /> usado para crear esta tarea.</summary>
        <value>Objeto <see cref="T:System.Threading.Tasks.TaskCreationOptions" /> usado para crear esta tarea.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CurrentId">
      <MemberSignature Language="C#" Value="public static Nullable&lt;int&gt; CurrentId { get; }" />
      <MemberSignature Language="ILAsm" Value=".property valuetype System.Nullable`1&lt;int32&gt; CurrentId" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.Task.CurrentId" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property CurrentId As Nullable(Of Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property Nullable&lt;int&gt; CurrentId { Nullable&lt;int&gt; get(); };" />
      <MemberSignature Language="F#" Value="member this.CurrentId : Nullable&lt;int&gt;" Usage="System.Threading.Tasks.Task.CurrentId" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Devuelve el identificador del objeto <see cref="T:System.Threading.Tasks.Task" /> que se está ejecutando actualmente.</summary>
        <value>Entero que el sistema asignó a la tarea en ejecución.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Tasks.Task.CurrentId%2A> es un `static` (`Shared` en Visual Basic) propiedad que se usa para obtener el identificador de la tarea que se está ejecutando actualmente desde el código que se está ejecutando la tarea. Difiere de la <xref:System.Threading.Tasks.Task.Id%2A> propiedad, que devuelve el identificador de una determinada <xref:System.Threading.Tasks.Task> instancia. Si se intenta recuperar el <xref:System.Threading.Tasks.Task.CurrentId%2A> valor desde fuera del código que se está ejecutando una tarea, la propiedad devuelve `null`.  
  
 Tenga en cuenta que aunque las colisiones son muy raras, identificadores de tarea no se garantiza que sea único.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Threading.Tasks.Task.Id" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Delay">
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Crea una tarea que se completará después de un retardo.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Delay">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task Delay (int millisecondsDelay);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task Delay(int32 millisecondsDelay) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.Delay(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Delay (millisecondsDelay As Integer) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Tasks::Task ^ Delay(int millisecondsDelay);" />
      <MemberSignature Language="F#" Value="static member Delay : int -&gt; System.Threading.Tasks.Task" Usage="System.Threading.Tasks.Task.Delay millisecondsDelay" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="millisecondsDelay" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="millisecondsDelay">El número de milisegundos que se esperará antes de completar la tarea devuelta o -1 para esperar indefinidamente.</param>
        <summary>Crea una tarea que se completa después de un retraso.</summary>
        <returns>Una tarea que representa el retraso.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Threading.Tasks.Task.Delay%2A> método se utiliza normalmente para retrasar la operación de todo o parte de una tarea durante un intervalo de tiempo especificado. Normalmente, el tiempo de retardo se incluye:  
  
-   Al principio de la tarea, como en el ejemplo siguiente se muestra.  
  
     [!code-csharp[System.Threading.Tasks.Task.Delay#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.delay/cs/delay5.cs#5)]
     [!code-vb[System.Threading.Tasks.Task.Delay#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.delay/vb/delay5.vb#5)]  
  
-   En algún momento mientras se está ejecutando la tarea. En este caso, la llamada a la <xref:System.Threading.Tasks.Task.Delay%2A> método se ejecuta como una tarea secundaria dentro de una tarea, como se muestra en el ejemplo siguiente. Tenga en cuenta que desde la tarea que llama el <xref:System.Threading.Tasks.Task.Delay%2A> método se ejecuta de forma asincrónica, la tarea primaria debe esperar a que finalice mediante el uso de la `await` (palabra clave).  
  
     [!code-csharp[System.Threading.Tasks.Task.Delay#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.delay/cs/delay5.cs#7)]
     [!code-vb[System.Threading.Tasks.Task.Delay#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.delay/vb/delay5.vb#7)]  
  
 Después del retraso de tiempo especificado, se completa la tarea en el <xref:System.Threading.Tasks.TaskStatus.RanToCompletion> estado.  
  
 Este método depende del reloj del sistema. Esto significa que el tiempo de retardo aproximadamente será igual a la resolución del reloj del sistema si el `millisecondsDelay` argumento es menor que la resolución del reloj del sistema, que es aproximadamente 15 milisegundos en los sistemas Windows.  
  
   
  
## Examples  
 En el ejemplo siguiente se muestra un uso simple de la <xref:System.Threading.Tasks.Task.Delay%2A> método.  
  
 [!code-csharp[System.Threading.Tasks.Task.Delay#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.delay/cs/delay1.cs#1)]
 [!code-vb[System.Threading.Tasks.Task.Delay#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.delay/vb/delay1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">El argumento <paramref name="millisecondsDelay" /> es menor que -1.</exception>
      </Docs>
    </Member>
    <Member MemberName="Delay">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task Delay (TimeSpan delay);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task Delay(valuetype System.TimeSpan delay) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.Delay(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Delay (delay As TimeSpan) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Tasks::Task ^ Delay(TimeSpan delay);" />
      <MemberSignature Language="F#" Value="static member Delay : TimeSpan -&gt; System.Threading.Tasks.Task" Usage="System.Threading.Tasks.Task.Delay delay" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="delay" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="delay">El intervalo de tiempo que espera antes de completar la tarea devuelta o <see langword="TimeSpan.FromMilliseconds(-1)" /> para esperar indefinidamente.</param>
        <summary>Crea una tarea que se completa después de un intervalo de tiempo especificado.</summary>
        <returns>Una tarea que representa el retraso.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Después del retraso de tiempo especificado, se completa la tarea en <xref:System.Threading.Tasks.TaskStatus.RanToCompletion> estado.  
  
 Para escenarios de uso y ejemplos adicionales, consulte la documentación de la <xref:System.Threading.Tasks.Task.Delay%28System.Int32%29> de sobrecarga.  
  
 Este método depende del reloj del sistema. Esto significa que el tiempo de retardo aproximadamente será igual a la resolución del reloj del sistema si el `delay` argumento es menor que la resolución del reloj del sistema, que es aproximadamente 15 milisegundos en los sistemas Windows.  
  
   
  
## Examples  
 En el ejemplo siguiente se muestra un uso simple de la <xref:System.Threading.Tasks.Task.Delay%2A> método.  
  
 [!code-csharp[System.Threading.Tasks.Task.Delay#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.delay/cs/delay2.cs#2)]
 [!code-vb[System.Threading.Tasks.Task.Delay#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.delay/vb/delay2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="delay" /> representa un intervalo de tiempo negativo distinto de <see langword="TimeSpan.FromMillseconds(-1)" />.  -o bien- La propiedad <see cref="P:System.TimeSpan.TotalMilliseconds" /> del argumento <paramref name="delay" /> es mayor que <see cref="F:System.Int32.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Delay">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task Delay (int millisecondsDelay, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task Delay(int32 millisecondsDelay, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.Delay(System.Int32,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Tasks::Task ^ Delay(int millisecondsDelay, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="static member Delay : int * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task" Usage="System.Threading.Tasks.Task.Delay (millisecondsDelay, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="millisecondsDelay" Type="System.Int32" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="millisecondsDelay">El número de milisegundos que se esperará antes de completar la tarea devuelta o -1 para esperar indefinidamente.</param>
        <param name="cancellationToken">El token de cancelación que se comprobará antes de completar la tarea devuelta.</param>
        <summary>Crea una tarea cancelable que se completa después de un retraso.</summary>
        <returns>Una tarea que representa el retraso.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si el token de cancelación se señala antes el retraso de tiempo especificado, un <xref:System.Threading.Tasks.TaskCanceledException> resultados de la excepción y la tarea se completa en el <xref:System.Threading.Tasks.TaskStatus.Canceled> estado.  En caso contrario, se completa la tarea en el <xref:System.Threading.Tasks.TaskStatus.RanToCompletion> estado una vez que haya transcurrido el intervalo de tiempo especificado.  
  
 Para escenarios de uso y ejemplos adicionales, consulte la documentación de la <xref:System.Threading.Tasks.Task.Delay%28System.Int32%29> de sobrecarga.  
  
 Este método depende del reloj del sistema. Esto significa que el tiempo de retardo aproximadamente será igual a la resolución del reloj del sistema si el `millisecondsDelay` argumento es menor que la resolución del reloj del sistema, que es aproximadamente 15 milisegundos en los sistemas Windows.  
  
   
  
## Examples  
 El ejemplo siguiente inicia una tarea que incluye una llamada a la <xref:System.Threading.Tasks.Task.Delay%28System.Int32%2CSystem.Threading.CancellationToken%29> método con un un retraso segundo. Antes de que transcurra el intervalo de demora, se cancela el token. El resultado del ejemplo muestra que, como resultado, un <xref:System.Threading.Tasks.TaskCanceledException> se inicia y las tareas <xref:System.Threading.Tasks.Task.Status%2A> propiedad está establecida en <xref:System.Threading.Tasks.TaskStatus.Canceled>.  
  
 [!code-csharp[System.Threading.Tasks.Task.Delay#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.delay/cs/delay3.cs#3)]
 [!code-vb[System.Threading.Tasks.Task.Delay#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.delay/vb/delay3.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">El argumento <paramref name="millisecondsDelay" /> es menor que -1.</exception>
        <exception cref="T:System.Threading.Tasks.TaskCanceledException">Se ha cancelado la tarea.</exception>
        <exception cref="T:System.ObjectDisposedException">El <paramref name="cancellationToken" /> proporcionado ya se ha eliminado.</exception>
      </Docs>
    </Member>
    <Member MemberName="Delay">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task Delay (TimeSpan delay, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task Delay(valuetype System.TimeSpan delay, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.Delay(System.TimeSpan,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Tasks::Task ^ Delay(TimeSpan delay, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="static member Delay : TimeSpan * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task" Usage="System.Threading.Tasks.Task.Delay (delay, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="delay" Type="System.TimeSpan" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="delay">El intervalo de tiempo que espera antes de completar la tarea devuelta o <see langword="TimeSpan.FromMilliseconds(-1)" /> para esperar indefinidamente.</param>
        <param name="cancellationToken">El token de cancelación que se comprobará antes de completar la tarea devuelta.</param>
        <summary>Crea una tarea cancelable que se completa después de un intervalo de tiempo específico.</summary>
        <returns>Una tarea que representa el retraso.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si el token de cancelación se señala antes el retraso de tiempo especificado, un <xref:System.Threading.Tasks.TaskCanceledException> resultados de la excepción y la tarea se completa en el <xref:System.Threading.Tasks.TaskStatus.Canceled> estado.  En caso contrario, se completa la tarea en el <xref:System.Threading.Tasks.TaskStatus.RanToCompletion> estado una vez que haya transcurrido el intervalo de tiempo especificado.  
  
 Para escenarios de uso y ejemplos adicionales, consulte la documentación de la <xref:System.Threading.Tasks.Task.Delay%28System.Int32%29> de sobrecarga.  
  
 Este método depende del reloj del sistema. Esto significa que el tiempo de retardo aproximadamente será igual a la resolución del reloj del sistema si el `delay` argumento es menor que la resolución del reloj del sistema, que es aproximadamente 15 milisegundos en los sistemas Windows.  
  
   
  
## Examples  
 El ejemplo siguiente inicia una tarea que incluye una llamada a la <xref:System.Threading.Tasks.Task.Delay%28System.TimeSpan%2CSystem.Threading.CancellationToken%29> método con un retraso de segundo de uno y medio. Antes de que transcurra el intervalo de demora, se cancela el token. El resultado del ejemplo muestra que, como resultado, un <xref:System.Threading.Tasks.TaskCanceledException> se inicia y las tareas <xref:System.Threading.Tasks.Task.Status%2A> propiedad está establecida en <xref:System.Threading.Tasks.TaskStatus.Canceled>.  
  
 [!code-csharp[System.Threading.Tasks.Task.Delay#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.delay/cs/delay4.cs#4)]
 [!code-vb[System.Threading.Tasks.Task.Delay#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.delay/vb/delay4.vb#4)]  
  
 Tenga en cuenta que este ejemplo incluye una posible condición de carrera: depende de la tarea ejecutando el retraso de forma asincrónica cuando se cancela el token. Aunque el segundo 1,5 retraso de la llamada a la <xref:System.Threading.Tasks.Task.Delay%28System.TimeSpan%2CSystem.Threading.CancellationToken%29> método realiza esa suposición probable, sin embargo, es posible que la llamada a la <xref:System.Threading.Tasks.Task.Delay%28System.TimeSpan%2CSystem.Threading.CancellationToken%29> método podría devolver antes de que se cancela el token. En ese caso, el ejemplo produce el siguiente resultado:  
  
```  
Task t Status: RanToCompletion, Result: 42  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="delay" /> representa un intervalo de tiempo negativo distinto de <see langword="TimeSpan.FromMillseconds(-1)" />.  -o bien- La propiedad <see cref="P:System.TimeSpan.TotalMilliseconds" /> del argumento <paramref name="delay" /> es mayor que <see cref="F:System.Int32.MaxValue" />.</exception>
        <exception cref="T:System.Threading.Tasks.TaskCanceledException">Se ha cancelado la tarea.</exception>
        <exception cref="T:System.ObjectDisposedException">El <paramref name="cancellationToken" /> proporcionado ya se ha eliminado.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Dispose">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Libera todos los recursos usados por la instancia actual de la clase <see cref="T:System.Threading.Tasks.Task" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberSignature Language="F#" Value="abstract member Dispose : unit -&gt; unit&#xA;override this.Dispose : unit -&gt; unit" Usage="task.Dispose " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Libera todos los recursos usados por la instancia actual de la clase <see cref="T:System.Threading.Tasks.Task" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Threading.Tasks.Task> la clase implementa la <xref:System.IDisposable> porque internamente utiliza recursos que también implementan la interfaz <xref:System.IDisposable>. Sin embargo, especialmente si la aplicación tiene como destino el [!INCLUDE[net_v45](~/includes/net-v45-md.md)] o una versión posterior, no es necesario llamar a <xref:System.Threading.Tasks.Task.Dispose%2A> a menos que el rendimiento o las pruebas de escalabilidad indican que, según los patrones de uso, rendimiento de la aplicación podría mejorarse eliminando de tareas. Para obtener más información, consulte [es necesario disponer de tareas?](http://blogs.msdn.com/b/pfxteam/archive/2012/03/25/10287435.aspx) en la programación en paralelo con .NET blog.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">La tarea no está en uno de los estados finales: <see cref="F:System.Threading.Tasks.TaskStatus.RanToCompletion" />, <see cref="F:System.Threading.Tasks.TaskStatus.Faulted" /> o <see cref="F:System.Threading.Tasks.TaskStatus.Canceled" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected virtual void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void Dispose(bool disposing);" />
      <MemberSignature Language="F#" Value="abstract member Dispose : bool -&gt; unit&#xA;override this.Dispose : bool -&gt; unit" Usage="task.Dispose disposing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">Valor booleano que indica si se llama a este método debido a una llamada a <see cref="M:System.Threading.Tasks.Task.Dispose" />.</param>
        <summary>Desecha el objeto <see cref="T:System.Threading.Tasks.Task" /> y libera todos sus recursos no administrados.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Threading.Tasks.Task> la clase implementa la <xref:System.IDisposable> porque internamente utiliza recursos que también implementan la interfaz <xref:System.IDisposable>. Sin embargo, especialmente si la aplicación tiene como destino el [!INCLUDE[net_v45](~/includes/net-v45-md.md)] o una versión posterior, no es necesario llamar a <xref:System.Threading.Tasks.Task.Dispose%2A> a menos que el rendimiento o las pruebas de escalabilidad indican que, según los patrones de uso, rendimiento de la aplicación podría mejorarse eliminando de tareas. Para obtener más información, consulte [es necesario disponer de tareas?](http://blogs.msdn.com/b/pfxteam/archive/2012/03/25/10287435.aspx) en la programación en paralelo con .NET blog.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">La tarea no está en uno de los estados finales: <see cref="F:System.Threading.Tasks.TaskStatus.RanToCompletion" />, <see cref="F:System.Threading.Tasks.TaskStatus.Faulted" /> o <see cref="F:System.Threading.Tasks.TaskStatus.Canceled" />.</exception>
        <threadsafe>A diferencia de la mayoría de los miembros de la <see cref="T:System.Threading.Tasks.Task" /> (clase), este método no es seguro para subprocesos.</threadsafe>
      </Docs>
    </Member>
    <Member MemberName="Exception">
      <MemberSignature Language="C#" Value="public AggregateException Exception { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.AggregateException Exception" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.Task.Exception" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Exception As AggregateException" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property AggregateException ^ Exception { AggregateException ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Exception : AggregateException" Usage="System.Threading.Tasks.Task.Exception" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.AggregateException</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene la excepción <see cref="T:System.AggregateException" /> que causó la finalización prematura del objeto <see cref="T:System.Threading.Tasks.Task" />. Si <see cref="T:System.Threading.Tasks.Task" /> se completó correctamente o no ha iniciado ninguna excepción, el valor devuelto será <see langword="null" />.</summary>
        <value>Excepción <see cref="T:System.AggregateException" /> que causó la finalización prematura del objeto <see cref="T:System.Threading.Tasks.Task" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Las tareas que producen excepciones no controladas almacenan la excepción resultante y propagan incluida en una <xref:System.AggregateException> en las llamadas a <xref:System.Threading.Tasks.Task.Wait%2A> o en accesos a la <xref:System.Threading.Tasks.Task.Exception%2A> propiedad. Las excepciones no detecta la instancia de tarea sean recolección se propagará en el subproceso finalizador. Para obtener más información y un ejemplo, vea [control de excepciones (Task Parallel Library)](~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Factory">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.TaskFactory Factory { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Threading.Tasks.TaskFactory Factory" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.Task.Factory" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property Factory As TaskFactory" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Threading::Tasks::TaskFactory ^ Factory { System::Threading::Tasks::TaskFactory ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Factory : System.Threading.Tasks.TaskFactory" Usage="System.Threading.Tasks.Task.Factory" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.TaskFactory</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Proporciona acceso a patrones de diseño para crear y configurar instancias de <see cref="T:System.Threading.Tasks.Task" /> y <see cref="T:System.Threading.Tasks.Task`1" />.</summary>
        <value>Un objeto de fábrica que puede crear una variedad de objetos <see cref="T:System.Threading.Tasks.Task" /> y <see cref="T:System.Threading.Tasks.Task`1" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esta propiedad devuelve una instancia predeterminada de la <xref:System.Threading.Tasks.TaskFactory> que es idéntica a la que se creó mediante una llamada sin parámetros <xref:System.Threading.Tasks.TaskFactory.%23ctor?displayProperty=nameWithType> constructor. Tiene los siguientes valores de propiedad:  
  
|Propiedad.|Valor|  
|--------------|-----------|  
|<xref:System.Threading.Tasks.TaskFactory.CancellationToken%2A?displayProperty=nameWithType>|<xref:System.Threading.CancellationToken.None%2A?displayProperty=nameWithType>|  
|<xref:System.Threading.Tasks.TaskFactory.ContinuationOptions%2A?displayProperty=nameWithType>|<xref:System.Threading.Tasks.TaskContinuationOptions.None?displayProperty=nameWithType>|  
|<xref:System.Threading.Tasks.TaskFactory.CreationOptions%2A?displayProperty=nameWithType>|<xref:System.Threading.Tasks.TaskCreationOptions.None?displayProperty=nameWithType>|  
|<xref:System.Threading.Tasks.TaskFactory.Scheduler%2A?displayProperty=nameWithType>|`null`, o <xref:System.Threading.Tasks.TaskScheduler.Current%2A?displayProperty=nameWithType>|  
  
 El uso más común de esta propiedad es crear e iniciar una nueva tarea en una sola llamada a la <xref:System.Threading.Tasks.TaskFactory.StartNew%2A?displayProperty=nameWithType> método.  
  
> [!NOTE]
>  A partir de la [!INCLUDE[net_v45](~/includes/net-v45-md.md)], <xref:System.Threading.Tasks.Task.Run%2A?displayProperty=nameWithType> método proporciona la manera más fácil de crear un <xref:System.Threading.Tasks.Task> objeto con valores de configuración predeterminados.  
  
 En el ejemplo siguiente se utiliza el método estático <xref:System.Threading.Tasks.Task.Factory%2A> propiedad realizar dos llamadas a la <xref:System.Threading.Tasks.TaskFactory.StartNew%2A?displayProperty=nameWithType> método. La primera rellena una matriz con los nombres de los archivos del directorio Mis documentos del usuario, mientras que el segundo rellena una matriz con los nombres de los subdirectorios del directorio de Mis documentos del usuario. A continuación, llama el <xref:System.Threading.Tasks.TaskFactory.ContinueWhenAll%28System.Threading.Tasks.Task%5B%5D%2CSystem.Action%7BSystem.Threading.Tasks.Task%5B%5D%7D%29?displayProperty=nameWithType> método, que muestra información sobre el número de archivos y directorios en las dos matrices después de las dos primeras tareas hayan terminado de ejecutarse.  
  
 [!code-csharp[System.Threading.Tasks.Task.Factory#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.factory/cs/factory1.cs#1)]
 [!code-vb[System.Threading.Tasks.Task.Factory#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.factory/vb/factory1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Threading.Tasks.TaskFactory" />
      </Docs>
    </Member>
    <Member MemberName="FromCanceled">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task FromCanceled (System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task FromCanceled(valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.FromCanceled(System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Tasks::Task ^ FromCanceled(System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="static member FromCanceled : System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task" Usage="System.Threading.Tasks.Task.FromCanceled cancellationToken" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="cancellationToken">Token de cancelación con el que se finaliza la tarea.</param>
        <summary>Crea una <see cref="T:System.Threading.Tasks.Task" /> que se finaliza debido a la cancelación con un token de cancelación especificado.</summary>
        <returns>Tarea cancelada.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">No se solicitó la cancelación de <paramref name="cancellationToken" />; su propiedad <see cref="P:System.Threading.CancellationToken.IsCancellationRequested" /> es <see langword="false" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="FromCanceled&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task&lt;TResult&gt; FromCanceled&lt;TResult&gt; (System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task`1&lt;!!TResult&gt; FromCanceled&lt;TResult&gt;(valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.FromCanceled``1(System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; static System::Threading::Tasks::Task&lt;TResult&gt; ^ FromCanceled(System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="static member FromCanceled : System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="System.Threading.Tasks.Task.FromCanceled cancellationToken" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">Tipo de resultado devuelto por la tarea.</typeparam>
        <param name="cancellationToken">Token de cancelación con el que se finaliza la tarea.</param>
        <summary>Crea una <see cref="T:System.Threading.Tasks.Task`1" /> que se finaliza debido a la cancelación con un token de cancelación especificado.</summary>
        <returns>Tarea cancelada.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">No se solicitó la cancelación de <paramref name="cancellationToken" />; su propiedad <see cref="P:System.Threading.CancellationToken.IsCancellationRequested" /> es <see langword="false" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="FromException">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task FromException (Exception exception);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task FromException(class System.Exception exception) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.FromException(System.Exception)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Tasks::Task ^ FromException(Exception ^ exception);" />
      <MemberSignature Language="F#" Value="static member FromException : Exception -&gt; System.Threading.Tasks.Task" Usage="System.Threading.Tasks.Task.FromException exception" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="exception" Type="System.Exception" />
      </Parameters>
      <Docs>
        <param name="exception">Excepción con la que se finaliza la tarea.</param>
        <summary>Crea una <see cref="T:System.Threading.Tasks.Task" /> que finalizó con una excepción especificada.</summary>
        <returns>Tarea con error.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método crea un <xref:System.Threading.Tasks.Task> cuyos <xref:System.Threading.Tasks.Task.Status%2A> propiedad es <xref:System.Threading.Tasks.TaskStatus.Faulted> y cuyo <xref:System.Threading.Tasks.Task.Exception%2A> propiedad contiene `exception`. El método suele utilizarse cuando sabrá inmediatamente que el trabajo que realiza una tarea iniciará una excepción antes de ejecutar una ruta de acceso de código más. Para obtener un ejemplo, vea el <xref:System.Threading.Tasks.Task.FromException%60%601%28System.Exception%29> sobrecarga.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FromException&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task&lt;TResult&gt; FromException&lt;TResult&gt; (Exception exception);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task`1&lt;!!TResult&gt; FromException&lt;TResult&gt;(class System.Exception exception) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.FromException``1(System.Exception)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; static System::Threading::Tasks::Task&lt;TResult&gt; ^ FromException(Exception ^ exception);" />
      <MemberSignature Language="F#" Value="static member FromException : Exception -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="System.Threading.Tasks.Task.FromException exception" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="exception" Type="System.Exception" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">Tipo de resultado devuelto por la tarea.</typeparam>
        <param name="exception">Excepción con la que se finaliza la tarea.</param>
        <summary>Crea una <see cref="T:System.Threading.Tasks.Task`1" /> que finalizó con una excepción especificada.</summary>
        <returns>Tarea con error.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método crea un <xref:System.Threading.Tasks.Task%601> cuyos <xref:System.Threading.Tasks.Task.Status%2A> propiedad es <xref:System.Threading.Tasks.TaskStatus.Faulted> y cuyo <xref:System.Threading.Tasks.Task.Exception%2A> propiedad contiene `exception`. El método suele utilizarse cuando sabrá inmediatamente que el trabajo que realiza una tarea iniciará una excepción antes de ejecutar una ruta de acceso de código más. En este ejemplo se ilustra.  
  
   
  
## Examples  
 El ejemplo siguiente es una utilidad de línea de comandos que calcula el número de bytes de los archivos en cada directorio cuyo nombre se pasa como un argumento de línea de comandos. En lugar de ejecutar una ruta de acceso más larga de código que crea una instancia de un <xref:System.IO.FileInfo> objeto y recupera el valor de su <xref:System.IO.FileInfo.Length%2A?displayProperty=nameWithType> propiedad para cada archivo en el directorio, en el ejemplo se llama simplemente la <xref:System.Threading.Tasks.Task.FromException%60%601%28System.Exception%29> método para crear una tarea con errores si un determinado subdirectorio no existe.  
  
 [!code-csharp[System.Threading.Tasks.Task.FromResult#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.fromresult/cs/fromresult1.cs#1)]
 [!code-vb[System.Threading.Tasks.Task.FromResult#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.fromresult/vb/fromresult1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FromResult&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task&lt;TResult&gt; FromResult&lt;TResult&gt; (TResult result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task`1&lt;!!TResult&gt; FromResult&lt;TResult&gt;(!!TResult result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.FromResult``1(``0)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FromResult(Of TResult) (result As TResult) As Task(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; static System::Threading::Tasks::Task&lt;TResult&gt; ^ FromResult(TResult result);" />
      <MemberSignature Language="F#" Value="static member FromResult : 'Result -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="System.Threading.Tasks.Task.FromResult result" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="result" Type="TResult" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">Tipo de resultado devuelto por la tarea.</typeparam>
        <param name="result">El resultado que se va a almacenar en la tarea completada.</param>
        <summary>Crea un objeto <see cref="T:System.Threading.Tasks.Task`1" /> que se ha completado correctamente con el resultado especificado.</summary>
        <returns>La tarea terminó correctamente.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método crea un <xref:System.Threading.Tasks.Task%601> cuyos <xref:System.Threading.Tasks.Task%601.Result%2A?displayProperty=nameWithType> propiedad es `result` y cuyo <xref:System.Threading.Tasks.Task.Status%2A> propiedad es <xref:System.Threading.Tasks.TaskStatus.RanToCompletion>. El método se utiliza normalmente cuando el valor devuelto de una tarea se conoce inmediatamente sin ejecutar una ruta de acceso de código más. En este ejemplo se ilustra.  
  
 Para crear un objeto de tarea que no devuelve un valor, recupere el objeto de tarea de la <xref:System.Threading.Tasks.Task.CompletedTask%2A> propiedad.  
  
   
  
## Examples  
 El ejemplo siguiente es una utilidad de línea de comandos que calcula el número de bytes de los archivos en cada directorio cuyo nombre se pasa como un argumento de línea de comandos. En lugar de ejecutar una ruta de acceso más larga de código que crea una instancia de un <xref:System.IO.FileStream> objeto y recupera el valor de su <xref:System.IO.FileStream.Length%2A?displayProperty=nameWithType> propiedad para cada archivo en el directorio, en el ejemplo se llama simplemente la <xref:System.Threading.Tasks.Task.FromResult%2A> método para crear una tarea cuya <xref:System.Threading.Tasks.Task%601.Result%2A?displayProperty=nameWithType> propiedad es cero (0) si un directorio no tiene archivos.  
  
 [!code-csharp[System.Threading.Tasks.Task.FromResult#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.fromresult/cs/fromresult1.cs#1)]
 [!code-vb[System.Threading.Tasks.Task.FromResult#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.fromresult/vb/fromresult1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Threading.Tasks.Task.CompletedTask" />
      </Docs>
    </Member>
    <Member MemberName="GetAwaiter">
      <MemberSignature Language="C#" Value="public System.Runtime.CompilerServices.TaskAwaiter GetAwaiter ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Runtime.CompilerServices.TaskAwaiter GetAwaiter() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.GetAwaiter" />
      <MemberSignature Language="VB.NET" Value="Public Function GetAwaiter () As TaskAwaiter" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Runtime::CompilerServices::TaskAwaiter GetAwaiter();" />
      <MemberSignature Language="F#" Value="member this.GetAwaiter : unit -&gt; System.Runtime.CompilerServices.TaskAwaiter" Usage="task.GetAwaiter " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.CompilerServices.TaskAwaiter</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Obtiene un awaiter utilizado para esperar este objeto <see cref="T:System.Threading.Tasks.Task" />.</summary>
        <returns>Una instancia de awaiter.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método está pensado para uso del compilador en lugar de para su uso en código de la aplicación.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Id">
      <MemberSignature Language="C#" Value="public int Id { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Id" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.Task.Id" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Id As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Id { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Id : int" Usage="System.Threading.Tasks.Task.Id" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene un identificador para esta instancia de <see cref="T:System.Threading.Tasks.Task" />.</summary>
        <value>Identificador asignado por el sistema a esta instancia de <see cref="T:System.Threading.Tasks.Task" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Identificadores de tarea se asignan a petición y no representa necesariamente el orden en la tarea que se crean instancias. Tenga en cuenta que aunque las colisiones son muy raras, identificadores de tarea no se garantiza que sea único.  
  
 Para obtener el Id. de tarea de la tarea actualmente en ejecución desde dentro del código que la tarea se está ejecutando, use la <xref:System.Threading.Tasks.Task.CurrentId%2A> propiedad.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Threading.Tasks.Task.CurrentId" />
      </Docs>
    </Member>
    <Member MemberName="IsCanceled">
      <MemberSignature Language="C#" Value="public bool IsCanceled { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsCanceled" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.Task.IsCanceled" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsCanceled As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsCanceled { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsCanceled : bool" Usage="System.Threading.Tasks.Task.IsCanceled" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene un valor que indica si esta instancia de <see cref="T:System.Threading.Tasks.Task" /> ha dejado de ejecutarse debido a una cancelación.</summary>
        <value>Es <see langword="true" /> si la tarea se ha completado debido a su cancelación; de lo contrario, es <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A <xref:System.Threading.Tasks.Task> llevará a cabo en el <xref:System.Threading.Tasks.TaskStatus.Canceled> estado en cualquiera de las condiciones siguientes:  
  
-   Su <xref:System.Threading.Tasks.TaskFactory.CancellationToken%2A> se marcó para cancelación antes de que la tarea empezara a ejecutarse,  
  
-   La tarea confirmó la solicitud de cancelación en sus ya señalado <xref:System.Threading.Tasks.TaskFactory.CancellationToken%2A> iniciando una <xref:System.OperationCanceledException> que lleva el mismo <xref:System.Threading.CancellationToken>.  
  
-   La tarea confirmó la solicitud de cancelación en sus ya señalado <xref:System.Threading.Tasks.TaskFactory.CancellationToken%2A> mediante una llamada a la <xref:System.Threading.CancellationToken.ThrowIfCancellationRequested%2A> método en el <xref:System.Threading.CancellationToken>.  
  
> [!IMPORTANT]
>  Recuperación del valor de la <xref:System.Threading.Tasks.Task.IsCanceled%2A> propiedad no bloquea el subproceso que realiza la llamada hasta que la tarea se ha completado.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsCompleted">
      <MemberSignature Language="C#" Value="public bool IsCompleted { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsCompleted" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.Task.IsCompleted" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsCompleted As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsCompleted { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsCompleted : bool" Usage="System.Threading.Tasks.Task.IsCompleted" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.IAsyncResult.IsCompleted</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene un valor que indica si se ha completado esta instancia de <see cref="T:System.Threading.Tasks.Task" />.</summary>
        <value>Es <see langword="true" /> si la tarea se ha completado; de lo contrario, es <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Tasks.Task.IsCompleted%2A> devolverá `true` cuando la tarea está en uno de los tres estados finales: <xref:System.Threading.Tasks.TaskStatus.RanToCompletion>, <xref:System.Threading.Tasks.TaskStatus.Faulted>, o <xref:System.Threading.Tasks.TaskStatus.Canceled>.  
  
> [!IMPORTANT]
>  Recuperación del valor de la <xref:System.Threading.Tasks.Task.IsCompleted%2A?displayProperty=nameWithType> propiedad no bloquea el subproceso que realiza la llamada hasta que la tarea se ha completado.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsCompletedSuccessfully">
      <MemberSignature Language="C#" Value="public bool IsCompletedSuccessfully { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsCompletedSuccessfully" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.Task.IsCompletedSuccessfully" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsCompletedSuccessfully As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsCompletedSuccessfully { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsCompletedSuccessfully : bool" Usage="System.Threading.Tasks.Task.IsCompletedSuccessfully" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsFaulted">
      <MemberSignature Language="C#" Value="public bool IsFaulted { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsFaulted" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.Task.IsFaulted" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsFaulted As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsFaulted { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsFaulted : bool" Usage="System.Threading.Tasks.Task.IsFaulted" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene un valor que indica si el objeto <see cref="T:System.Threading.Tasks.Task" /> se ha completado debido a una excepción no controlada.</summary>
        <value>Es <see langword="true" /> si la tarea ha producido una excepción no controlada; de lo contrario, es <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si <xref:System.Threading.Tasks.Task.IsFaulted%2A> es `true`, la tarea <xref:System.Threading.Tasks.Task.Status%2A> es igual a <xref:System.Threading.Tasks.TaskStatus.Faulted>y su <xref:System.Threading.Tasks.Task.Exception%2A> propiedad será distinto de null.  
  
> [!IMPORTANT]
>  Recuperación del valor de la <xref:System.Threading.Tasks.Task.IsFaulted%2A?displayProperty=nameWithType> propiedad no bloquea el subproceso que realiza la llamada hasta que la tarea se ha completado.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Run">
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Pone en cola el trabajo especificado para ejecutarlo en ThreadPool y devuelve una tarea o controlador <see cref="T:System.Threading.Tasks.Task`1" /> para dicho trabajo.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Threading.Tasks.Task.Run%2A> método proporciona un conjunto de sobrecargas que facilitan la tarea iniciar una tarea mediante el uso de valores predeterminados. Es una alternativa ligera a la <xref:System.Threading.Tasks.TaskFactory.StartNew%2A> sobrecargas.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Run">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task Run (Action action);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task Run(class System.Action action) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.Run(System.Action)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Tasks::Task ^ Run(Action ^ action);" />
      <MemberSignature Language="F#" Value="static member Run : Action -&gt; System.Threading.Tasks.Task" Usage="System.Threading.Tasks.Task.Run action" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="action" Type="System.Action" />
      </Parameters>
      <Docs>
        <param name="action">Trabajo que se va a ejecutar de forma asincrónica.</param>
        <summary>Pone en cola el trabajo especificado para ejecutarlo en el grupo de subprocesos y devuelve un objeto <see cref="T:System.Threading.Tasks.Task" /> que representa ese trabajo.</summary>
        <returns>Una tarea que representa el trabajo en cola para ejecutarse en ThreadPool.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Threading.Tasks.Task.Run%2A> método le permite crear y ejecutar una tarea en una única llamada al método y es una alternativa más sencilla a la <xref:System.Threading.Tasks.TaskFactory.StartNew%2A> método. Crea una tarea con los valores predeterminados siguientes:  
  
-   Su token de cancelación es <xref:System.Threading.CancellationToken.None%2A?displayProperty=nameWithType>.  
  
-   Su <xref:System.Threading.Tasks.Task.CreationOptions%2A> es el valor de la propiedad <xref:System.Threading.Tasks.TaskCreationOptions.DenyChildAttach?displayProperty=nameWithType>.  
  
-   Usa al programador de tareas de forma predeterminada.  
  
 Para obtener información sobre cómo controlar las excepciones producidas por las operaciones de tareas, consulte [Exception Handling](~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md).  
  
   
  
## Examples  
 En el ejemplo siguiente se define un `ShowThreadInfo` método que muestra la <xref:System.Threading.Thread.ManagedThreadId%2A?displayProperty=nameWithType> del subproceso actual. Se denomina directamente desde el subproceso de la aplicación y se llama desde el <xref:System.Action> delegado pasado a la <xref:System.Threading.Tasks.Task.Run%28System.Action%29> método.  
  
 [!code-csharp[System.Threading.Tasks.Task.Run#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.run/cs/Run11.cs#11)]
 [!code-vb[System.Threading.Tasks.Task.Run#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.run/vb/Run11.vb#11)]  
  
 En el ejemplo siguiente es similar al anterior, salvo que usa una expresión lambda para definir el código ejecutar la tarea.  
  
 [!code-csharp[System.Threading.Tasks.Task.Run#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.run/cs/run6.cs#3)]
 [!code-vb[System.Threading.Tasks.Task.Run#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.run/vb/run6.vb#3)]  
  
 Los ejemplos muestran que la tarea asincrónica se ejecuta en un subproceso distinto al subproceso de aplicación principal.  
  
 La llamada a la <xref:System.Threading.Tasks.Task.Wait%2A> método garantiza que la tarea se completa y muestra su salida antes de que la aplicación finalice. En caso contrario, es posible que el `Main` método se completará antes de que finalice la tarea.  
  
 En el ejemplo siguiente se muestra el <xref:System.Threading.Tasks.Task.Run%28System.Action%29> método. Define una matriz de nombres de directorio y se inicia una tarea independiente para recuperar los nombres de archivo en cada directorio. Todas las tareas de escriban los nombres de archivo en una sola <xref:System.Collections.Concurrent.ConcurrentBag%601> objeto. El ejemplo, a continuación, se llama la <xref:System.Threading.Tasks.Task.WaitAll%28System.Threading.Tasks.Task%5B%5D%29> método para asegurarse de que ha completado todas las tareas y, a continuación, muestra un recuento del número total de nombres de archivo que se escriben en el <xref:System.Collections.Concurrent.ConcurrentBag%601> objeto.  
  
 [!code-csharp[System.Threading.Tasks.Task.Run#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.run/cs/run2.cs#1)]
 [!code-vb[System.Threading.Tasks.Task.Run#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.run/vb/run2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El valor del parámetro <paramref name="action" /> es <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Run">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task Run (Func&lt;System.Threading.Tasks.Task&gt; function);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task Run(class System.Func`1&lt;class System.Threading.Tasks.Task&gt; function) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.Run(System.Func{System.Threading.Tasks.Task})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Run (function As Func(Of Task)) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Tasks::Task ^ Run(Func&lt;System::Threading::Tasks::Task ^&gt; ^ function);" />
      <MemberSignature Language="F#" Value="static member Run : Func&lt;System.Threading.Tasks.Task&gt; -&gt; System.Threading.Tasks.Task" Usage="System.Threading.Tasks.Task.Run function" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="function" Type="System.Func&lt;System.Threading.Tasks.Task&gt;" />
      </Parameters>
      <Docs>
        <param name="function">Trabajo que se va a ejecutar de forma asincrónica.</param>
        <summary>Pone en cola el trabajo especificado para ejecutarlo en el grupo de subprocesos y devuelve un proxy para la tarea devuelta por <paramref name="function" />.</summary>
        <returns>Una tarea que representa un proxy para la tarea devuelta por <paramref name="function" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para obtener información sobre cómo controlar las excepciones producidas por las operaciones de tareas, consulte [Exception Handling](~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El valor del parámetro <paramref name="function" /> es <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Run">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task Run (Action action, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task Run(class System.Action action, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.Run(System.Action,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Tasks::Task ^ Run(Action ^ action, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="static member Run : Action * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task" Usage="System.Threading.Tasks.Task.Run (action, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="action" Type="System.Action" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="action">Trabajo que se va a ejecutar de forma asincrónica.</param>
        <param name="cancellationToken">Token de cancelación que puede usarse para cancelar el trabajo.</param>
        <summary>Pone en cola el trabajo especificado para ejecutarlo en el grupo de subprocesos y devuelve un objeto <see cref="T:System.Threading.Tasks.Task" /> que representa ese trabajo. Un token de cancelación permite cancelar el trabajo.</summary>
        <returns>Tarea que representa el trabajo en cola que se va a ejecutar en el grupo de subprocesos.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si se solicita la cancelación antes de que la tarea comienza a ejecutarse, la tarea no se ejecuta. En su lugar, se establece en el <xref:System.Threading.Tasks.TaskStatus.Canceled> estado e inicia un <xref:System.Threading.Tasks.TaskCanceledException> excepción.  
  
 El <xref:System.Threading.Tasks.Task.Run%28System.Action%2CSystem.Threading.CancellationToken%29> método es una alternativa más sencilla a la <xref:System.Threading.Tasks.TaskFactory.StartNew%28System.Action%2CSystem.Threading.CancellationToken%29?displayProperty=nameWithType> método. Crea una tarea con los valores predeterminados siguientes:  
  
-   Su <xref:System.Threading.Tasks.Task.CreationOptions%2A> es el valor de la propiedad <xref:System.Threading.Tasks.TaskCreationOptions.DenyChildAttach?displayProperty=nameWithType>.  
  
-   Usa al programador de tareas de forma predeterminada.  
  
 Para obtener información sobre cómo controlar las excepciones producidas por las operaciones de tareas, consulte [Exception Handling](~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md).  
  
   
  
## Examples  
 El ejemplo siguiente se llama el <xref:System.Threading.Tasks.Task.Run%28System.Action%2CSystem.Threading.CancellationToken%29> método para crear una tarea que recorre en iteración los archivos en el directorio C:\Windows\System32. La expresión lambda llama el <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> método para agregar información sobre todos los archivos en un <xref:System.Collections.Generic.List%601> objeto. Cada tarea anidada invocado por desasociada el <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> bucle comprueba el estado del token de cancelación y, si se solicita la cancelación, llama a la <xref:System.Threading.CancellationToken.ThrowIfCancellationRequested%2A?displayProperty=nameWithType> método. El <xref:System.Threading.CancellationToken.ThrowIfCancellationRequested%2A?displayProperty=nameWithType> método inicie una excepción un <xref:System.OperationCanceledException> excepción que se controla en un `catch` bloquear cuando el subproceso que realiza la llamada llama la <xref:System.Threading.Tasks.Task.Wait%2A?displayProperty=nameWithType> método.  
  
 [!code-csharp[System.Threading.Tasks.Task.Run#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.run/cs/run4.cs#4)]
 [!code-vb[System.Threading.Tasks.Task.Run#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.run/vb/run4.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El valor del parámetro <paramref name="action" /> es <see langword="null" />.</exception>
        <exception cref="T:System.Threading.Tasks.TaskCanceledException">La tarea se canceló.</exception>
        <exception cref="T:System.ObjectDisposedException">El <see cref="T:System.Threading.CancellationTokenSource" /> asociado a <paramref name="cancellationToken" /> se desechó.</exception>
      </Docs>
    </Member>
    <Member MemberName="Run">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task Run (Func&lt;System.Threading.Tasks.Task&gt; function, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task Run(class System.Func`1&lt;class System.Threading.Tasks.Task&gt; function, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.Run(System.Func{System.Threading.Tasks.Task},System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Tasks::Task ^ Run(Func&lt;System::Threading::Tasks::Task ^&gt; ^ function, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="static member Run : Func&lt;System.Threading.Tasks.Task&gt; * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task" Usage="System.Threading.Tasks.Task.Run (function, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="function" Type="System.Func&lt;System.Threading.Tasks.Task&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="function">El trabajo que se ejecutará de forma asincrónica.</param>
        <param name="cancellationToken">Un token de cancelación que debería usarse para cancelar el trabajo.</param>
        <summary>Pone en cola el trabajo especificado para ejecutarlo en el grupo de subprocesos y devuelve un proxy para la tarea devuelta por <paramref name="function" />.</summary>
        <returns>Una tarea que representa un proxy para la tarea devuelta por <paramref name="function" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para obtener información sobre cómo controlar las excepciones producidas por las operaciones de tareas, consulte [Exception Handling](~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El valor del parámetro <paramref name="function" /> es <see langword="null" />.</exception>
        <exception cref="T:System.Threading.Tasks.TaskCanceledException">La tarea se canceló.</exception>
        <exception cref="T:System.ObjectDisposedException">El <see cref="T:System.Threading.CancellationTokenSource" /> asociado a <paramref name="cancellationToken" /> se desechó.</exception>
      </Docs>
    </Member>
    <Member MemberName="Run&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task&lt;TResult&gt; Run&lt;TResult&gt; (Func&lt;System.Threading.Tasks.Task&lt;TResult&gt;&gt; function);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task`1&lt;!!TResult&gt; Run&lt;TResult&gt;(class System.Func`1&lt;class System.Threading.Tasks.Task`1&lt;!!TResult&gt;&gt; function) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.Run``1(System.Func{System.Threading.Tasks.Task{``0}})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Run(Of TResult) (function As Func(Of Task(Of TResult))) As Task(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; static System::Threading::Tasks::Task&lt;TResult&gt; ^ Run(Func&lt;System::Threading::Tasks::Task&lt;TResult&gt; ^&gt; ^ function);" />
      <MemberSignature Language="F#" Value="static member Run : Func&lt;System.Threading.Tasks.Task&lt;'Result&gt;&gt; -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="System.Threading.Tasks.Task.Run function" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="function" Type="System.Func&lt;System.Threading.Tasks.Task&lt;TResult&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">Tipo de resultado devuelto por la tarea del proxy.</typeparam>
        <param name="function">Trabajo que se va a ejecutar de forma asincrónica.</param>
        <summary>Pone en cola el trabajo especificado para ejecutarlo en el grupo de subprocesos y devuelve un proxy para <see langword="Task(TResult)" /> que devuelve <paramref name="function" />.</summary>
        <returns>Una <see langword="Task(TResult)" /> que representa un proxy para <see langword="Task(TResult)" /> devuelta por <paramref name="function" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para obtener información sobre cómo controlar las excepciones producidas por las operaciones de tareas, consulte [Exception Handling](~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El valor del parámetro <paramref name="function" /> es <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Run&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task&lt;TResult&gt; Run&lt;TResult&gt; (Func&lt;TResult&gt; function);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task`1&lt;!!TResult&gt; Run&lt;TResult&gt;(class System.Func`1&lt;!!TResult&gt; function) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.Run``1(System.Func{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Run(Of TResult) (function As Func(Of TResult)) As Task(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; static System::Threading::Tasks::Task&lt;TResult&gt; ^ Run(Func&lt;TResult&gt; ^ function);" />
      <MemberSignature Language="F#" Value="static member Run : Func&lt;'Result&gt; -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="System.Threading.Tasks.Task.Run function" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="function" Type="System.Func&lt;TResult&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">El tipo devuelto de la tarea.</typeparam>
        <param name="function">El trabajo que se ejecutará de forma asincrónica.</param>
        <summary>Pone en cola el trabajo especificado para ejecutarlo en el grupo de subprocesos y devuelve un objeto <see cref="T:System.Threading.Tasks.Task`1" /> que representa ese trabajo.</summary>
        <returns>Un objeto de tarea que representa el trabajo en cola para ejecutarse en el grupo de subprocesos.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Threading.Tasks.Task.Run%2A> método es una alternativa más sencilla a la <xref:System.Threading.Tasks.TaskFactory.StartNew%28System.Action%29?displayProperty=nameWithType> método. Crea una tarea con los valores predeterminados siguientes:  
  
-   Su token de cancelación es <xref:System.Threading.CancellationToken.None%2A?displayProperty=nameWithType>.  
  
-   Su <xref:System.Threading.Tasks.Task.CreationOptions%2A> es el valor de la propiedad <xref:System.Threading.Tasks.TaskCreationOptions.DenyChildAttach?displayProperty=nameWithType>.  
  
-   Usa al programador de tareas de forma predeterminada.  
  
 Para obtener información sobre cómo controlar las excepciones producidas por las operaciones de tareas, consulte [Exception Handling](~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md).  
  
   
  
## Examples  
 El ejemplo siguiente cuenta el número aproximado de palabras en los archivos de texto que representan libros publicados. Cada tarea es responsable de abrir un archivo, leer todo su contenido de forma asincrónica y calcular el recuento de palabras, mediante una expresión regular. El <xref:System.Threading.Tasks.Task.WaitAll%28System.Threading.Tasks.Task%5B%5D%29> método se llama para asegurarse de que todas las tareas se han completado antes de mostrar el número de palabras de cada libro en la consola.  
  
 [!code-csharp[System.Threading.Tasks.Task.Run#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.run/cs/run3.cs#2)]
 [!code-vb[System.Threading.Tasks.Task.Run#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.run/vb/run3.vb#2)]  
  
 La expresión regular `\p{P}*\s+` coincide con cero, uno o más caracteres de puntuación, seguidos de uno o más caracteres de espacio en blanco. Se supone que el número total de coincidencias es igual que el recuento de palabras aproximado.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El valor del parámetro <paramref name="function" /> es <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Run&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task&lt;TResult&gt; Run&lt;TResult&gt; (Func&lt;System.Threading.Tasks.Task&lt;TResult&gt;&gt; function, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task`1&lt;!!TResult&gt; Run&lt;TResult&gt;(class System.Func`1&lt;class System.Threading.Tasks.Task`1&lt;!!TResult&gt;&gt; function, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.Run``1(System.Func{System.Threading.Tasks.Task{``0}},System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; static System::Threading::Tasks::Task&lt;TResult&gt; ^ Run(Func&lt;System::Threading::Tasks::Task&lt;TResult&gt; ^&gt; ^ function, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="static member Run : Func&lt;System.Threading.Tasks.Task&lt;'Result&gt;&gt; * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="System.Threading.Tasks.Task.Run (function, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="function" Type="System.Func&lt;System.Threading.Tasks.Task&lt;TResult&gt;&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">Tipo de resultado devuelto por la tarea del proxy.</typeparam>
        <param name="function">Trabajo que se va a ejecutar de forma asincrónica.</param>
        <param name="cancellationToken">Token de cancelación que se debe usar para cancelar el trabajo.</param>
        <summary>Pone en cola el trabajo especificado para ejecutarlo en el grupo de subprocesos y devuelve un proxy para <see langword="Task(TResult)" /> que devuelve <paramref name="function" />.</summary>
        <returns>Una <see langword="Task(TResult)" /> que representa un proxy para <see langword="Task(TResult)" /> devuelta por <paramref name="function" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para obtener información sobre cómo controlar las excepciones producidas por las operaciones de tareas, consulte [Exception Handling](~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El valor del parámetro <paramref name="function" /> es <see langword="null" />.</exception>
        <exception cref="T:System.Threading.Tasks.TaskCanceledException">La tarea se canceló.</exception>
        <exception cref="T:System.ObjectDisposedException">El <see cref="T:System.Threading.CancellationTokenSource" /> asociado a <paramref name="cancellationToken" /> se desechó.</exception>
      </Docs>
    </Member>
    <Member MemberName="Run&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task&lt;TResult&gt; Run&lt;TResult&gt; (Func&lt;TResult&gt; function, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task`1&lt;!!TResult&gt; Run&lt;TResult&gt;(class System.Func`1&lt;!!TResult&gt; function, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.Run``1(System.Func{``0},System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; static System::Threading::Tasks::Task&lt;TResult&gt; ^ Run(Func&lt;TResult&gt; ^ function, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="static member Run : Func&lt;'Result&gt; * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="System.Threading.Tasks.Task.Run (function, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="function" Type="System.Func&lt;TResult&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">Tipo de resultado de la tarea.</typeparam>
        <param name="function">Trabajo que se va a ejecutar de forma asincrónica.</param>
        <param name="cancellationToken">Token de cancelación que se debe usar para cancelar el trabajo.</param>
        <summary>Pone en cola el trabajo especificado para ejecutarlo en el grupo de subprocesos y devuelve un objeto <see langword="Task(TResult)" /> que representa ese trabajo. Un token de cancelación permite cancelar el trabajo.</summary>
        <returns>
          <see langword="Task(TResult)" /> que representa el trabajo en cola que se va a ejecutar en el grupo de subprocesos.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si se solicita la cancelación antes de que la tarea comienza a ejecutarse, la tarea no se ejecuta. En su lugar, se establece en el <xref:System.Threading.Tasks.TaskStatus.Canceled> estado e inicia un <xref:System.Threading.Tasks.TaskCanceledException> excepción.  
  
 El <xref:System.Threading.Tasks.Task.Run%2A> método es una alternativa más sencilla a la <xref:System.Threading.Tasks.TaskFactory.StartNew%2A> método. Crea una tarea con los valores predeterminados siguientes:  
  
-   Su <xref:System.Threading.Tasks.Task.CreationOptions%2A> es el valor de la propiedad <xref:System.Threading.Tasks.TaskCreationOptions.DenyChildAttach?displayProperty=nameWithType>.  
  
-   Usa al programador de tareas de forma predeterminada.  
  
 Para obtener información sobre cómo controlar las excepciones producidas por las operaciones de tareas, consulte [Exception Handling](~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md).  
  
   
  
## Examples  
 En el ejemplo siguiente se crea 20 tareas que genere un bucle hasta que se incrementa un contador con un valor de 2 millones. Cuando las 10 primeras tareas alcancen 2 millones, el token de cancelación se cancela y se cancelan todas las tareas cuyos contadores no hayan alcanzado 2 millones. El ejemplo muestra los resultados posibles.  
  
 [!code-csharp[System.Threading.Tasks.Task.Run#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.run/cs/Run7.cs#7)]
 [!code-vb[System.Threading.Tasks.Task.Run#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.run/vb/Run7.vb#7)]  
  
 En lugar de utilizar el <xref:System.AggregateException.InnerExceptions%2A> propiedad para examinar las excepciones, el ejemplo recorre en iteración todas las tareas para determinar que se han completado correctamente y que se han cancelado. Para los que se ha completado, muestra el valor devuelto por la tarea.  
  
 Dado que la cancelación es cooperativa, cada tarea puede decidir cómo responder a la cancelación. El ejemplo siguiente es parecida a la primera, salvo que, cuando se cancela el token, tareas devuelven el número de iteraciones que han completado en lugar de producirán una excepción.  
  
 [!code-csharp[System.Threading.Tasks.Task.Run#28](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.run/cs/Run28.cs#28)]
 [!code-vb[System.Threading.Tasks.Task.Run#28](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.run/vb/Run28.vb#28)]  
  
 El ejemplo todavía debe controlar la <xref:System.AggregateException> excepción, ya que las tareas que no han iniciado cuando se solicita la cancelación todavía producen una excepción.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El valor del parámetro <paramref name="function" /> es <see langword="null" />.</exception>
        <exception cref="T:System.Threading.Tasks.TaskCanceledException">La tarea se canceló.</exception>
        <exception cref="T:System.ObjectDisposedException">El <see cref="T:System.Threading.CancellationTokenSource" /> asociado a <paramref name="cancellationToken" /> se desechó.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="RunSynchronously">
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Ejecuta sincrónicamente el objeto <see cref="T:System.Threading.Tasks.Task" /> en el objeto <see cref="T:System.Threading.Tasks.TaskScheduler" /> actual.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RunSynchronously">
      <MemberSignature Language="C#" Value="public void RunSynchronously ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RunSynchronously() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.RunSynchronously" />
      <MemberSignature Language="VB.NET" Value="Public Sub RunSynchronously ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RunSynchronously();" />
      <MemberSignature Language="F#" Value="member this.RunSynchronously : unit -&gt; unit" Usage="task.RunSynchronously " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ejecuta sincrónicamente el objeto <see cref="T:System.Threading.Tasks.Task" /> en el objeto <see cref="T:System.Threading.Tasks.TaskScheduler" /> actual.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Por lo general, las tareas se ejecutan de forma asincrónica en un subproceso del grupo y no bloquean el subproceso que realiza la llamada. Las tareas ejecutadas mediante una llamada a la <xref:System.Threading.Tasks.Task.RunSynchronously> están asociados con el actual método <xref:System.Threading.Tasks.TaskScheduler> y se ejecutan en el subproceso que realiza la llamada. Si el programador de destino no admite la ejecución de esta tarea en el subproceso que realiza la llamada, la tarea se programará para su ejecución en el programador y el subproceso que realiza la llamada se bloqueará hasta que la tarea ha completado su ejecución. Aunque la tarea se ejecuta de forma sincrónica, el subproceso que realiza la llamada debe seguir llamando a <xref:System.Threading.Tasks.Task.Wait%2A> para controlar las excepciones que puede iniciar la tarea.  Para obtener más información sobre el control de excepciones, vea [Exception Handling](~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md).  
  
 Las tareas ejecutadas mediante una llamada a la <xref:System.Threading.Tasks.Task.RunSynchronously%2A> se crea una instancia de método mediante una llamada a un <xref:System.Threading.Tasks.Task> o <xref:System.Threading.Tasks.Task%601> constructor de clase. La tarea se ejecute sincrónicamente debe estar en el <xref:System.Threading.Tasks.TaskStatus.Created> estado. Una tarea se puede iniciar y ejecutar una sola vez. Cualquier intento para programar una tarea de un segundo tiempo da como resultado una excepción.  
  
   
  
## Examples  
 El ejemplo siguiente compara una tarea que se ejecuta mediante una llamada a la <xref:System.Threading.Tasks.Task.RunSynchronously%2A> método con una ejecución asincrónica. En ambos casos, las tareas ejecutan expresiones de lambda idénticos que muestran el identificador de tarea y el identificador del subproceso en el que se ejecuta la tarea. La tarea calcula la suma de los enteros entre 1 y 1.000.000. Como se muestra en el resultado del ejemplo, la tarea se ejecuta mediante una llamada a la <xref:System.Threading.Tasks.Task.RunSynchronously%2A> método se ejecuta en el subproceso de la aplicación, mientras que la tarea asincrónica no.  
  
 [!code-csharp[System.Threading.Tasks.Task.RunSynchronously#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.runsynchronously/cs/runsynchronously1.cs#1)]
 [!code-vb[System.Threading.Tasks.Task.RunSynchronously#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.runsynchronously/vb/runsynchronously1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">La instancia de <see cref="T:System.Threading.Tasks.Task" /> se ha eliminado.</exception>
        <exception cref="T:System.InvalidOperationException">La tarea <see cref="T:System.Threading.Tasks.Task" /> no está en un estado válido para que se inicie. Puede que ya se haya iniciado, ejecutado o cancelado, o puede que ya se haya creado de una manera que no admite la programación directa.</exception>
      </Docs>
    </Member>
    <Member MemberName="RunSynchronously">
      <MemberSignature Language="C#" Value="public void RunSynchronously (System.Threading.Tasks.TaskScheduler scheduler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RunSynchronously(class System.Threading.Tasks.TaskScheduler scheduler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.RunSynchronously(System.Threading.Tasks.TaskScheduler)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RunSynchronously (scheduler As TaskScheduler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RunSynchronously(System::Threading::Tasks::TaskScheduler ^ scheduler);" />
      <MemberSignature Language="F#" Value="member this.RunSynchronously : System.Threading.Tasks.TaskScheduler -&gt; unit" Usage="task.RunSynchronously scheduler" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="scheduler" Type="System.Threading.Tasks.TaskScheduler" />
      </Parameters>
      <Docs>
        <param name="scheduler">Programador en el que se va a intentar ejecutar esta tarea insertada.</param>
        <summary>Ejecuta sincrónicamente el objeto <see cref="T:System.Threading.Tasks.Task" /> en el objeto <see cref="T:System.Threading.Tasks.TaskScheduler" /> especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Las tareas ejecutadas mediante una llamada a la <xref:System.Threading.Tasks.Task.RunSynchronously%2A> se crea una instancia de método mediante una llamada a un <xref:System.Threading.Tasks.Task> o <xref:System.Threading.Tasks.Task%601> constructor de clase. La tarea se ejecute sincrónicamente debe estar en el <xref:System.Threading.Tasks.TaskStatus.Created> estado. Una tarea se puede iniciar y ejecutar una sola vez. Cualquier intento para programar una tarea de un segundo tiempo da como resultado una excepción.  
  
 Si el programador de destino no admite la ejecución de esta tarea en el subproceso actual, la tarea se programará para su ejecución en el programador y el subproceso actual se bloqueará hasta que la tarea ha completado su ejecución. Por este motivo, el subproceso que realiza la llamada no necesita llamar a un método como <xref:System.Threading.Tasks.Task.Wait%2A> para asegurarse de que la tarea ha completado su ejecución. Para obtener más información sobre el control de excepciones para las operaciones de tareas, consulte [Exception Handling](~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">La instancia de <see cref="T:System.Threading.Tasks.Task" /> se ha eliminado.</exception>
        <exception cref="T:System.ArgumentNullException">El argumento <paramref name="scheduler" /> es <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="T:System.Threading.Tasks.Task" /> no se encuentra en un estado válido para iniciarse. Puede que ya se haya iniciado, ejecutado o cancelado, o puede que ya se haya creado de una manera que no admite la programación directa.</exception>
        <altmember cref="T:System.Threading.Tasks.TaskScheduler" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Start">
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inicia <see cref="T:System.Threading.Tasks.Task" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Start">
      <MemberSignature Language="C#" Value="public void Start ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Start() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.Start" />
      <MemberSignature Language="VB.NET" Value="Public Sub Start ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Start();" />
      <MemberSignature Language="F#" Value="member this.Start : unit -&gt; unit" Usage="task.Start " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Inicia el objeto <see cref="T:System.Threading.Tasks.Task" />, programando su ejecución en el objeto <see cref="T:System.Threading.Tasks.TaskScheduler" /> actual.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Una tarea se puede iniciar y ejecutar una sola vez. Cualquier intento de programar una tarea una segunda vez se producirá una excepción.  
  
 El <xref:System.Threading.Tasks.Task.Start%2A> se usa para ejecutar una tarea que se ha creado llamando a uno de los <xref:System.Threading.Tasks.Task> constructores. Normalmente, esto se realiza cuando es necesario separar la creación de la tarea de su ejecución, por ejemplo, cuando se ejecutan condicionalmente las tareas que ha creado. En el caso más común en el que no es necesario separar la creación de instancias de tareas de ejecución, se recomienda llamar a una sobrecarga de la <xref:System.Threading.Tasks.Task.Run%2A?displayProperty=nameWithType> o <xref:System.Threading.Tasks.TaskFactory.StartNew%2A?displayProperty=nameWithType> método.  
  
 Para obtener información sobre cómo controlar las excepciones producidas por las operaciones de tareas, consulte [Exception Handling](~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md).  
  
   
  
## Examples  
 El ejemplo siguiente se llama el <xref:System.Threading.Tasks.Task.%23ctor%28System.Action%29> constructor para crear instancias de un nuevo <xref:System.Threading.Tasks.Task> objeto que muestra su tarea identificador y el identificador de subproceso administrado y, a continuación, ejecuta un bucle. A continuación, llama el <xref:System.Threading.Tasks.Task.Start%2A> método para ejecutar la tarea.  Puesto que se trata de una aplicación de consola, la llamada a la <xref:System.Threading.Tasks.Task.Wait%2A> método es necesario para evitar que la aplicación finalice antes de que la tarea finaliza la ejecución.  
  
 [!code-csharp[System.Threading.Tasks.Task.Start#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.start/cs/Start1.cs#1)]
 [!code-vb[System.Threading.Tasks.Task.Start#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.start/vb/Start1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">La instancia de <see cref="T:System.Threading.Tasks.Task" /> se ha eliminado.</exception>
        <exception cref="T:System.InvalidOperationException">La tarea <see cref="T:System.Threading.Tasks.Task" /> no está en un estado válido para que se inicie. Puede que ya se haya iniciado, ejecutado o cancelado, o puede que ya se haya creado de una manera que no admite la programación directa.</exception>
      </Docs>
    </Member>
    <Member MemberName="Start">
      <MemberSignature Language="C#" Value="public void Start (System.Threading.Tasks.TaskScheduler scheduler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Start(class System.Threading.Tasks.TaskScheduler scheduler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.Start(System.Threading.Tasks.TaskScheduler)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Start (scheduler As TaskScheduler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Start(System::Threading::Tasks::TaskScheduler ^ scheduler);" />
      <MemberSignature Language="F#" Value="member this.Start : System.Threading.Tasks.TaskScheduler -&gt; unit" Usage="task.Start scheduler" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="scheduler" Type="System.Threading.Tasks.TaskScheduler" />
      </Parameters>
      <Docs>
        <param name="scheduler">Objeto <see cref="T:System.Threading.Tasks.TaskScheduler" /> con el que se va a asociar y ejecutar esta tarea.</param>
        <summary>Inicia el objeto <see cref="T:System.Threading.Tasks.Task" />, programando su ejecución en el objeto <see cref="T:System.Threading.Tasks.TaskScheduler" /> especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Una tarea solo se inicia y ejecuta una sola vez. Cualquier intento de programar una tarea una segunda vez se producirá una excepción.  
  
 Para obtener información sobre cómo controlar las excepciones producidas por las operaciones de tareas, consulte [Exception Handling](~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El argumento <paramref name="scheduler" /> es <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="T:System.Threading.Tasks.Task" /> no se encuentra en un estado válido para iniciarse. Puede que ya se haya iniciado, ejecutado o cancelado, o puede que ya se haya creado de una manera que no admite la programación directa.</exception>
        <exception cref="T:System.ObjectDisposedException">Se eliminó la instancia de <see cref="T:System.Threading.Tasks.Task" />.</exception>
        <exception cref="T:System.Threading.Tasks.TaskSchedulerException">El programador no pudo poner en cola esta tarea.</exception>
      </Docs>
    </Member>
    <Member MemberName="Status">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.TaskStatus Status { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Threading.Tasks.TaskStatus Status" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.Task.Status" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Status As TaskStatus" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Threading::Tasks::TaskStatus Status { System::Threading::Tasks::TaskStatus get(); };" />
      <MemberSignature Language="F#" Value="member this.Status : System.Threading.Tasks.TaskStatus" Usage="System.Threading.Tasks.Task.Status" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.TaskStatus</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene el objeto <see cref="T:System.Threading.Tasks.TaskStatus" /> de esta tarea.</summary>
        <value>
          <see cref="T:System.Threading.Tasks.TaskStatus" /> actual de esta instancia de la tarea.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Recuperación del valor de la <xref:System.Threading.Tasks.Task.Status%2A?displayProperty=nameWithType> propiedad no bloquea el subproceso que realiza la llamada hasta que la tarea se ha completado.  
  
 Para obtener más información y un ejemplo, vea [encadenar tareas mediante tareas de continuación](~/docs/standard/parallel-programming/chaining-tasks-by-using-continuation-tasks.md) y [Cómo: cancelar una tarea y sus elementos secundarios](~/docs/standard/parallel-programming/how-to-cancel-a-task-and-its-children.md).  
  
   
  
## Examples  
 En el ejemplo siguiente se crea 20 tareas que genere un bucle hasta que se incrementa un contador con un valor de 2 millones. Cuando las 10 primeras tareas alcancen 2 millones, el token de cancelación se cancela y se cancelan todas las tareas cuyos contadores no hayan alcanzado 2 millones. En el ejemplo, a continuación, examina el <xref:System.Threading.Tasks.Task.Status%2A> propiedad de cada tarea para indicar si se completó correctamente o se canceló. Para los que se completa, muestra el valor devuelto por la tarea.  
  
 [!code-csharp[System.Threading.Tasks.Task.Run#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.run/cs/Run7.cs#7)]
 [!code-vb[System.Threading.Tasks.Task.Run#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.run/vb/Run7.vb#7)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IAsyncResult.AsyncWaitHandle">
      <MemberSignature Language="C#" Value="System.Threading.WaitHandle System.IAsyncResult.AsyncWaitHandle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Threading.WaitHandle System.IAsyncResult.AsyncWaitHandle" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.Task.System#IAsyncResult#AsyncWaitHandle" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property AsyncWaitHandle As WaitHandle Implements IAsyncResult.AsyncWaitHandle" />
      <MemberSignature Language="C++ CLI" Value="property System::Threading::WaitHandle ^ System.IAsyncResult.AsyncWaitHandle { System::Threading::WaitHandle ^ get(); };" />
      <MemberSignature Language="F#" Usage="System.Threading.Tasks.Task.System.IAsyncResult.AsyncWaitHandle" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.IAsyncResult.AsyncWaitHandle</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.WaitHandle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene un identificador <see cref="T:System.Threading.WaitHandle" /> que se puede usar para esperar a que se complete la tarea.</summary>
        <value>
          <see cref="T:System.Threading.WaitHandle" /> que se puede usar para esperar a que se complete la tarea.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Mediante la funcionalidad de espera proporcionada por <xref:System.Threading.Tasks.Task.Wait%2A?displayProperty=nameWithType> es preferible al uso de <xref:System.IAsyncResult.AsyncWaitHandle%2A> para una funcionalidad similar. Para obtener más información, consulte la sección "Esperando en tareas" en [basado en tareas de programación asincrónica](~/docs/standard/parallel-programming/task-based-asynchronous-programming.md) y [usar TPL con otros modelos asincrónicos](~/docs/standard/parallel-programming/using-tpl-with-other-asynchronous-patterns.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Se ha eliminado el objeto <see cref="T:System.Threading.Tasks.Task" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IAsyncResult.CompletedSynchronously">
      <MemberSignature Language="C#" Value="bool System.IAsyncResult.CompletedSynchronously { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.IAsyncResult.CompletedSynchronously" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.Task.System#IAsyncResult#CompletedSynchronously" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property CompletedSynchronously As Boolean Implements IAsyncResult.CompletedSynchronously" />
      <MemberSignature Language="C++ CLI" Value="property bool System.IAsyncResult.CompletedSynchronously { bool get(); };" />
      <MemberSignature Language="F#" Usage="System.Threading.Tasks.Task.System.IAsyncResult.CompletedSynchronously" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.IAsyncResult.CompletedSynchronously</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene un valor que indica si la operación se ha completado sincrónicamente.</summary>
        <value>Es <see langword="true" /> si la operación se completó sincrónicamente; de lo contrario, es <see langword="false" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Wait">
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Espera a que se complete la ejecución del objeto <see cref="T:System.Threading.Tasks.Task" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Wait">
      <MemberSignature Language="C#" Value="public void Wait ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Wait() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.Wait" />
      <MemberSignature Language="VB.NET" Value="Public Sub Wait ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Wait();" />
      <MemberSignature Language="F#" Value="member this.Wait : unit -&gt; unit" Usage="task.Wait " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Espera a que se complete la ejecución del objeto <see cref="T:System.Threading.Tasks.Task" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Tasks.Task.Wait%2A> es un método de sincronización que hace que el subproceso que realiza la llamada esperar hasta que se ha completado la tarea actual. Si la tarea actual no ha iniciado la ejecución, el método espera intenta quitar la tarea del programador y lo ejecuta en línea en el subproceso actual. Si no es capaz de hacerlo, o si la tarea actual ya ha iniciado la ejecución, se bloquea el subproceso que realiza la llamada hasta que se complete la tarea. Para obtener más información, consulte [Task.Wait y "Inserción"](http://blogs.msdn.com/b/pfxteam/archive/2009/10/15/9907713.aspx) en la programación en paralelo con .NET blog.  
  
 Para obtener más información y un ejemplo, vea [Cómo: esperar a que una o varias tareas se completen](http://msdn.microsoft.com/library/79cb522b-9c93-46ed-b23a-c06908f3a374).  
  
   
  
## Examples  
 En el ejemplo siguiente se inicia una tarea que genera un millón de números enteros aleatorios entre 0 y 100 y calcula su Media. El ejemplo se utiliza la <xref:System.Threading.Tasks.Task.Wait%2A> método para asegurarse de que la tarea se complete antes de que finalice la aplicación. En caso contrario, se trata de una aplicación de consola, en el ejemplo finalizaría antes de que la tarea puede calcular y mostrar la Media.  
  
 [!code-csharp[System.Threading.Tasks.Task.Wait#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.wait/cs/wait1.cs#1)]
 [!code-vb[System.Threading.Tasks.Task.Wait#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.wait/vb/wait1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Se ha eliminado el objeto <see cref="T:System.Threading.Tasks.Task" />.</exception>
        <exception cref="T:System.AggregateException">Se canceló la tarea. La colección <see cref="P:System.AggregateException.InnerExceptions" /> contiene un objeto <see cref="T:System.Threading.Tasks.TaskCanceledException" />.  -o bien- Se inició una excepción durante la ejecución de la tarea. La colección <see cref="P:System.AggregateException.InnerExceptions" /> contiene información sobre la excepción o excepciones.</exception>
      </Docs>
    </Member>
    <Member MemberName="Wait">
      <MemberSignature Language="C#" Value="public bool Wait (int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Wait(int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.Wait(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Wait (millisecondsTimeout As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Wait(int millisecondsTimeout);" />
      <MemberSignature Language="F#" Value="member this.Wait : int -&gt; bool" Usage="task.Wait millisecondsTimeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="millisecondsTimeout">Número de milisegundos de espera o <see cref="F:System.Threading.Timeout.Infinite" /> (-1) para esperar indefinidamente.</param>
        <summary>Espera a que <see cref="T:System.Threading.Tasks.Task" /> complete la ejecución dentro de un número de milisegundos.</summary>
        <returns>Es <see langword="true" />, si la ejecución del objeto <see cref="T:System.Threading.Tasks.Task" /> se completó en el tiempo asignado; de lo contrario, es <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Tasks.Task.Wait%28System.Int32%29> es un método de sincronización que hace que el subproceso que realiza la llamada debe esperar para que la instancia actual de la tarea completar hasta que se produzca uno de los siguientes:  
  
-   La tarea se completa correctamente.  
  
-   La tarea propiamente dicha se cancela o inicia una excepción. En este caso, controlar un <xref:System.AggregateException> excepción. El <xref:System.AggregateException.InnerExceptions%2A?displayProperty=nameWithType> propiedad contiene información detallada sobre la excepción o excepciones.  
  
-   El intervalo que define `millisecondsTimeout` transcurre. En este caso, el subproceso actual reanuda la ejecución y el método devuelve `false`.  
  
   
  
## Examples  
 En el ejemplo siguiente se inicia una tarea que genera números enteros aleatorios de cinco millones entre 0 y 100 y calcula su Media. El ejemplo se utiliza la <xref:System.Threading.Tasks.Task.Wait%28System.Int32%29> método para esperar la aplicación pueda completar dentro de 150 milisegundos. Si la aplicación se completa con normalidad, la tarea muestra la suma y promedio de los números aleatorios que ha generado. Si ha transcurrido el intervalo de tiempo de espera, en el ejemplo se muestra un mensaje antes de finalizar.  
  
 [!code-csharp[System.Threading.Tasks.Task.Wait#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.wait/cs/Wait5.cs#5)]
 [!code-vb[System.Threading.Tasks.Task.Wait#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.wait/vb/Wait5.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Se ha eliminado el objeto <see cref="T:System.Threading.Tasks.Task" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="millisecondsTimeout" /> es un número negativo distinto de-1, que representa un tiempo de espera infinito.</exception>
        <exception cref="T:System.AggregateException">Se canceló la tarea. La colección <see cref="P:System.AggregateException.InnerExceptions" /> contiene un objeto <see cref="T:System.Threading.Tasks.TaskCanceledException" />.  -o bien- Se inició una excepción durante la ejecución de la tarea. La colección <see cref="P:System.AggregateException.InnerExceptions" /> contiene información sobre la excepción o excepciones.</exception>
      </Docs>
    </Member>
    <Member MemberName="Wait">
      <MemberSignature Language="C#" Value="public void Wait (System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Wait(valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.Wait(System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Wait(System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="member this.Wait : System.Threading.CancellationToken -&gt; unit" Usage="task.Wait cancellationToken" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="cancellationToken">Un token de cancelación que se observará mientras se espera a que se complete la tarea.</param>
        <summary>Espera a que se complete la ejecución del objeto <see cref="T:System.Threading.Tasks.Task" />. La espera finalizará si un token de cancelación se cancela antes de que finalice la tarea.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Threading.Tasks.Task.Wait%28System.Threading.CancellationToken%29> método crea una espera puede cancelarse; es decir, hace que el subproceso actual esperar hasta que se produce uno de los siguientes valores:  
  
-   La tarea se complete.  
  
-   El token de cancelación se cancela. En este caso, la llamada a la <xref:System.Threading.Tasks.Task.Wait%28System.Threading.CancellationToken%29> método produce un <xref:System.OperationCanceledException>.  
  
> [!NOTE]
>  Cancelar la `cancellationToken` token de cancelación no tiene ningún efecto en la tarea en ejecución a menos que también se ha pasado el token de cancelación y está preparado para administrar su cancelación. Pasar la `cancellationToken` objeto a este método simplemente permite la espera se cancele.  
  
   
  
## Examples  
 En el ejemplo siguiente se muestra el uso simple de un token de cancelación para cancelar esperar la finalización de una tarea. Una tarea se inicia, se llama a la <xref:System.Threading.CancellationTokenSource.Cancel%2A?displayProperty=nameWithType> método cancelar cualquiera del origen de token tokens de cancelación y, a continuación, retrasos durante cinco segundos. Tenga en cuenta que la propia tarea no se ha pasado el token de cancelación y no puede cancelar. El subproceso de la aplicación llama a la tarea <xref:System.Threading.Tasks.Task.Wait%2A?displayProperty=nameWithType> método para esperar a que complete la tarea, pero la espera se cancela una vez que se cancela el token de cancelación y un <xref:System.OperationCanceledException> se produce. El controlador de excepciones notifica la excepción y, a continuación, se suspende durante seis segundos. Como se muestra en el resultado del ejemplo, ese retraso permite que la tarea se complete en el <xref:System.Threading.Tasks.TaskStatus.RanToCompletion> estado.  
  
 [!code-csharp[System.Threading.Tasks.Task.Wait#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.wait/cs/wait3.cs#3)]
 [!code-vb[System.Threading.Tasks.Task.Wait#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.wait/vb/wait3.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OperationCanceledException">Se canceló <paramref name="cancellationToken" />.</exception>
        <exception cref="T:System.ObjectDisposedException">Se ha desechado la tarea.</exception>
        <exception cref="T:System.AggregateException">Se canceló la tarea. La colección <see cref="P:System.AggregateException.InnerExceptions" /> contiene un objeto <see cref="T:System.Threading.Tasks.TaskCanceledException" />.  -o bien- Se inició una excepción durante la ejecución de la tarea. La colección <see cref="P:System.AggregateException.InnerExceptions" /> contiene información sobre la excepción o excepciones.</exception>
      </Docs>
    </Member>
    <Member MemberName="Wait">
      <MemberSignature Language="C#" Value="public bool Wait (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Wait(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.Wait(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Function Wait (timeout As TimeSpan) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Wait(TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="member this.Wait : TimeSpan -&gt; bool" Usage="task.Wait timeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout">Estructura <see cref="T:System.TimeSpan" /> que representa el número de milisegundos de espera o estructura <see cref="T:System.TimeSpan" /> que representa -1 milisegundos para esperar indefinidamente.</param>
        <summary>Espera a que <see cref="T:System.Threading.Tasks.Task" /> complete la ejecución dentro de un intervalo de tiempo especificado.</summary>
        <returns>Es <see langword="true" />, si la ejecución del objeto <see cref="T:System.Threading.Tasks.Task" /> se completó en el tiempo asignado; de lo contrario, es <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Tasks.Task.Wait%28System.TimeSpan%29> es un método de sincronización que hace que el subproceso que realiza la llamada debe esperar para que la instancia actual de la tarea completar hasta que se produzca uno de los siguientes:  
  
-   La tarea se completa correctamente.  
  
-   La tarea propiamente dicha se cancela o inicia una excepción. En este caso, controlar un <xref:System.AggregateException> excepción. El <xref:System.AggregateException.InnerExceptions%2A?displayProperty=nameWithType> propiedad contiene información detallada sobre la excepción o excepciones.  
  
-   El intervalo que define `timeout` transcurre. En este caso, el subproceso actual reanuda la ejecución y el método devuelve `false`.  
  
   
  
## Examples  
 En el ejemplo siguiente se inicia una tarea que genera números enteros aleatorios de cinco millones entre 0 y 100 y calcula su Media. El ejemplo se utiliza la <xref:System.Threading.Tasks.Task.Wait%28System.TimeSpan%29> método para esperar la aplicación pueda completar dentro de 150 milisegundos. Si la aplicación se completa con normalidad, la tarea muestra la suma y promedio de los números aleatorios que ha generado. Si ha transcurrido el intervalo de tiempo de espera, en el ejemplo se muestra un mensaje antes de finalizar.  
  
 [!code-csharp[System.Threading.Tasks.Task.Wait#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.wait/cs/Wait6.cs#6)]
 [!code-vb[System.Threading.Tasks.Task.Wait#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.wait/vb/Wait6.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Se ha eliminado el objeto <see cref="T:System.Threading.Tasks.Task" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="timeout" /> es un número negativo distinto de -1 milisegundo, que representa un tiempo de espera infinito. -o bien- <paramref name="timeout" /> es mayor de <see cref="F:System.Int32.MaxValue" />.</exception>
        <exception cref="T:System.AggregateException">Se canceló la tarea. La colección <see cref="P:System.AggregateException.InnerExceptions" /> contiene un objeto <see cref="T:System.Threading.Tasks.TaskCanceledException" />.  -o bien- Se inició una excepción durante la ejecución de la tarea. La colección <see cref="P:System.AggregateException.InnerExceptions" /> contiene información sobre la excepción o excepciones.</exception>
      </Docs>
    </Member>
    <Member MemberName="Wait">
      <MemberSignature Language="C#" Value="public bool Wait (int millisecondsTimeout, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Wait(int32 millisecondsTimeout, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.Wait(System.Int32,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Wait(int millisecondsTimeout, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="member this.Wait : int * System.Threading.CancellationToken -&gt; bool" Usage="task.Wait (millisecondsTimeout, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="millisecondsTimeout">Número de milisegundos de espera o <see cref="F:System.Threading.Timeout.Infinite" /> (-1) para esperar indefinidamente.</param>
        <param name="cancellationToken">Un token de cancelación que se observará mientras se espera a que se complete la tarea.</param>
        <summary>Espera a que se complete la ejecución del objeto <see cref="T:System.Threading.Tasks.Task" />. La espera finalizará si transcurre un intervalo de tiempo de espera o un token de cancelación se cancela antes de que finalice la tarea.</summary>
        <returns>Es <see langword="true" />, si la ejecución del objeto <see cref="T:System.Threading.Tasks.Task" /> se completó en el tiempo asignado; de lo contrario, es <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Tasks.Task.Wait%28System.Int32%2CSystem.Threading.CancellationToken%29> es un método de sincronización que hace que el subproceso que realiza la llamada debe esperar para que la instancia actual de la tarea completar hasta que se produzca uno de los siguientes:  
  
-   La tarea se completa correctamente.  
  
-   La tarea propiamente dicha se cancela o inicia una excepción. En este caso, controlar un <xref:System.AggregateException> excepción. El <xref:System.AggregateException.InnerExceptions%2A?displayProperty=nameWithType> propiedad contiene información detallada sobre la excepción o excepciones.  
  
-   El `cancellationToken` se cancela el token de cancelación. En este caso, la llamada a la <xref:System.Threading.Tasks.Task.Wait%28System.Int32%2CSystem.Threading.CancellationToken%29> método produce un <xref:System.OperationCanceledException>.  
  
-   El intervalo que define `millisecondsTimeout` transcurre. En este caso, el subproceso actual reanuda la ejecución y el método devuelve `false`.  
  
> [!NOTE]
>  Cancelar la `cancellationToken` token de cancelación no tiene ningún efecto en la tarea en ejecución a menos que también se ha pasado el token de cancelación y está preparado para administrar su cancelación. Pasar la `cancellationToken` objeto a este método simplemente permite la espera cancelarse basándose en alguna condición.  
  
   
  
## Examples  
 El ejemplo siguiente se llama el <xref:System.Threading.Tasks.Task.Wait%28System.Int32%2CSystem.Threading.CancellationToken%29> método para proporcionar un valor de tiempo de espera y una cancelación de tokens que puede finalizar la espera de finalización de una tarea. Un nuevo subproceso se inicia y ejecuta el `CancelToken` método, que pone en pausa y, a continuación, llama a la <xref:System.Threading.CancellationTokenSource.Cancel%2A?displayProperty=nameWithType> método para cancelar los tokens de cancelación. Una tarea es, a continuación, inicia y retrasa durante 5 segundos. El <xref:System.Threading.Tasks.Task.Wait%2A> , a continuación, se llama para esperar la finalización de la tarea de método y se proporciona un valor de tiempo de espera breve y un token de cancelación.  
  
 [!code-csharp[System.Threading.Tasks.Task.Wait#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.wait/cs/wait4.cs#4)]
 [!code-vb[System.Threading.Tasks.Task.Wait#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.wait/vb/wait4.vb#4)]  
  
 Tenga en cuenta que el resultado del ejemplo preciso depende de si se canceló la espera por el token de cancelación o porque se agotó el intervalo de tiempo de espera.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OperationCanceledException">Se canceló <paramref name="cancellationToken" />.</exception>
        <exception cref="T:System.ObjectDisposedException">Se ha eliminado el objeto <see cref="T:System.Threading.Tasks.Task" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="millisecondsTimeout" /> es un número negativo distinto de-1, que representa un tiempo de espera infinito.</exception>
        <exception cref="T:System.AggregateException">Se canceló la tarea. La colección <see cref="P:System.AggregateException.InnerExceptions" /> contiene un objeto <see cref="T:System.Threading.Tasks.TaskCanceledException" />.  -o bien- Se inició una excepción durante la ejecución de la tarea. La colección <see cref="P:System.AggregateException.InnerExceptions" /> contiene información sobre la excepción o excepciones.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="WaitAll">
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Espera que se complete la ejecución de todos los objetos <see cref="T:System.Threading.Tasks.Task" /> proporcionados.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WaitAll">
      <MemberSignature Language="C#" Value="public static void WaitAll (params System.Threading.Tasks.Task[] tasks);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WaitAll(class System.Threading.Tasks.Task[] tasks) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WaitAll (ParamArray tasks As Task())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WaitAll(... cli::array &lt;System::Threading::Tasks::Task ^&gt; ^ tasks);" />
      <MemberSignature Language="F#" Value="static member WaitAll : System.Threading.Tasks.Task[] -&gt; unit" Usage="System.Threading.Tasks.Task.WaitAll tasks" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="tasks">Matriz de instancias de <see cref="T:System.Threading.Tasks.Task" /> en las que se va a esperar.</param>
        <summary>Espera que se complete la ejecución de todos los objetos <see cref="T:System.Threading.Tasks.Task" /> proporcionados.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 El ejemplo siguiente inicia 10 tareas, cada uno de los cuales se pasa un índice como un objeto de estado. Tareas con un índice de dos a cinco producen excepciones. La llamada a la <xref:System.Threading.Tasks.Task.WaitAll%2A> método ajusta todas las excepciones en un <xref:System.AggregateException> de objetos y propaga al subproceso que realiza la llamada.  
  
 [!code-csharp[System.Threading.Tasks.Task#02](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task/cs/waitall.cs#02)]
 [!code-vb[System.Threading.Tasks.Task#02](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task/vb/waitall.vb#02)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Al menos se ha eliminado uno de los objetos <see cref="T:System.Threading.Tasks.Task" /> en <paramref name="tasks" />.</exception>
        <exception cref="T:System.ArgumentNullException">El argumento <paramref name="tasks" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">El argumento <paramref name="tasks" /> contiene un elemento NULL.  -o bien- El argumento <paramref name="tasks" /> es una matriz vacía.</exception>
        <exception cref="T:System.AggregateException">Se canceló al menos una de las instancias <see cref="T:System.Threading.Tasks.Task" />. Si se canceló una tarea, la excepción <see cref="T:System.AggregateException" /> contiene una excepción <see cref="T:System.OperationCanceledException" /> en su colección <see cref="P:System.AggregateException.InnerExceptions" />.  -o bien- Se inició una excepción durante la ejecución de al menos una de las instancias de <see cref="T:System.Threading.Tasks.Task" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAll">
      <MemberSignature Language="C#" Value="public static bool WaitAll (System.Threading.Tasks.Task[] tasks, int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool WaitAll(class System.Threading.Tasks.Task[] tasks, int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAll (tasks As Task(), millisecondsTimeout As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool WaitAll(cli::array &lt;System::Threading::Tasks::Task ^&gt; ^ tasks, int millisecondsTimeout);" />
      <MemberSignature Language="F#" Value="static member WaitAll : System.Threading.Tasks.Task[] * int -&gt; bool" Usage="System.Threading.Tasks.Task.WaitAll (tasks, millisecondsTimeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task[]" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="tasks">Matriz de instancias de <see cref="T:System.Threading.Tasks.Task" /> en las que se va a esperar.</param>
        <param name="millisecondsTimeout">Número de milisegundos de espera o <see cref="F:System.Threading.Timeout.Infinite" /> (-1) para esperar indefinidamente.</param>
        <summary>Espera a que todos los objetos proporcionados de <see cref="T:System.Threading.Tasks.Task" /> completen la ejecución dentro de un número de milisegundos.</summary>
        <returns>Es <see langword="true" /> si la ejecución de todas las instancias de <see cref="T:System.Threading.Tasks.Task" /> se completan en el tiempo asignado; de lo contrario, es <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException">Al menos se ha eliminado uno de los objetos <see cref="T:System.Threading.Tasks.Task" /> en <paramref name="tasks" />.</exception>
        <exception cref="T:System.ArgumentNullException">El argumento <paramref name="tasks" /> es <see langword="null" />.</exception>
        <exception cref="T:System.AggregateException">Se canceló al menos una de las instancias <see cref="T:System.Threading.Tasks.Task" />. Si una tarea estuviera cancelada, <see cref="T:System.AggregateException" /> contiene <see cref="T:System.OperationCanceledException" /> en su colección <see cref="P:System.AggregateException.InnerExceptions" />.  -o bien- Se inició una excepción durante la ejecución de al menos una de las instancias de <see cref="T:System.Threading.Tasks.Task" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="millisecondsTimeout" /> es un número negativo distinto de -1 que representa un tiempo de espera infinito.</exception>
        <exception cref="T:System.ArgumentException">El argumento <paramref name="tasks" /> contiene un elemento NULL.  -o bien- El argumento <paramref name="tasks" /> es una matriz vacía.</exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAll">
      <MemberSignature Language="C#" Value="public static void WaitAll (System.Threading.Tasks.Task[] tasks, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WaitAll(class System.Threading.Tasks.Task[] tasks, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[],System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WaitAll(cli::array &lt;System::Threading::Tasks::Task ^&gt; ^ tasks, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="static member WaitAll : System.Threading.Tasks.Task[] * System.Threading.CancellationToken -&gt; unit" Usage="System.Threading.Tasks.Task.WaitAll (tasks, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task[]" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="tasks">Matriz de instancias de <see cref="T:System.Threading.Tasks.Task" /> en las que se va a esperar.</param>
        <param name="cancellationToken">
          <see cref="P:System.Threading.Tasks.TaskFactory.CancellationToken" /> que se va a observar mientras se espera la finalización de las tareas.</param>
        <summary>Espera que se complete la ejecución de todos los objetos <see cref="T:System.Threading.Tasks.Task" /> proporcionados, a menos que se cancele la espera.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El `cancellationToken` argumento se utiliza para cancelar la operación de espera. Cancelación de la tarea es una operación distinta y se señaliza mediante el <xref:System.AggregateException> como se indicó anteriormente.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OperationCanceledException">Se canceló <paramref name="cancellationToken" />.</exception>
        <exception cref="T:System.ArgumentNullException">El argumento <paramref name="tasks" /> es <see langword="null" />.</exception>
        <exception cref="T:System.AggregateException">Se canceló al menos una de las instancias <see cref="T:System.Threading.Tasks.Task" />. Si una tarea estuviera cancelada, <see cref="T:System.AggregateException" /> contiene <see cref="T:System.OperationCanceledException" /> en su colección <see cref="P:System.AggregateException.InnerExceptions" />.  -o bien- Se inició una excepción durante la ejecución de al menos una de las instancias de <see cref="T:System.Threading.Tasks.Task" />.</exception>
        <exception cref="T:System.ArgumentException">El argumento <paramref name="tasks" /> contiene un elemento NULL.  -o bien- El argumento <paramref name="tasks" /> es una matriz vacía.</exception>
        <exception cref="T:System.ObjectDisposedException">Al menos se ha eliminado uno de los objetos <see cref="T:System.Threading.Tasks.Task" /> en <paramref name="tasks" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAll">
      <MemberSignature Language="C#" Value="public static bool WaitAll (System.Threading.Tasks.Task[] tasks, TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool WaitAll(class System.Threading.Tasks.Task[] tasks, valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[],System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAll (tasks As Task(), timeout As TimeSpan) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool WaitAll(cli::array &lt;System::Threading::Tasks::Task ^&gt; ^ tasks, TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="static member WaitAll : System.Threading.Tasks.Task[] * TimeSpan -&gt; bool" Usage="System.Threading.Tasks.Task.WaitAll (tasks, timeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task[]" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="tasks">Matriz de instancias de <see cref="T:System.Threading.Tasks.Task" /> en las que se va a esperar.</param>
        <param name="timeout">Estructura <see cref="T:System.TimeSpan" /> que representa el número de milisegundos de espera o estructura <see cref="T:System.TimeSpan" /> que representa -1 milisegundos para esperar indefinidamente.</param>
        <summary>Espera a que todos los objetos cancelables proporcionados de <see cref="T:System.Threading.Tasks.Task" /> completen la ejecución en un intervalo de tiempo especificado.</summary>
        <returns>Es <see langword="true" /> si la ejecución de todas las instancias de <see cref="T:System.Threading.Tasks.Task" /> se completan en el tiempo asignado; de lo contrario, es <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException">Al menos se ha eliminado uno de los objetos <see cref="T:System.Threading.Tasks.Task" /> en <paramref name="tasks" />.</exception>
        <exception cref="T:System.ArgumentNullException">El argumento <paramref name="tasks" /> es <see langword="null" />.</exception>
        <exception cref="T:System.AggregateException">Se canceló al menos una de las instancias <see cref="T:System.Threading.Tasks.Task" />. Si una tarea estuviera cancelada, <see cref="T:System.AggregateException" /> contiene <see cref="T:System.OperationCanceledException" /> en su colección <see cref="P:System.AggregateException.InnerExceptions" />.  -o bien- Se inició una excepción durante la ejecución de al menos una de las instancias de <see cref="T:System.Threading.Tasks.Task" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="timeout" /> es un número negativo distinto de -1 milisegundo, que representa un tiempo de espera infinito. -o bien- <paramref name="timeout" /> es mayor de <see cref="F:System.Int32.MaxValue" />.</exception>
        <exception cref="T:System.ArgumentException">El argumento <paramref name="tasks" /> contiene un elemento NULL.  -o bien- El argumento <paramref name="tasks" /> es una matriz vacía.</exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAll">
      <MemberSignature Language="C#" Value="public static bool WaitAll (System.Threading.Tasks.Task[] tasks, int millisecondsTimeout, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool WaitAll(class System.Threading.Tasks.Task[] tasks, int32 millisecondsTimeout, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[],System.Int32,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool WaitAll(cli::array &lt;System::Threading::Tasks::Task ^&gt; ^ tasks, int millisecondsTimeout, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="static member WaitAll : System.Threading.Tasks.Task[] * int * System.Threading.CancellationToken -&gt; bool" Usage="System.Threading.Tasks.Task.WaitAll (tasks, millisecondsTimeout, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task[]" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="tasks">Matriz de instancias de <see cref="T:System.Threading.Tasks.Task" /> en las que se va a esperar.</param>
        <param name="millisecondsTimeout">Número de milisegundos de espera o <see cref="F:System.Threading.Timeout.Infinite" /> (-1) para esperar indefinidamente.</param>
        <param name="cancellationToken">
          <see cref="P:System.Threading.Tasks.TaskFactory.CancellationToken" /> que se va a observar mientras se espera la finalización de las tareas.</param>
        <summary>Espera a que todos los objetos <see cref="T:System.Threading.Tasks.Task" /> proporcionados completen la ejecución dentro de un número especificado de milisegundos o hasta que se cancele la espera.</summary>
        <returns>Es <see langword="true" /> si la ejecución de todas las instancias de <see cref="T:System.Threading.Tasks.Task" /> se completan en el tiempo asignado; de lo contrario, es <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El `cancellationToken` argumento se utiliza para cancelar la operación de espera. Cancelación de la tarea es una operación distinta y se señaliza mediante el <xref:System.AggregateException> indicados anteriormente.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Al menos se ha eliminado uno de los objetos <see cref="T:System.Threading.Tasks.Task" /> en <paramref name="tasks" />.</exception>
        <exception cref="T:System.ArgumentNullException">El argumento <paramref name="tasks" /> es <see langword="null" />.</exception>
        <exception cref="T:System.AggregateException">Se canceló al menos una de las instancias <see cref="T:System.Threading.Tasks.Task" />. Si una tarea estuviera cancelada, <see cref="T:System.AggregateException" /> contiene <see cref="T:System.OperationCanceledException" /> en su colección <see cref="P:System.AggregateException.InnerExceptions" />.  -o bien- Se inició una excepción durante la ejecución de al menos una de las instancias de <see cref="T:System.Threading.Tasks.Task" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="millisecondsTimeout" /> es un número negativo distinto de -1 que representa un tiempo de espera infinito.</exception>
        <exception cref="T:System.ArgumentException">El argumento <paramref name="tasks" /> contiene un elemento NULL.  -o bien- El argumento <paramref name="tasks" /> es una matriz vacía.</exception>
        <exception cref="T:System.OperationCanceledException">Se canceló <paramref name="cancellationToken" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="WaitAny">
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Espera a que se complete la ejecución de cualquiera de los objetos <see cref="T:System.Threading.Tasks.Task" /> proporcionados.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WaitAny">
      <MemberSignature Language="C#" Value="public static int WaitAny (params System.Threading.Tasks.Task[] tasks);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 WaitAny(class System.Threading.Tasks.Task[] tasks) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.WaitAny(System.Threading.Tasks.Task[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAny (ParamArray tasks As Task()) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int WaitAny(... cli::array &lt;System::Threading::Tasks::Task ^&gt; ^ tasks);" />
      <MemberSignature Language="F#" Value="static member WaitAny : System.Threading.Tasks.Task[] -&gt; int" Usage="System.Threading.Tasks.Task.WaitAny tasks" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="tasks">Matriz de instancias de <see cref="T:System.Threading.Tasks.Task" /> en las que se va a esperar.</param>
        <summary>Espera a que se complete la ejecución de cualquiera de los objetos <see cref="T:System.Threading.Tasks.Task" /> proporcionados.</summary>
        <returns>Índice del objeto <see cref="T:System.Threading.Tasks.Task" /> completado en la matriz <paramref name="tasks" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 En el ejemplo siguiente se inicia tareas de cinco, cada uno de los cuales se suspende durante un mínimo de 50 milisegundos o un máximo de 1050 milisegundos. El <xref:System.Threading.Tasks.Task.WaitAny%2A> método espera a que cualquiera de las tareas que se complete. En el ejemplo se muestra el identificador de tarea de la tarea que finalizó la espera, así como el estado actual de todas las tareas.  
  
 [!code-csharp[System.Threading.Tasks.Task.WaitAny#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Threading.Tasks.Task.WaitAny/cs/WaitAny1.cs#1)]
 [!code-vb[System.Threading.Tasks.Task.WaitAny#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Threading.Tasks.Task.WaitAny/vb/WaitAny1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Se ha eliminado el objeto <see cref="T:System.Threading.Tasks.Task" />.</exception>
        <exception cref="T:System.ArgumentNullException">El argumento <paramref name="tasks" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">El argumento <paramref name="tasks" /> contiene un elemento NULL.</exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAny">
      <MemberSignature Language="C#" Value="public static int WaitAny (System.Threading.Tasks.Task[] tasks, int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 WaitAny(class System.Threading.Tasks.Task[] tasks, int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.WaitAny(System.Threading.Tasks.Task[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAny (tasks As Task(), millisecondsTimeout As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int WaitAny(cli::array &lt;System::Threading::Tasks::Task ^&gt; ^ tasks, int millisecondsTimeout);" />
      <MemberSignature Language="F#" Value="static member WaitAny : System.Threading.Tasks.Task[] * int -&gt; int" Usage="System.Threading.Tasks.Task.WaitAny (tasks, millisecondsTimeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task[]" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="tasks">Matriz de instancias de <see cref="T:System.Threading.Tasks.Task" /> en las que se va a esperar.</param>
        <param name="millisecondsTimeout">Número de milisegundos de espera o <see cref="F:System.Threading.Timeout.Infinite" /> (-1) para esperar indefinidamente.</param>
        <summary>Espera a que cualquier objeto proporcionado de <see cref="T:System.Threading.Tasks.Task" /> complete la ejecución dentro de un número de milisegundos.</summary>
        <returns>Índice de la tarea completada en la matriz especificada por el parámetro <paramref name="tasks" /> o -1 si se agotó el tiempo de espera.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException">Se ha eliminado el objeto <see cref="T:System.Threading.Tasks.Task" />.</exception>
        <exception cref="T:System.ArgumentNullException">El argumento <paramref name="tasks" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="millisecondsTimeout" /> es un número negativo distinto de -1 que representa un tiempo de espera infinito.</exception>
        <exception cref="T:System.ArgumentException">El argumento <paramref name="tasks" /> contiene un elemento NULL.</exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAny">
      <MemberSignature Language="C#" Value="public static int WaitAny (System.Threading.Tasks.Task[] tasks, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 WaitAny(class System.Threading.Tasks.Task[] tasks, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.WaitAny(System.Threading.Tasks.Task[],System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int WaitAny(cli::array &lt;System::Threading::Tasks::Task ^&gt; ^ tasks, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="static member WaitAny : System.Threading.Tasks.Task[] * System.Threading.CancellationToken -&gt; int" Usage="System.Threading.Tasks.Task.WaitAny (tasks, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task[]" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="tasks">Matriz de instancias de <see cref="T:System.Threading.Tasks.Task" /> en las que se va a esperar.</param>
        <param name="cancellationToken">
          <see cref="P:System.Threading.Tasks.TaskFactory.CancellationToken" /> que se va a observar mientras se espera la finalización de una tarea.</param>
        <summary>Espera que se complete la ejecución de cualquiera de los objetos <see cref="T:System.Threading.Tasks.Task" /> proporcionados, a menos que se cancele la espera.</summary>
        <returns>Índice de la tarea completada en la matriz especificada por el parámetro <paramref name="tasks" />.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException">Se ha eliminado el objeto <see cref="T:System.Threading.Tasks.Task" />.</exception>
        <exception cref="T:System.ArgumentNullException">El argumento <paramref name="tasks" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">El argumento <paramref name="tasks" /> contiene un elemento NULL.</exception>
        <exception cref="T:System.OperationCanceledException">Se canceló <paramref name="cancellationToken" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAny">
      <MemberSignature Language="C#" Value="public static int WaitAny (System.Threading.Tasks.Task[] tasks, TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 WaitAny(class System.Threading.Tasks.Task[] tasks, valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.WaitAny(System.Threading.Tasks.Task[],System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAny (tasks As Task(), timeout As TimeSpan) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int WaitAny(cli::array &lt;System::Threading::Tasks::Task ^&gt; ^ tasks, TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="static member WaitAny : System.Threading.Tasks.Task[] * TimeSpan -&gt; int" Usage="System.Threading.Tasks.Task.WaitAny (tasks, timeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task[]" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="tasks">Matriz de instancias de <see cref="T:System.Threading.Tasks.Task" /> en las que se va a esperar.</param>
        <param name="timeout">Estructura <see cref="T:System.TimeSpan" /> que representa el número de milisegundos de espera o estructura <see cref="T:System.TimeSpan" /> que representa -1 milisegundos para esperar indefinidamente.</param>
        <summary>Espera a que cualquier objeto proporcionado de <see cref="T:System.Threading.Tasks.Task" /> complete la ejecución en un intervalo de tiempo especificado.</summary>
        <returns>Índice de la tarea completada en la matriz especificada por el parámetro <paramref name="tasks" /> o -1 si se agotó el tiempo de espera.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException">Se ha eliminado el objeto <see cref="T:System.Threading.Tasks.Task" />.</exception>
        <exception cref="T:System.ArgumentNullException">El argumento <paramref name="tasks" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="timeout" /> es un número negativo distinto de -1 milisegundo, que representa un tiempo de espera infinito. -o bien- <paramref name="timeout" /> es mayor de <see cref="F:System.Int32.MaxValue" />.</exception>
        <exception cref="T:System.ArgumentException">El argumento <paramref name="tasks" /> contiene un elemento NULL.</exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAny">
      <MemberSignature Language="C#" Value="public static int WaitAny (System.Threading.Tasks.Task[] tasks, int millisecondsTimeout, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 WaitAny(class System.Threading.Tasks.Task[] tasks, int32 millisecondsTimeout, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.WaitAny(System.Threading.Tasks.Task[],System.Int32,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int WaitAny(cli::array &lt;System::Threading::Tasks::Task ^&gt; ^ tasks, int millisecondsTimeout, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="static member WaitAny : System.Threading.Tasks.Task[] * int * System.Threading.CancellationToken -&gt; int" Usage="System.Threading.Tasks.Task.WaitAny (tasks, millisecondsTimeout, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task[]" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="tasks">Matriz de instancias de <see cref="T:System.Threading.Tasks.Task" /> en las que se va a esperar.</param>
        <param name="millisecondsTimeout">Número de milisegundos de espera o <see cref="F:System.Threading.Timeout.Infinite" /> (-1) para esperar indefinidamente.</param>
        <param name="cancellationToken">
          <see cref="P:System.Threading.Tasks.TaskFactory.CancellationToken" /> que se va a observar mientras se espera la finalización de una tarea.</param>
        <summary>Espera a que cualquiera de los objetos <see cref="T:System.Threading.Tasks.Task" /> proporcionados complete la ejecución dentro de un número especificado de milisegundos o hasta que se cancele un token de cancelación.</summary>
        <returns>Índice de la tarea completada en la matriz especificada por el parámetro <paramref name="tasks" /> o -1 si se agotó el tiempo de espera.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException">Se ha eliminado el objeto <see cref="T:System.Threading.Tasks.Task" />.</exception>
        <exception cref="T:System.ArgumentNullException">El argumento <paramref name="tasks" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="millisecondsTimeout" /> es un número negativo distinto de -1 que representa un tiempo de espera infinito.</exception>
        <exception cref="T:System.ArgumentException">El argumento <paramref name="tasks" /> contiene un elemento null.</exception>
        <exception cref="T:System.OperationCanceledException">Se canceló <paramref name="cancellationToken" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="WhenAll">
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Crea una tarea que se completará cuando se hayan completado todas las tareas proporcionadas.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WhenAll">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task WhenAll (System.Collections.Generic.IEnumerable&lt;System.Threading.Tasks.Task&gt; tasks);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task WhenAll(class System.Collections.Generic.IEnumerable`1&lt;class System.Threading.Tasks.Task&gt; tasks) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.WhenAll(System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WhenAll (tasks As IEnumerable(Of Task)) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Tasks::Task ^ WhenAll(System::Collections::Generic::IEnumerable&lt;System::Threading::Tasks::Task ^&gt; ^ tasks);" />
      <MemberSignature Language="F#" Value="static member WhenAll : seq&lt;System.Threading.Tasks.Task&gt; -&gt; System.Threading.Tasks.Task" Usage="System.Threading.Tasks.Task.WhenAll tasks" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tasks" Type="System.Collections.Generic.IEnumerable&lt;System.Threading.Tasks.Task&gt;" />
      </Parameters>
      <Docs>
        <param name="tasks">Tareas cuya finalización hay que esperar.</param>
        <summary>Crea una tarea que se completará cuando todos los objetos <see cref="T:System.Threading.Tasks.Task" /> de una colección enumerable se hayan completado.</summary>
        <returns>Tarea que representa la finalización de todas las tareas proporcionadas.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Las sobrecargas de la <xref:System.Threading.Tasks.Task.WhenAll%2A> método que devuelve un <xref:System.Threading.Tasks.Task> objeto se suelen denominar simplemente cuando está interesado en el estado de un conjunto de tareas o en las excepciones producidas por un conjunto de tareas.  
  
> [!NOTE]
>  La llamada a <xref:System.Threading.Tasks.Task.WhenAll%28System.Collections.Generic.IEnumerable%7BSystem.Threading.Tasks.Task%7D%29> método no bloquea el subproceso que realiza la llamada.  
  
 Si cualquiera de las tareas proporcionadas se completa con un estado de error, la tarea devuelta también finalizará con un <xref:System.Threading.Tasks.TaskStatus.Faulted> estado, donde sus excepciones contendrá la agregación del conjunto de excepciones sin ajustar de cada una de las tareas proporcionadas.  
  
 Si ninguna de las tareas proporcionadas con errores, pero al menos uno de ellos se ha cancelado, la tarea devuelta finalizará en el <xref:System.Threading.Tasks.TaskStatus.Canceled> estado.  
  
 Si ninguna de las tareas con errores y ninguna de las tareas se han cancelado, la tarea resultante finalizará en el <xref:System.Threading.Tasks.TaskStatus.RanToCompletion> estado.  
  
 Si el proporcionado matriz/enumerable no contenga ninguna tarea, la tarea devuelta cambiará inmediatamente a un <xref:System.Threading.Tasks.TaskStatus.RanToCompletion> estado antes de que se devuelve al llamador.  
  
   
  
## Examples  
 En el ejemplo siguiente se crea un conjunto de tareas que hacer ping a las direcciones URL en una matriz. Las tareas se almacenan en un `List<Task>` colección que se pasa a la <xref:System.Threading.Tasks.Task.WhenAll%28System.Collections.Generic.IEnumerable%7BSystem.Threading.Tasks.Task%7D%29> método. Después de llamar a la <xref:System.Threading.Tasks.Task.Wait%2A> método se asegura de que han completado todos los subprocesos, en el ejemplo se examina la <xref:System.Threading.Tasks.Task.Status%2A?displayProperty=nameWithType> propiedad para determinar si las tareas se generó un error.  
  
 [!code-csharp[System.Threading.Tasks.Task.WhenAll#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.whenall/cs/WhenAll4.cs#4)]
 [!code-vb[System.Threading.Tasks.Task.WhenAll#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.whenall/vb/WhenAll4.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El argumento <paramref name="tasks" /> era <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">La colección <paramref name="tasks" /> contiene una tarea <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="WhenAll">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task WhenAll (params System.Threading.Tasks.Task[] tasks);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task WhenAll(class System.Threading.Tasks.Task[] tasks) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.WhenAll(System.Threading.Tasks.Task[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WhenAll (ParamArray tasks As Task()) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Tasks::Task ^ WhenAll(... cli::array &lt;System::Threading::Tasks::Task ^&gt; ^ tasks);" />
      <MemberSignature Language="F#" Value="static member WhenAll : System.Threading.Tasks.Task[] -&gt; System.Threading.Tasks.Task" Usage="System.Threading.Tasks.Task.WhenAll tasks" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="tasks">Tareas cuya finalización hay que esperar.</param>
        <summary>Crea una tarea que se completará cuando todos los objetos <see cref="T:System.Threading.Tasks.Task" /> de una matriz se hayan completado.</summary>
        <returns>Tarea que representa la finalización de todas las tareas proporcionadas.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Las sobrecargas de la <xref:System.Threading.Tasks.Task.WhenAll%2A> método que devuelve un <xref:System.Threading.Tasks.Task> objeto se suelen denominar simplemente cuando está interesado en el estado de un conjunto de tareas o en las excepciones producidas por un conjunto de tareas.  
  
> [!NOTE]
>  La llamada a <xref:System.Threading.Tasks.Task.WhenAll%28System.Threading.Tasks.Task%5B%5D%29> método no bloquea el subproceso que realiza la llamada.  
  
 Si cualquiera de las tareas proporcionadas se completa con un estado de error, la tarea devuelta también finalizará con un <xref:System.Threading.Tasks.TaskStatus.Faulted> estado, donde sus excepciones contendrá la agregación del conjunto de excepciones sin ajustar de cada una de las tareas proporcionadas.  
  
 Si ninguna de las tareas proporcionadas con errores, pero al menos uno de ellos se ha cancelado, la tarea devuelta finalizará en el <xref:System.Threading.Tasks.TaskStatus.Canceled> estado.  
  
 Si ninguna de las tareas con errores y ninguna de las tareas se han cancelado, la tarea resultante finalizará en el <xref:System.Threading.Tasks.TaskStatus.RanToCompletion> estado.  
  
 Si el proporcionado matriz/enumerable no contenga ninguna tarea, la tarea devuelta cambiará inmediatamente a un <xref:System.Threading.Tasks.TaskStatus.RanToCompletion> estado antes de que se devuelve al llamador.  
  
   
  
## Examples  
 En el ejemplo siguiente se crea un conjunto de tareas que hacer ping a las direcciones URL en una matriz. Las tareas se almacenan en un `List<Task>` colección que se convierte en una matriz y se pasa a la <xref:System.Threading.Tasks.Task.WhenAll%28System.Collections.Generic.IEnumerable%7BSystem.Threading.Tasks.Task%7D%29> método. Después de llamar a la <xref:System.Threading.Tasks.Task.Wait%2A> método se asegura de que han completado todos los subprocesos, en el ejemplo se examina la <xref:System.Threading.Tasks.Task.Status%2A?displayProperty=nameWithType> propiedad para determinar si las tareas se generó un error.  
  
 [!code-csharp[System.Threading.Tasks.Task.WhenAll#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.whenall/cs/WhenAll3.cs#3)]
 [!code-vb[System.Threading.Tasks.Task.WhenAll#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.whenall/vb/WhenAll3.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El argumento <paramref name="tasks" /> era <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">La matriz <paramref name="tasks" /> contiene una tarea <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="WhenAll&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task&lt;TResult[]&gt; WhenAll&lt;TResult&gt; (System.Collections.Generic.IEnumerable&lt;System.Threading.Tasks.Task&lt;TResult&gt;&gt; tasks);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task`1&lt;!!TResult[]&gt; WhenAll&lt;TResult&gt;(class System.Collections.Generic.IEnumerable`1&lt;class System.Threading.Tasks.Task`1&lt;!!TResult&gt;&gt; tasks) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.WhenAll``1(System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task{``0}})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WhenAll(Of TResult) (tasks As IEnumerable(Of Task(Of TResult))) As Task(Of TResult())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; static System::Threading::Tasks::Task&lt;cli::array &lt;TResult&gt; ^&gt; ^ WhenAll(System::Collections::Generic::IEnumerable&lt;System::Threading::Tasks::Task&lt;TResult&gt; ^&gt; ^ tasks);" />
      <MemberSignature Language="F#" Value="static member WhenAll : seq&lt;System.Threading.Tasks.Task&lt;'Result&gt;&gt; -&gt; System.Threading.Tasks.Task&lt;'Result[]&gt;" Usage="System.Threading.Tasks.Task.WhenAll tasks" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult[]&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="tasks" Type="System.Collections.Generic.IEnumerable&lt;System.Threading.Tasks.Task&lt;TResult&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">Tipo de la tarea completada.</typeparam>
        <param name="tasks">Tareas cuya finalización hay que esperar.</param>
        <summary>Crea una tarea que se completará cuando todos los objetos <see cref="T:System.Threading.Tasks.Task`1" /> de una colección enumerable se hayan completado.</summary>
        <returns>Tarea que representa la finalización de todas las tareas proporcionadas.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La llamada a <xref:System.Threading.Tasks.Task.WhenAll%60%601%28System.Collections.Generic.IEnumerable%7BSystem.Threading.Tasks.Task%7B%60%600%7D%7D%29> método no bloquea el subproceso que realiza la llamada. Sin embargo, una llamada a devuelto <xref:System.Threading.Tasks.Task%601.Result%2A> propiedad bloquea el subproceso que realiza la llamada.  
  
 Si cualquiera de las tareas proporcionadas se completa con un estado de error, la tarea devuelta también finalizará con un <xref:System.Threading.Tasks.TaskStatus.Faulted> estado, donde sus excepciones contendrá la agregación del conjunto de excepciones sin ajustar de cada una de las tareas proporcionadas.  
  
 Si ninguna de las tareas proporcionadas con errores, pero al menos uno de ellos se ha cancelado, la tarea devuelta finalizará en el <xref:System.Threading.Tasks.TaskStatus.Canceled> estado.  
  
 Si ninguna de las tareas con errores y ninguna de las tareas se han cancelado, la tarea resultante finalizará en el <xref:System.Threading.Tasks.TaskStatus.RanToCompletion> estado.  El <xref:System.Threading.Tasks.Task%601.Result%2A?displayProperty=nameWithType> se establecerá la propiedad de la tarea devuelta a una matriz que contiene todos los resultados de las tareas proporcionadas en el mismo orden como se proporcionan (por ejemplo, si la entrada tareas matriz incluida t1, t2, t3, la tarea de salida <xref:System.Threading.Tasks.Task%601.Result%2A?displayProperty=nameWithType> propiedad devolverá un `TResult[]` donde `arr[0] == t1.Result, arr[1] == t2.Result, and arr[2] == t3.Result)`.  
  
 Si el `tasks` argumento no contiene ninguna tarea, la tarea devuelta cambiará inmediatamente a un <xref:System.Threading.Tasks.TaskStatus.RanToCompletion> estado antes de que se devuelve al llamador. El valor devuelto `TResult[]` será una matriz de 0 elementos.  
  
   
  
## Examples  
 En el ejemplo siguiente se crea diez tareas, cada uno de los cuales crea una instancia de un generador de números aleatorios que crea 1.000 números aleatorios entre 1 y 1.000 y calcula su Media. El <xref:System.Threading.Tasks.Task.Delay%28System.Int32%29> método se usa para retrasar la creación de instancias de los generadores de números aleatorios para que no se crean con valores de inicialización idénticos. La llamada a la <xref:System.Threading.Tasks.Task.WhenAll%2A> método, a continuación, devuelve un <xref:System.Int64> matriz que contiene el promedio calculado por cada tarea. A continuación, estos se utilizan para calcular la media general.  
  
 [!code-csharp[System.Threading.Tasks.Task.WhenAll#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.whenall/cs/whenall1.cs#1)]
 [!code-vb[System.Threading.Tasks.Task.WhenAll#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.whenall/vb/whenall1.vb#1)]  
  
 En este caso, se almacenan las diez tareas individuales en un <xref:System.Collections.Generic.List%601> objeto. <xref:System.Collections.Generic.List%601> implementa la interfaz <xref:System.Collections.Generic.IEnumerable%601>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El argumento <paramref name="tasks" /> era <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">La colección <paramref name="tasks" /> contiene una tarea <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="WhenAll&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task&lt;TResult[]&gt; WhenAll&lt;TResult&gt; (params System.Threading.Tasks.Task&lt;TResult&gt;[] tasks);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task`1&lt;!!TResult[]&gt; WhenAll&lt;TResult&gt;(class System.Threading.Tasks.Task`1&lt;!!TResult&gt;[] tasks) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.WhenAll``1(System.Threading.Tasks.Task{``0}[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WhenAll(Of TResult) (ParamArray tasks As Task(Of TResult)()) As Task(Of TResult())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; static System::Threading::Tasks::Task&lt;cli::array &lt;TResult&gt; ^&gt; ^ WhenAll(... cli::array &lt;System::Threading::Tasks::Task&lt;TResult&gt; ^&gt; ^ tasks);" />
      <MemberSignature Language="F#" Value="static member WhenAll : System.Threading.Tasks.Task&lt;'Result&gt;[] -&gt; System.Threading.Tasks.Task&lt;'Result[]&gt;" Usage="System.Threading.Tasks.Task.WhenAll tasks" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult[]&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task&lt;TResult&gt;[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="TResult">Tipo de la tarea completada.</typeparam>
        <param name="tasks">Tareas cuya finalización hay que esperar.</param>
        <summary>Crea una tarea que se completará cuando todos los objetos <see cref="T:System.Threading.Tasks.Task`1" /> de una matriz se hayan completado.</summary>
        <returns>Tarea que representa la finalización de todas las tareas proporcionadas.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La llamada a <xref:System.Threading.Tasks.Task.WhenAll%60%601%28System.Threading.Tasks.Task%7B%60%600%7D%5B%5D%29> método no bloquea el subproceso que realiza la llamada. Sin embargo, una llamada a devuelto <xref:System.Threading.Tasks.Task%601.Result%2A> propiedad bloquea el subproceso que realiza la llamada.  
  
 Si cualquiera de las tareas proporcionadas se completa con un estado de error, la tarea devuelta también finalizará con un <xref:System.Threading.Tasks.TaskStatus.Faulted> estado, donde sus excepciones contendrá la agregación del conjunto de excepciones sin ajustar de cada una de las tareas proporcionadas.  
  
 Si ninguna de las tareas proporcionadas con errores, pero al menos uno de ellos se ha cancelado, la tarea devuelta finalizará en el <xref:System.Threading.Tasks.TaskStatus.Canceled> estado.  
  
 Si ninguna de las tareas con errores y ninguna de las tareas se han cancelado, la tarea resultante finalizará en el <xref:System.Threading.Tasks.TaskStatus.RanToCompletion> estado.  El <xref:System.Threading.Tasks.Task%601.Result%2A> de la tarea devuelta se establecerá en una matriz que contiene todos los resultados de las tareas proporcionadas en el mismo orden como se proporcionan (por ejemplo, si la entrada tareas matriz incluida t1, t2, t3, la tarea de salida <xref:System.Threading.Tasks.Task%601.Result%2A> devolverá un `TResult[]` donde `arr[0] == t1.Result, arr[1] == t2.Result, and arr[2] == t3.Result)`.  
  
 Si el proporcionado matriz/enumerable no contenga ninguna tarea, la tarea devuelta cambiará inmediatamente a un <xref:System.Threading.Tasks.TaskStatus.RanToCompletion> estado antes de que se devuelve al llamador.  El valor devuelto `TResult[]` será una matriz de 0 elementos.  
  
   
  
## Examples  
 En el ejemplo siguiente se crea diez tareas, cada uno de los cuales crea una instancia de un generador de números aleatorios que crea 1.000 números aleatorios entre 1 y 1.000 y calcula su Media. En este caso, se almacenan las diez tareas individuales en un `Task<Int64>` matriz.  El <xref:System.Threading.Tasks.Task.Delay%28System.Int32%29> método se usa para retrasar la creación de instancias de los generadores de números aleatorios para que no se crean con valores de inicialización idénticos. La llamada a la <xref:System.Threading.Tasks.Task.WhenAll%2A> método, a continuación, devuelve un <xref:System.Int64> matriz que contiene el promedio calculado por cada tarea. A continuación, estos se utilizan para calcular la media general.  
  
 [!code-csharp[System.Threading.Tasks.Task.WhenAll#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.whenall/cs/whenall2.cs#2)]
 [!code-vb[System.Threading.Tasks.Task.WhenAll#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.whenall/vb/whenall2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El argumento <paramref name="tasks" /> era <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">La matriz <paramref name="tasks" /> contiene una tarea <see langword="null" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="WhenAny">
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Crea una tarea que se completará cuando se haya completado cualquiera de las tareas proporcionadas.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WhenAny">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task&lt;System.Threading.Tasks.Task&gt; WhenAny (System.Collections.Generic.IEnumerable&lt;System.Threading.Tasks.Task&gt; tasks);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task`1&lt;class System.Threading.Tasks.Task&gt; WhenAny(class System.Collections.Generic.IEnumerable`1&lt;class System.Threading.Tasks.Task&gt; tasks) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.WhenAny(System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WhenAny (tasks As IEnumerable(Of Task)) As Task(Of Task)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Tasks::Task&lt;System::Threading::Tasks::Task ^&gt; ^ WhenAny(System::Collections::Generic::IEnumerable&lt;System::Threading::Tasks::Task ^&gt; ^ tasks);" />
      <MemberSignature Language="F#" Value="static member WhenAny : seq&lt;System.Threading.Tasks.Task&gt; -&gt; System.Threading.Tasks.Task&lt;System.Threading.Tasks.Task&gt;" Usage="System.Threading.Tasks.Task.WhenAny tasks" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Threading.Tasks.Task&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tasks" Type="System.Collections.Generic.IEnumerable&lt;System.Threading.Tasks.Task&gt;" />
      </Parameters>
      <Docs>
        <param name="tasks">Tareas cuya finalización hay que esperar.</param>
        <summary>Crea una tarea que se completará cuando se haya completado cualquiera de las tareas proporcionadas.</summary>
        <returns>Tarea que representa la finalización de una de las tareas proporcionadas.  El resultado de la tarea devuelto es la tarea completada.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La tarea devuelta completará cuando haya completado cualquiera de las tareas proporcionadas.  La tarea devuelta finalizará siempre en el `RanToCompletion` estado con su conjunto de resultados a la primera tarea para completar.  Esto es cierto incluso si ha finalizado la primera tarea para completar con el `Canceled` o `Faulted` estado.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El argumento <paramref name="tasks" /> era <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">La matriz <paramref name="tasks" /> contenía una tarea NULL o estaba vacía.</exception>
      </Docs>
    </Member>
    <Member MemberName="WhenAny">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task&lt;System.Threading.Tasks.Task&gt; WhenAny (params System.Threading.Tasks.Task[] tasks);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task`1&lt;class System.Threading.Tasks.Task&gt; WhenAny(class System.Threading.Tasks.Task[] tasks) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.WhenAny(System.Threading.Tasks.Task[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WhenAny (ParamArray tasks As Task()) As Task(Of Task)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Tasks::Task&lt;System::Threading::Tasks::Task ^&gt; ^ WhenAny(... cli::array &lt;System::Threading::Tasks::Task ^&gt; ^ tasks);" />
      <MemberSignature Language="F#" Value="static member WhenAny : System.Threading.Tasks.Task[] -&gt; System.Threading.Tasks.Task&lt;System.Threading.Tasks.Task&gt;" Usage="System.Threading.Tasks.Task.WhenAny tasks" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Threading.Tasks.Task&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="tasks">Tareas cuya finalización hay que esperar.</param>
        <summary>Crea una tarea que se completará cuando se haya completado cualquiera de las tareas proporcionadas.</summary>
        <returns>Tarea que representa la finalización de una de las tareas proporcionadas.  El resultado de la tarea devuelto es la tarea completada.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La tarea devuelta completará cuando haya completado cualquiera de las tareas proporcionadas.  La tarea devuelta finalizará siempre en el `RanToCompletion` estado con su `Result` se establece en la primera tarea para completar.  Esto es cierto incluso si ha finalizado la primera tarea para completar con el `Canceled` o `Faulted` estado.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El argumento de <paramref name="tasks" /> fue nulo.</exception>
        <exception cref="T:System.ArgumentException">La matriz <paramref name="tasks" /> contenía una tarea NULL o estaba vacía.</exception>
      </Docs>
    </Member>
    <Member MemberName="WhenAny&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task&lt;System.Threading.Tasks.Task&lt;TResult&gt;&gt; WhenAny&lt;TResult&gt; (System.Collections.Generic.IEnumerable&lt;System.Threading.Tasks.Task&lt;TResult&gt;&gt; tasks);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task`1&lt;class System.Threading.Tasks.Task`1&lt;!!TResult&gt;&gt; WhenAny&lt;TResult&gt;(class System.Collections.Generic.IEnumerable`1&lt;class System.Threading.Tasks.Task`1&lt;!!TResult&gt;&gt; tasks) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.WhenAny``1(System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task{``0}})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WhenAny(Of TResult) (tasks As IEnumerable(Of Task(Of TResult))) As Task(Of Task(Of TResult))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; static System::Threading::Tasks::Task&lt;System::Threading::Tasks::Task&lt;TResult&gt; ^&gt; ^ WhenAny(System::Collections::Generic::IEnumerable&lt;System::Threading::Tasks::Task&lt;TResult&gt; ^&gt; ^ tasks);" />
      <MemberSignature Language="F#" Value="static member WhenAny : seq&lt;System.Threading.Tasks.Task&lt;'Result&gt;&gt; -&gt; System.Threading.Tasks.Task&lt;System.Threading.Tasks.Task&lt;'Result&gt;&gt;" Usage="System.Threading.Tasks.Task.WhenAny tasks" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Threading.Tasks.Task&lt;TResult&gt;&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="tasks" Type="System.Collections.Generic.IEnumerable&lt;System.Threading.Tasks.Task&lt;TResult&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">Tipo de la tarea completada.</typeparam>
        <param name="tasks">Tareas cuya finalización hay que esperar.</param>
        <summary>Crea una tarea que se completará cuando se haya completado cualquiera de las tareas proporcionadas.</summary>
        <returns>Tarea que representa la finalización de una de las tareas proporcionadas.  El resultado de la tarea devuelto es la tarea completada.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La tarea devuelta completará cuando haya completado cualquiera de las tareas proporcionadas.  La tarea devuelta finalizará siempre en el estado RanToCompletion con su conjunto de resultados a la primera tarea para completar. Esto es cierto incluso si ha finalizado la primera tarea para completar con el estado cancelado o con errores.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El argumento <paramref name="tasks" /> era <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">La matriz <paramref name="tasks" /> contenía una tarea NULL o estaba vacía.</exception>
      </Docs>
    </Member>
    <Member MemberName="WhenAny&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task&lt;System.Threading.Tasks.Task&lt;TResult&gt;&gt; WhenAny&lt;TResult&gt; (params System.Threading.Tasks.Task&lt;TResult&gt;[] tasks);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task`1&lt;class System.Threading.Tasks.Task`1&lt;!!TResult&gt;&gt; WhenAny&lt;TResult&gt;(class System.Threading.Tasks.Task`1&lt;!!TResult&gt;[] tasks) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.WhenAny``1(System.Threading.Tasks.Task{``0}[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WhenAny(Of TResult) (ParamArray tasks As Task(Of TResult)()) As Task(Of Task(Of TResult))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; static System::Threading::Tasks::Task&lt;System::Threading::Tasks::Task&lt;TResult&gt; ^&gt; ^ WhenAny(... cli::array &lt;System::Threading::Tasks::Task&lt;TResult&gt; ^&gt; ^ tasks);" />
      <MemberSignature Language="F#" Value="static member WhenAny : System.Threading.Tasks.Task&lt;'Result&gt;[] -&gt; System.Threading.Tasks.Task&lt;System.Threading.Tasks.Task&lt;'Result&gt;&gt;" Usage="System.Threading.Tasks.Task.WhenAny tasks" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Threading.Tasks.Task&lt;TResult&gt;&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task&lt;TResult&gt;[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="TResult">Tipo de la tarea completada.</typeparam>
        <param name="tasks">Tareas cuya finalización hay que esperar.</param>
        <summary>Crea una tarea que se completará cuando se haya completado cualquiera de las tareas proporcionadas.</summary>
        <returns>Tarea que representa la finalización de una de las tareas proporcionadas.  El resultado de la tarea devuelto es la tarea completada.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La tarea devuelta completará cuando haya completado cualquiera de las tareas proporcionadas.  La tarea devuelta finalizará siempre en el estado RanToCompletion con su conjunto de resultados a la primera tarea para completar. Esto es cierto incluso si ha finalizado la primera tarea para completar con el estado cancelado o con errores.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El argumento de <paramref name="tasks" /> fue nulo.</exception>
        <exception cref="T:System.ArgumentException">La matriz <paramref name="tasks" /> contenía una tarea NULL o estaba vacía.</exception>
      </Docs>
    </Member>
    <Member MemberName="Yield">
      <MemberSignature Language="C#" Value="public static System.Runtime.CompilerServices.YieldAwaitable Yield ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Runtime.CompilerServices.YieldAwaitable Yield() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.Yield" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Yield () As YieldAwaitable" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Runtime::CompilerServices::YieldAwaitable Yield();" />
      <MemberSignature Language="F#" Value="static member Yield : unit -&gt; System.Runtime.CompilerServices.YieldAwaitable" Usage="System.Threading.Tasks.Task.Yield " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.CompilerServices.YieldAwaitable</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Crea una tarea que admite "await" que, de forma asincrónica, devuelve al contexto actual cuando es "awaited".</summary>
        <returns>Contexto que, cuando se espera, hará la transición de vuelta de forma asincrónica en el contexto actual en el momento de la espera. Si el objeto <see cref="T:System.Threading.SynchronizationContext" /> actual no es null, se trata como el contexto actual. Si no, el programador de tareas que está asociado a la tarea que se está ejecutando actualmente se trata como el contexto actual.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Puede usar `await Task.Yield();` en un método asincrónico para aplicar el método para completar de forma asincrónica. Si no hay un contexto de sincronización actual (<xref:System.Threading.SynchronizationContext> objeto), se registrará el resto de la ejecución del método a ese contexto. Sin embargo, el contexto que decida cómo asignar prioridades a este trabajo en relación con otro trabajo que puede estar pendiente. El contexto de sincronización que se encuentra en un subproceso de interfaz de usuario en la mayoría de los entornos de interfaz de usuario a menudo priorizar el trabajo que se publican en el contexto de mayor que la entrada y el trabajo de representación. Por esta razón, no debe confiar en que `await Task.Yield();` que una interfaz de usuario siga respondiendo.  Para obtener más información, vea la entrada [útil abstracciones habilitada con el método ContinueWith](http://blogs.msdn.com/b/pfxteam/archive/2008/07/23/8768673.aspx) en la programación en paralelo con .NET blog.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>