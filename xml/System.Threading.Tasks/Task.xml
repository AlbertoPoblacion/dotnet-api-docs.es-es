<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="Task.xml" source-language="en-US" target-language="es-ES">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-15c36f0" tool-company="Microsoft" />
      <xliffext:skl_file_name xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">02cd5861-7ce2-4a82-b358-31f8435a0ac5d920b17ab80db20fab0e3101b745858eade81dd1.skl</xliffext:skl_file_name>
      <xliffext:version xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">1.2</xliffext:version>
      <xliffext:ms.openlocfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">d920b17ab80db20fab0e3101b745858eade81dd1</xliffext:ms.openlocfilehash>
      <xliffext:ms.sourcegitcommit xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b</xliffext:ms.sourcegitcommit>
      <xliffext:ms.lasthandoff xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">04/03/2018</xliffext:ms.lasthandoff>
      <xliffext:moniker_ids xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">netcore-1.0,netcore-1.1,netcore-2.0,netcore-2.1,netframework-4.5.1,netframework-4.5.2,netframework-4.5,netframework-4.6.1,netframework-4.6.2,netframework-4.6,netframework-4.7.1,netframework-4.7,netstandard-1.0,netstandard-1.1,netstandard-1.2,netstandard-1.3,netstandard-1.4,netstandard-1.6,netstandard-2.0,xamarinandroid-7.1,xamarinios-10.8,xamarinmac-3.0</xliffext:moniker_ids>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve" uid="T:System.Threading.Tasks.Task">
          <source>Represents an asynchronous operation.</source>
          <target state="translated">Representa una operación asincrónica.</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.Task">
          <source>The <ph id="ph1">&lt;xref:System.Threading.Tasks.Task&gt;</ph> class represents a single operation that does not return a value and that usually executes asynchronously.</source>
          <target state="translated">La <ph id="ph1">&lt;xref:System.Threading.Tasks.Task&gt;</ph> clase representa una única operación que no devuelve un valor y que normalmente se ejecuta de forma asincrónica.</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.Task">
          <source><ph id="ph1">&lt;xref:System.Threading.Tasks.Task&gt;</ph> objects are one of the central components of the  <bpt id="p1">[</bpt>task-based asynchronous pattern<ept id="p1">](~/docs/standard/asynchronous-programming-patterns/task-based-asynchronous-pattern-tap.md)</ept> first introduced in the .NET Framework 4.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Threading.Tasks.Task&gt;</ph> los objetos son uno de los componentes centrales de la <bpt id="p1">[</bpt>modelo asincrónico basado en tareas<ept id="p1">](~/docs/standard/asynchronous-programming-patterns/task-based-asynchronous-pattern-tap.md)</ept> inicialmente se introdujo en .NET Framework 4.</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.Task">
          <source>Because the work performed by a <ph id="ph1">&lt;xref:System.Threading.Tasks.Task&gt;</ph> object typically executes asynchronously on a thread pool thread rather than synchronously on the main application thread, you can use the <ph id="ph2">&lt;xref:System.Threading.Tasks.Task.Status%2A&gt;</ph> property, as well as the <ph id="ph3">&lt;xref:System.Threading.Tasks.Task.IsCanceled%2A&gt;</ph>, <ph id="ph4">&lt;xref:System.Threading.Tasks.Task.IsCompleted%2A&gt;</ph>, and <ph id="ph5">&lt;xref:System.Threading.Tasks.Task.IsFaulted%2A&gt;</ph> properties, to determine the   state of a task.</source>
          <target state="translated">Dado que el trabajo realizado por un <ph id="ph1">&lt;xref:System.Threading.Tasks.Task&gt;</ph> objeto normalmente ejecuta de forma asincrónica en un subproceso del grupo en lugar de forma sincrónica en el subproceso de aplicación principal, puede usar el <ph id="ph2">&lt;xref:System.Threading.Tasks.Task.Status%2A&gt;</ph> propiedad, así como el <ph id="ph3">&lt;xref:System.Threading.Tasks.Task.IsCanceled%2A&gt;</ph>, <ph id="ph4">&lt;xref:System.Threading.Tasks.Task.IsCompleted%2A&gt;</ph>, y <ph id="ph5">&lt;xref:System.Threading.Tasks.Task.IsFaulted%2A&gt;</ph> propiedades para determinar el estado de una tarea.</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.Task">
          <source>Most commonly, a lambda expression is used to specify the work that the task is to perform.</source>
          <target state="translated">Normalmente, se utiliza una expresión lambda para especificar el trabajo que debe realizar la tarea.</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.Task">
          <source>For operations that return values, you use the <ph id="ph1">&lt;xref:System.Threading.Tasks.Task%601&gt;</ph> class.</source>
          <target state="translated">Para las operaciones que devuelven valores, utilice la <ph id="ph1">&lt;xref:System.Threading.Tasks.Task%601&gt;</ph> clase.</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.Task">
          <source>In this section:</source>
          <target state="translated">En esta sección:</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.Task">
          <source><bpt id="p1">[</bpt>Task instantiation examples<ept id="p1">](#Instant)</ept><ph id="ph1"> </ph></source>
          <target state="translated"><bpt id="p1">[</bpt>Ejemplos de creación de instancias de la tarea<ept id="p1">](#Instant)</ept><ph id="ph1"> </ph></target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.Task">
          <source><bpt id="p1">[</bpt>Creating and executing a task<ept id="p1">](#Creating)</ept><ph id="ph1"> </ph></source>
          <target state="translated"><bpt id="p1">[</bpt>Crear y ejecutar una tarea<ept id="p1">](#Creating)</ept><ph id="ph1"> </ph></target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.Task">
          <source><bpt id="p1">[</bpt>Separating task creation and execution<ept id="p1">](#Separating)</ept><ph id="ph1"> </ph></source>
          <target state="translated"><bpt id="p1">[</bpt>Separación de ejecución y la creación de tareas<ept id="p1">](#Separating)</ept><ph id="ph1"> </ph></target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.Task">
          <source><bpt id="p1">[</bpt>Waiting for one or more tasks to complete<ept id="p1">](#WaitingForOne)</ept><ph id="ph1"> </ph></source>
          <target state="translated"><bpt id="p1">[</bpt>Esperando a completar las tareas de uno o más<ept id="p1">](#WaitingForOne)</ept><ph id="ph1"> </ph></target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.Task">
          <source><bpt id="p1">[</bpt>Tasks and culture<ept id="p1">](#Culture)</ept><ph id="ph1"> </ph></source>
          <target state="translated"><bpt id="p1">[</bpt>Tareas y la referencia cultural<ept id="p1">](#Culture)</ept><ph id="ph1"> </ph></target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.Task">
          <source><bpt id="p1">[</bpt>For debugger developers<ept id="p1">](#Debugger)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Para los desarrolladores de depurador<ept id="p1">](#Debugger)</ept></target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.Task">
          <source>Task instantiation</source>
          <target state="translated">Creación de instancias de tarea</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.Task">
          <source>The following example creates and executes four tasks.</source>
          <target state="translated">En el ejemplo siguiente se crea y ejecuta las cuatro tareas.</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.Task">
          <source>Three tasks execute an <ph id="ph1">&lt;xref:System.Action%601&gt;</ph> delegate named <ph id="ph2">`action`</ph>, which accepts an argument of type <ph id="ph3">&lt;xref:System.Object&gt;</ph>.</source>
          <target state="translated">Tres de las tareas se ejecutan una <ph id="ph1">&lt;xref:System.Action%601&gt;</ph> delegado denominado <ph id="ph2">`action`</ph>, que acepta un argumento de tipo <ph id="ph3">&lt;xref:System.Object&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.Task">
          <source>A fourth task executes a lambda expression (an <ph id="ph1">&lt;xref:System.Action&gt;</ph> delegate) that is defined inline in the call to the task creation method.</source>
          <target state="translated">Una cuarta tarea ejecuta una expresión lambda (un <ph id="ph1">&lt;xref:System.Action&gt;</ph> delegar) que es definida insertada en la llamada al método de creación de tarea.</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.Task">
          <source>Each task is instantiated and run in a different way:</source>
          <target state="translated">Cada tarea se crea y se ejecuta de forma diferente:</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.Task">
          <source>Task <ph id="ph1">`t1`</ph> is instantiated by calling a Task class constructor, but is started by calling its <ph id="ph2">&lt;xref:System.Threading.Tasks.Task.Start&gt;</ph> method only after task <ph id="ph3">`t2`</ph> has started.</source>
          <target state="translated">Tarea <ph id="ph1">`t1`</ph> se crea una instancia mediante una llamada a un constructor de clase de tarea, pero se inicia mediante una llamada a su <ph id="ph2">&lt;xref:System.Threading.Tasks.Task.Start&gt;</ph> método sólo después de la tarea <ph id="ph3">`t2`</ph> se ha iniciado.</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.Task">
          <source>Task <ph id="ph1">`t2`</ph> is instantiated and started in a single method call by calling the <ph id="ph2">&lt;xref:System.Threading.Tasks.TaskFactory.StartNew%28System.Action%7BSystem.Object%7D%2CSystem.Object%29?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">Tarea <ph id="ph1">`t2`</ph> se crea y se inicia en una única llamada al método mediante una llamada a la <ph id="ph2">&lt;xref:System.Threading.Tasks.TaskFactory.StartNew%28System.Action%7BSystem.Object%7D%2CSystem.Object%29?displayProperty=nameWithType&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.Task">
          <source>Task <ph id="ph1">`t3`</ph> is instantiated and started in a single method call by calling the <ph id="ph2">&lt;xref:System.Threading.Tasks.Task.Run%28System.Action%29&gt;</ph> method.</source>
          <target state="translated">Tarea <ph id="ph1">`t3`</ph> se crea y se inicia en una única llamada al método mediante una llamada a la <ph id="ph2">&lt;xref:System.Threading.Tasks.Task.Run%28System.Action%29&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.Task">
          <source>Task <ph id="ph1">`t4`</ph> is executed synchronously on the main thread by calling the <ph id="ph2">&lt;xref:System.Threading.Tasks.Task.RunSynchronously&gt;</ph> method.</source>
          <target state="translated">Tarea <ph id="ph1">`t4`</ph> se ejecuta sincrónicamente en el subproceso principal mediante una llamada a la <ph id="ph2">&lt;xref:System.Threading.Tasks.Task.RunSynchronously&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.Task">
          <source>Because task <ph id="ph1">`t4`</ph> executes synchronously, it executes on the main application thread.</source>
          <target state="translated">Dado que tarea <ph id="ph1">`t4`</ph> ejecuta de forma sincrónica, ejecuta en el subproceso de aplicación principal.</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.Task">
          <source>The remaining tasks execute asynchronously typically on one or more thread pool threads.</source>
          <target state="translated">Las tareas restantes asincrónicamente ejecutan normalmente en uno o más subprocesos del grupo de subprocesos.</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.Task">
          <source>Creating and executing a task</source>
          <target state="translated">Crear y ejecutar una tarea</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.Task">
          <source><ph id="ph1">&lt;xref:System.Threading.Tasks.Task&gt;</ph> instances may be created in a variety of ways.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Threading.Tasks.Task&gt;</ph> pueden crear instancias en una variedad de formas.</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.Task">
          <source>The most common approach, which is available starting with the <ph id="ph1">[!INCLUDE[net_v45](~/includes/net-v45-md.md)]</ph>, is to call the static <ph id="ph2">&lt;xref:System.Threading.Tasks.Task.Run%2A&gt;</ph> method.</source>
          <target state="translated">El enfoque más común, que está disponible a partir de la <ph id="ph1">[!INCLUDE[net_v45](~/includes/net-v45-md.md)]</ph>, consiste en llamar el método estático <ph id="ph2">&lt;xref:System.Threading.Tasks.Task.Run%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.Task">
          <source>The <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Run%2A&gt;</ph> method provides a simple way to start a task using default values and without requiring additional parameters.</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Run%2A&gt;</ph> método proporciona una manera sencilla de iniciar una tarea con los valores predeterminados y sin necesidad de parámetros adicionales.</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.Task">
          <source>The following example uses the <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Run%28System.Action%29&gt;</ph> method to start a task that loops and then displays the number of loop iterations:</source>
          <target state="translated">En el ejemplo siguiente se usa el <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Run%28System.Action%29&gt;</ph> método para iniciar una tarea que se ejecuta un bucle y, a continuación, muestra el número de iteraciones del bucle:</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.Task">
          <source>An alternative, and the most common method to start a task in <ph id="ph1">[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]</ph>, is the static <ph id="ph2">&lt;xref:System.Threading.Tasks.TaskFactory.StartNew%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">Una alternativa y el método más común para iniciar una tarea <ph id="ph1">[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]</ph>, es el método estático <ph id="ph2">&lt;xref:System.Threading.Tasks.TaskFactory.StartNew%2A?displayProperty=nameWithType&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.Task">
          <source>The <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Factory%2A?displayProperty=nameWithType&gt;</ph> property returns a <ph id="ph2">&lt;xref:System.Threading.Tasks.TaskFactory&gt;</ph> object.</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Factory%2A?displayProperty=nameWithType&gt;</ph> propiedad devuelve un <ph id="ph2">&lt;xref:System.Threading.Tasks.TaskFactory&gt;</ph> objeto.</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.Task">
          <source>Overloads of the <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskFactory.StartNew%2A?displayProperty=nameWithType&gt;</ph> method let you specify parameters to pass to the task creation options and a task scheduler.</source>
          <target state="translated">Las sobrecargas de los <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskFactory.StartNew%2A?displayProperty=nameWithType&gt;</ph> método le permite especificar parámetros para pasar a las opciones de creación de tarea y un programador de tareas.</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.Task">
          <source>The following example uses the <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskFactory.StartNew%2A?displayProperty=nameWithType&gt;</ph> method to start a task.</source>
          <target state="translated">En el ejemplo siguiente se usa el <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskFactory.StartNew%2A?displayProperty=nameWithType&gt;</ph> método para iniciar una tarea.</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.Task">
          <source>It is functionally equivalent to the code in the previous example.</source>
          <target state="translated">Es funcionalmente equivalente al código en el ejemplo anterior.</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.Task">
          <source>For more complete examples, see <bpt id="p1">[</bpt>Task-based Asynchronous Programming<ept id="p1">](~/docs/standard/parallel-programming/task-based-asynchronous-programming.md)</ept>.</source>
          <target state="translated">Para obtener ejemplos más completos, vea <bpt id="p1">[</bpt>basado en tareas de programación asincrónica<ept id="p1">](~/docs/standard/parallel-programming/task-based-asynchronous-programming.md)</ept>.</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.Task">
          <source>Separating task creation and execution</source>
          <target state="translated">Separación de ejecución y la creación de tareas</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.Task">
          <source>The <ph id="ph1">&lt;xref:System.Threading.Tasks.Task&gt;</ph> class also provides constructors that initialize the task but that do not schedule it for execution.</source>
          <target state="translated">La <ph id="ph1">&lt;xref:System.Threading.Tasks.Task&gt;</ph> clase también proporciona constructores que inicializan la tarea pero que no la programan para su ejecución.</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.Task">
          <source>For performance reasons, the <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Run%2A?displayProperty=nameWithType&gt;</ph> or <ph id="ph2">&lt;xref:System.Threading.Tasks.TaskFactory.StartNew%2A?displayProperty=nameWithType&gt;</ph> method is the preferred mechanism for creating and scheduling computational tasks, but for scenarios where creation and scheduling must be separated, you can use the constructors and then call the <ph id="ph3">&lt;xref:System.Threading.Tasks.Task.Start%2A?displayProperty=nameWithType&gt;</ph> method to schedule the task for execution at a later time.</source>
          <target state="translated">Por motivos de rendimiento, el <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Run%2A?displayProperty=nameWithType&gt;</ph> o <ph id="ph2">&lt;xref:System.Threading.Tasks.TaskFactory.StartNew%2A?displayProperty=nameWithType&gt;</ph> método es el mecanismo preferido para crear y programar tareas de cálculo, pero para escenarios donde deben estar separados la creación y la programación, puede usar los constructores y, a continuación, llamar a la <ph id="ph3">&lt;xref:System.Threading.Tasks.Task.Start%2A?displayProperty=nameWithType&gt;</ph> método para programar la tarea para su ejecución en un momento posterior.</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.Task">
          <source>Waiting for one or more tasks to complete</source>
          <target state="translated">Esperando a completar las tareas de uno o más</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.Task">
          <source>Because tasks typically run asynchronously on a thread pool thread, the thread that creates and starts the task continues execution as soon as the task has been instantiated.</source>
          <target state="translated">Las tareas normalmente se ejecutan asincrónicamente en un subproceso del grupo, por lo que el subproceso que crea e inicia la tarea continúa la ejecución tan pronto como se ha creado una instancia de la tarea.</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.Task">
          <source>In some cases, when the calling thread is the main application thread, the app may terminate before any the task actually begins execution.</source>
          <target state="translated">En algunos casos, cuando el subproceso que realiza la llamada es el subproceso de aplicación principal, la aplicación puede finalizar antes de cualquier la tarea que empiece la ejecución.</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.Task">
          <source>In others,   your application's logic may require that the calling thread continue execution only when one or more tasks has completed execution.</source>
          <target state="translated">En otros casos, la lógica de la aplicación puede requerir que el subproceso que realiza la llamada continuar la ejecución solo cuando una o más tareas ha completado su ejecución.</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.Task">
          <source>You can synchronize the execution of the calling thread and the asynchronous tasks it launches by calling a <ph id="ph1">`Wait`</ph> method to wait for one or more tasks to complete.</source>
          <target state="translated">Puede sincronizar la ejecución del subproceso que realiza la llamada y la asincrónica las tareas se inicia mediante una llamada a un <ph id="ph1">`Wait`</ph> método para esperar una o más tareas se completen.</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.Task">
          <source>To wait for a single task to complete, you can call its <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Wait%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">Para esperar a que una sola tarea para completar, puede llamar a su <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Wait%2A?displayProperty=nameWithType&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.Task">
          <source>A call to the  <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Wait%2A&gt;</ph> method blocks the calling thread until the single class instance has completed execution.</source>
          <target state="translated">Una llamada a la <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Wait%2A&gt;</ph> método bloquea el subproceso que realiza la llamada hasta que la instancia de clase único ha completado su ejecución.</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.Task">
          <source>The following example calls the parameterless <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Wait&gt;</ph> method to wait unconditionally until a task completes.</source>
          <target state="translated">En el ejemplo siguiente se llama sin parámetros <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Wait&gt;</ph> método incondicionalmente espere hasta que se complete una tarea.</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.Task">
          <source>The task simulates work by calling the <ph id="ph1">&lt;xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType&gt;</ph> method to sleep for two seconds.</source>
          <target state="translated">La tarea simula un trabajo mediante una llamada a la <ph id="ph1">&lt;xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType&gt;</ph> método en modo de suspensión durante dos segundos.</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.Task">
          <source>You can also conditionally wait for a task to complete.</source>
          <target state="translated">También condicionalmente puede esperar de una tarea se complete.</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.Task">
          <source>The  <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Wait%28System.Int32%29&gt;</ph> and <ph id="ph2">&lt;xref:System.Threading.Tasks.Task.Wait%28System.TimeSpan%29&gt;</ph> methods block the calling thread until the task finishes or a timeout interval elapses, whichever comes first.</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Wait%28System.Int32%29&gt;</ph> y <ph id="ph2">&lt;xref:System.Threading.Tasks.Task.Wait%28System.TimeSpan%29&gt;</ph> métodos bloquean el subproceso que realiza la llamada hasta que finaliza la tarea o transcurre un intervalo de tiempo de espera, lo que ocurra primero.</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.Task">
          <source>Since the following example launches a task that sleeps for two seconds but defines a one-second timeout value, the calling thread blocks until the timeout expires and before the task has completed execution.</source>
          <target state="translated">Puesto que el ejemplo siguiente inicia una tarea que se suspende durante dos segundos, pero define un valor de tiempo de espera de un segundo subproceso que realiza la llamada se bloquea hasta que expire el tiempo de espera y antes de la tarea ha completado su ejecución.</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.Task">
          <source>You can also supply a cancellation token by calling the <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Wait%28System.Threading.CancellationToken%29&gt;</ph> and  <ph id="ph2">&lt;xref:System.Threading.Tasks.Task.Wait%28System.Int32%2CSystem.Threading.CancellationToken%29&gt;</ph> methods.</source>
          <target state="translated">También puede proporcionar un token de cancelación mediante una llamada a la <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Wait%28System.Threading.CancellationToken%29&gt;</ph> y <ph id="ph2">&lt;xref:System.Threading.Tasks.Task.Wait%28System.Int32%2CSystem.Threading.CancellationToken%29&gt;</ph> métodos.</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.Task">
          <source>If the  token's <ph id="ph1">&lt;xref:System.Threading.CancellationToken.IsCancellationRequested%2A&gt;</ph> property is <ph id="ph2">`true`</ph>, the wait is cancelled; if it becomes true while the <ph id="ph3">&lt;xref:System.Threading.Tasks.Task.Wait%2A&gt;</ph> method terminates.</source>
          <target state="translated">Si el token <ph id="ph1">&lt;xref:System.Threading.CancellationToken.IsCancellationRequested%2A&gt;</ph> propiedad es <ph id="ph2">`true`</ph>, se cancele la espera; si es true mientras el <ph id="ph3">&lt;xref:System.Threading.Tasks.Task.Wait%2A&gt;</ph> método termina.</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.Task">
          <source>In some cases, you may want to wait for the first of a series of executing tasks to complete, but don't care which task it is.</source>
          <target state="translated">En algunos casos, puede que desee esperar para que la primera de una serie de tareas ejecutándose completar, pero no la atención que la tarea lo es.</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.Task">
          <source>For this purpose, you can call one of the overloads of the <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.WaitAll%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">Para ello, puede llamar a una de las sobrecargas de los <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.WaitAll%2A?displayProperty=nameWithType&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.Task">
          <source>The following example creates three tasks, each of which sleeps for an interval determine by a random number generator.</source>
          <target state="translated">En el ejemplo siguiente se crea tres tareas, cada una de las cuales se suspende para determinar un intervalo mediante un generador de números aleatorios.</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.Task">
          <source>The <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.WaitAny%28System.Threading.Tasks.Task%5B%5D%29&gt;</ph> method waits for the first task to complete.</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.WaitAny%28System.Threading.Tasks.Task%5B%5D%29&gt;</ph> método espera a que la primera tarea se complete.</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.Task">
          <source>The example then displays information about the status of all three tasks.</source>
          <target state="translated">En el ejemplo, a continuación, muestra información sobre el estado de las tres tareas.</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.Task">
          <source>You can also wait for all of a series of tasks to complete by calling the <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.WaitAll%2A&gt;</ph> method.</source>
          <target state="translated">También puede esperar de una serie de tareas se completen mediante una llamada a todos los <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.WaitAll%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.Task">
          <source>The following example creates ten tasks, waits for all ten to complete, and then displays their status.</source>
          <target state="translated">En el ejemplo siguiente se crea diez tareas, espera a que todos los diez en completarse y, a continuación, muestra su estado.</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.Task">
          <source>Note that when you wait for one or more tasks to complete, any exceptions thrown in the running tasks are propagated on the thread that calls the <ph id="ph1">`Wait`</ph> method, as the following example shows.</source>
          <target state="translated">Tenga en cuenta que, cuando se espera completar las tareas de uno o más, las excepciones producidas en las tareas en ejecución se propaguen en el subproceso que llama el <ph id="ph1">`Wait`</ph> método, tal como se muestra en el ejemplo siguiente.</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.Task">
          <source>It launches 12 tasks, three of which complete normally and three of which throw an exception.</source>
          <target state="translated">Inicia 12 tareas, tres de los cuales finalizar con normalidad y tres que inician una excepción.</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.Task">
          <source>Of the remaining six tasks, three are cancelled before the start, and three are cancelled while they executing.</source>
          <target state="translated">De las seis tareas pendientes, tres se cancelan antes del inicio y tres se cancelan mientras se ejecutan.</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.Task">
          <source>Exceptions are thrown in the <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.WaitAll%2A&gt;</ph> method call and are handled by a <ph id="ph2">`try`</ph><ph id="ph3">/</ph><ph id="ph4">`catch`</ph> block.</source>
          <target state="translated">Las excepciones se producen el <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.WaitAll%2A&gt;</ph> llamada al método y se controlan un <ph id="ph2">`try`</ph> <ph id="ph3">/</ph> <ph id="ph4">`catch`</ph> bloque.</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.Task">
          <source>For more information on exception handling in task-based asynchronous operations, see <bpt id="p1">[</bpt>Exception Handling<ept id="p1">](~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md)</ept>.</source>
          <target state="translated">Para obtener más información sobre el control de excepciones en las operaciones asincrónicas basadas en tareas, consulte <bpt id="p1">[</bpt>Exception Handling<ept id="p1">](~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md)</ept>.</target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.Task">
          <source>Tasks and culture</source>
          <target state="translated">Tareas y la referencia cultural</target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.Task">
          <source>Starting with desktop apps that target the <ph id="ph1">[!INCLUDE[net_v46](~/includes/net-v46-md.md)]</ph>, the culture of the thread that creates and invokes a task becomes part of the thread's context.</source>
          <target state="translated">A partir de las aplicaciones de escritorio que tienen como destino el <ph id="ph1">[!INCLUDE[net_v46](~/includes/net-v46-md.md)]</ph>, la referencia cultural del subproceso que crea e invoca una tarea se convierte en parte del contexto del subproceso.</target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.Task">
          <source>That is, regardless of the current culture of the thread on which the task executes, the current culture of the task is the culture of the calling thread.</source>
          <target state="translated">Es decir, sin tener en cuenta la referencia cultural actual del subproceso en el que se ejecuta la tarea, la referencia cultural actual de la tarea es la referencia cultural del subproceso que realiza la llamada.</target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.Task">
          <source>For apps that target versions of the .NET Framework prior to the <ph id="ph1">[!INCLUDE[net_v46](~/includes/net-v46-md.md)]</ph>, the culture of the task is the culture of the thread on which the task executes.</source>
          <target state="translated">Para las aplicaciones destinadas a versiones de .NET Framework anteriores a la <ph id="ph1">[!INCLUDE[net_v46](~/includes/net-v46-md.md)]</ph>, la referencia cultural de la tarea es la referencia cultural del subproceso en el que se ejecuta la tarea.</target>       </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.Task">
          <source>For more information, see the "Culture and task-based asynchronous operations" section in the <ph id="ph1">&lt;xref:System.Globalization.CultureInfo&gt;</ph> topic.</source>
          <target state="translated">Para obtener más información, vea la sección "Referencia cultural y operaciones asincrónicas basadas en tareas" en el <ph id="ph1">&lt;xref:System.Globalization.CultureInfo&gt;</ph> tema.</target>       </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.Task">
          <source>Store apps follow the Windows Runtime in setting and getting the default culture.</source>
          <target state="translated">Aplicaciones de la tienda siguen el tiempo de ejecución de Windows en la configuración y la obtención de la referencia cultural predeterminada.</target>       </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.Task">
          <source>For debugger developers</source>
          <target state="translated">Para los desarrolladores de depurador</target>       </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.Task">
          <source>For developers implementing custom debuggers, several internal and private members of task may be useful (these may change from release to release).</source>
          <target state="translated">Para los desarrolladores que implementan a depuradores personalizados, varios miembros privados e internos de la tarea pueden ser útiles (puede que éstos cambien de una versión a otra).</target>       </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.Task">
          <source>The <ph id="ph1">`m_taskId`</ph> field serves as the backing store for the <ph id="ph2">&lt;xref:System.Threading.Tasks.Task.Id%2A&gt;</ph> property, however accessing this field directly from a debugger may be more efficient than accessing the same value through the property's getter method (the <ph id="ph3">`s_taskIdCounter`</ph> counter is used to retrieve the next available ID for a task).</source>
          <target state="translated">El <ph id="ph1">`m_taskId`</ph> campo actúa como el almacén de copia de seguridad para la <ph id="ph2">&lt;xref:System.Threading.Tasks.Task.Id%2A&gt;</ph> propiedad, sin embargo acceso a este campo directamente desde un depurador puede ser más eficaz que si tuviera acceso el mismo valor a través del método de captador de la propiedad (la <ph id="ph3">`s_taskIdCounter`</ph> contador se utiliza para recuperar el siguiente identificador disponible para una tarea).</target>       </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.Task">
          <source>Similarly, the <ph id="ph1">`m_stateFlags`</ph> field stores information about the current lifecycle stage of the task, information also accessible through the <ph id="ph2">&lt;xref:System.Threading.Tasks.Task.Status%2A&gt;</ph> property.</source>
          <target state="translated">De forma similar, el <ph id="ph1">`m_stateFlags`</ph> campo almacena información sobre la fase actual del ciclo de vida de la tarea, la información también es accesible a través de la <ph id="ph2">&lt;xref:System.Threading.Tasks.Task.Status%2A&gt;</ph> propiedad.</target>       </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.Task">
          <source>The <ph id="ph1">`m_action`</ph> field stores a reference to the task's delegate, and the <ph id="ph2">`m_stateObject`</ph> field stores the async state passed to the task by the developer.</source>
          <target state="translated">El <ph id="ph1">`m_action`</ph> campo almacena una referencia al delegado de la tarea y el <ph id="ph2">`m_stateObject`</ph> campo almacena el estado asincrónico pasado a la tarea por el desarrollador.</target>       </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.Task">
          <source>Finally, for debuggers that parse stack frames, the <ph id="ph1">`InternalWait`</ph> method serves a potential marker for when a task is entering a wait operation.</source>
          <target state="translated">Por último, para los depuradores que analizan marcos de pila, el <ph id="ph1">`InternalWait`</ph> método proporciona un marcador potencial para cuando una tarea está entrando en una operación de espera.</target>       </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.Task">
          <source>All members of <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph>, except for <ph id="ph2">&lt;see cref="M:System.Threading.Tasks.Task.Dispose" /&gt;</ph>, are thread-safe and may be used from multiple threads concurrently.</source>
          <target state="translated">Todos los miembros de <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph>, excepto para <ph id="ph2">&lt;see cref="M:System.Threading.Tasks.Task.Dispose" /&gt;</ph>, es seguro para subprocesos y pueden usar desde varios subprocesos simultáneamente.</target>       </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve" uid="T:System.Threading.Tasks.Task">
          <source>Initializes a new <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph>.</source>
          <target state="translated">Inicializa un nuevo objeto <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.#ctor(System.Action)">
          <source>The delegate that represents the code to execute in the task.</source>
          <target state="translated">Delegado que representa el código que se va a ejecutar en la tarea.</target>       </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.#ctor(System.Action)">
          <source>Initializes a new <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> with the specified action.</source>
          <target state="translated">Inicializa una nueva instancia de <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> con la acción especificada.</target>       </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.#ctor(System.Action)">
          <source>Rather than calling this constructor, the most common way to instantiate a <ph id="ph1">&lt;xref:System.Threading.Tasks.Task&gt;</ph> object and launch a task is by calling the static <ph id="ph2">&lt;xref:System.Threading.Tasks.Task.Run%28System.Action%29?displayProperty=nameWithType&gt;</ph> or <ph id="ph3">&lt;xref:System.Threading.Tasks.TaskFactory.StartNew%28System.Action%29?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">En lugar de llamar a este constructor, la manera más común para crear instancias de un <ph id="ph1">&lt;xref:System.Threading.Tasks.Task&gt;</ph> objeto e inicie una tarea consiste en llamar al estático <ph id="ph2">&lt;xref:System.Threading.Tasks.Task.Run%28System.Action%29?displayProperty=nameWithType&gt;</ph> o <ph id="ph3">&lt;xref:System.Threading.Tasks.TaskFactory.StartNew%28System.Action%29?displayProperty=nameWithType&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.#ctor(System.Action)">
          <source>The only advantage offered by this constructor is that it allows object instantiation to be separated from task invocation.</source>
          <target state="translated">La única ventaja que ofrece este constructor es que permite la creación de instancias de objeto se separen de invocación de la tarea.</target>       </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.#ctor(System.Action)">
          <source>The following example uses the <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.%23ctor%28System.Action%29&gt;</ph> constructor to create tasks that retrieve the filenames in specified directories.</source>
          <target state="translated">En el ejemplo siguiente se usa el <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.%23ctor%28System.Action%29&gt;</ph> constructor para crear tareas que recuperar los nombres de archivo en los directorios especificados.</target>       </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.#ctor(System.Action)">
          <source>All tasks write the file names to a single <ph id="ph1">&lt;xref:System.Collections.Concurrent.ConcurrentBag%601&gt;</ph> object.</source>
          <target state="translated">Todas las tareas de escriban los nombres de archivo en una sola <ph id="ph1">&lt;xref:System.Collections.Concurrent.ConcurrentBag%601&gt;</ph> objeto.</target>       </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.#ctor(System.Action)">
          <source>The example then calls the <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.WaitAll%28System.Threading.Tasks.Task%5B%5D%29&gt;</ph> method to ensure that all tasks have completed, and then displays a count of the total number of file names written to the <ph id="ph2">&lt;xref:System.Collections.Concurrent.ConcurrentBag%601&gt;</ph> object.</source>
          <target state="translated">El ejemplo, a continuación, se llama la <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.WaitAll%28System.Threading.Tasks.Task%5B%5D%29&gt;</ph> método para asegurarse de que ha completado todas las tareas y, a continuación, muestra un recuento del número total de nombres de archivo que se escriben en el <ph id="ph2">&lt;xref:System.Collections.Concurrent.ConcurrentBag%601&gt;</ph> objeto.</target>       </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.#ctor(System.Action)">
          <source>The following example is identical, except that it used the <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Run%28System.Action%29&gt;</ph> method to instantiate and run the task in a single operation.</source>
          <target state="translated">El ejemplo siguiente es idéntico, salvo que usa el <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Run%28System.Action%29&gt;</ph> método para crear una instancia y ejecutar la tarea en una sola operación.</target>       </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.#ctor(System.Action)">
          <source>The method returns the <ph id="ph1">&lt;xref:System.Threading.Tasks.Task&gt;</ph> object that represents the task.</source>
          <target state="translated">El método devuelve el <ph id="ph1">&lt;xref:System.Threading.Tasks.Task&gt;</ph> objeto que representa la tarea.</target>       </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.#ctor(System.Action)">
          <source>The <ph id="ph1">&lt;paramref name="action" /&gt;</ph> argument is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">El argumento <ph id="ph1">&lt;paramref name="action" /&gt;</ph> es <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.#ctor(System.Action,System.Threading.CancellationToken)">
          <source>The delegate that represents the code to execute in the task.</source>
          <target state="translated">Delegado que representa el código que se va a ejecutar en la tarea.</target>       </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.#ctor(System.Action,System.Threading.CancellationToken)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Threading.CancellationToken" /&gt;</ph> that the new  task will observe.</source>
          <target state="translated">El <ph id="ph1">&lt;see cref="T:System.Threading.CancellationToken" /&gt;</ph> que observará la nueva tarea.</target>       </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.#ctor(System.Action,System.Threading.CancellationToken)">
          <source>Initializes a new <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> with the specified action and <ph id="ph2">&lt;see cref="T:System.Threading.CancellationToken" /&gt;</ph>.</source>
          <target state="translated">Inicializa una nueva instancia de <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> con la acción especificada y <ph id="ph2">&lt;see cref="T:System.Threading.CancellationToken" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.#ctor(System.Action,System.Threading.CancellationToken)">
          <source>Rather than calling this constructor, the most common way to instantiate a <ph id="ph1">&lt;xref:System.Threading.Tasks.Task&gt;</ph> object and launch a task is by calling the static <ph id="ph2">&lt;xref:System.Threading.Tasks.Task.Run%28System.Action%2CSystem.Threading.CancellationToken%29?displayProperty=nameWithType&gt;</ph> and <ph id="ph3">&lt;xref:System.Threading.Tasks.TaskFactory.StartNew%28System.Action%2CSystem.Threading.CancellationToken%29?displayProperty=nameWithType&gt;</ph> methods.</source>
          <target state="translated">En lugar de llamar a este constructor, la manera más común para crear instancias de un <ph id="ph1">&lt;xref:System.Threading.Tasks.Task&gt;</ph> objeto e inicie una tarea consiste en llamar al estático <ph id="ph2">&lt;xref:System.Threading.Tasks.Task.Run%28System.Action%2CSystem.Threading.CancellationToken%29?displayProperty=nameWithType&gt;</ph> y <ph id="ph3">&lt;xref:System.Threading.Tasks.TaskFactory.StartNew%28System.Action%2CSystem.Threading.CancellationToken%29?displayProperty=nameWithType&gt;</ph> métodos.</target>       </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.#ctor(System.Action,System.Threading.CancellationToken)">
          <source>The only advantage offered by this constructor is that it allows object instantiation to be separated from task invocation.</source>
          <target state="translated">La única ventaja que ofrece este constructor es que permite la creación de instancias de objeto se separen de invocación de la tarea.</target>       </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.#ctor(System.Action,System.Threading.CancellationToken)">
          <source>For more information, see <bpt id="p1">[</bpt>Task Parallelism (Task Parallel Library)<ept id="p1">](~/docs/standard/parallel-programming/task-based-asynchronous-programming.md)</ept> and <bpt id="p2">[</bpt>Cancellation in Managed Threads<ept id="p2">](~/docs/standard/threading/cancellation-in-managed-threads.md)</ept>.</source>
          <target state="translated">Para obtener más información, consulte <bpt id="p1">[</bpt>paralelismo de tareas (Task Parallel Library)<ept id="p1">](~/docs/standard/parallel-programming/task-based-asynchronous-programming.md)</ept> y <bpt id="p2">[</bpt>cancelación en subprocesos administrados<ept id="p2">](~/docs/standard/threading/cancellation-in-managed-threads.md)</ept>.</target>       </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.#ctor(System.Action,System.Threading.CancellationToken)">
          <source>The following example calls the <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.%23ctor%28System.Action%2CSystem.Threading.CancellationToken%29&gt;</ph> constructor to create a task that iterates the files in the C:\Windows\System32 directory.</source>
          <target state="translated">El ejemplo siguiente se llama el <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.%23ctor%28System.Action%2CSystem.Threading.CancellationToken%29&gt;</ph> constructor para crear una tarea que recorre en iteración los archivos en el directorio C:\Windows\System32.</target>       </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.#ctor(System.Action,System.Threading.CancellationToken)">
          <source>The lambda expression calls the <ph id="ph1">&lt;xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType&gt;</ph> method to add information about each  file to a <ph id="ph2">&lt;xref:System.Collections.Generic.List%601&gt;</ph> object.</source>
          <target state="translated">La expresión lambda llama el <ph id="ph1">&lt;xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType&gt;</ph> método para agregar información sobre todos los archivos en un <ph id="ph2">&lt;xref:System.Collections.Generic.List%601&gt;</ph> objeto.</target>       </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.#ctor(System.Action,System.Threading.CancellationToken)">
          <source>Each detached nested task invoked by the <ph id="ph1">&lt;xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType&gt;</ph> loop checks the state of the cancellation token and, if cancellation is requested, calls the <ph id="ph2">&lt;xref:System.Threading.CancellationToken.ThrowIfCancellationRequested%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">Cada tarea anidada invocado por desasociada el <ph id="ph1">&lt;xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType&gt;</ph> bucle comprueba el estado del token de cancelación y, si se solicita la cancelación, llama a la <ph id="ph2">&lt;xref:System.Threading.CancellationToken.ThrowIfCancellationRequested%2A?displayProperty=nameWithType&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.#ctor(System.Action,System.Threading.CancellationToken)">
          <source>The <ph id="ph1">&lt;xref:System.Threading.CancellationToken.ThrowIfCancellationRequested%2A?displayProperty=nameWithType&gt;</ph> method throws an <ph id="ph2">&lt;xref:System.OperationCanceledException&gt;</ph> exception that is handled in a <ph id="ph3">`catch`</ph> block when the calling thread calls the <ph id="ph4">&lt;xref:System.Threading.Tasks.Task.Wait%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.Threading.CancellationToken.ThrowIfCancellationRequested%2A?displayProperty=nameWithType&gt;</ph> método inicie una excepción un <ph id="ph2">&lt;xref:System.OperationCanceledException&gt;</ph> excepción que se controla en un <ph id="ph3">`catch`</ph> bloquear cuando el subproceso que realiza la llamada llama la <ph id="ph4">&lt;xref:System.Threading.Tasks.Task.Wait%2A?displayProperty=nameWithType&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.#ctor(System.Action,System.Threading.CancellationToken)">
          <source>The <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Start%2A&gt;</ph> method is then called to start the task.</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Start%2A&gt;</ph> , a continuación, se llama el método para iniciar la tarea.</target>       </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.#ctor(System.Action,System.Threading.CancellationToken)">
          <source>The provided <ph id="ph1">&lt;see cref="T:System.Threading.CancellationToken" /&gt;</ph> has already been disposed.</source>
          <target state="translated">El <ph id="ph1">&lt;see cref="T:System.Threading.CancellationToken" /&gt;</ph> proporcionado ya se ha eliminado.</target>       </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.#ctor(System.Action,System.Threading.CancellationToken)">
          <source>The <ph id="ph1">&lt;paramref name="action" /&gt;</ph> argument is null.</source>
          <target state="translated">El argumento <ph id="ph1">&lt;paramref name="action" /&gt;</ph> es null.</target>       </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.#ctor(System.Action,System.Threading.Tasks.TaskCreationOptions)">
          <source>The delegate that represents the code to execute in the task.</source>
          <target state="translated">Delegado que representa el código que se va a ejecutar en la tarea.</target>       </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.#ctor(System.Action,System.Threading.Tasks.TaskCreationOptions)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.TaskCreationOptions" /&gt;</ph> used to customize the task's behavior.</source>
          <target state="translated">El objeto <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.TaskCreationOptions" /&gt;</ph> que se usa para personalizar el comportamiento de la tarea.</target>       </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.#ctor(System.Action,System.Threading.Tasks.TaskCreationOptions)">
          <source>Initializes a new <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> with the specified action and creation options.</source>
          <target state="translated">Inicializa un nuevo objeto <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> con la acción y las opciones de creación especificadas.</target>       </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.#ctor(System.Action,System.Threading.Tasks.TaskCreationOptions)">
          <source>Rather than calling this constructor, the most common way to instantiate a <ph id="ph1">&lt;xref:System.Threading.Tasks.Task&gt;</ph> object and launch a task is by calling the static <ph id="ph2">&lt;xref:System.Threading.Tasks.TaskFactory.StartNew%28System.Action%2CSystem.Threading.Tasks.TaskCreationOptions%29?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">En lugar de llamar a este constructor, la manera más común para crear instancias de un <ph id="ph1">&lt;xref:System.Threading.Tasks.Task&gt;</ph> objeto e inicie una tarea consiste en llamar al estático <ph id="ph2">&lt;xref:System.Threading.Tasks.TaskFactory.StartNew%28System.Action%2CSystem.Threading.Tasks.TaskCreationOptions%29?displayProperty=nameWithType&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.#ctor(System.Action,System.Threading.Tasks.TaskCreationOptions)">
          <source>The only advantage offered by this constructor is that it allows object instantiation to be separated from task invocation.</source>
          <target state="translated">La única ventaja que ofrece este constructor es que permite la creación de instancias de objeto se separen de invocación de la tarea.</target>       </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.#ctor(System.Action,System.Threading.Tasks.TaskCreationOptions)">
          <source>The <ph id="ph1">&lt;paramref name="action" /&gt;</ph> argument is null.</source>
          <target state="translated">El argumento <ph id="ph1">&lt;paramref name="action" /&gt;</ph> es null.</target>       </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.#ctor(System.Action,System.Threading.Tasks.TaskCreationOptions)">
          <source>The <ph id="ph1">&lt;paramref name="creationOptions" /&gt;</ph> argument specifies an invalid value for <ph id="ph2">&lt;see cref="T:System.Threading.Tasks.TaskCreationOptions" /&gt;</ph>.</source>
          <target state="translated">El argumento <ph id="ph1">&lt;paramref name="creationOptions" /&gt;</ph> especifica un valor no válido para <ph id="ph2">&lt;see cref="T:System.Threading.Tasks.TaskCreationOptions" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.#ctor(System.Action{System.Object},System.Object)">
          <source>The delegate that represents the code to execute in the task.</source>
          <target state="translated">Delegado que representa el código que se va a ejecutar en la tarea.</target>       </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.#ctor(System.Action{System.Object},System.Object)">
          <source>An object representing data to be used by the action.</source>
          <target state="translated">Objeto que representa los datos que la acción va a usar.</target>       </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.#ctor(System.Action{System.Object},System.Object)">
          <source>Initializes a new <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> with the specified action and state.</source>
          <target state="translated">Inicializa una nueva instancia de <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> con la acción y el estado especificados.</target>       </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.#ctor(System.Action{System.Object},System.Object)">
          <source>Rather than calling this constructor, the most common way to instantiate a <ph id="ph1">&lt;xref:System.Threading.Tasks.Task&gt;</ph> object and launch a task is by calling the static <ph id="ph2">&lt;xref:System.Threading.Tasks.TaskFactory.StartNew%28System.Action%7BSystem.Object%7D%2CSystem.Object%29?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">En lugar de llamar a este constructor, la manera más común para crear instancias de un <ph id="ph1">&lt;xref:System.Threading.Tasks.Task&gt;</ph> objeto e inicie una tarea consiste en llamar al estático <ph id="ph2">&lt;xref:System.Threading.Tasks.TaskFactory.StartNew%28System.Action%7BSystem.Object%7D%2CSystem.Object%29?displayProperty=nameWithType&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.#ctor(System.Action{System.Object},System.Object)">
          <source>The only advantage offered by this constructor is that it allows object instantiation to be separated from task invocation.</source>
          <target state="translated">La única ventaja que ofrece este constructor es que permite la creación de instancias de objeto se separen de invocación de la tarea.</target>       </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.#ctor(System.Action{System.Object},System.Object)">
          <source>The following example defines an array of 6-letter words.</source>
          <target state="translated">En el ejemplo siguiente se define una matriz de palabras de letra de 6.</target>       </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.#ctor(System.Action{System.Object},System.Object)">
          <source>Each word is then passed as an argument to the <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.%23ctor%28System.Action%7BSystem.Object%7D%2CSystem.Object%29&gt;</ph> constructor, whose <ph id="ph2">&lt;xref:System.Action%601&gt;</ph> delegate scrambles the characters in the word, then displays the original word and its scrambled version.</source>
          <target state="translated">Cada palabra, a continuación, se pasa como argumento a la <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.%23ctor%28System.Action%7BSystem.Object%7D%2CSystem.Object%29&gt;</ph> constructor, cuyo <ph id="ph2">&lt;xref:System.Action%601&gt;</ph> delegado codifica los caracteres de la palabra, a continuación, muestra la palabra original y su versión codificado.</target>       </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.#ctor(System.Action{System.Object},System.Object)">
          <source>The <ph id="ph1">&lt;paramref name="action" /&gt;</ph> argument is null.</source>
          <target state="translated">El argumento <ph id="ph1">&lt;paramref name="action" /&gt;</ph> es null.</target>       </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.#ctor(System.Action,System.Threading.CancellationToken,System.Threading.Tasks.TaskCreationOptions)">
          <source>The delegate that represents the code to execute in the task.</source>
          <target state="translated">Delegado que representa el código que se va a ejecutar en la tarea.</target>       </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.#ctor(System.Action,System.Threading.CancellationToken,System.Threading.Tasks.TaskCreationOptions)">
          <source>The <ph id="ph1">&lt;see cref="P:System.Threading.Tasks.TaskFactory.CancellationToken" /&gt;</ph> that the new task will observe.</source>
          <target state="translated">El <ph id="ph1">&lt;see cref="P:System.Threading.Tasks.TaskFactory.CancellationToken" /&gt;</ph> que observará la nueva tarea.</target>       </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.#ctor(System.Action,System.Threading.CancellationToken,System.Threading.Tasks.TaskCreationOptions)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.TaskCreationOptions" /&gt;</ph> used to customize the task's behavior.</source>
          <target state="translated">El objeto <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.TaskCreationOptions" /&gt;</ph> que se usa para personalizar el comportamiento de la tarea.</target>       </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.#ctor(System.Action,System.Threading.CancellationToken,System.Threading.Tasks.TaskCreationOptions)">
          <source>Initializes a new <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> with the specified action and creation options.</source>
          <target state="translated">Inicializa un nuevo objeto <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> con la acción y las opciones de creación especificadas.</target>       </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.#ctor(System.Action,System.Threading.CancellationToken,System.Threading.Tasks.TaskCreationOptions)">
          <source>Rather than calling this constructor, the most common way to instantiate a <ph id="ph1">&lt;xref:System.Threading.Tasks.Task&gt;</ph> object and launch a task is by calling the static <ph id="ph2">&lt;xref:System.Threading.Tasks.TaskFactory.StartNew%28System.Action%2CSystem.Threading.CancellationToken%2CSystem.Threading.Tasks.TaskCreationOptions%2CSystem.Threading.Tasks.TaskScheduler%29?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">En lugar de llamar a este constructor, la manera más común para crear instancias de un <ph id="ph1">&lt;xref:System.Threading.Tasks.Task&gt;</ph> objeto e inicie una tarea consiste en llamar al estático <ph id="ph2">&lt;xref:System.Threading.Tasks.TaskFactory.StartNew%28System.Action%2CSystem.Threading.CancellationToken%2CSystem.Threading.Tasks.TaskCreationOptions%2CSystem.Threading.Tasks.TaskScheduler%29?displayProperty=nameWithType&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.#ctor(System.Action,System.Threading.CancellationToken,System.Threading.Tasks.TaskCreationOptions)">
          <source>The only advantage offered by this constructor is that it allows object instantiation to be separated from task invocation.</source>
          <target state="translated">La única ventaja que ofrece este constructor es que permite la creación de instancias de objeto se separen de invocación de la tarea.</target>       </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.#ctor(System.Action,System.Threading.CancellationToken,System.Threading.Tasks.TaskCreationOptions)">
          <source>For more information, see <bpt id="p1">[</bpt>Task Parallelism (Task Parallel Library)<ept id="p1">](~/docs/standard/parallel-programming/task-based-asynchronous-programming.md)</ept> and <bpt id="p2">[</bpt>Task Cancellation<ept id="p2">](~/docs/standard/parallel-programming/task-cancellation.md)</ept>.</source>
          <target state="translated">Para obtener más información, consulte <bpt id="p1">[</bpt>paralelismo de tareas (Task Parallel Library)<ept id="p1">](~/docs/standard/parallel-programming/task-based-asynchronous-programming.md)</ept> y <bpt id="p2">[</bpt>cancelación de tareas<ept id="p2">](~/docs/standard/parallel-programming/task-cancellation.md)</ept>.</target>       </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.#ctor(System.Action,System.Threading.CancellationToken,System.Threading.Tasks.TaskCreationOptions)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Threading.CancellationTokenSource" /&gt;</ph> that created <ph id="ph2">&lt;paramref name="cancellationToken" /&gt;</ph> has already been disposed.</source>
          <target state="translated">El <ph id="ph1">&lt;see cref="T:System.Threading.CancellationTokenSource" /&gt;</ph> que creó <ph id="ph2">&lt;paramref name="cancellationToken" /&gt;</ph> ya se ha eliminado.</target>       </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.#ctor(System.Action,System.Threading.CancellationToken,System.Threading.Tasks.TaskCreationOptions)">
          <source>The <ph id="ph1">&lt;paramref name="action" /&gt;</ph> argument is null.</source>
          <target state="translated">El argumento <ph id="ph1">&lt;paramref name="action" /&gt;</ph> es null.</target>       </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.#ctor(System.Action,System.Threading.CancellationToken,System.Threading.Tasks.TaskCreationOptions)">
          <source>The <ph id="ph1">&lt;paramref name="creationOptions" /&gt;</ph> argument specifies an invalid value for <ph id="ph2">&lt;see cref="T:System.Threading.Tasks.TaskCreationOptions" /&gt;</ph>.</source>
          <target state="translated">El argumento <ph id="ph1">&lt;paramref name="creationOptions" /&gt;</ph> especifica un valor no válido para <ph id="ph2">&lt;see cref="T:System.Threading.Tasks.TaskCreationOptions" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.#ctor(System.Action{System.Object},System.Object,System.Threading.CancellationToken)">
          <source>The delegate that represents the code to execute in the task.</source>
          <target state="translated">Delegado que representa el código que se va a ejecutar en la tarea.</target>       </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.#ctor(System.Action{System.Object},System.Object,System.Threading.CancellationToken)">
          <source>An object representing data to be used by the action.</source>
          <target state="translated">Objeto que representa los datos que la acción va a usar.</target>       </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.#ctor(System.Action{System.Object},System.Object,System.Threading.CancellationToken)">
          <source>The <ph id="ph1">&lt;see cref="P:System.Threading.Tasks.TaskFactory.CancellationToken" /&gt;</ph> that that the new task will observe.</source>
          <target state="translated">El <ph id="ph1">&lt;see cref="P:System.Threading.Tasks.TaskFactory.CancellationToken" /&gt;</ph> que observará la nueva tarea.</target>       </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.#ctor(System.Action{System.Object},System.Object,System.Threading.CancellationToken)">
          <source>Initializes a new <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> with the specified action, state, and options.</source>
          <target state="translated">Inicializa un nuevo objeto <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> con la acción, el estado y las opciones especificados.</target>       </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.#ctor(System.Action{System.Object},System.Object,System.Threading.CancellationToken)">
          <source>Rather than calling this constructor, the most common way to instantiate a <ph id="ph1">&lt;xref:System.Threading.Tasks.Task&gt;</ph> object and launch a task is by calling the static <ph id="ph2">&lt;xref:System.Threading.Tasks.TaskFactory.StartNew%28System.Action%7BSystem.Object%7D%2CSystem.Object%2CSystem.Threading.CancellationToken%29?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">En lugar de llamar a este constructor, la manera más común para crear instancias de un <ph id="ph1">&lt;xref:System.Threading.Tasks.Task&gt;</ph> objeto e inicie una tarea consiste en llamar al estático <ph id="ph2">&lt;xref:System.Threading.Tasks.TaskFactory.StartNew%28System.Action%7BSystem.Object%7D%2CSystem.Object%2CSystem.Threading.CancellationToken%29?displayProperty=nameWithType&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.#ctor(System.Action{System.Object},System.Object,System.Threading.CancellationToken)">
          <source>The only advantage offered by this constructor is that it allows object instantiation to be separated from task invocation.</source>
          <target state="translated">La única ventaja que ofrece este constructor es que permite la creación de instancias de objeto se separen de invocación de la tarea.</target>       </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.#ctor(System.Action{System.Object},System.Object,System.Threading.CancellationToken)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Threading.CancellationTokenSource" /&gt;</ph> that created <ph id="ph2">&lt;paramref name="cancellationToken" /&gt;</ph> has already been disposed.</source>
          <target state="translated">El <ph id="ph1">&lt;see cref="T:System.Threading.CancellationTokenSource" /&gt;</ph> que creó <ph id="ph2">&lt;paramref name="cancellationToken" /&gt;</ph> ya se ha eliminado.</target>       </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.#ctor(System.Action{System.Object},System.Object,System.Threading.CancellationToken)">
          <source>The <ph id="ph1">&lt;paramref name="action" /&gt;</ph> argument is null.</source>
          <target state="translated">El argumento <ph id="ph1">&lt;paramref name="action" /&gt;</ph> es null.</target>       </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.#ctor(System.Action{System.Object},System.Object,System.Threading.Tasks.TaskCreationOptions)">
          <source>The delegate that represents the code to execute in the task.</source>
          <target state="translated">Delegado que representa el código que se va a ejecutar en la tarea.</target>       </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.#ctor(System.Action{System.Object},System.Object,System.Threading.Tasks.TaskCreationOptions)">
          <source>An object representing data to be used by the action.</source>
          <target state="translated">Objeto que representa los datos que la acción va a usar.</target>       </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.#ctor(System.Action{System.Object},System.Object,System.Threading.Tasks.TaskCreationOptions)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.TaskCreationOptions" /&gt;</ph> used to customize the task's behavior.</source>
          <target state="translated">El objeto <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.TaskCreationOptions" /&gt;</ph> que se usa para personalizar el comportamiento de la tarea.</target>       </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.#ctor(System.Action{System.Object},System.Object,System.Threading.Tasks.TaskCreationOptions)">
          <source>Initializes a new <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> with the specified action, state, and options.</source>
          <target state="translated">Inicializa un nuevo objeto <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> con la acción, el estado y las opciones especificados.</target>       </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.#ctor(System.Action{System.Object},System.Object,System.Threading.Tasks.TaskCreationOptions)">
          <source>Rather than calling this constructor, the most common way to instantiate a <ph id="ph1">&lt;xref:System.Threading.Tasks.Task&gt;</ph> object and launch a task is by calling the static <ph id="ph2">&lt;xref:System.Threading.Tasks.TaskFactory.StartNew%28System.Action%7BSystem.Object%7D%2CSystem.Object%2CSystem.Threading.Tasks.TaskCreationOptions%29?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">En lugar de llamar a este constructor, la manera más común para crear instancias de un <ph id="ph1">&lt;xref:System.Threading.Tasks.Task&gt;</ph> objeto e inicie una tarea consiste en llamar al estático <ph id="ph2">&lt;xref:System.Threading.Tasks.TaskFactory.StartNew%28System.Action%7BSystem.Object%7D%2CSystem.Object%2CSystem.Threading.Tasks.TaskCreationOptions%29?displayProperty=nameWithType&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.#ctor(System.Action{System.Object},System.Object,System.Threading.Tasks.TaskCreationOptions)">
          <source>The only advantage offered by this constructor is that it allows object instantiation to be separated from task invocation.</source>
          <target state="translated">La única ventaja que ofrece este constructor es que permite la creación de instancias de objeto se separen de invocación de la tarea.</target>       </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.#ctor(System.Action{System.Object},System.Object,System.Threading.Tasks.TaskCreationOptions)">
          <source>The <ph id="ph1">&lt;paramref name="action" /&gt;</ph> argument is null.</source>
          <target state="translated">El argumento <ph id="ph1">&lt;paramref name="action" /&gt;</ph> es null.</target>       </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.#ctor(System.Action{System.Object},System.Object,System.Threading.Tasks.TaskCreationOptions)">
          <source>The <ph id="ph1">&lt;paramref name="creationOptions" /&gt;</ph> argument specifies an invalid value for <ph id="ph2">&lt;see cref="T:System.Threading.Tasks.TaskCreationOptions" /&gt;</ph>.</source>
          <target state="translated">El argumento <ph id="ph1">&lt;paramref name="creationOptions" /&gt;</ph> especifica un valor no válido para <ph id="ph2">&lt;see cref="T:System.Threading.Tasks.TaskCreationOptions" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.#ctor(System.Action{System.Object},System.Object,System.Threading.CancellationToken,System.Threading.Tasks.TaskCreationOptions)">
          <source>The delegate that represents the code to execute in the task.</source>
          <target state="translated">Delegado que representa el código que se va a ejecutar en la tarea.</target>       </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.#ctor(System.Action{System.Object},System.Object,System.Threading.CancellationToken,System.Threading.Tasks.TaskCreationOptions)">
          <source>An object representing data to be used by the action.</source>
          <target state="translated">Objeto que representa los datos que la acción va a usar.</target>       </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.#ctor(System.Action{System.Object},System.Object,System.Threading.CancellationToken,System.Threading.Tasks.TaskCreationOptions)">
          <source>The <ph id="ph1">&lt;see cref="P:System.Threading.Tasks.TaskFactory.CancellationToken" /&gt;</ph> that that the new task will observe..</source>
          <target state="translated">El <ph id="ph1">&lt;see cref="P:System.Threading.Tasks.TaskFactory.CancellationToken" /&gt;</ph> que observará la nueva tarea.</target>       </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.#ctor(System.Action{System.Object},System.Object,System.Threading.CancellationToken,System.Threading.Tasks.TaskCreationOptions)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.TaskCreationOptions" /&gt;</ph> used to customize the task's behavior.</source>
          <target state="translated">El objeto <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.TaskCreationOptions" /&gt;</ph> que se usa para personalizar el comportamiento de la tarea.</target>       </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.#ctor(System.Action{System.Object},System.Object,System.Threading.CancellationToken,System.Threading.Tasks.TaskCreationOptions)">
          <source>Initializes a new <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> with the specified action, state, and options.</source>
          <target state="translated">Inicializa un nuevo objeto <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> con la acción, el estado y las opciones especificados.</target>       </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.#ctor(System.Action{System.Object},System.Object,System.Threading.CancellationToken,System.Threading.Tasks.TaskCreationOptions)">
          <source>Rather than calling this constructor, the most common way to instantiate a <ph id="ph1">&lt;xref:System.Threading.Tasks.Task&gt;</ph> object and launch a task is by calling the static <ph id="ph2">&lt;xref:System.Threading.Tasks.TaskFactory.StartNew%28System.Action%7BSystem.Object%7D%2CSystem.Object%2CSystem.Threading.CancellationToken%2CSystem.Threading.Tasks.TaskCreationOptions%2CSystem.Threading.Tasks.TaskScheduler%29?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">En lugar de llamar a este constructor, la manera más común para crear instancias de un <ph id="ph1">&lt;xref:System.Threading.Tasks.Task&gt;</ph> objeto e inicie una tarea consiste en llamar al estático <ph id="ph2">&lt;xref:System.Threading.Tasks.TaskFactory.StartNew%28System.Action%7BSystem.Object%7D%2CSystem.Object%2CSystem.Threading.CancellationToken%2CSystem.Threading.Tasks.TaskCreationOptions%2CSystem.Threading.Tasks.TaskScheduler%29?displayProperty=nameWithType&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.#ctor(System.Action{System.Object},System.Object,System.Threading.CancellationToken,System.Threading.Tasks.TaskCreationOptions)">
          <source>The only advantage offered by this constructor is that it allows object instantiation to be separated from task invocation.</source>
          <target state="translated">La única ventaja que ofrece este constructor es que permite la creación de instancias de objeto se separen de invocación de la tarea.</target>       </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.#ctor(System.Action{System.Object},System.Object,System.Threading.CancellationToken,System.Threading.Tasks.TaskCreationOptions)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Threading.CancellationTokenSource" /&gt;</ph> that created <ph id="ph2">&lt;paramref name="cancellationToken" /&gt;</ph> has already been disposed.</source>
          <target state="translated">El <ph id="ph1">&lt;see cref="T:System.Threading.CancellationTokenSource" /&gt;</ph> que creó <ph id="ph2">&lt;paramref name="cancellationToken" /&gt;</ph> ya se ha eliminado.</target>       </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.#ctor(System.Action{System.Object},System.Object,System.Threading.CancellationToken,System.Threading.Tasks.TaskCreationOptions)">
          <source>The <ph id="ph1">&lt;paramref name="action" /&gt;</ph> argument is null.</source>
          <target state="translated">El argumento <ph id="ph1">&lt;paramref name="action" /&gt;</ph> es null.</target>       </trans-unit>
        <trans-unit id="252" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.#ctor(System.Action{System.Object},System.Object,System.Threading.CancellationToken,System.Threading.Tasks.TaskCreationOptions)">
          <source>The <ph id="ph1">&lt;paramref name="creationOptions" /&gt;</ph> argument specifies an invalid value for <ph id="ph2">&lt;see cref="T:System.Threading.Tasks.TaskCreationOptions" /&gt;</ph>.</source>
          <target state="translated">El argumento <ph id="ph1">&lt;paramref name="creationOptions" /&gt;</ph> especifica un valor no válido para <ph id="ph2">&lt;see cref="T:System.Threading.Tasks.TaskCreationOptions" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="253" translate="yes" xml:space="preserve" uid="P:System.Threading.Tasks.Task.AsyncState">
          <source>Gets the state object supplied when the <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> was created, or null if none was supplied.</source>
          <target state="translated">Obtiene el objeto de estado que se proporcionó al crearse el objeto <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph>, o null si no se proporcionó ningún objeto de estado.</target>       </trans-unit>
        <trans-unit id="254" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Tasks.Task.AsyncState">
          <source>An <ph id="ph1">&lt;see cref="T:System.Object" /&gt;</ph> that represents the state data that was passed in to the task when it was created.</source>
          <target state="translated">Un <ph id="ph1">&lt;see cref="T:System.Object" /&gt;</ph> que representa los datos de estado que se pasaron a la tarea cuando se creó.</target>       </trans-unit>
        <trans-unit id="255" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Tasks.Task.AsyncState">
          <source>Cast the object back to the original type to retrieve its data.</source>
          <target state="translated">Convierta el objeto al tipo original para recuperar sus datos.</target>       </trans-unit>
        <trans-unit id="256" translate="yes" xml:space="preserve" uid="P:System.Threading.Tasks.Task.CompletedTask">
          <source>Gets a task that has already completed successfully.</source>
          <target state="translated">Obtiene una tarea que ya ha finalizado correctamente.</target>       </trans-unit>
        <trans-unit id="257" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Tasks.Task.CompletedTask">
          <source>The successfully completed task.</source>
          <target state="translated">Tarea completada correctamente.</target>       </trans-unit>
        <trans-unit id="258" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Tasks.Task.CompletedTask">
          <source>This property returns a task whose <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Status%2A&gt;</ph> property is set to <ph id="ph2">&lt;xref:System.Threading.Tasks.TaskStatus.RanToCompletion&gt;</ph>.</source>
          <target state="translated">Esta propiedad devuelve una tarea cuya <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Status%2A&gt;</ph> propiedad está establecida en <ph id="ph2">&lt;xref:System.Threading.Tasks.TaskStatus.RanToCompletion&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="259" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Tasks.Task.CompletedTask">
          <source>To create task that returns a value and runs to completion, call the <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.FromResult%2A&gt;</ph> method.</source>
          <target state="translated">Para crear la tarea que devuelve un valor y se ejecuta por completo, llame a la <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.FromResult%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="260" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Tasks.Task.CompletedTask">
          <source>Repeated attempts to retrieve this property value may not always return the same instance.</source>
          <target state="translated">Los intentos reiterados para recuperar el valor de esta propiedad no pueden devolver siempre la misma instancia.</target>       </trans-unit>
        <trans-unit id="261" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ConfigureAwait(System.Boolean)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> to attempt to marshal the continuation back to the original context captured; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> para intentar calcular las referencias de la continuación de nuevo al contexto original capturado; en caso contrario, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="262" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ConfigureAwait(System.Boolean)">
          <source>Configures an awaiter used to await this <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph>.</source>
          <target state="translated">Configura un awaiter utilizado para esperar a este objeto <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="263" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ConfigureAwait(System.Boolean)">
          <source>An object used to await this task.</source>
          <target state="translated">Objeto utilizado para esperar a esta tarea.</target>       </trans-unit>
        <trans-unit id="264" translate="yes" xml:space="preserve" uid="T:System.Threading.Tasks.Task">
          <source>Creates a continuation that executes asynchronously when the target <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> completes.</source>
          <target state="translated">Crea una continuación que se ejecuta de manera asincrónica cuando se completa el objeto <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> de destino.</target>       </trans-unit>
        <trans-unit id="265" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task})">
          <source>An action to run when the <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> completes.</source>
          <target state="translated">Acción que se va a ejecutar cuando se complete el objeto <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="266" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task})">
          <source>When run, the delegate will be passed the completed task as an argument.</source>
          <target state="translated">Cuando se ejecute, al delegado se le pasará la tarea completada como un argumento.</target>       </trans-unit>
        <trans-unit id="267" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task})">
          <source>Creates a continuation that executes asynchronously when the target <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> completes.</source>
          <target state="translated">Crea una continuación que se ejecuta de manera asincrónica cuando se completa el objeto <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> de destino.</target>       </trans-unit>
        <trans-unit id="268" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task})">
          <source>A new continuation <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph>.</source>
          <target state="translated">Nuevo objeto <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> de continuación.</target>       </trans-unit>
        <trans-unit id="269" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task})">
          <source>The returned <ph id="ph1">&lt;xref:System.Threading.Tasks.Task&gt;</ph> will not be scheduled for execution until the current task has completed, whether it completes due to running to completion successfully, faulting due to an unhandled exception, or exiting out early due to being canceled.</source>
          <target state="translated">El valor devuelto <ph id="ph1">&lt;xref:System.Threading.Tasks.Task&gt;</ph> no se programará para su ejecución hasta que haya completado la tarea actual, si finaliza debido a ejecutarse hasta completarse correctamente, con errores debido a una excepción no controlada o se abandone al principio debido a la cancelación.</target>       </trans-unit>
        <trans-unit id="270" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task})">
          <source>The following example defines a task that populates an array with 100 random date and time values.</source>
          <target state="translated">En el ejemplo siguiente se define una tarea que rellena una matriz con 100 aleatorio valores de fecha y hora.</target>       </trans-unit>
        <trans-unit id="271" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task})">
          <source>It uses the <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.ContinueWith%28System.Action%7BSystem.Threading.Tasks.Task%7D%29&gt;</ph> method to select the earliest and the latest date values once the array is fully populated.</source>
          <target state="translated">Usa el <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.ContinueWith%28System.Action%7BSystem.Threading.Tasks.Task%7D%29&gt;</ph> método para seleccionar la más antigua y los valores de fecha más recientes una vez que se completa la matriz.</target>       </trans-unit>
        <trans-unit id="272" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task})">
          <source>Because a console application may terminate before the continuation task executes, the <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Wait&gt;</ph> method is called to ensure that the continuation finishes executing before the example ends.</source>
          <target state="translated">Dado que una aplicación de consola puede finalizar antes de que se ejecuta la tarea de continuación, el <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Wait&gt;</ph> método se llama para asegurarse de que la continuación termine de ejecutarse antes de los extremos de ejemplo.</target>       </trans-unit>
        <trans-unit id="273" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task})">
          <source>For an additional example, see <bpt id="p1">[</bpt>Chaining Tasks by Using Continuation Tasks<ept id="p1">](~/docs/standard/parallel-programming/chaining-tasks-by-using-continuation-tasks.md)</ept>.</source>
          <target state="translated">Para obtener un ejemplo adicional, consulte <bpt id="p1">[</bpt>encadenar tareas mediante tareas de continuación<ept id="p1">](~/docs/standard/parallel-programming/chaining-tasks-by-using-continuation-tasks.md)</ept>.</target>       </trans-unit>
        <trans-unit id="274" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task})">
          <source>The <ph id="ph1">&lt;paramref name="continuationAction" /&gt;</ph> argument is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">El argumento <ph id="ph1">&lt;paramref name="continuationAction" /&gt;</ph> es <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="275" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task,System.Object},System.Object)">
          <source>An action to run when the task completes.</source>
          <target state="translated">Acción que se ejecutará cuando se complete la tarea.</target>       </trans-unit>
        <trans-unit id="276" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task,System.Object},System.Object)">
          <source>When run, the delegate is passed the completed task and a caller-supplied state object as arguments.</source>
          <target state="translated">Cuando se ejecuta, se pasa al delegado la tarea completada y el objeto de estado proporcionado por el autor de la llamada como argumentos.</target>       </trans-unit>
        <trans-unit id="277" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task,System.Object},System.Object)">
          <source>An object representing data to be used by the continuation action.</source>
          <target state="translated">Objeto que representa los datos que la acción de continuación va a usar.</target>       </trans-unit>
        <trans-unit id="278" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task,System.Object},System.Object)">
          <source>Creates a continuation that receives caller-supplied state information and executes when the target <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> completes.</source>
          <target state="translated">Crea una continuación que recibe información de estado proporcionada por el autor de la llamada y se ejecuta cuando el elemento <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> de destino se completa.</target>       </trans-unit>
        <trans-unit id="279" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task,System.Object},System.Object)">
          <source>A new continuation task.</source>
          <target state="translated">Una tarea de continuación nueva.</target>       </trans-unit>
        <trans-unit id="280" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task,System.Object},System.Object)">
          <source>The returned <ph id="ph1">&lt;xref:System.Threading.Tasks.Task&gt;</ph> will not be scheduled for execution until the current task has completed, whether it completes due to running to completion successfully, faulting due to an unhandled exception, or exiting early due to cancellation.</source>
          <target state="translated">El valor devuelto <ph id="ph1">&lt;xref:System.Threading.Tasks.Task&gt;</ph> no se programará para su ejecución hasta que haya completado la tarea actual, si finaliza debido a ejecutarse hasta completarse correctamente, con errores debido a una excepción no controlada o salir al principio debido a la cancelación.</target>       </trans-unit>
        <trans-unit id="281" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task,System.Object},System.Object)">
          <source>The <ph id="ph1">&lt;paramref name="continuationAction" /&gt;</ph> argument is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">El argumento <ph id="ph1">&lt;paramref name="continuationAction" /&gt;</ph> es <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="282" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task},System.Threading.CancellationToken)">
          <source>An action to run when the <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> completes.</source>
          <target state="translated">Acción que se va a ejecutar cuando se complete el objeto <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="283" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task},System.Threading.CancellationToken)">
          <source>When run, the delegate will be passed the completed task as an argument.</source>
          <target state="translated">Cuando se ejecute, al delegado se le pasará la tarea completada como un argumento.</target>       </trans-unit>
        <trans-unit id="284" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task},System.Threading.CancellationToken)">
          <source>The <ph id="ph1">&lt;see cref="P:System.Threading.Tasks.TaskFactory.CancellationToken" /&gt;</ph> that will be assigned to the new continuation task.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="P:System.Threading.Tasks.TaskFactory.CancellationToken" /&gt;</ph> que se asignará a la nueva tarea de continuación.</target>       </trans-unit>
        <trans-unit id="285" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task},System.Threading.CancellationToken)">
          <source>Creates a continuation that receives a cancellation token and executes asynchronously when the target <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> completes.</source>
          <target state="translated">Crea una continuación que recibe un token de cancelación y se ejecuta de forma asincrónica cuando el elemento <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> de destino se completa.</target>       </trans-unit>
        <trans-unit id="286" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task},System.Threading.CancellationToken)">
          <source>A new continuation <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph>.</source>
          <target state="translated">Nuevo objeto <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> de continuación.</target>       </trans-unit>
        <trans-unit id="287" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task},System.Threading.CancellationToken)">
          <source>The returned <ph id="ph1">&lt;xref:System.Threading.Tasks.Task&gt;</ph> will not be scheduled for execution until the current task has completed, whether it completes due to running to completion successfully, faulting due to an unhandled exception, or exiting out early due to being canceled.</source>
          <target state="translated">El valor devuelto <ph id="ph1">&lt;xref:System.Threading.Tasks.Task&gt;</ph> no se programará para su ejecución hasta que haya completado la tarea actual, si finaliza debido a ejecutarse hasta completarse correctamente, con errores debido a una excepción no controlada o se abandone al principio debido a la cancelación.</target>       </trans-unit>
        <trans-unit id="288" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task},System.Threading.CancellationToken)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Threading.CancellationTokenSource" /&gt;</ph> that created the token has already been disposed.</source>
          <target state="translated">El <ph id="ph1">&lt;see cref="T:System.Threading.CancellationTokenSource" /&gt;</ph> que creó el token ya se ha eliminado.</target>       </trans-unit>
        <trans-unit id="289" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task},System.Threading.CancellationToken)">
          <source>The <ph id="ph1">&lt;paramref name="continuationAction" /&gt;</ph> argument is null.</source>
          <target state="translated">El argumento <ph id="ph1">&lt;paramref name="continuationAction" /&gt;</ph> es null.</target>       </trans-unit>
        <trans-unit id="290" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task},System.Threading.Tasks.TaskContinuationOptions)">
          <source>An action to run according to the specified <bpt id="p1">&lt;c&gt;</bpt>continuationOptions<ept id="p1">&lt;/c&gt;</ept>.</source>
          <target state="translated">Una acción que se ejecutará según el parámetro <bpt id="p1">&lt;c&gt;</bpt>continuationOptions<ept id="p1">&lt;/c&gt;</ept> especificado.</target>       </trans-unit>
        <trans-unit id="291" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task},System.Threading.Tasks.TaskContinuationOptions)">
          <source>When run, the delegate will be passed the completed task as an argument.</source>
          <target state="translated">Cuando se ejecute, al delegado se le pasará la tarea completada como un argumento.</target>       </trans-unit>
        <trans-unit id="292" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task},System.Threading.Tasks.TaskContinuationOptions)">
          <source>Options for when the continuation is scheduled and how it behaves.</source>
          <target state="translated">Opciones para la programación y el comportamiento de la continuación.</target>       </trans-unit>
        <trans-unit id="293" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task},System.Threading.Tasks.TaskContinuationOptions)">
          <source>This includes criteria, such as <ph id="ph1">&lt;see cref="F:System.Threading.Tasks.TaskContinuationOptions.OnlyOnCanceled" /&gt;</ph>, as well as execution options, such as <ph id="ph2">&lt;see cref="F:System.Threading.Tasks.TaskContinuationOptions.ExecuteSynchronously" /&gt;</ph>.</source>
          <target state="translated">Incluye criterios, como <ph id="ph1">&lt;see cref="F:System.Threading.Tasks.TaskContinuationOptions.OnlyOnCanceled" /&gt;</ph>, y opciones de ejecución, como <ph id="ph2">&lt;see cref="F:System.Threading.Tasks.TaskContinuationOptions.ExecuteSynchronously" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="294" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task},System.Threading.Tasks.TaskContinuationOptions)">
          <source>Creates a continuation that executes when the target task completes according to the specified <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.TaskContinuationOptions" /&gt;</ph>.</source>
          <target state="translated">Crea una continuación que se ejecuta cuando se completa la tarea de destino según el elemento <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.TaskContinuationOptions" /&gt;</ph> especificado.</target>       </trans-unit>
        <trans-unit id="295" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task},System.Threading.Tasks.TaskContinuationOptions)">
          <source>A new continuation <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph>.</source>
          <target state="translated">Nuevo objeto <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> de continuación.</target>       </trans-unit>
        <trans-unit id="296" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task},System.Threading.Tasks.TaskContinuationOptions)">
          <source>The returned <ph id="ph1">&lt;xref:System.Threading.Tasks.Task&gt;</ph> will not be scheduled for execution until the current task has completed.</source>
          <target state="translated">El valor devuelto <ph id="ph1">&lt;xref:System.Threading.Tasks.Task&gt;</ph> no se programará para su ejecución hasta que haya completado la tarea actual.</target>       </trans-unit>
        <trans-unit id="297" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task},System.Threading.Tasks.TaskContinuationOptions)">
          <source>If the continuation criteria specified through the <ph id="ph1">`continuationOptions`</ph> parameter are not met, the continuation task will be canceled instead of scheduled.</source>
          <target state="translated">Si especifican los criterios de continuación a través de la <ph id="ph1">`continuationOptions`</ph> parámetro no se cumplen, se cancela la tarea de continuación en lugar de programarse.</target>       </trans-unit>
        <trans-unit id="298" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task},System.Threading.Tasks.TaskContinuationOptions)">
          <source>The following example demonstrates using <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskContinuationOptions&gt;</ph> to specify that a continuation task should run synchronously when the antecedent task completes.</source>
          <target state="translated">En el ejemplo siguiente se muestra cómo utilizar <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskContinuationOptions&gt;</ph> para especificar que una tarea de continuación debe ejecutarse sincrónicamente cuando se complete la tarea anterior.</target>       </trans-unit>
        <trans-unit id="299" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task},System.Threading.Tasks.TaskContinuationOptions)">
          <source>(If the specified task has already completed by the time <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.ContinueWith%2A&gt;</ph> is called, the synchronous continuation will run on the thread calling <ph id="ph2">&lt;xref:System.Threading.Tasks.Task.ContinueWith%2A&gt;</ph>.)</source>
          <target state="translated">(Si la tarea especificada ya se ha completado por el tiempo <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.ContinueWith%2A&gt;</ph> se llama, sincrónico se ejecutará a continuación en la llamada del subproceso <ph id="ph2">&lt;xref:System.Threading.Tasks.Task.ContinueWith%2A&gt;</ph>.)</target>       </trans-unit>
        <trans-unit id="300" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task},System.Threading.Tasks.TaskContinuationOptions)">
          <source>The <ph id="ph1">&lt;paramref name="continuationAction" /&gt;</ph> argument is null.</source>
          <target state="translated">El argumento <ph id="ph1">&lt;paramref name="continuationAction" /&gt;</ph> es null.</target>       </trans-unit>
        <trans-unit id="301" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task},System.Threading.Tasks.TaskContinuationOptions)">
          <source>The <ph id="ph1">&lt;paramref name="continuationOptions" /&gt;</ph> argument specifies an invalid value for <ph id="ph2">&lt;see cref="T:System.Threading.Tasks.TaskContinuationOptions" /&gt;</ph>.</source>
          <target state="translated">El argumento <ph id="ph1">&lt;paramref name="continuationOptions" /&gt;</ph> especifica un valor no válido para <ph id="ph2">&lt;see cref="T:System.Threading.Tasks.TaskContinuationOptions" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="302" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task},System.Threading.Tasks.TaskScheduler)">
          <source>An action to run when the <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> completes.</source>
          <target state="translated">Acción que se va a ejecutar cuando se complete el objeto <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="303" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task},System.Threading.Tasks.TaskScheduler)">
          <source>When run, the delegate will be passed the completed task as an argument.</source>
          <target state="translated">Cuando se ejecute, al delegado se le pasará la tarea completada como un argumento.</target>       </trans-unit>
        <trans-unit id="304" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task},System.Threading.Tasks.TaskScheduler)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.TaskScheduler" /&gt;</ph> to associate with the continuation task and to use for its execution.</source>
          <target state="translated">Objeto <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.TaskScheduler" /&gt;</ph> que se va a asociar a la tarea de continuación y se va a usar para su ejecución.</target>       </trans-unit>
        <trans-unit id="305" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task},System.Threading.Tasks.TaskScheduler)">
          <source>Creates a continuation that executes asynchronously when the target <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> completes.</source>
          <target state="translated">Crea una continuación que se ejecuta de manera asincrónica cuando se completa el objeto <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> de destino.</target>       </trans-unit>
        <trans-unit id="306" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task},System.Threading.Tasks.TaskScheduler)">
          <source>The continuation uses a specified scheduler.</source>
          <target state="translated">La continuación usa un programador especificado.</target>       </trans-unit>
        <trans-unit id="307" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task},System.Threading.Tasks.TaskScheduler)">
          <source>A new continuation <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph>.</source>
          <target state="translated">Nuevo objeto <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> de continuación.</target>       </trans-unit>
        <trans-unit id="308" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task},System.Threading.Tasks.TaskScheduler)">
          <source>The returned <ph id="ph1">&lt;xref:System.Threading.Tasks.Task&gt;</ph> will not be scheduled for execution until the current task has completed, whether it completes due to running to completion successfully, faulting due to an unhandled exception, or exiting out early due to being canceled.</source>
          <target state="translated">El valor devuelto <ph id="ph1">&lt;xref:System.Threading.Tasks.Task&gt;</ph> no se programará para su ejecución hasta que haya completado la tarea actual, si finaliza debido a ejecutarse hasta completarse correctamente, con errores debido a una excepción no controlada o se abandone al principio debido a la cancelación.</target>       </trans-unit>
        <trans-unit id="309" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task},System.Threading.Tasks.TaskScheduler)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> has been disposed.</source>
          <target state="translated">Se ha eliminado <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="310" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task},System.Threading.Tasks.TaskScheduler)">
          <source>The <ph id="ph1">&lt;paramref name="continuationAction" /&gt;</ph> argument is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">El argumento <ph id="ph1">&lt;paramref name="continuationAction" /&gt;</ph> es <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="311" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task},System.Threading.Tasks.TaskScheduler)">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="312" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task},System.Threading.Tasks.TaskScheduler)">
          <source>The <ph id="ph1">&lt;paramref name="scheduler" /&gt;</ph> argument is null.</source>
          <target state="translated">El argumento <ph id="ph1">&lt;paramref name="scheduler" /&gt;</ph> es null.</target>       </trans-unit>
        <trans-unit id="313" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task,System.Object},System.Object,System.Threading.CancellationToken)">
          <source>An action to run when the <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> completes.</source>
          <target state="translated">Acción que se va a ejecutar cuando se complete el objeto <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="314" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task,System.Object},System.Object,System.Threading.CancellationToken)">
          <source>When run, the delegate will be passed the completed task and the caller-supplied state object as arguments.</source>
          <target state="translated">Cuando se ejecute, se pasarán al delegado la tarea completada y el objeto de estado proporcionado por el llamador como argumentos.</target>       </trans-unit>
        <trans-unit id="315" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task,System.Object},System.Object,System.Threading.CancellationToken)">
          <source>An object representing data to be used by the continuation action.</source>
          <target state="translated">Objeto que representa los datos que la acción de continuación va a usar.</target>       </trans-unit>
        <trans-unit id="316" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task,System.Object},System.Object,System.Threading.CancellationToken)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Threading.CancellationToken" /&gt;</ph> that will be assigned to the new continuation task.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Threading.CancellationToken" /&gt;</ph> que se asignará a la nueva tarea de continuación.</target>       </trans-unit>
        <trans-unit id="317" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task,System.Object},System.Object,System.Threading.CancellationToken)">
          <source>Creates a continuation that receives caller-supplied state information and a cancellation token and that executes asynchronously when the target <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> completes.</source>
          <target state="translated">Crea una continuación que recibe información de estado proporcionada por el autor de la llamada y un token de cancelación y que se ejecuta de forma asincrónica cuando el elemento <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> de destino se completa.</target>       </trans-unit>
        <trans-unit id="318" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task,System.Object},System.Object,System.Threading.CancellationToken)">
          <source>A new continuation <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph>.</source>
          <target state="translated">Nuevo objeto <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> de continuación.</target>       </trans-unit>
        <trans-unit id="319" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task,System.Object},System.Object,System.Threading.CancellationToken)">
          <source>The returned <ph id="ph1">&lt;xref:System.Threading.Tasks.Task&gt;</ph> will not be scheduled for execution until the current task has  completed, whether it completes due to running to completion successfully, faulting due to an  unhandled exception, or exiting out early due to being canceled.</source>
          <target state="translated">El valor devuelto <ph id="ph1">&lt;xref:System.Threading.Tasks.Task&gt;</ph> no se programará para su ejecución hasta que haya completado la tarea actual, si finaliza debido a ejecutarse hasta completarse correctamente, con errores debido a una excepción no controlada o se abandone al principio debido a la cancelación.</target>       </trans-unit>
        <trans-unit id="320" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task,System.Object},System.Object,System.Threading.CancellationToken)">
          <source>The <ph id="ph1">&lt;paramref name="continuationAction" /&gt;</ph> argument is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">El argumento <ph id="ph1">&lt;paramref name="continuationAction" /&gt;</ph> es <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="321" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task,System.Object},System.Object,System.Threading.CancellationToken)">
          <source>The provided <ph id="ph1">&lt;see cref="T:System.Threading.CancellationToken" /&gt;</ph> has already been disposed.</source>
          <target state="translated">El <ph id="ph1">&lt;see cref="T:System.Threading.CancellationToken" /&gt;</ph> proporcionado ya se ha eliminado.</target>       </trans-unit>
        <trans-unit id="322" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task,System.Object},System.Object,System.Threading.Tasks.TaskContinuationOptions)">
          <source>An action to run when the <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> completes.</source>
          <target state="translated">Acción que se va a ejecutar cuando se complete el objeto <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="323" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task,System.Object},System.Object,System.Threading.Tasks.TaskContinuationOptions)">
          <source>When run, the delegate will be  passed the completed task and the caller-supplied state object as arguments.</source>
          <target state="translated">Cuando se ejecute, se pasarán al delegado la tarea completada y el objeto de estado proporcionado por el llamador como argumentos.</target>       </trans-unit>
        <trans-unit id="324" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task,System.Object},System.Object,System.Threading.Tasks.TaskContinuationOptions)">
          <source>An object representing data to be used by the continuation action.</source>
          <target state="translated">Objeto que representa los datos que la acción de continuación va a usar.</target>       </trans-unit>
        <trans-unit id="325" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task,System.Object},System.Object,System.Threading.Tasks.TaskContinuationOptions)">
          <source>Options for when the continuation is scheduled and how it behaves.</source>
          <target state="translated">Opciones para la programación y el comportamiento de la continuación.</target>       </trans-unit>
        <trans-unit id="326" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task,System.Object},System.Object,System.Threading.Tasks.TaskContinuationOptions)">
          <source>This includes criteria, such as <ph id="ph1">&lt;see cref="F:System.Threading.Tasks.TaskContinuationOptions.OnlyOnCanceled" /&gt;</ph>, as well as execution options, such as <ph id="ph2">&lt;see cref="F:System.Threading.Tasks.TaskContinuationOptions.ExecuteSynchronously" /&gt;</ph>.</source>
          <target state="translated">Incluye criterios, como <ph id="ph1">&lt;see cref="F:System.Threading.Tasks.TaskContinuationOptions.OnlyOnCanceled" /&gt;</ph>, y opciones de ejecución, como <ph id="ph2">&lt;see cref="F:System.Threading.Tasks.TaskContinuationOptions.ExecuteSynchronously" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="327" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task,System.Object},System.Object,System.Threading.Tasks.TaskContinuationOptions)">
          <source>Creates a continuation that receives caller-supplied state information and executes when the target <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> completes.</source>
          <target state="translated">Crea una continuación que recibe información de estado proporcionada por el autor de la llamada y se ejecuta cuando el elemento <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> de destino se completa.</target>       </trans-unit>
        <trans-unit id="328" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task,System.Object},System.Object,System.Threading.Tasks.TaskContinuationOptions)">
          <source>The continuation executes based on a set of specified conditions.</source>
          <target state="translated">La continuación se ejecuta según un conjunto de condiciones especificadas.</target>       </trans-unit>
        <trans-unit id="329" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task,System.Object},System.Object,System.Threading.Tasks.TaskContinuationOptions)">
          <source>A new continuation <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph>.</source>
          <target state="translated">Nuevo objeto <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> de continuación.</target>       </trans-unit>
        <trans-unit id="330" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task,System.Object},System.Object,System.Threading.Tasks.TaskContinuationOptions)">
          <source>The returned <ph id="ph1">&lt;xref:System.Threading.Tasks.Task&gt;</ph> will not be scheduled for execution until the current task has completed.</source>
          <target state="translated">El valor devuelto <ph id="ph1">&lt;xref:System.Threading.Tasks.Task&gt;</ph> no se programará para su ejecución hasta que haya completado la tarea actual.</target>       </trans-unit>
        <trans-unit id="331" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task,System.Object},System.Object,System.Threading.Tasks.TaskContinuationOptions)">
          <source>If the continuation criteria specified through the <ph id="ph1">`continuationOptions`</ph> parameter are not met, the continuation task will be canceled instead of scheduled.</source>
          <target state="translated">Si especifican los criterios de continuación a través de la <ph id="ph1">`continuationOptions`</ph> parámetro no se cumplen, se cancela la tarea de continuación en lugar de programarse.</target>       </trans-unit>
        <trans-unit id="332" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task,System.Object},System.Object,System.Threading.Tasks.TaskContinuationOptions)">
          <source>The <ph id="ph1">&lt;paramref name="continuationAction" /&gt;</ph> argument is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">El argumento <ph id="ph1">&lt;paramref name="continuationAction" /&gt;</ph> es <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="333" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task,System.Object},System.Object,System.Threading.Tasks.TaskContinuationOptions)">
          <source>The <ph id="ph1">&lt;paramref name="continuationOptions" /&gt;</ph> argument specifies an invalid value for <ph id="ph2">&lt;see cref="T:System.Threading.Tasks.TaskContinuationOptions" /&gt;</ph>.</source>
          <target state="translated">El argumento <ph id="ph1">&lt;paramref name="continuationOptions" /&gt;</ph> especifica un valor no válido para <ph id="ph2">&lt;see cref="T:System.Threading.Tasks.TaskContinuationOptions" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="334" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task,System.Object},System.Object,System.Threading.Tasks.TaskScheduler)">
          <source>An action to run when the <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> completes.</source>
          <target state="translated">Acción que se va a ejecutar cuando se complete el objeto <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="335" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task,System.Object},System.Object,System.Threading.Tasks.TaskScheduler)">
          <source>When run, the delegate will be  passed the completed task and the caller-supplied state object as arguments.</source>
          <target state="translated">Cuando se ejecute, se pasarán al delegado la tarea completada y el objeto de estado proporcionado por el llamador como argumentos.</target>       </trans-unit>
        <trans-unit id="336" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task,System.Object},System.Object,System.Threading.Tasks.TaskScheduler)">
          <source>An object representing data to be used by the continuation action.</source>
          <target state="translated">Objeto que representa los datos que la acción de continuación va a usar.</target>       </trans-unit>
        <trans-unit id="337" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task,System.Object},System.Object,System.Threading.Tasks.TaskScheduler)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.TaskScheduler" /&gt;</ph> to associate with the continuation task and to use for its execution.</source>
          <target state="translated">Objeto <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.TaskScheduler" /&gt;</ph> que se va a asociar a la tarea de continuación y se va a usar para su ejecución.</target>       </trans-unit>
        <trans-unit id="338" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task,System.Object},System.Object,System.Threading.Tasks.TaskScheduler)">
          <source>Creates a continuation that receives caller-supplied state information and executes asynchronously when the target <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> completes.</source>
          <target state="translated">Crea una continuación que recibe información de estado proporcionada por el autor de la llamada y se ejecuta de forma asincrónica cuando el elemento <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> de destino se completa.</target>       </trans-unit>
        <trans-unit id="339" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task,System.Object},System.Object,System.Threading.Tasks.TaskScheduler)">
          <source>The continuation uses a specified scheduler.</source>
          <target state="translated">La continuación usa un programador especificado.</target>       </trans-unit>
        <trans-unit id="340" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task,System.Object},System.Object,System.Threading.Tasks.TaskScheduler)">
          <source>A new continuation <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph>.</source>
          <target state="translated">Nuevo objeto <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> de continuación.</target>       </trans-unit>
        <trans-unit id="341" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task,System.Object},System.Object,System.Threading.Tasks.TaskScheduler)">
          <source>The returned <ph id="ph1">&lt;xref:System.Threading.Tasks.Task&gt;</ph> will not be scheduled for execution until the current task has  completed, whether it completes due to running to completion successfully, faulting due to an  unhandled exception, or exiting out early due to being canceled.</source>
          <target state="translated">El valor devuelto <ph id="ph1">&lt;xref:System.Threading.Tasks.Task&gt;</ph> no se programará para su ejecución hasta que haya completado la tarea actual, si finaliza debido a ejecutarse hasta completarse correctamente, con errores debido a una excepción no controlada o se abandone al principio debido a la cancelación.</target>       </trans-unit>
        <trans-unit id="342" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task,System.Object},System.Object,System.Threading.Tasks.TaskScheduler)">
          <source>The <ph id="ph1">&lt;paramref name="scheduler" /&gt;</ph> argument is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">El argumento <ph id="ph1">&lt;paramref name="scheduler" /&gt;</ph> es <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="343" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task},System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)">
          <source>An action to run according to the specified <bpt id="p1">&lt;c&gt;</bpt>continuationOptions<ept id="p1">&lt;/c&gt;</ept>.</source>
          <target state="translated">Una acción que se ejecutará según el parámetro <bpt id="p1">&lt;c&gt;</bpt>continuationOptions<ept id="p1">&lt;/c&gt;</ept> especificado.</target>       </trans-unit>
        <trans-unit id="344" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task},System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)">
          <source>When run, the delegate will be passed the completed task as an argument.</source>
          <target state="translated">Cuando se ejecute, al delegado se le pasará la tarea completada como un argumento.</target>       </trans-unit>
        <trans-unit id="345" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task},System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)">
          <source>The <ph id="ph1">&lt;see cref="P:System.Threading.Tasks.TaskFactory.CancellationToken" /&gt;</ph> that will be assigned to the new continuation task.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="P:System.Threading.Tasks.TaskFactory.CancellationToken" /&gt;</ph> que se asignará a la nueva tarea de continuación.</target>       </trans-unit>
        <trans-unit id="346" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task},System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)">
          <source>Options for when the continuation is scheduled and how it behaves.</source>
          <target state="translated">Opciones para la programación y el comportamiento de la continuación.</target>       </trans-unit>
        <trans-unit id="347" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task},System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)">
          <source>This includes criteria, such as <ph id="ph1">&lt;see cref="F:System.Threading.Tasks.TaskContinuationOptions.OnlyOnCanceled" /&gt;</ph>, as well as execution options, such as <ph id="ph2">&lt;see cref="F:System.Threading.Tasks.TaskContinuationOptions.ExecuteSynchronously" /&gt;</ph>.</source>
          <target state="translated">Incluye criterios, como <ph id="ph1">&lt;see cref="F:System.Threading.Tasks.TaskContinuationOptions.OnlyOnCanceled" /&gt;</ph>, y opciones de ejecución, como <ph id="ph2">&lt;see cref="F:System.Threading.Tasks.TaskContinuationOptions.ExecuteSynchronously" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="348" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task},System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.TaskScheduler" /&gt;</ph> to associate with the continuation task and to use for its execution.</source>
          <target state="translated">Objeto <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.TaskScheduler" /&gt;</ph> que se va a asociar a la tarea de continuación y se va a usar para su ejecución.</target>       </trans-unit>
        <trans-unit id="349" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task},System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)">
          <source>Creates a continuation that executes when the target task competes according to the specified <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.TaskContinuationOptions" /&gt;</ph>.</source>
          <target state="translated">Crea una continuación que se ejecuta cuando se completa la tarea de destino según el elemento <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.TaskContinuationOptions" /&gt;</ph> especificado.</target>       </trans-unit>
        <trans-unit id="350" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task},System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)">
          <source>The continuation receives a cancellation token and uses a specified scheduler.</source>
          <target state="translated">La continuación recibe un token de cancelación y usa un programador especificado.</target>       </trans-unit>
        <trans-unit id="351" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task},System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)">
          <source>A new continuation <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph>.</source>
          <target state="translated">Nuevo objeto <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> de continuación.</target>       </trans-unit>
        <trans-unit id="352" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task},System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)">
          <source>The returned <ph id="ph1">&lt;xref:System.Threading.Tasks.Task&gt;</ph> will not be scheduled for execution until the current task has completed.</source>
          <target state="translated">El valor devuelto <ph id="ph1">&lt;xref:System.Threading.Tasks.Task&gt;</ph> no se programará para su ejecución hasta que haya completado la tarea actual.</target>       </trans-unit>
        <trans-unit id="353" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task},System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)">
          <source>If the criteria specified through the <ph id="ph1">`continuationOptions`</ph> parameter are not met, the continuation task will be canceled instead of scheduled.</source>
          <target state="translated">Si los criterios especifican a través de la <ph id="ph1">`continuationOptions`</ph> parámetro no se cumplen, se cancela la tarea de continuación en lugar de programarse.</target>       </trans-unit>
        <trans-unit id="354" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task},System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)">
          <source>The following is an example of using ContinueWith to run work both in the background and on the user interface threads.</source>
          <target state="translated">El siguiente es un ejemplo del uso de ContinueWith para ejecutar el trabajo en segundo plano y el usuario de subprocesos de interfaz.</target>       </trans-unit>
        <trans-unit id="355" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task},System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Threading.CancellationTokenSource" /&gt;</ph> that created the token has already been disposed.</source>
          <target state="translated">El <ph id="ph1">&lt;see cref="T:System.Threading.CancellationTokenSource" /&gt;</ph> que creó el token ya se ha eliminado.</target>       </trans-unit>
        <trans-unit id="356" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task},System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)">
          <source>The <ph id="ph1">&lt;paramref name="continuationAction" /&gt;</ph> argument is null.</source>
          <target state="translated">El argumento <ph id="ph1">&lt;paramref name="continuationAction" /&gt;</ph> es null.</target>       </trans-unit>
        <trans-unit id="357" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task},System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="358" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task},System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)">
          <source>The <ph id="ph1">&lt;paramref name="scheduler" /&gt;</ph> argument is null.</source>
          <target state="translated">El argumento <ph id="ph1">&lt;paramref name="scheduler" /&gt;</ph> es null.</target>       </trans-unit>
        <trans-unit id="359" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task},System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)">
          <source>The <ph id="ph1">&lt;paramref name="continuationOptions" /&gt;</ph> argument specifies an invalid value for <ph id="ph2">&lt;see cref="T:System.Threading.Tasks.TaskContinuationOptions" /&gt;</ph>.</source>
          <target state="translated">El argumento <ph id="ph1">&lt;paramref name="continuationOptions" /&gt;</ph> especifica un valor no válido para <ph id="ph2">&lt;see cref="T:System.Threading.Tasks.TaskContinuationOptions" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="360" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task,System.Object},System.Object,System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)">
          <source>An action to run when the <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> completes.</source>
          <target state="translated">Acción que se va a ejecutar cuando se complete el objeto <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="361" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task,System.Object},System.Object,System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)">
          <source>When run, the delegate will be  passed the completed task and the caller-supplied state object as arguments.</source>
          <target state="translated">Cuando se ejecute, se pasarán al delegado la tarea completada y el objeto de estado proporcionado por el llamador como argumentos.</target>       </trans-unit>
        <trans-unit id="362" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task,System.Object},System.Object,System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)">
          <source>An object representing data to be used by the continuation action.</source>
          <target state="translated">Objeto que representa los datos que la acción de continuación va a usar.</target>       </trans-unit>
        <trans-unit id="363" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task,System.Object},System.Object,System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Threading.CancellationToken" /&gt;</ph> that will be assigned to the new continuation task.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Threading.CancellationToken" /&gt;</ph> que se asignará a la nueva tarea de continuación.</target>       </trans-unit>
        <trans-unit id="364" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task,System.Object},System.Object,System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)">
          <source>Options for when the continuation is scheduled and how it behaves.</source>
          <target state="translated">Opciones para la programación y el comportamiento de la continuación.</target>       </trans-unit>
        <trans-unit id="365" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task,System.Object},System.Object,System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)">
          <source>This includes criteria, such as <ph id="ph1">&lt;see cref="F:System.Threading.Tasks.TaskContinuationOptions.OnlyOnCanceled" /&gt;</ph>, as well as execution options, such as <ph id="ph2">&lt;see cref="F:System.Threading.Tasks.TaskContinuationOptions.ExecuteSynchronously" /&gt;</ph>.</source>
          <target state="translated">Incluye criterios, como <ph id="ph1">&lt;see cref="F:System.Threading.Tasks.TaskContinuationOptions.OnlyOnCanceled" /&gt;</ph>, y opciones de ejecución, como <ph id="ph2">&lt;see cref="F:System.Threading.Tasks.TaskContinuationOptions.ExecuteSynchronously" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="366" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task,System.Object},System.Object,System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.TaskScheduler" /&gt;</ph> to associate with the continuation task and to use for its  execution.</source>
          <target state="translated">Objeto <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.TaskScheduler" /&gt;</ph> que se va a asociar a la tarea de continuación y se va a usar para su ejecución.</target>       </trans-unit>
        <trans-unit id="367" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task,System.Object},System.Object,System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)">
          <source>Creates a continuation that receives caller-supplied state information and a cancellation token and that executes when the target <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> completes.</source>
          <target state="translated">Crea una continuación que recibe información de estado proporcionada por el autor de la llamada y un token de cancelación y que se ejecuta cuando el elemento <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> de destino se completa.</target>       </trans-unit>
        <trans-unit id="368" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task,System.Object},System.Object,System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)">
          <source>The continuation executes based on a set of specified conditions and uses a specified scheduler.</source>
          <target state="translated">La continuación se ejecuta según un conjunto de condiciones especificadas y usa un programador especificado.</target>       </trans-unit>
        <trans-unit id="369" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task,System.Object},System.Object,System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)">
          <source>A new continuation <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph>.</source>
          <target state="translated">Nuevo objeto <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> de continuación.</target>       </trans-unit>
        <trans-unit id="370" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task,System.Object},System.Object,System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)">
          <source>The returned <ph id="ph1">&lt;xref:System.Threading.Tasks.Task&gt;</ph> will not be scheduled for execution until the current task has  completed.</source>
          <target state="translated">El valor devuelto <ph id="ph1">&lt;xref:System.Threading.Tasks.Task&gt;</ph> no se programará para su ejecución hasta que haya completado la tarea actual.</target>       </trans-unit>
        <trans-unit id="371" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task,System.Object},System.Object,System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)">
          <source>If the criteria specified through the <ph id="ph1">`continuationOptions`</ph> parameter  are not met, the continuation task will be canceled instead of scheduled.</source>
          <target state="translated">Si los criterios especifican a través de la <ph id="ph1">`continuationOptions`</ph> parámetro no se cumplen, se cancela la tarea de continuación en lugar de programarse.</target>       </trans-unit>
        <trans-unit id="372" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task,System.Object},System.Object,System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)">
          <source>The <ph id="ph1">&lt;paramref name="scheduler" /&gt;</ph> argument is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">El argumento <ph id="ph1">&lt;paramref name="scheduler" /&gt;</ph> es <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="373" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task,System.Object},System.Object,System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)">
          <source>The <ph id="ph1">&lt;paramref name="continuationOptions" /&gt;</ph> argument specifies an invalid value for <ph id="ph2">&lt;see cref="T:System.Threading.Tasks.TaskContinuationOptions" /&gt;</ph>.</source>
          <target state="translated">El argumento <ph id="ph1">&lt;paramref name="continuationOptions" /&gt;</ph> especifica un valor no válido para <ph id="ph2">&lt;see cref="T:System.Threading.Tasks.TaskContinuationOptions" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="374" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task,System.Object},System.Object,System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)">
          <source>The provided <ph id="ph1">&lt;see cref="T:System.Threading.CancellationToken" /&gt;</ph> has already been disposed.</source>
          <target state="translated">El <ph id="ph1">&lt;see cref="T:System.Threading.CancellationToken" /&gt;</ph> proporcionado ya se ha eliminado.</target>       </trans-unit>
        <trans-unit id="375" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,``0})">
          <source>The type of the result produced by the continuation.</source>
          <target state="translated">Tipo de resultado generado por la continuación.</target>       </trans-unit>
        <trans-unit id="376" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,``0})">
          <source>A function to run when the <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task`1" /&gt;</ph> completes.</source>
          <target state="translated">Función que se va a ejecutar cuando se complete el objeto <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task`1" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="377" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,``0})">
          <source>When run, the delegate will be passed the completed task as an argument.</source>
          <target state="translated">Cuando se ejecute, al delegado se le pasará la tarea completada como un argumento.</target>       </trans-unit>
        <trans-unit id="378" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,``0})">
          <source>Creates a continuation that executes asynchronously when the target <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task`1" /&gt;</ph> completes and returns a value.</source>
          <target state="translated">Crea una continuación que se ejecuta de forma asincrónica cuando el elemento <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task`1" /&gt;</ph> de destino se completa y devuelve un valor.</target>       </trans-unit>
        <trans-unit id="379" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,``0})">
          <source>A new continuation task.</source>
          <target state="translated">Una tarea de continuación nueva.</target>       </trans-unit>
        <trans-unit id="380" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,``0})">
          <source>The returned <ph id="ph1">&lt;xref:System.Threading.Tasks.Task%601&gt;</ph> will not be scheduled for execution until the current task has completed, whether it completes due to running to completion successfully, faulting due to an unhandled exception, or exiting out early due to being canceled.</source>
          <target state="translated">El valor devuelto <ph id="ph1">&lt;xref:System.Threading.Tasks.Task%601&gt;</ph> no se programará para su ejecución hasta que haya completado la tarea actual, si finaliza debido a ejecutarse hasta completarse correctamente, con errores debido a una excepción no controlada o se abandone al principio debido a la cancelación.</target>       </trans-unit>
        <trans-unit id="381" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,``0})">
          <source>The following example shows how to use the ContinueWith method:</source>
          <target state="translated">En el ejemplo siguiente se muestra cómo utilizar el método ContinueWith:</target>       </trans-unit>
        <trans-unit id="382" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,``0})">
          <source>The <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> has been disposed.</source>
          <target state="translated">Se ha eliminado <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="383" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,``0})">
          <source>The <ph id="ph1">&lt;paramref name="continuationFunction" /&gt;</ph> argument is null.</source>
          <target state="translated">El argumento <ph id="ph1">&lt;paramref name="continuationFunction" /&gt;</ph> es null.</target>       </trans-unit>
        <trans-unit id="384" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,System.Object,``0},System.Object)">
          <source>The type of the result produced by the continuation.</source>
          <target state="translated">Tipo de resultado generado por la continuación.</target>       </trans-unit>
        <trans-unit id="385" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,System.Object,``0},System.Object)">
          <source>A function to run when the <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> completes.</source>
          <target state="translated">Función que se va a ejecutar cuando se complete el objeto <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="386" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,System.Object,``0},System.Object)">
          <source>When run, the delegate will be passed the completed task and the caller-supplied state object as arguments.</source>
          <target state="translated">Cuando se ejecute, se pasarán al delegado la tarea completada y el objeto de estado proporcionado por el llamador como argumentos.</target>       </trans-unit>
        <trans-unit id="387" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,System.Object,``0},System.Object)">
          <source>An object representing data to be used by the continuation function.</source>
          <target state="translated">Objeto que representa los datos que la función de continuación va a usar.</target>       </trans-unit>
        <trans-unit id="388" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,System.Object,``0},System.Object)">
          <source>Creates a continuation that receives caller-supplied state information and executes asynchronously when the target <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> completes and returns a value.</source>
          <target state="translated">Crea una continuación que recibe información de estado proporcionada por el autor de la llamada y se ejecuta de forma asincrónica cuando el elemento <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> de destino se completa y devuelve un valor.</target>       </trans-unit>
        <trans-unit id="389" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,System.Object,``0},System.Object)">
          <source>A new continuation <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task`1" /&gt;</ph>.</source>
          <target state="translated">Nuevo objeto <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task`1" /&gt;</ph> de continuación.</target>       </trans-unit>
        <trans-unit id="390" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,System.Object,``0},System.Object)">
          <source>The returned <ph id="ph1">&lt;xref:System.Threading.Tasks.Task%601&gt;</ph> will not be scheduled for execution until the current task has  completed, whether it completes due to running to completion successfully, faulting due to an  unhandled exception, or exiting out early due to being canceled.</source>
          <target state="translated">El valor devuelto <ph id="ph1">&lt;xref:System.Threading.Tasks.Task%601&gt;</ph> no se programará para su ejecución hasta que haya completado la tarea actual, si finaliza debido a ejecutarse hasta completarse correctamente, con errores debido a una excepción no controlada o se abandone al principio debido a la cancelación.</target>       </trans-unit>
        <trans-unit id="391" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,System.Object,``0},System.Object)">
          <source>The <ph id="ph1">&lt;paramref name="continuationFunction" /&gt;</ph> argument is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">El argumento <ph id="ph1">&lt;paramref name="continuationFunction" /&gt;</ph> es <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="392" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,``0},System.Threading.CancellationToken)">
          <source>The type of the result produced by the continuation.</source>
          <target state="translated">Tipo de resultado generado por la continuación.</target>       </trans-unit>
        <trans-unit id="393" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,``0},System.Threading.CancellationToken)">
          <source>A function to run when the <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> completes.</source>
          <target state="translated">Función que se va a ejecutar cuando se complete el objeto <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="394" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,``0},System.Threading.CancellationToken)">
          <source>When run, the delegate will be passed the completed task as an argument.</source>
          <target state="translated">Cuando se ejecute, al delegado se le pasará la tarea completada como un argumento.</target>       </trans-unit>
        <trans-unit id="395" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,``0},System.Threading.CancellationToken)">
          <source>The <ph id="ph1">&lt;see cref="P:System.Threading.Tasks.TaskFactory.CancellationToken" /&gt;</ph> that will be assigned to the new continuation task.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="P:System.Threading.Tasks.TaskFactory.CancellationToken" /&gt;</ph> que se asignará a la nueva tarea de continuación.</target>       </trans-unit>
        <trans-unit id="396" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,``0},System.Threading.CancellationToken)">
          <source>Creates a continuation that executes asynchronously when the target <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> completes and returns a value.</source>
          <target state="translated">Crea una continuación que se ejecuta de forma asincrónica cuando el elemento <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> de destino se completa y devuelve un valor.</target>       </trans-unit>
        <trans-unit id="397" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,``0},System.Threading.CancellationToken)">
          <source>The continuation receives a cancellation token.</source>
          <target state="translated">La continuación recibe un token de cancelación.</target>       </trans-unit>
        <trans-unit id="398" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,``0},System.Threading.CancellationToken)">
          <source>A new continuation <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task`1" /&gt;</ph>.</source>
          <target state="translated">Nuevo objeto <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task`1" /&gt;</ph> de continuación.</target>       </trans-unit>
        <trans-unit id="399" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,``0},System.Threading.CancellationToken)">
          <source>The returned <ph id="ph1">&lt;xref:System.Threading.Tasks.Task%601&gt;</ph> will not be scheduled for execution until the current task has completed, whether it completes due to running to completion successfully, faulting due to an unhandled exception, or exiting out early due to being canceled.</source>
          <target state="translated">El valor devuelto <ph id="ph1">&lt;xref:System.Threading.Tasks.Task%601&gt;</ph> no se programará para su ejecución hasta que haya completado la tarea actual, si finaliza debido a ejecutarse hasta completarse correctamente, con errores debido a una excepción no controlada o se abandone al principio debido a la cancelación.</target>       </trans-unit>
        <trans-unit id="400" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,``0},System.Threading.CancellationToken)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> has been disposed.</source>
          <target state="translated">Se ha eliminado <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="401" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,``0},System.Threading.CancellationToken)">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="402" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,``0},System.Threading.CancellationToken)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Threading.CancellationTokenSource" /&gt;</ph> that created the token has already been disposed.</source>
          <target state="translated">El <ph id="ph1">&lt;see cref="T:System.Threading.CancellationTokenSource" /&gt;</ph> que creó el token ya se ha eliminado.</target>       </trans-unit>
        <trans-unit id="403" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,``0},System.Threading.CancellationToken)">
          <source>The <ph id="ph1">&lt;paramref name="continuationFunction" /&gt;</ph> argument is null.</source>
          <target state="translated">El argumento <ph id="ph1">&lt;paramref name="continuationFunction" /&gt;</ph> es null.</target>       </trans-unit>
        <trans-unit id="404" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,``0},System.Threading.Tasks.TaskContinuationOptions)">
          <source>The type of the result produced by the continuation.</source>
          <target state="translated">Tipo de resultado generado por la continuación.</target>       </trans-unit>
        <trans-unit id="405" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,``0},System.Threading.Tasks.TaskContinuationOptions)">
          <source>A function to run according to the condition specified in <bpt id="p1">&lt;c&gt;</bpt>continuationOptions<ept id="p1">&lt;/c&gt;</ept>.</source>
          <target state="translated">Una función que se ejecutará según las condiciones especificadas en <bpt id="p1">&lt;c&gt;</bpt>continuationOptions<ept id="p1">&lt;/c&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="406" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,``0},System.Threading.Tasks.TaskContinuationOptions)">
          <source>When run, the delegate will be passed the completed task as an argument.</source>
          <target state="translated">Cuando se ejecute, al delegado se le pasará la tarea completada como un argumento.</target>       </trans-unit>
        <trans-unit id="407" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,``0},System.Threading.Tasks.TaskContinuationOptions)">
          <source>Options for when the continuation is scheduled and how it behaves.</source>
          <target state="translated">Opciones para la programación y el comportamiento de la continuación.</target>       </trans-unit>
        <trans-unit id="408" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,``0},System.Threading.Tasks.TaskContinuationOptions)">
          <source>This includes criteria, such as <ph id="ph1">&lt;see cref="F:System.Threading.Tasks.TaskContinuationOptions.OnlyOnCanceled" /&gt;</ph>, as well as execution options, such as <ph id="ph2">&lt;see cref="F:System.Threading.Tasks.TaskContinuationOptions.ExecuteSynchronously" /&gt;</ph>.</source>
          <target state="translated">Incluye criterios, como <ph id="ph1">&lt;see cref="F:System.Threading.Tasks.TaskContinuationOptions.OnlyOnCanceled" /&gt;</ph>, y opciones de ejecución, como <ph id="ph2">&lt;see cref="F:System.Threading.Tasks.TaskContinuationOptions.ExecuteSynchronously" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="409" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,``0},System.Threading.Tasks.TaskContinuationOptions)">
          <source>Creates a continuation that executes according to the specified continuation options and returns a value.</source>
          <target state="translated">Crea una continuación que se ejecuta según las opciones de continuación especificadas y devuelve un valor.</target>       </trans-unit>
        <trans-unit id="410" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,``0},System.Threading.Tasks.TaskContinuationOptions)">
          <source>A new continuation <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task`1" /&gt;</ph>.</source>
          <target state="translated">Nuevo objeto <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task`1" /&gt;</ph> de continuación.</target>       </trans-unit>
        <trans-unit id="411" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,``0},System.Threading.Tasks.TaskContinuationOptions)">
          <source>The returned <ph id="ph1">&lt;xref:System.Threading.Tasks.Task%601&gt;</ph> will not be scheduled for execution until the current task has completed.</source>
          <target state="translated">El valor devuelto <ph id="ph1">&lt;xref:System.Threading.Tasks.Task%601&gt;</ph> no se programará para su ejecución hasta que haya completado la tarea actual.</target>       </trans-unit>
        <trans-unit id="412" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,``0},System.Threading.Tasks.TaskContinuationOptions)">
          <source>If the continuation criteria specified through the <ph id="ph1">`continuationOptions`</ph> parameter are not met, the continuation task will be canceled instead of scheduled.</source>
          <target state="translated">Si especifican los criterios de continuación a través de la <ph id="ph1">`continuationOptions`</ph> parámetro no se cumplen, se cancela la tarea de continuación en lugar de programarse.</target>       </trans-unit>
        <trans-unit id="413" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,``0},System.Threading.Tasks.TaskContinuationOptions)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> has been disposed.</source>
          <target state="translated">Se ha eliminado <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="414" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,``0},System.Threading.Tasks.TaskContinuationOptions)">
          <source>The <ph id="ph1">&lt;paramref name="continuationFunction" /&gt;</ph> argument is null.</source>
          <target state="translated">El argumento <ph id="ph1">&lt;paramref name="continuationFunction" /&gt;</ph> es null.</target>       </trans-unit>
        <trans-unit id="415" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,``0},System.Threading.Tasks.TaskContinuationOptions)">
          <source>The <ph id="ph1">&lt;paramref name="continuationOptions" /&gt;</ph> argument specifies an invalid value for <ph id="ph2">&lt;see cref="T:System.Threading.Tasks.TaskContinuationOptions" /&gt;</ph>.</source>
          <target state="translated">El argumento <ph id="ph1">&lt;paramref name="continuationOptions" /&gt;</ph> especifica un valor no válido para <ph id="ph2">&lt;see cref="T:System.Threading.Tasks.TaskContinuationOptions" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="416" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,``0},System.Threading.Tasks.TaskScheduler)">
          <source>The type of the result produced by the continuation.</source>
          <target state="translated">Tipo de resultado generado por la continuación.</target>       </trans-unit>
        <trans-unit id="417" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,``0},System.Threading.Tasks.TaskScheduler)">
          <source>A function to run when the <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> completes.</source>
          <target state="translated">Función que se va a ejecutar cuando se complete el objeto <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="418" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,``0},System.Threading.Tasks.TaskScheduler)">
          <source>When run, the delegate will be passed the completed task as an argument.</source>
          <target state="translated">Cuando se ejecute, al delegado se le pasará la tarea completada como un argumento.</target>       </trans-unit>
        <trans-unit id="419" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,``0},System.Threading.Tasks.TaskScheduler)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.TaskScheduler" /&gt;</ph> to associate with the continuation task and to use for its execution.</source>
          <target state="translated">Objeto <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.TaskScheduler" /&gt;</ph> que se va a asociar a la tarea de continuación y se va a usar para su ejecución.</target>       </trans-unit>
        <trans-unit id="420" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,``0},System.Threading.Tasks.TaskScheduler)">
          <source>Creates a continuation that executes asynchronously when the target <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> completes and returns a value.</source>
          <target state="translated">Crea una continuación que se ejecuta de forma asincrónica cuando el elemento <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> de destino se completa y devuelve un valor.</target>       </trans-unit>
        <trans-unit id="421" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,``0},System.Threading.Tasks.TaskScheduler)">
          <source>The continuation uses a specified scheduler.</source>
          <target state="translated">La continuación usa un programador especificado.</target>       </trans-unit>
        <trans-unit id="422" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,``0},System.Threading.Tasks.TaskScheduler)">
          <source>A new continuation <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task`1" /&gt;</ph>.</source>
          <target state="translated">Nuevo objeto <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task`1" /&gt;</ph> de continuación.</target>       </trans-unit>
        <trans-unit id="423" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,``0},System.Threading.Tasks.TaskScheduler)">
          <source>The returned <ph id="ph1">&lt;xref:System.Threading.Tasks.Task%601&gt;</ph> will not be scheduled for execution until the current task has completed, whether it completes due to running to completion successfully, faulting due to an unhandled exception, or exiting out early due to being canceled.</source>
          <target state="translated">El valor devuelto <ph id="ph1">&lt;xref:System.Threading.Tasks.Task%601&gt;</ph> no se programará para su ejecución hasta que haya completado la tarea actual, si finaliza debido a ejecutarse hasta completarse correctamente, con errores debido a una excepción no controlada o se abandone al principio debido a la cancelación.</target>       </trans-unit>
        <trans-unit id="424" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,``0},System.Threading.Tasks.TaskScheduler)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> has been disposed.</source>
          <target state="translated">Se ha eliminado <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="425" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,``0},System.Threading.Tasks.TaskScheduler)">
          <source>The <ph id="ph1">&lt;paramref name="continuationFunction" /&gt;</ph> argument is null.</source>
          <target state="translated">El argumento <ph id="ph1">&lt;paramref name="continuationFunction" /&gt;</ph> es null.</target>       </trans-unit>
        <trans-unit id="426" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,``0},System.Threading.Tasks.TaskScheduler)">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="427" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,``0},System.Threading.Tasks.TaskScheduler)">
          <source>The <ph id="ph1">&lt;paramref name="scheduler" /&gt;</ph> argument is null.</source>
          <target state="translated">El argumento <ph id="ph1">&lt;paramref name="scheduler" /&gt;</ph> es null.</target>       </trans-unit>
        <trans-unit id="428" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,System.Object,``0},System.Object,System.Threading.CancellationToken)">
          <source>The type of the result produced by the continuation.</source>
          <target state="translated">Tipo de resultado generado por la continuación.</target>       </trans-unit>
        <trans-unit id="429" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,System.Object,``0},System.Object,System.Threading.CancellationToken)">
          <source>A function to run when the <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> completes.</source>
          <target state="translated">Función que se va a ejecutar cuando se complete el objeto <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="430" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,System.Object,``0},System.Object,System.Threading.CancellationToken)">
          <source>When run, the delegate will be  passed the completed task and the caller-supplied state object as arguments.</source>
          <target state="translated">Cuando se ejecute, se pasarán al delegado la tarea completada y el objeto de estado proporcionado por el llamador como argumentos.</target>       </trans-unit>
        <trans-unit id="431" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,System.Object,``0},System.Object,System.Threading.CancellationToken)">
          <source>An object representing data to be used by the continuation function.</source>
          <target state="translated">Objeto que representa los datos que la función de continuación va a usar.</target>       </trans-unit>
        <trans-unit id="432" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,System.Object,``0},System.Object,System.Threading.CancellationToken)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Threading.CancellationToken" /&gt;</ph> that will be assigned to the new continuation task.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Threading.CancellationToken" /&gt;</ph> que se asignará a la nueva tarea de continuación.</target>       </trans-unit>
        <trans-unit id="433" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,System.Object,``0},System.Object,System.Threading.CancellationToken)">
          <source>Creates a continuation that executes asynchronously when the target <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> completes and returns a value.</source>
          <target state="translated">Crea una continuación que se ejecuta de forma asincrónica cuando el elemento <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> de destino se completa y devuelve un valor.</target>       </trans-unit>
        <trans-unit id="434" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,System.Object,``0},System.Object,System.Threading.CancellationToken)">
          <source>The continuation receives caller-supplied state information and a cancellation token.</source>
          <target state="translated">La continuación recibe información de estado proporcionada por el autor de la llamada y un token de cancelación.</target>       </trans-unit>
        <trans-unit id="435" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,System.Object,``0},System.Object,System.Threading.CancellationToken)">
          <source>A new continuation <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task`1" /&gt;</ph>.</source>
          <target state="translated">Nuevo objeto <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task`1" /&gt;</ph> de continuación.</target>       </trans-unit>
        <trans-unit id="436" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,System.Object,``0},System.Object,System.Threading.CancellationToken)">
          <source>The returned <ph id="ph1">&lt;xref:System.Threading.Tasks.Task%601&gt;</ph> will not be scheduled for execution until the current task has  completed, whether it completes due to running to completion successfully, faulting due to an  unhandled exception, or exiting out early due to being canceled.</source>
          <target state="translated">El valor devuelto <ph id="ph1">&lt;xref:System.Threading.Tasks.Task%601&gt;</ph> no se programará para su ejecución hasta que haya completado la tarea actual, si finaliza debido a ejecutarse hasta completarse correctamente, con errores debido a una excepción no controlada o se abandone al principio debido a la cancelación.</target>       </trans-unit>
        <trans-unit id="437" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,System.Object,``0},System.Object,System.Threading.CancellationToken)">
          <source>The <ph id="ph1">&lt;paramref name="continuationFunction" /&gt;</ph> argument is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">El argumento <ph id="ph1">&lt;paramref name="continuationFunction" /&gt;</ph> es <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="438" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,System.Object,``0},System.Object,System.Threading.CancellationToken)">
          <source>The provided <ph id="ph1">&lt;see cref="T:System.Threading.CancellationToken" /&gt;</ph> has already been disposed.</source>
          <target state="translated">El <ph id="ph1">&lt;see cref="T:System.Threading.CancellationToken" /&gt;</ph> proporcionado ya se ha eliminado.</target>       </trans-unit>
        <trans-unit id="439" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,System.Object,``0},System.Object,System.Threading.Tasks.TaskContinuationOptions)">
          <source>The type of the result produced by the continuation.</source>
          <target state="translated">Tipo de resultado generado por la continuación.</target>       </trans-unit>
        <trans-unit id="440" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,System.Object,``0},System.Object,System.Threading.Tasks.TaskContinuationOptions)">
          <source>A function to run when the <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> completes.</source>
          <target state="translated">Función que se va a ejecutar cuando se complete el objeto <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="441" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,System.Object,``0},System.Object,System.Threading.Tasks.TaskContinuationOptions)">
          <source>When run, the delegate will be  passed the completed task and the caller-supplied state object as arguments.</source>
          <target state="translated">Cuando se ejecute, se pasarán al delegado la tarea completada y el objeto de estado proporcionado por el llamador como argumentos.</target>       </trans-unit>
        <trans-unit id="442" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,System.Object,``0},System.Object,System.Threading.Tasks.TaskContinuationOptions)">
          <source>An object representing data to be used by the continuation function.</source>
          <target state="translated">Objeto que representa los datos que la función de continuación va a usar.</target>       </trans-unit>
        <trans-unit id="443" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,System.Object,``0},System.Object,System.Threading.Tasks.TaskContinuationOptions)">
          <source>Options for when the continuation is scheduled and how it behaves.</source>
          <target state="translated">Opciones para la programación y el comportamiento de la continuación.</target>       </trans-unit>
        <trans-unit id="444" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,System.Object,``0},System.Object,System.Threading.Tasks.TaskContinuationOptions)">
          <source>This includes criteria, such as <ph id="ph1">&lt;see cref="F:System.Threading.Tasks.TaskContinuationOptions.OnlyOnCanceled" /&gt;</ph>, as well as execution options, such as <ph id="ph2">&lt;see cref="F:System.Threading.Tasks.TaskContinuationOptions.ExecuteSynchronously" /&gt;</ph>.</source>
          <target state="translated">Incluye criterios, como <ph id="ph1">&lt;see cref="F:System.Threading.Tasks.TaskContinuationOptions.OnlyOnCanceled" /&gt;</ph>, y opciones de ejecución, como <ph id="ph2">&lt;see cref="F:System.Threading.Tasks.TaskContinuationOptions.ExecuteSynchronously" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="445" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,System.Object,``0},System.Object,System.Threading.Tasks.TaskContinuationOptions)">
          <source>Creates a continuation that executes based on the specified task continuation options when the target <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> completes.</source>
          <target state="translated">Crea una continuación que se ejecuta según las opciones de continuación de la tarea especificadas cuando el elemento <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> de destino se completa.</target>       </trans-unit>
        <trans-unit id="446" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,System.Object,``0},System.Object,System.Threading.Tasks.TaskContinuationOptions)">
          <source>The continuation receives caller-supplied state information.</source>
          <target state="translated">La continuación recibe información de estado proporcionada por el autor de la llamada.</target>       </trans-unit>
        <trans-unit id="447" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,System.Object,``0},System.Object,System.Threading.Tasks.TaskContinuationOptions)">
          <source>A new continuation <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task`1" /&gt;</ph>.</source>
          <target state="translated">Nuevo objeto <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task`1" /&gt;</ph> de continuación.</target>       </trans-unit>
        <trans-unit id="448" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,System.Object,``0},System.Object,System.Threading.Tasks.TaskContinuationOptions)">
          <source>The returned <ph id="ph1">&lt;xref:System.Threading.Tasks.Task%601&gt;</ph> will not be scheduled for execution until the current task has completed.</source>
          <target state="translated">El valor devuelto <ph id="ph1">&lt;xref:System.Threading.Tasks.Task%601&gt;</ph> no se programará para su ejecución hasta que haya completado la tarea actual.</target>       </trans-unit>
        <trans-unit id="449" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,System.Object,``0},System.Object,System.Threading.Tasks.TaskContinuationOptions)">
          <source>If the continuation criteria specified through the <ph id="ph1">`continuationOptions`</ph> parameter are not met, the continuation task will be canceled instead of scheduled.</source>
          <target state="translated">Si especifican los criterios de continuación a través de la <ph id="ph1">`continuationOptions`</ph> parámetro no se cumplen, se cancela la tarea de continuación en lugar de programarse.</target>       </trans-unit>
        <trans-unit id="450" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,System.Object,``0},System.Object,System.Threading.Tasks.TaskContinuationOptions)">
          <source>The <ph id="ph1">&lt;paramref name="continuationFunction" /&gt;</ph> argument is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">El argumento <ph id="ph1">&lt;paramref name="continuationFunction" /&gt;</ph> es <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="451" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,System.Object,``0},System.Object,System.Threading.Tasks.TaskContinuationOptions)">
          <source>The <ph id="ph1">&lt;paramref name="continuationOptions" /&gt;</ph> argument specifies an invalid value for <ph id="ph2">&lt;see cref="T:System.Threading.Tasks.TaskContinuationOptions" /&gt;</ph>.</source>
          <target state="translated">El argumento <ph id="ph1">&lt;paramref name="continuationOptions" /&gt;</ph> especifica un valor no válido para <ph id="ph2">&lt;see cref="T:System.Threading.Tasks.TaskContinuationOptions" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="452" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,System.Object,``0},System.Object,System.Threading.Tasks.TaskScheduler)">
          <source>The type of the result produced by the continuation.</source>
          <target state="translated">Tipo de resultado generado por la continuación.</target>       </trans-unit>
        <trans-unit id="453" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,System.Object,``0},System.Object,System.Threading.Tasks.TaskScheduler)">
          <source>A function to run when the <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> completes.</source>
          <target state="translated">Función que se va a ejecutar cuando se complete el objeto <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="454" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,System.Object,``0},System.Object,System.Threading.Tasks.TaskScheduler)">
          <source>When run, the delegate will be  passed the completed task and the caller-supplied state object as arguments.</source>
          <target state="translated">Cuando se ejecute, se pasarán al delegado la tarea completada y el objeto de estado proporcionado por el llamador como argumentos.</target>       </trans-unit>
        <trans-unit id="455" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,System.Object,``0},System.Object,System.Threading.Tasks.TaskScheduler)">
          <source>An object representing data to be used by the continuation function.</source>
          <target state="translated">Objeto que representa los datos que la función de continuación va a usar.</target>       </trans-unit>
        <trans-unit id="456" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,System.Object,``0},System.Object,System.Threading.Tasks.TaskScheduler)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.TaskScheduler" /&gt;</ph> to associate with the continuation task and to use for its execution.</source>
          <target state="translated">Objeto <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.TaskScheduler" /&gt;</ph> que se va a asociar a la tarea de continuación y se va a usar para su ejecución.</target>       </trans-unit>
        <trans-unit id="457" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,System.Object,``0},System.Object,System.Threading.Tasks.TaskScheduler)">
          <source>Creates a continuation that executes asynchronously when the target <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> completes.</source>
          <target state="translated">Crea una continuación que se ejecuta de manera asincrónica cuando se completa el objeto <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> de destino.</target>       </trans-unit>
        <trans-unit id="458" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,System.Object,``0},System.Object,System.Threading.Tasks.TaskScheduler)">
          <source>The continuation receives caller-supplied state information and uses a specified scheduler.</source>
          <target state="translated">La continuación recibe información de estado proporcionada por el autor de la llamada y usa a un programador especificado.</target>       </trans-unit>
        <trans-unit id="459" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,System.Object,``0},System.Object,System.Threading.Tasks.TaskScheduler)">
          <source>A new continuation <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task`1" /&gt;</ph>.</source>
          <target state="translated">Nuevo objeto <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task`1" /&gt;</ph> de continuación.</target>       </trans-unit>
        <trans-unit id="460" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,System.Object,``0},System.Object,System.Threading.Tasks.TaskScheduler)">
          <source>The returned <ph id="ph1">&lt;xref:System.Threading.Tasks.Task%601&gt;</ph> will not be scheduled for execution until the current task has  completed, whether it completes due to running to completion successfully, faulting due to an  unhandled exception, or exiting out early due to being canceled.</source>
          <target state="translated">El valor devuelto <ph id="ph1">&lt;xref:System.Threading.Tasks.Task%601&gt;</ph> no se programará para su ejecución hasta que haya completado la tarea actual, si finaliza debido a ejecutarse hasta completarse correctamente, con errores debido a una excepción no controlada o se abandone al principio debido a la cancelación.</target>       </trans-unit>
        <trans-unit id="461" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,System.Object,``0},System.Object,System.Threading.Tasks.TaskScheduler)">
          <source>The <ph id="ph1">&lt;paramref name="scheduler" /&gt;</ph> argument is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">El argumento <ph id="ph1">&lt;paramref name="scheduler" /&gt;</ph> es <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="462" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,``0},System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)">
          <source>The type of the result produced by the continuation.</source>
          <target state="translated">Tipo de resultado generado por la continuación.</target>       </trans-unit>
        <trans-unit id="463" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,``0},System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)">
          <source>A function to run according to the specified <bpt id="p1">&lt;c&gt;</bpt>continuationOptions.<ept id="p1">&lt;/c&gt;</ept></source>
          <target state="translated">Una función que se ejecutará según el parámetro <bpt id="p1">&lt;c&gt;</bpt>continuationOptions<ept id="p1">&lt;/c&gt;</ept> especificado.</target>       </trans-unit>
        <trans-unit id="464" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,``0},System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)">
          <source>When run, the delegate will be passed the completed task as an argument.</source>
          <target state="translated">Cuando se ejecute, al delegado se le pasará la tarea completada como un argumento.</target>       </trans-unit>
        <trans-unit id="465" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,``0},System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)">
          <source>The <ph id="ph1">&lt;see cref="P:System.Threading.Tasks.TaskFactory.CancellationToken" /&gt;</ph> that will be assigned to the new continuation task.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="P:System.Threading.Tasks.TaskFactory.CancellationToken" /&gt;</ph> que se asignará a la nueva tarea de continuación.</target>       </trans-unit>
        <trans-unit id="466" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,``0},System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)">
          <source>Options for when the continuation is scheduled and how it behaves.</source>
          <target state="translated">Opciones para la programación y el comportamiento de la continuación.</target>       </trans-unit>
        <trans-unit id="467" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,``0},System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)">
          <source>This includes criteria, such as <ph id="ph1">&lt;see cref="F:System.Threading.Tasks.TaskContinuationOptions.OnlyOnCanceled" /&gt;</ph>, as well as execution options, such as <ph id="ph2">&lt;see cref="F:System.Threading.Tasks.TaskContinuationOptions.ExecuteSynchronously" /&gt;</ph>.</source>
          <target state="translated">Incluye criterios, como <ph id="ph1">&lt;see cref="F:System.Threading.Tasks.TaskContinuationOptions.OnlyOnCanceled" /&gt;</ph>, y opciones de ejecución, como <ph id="ph2">&lt;see cref="F:System.Threading.Tasks.TaskContinuationOptions.ExecuteSynchronously" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="468" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,``0},System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.TaskScheduler" /&gt;</ph> to associate with the continuation task and to use for its execution.</source>
          <target state="translated">Objeto <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.TaskScheduler" /&gt;</ph> que se va a asociar a la tarea de continuación y se va a usar para su ejecución.</target>       </trans-unit>
        <trans-unit id="469" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,``0},System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)">
          <source>Creates a continuation that executes according to the specified continuation options and returns a value.</source>
          <target state="translated">Crea una continuación que se ejecuta según las opciones de continuación especificadas y devuelve un valor.</target>       </trans-unit>
        <trans-unit id="470" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,``0},System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)">
          <source>The continuation is passed a cancellation token and uses a specified scheduler.</source>
          <target state="translated">Se pasa un token de cancelación a la continuación y usa un programador especificado.</target>       </trans-unit>
        <trans-unit id="471" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,``0},System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)">
          <source>A new continuation <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task`1" /&gt;</ph>.</source>
          <target state="translated">Nuevo objeto <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task`1" /&gt;</ph> de continuación.</target>       </trans-unit>
        <trans-unit id="472" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,``0},System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)">
          <source>The returned <ph id="ph1">&lt;xref:System.Threading.Tasks.Task%601&gt;</ph> will not be scheduled for execution until the current task has completed.</source>
          <target state="translated">El valor devuelto <ph id="ph1">&lt;xref:System.Threading.Tasks.Task%601&gt;</ph> no se programará para su ejecución hasta que haya completado la tarea actual.</target>       </trans-unit>
        <trans-unit id="473" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,``0},System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)">
          <source>If the criteria specified through the <ph id="ph1">`continuationOptions`</ph> parameter are not met, the continuation task will be canceled instead of scheduled.</source>
          <target state="translated">Si los criterios especifican a través de la <ph id="ph1">`continuationOptions`</ph> parámetro no se cumplen, se cancela la tarea de continuación en lugar de programarse.</target>       </trans-unit>
        <trans-unit id="474" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,``0},System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)">
          <source>The following example shows how to use the ContinueWith method with continuation options:</source>
          <target state="translated">En el ejemplo siguiente se muestra cómo utilizar el método ContinueWith con opciones de continuación:</target>       </trans-unit>
        <trans-unit id="475" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,``0},System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> has been disposed.</source>
          <target state="translated">Se ha eliminado <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="476" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,``0},System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="477" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,``0},System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Threading.CancellationTokenSource" /&gt;</ph> that created the token has already been disposed.</source>
          <target state="translated">El <ph id="ph1">&lt;see cref="T:System.Threading.CancellationTokenSource" /&gt;</ph> que creó el token ya se ha eliminado.</target>       </trans-unit>
        <trans-unit id="478" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,``0},System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)">
          <source>The <ph id="ph1">&lt;paramref name="continuationFunction" /&gt;</ph> argument is null.</source>
          <target state="translated">El argumento <ph id="ph1">&lt;paramref name="continuationFunction" /&gt;</ph> es null.</target>       </trans-unit>
        <trans-unit id="479" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,``0},System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="480" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,``0},System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)">
          <source>The <ph id="ph1">&lt;paramref name="scheduler" /&gt;</ph> argument is null.</source>
          <target state="translated">El argumento <ph id="ph1">&lt;paramref name="scheduler" /&gt;</ph> es null.</target>       </trans-unit>
        <trans-unit id="481" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,``0},System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)">
          <source>The <ph id="ph1">&lt;paramref name="continuationOptions" /&gt;</ph> argument specifies an invalid value for <ph id="ph2">&lt;see cref="T:System.Threading.Tasks.TaskContinuationOptions" /&gt;</ph>.</source>
          <target state="translated">El argumento <ph id="ph1">&lt;paramref name="continuationOptions" /&gt;</ph> especifica un valor no válido para <ph id="ph2">&lt;see cref="T:System.Threading.Tasks.TaskContinuationOptions" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="482" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,System.Object,``0},System.Object,System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)">
          <source>The type of the result produced by the continuation.</source>
          <target state="translated">Tipo de resultado generado por la continuación.</target>       </trans-unit>
        <trans-unit id="483" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,System.Object,``0},System.Object,System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)">
          <source>A function to run when the <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> completes.</source>
          <target state="translated">Función que se va a ejecutar cuando se complete el objeto <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="484" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,System.Object,``0},System.Object,System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)">
          <source>When run, the delegate will be  passed the completed task and the caller-supplied state object as arguments.</source>
          <target state="translated">Cuando se ejecute, se pasarán al delegado la tarea completada y el objeto de estado proporcionado por el llamador como argumentos.</target>       </trans-unit>
        <trans-unit id="485" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,System.Object,``0},System.Object,System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)">
          <source>An object representing data to be used by the continuation function.</source>
          <target state="translated">Objeto que representa los datos que la función de continuación va a usar.</target>       </trans-unit>
        <trans-unit id="486" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,System.Object,``0},System.Object,System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Threading.CancellationToken" /&gt;</ph> that will be assigned to the new continuation task.</source>
          <target state="translated">El <ph id="ph1">&lt;see cref="T:System.Threading.CancellationToken" /&gt;</ph> que se asignará a la nueva tarea de continuación.</target>       </trans-unit>
        <trans-unit id="487" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,System.Object,``0},System.Object,System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)">
          <source>Options for when the continuation is scheduled and how it behaves.</source>
          <target state="translated">Opciones para la programación y el comportamiento de la continuación.</target>       </trans-unit>
        <trans-unit id="488" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,System.Object,``0},System.Object,System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)">
          <source>This includes criteria, such as <ph id="ph1">&lt;see cref="F:System.Threading.Tasks.TaskContinuationOptions.OnlyOnCanceled" /&gt;</ph>, as well as execution options, such as <ph id="ph2">&lt;see cref="F:System.Threading.Tasks.TaskContinuationOptions.ExecuteSynchronously" /&gt;</ph>.</source>
          <target state="translated">Incluye criterios, como <ph id="ph1">&lt;see cref="F:System.Threading.Tasks.TaskContinuationOptions.OnlyOnCanceled" /&gt;</ph>, y opciones de ejecución, como <ph id="ph2">&lt;see cref="F:System.Threading.Tasks.TaskContinuationOptions.ExecuteSynchronously" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="489" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,System.Object,``0},System.Object,System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.TaskScheduler" /&gt;</ph> to associate with the continuation task and to use for its  execution.</source>
          <target state="translated">Objeto <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.TaskScheduler" /&gt;</ph> que se va a asociar a la tarea de continuación y se va a usar para su ejecución.</target>       </trans-unit>
        <trans-unit id="490" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,System.Object,``0},System.Object,System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)">
          <source>Creates a continuation that executes based on the specified task continuation options when the target <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> completes and returns a value.</source>
          <target state="translated">Crea una continuación que se ejecuta según las opciones de continuación de la tarea especificadas cuando el elemento <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> de destino se completa y devuelve un valor.</target>       </trans-unit>
        <trans-unit id="491" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,System.Object,``0},System.Object,System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)">
          <source>The continuation receives caller-supplied state information and a cancellation token and uses the specified scheduler.</source>
          <target state="translated">La continuación recibe información de estado proporcionada por el autor de la llamada y un token de cancelación y usa el programador especificado.</target>       </trans-unit>
        <trans-unit id="492" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,System.Object,``0},System.Object,System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)">
          <source>A new continuation <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task`1" /&gt;</ph>.</source>
          <target state="translated">Nuevo objeto <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task`1" /&gt;</ph> de continuación.</target>       </trans-unit>
        <trans-unit id="493" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,System.Object,``0},System.Object,System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)">
          <source>The returned <ph id="ph1">&lt;xref:System.Threading.Tasks.Task%601&gt;</ph> will not be scheduled for execution until the current task has  completed.</source>
          <target state="translated">El valor devuelto <ph id="ph1">&lt;xref:System.Threading.Tasks.Task%601&gt;</ph> no se programará para su ejecución hasta que haya completado la tarea actual.</target>       </trans-unit>
        <trans-unit id="494" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,System.Object,``0},System.Object,System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)">
          <source>If the criteria specified through the <ph id="ph1">`continuationOptions`</ph> parameter  are not met, the continuation task will be canceled instead of scheduled.</source>
          <target state="translated">Si los criterios especifican a través de la <ph id="ph1">`continuationOptions`</ph> parámetro no se cumplen, se cancela la tarea de continuación en lugar de programarse.</target>       </trans-unit>
        <trans-unit id="495" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,System.Object,``0},System.Object,System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)">
          <source>The <ph id="ph1">&lt;paramref name="scheduler" /&gt;</ph> argument is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">El argumento <ph id="ph1">&lt;paramref name="scheduler" /&gt;</ph> es <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="496" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,System.Object,``0},System.Object,System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)">
          <source>The <ph id="ph1">&lt;paramref name="continuationOptions" /&gt;</ph> argument specifies an invalid value for <ph id="ph2">&lt;see cref="T:System.Threading.Tasks.TaskContinuationOptions" /&gt;</ph>.</source>
          <target state="translated">El argumento <ph id="ph1">&lt;paramref name="continuationOptions" /&gt;</ph> especifica un valor no válido para <ph id="ph2">&lt;see cref="T:System.Threading.Tasks.TaskContinuationOptions" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="497" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,System.Object,``0},System.Object,System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)">
          <source>The provided <ph id="ph1">&lt;see cref="T:System.Threading.CancellationToken" /&gt;</ph> has already been disposed.</source>
          <target state="translated">El <ph id="ph1">&lt;see cref="T:System.Threading.CancellationToken" /&gt;</ph> proporcionado ya se ha eliminado.</target>       </trans-unit>
        <trans-unit id="498" translate="yes" xml:space="preserve" uid="P:System.Threading.Tasks.Task.CreationOptions">
          <source>Gets the <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.TaskCreationOptions" /&gt;</ph> used to create this task.</source>
          <target state="translated">Obtiene el objeto <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.TaskCreationOptions" /&gt;</ph> usado para crear esta tarea.</target>       </trans-unit>
        <trans-unit id="499" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Tasks.Task.CreationOptions">
          <source>The <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.TaskCreationOptions" /&gt;</ph> used to create this task.</source>
          <target state="translated">Objeto <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.TaskCreationOptions" /&gt;</ph> usado para crear esta tarea.</target>       </trans-unit>
        <trans-unit id="500" translate="yes" xml:space="preserve" uid="P:System.Threading.Tasks.Task.CurrentId">
          <source>Returns the ID of the currently executing <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph>.</source>
          <target state="translated">Devuelve el identificador del objeto <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> que se está ejecutando actualmente.</target>       </trans-unit>
        <trans-unit id="501" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Tasks.Task.CurrentId">
          <source>An integer that was assigned by the system to the currently-executing task.</source>
          <target state="translated">Entero que el sistema asignó a la tarea en ejecución.</target>       </trans-unit>
        <trans-unit id="502" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Tasks.Task.CurrentId">
          <source><ph id="ph1">&lt;xref:System.Threading.Tasks.Task.CurrentId%2A&gt;</ph> is a <ph id="ph2">`static`</ph> (<ph id="ph3">`Shared`</ph> in Visual Basic) property that is used to get the identifier of the currently executing task from the code that the task is executing.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Threading.Tasks.Task.CurrentId%2A&gt;</ph> es un <ph id="ph2">`static`</ph> (<ph id="ph3">`Shared`</ph> en Visual Basic) propiedad que se usa para obtener el identificador de la tarea que se está ejecutando actualmente desde el código que se está ejecutando la tarea.</target>       </trans-unit>
        <trans-unit id="503" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Tasks.Task.CurrentId">
          <source>It differs from the <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Id%2A&gt;</ph> property, which returns the identifier of a particular <ph id="ph2">&lt;xref:System.Threading.Tasks.Task&gt;</ph> instance.</source>
          <target state="translated">Difiere de la <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Id%2A&gt;</ph> propiedad, que devuelve el identificador de una determinada <ph id="ph2">&lt;xref:System.Threading.Tasks.Task&gt;</ph> instancia.</target>       </trans-unit>
        <trans-unit id="504" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Tasks.Task.CurrentId">
          <source>If you attempt to retrieve the <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.CurrentId%2A&gt;</ph> value from outside the code that a task is executing, the property returns <ph id="ph2">`null`</ph>.</source>
          <target state="translated">Si se intenta recuperar el <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.CurrentId%2A&gt;</ph> valor desde fuera del código que se está ejecutando una tarea, la propiedad devuelve <ph id="ph2">`null`</ph>.</target>       </trans-unit>
        <trans-unit id="505" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Tasks.Task.CurrentId">
          <source>Note that although collisions are very rare, task identifiers are not guaranteed to be unique.</source>
          <target state="translated">Tenga en cuenta que aunque las colisiones son muy raras, identificadores de tarea no se garantiza que sea único.</target>       </trans-unit>
        <trans-unit id="506" translate="yes" xml:space="preserve" uid="T:System.Threading.Tasks.Task">
          <source>Creates a task that will complete after a time delay.</source>
          <target state="translated">Crea una tarea que se completará después de un retraso.</target>       </trans-unit>
        <trans-unit id="507" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Delay(System.Int32)">
          <source>The number of milliseconds to wait before completing the returned task, or -1 to wait indefinitely.</source>
          <target state="translated">El número de milisegundos que se esperará antes de completar la tarea devuelta o -1 para esperar indefinidamente.</target>       </trans-unit>
        <trans-unit id="508" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Delay(System.Int32)">
          <source>Creates a task that completes after a time delay.</source>
          <target state="translated">Crea una tarea que se completa después de un retraso.</target>       </trans-unit>
        <trans-unit id="509" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Delay(System.Int32)">
          <source>A task that represents the time delay.</source>
          <target state="translated">Una tarea que representa el retraso.</target>       </trans-unit>
        <trans-unit id="510" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Delay(System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Delay%2A&gt;</ph> method is typically used to delay the operation of all or part of a task for a specified time interval.</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Delay%2A&gt;</ph> método se utiliza normalmente para retrasar la operación de todo o parte de una tarea durante un intervalo de tiempo especificado.</target>       </trans-unit>
        <trans-unit id="511" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Delay(System.Int32)">
          <source>Most commonly, the time delay is introduced:</source>
          <target state="translated">Normalmente, el tiempo de retardo se incluye:</target>       </trans-unit>
        <trans-unit id="512" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Delay(System.Int32)">
          <source>At the beginning of the task, as the following example shows.</source>
          <target state="translated">Al principio de la tarea, como en el ejemplo siguiente se muestra.</target>       </trans-unit>
        <trans-unit id="513" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Delay(System.Int32)">
          <source>Sometime while the task is executing.</source>
          <target state="translated">En algún momento mientras se está ejecutando la tarea.</target>       </trans-unit>
        <trans-unit id="514" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Delay(System.Int32)">
          <source>In this case, the call to the <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Delay%2A&gt;</ph> method executes as a child task within a task, as the following example shows.</source>
          <target state="translated">En este caso, la llamada a la <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Delay%2A&gt;</ph> método se ejecuta como una tarea secundaria dentro de una tarea, como se muestra en el ejemplo siguiente.</target>       </trans-unit>
        <trans-unit id="515" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Delay(System.Int32)">
          <source>Note that since the task that calls the <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Delay%2A&gt;</ph> method executes asynchronously, the parent task must wait for it to complete by using the <ph id="ph2">`await`</ph> keyword.</source>
          <target state="translated">Tenga en cuenta que desde la tarea que llama el <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Delay%2A&gt;</ph> método se ejecuta de forma asincrónica, la tarea primaria debe esperar a que finalice mediante el uso de la <ph id="ph2">`await`</ph> (palabra clave).</target>       </trans-unit>
        <trans-unit id="516" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Delay(System.Int32)">
          <source>After the specified time delay, the task is completed in the <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskStatus.RanToCompletion&gt;</ph> state.</source>
          <target state="translated">Después del retraso de tiempo especificado, se completa la tarea en el <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskStatus.RanToCompletion&gt;</ph> estado.</target>       </trans-unit>
        <trans-unit id="517" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Delay(System.Int32)">
          <source>This method depends on the system clock.</source>
          <target state="translated">Este método depende del reloj del sistema.</target>       </trans-unit>
        <trans-unit id="518" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Delay(System.Int32)">
          <source>This means that the time delay will approximately equal the resolution of the system clock if the <ph id="ph1">`millisecondsDelay`</ph> argument is less than the resolution of the system clock, which is approximately 15 milliseconds on Windows systems.</source>
          <target state="translated">Esto significa que el tiempo de retardo aproximadamente será igual a la resolución del reloj del sistema si el <ph id="ph1">`millisecondsDelay`</ph> argumento es menor que la resolución del reloj del sistema, que es aproximadamente 15 milisegundos en los sistemas Windows.</target>       </trans-unit>
        <trans-unit id="519" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Delay(System.Int32)">
          <source>The following example shows a simple use of the <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Delay%2A&gt;</ph> method.</source>
          <target state="translated">En el ejemplo siguiente se muestra un uso simple de la <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Delay%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="520" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Delay(System.Int32)">
          <source>The <ph id="ph1">&lt;paramref name="millisecondsDelay" /&gt;</ph> argument is less than -1.</source>
          <target state="translated">El argumento <ph id="ph1">&lt;paramref name="millisecondsDelay" /&gt;</ph> es menor que -1.</target>       </trans-unit>
        <trans-unit id="521" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Delay(System.TimeSpan)">
          <source>The time span to wait before completing the returned task, or <ph id="ph1">&lt;see langword="TimeSpan.FromMilliseconds(-1)" /&gt;</ph> to wait indefinitely.</source>
          <target state="translated">El intervalo de tiempo que espera antes de completar la tarea devuelta o <ph id="ph1">&lt;see langword="TimeSpan.FromMilliseconds(-1)" /&gt;</ph> para esperar indefinidamente.</target>       </trans-unit>
        <trans-unit id="522" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Delay(System.TimeSpan)">
          <source>Creates a task that completes after a specified time interval.</source>
          <target state="translated">Crea una tarea que se completa después de un intervalo de tiempo especificado.</target>       </trans-unit>
        <trans-unit id="523" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Delay(System.TimeSpan)">
          <source>A task that represents the time delay.</source>
          <target state="translated">Una tarea que representa el retraso.</target>       </trans-unit>
        <trans-unit id="524" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Delay(System.TimeSpan)">
          <source>After the specified time delay, the task is completed in <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskStatus.RanToCompletion&gt;</ph> state.</source>
          <target state="translated">Después del retraso de tiempo especificado, se completa la tarea en <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskStatus.RanToCompletion&gt;</ph> estado.</target>       </trans-unit>
        <trans-unit id="525" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Delay(System.TimeSpan)">
          <source>For usage scenarios and additional examples, see the documentation for the <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Delay%28System.Int32%29&gt;</ph> overload.</source>
          <target state="translated">Para escenarios de uso y ejemplos adicionales, consulte la documentación de la <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Delay%28System.Int32%29&gt;</ph> de sobrecarga.</target>       </trans-unit>
        <trans-unit id="526" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Delay(System.TimeSpan)">
          <source>This method depends on the system clock.</source>
          <target state="translated">Este método depende del reloj del sistema.</target>       </trans-unit>
        <trans-unit id="527" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Delay(System.TimeSpan)">
          <source>This means that the time delay will approximately equal the resolution of the system clock if the <ph id="ph1">`delay`</ph> argument is less than the resolution of the system clock, which is approximately 15 milliseconds on Windows systems.</source>
          <target state="translated">Esto significa que el tiempo de retardo aproximadamente será igual a la resolución del reloj del sistema si el <ph id="ph1">`delay`</ph> argumento es menor que la resolución del reloj del sistema, que es aproximadamente 15 milisegundos en los sistemas Windows.</target>       </trans-unit>
        <trans-unit id="528" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Delay(System.TimeSpan)">
          <source>The following example shows a simple use of the <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Delay%2A&gt;</ph> method.</source>
          <target state="translated">En el ejemplo siguiente se muestra un uso simple de la <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Delay%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="529" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Delay(System.TimeSpan)">
          <source><ph id="ph1">&lt;paramref name="delay" /&gt;</ph> represents a negative time interval other than <ph id="ph2">&lt;see langword="TimeSpan.FromMillseconds(-1)" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="delay" /&gt;</ph> representa un intervalo de tiempo negativo distinto de <ph id="ph2">&lt;see langword="TimeSpan.FromMillseconds(-1)" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="530" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Delay(System.TimeSpan)">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="531" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Delay(System.TimeSpan)">
          <source>The <ph id="ph1">&lt;paramref name="delay" /&gt;</ph> argument's <ph id="ph2">&lt;see cref="P:System.TimeSpan.TotalMilliseconds" /&gt;</ph> property is greater than <ph id="ph3">&lt;see cref="F:System.Int32.MaxValue" /&gt;</ph>.</source>
          <target state="translated">La propiedad <ph id="ph2">&lt;see cref="P:System.TimeSpan.TotalMilliseconds" /&gt;</ph> del argumento <ph id="ph1">&lt;paramref name="delay" /&gt;</ph> es mayor que <ph id="ph3">&lt;see cref="F:System.Int32.MaxValue" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="532" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Delay(System.Int32,System.Threading.CancellationToken)">
          <source>The number of milliseconds to wait before completing the returned task, or -1 to wait indefinitely.</source>
          <target state="translated">El número de milisegundos que se esperará antes de completar la tarea devuelta o -1 para esperar indefinidamente.</target>       </trans-unit>
        <trans-unit id="533" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Delay(System.Int32,System.Threading.CancellationToken)">
          <source>The cancellation token that will be checked prior to completing the returned task.</source>
          <target state="translated">El token de cancelación que se comprobará antes de completar la tarea devuelta.</target>       </trans-unit>
        <trans-unit id="534" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Delay(System.Int32,System.Threading.CancellationToken)">
          <source>Creates a cancellable task that completes after a time delay.</source>
          <target state="translated">Crea una tarea cancelable que se completa después de un retraso.</target>       </trans-unit>
        <trans-unit id="535" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Delay(System.Int32,System.Threading.CancellationToken)">
          <source>A task that represents the time delay.</source>
          <target state="translated">Una tarea que representa el retraso.</target>       </trans-unit>
        <trans-unit id="536" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Delay(System.Int32,System.Threading.CancellationToken)">
          <source>If the cancellation token is signaled before the specified time delay, a <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskCanceledException&gt;</ph> exception results, and the task is completed in the <ph id="ph2">&lt;xref:System.Threading.Tasks.TaskStatus.Canceled&gt;</ph> state.</source>
          <target state="translated">Si el token de cancelación se señala antes el retraso de tiempo especificado, un <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskCanceledException&gt;</ph> resultados de la excepción y la tarea se completa en el <ph id="ph2">&lt;xref:System.Threading.Tasks.TaskStatus.Canceled&gt;</ph> estado.</target>       </trans-unit>
        <trans-unit id="537" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Delay(System.Int32,System.Threading.CancellationToken)">
          <source>Otherwise, the task is completed in the <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskStatus.RanToCompletion&gt;</ph> state once the specified time delay has elapsed.</source>
          <target state="translated">En caso contrario, se completa la tarea en el <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskStatus.RanToCompletion&gt;</ph> estado una vez que haya transcurrido el intervalo de tiempo especificado.</target>       </trans-unit>
        <trans-unit id="538" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Delay(System.Int32,System.Threading.CancellationToken)">
          <source>For usage scenarios and additional examples, see the documentation for the <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Delay%28System.Int32%29&gt;</ph> overload.</source>
          <target state="translated">Para escenarios de uso y ejemplos adicionales, consulte la documentación de la <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Delay%28System.Int32%29&gt;</ph> de sobrecarga.</target>       </trans-unit>
        <trans-unit id="539" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Delay(System.Int32,System.Threading.CancellationToken)">
          <source>This method depends on the system clock.</source>
          <target state="translated">Este método depende del reloj del sistema.</target>       </trans-unit>
        <trans-unit id="540" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Delay(System.Int32,System.Threading.CancellationToken)">
          <source>This means that the time delay will approximately equal the resolution of the system clock if the <ph id="ph1">`millisecondsDelay`</ph> argument is less than the resolution of the system clock, which is approximately 15 milliseconds on Windows systems.</source>
          <target state="translated">Esto significa que el tiempo de retardo aproximadamente será igual a la resolución del reloj del sistema si el <ph id="ph1">`millisecondsDelay`</ph> argumento es menor que la resolución del reloj del sistema, que es aproximadamente 15 milisegundos en los sistemas Windows.</target>       </trans-unit>
        <trans-unit id="541" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Delay(System.Int32,System.Threading.CancellationToken)">
          <source>The following example launches a task that includes a call to the <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Delay%28System.Int32%2CSystem.Threading.CancellationToken%29&gt;</ph> method with a one second delay.</source>
          <target state="translated">El ejemplo siguiente inicia una tarea que incluye una llamada a la <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Delay%28System.Int32%2CSystem.Threading.CancellationToken%29&gt;</ph> método con un un retraso segundo.</target>       </trans-unit>
        <trans-unit id="542" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Delay(System.Int32,System.Threading.CancellationToken)">
          <source>Before the delay interval elapses, the token is cancelled.</source>
          <target state="translated">Antes de que transcurra el intervalo de demora, se cancela el token.</target>       </trans-unit>
        <trans-unit id="543" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Delay(System.Int32,System.Threading.CancellationToken)">
          <source>The output from the example shows that, as a result, a <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskCanceledException&gt;</ph> is thrown, and the tasks' <ph id="ph2">&lt;xref:System.Threading.Tasks.Task.Status%2A&gt;</ph> property is set to <ph id="ph3">&lt;xref:System.Threading.Tasks.TaskStatus.Canceled&gt;</ph>.</source>
          <target state="translated">El resultado del ejemplo muestra que, como resultado, un <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskCanceledException&gt;</ph> se inicia y las tareas <ph id="ph2">&lt;xref:System.Threading.Tasks.Task.Status%2A&gt;</ph> propiedad está establecida en <ph id="ph3">&lt;xref:System.Threading.Tasks.TaskStatus.Canceled&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="544" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Delay(System.Int32,System.Threading.CancellationToken)">
          <source>The <ph id="ph1">&lt;paramref name="millisecondsDelay" /&gt;</ph> argument is less than -1.</source>
          <target state="translated">El argumento <ph id="ph1">&lt;paramref name="millisecondsDelay" /&gt;</ph> es menor que -1.</target>       </trans-unit>
        <trans-unit id="545" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Delay(System.Int32,System.Threading.CancellationToken)">
          <source>The task has been canceled.</source>
          <target state="translated">La tarea se canceló.</target>       </trans-unit>
        <trans-unit id="546" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Delay(System.Int32,System.Threading.CancellationToken)">
          <source>The provided <ph id="ph1">&lt;paramref name="cancellationToken" /&gt;</ph> has already been disposed.</source>
          <target state="translated">El <ph id="ph1">&lt;paramref name="cancellationToken" /&gt;</ph> proporcionado ya se ha eliminado.</target>       </trans-unit>
        <trans-unit id="547" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Delay(System.TimeSpan,System.Threading.CancellationToken)">
          <source>The time span to wait before completing the returned task, or <ph id="ph1">&lt;see langword="TimeSpan.FromMilliseconds(-1)" /&gt;</ph> to wait indefinitely.</source>
          <target state="translated">El intervalo de tiempo que espera antes de completar la tarea devuelta o <ph id="ph1">&lt;see langword="TimeSpan.FromMilliseconds(-1)" /&gt;</ph> para esperar indefinidamente.</target>       </trans-unit>
        <trans-unit id="548" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Delay(System.TimeSpan,System.Threading.CancellationToken)">
          <source>The cancellation token that will be checked prior to completing the returned task.</source>
          <target state="translated">El token de cancelación que se comprobará antes de completar la tarea devuelta.</target>       </trans-unit>
        <trans-unit id="549" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Delay(System.TimeSpan,System.Threading.CancellationToken)">
          <source>Creates a cancellable task that completes after a specified time interval.</source>
          <target state="translated">Crea una tarea cancelable que se completa después de un intervalo de tiempo específico.</target>       </trans-unit>
        <trans-unit id="550" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Delay(System.TimeSpan,System.Threading.CancellationToken)">
          <source>A task that represents the time delay.</source>
          <target state="translated">Una tarea que representa el retraso.</target>       </trans-unit>
        <trans-unit id="551" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Delay(System.TimeSpan,System.Threading.CancellationToken)">
          <source>If the cancellation token is signaled before the specified time delay, a <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskCanceledException&gt;</ph> exception results, and the task is completed in the <ph id="ph2">&lt;xref:System.Threading.Tasks.TaskStatus.Canceled&gt;</ph> state.</source>
          <target state="translated">Si el token de cancelación se señala antes el retraso de tiempo especificado, un <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskCanceledException&gt;</ph> resultados de la excepción y la tarea se completa en el <ph id="ph2">&lt;xref:System.Threading.Tasks.TaskStatus.Canceled&gt;</ph> estado.</target>       </trans-unit>
        <trans-unit id="552" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Delay(System.TimeSpan,System.Threading.CancellationToken)">
          <source>Otherwise, the task is completed in the <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskStatus.RanToCompletion&gt;</ph> state once the specified time delay has elapsed.</source>
          <target state="translated">En caso contrario, se completa la tarea en el <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskStatus.RanToCompletion&gt;</ph> estado una vez que haya transcurrido el intervalo de tiempo especificado.</target>       </trans-unit>
        <trans-unit id="553" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Delay(System.TimeSpan,System.Threading.CancellationToken)">
          <source>For usage scenarios and additional examples, see the documentation for the <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Delay%28System.Int32%29&gt;</ph> overload.</source>
          <target state="translated">Para escenarios de uso y ejemplos adicionales, consulte la documentación de la <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Delay%28System.Int32%29&gt;</ph> de sobrecarga.</target>       </trans-unit>
        <trans-unit id="554" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Delay(System.TimeSpan,System.Threading.CancellationToken)">
          <source>This method depends on the system clock.</source>
          <target state="translated">Este método depende del reloj del sistema.</target>       </trans-unit>
        <trans-unit id="555" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Delay(System.TimeSpan,System.Threading.CancellationToken)">
          <source>This means that the time delay will approximately equal the resolution of the system clock if the <ph id="ph1">`delay`</ph> argument is less than the resolution of the system clock, which is approximately 15 milliseconds on Windows systems.</source>
          <target state="translated">Esto significa que el tiempo de retardo aproximadamente será igual a la resolución del reloj del sistema si el <ph id="ph1">`delay`</ph> argumento es menor que la resolución del reloj del sistema, que es aproximadamente 15 milisegundos en los sistemas Windows.</target>       </trans-unit>
        <trans-unit id="556" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Delay(System.TimeSpan,System.Threading.CancellationToken)">
          <source>The following example launches a task that includes a call to the <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Delay%28System.TimeSpan%2CSystem.Threading.CancellationToken%29&gt;</ph> method with a one-and-a-half second delay.</source>
          <target state="translated">El ejemplo siguiente inicia una tarea que incluye una llamada a la <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Delay%28System.TimeSpan%2CSystem.Threading.CancellationToken%29&gt;</ph> método con un retraso de segundo de uno y medio.</target>       </trans-unit>
        <trans-unit id="557" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Delay(System.TimeSpan,System.Threading.CancellationToken)">
          <source>Before the delay interval elapses, the token is cancelled.</source>
          <target state="translated">Antes de que transcurra el intervalo de demora, se cancela el token.</target>       </trans-unit>
        <trans-unit id="558" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Delay(System.TimeSpan,System.Threading.CancellationToken)">
          <source>The output from the example shows that, as a result, a <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskCanceledException&gt;</ph> is thrown, and the tasks' <ph id="ph2">&lt;xref:System.Threading.Tasks.Task.Status%2A&gt;</ph> property is set to <ph id="ph3">&lt;xref:System.Threading.Tasks.TaskStatus.Canceled&gt;</ph>.</source>
          <target state="translated">El resultado del ejemplo muestra que, como resultado, un <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskCanceledException&gt;</ph> se inicia y las tareas <ph id="ph2">&lt;xref:System.Threading.Tasks.Task.Status%2A&gt;</ph> propiedad está establecida en <ph id="ph3">&lt;xref:System.Threading.Tasks.TaskStatus.Canceled&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="559" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Delay(System.TimeSpan,System.Threading.CancellationToken)">
          <source>Note that this example includes a potential race condition: it depends on the task asynchronously executing the delay when the token is cancelled.</source>
          <target state="translated">Tenga en cuenta que este ejemplo incluye una posible condición de carrera: depende de la tarea ejecutando el retraso de forma asincrónica cuando se cancela el token.</target>       </trans-unit>
        <trans-unit id="560" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Delay(System.TimeSpan,System.Threading.CancellationToken)">
          <source>Although the 1.5 second delay from the call to the <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Delay%28System.TimeSpan%2CSystem.Threading.CancellationToken%29&gt;</ph> method makes that assumption likely, it is nevertheless possible that the call to the <ph id="ph2">&lt;xref:System.Threading.Tasks.Task.Delay%28System.TimeSpan%2CSystem.Threading.CancellationToken%29&gt;</ph> method could return before the token is cancelled.</source>
          <target state="translated">Aunque el segundo 1,5 retraso de la llamada a la <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Delay%28System.TimeSpan%2CSystem.Threading.CancellationToken%29&gt;</ph> método realiza esa suposición probable, sin embargo, es posible que la llamada a la <ph id="ph2">&lt;xref:System.Threading.Tasks.Task.Delay%28System.TimeSpan%2CSystem.Threading.CancellationToken%29&gt;</ph> método podría devolver antes de que se cancela el token.</target>       </trans-unit>
        <trans-unit id="561" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Delay(System.TimeSpan,System.Threading.CancellationToken)">
          <source>In that case, the example produces the following output:</source>
          <target state="translated">En ese caso, el ejemplo produce el siguiente resultado:</target>       </trans-unit>
        <trans-unit id="562" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Delay(System.TimeSpan,System.Threading.CancellationToken)">
          <source><ph id="ph1">&lt;paramref name="delay" /&gt;</ph> represents a negative time interval other than <ph id="ph2">&lt;see langword="TimeSpan.FromMillseconds(-1)" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="delay" /&gt;</ph> representa un intervalo de tiempo negativo distinto de <ph id="ph2">&lt;see langword="TimeSpan.FromMillseconds(-1)" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="563" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Delay(System.TimeSpan,System.Threading.CancellationToken)">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="564" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Delay(System.TimeSpan,System.Threading.CancellationToken)">
          <source>The <ph id="ph1">&lt;paramref name="delay" /&gt;</ph> argument's <ph id="ph2">&lt;see cref="P:System.TimeSpan.TotalMilliseconds" /&gt;</ph> property is greater than <ph id="ph3">&lt;see cref="F:System.Int32.MaxValue" /&gt;</ph>.</source>
          <target state="translated">La propiedad <ph id="ph2">&lt;see cref="P:System.TimeSpan.TotalMilliseconds" /&gt;</ph> del argumento <ph id="ph1">&lt;paramref name="delay" /&gt;</ph> es mayor que <ph id="ph3">&lt;see cref="F:System.Int32.MaxValue" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="565" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Delay(System.TimeSpan,System.Threading.CancellationToken)">
          <source>The task has been canceled.</source>
          <target state="translated">La tarea se canceló.</target>       </trans-unit>
        <trans-unit id="566" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Delay(System.TimeSpan,System.Threading.CancellationToken)">
          <source>The provided <ph id="ph1">&lt;paramref name="cancellationToken" /&gt;</ph> has already been disposed.</source>
          <target state="translated">El <ph id="ph1">&lt;paramref name="cancellationToken" /&gt;</ph> proporcionado ya se ha eliminado.</target>       </trans-unit>
        <trans-unit id="567" translate="yes" xml:space="preserve" uid="T:System.Threading.Tasks.Task">
          <source>Releases all resources used by the current instance of the <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> class.</source>
          <target state="translated">Libera todos los recursos usados por la instancia actual de la clase <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="568" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Dispose">
          <source>Releases all resources used by the current instance of the <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> class.</source>
          <target state="translated">Libera todos los recursos usados por la instancia actual de la clase <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="569" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Dispose">
          <source>The <ph id="ph1">&lt;xref:System.Threading.Tasks.Task&gt;</ph> class implements the <ph id="ph2">&lt;xref:System.IDisposable&gt;</ph> interface because internally it uses resources that also implement <ph id="ph3">&lt;xref:System.IDisposable&gt;</ph>.</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.Threading.Tasks.Task&gt;</ph> la clase implementa la <ph id="ph2">&lt;xref:System.IDisposable&gt;</ph> porque internamente utiliza recursos que también implementan la interfaz <ph id="ph3">&lt;xref:System.IDisposable&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="570" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Dispose">
          <source>However, particularly if your app targets the <ph id="ph1">[!INCLUDE[net_v45](~/includes/net-v45-md.md)]</ph> or later, there is no need to call <ph id="ph2">&lt;xref:System.Threading.Tasks.Task.Dispose%2A&gt;</ph> unless performance or scalability testing indicates that, based on your usage patterns, your app's performance would be improved by disposing of tasks.</source>
          <target state="translated">Sin embargo, especialmente si la aplicación tiene como destino el <ph id="ph1">[!INCLUDE[net_v45](~/includes/net-v45-md.md)]</ph> o una versión posterior, no es necesario llamar a <ph id="ph2">&lt;xref:System.Threading.Tasks.Task.Dispose%2A&gt;</ph> a menos que el rendimiento o las pruebas de escalabilidad indican que, según los patrones de uso, rendimiento de la aplicación podría mejorarse eliminando de tareas.</target>       </trans-unit>
        <trans-unit id="571" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Dispose">
          <source>For more information, see <bpt id="p1">[</bpt>Do I need to dispose of Tasks?<ept id="p1">](http://blogs.msdn.com/b/pfxteam/archive/2012/03/25/10287435.aspx)</ept> in the Parallel Programming with .NET blog.</source>
          <target state="translated">Para obtener más información, consulte <bpt id="p1">[</bpt>es necesario disponer de tareas?<ept id="p1">](http://blogs.msdn.com/b/pfxteam/archive/2012/03/25/10287435.aspx)</ept> en la programación en paralelo con .NET blog.</target>       </trans-unit>
        <trans-unit id="572" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Dispose">
          <source>The task is not in one of the final states: <ph id="ph1">&lt;see cref="F:System.Threading.Tasks.TaskStatus.RanToCompletion" /&gt;</ph>, <ph id="ph2">&lt;see cref="F:System.Threading.Tasks.TaskStatus.Faulted" /&gt;</ph>, or <ph id="ph3">&lt;see cref="F:System.Threading.Tasks.TaskStatus.Canceled" /&gt;</ph>.</source>
          <target state="translated">La tarea no está en uno de los estados finales: <ph id="ph1">&lt;see cref="F:System.Threading.Tasks.TaskStatus.RanToCompletion" /&gt;</ph>, <ph id="ph2">&lt;see cref="F:System.Threading.Tasks.TaskStatus.Faulted" /&gt;</ph> o <ph id="ph3">&lt;see cref="F:System.Threading.Tasks.TaskStatus.Canceled" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="573" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Dispose(System.Boolean)">
          <source>A Boolean value that indicates whether this method is being called due to a call to <ph id="ph1">&lt;see cref="M:System.Threading.Tasks.Task.Dispose" /&gt;</ph>.</source>
          <target state="translated">Valor booleano que indica si se llama a este método debido a una llamada a <ph id="ph1">&lt;see cref="M:System.Threading.Tasks.Task.Dispose" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="574" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Dispose(System.Boolean)">
          <source>Disposes the <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph>, releasing all of its unmanaged resources.</source>
          <target state="translated">Desecha el objeto <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> y libera todos sus recursos no administrados.</target>       </trans-unit>
        <trans-unit id="575" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Dispose(System.Boolean)">
          <source>The <ph id="ph1">&lt;xref:System.Threading.Tasks.Task&gt;</ph> class implements the <ph id="ph2">&lt;xref:System.IDisposable&gt;</ph> interface because internally it uses resources that also implement <ph id="ph3">&lt;xref:System.IDisposable&gt;</ph>.</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.Threading.Tasks.Task&gt;</ph> la clase implementa la <ph id="ph2">&lt;xref:System.IDisposable&gt;</ph> porque internamente utiliza recursos que también implementan la interfaz <ph id="ph3">&lt;xref:System.IDisposable&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="576" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Dispose(System.Boolean)">
          <source>However, particularly if your app targets the <ph id="ph1">[!INCLUDE[net_v45](~/includes/net-v45-md.md)]</ph> or later, there is no need to call <ph id="ph2">&lt;xref:System.Threading.Tasks.Task.Dispose%2A&gt;</ph> unless performance or scalability testing indicates that, based on your usage patterns, your app's performance would be improved by disposing of tasks.</source>
          <target state="translated">Sin embargo, especialmente si la aplicación tiene como destino el <ph id="ph1">[!INCLUDE[net_v45](~/includes/net-v45-md.md)]</ph> o una versión posterior, no es necesario llamar a <ph id="ph2">&lt;xref:System.Threading.Tasks.Task.Dispose%2A&gt;</ph> a menos que el rendimiento o las pruebas de escalabilidad indican que, según los patrones de uso, rendimiento de la aplicación podría mejorarse eliminando de tareas.</target>       </trans-unit>
        <trans-unit id="577" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Dispose(System.Boolean)">
          <source>For more information, see <bpt id="p1">[</bpt>Do I need to dispose of Tasks?<ept id="p1">](http://blogs.msdn.com/b/pfxteam/archive/2012/03/25/10287435.aspx)</ept> in the Parallel Programming with .NET blog.</source>
          <target state="translated">Para obtener más información, consulte <bpt id="p1">[</bpt>es necesario disponer de tareas?<ept id="p1">](http://blogs.msdn.com/b/pfxteam/archive/2012/03/25/10287435.aspx)</ept> en la programación en paralelo con .NET blog.</target>       </trans-unit>
        <trans-unit id="578" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Dispose(System.Boolean)">
          <source>The task is not in one of the final states: <ph id="ph1">&lt;see cref="F:System.Threading.Tasks.TaskStatus.RanToCompletion" /&gt;</ph>, <ph id="ph2">&lt;see cref="F:System.Threading.Tasks.TaskStatus.Faulted" /&gt;</ph>, or <ph id="ph3">&lt;see cref="F:System.Threading.Tasks.TaskStatus.Canceled" /&gt;</ph>.</source>
          <target state="translated">La tarea no está en uno de los estados finales: <ph id="ph1">&lt;see cref="F:System.Threading.Tasks.TaskStatus.RanToCompletion" /&gt;</ph>, <ph id="ph2">&lt;see cref="F:System.Threading.Tasks.TaskStatus.Faulted" /&gt;</ph> o <ph id="ph3">&lt;see cref="F:System.Threading.Tasks.TaskStatus.Canceled" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="579" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Dispose(System.Boolean)">
          <source>Unlike most of the members of the <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> class, this method is not thread-safe.</source>
          <target state="translated">A diferencia de la mayoría de los miembros de la <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> (clase), este método no es seguro para subprocesos.</target>       </trans-unit>
        <trans-unit id="580" translate="yes" xml:space="preserve" uid="P:System.Threading.Tasks.Task.Exception">
          <source>Gets the <ph id="ph1">&lt;see cref="T:System.AggregateException" /&gt;</ph> that caused the <ph id="ph2">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> to end prematurely.</source>
          <target state="translated">Obtiene la excepción <ph id="ph1">&lt;see cref="T:System.AggregateException" /&gt;</ph> que causó la finalización prematura del objeto <ph id="ph2">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="581" translate="yes" xml:space="preserve" uid="P:System.Threading.Tasks.Task.Exception">
          <source>If the <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> completed successfully or has not yet thrown any exceptions, this will return <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Si <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> se completó correctamente o no ha iniciado ninguna excepción, el valor devuelto será <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="582" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Tasks.Task.Exception">
          <source>The <ph id="ph1">&lt;see cref="T:System.AggregateException" /&gt;</ph> that caused the <ph id="ph2">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> to end prematurely.</source>
          <target state="translated">Excepción <ph id="ph1">&lt;see cref="T:System.AggregateException" /&gt;</ph> que causó la finalización prematura del objeto <ph id="ph2">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="583" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Tasks.Task.Exception">
          <source>Tasks that throw unhandled exceptions store the resulting exception and propagate it wrapped in a <ph id="ph1">&lt;xref:System.AggregateException&gt;</ph> in calls to <ph id="ph2">&lt;xref:System.Threading.Tasks.Task.Wait%2A&gt;</ph> or in accesses to the <ph id="ph3">&lt;xref:System.Threading.Tasks.Task.Exception%2A&gt;</ph> property.</source>
          <target state="translated">Las tareas que producen excepciones no controladas almacenan la excepción resultante y propagan incluida en una <ph id="ph1">&lt;xref:System.AggregateException&gt;</ph> en las llamadas a <ph id="ph2">&lt;xref:System.Threading.Tasks.Task.Wait%2A&gt;</ph> o en accesos a la <ph id="ph3">&lt;xref:System.Threading.Tasks.Task.Exception%2A&gt;</ph> propiedad.</target>       </trans-unit>
        <trans-unit id="584" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Tasks.Task.Exception">
          <source>Any exceptions not observed by the time the task instance is garbage collected will be propagated on the finalizer thread.</source>
          <target state="translated">Las excepciones no detecta la instancia de tarea sean recolección se propagará en el subproceso finalizador.</target>       </trans-unit>
        <trans-unit id="585" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Tasks.Task.Exception">
          <source>For more information and an example, see <bpt id="p1">[</bpt>Exception Handling (Task Parallel Library)<ept id="p1">](~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md)</ept>.</source>
          <target state="translated">Para obtener más información y un ejemplo, vea <bpt id="p1">[</bpt>control de excepciones (Task Parallel Library)<ept id="p1">](~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md)</ept>.</target>       </trans-unit>
        <trans-unit id="586" translate="yes" xml:space="preserve" uid="P:System.Threading.Tasks.Task.Factory">
          <source>Provides access to factory methods for creating and configuring <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> and <ph id="ph2">&lt;see cref="T:System.Threading.Tasks.Task`1" /&gt;</ph> instances.</source>
          <target state="translated">Proporciona acceso a patrones de diseño para crear y configurar instancias de <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> y <ph id="ph2">&lt;see cref="T:System.Threading.Tasks.Task`1" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="587" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Tasks.Task.Factory">
          <source>A factory object that can create a variety of <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> and <ph id="ph2">&lt;see cref="T:System.Threading.Tasks.Task`1" /&gt;</ph> objects.</source>
          <target state="translated">Un objeto de fábrica que puede crear una variedad de objetos <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> y <ph id="ph2">&lt;see cref="T:System.Threading.Tasks.Task`1" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="588" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Tasks.Task.Factory">
          <source>This property returns a default instance of the <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskFactory&gt;</ph> class that is identical to the one created by calling the parameterless <ph id="ph2">&lt;xref:System.Threading.Tasks.TaskFactory.%23ctor?displayProperty=nameWithType&gt;</ph> constructor.</source>
          <target state="translated">Esta propiedad devuelve una instancia predeterminada de la <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskFactory&gt;</ph> que es idéntica a la que se creó mediante una llamada sin parámetros <ph id="ph2">&lt;xref:System.Threading.Tasks.TaskFactory.%23ctor?displayProperty=nameWithType&gt;</ph> constructor.</target>       </trans-unit>
        <trans-unit id="589" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Tasks.Task.Factory">
          <source>It has the following property values:</source>
          <target state="translated">Tiene los siguientes valores de propiedad:</target>       </trans-unit>
        <trans-unit id="590" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Tasks.Task.Factory">
          <source>Property</source>
          <target state="translated">Propiedad.</target>       </trans-unit>
        <trans-unit id="591" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Tasks.Task.Factory">
          <source>Value</source>
          <target state="translated">Valor</target>       </trans-unit>
        <trans-unit id="592" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Tasks.Task.Factory">
          <source><ph id="ph1">`null`</ph>, or <ph id="ph2">&lt;xref:System.Threading.Tasks.TaskScheduler.Current%2A?displayProperty=nameWithType&gt;</ph></source>
          <target state="translated"><ph id="ph1">`null`</ph>, o <ph id="ph2">&lt;xref:System.Threading.Tasks.TaskScheduler.Current%2A?displayProperty=nameWithType&gt;</ph></target>       </trans-unit>
        <trans-unit id="593" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Tasks.Task.Factory">
          <source>The most common use of this property is to create and start a new task in a single call to the <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskFactory.StartNew%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">El uso más común de esta propiedad es crear e iniciar una nueva tarea en una sola llamada a la <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskFactory.StartNew%2A?displayProperty=nameWithType&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="594" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Tasks.Task.Factory">
          <source>Starting with the <ph id="ph1">[!INCLUDE[net_v45](~/includes/net-v45-md.md)]</ph>, the <ph id="ph2">&lt;xref:System.Threading.Tasks.Task.Run%2A?displayProperty=nameWithType&gt;</ph> method provides the easiest way to create a <ph id="ph3">&lt;xref:System.Threading.Tasks.Task&gt;</ph> object with default configuration values.</source>
          <target state="translated">A partir de la <ph id="ph1">[!INCLUDE[net_v45](~/includes/net-v45-md.md)]</ph>, <ph id="ph2">&lt;xref:System.Threading.Tasks.Task.Run%2A?displayProperty=nameWithType&gt;</ph> método proporciona la manera más fácil de crear un <ph id="ph3">&lt;xref:System.Threading.Tasks.Task&gt;</ph> objeto con valores de configuración predeterminados.</target>       </trans-unit>
        <trans-unit id="595" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Tasks.Task.Factory">
          <source>The following example uses the static <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Factory%2A&gt;</ph> property to make two calls to the <ph id="ph2">&lt;xref:System.Threading.Tasks.TaskFactory.StartNew%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">En el ejemplo siguiente se utiliza el método estático <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Factory%2A&gt;</ph> propiedad realizar dos llamadas a la <ph id="ph2">&lt;xref:System.Threading.Tasks.TaskFactory.StartNew%2A?displayProperty=nameWithType&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="596" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Tasks.Task.Factory">
          <source>The first populates an array with the names of files in the user's MyDocuments directory, while the second populates an array with the names of subdirectories of the user's MyDocuments directory.</source>
          <target state="translated">La primera rellena una matriz con los nombres de los archivos del directorio Mis documentos del usuario, mientras que el segundo rellena una matriz con los nombres de los subdirectorios del directorio de Mis documentos del usuario.</target>       </trans-unit>
        <trans-unit id="597" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Tasks.Task.Factory">
          <source>It then calls the <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskFactory.ContinueWhenAll%28System.Threading.Tasks.Task%5B%5D%2CSystem.Action%7BSystem.Threading.Tasks.Task%5B%5D%7D%29?displayProperty=nameWithType&gt;</ph> method, which displays information about the number of files and directories in the two arrays after the first two tasks have completed execution.</source>
          <target state="translated">A continuación, llama el <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskFactory.ContinueWhenAll%28System.Threading.Tasks.Task%5B%5D%2CSystem.Action%7BSystem.Threading.Tasks.Task%5B%5D%7D%29?displayProperty=nameWithType&gt;</ph> método, que muestra información sobre el número de archivos y directorios en las dos matrices después de las dos primeras tareas hayan terminado de ejecutarse.</target>       </trans-unit>
        <trans-unit id="598" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.FromCanceled(System.Threading.CancellationToken)">
          <source>The cancellation token with which to complete the task.</source>
          <target state="translated">Token de cancelación con el que se finaliza la tarea.</target>       </trans-unit>
        <trans-unit id="599" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.FromCanceled(System.Threading.CancellationToken)">
          <source>Creates a <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> that's completed due to cancellation with a specified cancellation token.</source>
          <target state="translated">Crea una <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> que se finaliza debido a la cancelación con un token de cancelación especificado.</target>       </trans-unit>
        <trans-unit id="600" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.FromCanceled(System.Threading.CancellationToken)">
          <source>The canceled task.</source>
          <target state="translated">Tarea cancelada.</target>       </trans-unit>
        <trans-unit id="601" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.FromCanceled(System.Threading.CancellationToken)">
          <source>Cancellation has not been requested for <ph id="ph1">&lt;paramref name="cancellationToken" /&gt;</ph>; its <ph id="ph2">&lt;see cref="P:System.Threading.CancellationToken.IsCancellationRequested" /&gt;</ph> property is <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">No se solicitó la cancelación de <ph id="ph1">&lt;paramref name="cancellationToken" /&gt;</ph>; su propiedad <ph id="ph2">&lt;see cref="P:System.Threading.CancellationToken.IsCancellationRequested" /&gt;</ph> es <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="602" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.FromCanceled``1(System.Threading.CancellationToken)">
          <source>The type of the result returned by the task.</source>
          <target state="translated">Tipo de resultado devuelto por la tarea.</target>       </trans-unit>
        <trans-unit id="603" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.FromCanceled``1(System.Threading.CancellationToken)">
          <source>The cancellation token with which to complete the task.</source>
          <target state="translated">Token de cancelación con el que se finaliza la tarea.</target>       </trans-unit>
        <trans-unit id="604" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.FromCanceled``1(System.Threading.CancellationToken)">
          <source>Creates a <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task`1" /&gt;</ph> that's completed due to cancellation with a specified cancellation token.</source>
          <target state="translated">Crea una <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task`1" /&gt;</ph> que se finaliza debido a la cancelación con un token de cancelación especificado.</target>       </trans-unit>
        <trans-unit id="605" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.FromCanceled``1(System.Threading.CancellationToken)">
          <source>The canceled task.</source>
          <target state="translated">Tarea cancelada.</target>       </trans-unit>
        <trans-unit id="606" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.FromCanceled``1(System.Threading.CancellationToken)">
          <source>Cancellation has not been requested for <ph id="ph1">&lt;paramref name="cancellationToken" /&gt;</ph>; its <ph id="ph2">&lt;see cref="P:System.Threading.CancellationToken.IsCancellationRequested" /&gt;</ph> property is <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">No se solicitó la cancelación de <ph id="ph1">&lt;paramref name="cancellationToken" /&gt;</ph>; su propiedad <ph id="ph2">&lt;see cref="P:System.Threading.CancellationToken.IsCancellationRequested" /&gt;</ph> es <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="607" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.FromException(System.Exception)">
          <source>The exception with which to complete the task.</source>
          <target state="translated">Excepción con la que se finaliza la tarea.</target>       </trans-unit>
        <trans-unit id="608" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.FromException(System.Exception)">
          <source>Creates a <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> that has completed with a specified exception.</source>
          <target state="translated">Crea una <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> que finalizó con una excepción especificada.</target>       </trans-unit>
        <trans-unit id="609" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.FromException(System.Exception)">
          <source>The faulted task.</source>
          <target state="translated">Tarea con error.</target>       </trans-unit>
        <trans-unit id="610" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.FromException(System.Exception)">
          <source>This method creates a <ph id="ph1">&lt;xref:System.Threading.Tasks.Task&gt;</ph> object whose <ph id="ph2">&lt;xref:System.Threading.Tasks.Task.Status%2A&gt;</ph> property is <ph id="ph3">&lt;xref:System.Threading.Tasks.TaskStatus.Faulted&gt;</ph> and whose <ph id="ph4">&lt;xref:System.Threading.Tasks.Task.Exception%2A&gt;</ph> property contains <ph id="ph5">`exception`</ph>.</source>
          <target state="translated">Este método crea un <ph id="ph1">&lt;xref:System.Threading.Tasks.Task&gt;</ph> cuyos <ph id="ph2">&lt;xref:System.Threading.Tasks.Task.Status%2A&gt;</ph> propiedad es <ph id="ph3">&lt;xref:System.Threading.Tasks.TaskStatus.Faulted&gt;</ph> y cuyo <ph id="ph4">&lt;xref:System.Threading.Tasks.Task.Exception%2A&gt;</ph> propiedad contiene <ph id="ph5">`exception`</ph>.</target>       </trans-unit>
        <trans-unit id="611" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.FromException(System.Exception)">
          <source>The method is commonly used when you immediately know that the work that a task performs will throw an exception before executing a longer code path.</source>
          <target state="translated">El método suele utilizarse cuando sabrá inmediatamente que el trabajo que realiza una tarea iniciará una excepción antes de ejecutar una ruta de acceso de código más.</target>       </trans-unit>
        <trans-unit id="612" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.FromException(System.Exception)">
          <source>For an example, see the <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.FromException%60%601%28System.Exception%29&gt;</ph> overload.</source>
          <target state="translated">Para obtener un ejemplo, vea el <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.FromException%60%601%28System.Exception%29&gt;</ph> sobrecarga.</target>       </trans-unit>
        <trans-unit id="613" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.FromException``1(System.Exception)">
          <source>The type of the result returned by the task.</source>
          <target state="translated">Tipo de resultado devuelto por la tarea.</target>       </trans-unit>
        <trans-unit id="614" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.FromException``1(System.Exception)">
          <source>The exception with which to complete the task.</source>
          <target state="translated">Excepción con la que se finaliza la tarea.</target>       </trans-unit>
        <trans-unit id="615" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.FromException``1(System.Exception)">
          <source>Creates a <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task`1" /&gt;</ph> that's completed with a specified exception.</source>
          <target state="translated">Crea una <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task`1" /&gt;</ph> que finalizó con una excepción especificada.</target>       </trans-unit>
        <trans-unit id="616" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.FromException``1(System.Exception)">
          <source>The faulted task.</source>
          <target state="translated">Tarea con error.</target>       </trans-unit>
        <trans-unit id="617" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.FromException``1(System.Exception)">
          <source>This method creates a <ph id="ph1">&lt;xref:System.Threading.Tasks.Task%601&gt;</ph> object whose <ph id="ph2">&lt;xref:System.Threading.Tasks.Task.Status%2A&gt;</ph> property is <ph id="ph3">&lt;xref:System.Threading.Tasks.TaskStatus.Faulted&gt;</ph> and whose <ph id="ph4">&lt;xref:System.Threading.Tasks.Task.Exception%2A&gt;</ph> property contains <ph id="ph5">`exception`</ph>.</source>
          <target state="translated">Este método crea un <ph id="ph1">&lt;xref:System.Threading.Tasks.Task%601&gt;</ph> cuyos <ph id="ph2">&lt;xref:System.Threading.Tasks.Task.Status%2A&gt;</ph> propiedad es <ph id="ph3">&lt;xref:System.Threading.Tasks.TaskStatus.Faulted&gt;</ph> y cuyo <ph id="ph4">&lt;xref:System.Threading.Tasks.Task.Exception%2A&gt;</ph> propiedad contiene <ph id="ph5">`exception`</ph>.</target>       </trans-unit>
        <trans-unit id="618" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.FromException``1(System.Exception)">
          <source>The method is commonly used when you immediately know that the work that a task performs will throw an exception before executing a longer code path.</source>
          <target state="translated">El método suele utilizarse cuando sabrá inmediatamente que el trabajo que realiza una tarea iniciará una excepción antes de ejecutar una ruta de acceso de código más.</target>       </trans-unit>
        <trans-unit id="619" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.FromException``1(System.Exception)">
          <source>The example provides an illustration.</source>
          <target state="translated">En este ejemplo se ilustra.</target>       </trans-unit>
        <trans-unit id="620" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.FromException``1(System.Exception)">
          <source>The following example is a command-line utility that calculates the number of bytes in the files in each directory whose name is passed as a command-line argument.</source>
          <target state="translated">El ejemplo siguiente es una utilidad de línea de comandos que calcula el número de bytes de los archivos en cada directorio cuyo nombre se pasa como un argumento de línea de comandos.</target>       </trans-unit>
        <trans-unit id="621" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.FromException``1(System.Exception)">
          <source>Rather than executing a longer code path that instantiates a <ph id="ph1">&lt;xref:System.IO.FileInfo&gt;</ph> object and retrieves the value of its <ph id="ph2">&lt;xref:System.IO.FileInfo.Length%2A?displayProperty=nameWithType&gt;</ph> property for each file in the directory, the example simply calls the <ph id="ph3">&lt;xref:System.Threading.Tasks.Task.FromException%60%601%28System.Exception%29&gt;</ph> method to create a faulted task if a particular subdirectory does not exist.</source>
          <target state="translated">En lugar de ejecutar una ruta de acceso más larga de código que crea una instancia de un <ph id="ph1">&lt;xref:System.IO.FileInfo&gt;</ph> objeto y recupera el valor de su <ph id="ph2">&lt;xref:System.IO.FileInfo.Length%2A?displayProperty=nameWithType&gt;</ph> propiedad para cada archivo en el directorio, en el ejemplo se llama simplemente la <ph id="ph3">&lt;xref:System.Threading.Tasks.Task.FromException%60%601%28System.Exception%29&gt;</ph> método para crear una tarea con errores si un determinado subdirectorio no existe.</target>       </trans-unit>
        <trans-unit id="622" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.FromResult``1(``0)">
          <source>The type of the result returned by the task.</source>
          <target state="translated">Tipo de resultado devuelto por la tarea.</target>       </trans-unit>
        <trans-unit id="623" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.FromResult``1(``0)">
          <source>The result to store into the completed task.</source>
          <target state="translated">Resultado que se va a almacenar en la tarea completada.</target>       </trans-unit>
        <trans-unit id="624" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.FromResult``1(``0)">
          <source>Creates a <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task`1" /&gt;</ph> that's completed successfully with the specified result.</source>
          <target state="translated">Crea un objeto <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task`1" /&gt;</ph> que se ha completado correctamente con el resultado especificado.</target>       </trans-unit>
        <trans-unit id="625" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.FromResult``1(``0)">
          <source>The successfully completed task.</source>
          <target state="translated">Tarea completada correctamente.</target>       </trans-unit>
        <trans-unit id="626" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.FromResult``1(``0)">
          <source>This method creates a <ph id="ph1">&lt;xref:System.Threading.Tasks.Task%601&gt;</ph> object whose <ph id="ph2">&lt;xref:System.Threading.Tasks.Task%601.Result%2A?displayProperty=nameWithType&gt;</ph> property is <ph id="ph3">`result`</ph> and whose <ph id="ph4">&lt;xref:System.Threading.Tasks.Task.Status%2A&gt;</ph> property is <ph id="ph5">&lt;xref:System.Threading.Tasks.TaskStatus.RanToCompletion&gt;</ph>.</source>
          <target state="translated">Este método crea un <ph id="ph1">&lt;xref:System.Threading.Tasks.Task%601&gt;</ph> cuyos <ph id="ph2">&lt;xref:System.Threading.Tasks.Task%601.Result%2A?displayProperty=nameWithType&gt;</ph> propiedad es <ph id="ph3">`result`</ph> y cuyo <ph id="ph4">&lt;xref:System.Threading.Tasks.Task.Status%2A&gt;</ph> propiedad es <ph id="ph5">&lt;xref:System.Threading.Tasks.TaskStatus.RanToCompletion&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="627" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.FromResult``1(``0)">
          <source>The method is commonly used when the return value of a task is immediately known without executing a longer code path.</source>
          <target state="translated">El método se utiliza normalmente cuando el valor devuelto de una tarea se conoce inmediatamente sin ejecutar una ruta de acceso de código más.</target>       </trans-unit>
        <trans-unit id="628" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.FromResult``1(``0)">
          <source>The example provides an illustration.</source>
          <target state="translated">En este ejemplo se ilustra.</target>       </trans-unit>
        <trans-unit id="629" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.FromResult``1(``0)">
          <source>To create a Task object that does not return a value, retrieve the Task object from the <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.CompletedTask%2A&gt;</ph> property.</source>
          <target state="translated">Para crear un objeto de tarea que no devuelve un valor, recupere el objeto de tarea de la <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.CompletedTask%2A&gt;</ph> propiedad.</target>       </trans-unit>
        <trans-unit id="630" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.FromResult``1(``0)">
          <source>The following example is a command-line utility that calculates the number of bytes in the files in each directory whose name is passed as a command-line argument.</source>
          <target state="translated">El ejemplo siguiente es una utilidad de línea de comandos que calcula el número de bytes de los archivos en cada directorio cuyo nombre se pasa como un argumento de línea de comandos.</target>       </trans-unit>
        <trans-unit id="631" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.FromResult``1(``0)">
          <source>Rather than executing a longer code path that instantiates a <ph id="ph1">&lt;xref:System.IO.FileStream&gt;</ph> object and retrieves the value of its <ph id="ph2">&lt;xref:System.IO.FileStream.Length%2A?displayProperty=nameWithType&gt;</ph> property for each file in the directory, the example simply calls the <ph id="ph3">&lt;xref:System.Threading.Tasks.Task.FromResult%2A&gt;</ph> method to create a task whose <ph id="ph4">&lt;xref:System.Threading.Tasks.Task%601.Result%2A?displayProperty=nameWithType&gt;</ph> property is zero (0) if a directory has no files.</source>
          <target state="translated">En lugar de ejecutar una ruta de acceso más larga de código que crea una instancia de un <ph id="ph1">&lt;xref:System.IO.FileStream&gt;</ph> objeto y recupera el valor de su <ph id="ph2">&lt;xref:System.IO.FileStream.Length%2A?displayProperty=nameWithType&gt;</ph> propiedad para cada archivo en el directorio, en el ejemplo se llama simplemente la <ph id="ph3">&lt;xref:System.Threading.Tasks.Task.FromResult%2A&gt;</ph> método para crear una tarea cuya <ph id="ph4">&lt;xref:System.Threading.Tasks.Task%601.Result%2A?displayProperty=nameWithType&gt;</ph> propiedad es cero (0) si un directorio no tiene archivos.</target>       </trans-unit>
        <trans-unit id="632" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.GetAwaiter">
          <source>Gets an awaiter used to await this <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph>.</source>
          <target state="translated">Obtiene un awaiter utilizado para esperar a este objeto <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="633" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.GetAwaiter">
          <source>An awaiter instance.</source>
          <target state="translated">Una instancia de awaiter.</target>       </trans-unit>
        <trans-unit id="634" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.GetAwaiter">
          <source>This method is intended for compiler use rather than for use in application code.</source>
          <target state="translated">Este método está pensado para uso del compilador en lugar de para su uso en código de la aplicación.</target>       </trans-unit>
        <trans-unit id="635" translate="yes" xml:space="preserve" uid="P:System.Threading.Tasks.Task.Id">
          <source>Gets an ID for this <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> instance.</source>
          <target state="translated">Obtiene un identificador para esta instancia de <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="636" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Tasks.Task.Id">
          <source>The identifier that is assigned by the system to this <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> instance.</source>
          <target state="translated">Identificador asignado por el sistema a esta instancia de <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="637" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Tasks.Task.Id">
          <source>Task IDs are assigned on-demand and do not necessarily represent the order in which task instances are created.</source>
          <target state="translated">Identificadores de tarea se asignan a petición y no representa necesariamente el orden en la tarea que se crean instancias.</target>       </trans-unit>
        <trans-unit id="638" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Tasks.Task.Id">
          <source>Note that although collisions are very rare, task identifiers are not guaranteed to be unique.</source>
          <target state="translated">Tenga en cuenta que aunque las colisiones son muy raras, identificadores de tarea no se garantiza que sea único.</target>       </trans-unit>
        <trans-unit id="639" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Tasks.Task.Id">
          <source>To get the task ID of the currently executing task from within code that that task is executing, use the <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.CurrentId%2A&gt;</ph> property.</source>
          <target state="translated">Para obtener el Id. de tarea de la tarea actualmente en ejecución desde dentro del código que la tarea se está ejecutando, use la <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.CurrentId%2A&gt;</ph> propiedad.</target>       </trans-unit>
        <trans-unit id="640" translate="yes" xml:space="preserve" uid="P:System.Threading.Tasks.Task.IsCanceled">
          <source>Gets whether this <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> instance has completed execution due to being canceled.</source>
          <target state="translated">Obtiene un valor que indica si esta instancia de <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> ha completado su ejecución debido a una cancelación.</target>       </trans-unit>
        <trans-unit id="641" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Tasks.Task.IsCanceled">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the task has completed due to being canceled; otherwise <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">Es <ph id="ph1">&lt;see langword="true" /&gt;</ph> si la tarea se ha completado debido a su cancelación; de lo contrario, es <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="642" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Tasks.Task.IsCanceled">
          <source>A <ph id="ph1">&lt;xref:System.Threading.Tasks.Task&gt;</ph> will complete in the <ph id="ph2">&lt;xref:System.Threading.Tasks.TaskStatus.Canceled&gt;</ph> state under any of the following conditions:</source>
          <target state="translated">A <ph id="ph1">&lt;xref:System.Threading.Tasks.Task&gt;</ph> llevará a cabo en el <ph id="ph2">&lt;xref:System.Threading.Tasks.TaskStatus.Canceled&gt;</ph> estado en cualquiera de las condiciones siguientes:</target>       </trans-unit>
        <trans-unit id="643" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Tasks.Task.IsCanceled">
          <source>Its <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskFactory.CancellationToken%2A&gt;</ph> was marked for cancellation before the task started executing,</source>
          <target state="translated">Su <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskFactory.CancellationToken%2A&gt;</ph> se marcó para cancelación antes de que la tarea empezara a ejecutarse,</target>       </trans-unit>
        <trans-unit id="644" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Tasks.Task.IsCanceled">
          <source>The task acknowledged the cancellation request on its already signaled <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskFactory.CancellationToken%2A&gt;</ph> by throwing an <ph id="ph2">&lt;xref:System.OperationCanceledException&gt;</ph> that bears the same <ph id="ph3">&lt;xref:System.Threading.CancellationToken&gt;</ph>.</source>
          <target state="translated">La tarea confirmó la solicitud de cancelación en sus ya señalado <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskFactory.CancellationToken%2A&gt;</ph> iniciando una <ph id="ph2">&lt;xref:System.OperationCanceledException&gt;</ph> que lleva el mismo <ph id="ph3">&lt;xref:System.Threading.CancellationToken&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="645" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Tasks.Task.IsCanceled">
          <source>The task acknowledged the cancellation request on its already signaled <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskFactory.CancellationToken%2A&gt;</ph> by calling the <ph id="ph2">&lt;xref:System.Threading.CancellationToken.ThrowIfCancellationRequested%2A&gt;</ph> method on the <ph id="ph3">&lt;xref:System.Threading.CancellationToken&gt;</ph>.</source>
          <target state="translated">La tarea confirmó la solicitud de cancelación en sus ya señalado <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskFactory.CancellationToken%2A&gt;</ph> mediante una llamada a la <ph id="ph2">&lt;xref:System.Threading.CancellationToken.ThrowIfCancellationRequested%2A&gt;</ph> método en el <ph id="ph3">&lt;xref:System.Threading.CancellationToken&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="646" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Tasks.Task.IsCanceled">
          <source>Retrieving the value of the <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.IsCanceled%2A&gt;</ph> property does not block the calling thread until the task has completed.</source>
          <target state="translated">Recuperación del valor de la <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.IsCanceled%2A&gt;</ph> propiedad no bloquea el subproceso que realiza la llamada hasta que la tarea se ha completado.</target>       </trans-unit>
        <trans-unit id="647" translate="yes" xml:space="preserve" uid="P:System.Threading.Tasks.Task.IsCompleted">
          <source>Gets whether this <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> has completed.</source>
          <target state="translated">Obtiene un valor que indica si se ha completado esta instancia de <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="648" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Tasks.Task.IsCompleted">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the task has completed; otherwise <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">Es <ph id="ph1">&lt;see langword="true" /&gt;</ph> si la tarea se ha completado; de lo contrario, es <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="649" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Tasks.Task.IsCompleted">
          <source><ph id="ph1">&lt;xref:System.Threading.Tasks.Task.IsCompleted%2A&gt;</ph> will return <ph id="ph2">`true`</ph> when the task is in one of the three final states: <ph id="ph3">&lt;xref:System.Threading.Tasks.TaskStatus.RanToCompletion&gt;</ph>, <ph id="ph4">&lt;xref:System.Threading.Tasks.TaskStatus.Faulted&gt;</ph>, or <ph id="ph5">&lt;xref:System.Threading.Tasks.TaskStatus.Canceled&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Threading.Tasks.Task.IsCompleted%2A&gt;</ph> devolverá <ph id="ph2">`true`</ph> cuando la tarea está en uno de los tres estados finales: <ph id="ph3">&lt;xref:System.Threading.Tasks.TaskStatus.RanToCompletion&gt;</ph>, <ph id="ph4">&lt;xref:System.Threading.Tasks.TaskStatus.Faulted&gt;</ph>, o <ph id="ph5">&lt;xref:System.Threading.Tasks.TaskStatus.Canceled&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="650" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Tasks.Task.IsCompleted">
          <source>Retrieving the value of the <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.IsCompleted%2A?displayProperty=nameWithType&gt;</ph> property does not block the calling thread until the task has completed.</source>
          <target state="translated">Recuperación del valor de la <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.IsCompleted%2A?displayProperty=nameWithType&gt;</ph> propiedad no bloquea el subproceso que realiza la llamada hasta que la tarea se ha completado.</target>       </trans-unit>
        <trans-unit id="651" translate="yes" xml:space="preserve" uid="P:System.Threading.Tasks.Task.IsFaulted">
          <source>Gets whether the <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> completed due to an unhandled exception.</source>
          <target state="translated">Obtiene un valor que indica si el objeto <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> se ha completado debido a una excepción no controlada.</target>       </trans-unit>
        <trans-unit id="652" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Tasks.Task.IsFaulted">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the task has thrown an unhandled exception; otherwise <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">Es <ph id="ph1">&lt;see langword="true" /&gt;</ph> si la tarea ha producido una excepción no controlada; de lo contrario, es <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="653" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Tasks.Task.IsFaulted">
          <source>If <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.IsFaulted%2A&gt;</ph> is <ph id="ph2">`true`</ph>, the task's <ph id="ph3">&lt;xref:System.Threading.Tasks.Task.Status%2A&gt;</ph> is equal to <ph id="ph4">&lt;xref:System.Threading.Tasks.TaskStatus.Faulted&gt;</ph>, and its <ph id="ph5">&lt;xref:System.Threading.Tasks.Task.Exception%2A&gt;</ph> property will be non-null.</source>
          <target state="translated">Si <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.IsFaulted%2A&gt;</ph> es <ph id="ph2">`true`</ph>, la tarea <ph id="ph3">&lt;xref:System.Threading.Tasks.Task.Status%2A&gt;</ph> es igual a <ph id="ph4">&lt;xref:System.Threading.Tasks.TaskStatus.Faulted&gt;</ph>y su <ph id="ph5">&lt;xref:System.Threading.Tasks.Task.Exception%2A&gt;</ph> propiedad será distinto de null.</target>       </trans-unit>
        <trans-unit id="654" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Tasks.Task.IsFaulted">
          <source>Retrieving the value of the <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.IsFaulted%2A?displayProperty=nameWithType&gt;</ph> property does not block the calling thread until the task has completed.</source>
          <target state="translated">Recuperación del valor de la <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.IsFaulted%2A?displayProperty=nameWithType&gt;</ph> propiedad no bloquea el subproceso que realiza la llamada hasta que la tarea se ha completado.</target>       </trans-unit>
        <trans-unit id="655" translate="yes" xml:space="preserve" uid="T:System.Threading.Tasks.Task">
          <source>Queues the specified work to run on the ThreadPool and returns a task or <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task`1" /&gt;</ph> handle for that work.</source>
          <target state="translated">Pone en cola el trabajo especificado para ejecutarlo en ThreadPool y devuelve una tarea o controlador  <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task`1" /&gt;</ph> para dicho trabajo.</target>       </trans-unit>
        <trans-unit id="656" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.Task">
          <source>The <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Run%2A&gt;</ph> method provides a set of overloads that make it easy to start a task by using default values.</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Run%2A&gt;</ph> método proporciona un conjunto de sobrecargas que facilitan la tarea iniciar una tarea mediante el uso de valores predeterminados.</target>       </trans-unit>
        <trans-unit id="657" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.Tasks.Task">
          <source>It is a lightweight alternative to the <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskFactory.StartNew%2A&gt;</ph> overloads.</source>
          <target state="translated">Es una alternativa ligera a la <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskFactory.StartNew%2A&gt;</ph> sobrecargas.</target>       </trans-unit>
        <trans-unit id="658" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Run(System.Action)">
          <source>The work to execute asynchronously</source>
          <target state="translated">Trabajo que se va a ejecutar de forma asincrónica.</target>       </trans-unit>
        <trans-unit id="659" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Run(System.Action)">
          <source>Queues the specified work to run on the thread pool and returns a <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> object that represents that work.</source>
          <target state="translated">Pone en cola el trabajo especificado para ejecutarlo en el grupo de subprocesos y devuelve un objeto <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> que representa ese trabajo.</target>       </trans-unit>
        <trans-unit id="660" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Run(System.Action)">
          <source>A task that represents the work queued to execute in the ThreadPool.</source>
          <target state="translated">Tarea que representa el trabajo en cola para ejecutarse en ThreadPool.</target>       </trans-unit>
        <trans-unit id="661" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Run(System.Action)">
          <source>The <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Run%2A&gt;</ph> method allows you to create and execute a task in a single method call and is a simpler alternative to the <ph id="ph2">&lt;xref:System.Threading.Tasks.TaskFactory.StartNew%2A&gt;</ph> method.</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Run%2A&gt;</ph> método le permite crear y ejecutar una tarea en una única llamada al método y es una alternativa más sencilla a la <ph id="ph2">&lt;xref:System.Threading.Tasks.TaskFactory.StartNew%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="662" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Run(System.Action)">
          <source>It creates a task with the following default values:</source>
          <target state="translated">Crea una tarea con los valores predeterminados siguientes:</target>       </trans-unit>
        <trans-unit id="663" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Run(System.Action)">
          <source>Its cancellation token is <ph id="ph1">&lt;xref:System.Threading.CancellationToken.None%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Su token de cancelación es <ph id="ph1">&lt;xref:System.Threading.CancellationToken.None%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="664" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Run(System.Action)">
          <source>Its <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.CreationOptions%2A&gt;</ph> property value is <ph id="ph2">&lt;xref:System.Threading.Tasks.TaskCreationOptions.DenyChildAttach?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Su <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.CreationOptions%2A&gt;</ph> es el valor de la propiedad <ph id="ph2">&lt;xref:System.Threading.Tasks.TaskCreationOptions.DenyChildAttach?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="665" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Run(System.Action)">
          <source>It uses the default task scheduler.</source>
          <target state="translated">Usa al programador de tareas de forma predeterminada.</target>       </trans-unit>
        <trans-unit id="666" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Run(System.Action)">
          <source>For information on handling exceptions thrown by task operations, see <bpt id="p1">[</bpt>Exception Handling<ept id="p1">](~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md)</ept>.</source>
          <target state="translated">Para obtener información sobre cómo controlar las excepciones producidas por las operaciones de tareas, consulte <bpt id="p1">[</bpt>Exception Handling<ept id="p1">](~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md)</ept>.</target>       </trans-unit>
        <trans-unit id="667" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Run(System.Action)">
          <source>The following example defines a <ph id="ph1">`ShowThreadInfo`</ph> method  that displays the <ph id="ph2">&lt;xref:System.Threading.Thread.ManagedThreadId%2A?displayProperty=nameWithType&gt;</ph> of the current thread.</source>
          <target state="translated">En el ejemplo siguiente se define un <ph id="ph1">`ShowThreadInfo`</ph> método que muestra la <ph id="ph2">&lt;xref:System.Threading.Thread.ManagedThreadId%2A?displayProperty=nameWithType&gt;</ph> del subproceso actual.</target>       </trans-unit>
        <trans-unit id="668" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Run(System.Action)">
          <source>It is called directly from the application thread, and is called from the <ph id="ph1">&lt;xref:System.Action&gt;</ph> delegate passed to the <ph id="ph2">&lt;xref:System.Threading.Tasks.Task.Run%28System.Action%29&gt;</ph> method.</source>
          <target state="translated">Se denomina directamente desde el subproceso de la aplicación y se llama desde el <ph id="ph1">&lt;xref:System.Action&gt;</ph> delegado pasado a la <ph id="ph2">&lt;xref:System.Threading.Tasks.Task.Run%28System.Action%29&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="669" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Run(System.Action)">
          <source>The following example is similar to the previous one, except that it uses a lambda expression to define the code that the task is to execute.</source>
          <target state="translated">En el ejemplo siguiente es similar al anterior, salvo que usa una expresión lambda para definir el código ejecutar la tarea.</target>       </trans-unit>
        <trans-unit id="670" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Run(System.Action)">
          <source>The examples show that the asynchronous task executes on a different thread than the main application thread.</source>
          <target state="translated">Los ejemplos muestran que la tarea asincrónica se ejecuta en un subproceso distinto al subproceso de aplicación principal.</target>       </trans-unit>
        <trans-unit id="671" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Run(System.Action)">
          <source>The call to the <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Wait%2A&gt;</ph> method ensures that the task completes and displays its output before the application ends.</source>
          <target state="translated">La llamada a la <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Wait%2A&gt;</ph> método garantiza que la tarea se completa y muestra su salida antes de que la aplicación finalice.</target>       </trans-unit>
        <trans-unit id="672" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Run(System.Action)">
          <source>Otherwise, it is possible that the <ph id="ph1">`Main`</ph> method will complete before the task finishes.</source>
          <target state="translated">En caso contrario, es posible que el <ph id="ph1">`Main`</ph> método se completará antes de que finalice la tarea.</target>       </trans-unit>
        <trans-unit id="673" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Run(System.Action)">
          <source>The following example illustrates the <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Run%28System.Action%29&gt;</ph> method.</source>
          <target state="translated">En el ejemplo siguiente se muestra el <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Run%28System.Action%29&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="674" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Run(System.Action)">
          <source>It defines an array of directory names and starts a separate task to retrieve the file names in each directory.</source>
          <target state="translated">Define una matriz de nombres de directorio y se inicia una tarea independiente para recuperar los nombres de archivo en cada directorio.</target>       </trans-unit>
        <trans-unit id="675" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Run(System.Action)">
          <source>All tasks write the file names to a single <ph id="ph1">&lt;xref:System.Collections.Concurrent.ConcurrentBag%601&gt;</ph> object.</source>
          <target state="translated">Todas las tareas de escriban los nombres de archivo en una sola <ph id="ph1">&lt;xref:System.Collections.Concurrent.ConcurrentBag%601&gt;</ph> objeto.</target>       </trans-unit>
        <trans-unit id="676" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Run(System.Action)">
          <source>The example then calls the <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.WaitAll%28System.Threading.Tasks.Task%5B%5D%29&gt;</ph> method to ensure that all tasks have completed, and then displays a count of the total number of file names written to the <ph id="ph2">&lt;xref:System.Collections.Concurrent.ConcurrentBag%601&gt;</ph> object.</source>
          <target state="translated">El ejemplo, a continuación, se llama la <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.WaitAll%28System.Threading.Tasks.Task%5B%5D%29&gt;</ph> método para asegurarse de que ha completado todas las tareas y, a continuación, muestra un recuento del número total de nombres de archivo que se escriben en el <ph id="ph2">&lt;xref:System.Collections.Concurrent.ConcurrentBag%601&gt;</ph> objeto.</target>       </trans-unit>
        <trans-unit id="677" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Run(System.Action)">
          <source>The <ph id="ph1">&lt;paramref name="action" /&gt;</ph> parameter was <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">El parámetro <ph id="ph1">&lt;paramref name="action" /&gt;</ph> era <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="678" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Run(System.Func{System.Threading.Tasks.Task})">
          <source>The work to execute asynchronously</source>
          <target state="translated">Trabajo que se va a ejecutar de forma asincrónica.</target>       </trans-unit>
        <trans-unit id="679" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Run(System.Func{System.Threading.Tasks.Task})">
          <source>Queues the specified work to run on the thread pool and returns a proxy for the  task returned by <ph id="ph1">&lt;paramref name="function" /&gt;</ph>.</source>
          <target state="translated">Pone en cola el trabajo especificado para ejecutarlo en el grupo de subprocesos y devuelve un proxy para la tarea devuelta por <ph id="ph1">&lt;paramref name="function" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="680" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Run(System.Func{System.Threading.Tasks.Task})">
          <source>A task that represents a proxy for the task returned by <ph id="ph1">&lt;paramref name="function" /&gt;</ph>.</source>
          <target state="translated">Una tarea que representa un proxy para la tarea devuelta por <ph id="ph1">&lt;paramref name="function" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="681" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Run(System.Func{System.Threading.Tasks.Task})">
          <source>For information on handling exceptions thrown by task operations, see <bpt id="p1">[</bpt>Exception Handling<ept id="p1">](~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md)</ept>.</source>
          <target state="translated">Para obtener información sobre cómo controlar las excepciones producidas por las operaciones de tareas, consulte <bpt id="p1">[</bpt>Exception Handling<ept id="p1">](~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md)</ept>.</target>       </trans-unit>
        <trans-unit id="682" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Run(System.Func{System.Threading.Tasks.Task})">
          <source>The <ph id="ph1">&lt;paramref name="function" /&gt;</ph> parameter was <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">El parámetro <ph id="ph1">&lt;paramref name="function" /&gt;</ph> era <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="683" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Run(System.Action,System.Threading.CancellationToken)">
          <source>The work to execute asynchronously</source>
          <target state="translated">Trabajo que se va a ejecutar de forma asincrónica.</target>       </trans-unit>
        <trans-unit id="684" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Run(System.Action,System.Threading.CancellationToken)">
          <source>A cancellation token that can be used to cancel the work</source>
          <target state="translated">Token de cancelación que puede usarse para cancelar el trabajo.</target>       </trans-unit>
        <trans-unit id="685" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Run(System.Action,System.Threading.CancellationToken)">
          <source>Queues the specified work to run on the thread pool and returns a <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> object that represents that work.</source>
          <target state="translated">Pone en cola el trabajo especificado para ejecutarlo en el grupo de subprocesos y devuelve un objeto <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> que representa ese trabajo.</target>       </trans-unit>
        <trans-unit id="686" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Run(System.Action,System.Threading.CancellationToken)">
          <source>A cancellation token allows the work to be cancelled.</source>
          <target state="translated">Un token de cancelación permite cancelar el trabajo.</target>       </trans-unit>
        <trans-unit id="687" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Run(System.Action,System.Threading.CancellationToken)">
          <source>A task that represents the work queued to execute in the thread pool.</source>
          <target state="translated">Tarea que representa el trabajo en cola que se va a ejecutar en el grupo de subprocesos.</target>       </trans-unit>
        <trans-unit id="688" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Run(System.Action,System.Threading.CancellationToken)">
          <source>If cancellation is requested before the task begins execution, the task does not execute.</source>
          <target state="translated">Si se solicita la cancelación antes de que la tarea comienza a ejecutarse, la tarea no se ejecuta.</target>       </trans-unit>
        <trans-unit id="689" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Run(System.Action,System.Threading.CancellationToken)">
          <source>Instead it is set to the <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskStatus.Canceled&gt;</ph> state and throws a <ph id="ph2">&lt;xref:System.Threading.Tasks.TaskCanceledException&gt;</ph> exception.</source>
          <target state="translated">En su lugar, se establece en el <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskStatus.Canceled&gt;</ph> estado e inicia un <ph id="ph2">&lt;xref:System.Threading.Tasks.TaskCanceledException&gt;</ph> excepción.</target>       </trans-unit>
        <trans-unit id="690" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Run(System.Action,System.Threading.CancellationToken)">
          <source>The <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Run%28System.Action%2CSystem.Threading.CancellationToken%29&gt;</ph> method is a simpler alternative to the <ph id="ph2">&lt;xref:System.Threading.Tasks.TaskFactory.StartNew%28System.Action%2CSystem.Threading.CancellationToken%29?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Run%28System.Action%2CSystem.Threading.CancellationToken%29&gt;</ph> método es una alternativa más sencilla a la <ph id="ph2">&lt;xref:System.Threading.Tasks.TaskFactory.StartNew%28System.Action%2CSystem.Threading.CancellationToken%29?displayProperty=nameWithType&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="691" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Run(System.Action,System.Threading.CancellationToken)">
          <source>It creates a task with the following default values:</source>
          <target state="translated">Crea una tarea con los valores predeterminados siguientes:</target>       </trans-unit>
        <trans-unit id="692" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Run(System.Action,System.Threading.CancellationToken)">
          <source>Its <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.CreationOptions%2A&gt;</ph> property value is <ph id="ph2">&lt;xref:System.Threading.Tasks.TaskCreationOptions.DenyChildAttach?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Su <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.CreationOptions%2A&gt;</ph> es el valor de la propiedad <ph id="ph2">&lt;xref:System.Threading.Tasks.TaskCreationOptions.DenyChildAttach?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="693" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Run(System.Action,System.Threading.CancellationToken)">
          <source>It uses the default task scheduler.</source>
          <target state="translated">Usa al programador de tareas de forma predeterminada.</target>       </trans-unit>
        <trans-unit id="694" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Run(System.Action,System.Threading.CancellationToken)">
          <source>For information on handling exceptions thrown by task operations, see <bpt id="p1">[</bpt>Exception Handling<ept id="p1">](~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md)</ept>.</source>
          <target state="translated">Para obtener información sobre cómo controlar las excepciones producidas por las operaciones de tareas, consulte <bpt id="p1">[</bpt>Exception Handling<ept id="p1">](~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md)</ept>.</target>       </trans-unit>
        <trans-unit id="695" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Run(System.Action,System.Threading.CancellationToken)">
          <source>The following example calls the <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Run%28System.Action%2CSystem.Threading.CancellationToken%29&gt;</ph> method to create a task that iterates the files in the C:\Windows\System32 directory.</source>
          <target state="translated">El ejemplo siguiente se llama el <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Run%28System.Action%2CSystem.Threading.CancellationToken%29&gt;</ph> método para crear una tarea que recorre en iteración los archivos en el directorio C:\Windows\System32.</target>       </trans-unit>
        <trans-unit id="696" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Run(System.Action,System.Threading.CancellationToken)">
          <source>The lambda expression calls the <ph id="ph1">&lt;xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType&gt;</ph> method to add information about each  file to a <ph id="ph2">&lt;xref:System.Collections.Generic.List%601&gt;</ph> object.</source>
          <target state="translated">La expresión lambda llama el <ph id="ph1">&lt;xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType&gt;</ph> método para agregar información sobre todos los archivos en un <ph id="ph2">&lt;xref:System.Collections.Generic.List%601&gt;</ph> objeto.</target>       </trans-unit>
        <trans-unit id="697" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Run(System.Action,System.Threading.CancellationToken)">
          <source>Each detached nested task invoked by the <ph id="ph1">&lt;xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType&gt;</ph> loop checks the state of the cancellation token and, if cancellation is requested, calls the <ph id="ph2">&lt;xref:System.Threading.CancellationToken.ThrowIfCancellationRequested%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">Cada tarea anidada invocado por desasociada el <ph id="ph1">&lt;xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType&gt;</ph> bucle comprueba el estado del token de cancelación y, si se solicita la cancelación, llama a la <ph id="ph2">&lt;xref:System.Threading.CancellationToken.ThrowIfCancellationRequested%2A?displayProperty=nameWithType&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="698" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Run(System.Action,System.Threading.CancellationToken)">
          <source>The <ph id="ph1">&lt;xref:System.Threading.CancellationToken.ThrowIfCancellationRequested%2A?displayProperty=nameWithType&gt;</ph> method throws an <ph id="ph2">&lt;xref:System.OperationCanceledException&gt;</ph> exception that is handled in a <ph id="ph3">`catch`</ph> block when the calling thread calls the <ph id="ph4">&lt;xref:System.Threading.Tasks.Task.Wait%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.Threading.CancellationToken.ThrowIfCancellationRequested%2A?displayProperty=nameWithType&gt;</ph> método inicie una excepción un <ph id="ph2">&lt;xref:System.OperationCanceledException&gt;</ph> excepción que se controla en un <ph id="ph3">`catch`</ph> bloquear cuando el subproceso que realiza la llamada llama la <ph id="ph4">&lt;xref:System.Threading.Tasks.Task.Wait%2A?displayProperty=nameWithType&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="699" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Run(System.Action,System.Threading.CancellationToken)">
          <source>The <ph id="ph1">&lt;paramref name="action" /&gt;</ph> parameter was <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">El parámetro <ph id="ph1">&lt;paramref name="action" /&gt;</ph> era <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="700" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Run(System.Action,System.Threading.CancellationToken)">
          <source>The task has been canceled.</source>
          <target state="translated">La tarea se canceló.</target>       </trans-unit>
        <trans-unit id="701" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Run(System.Action,System.Threading.CancellationToken)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Threading.CancellationTokenSource" /&gt;</ph> associated with <ph id="ph2">&lt;paramref name="cancellationToken" /&gt;</ph> was disposed.</source>
          <target state="translated">Se eliminó el <ph id="ph1">&lt;see cref="T:System.Threading.CancellationTokenSource" /&gt;</ph> asociado a <ph id="ph2">&lt;paramref name="cancellationToken" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="702" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Run(System.Func{System.Threading.Tasks.Task},System.Threading.CancellationToken)">
          <source>The work to execute asynchronously.</source>
          <target state="translated">El trabajo que se ejecutará de forma asincrónica.</target>       </trans-unit>
        <trans-unit id="703" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Run(System.Func{System.Threading.Tasks.Task},System.Threading.CancellationToken)">
          <source>A cancellation token that should be used to cancel the work.</source>
          <target state="translated">Un token de cancelación que debería usarse para cancelar el trabajo.</target>       </trans-unit>
        <trans-unit id="704" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Run(System.Func{System.Threading.Tasks.Task},System.Threading.CancellationToken)">
          <source>Queues the specified work to run on the thread pool and returns a proxy for the task returned by <ph id="ph1">&lt;paramref name="function" /&gt;</ph>.</source>
          <target state="translated">Pone en cola el trabajo especificado para ejecutarlo en el grupo de subprocesos y devuelve un proxy para la tarea devuelta por <ph id="ph1">&lt;paramref name="function" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="705" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Run(System.Func{System.Threading.Tasks.Task},System.Threading.CancellationToken)">
          <source>A task that represents a proxy for the task returned by <ph id="ph1">&lt;paramref name="function" /&gt;</ph>.</source>
          <target state="translated">Una tarea que representa un proxy para la tarea devuelta por <ph id="ph1">&lt;paramref name="function" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="706" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Run(System.Func{System.Threading.Tasks.Task},System.Threading.CancellationToken)">
          <source>For information on handling exceptions thrown by task operations, see <bpt id="p1">[</bpt>Exception Handling<ept id="p1">](~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md)</ept>.</source>
          <target state="translated">Para obtener información sobre cómo controlar las excepciones producidas por las operaciones de tareas, consulte <bpt id="p1">[</bpt>Exception Handling<ept id="p1">](~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md)</ept>.</target>       </trans-unit>
        <trans-unit id="707" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Run(System.Func{System.Threading.Tasks.Task},System.Threading.CancellationToken)">
          <source>The <ph id="ph1">&lt;paramref name="function" /&gt;</ph> parameter was <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">El parámetro <ph id="ph1">&lt;paramref name="function" /&gt;</ph> era <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="708" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Run(System.Func{System.Threading.Tasks.Task},System.Threading.CancellationToken)">
          <source>The task has been canceled.</source>
          <target state="translated">La tarea se canceló.</target>       </trans-unit>
        <trans-unit id="709" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Run(System.Func{System.Threading.Tasks.Task},System.Threading.CancellationToken)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Threading.CancellationTokenSource" /&gt;</ph> associated with <ph id="ph2">&lt;paramref name="cancellationToken" /&gt;</ph> was disposed.</source>
          <target state="translated">Se eliminó el <ph id="ph1">&lt;see cref="T:System.Threading.CancellationTokenSource" /&gt;</ph> asociado a <ph id="ph2">&lt;paramref name="cancellationToken" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="710" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Run``1(System.Func{System.Threading.Tasks.Task{``0}})">
          <source>The type of the result returned by the proxy task.</source>
          <target state="translated">Tipo de resultado devuelto por la tarea del proxy.</target>       </trans-unit>
        <trans-unit id="711" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Run``1(System.Func{System.Threading.Tasks.Task{``0}})">
          <source>The work to execute asynchronously</source>
          <target state="translated">Trabajo que se va a ejecutar de forma asincrónica.</target>       </trans-unit>
        <trans-unit id="712" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Run``1(System.Func{System.Threading.Tasks.Task{``0}})">
          <source>Queues the specified work to run on the thread pool and returns a proxy for the <ph id="ph1">&lt;see langword="Task(TResult)" /&gt;</ph> returned by <ph id="ph2">&lt;paramref name="function" /&gt;</ph>.</source>
          <target state="translated">Pone en cola el trabajo especificado para ejecutarlo en el grupo de subprocesos y devuelve un proxy para <ph id="ph1">&lt;see langword="Task(TResult)" /&gt;</ph> que devuelve <ph id="ph2">&lt;paramref name="function" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="713" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Run``1(System.Func{System.Threading.Tasks.Task{``0}})">
          <source>A <ph id="ph1">&lt;see langword="Task(TResult)" /&gt;</ph> that represents a proxy for the <ph id="ph2">&lt;see langword="Task(TResult)" /&gt;</ph> returned by <ph id="ph3">&lt;paramref name="function" /&gt;</ph>.</source>
          <target state="translated">Una <ph id="ph1">&lt;see langword="Task(TResult)" /&gt;</ph> que representa un proxy para <ph id="ph2">&lt;see langword="Task(TResult)" /&gt;</ph> devuelta por <ph id="ph3">&lt;paramref name="function" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="714" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Run``1(System.Func{System.Threading.Tasks.Task{``0}})">
          <source>For information on handling exceptions thrown by task operations, see <bpt id="p1">[</bpt>Exception Handling<ept id="p1">](~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md)</ept>.</source>
          <target state="translated">Para obtener información sobre cómo controlar las excepciones producidas por las operaciones de tareas, consulte <bpt id="p1">[</bpt>Exception Handling<ept id="p1">](~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md)</ept>.</target>       </trans-unit>
        <trans-unit id="715" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Run``1(System.Func{System.Threading.Tasks.Task{``0}})">
          <source>The <ph id="ph1">&lt;paramref name="function" /&gt;</ph> parameter was <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">El parámetro <ph id="ph1">&lt;paramref name="function" /&gt;</ph> era <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="716" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Run``1(System.Func{``0})">
          <source>The return type of the task.</source>
          <target state="translated">El tipo devuelto de la tarea.</target>       </trans-unit>
        <trans-unit id="717" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Run``1(System.Func{``0})">
          <source>The work to execute asynchronously.</source>
          <target state="translated">El trabajo que se ejecutará de forma asincrónica.</target>       </trans-unit>
        <trans-unit id="718" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Run``1(System.Func{``0})">
          <source>Queues the specified work to run on the thread pool and returns a <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task`1" /&gt;</ph> object that represents that work.</source>
          <target state="translated">Pone en cola el trabajo especificado para ejecutarlo en el grupo de subprocesos y devuelve un objeto <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task`1" /&gt;</ph> que representa ese trabajo.</target>       </trans-unit>
        <trans-unit id="719" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Run``1(System.Func{``0})">
          <source>A task object that represents the work queued to execute in the thread pool.</source>
          <target state="translated">Un objeto de tarea que representa el trabajo en cola para ejecutarse en el grupo de subprocesos.</target>       </trans-unit>
        <trans-unit id="720" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Run``1(System.Func{``0})">
          <source>The <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Run%2A&gt;</ph> method is a simpler alternative to the <ph id="ph2">&lt;xref:System.Threading.Tasks.TaskFactory.StartNew%28System.Action%29?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Run%2A&gt;</ph> método es una alternativa más sencilla a la <ph id="ph2">&lt;xref:System.Threading.Tasks.TaskFactory.StartNew%28System.Action%29?displayProperty=nameWithType&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="721" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Run``1(System.Func{``0})">
          <source>It creates a task with the following default values:</source>
          <target state="translated">Crea una tarea con los valores predeterminados siguientes:</target>       </trans-unit>
        <trans-unit id="722" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Run``1(System.Func{``0})">
          <source>Its cancellation token is <ph id="ph1">&lt;xref:System.Threading.CancellationToken.None%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Su token de cancelación es <ph id="ph1">&lt;xref:System.Threading.CancellationToken.None%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="723" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Run``1(System.Func{``0})">
          <source>Its <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.CreationOptions%2A&gt;</ph> property value is <ph id="ph2">&lt;xref:System.Threading.Tasks.TaskCreationOptions.DenyChildAttach?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Su <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.CreationOptions%2A&gt;</ph> es el valor de la propiedad <ph id="ph2">&lt;xref:System.Threading.Tasks.TaskCreationOptions.DenyChildAttach?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="724" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Run``1(System.Func{``0})">
          <source>It uses the default task scheduler.</source>
          <target state="translated">Usa al programador de tareas de forma predeterminada.</target>       </trans-unit>
        <trans-unit id="725" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Run``1(System.Func{``0})">
          <source>For information on handling exceptions thrown by task operations, see <bpt id="p1">[</bpt>Exception Handling<ept id="p1">](~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md)</ept>.</source>
          <target state="translated">Para obtener información sobre cómo controlar las excepciones producidas por las operaciones de tareas, consulte <bpt id="p1">[</bpt>Exception Handling<ept id="p1">](~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md)</ept>.</target>       </trans-unit>
        <trans-unit id="726" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Run``1(System.Func{``0})">
          <source>The following example counts the approximate number of words in text files that represent published books.</source>
          <target state="translated">El ejemplo siguiente cuenta el número aproximado de palabras en los archivos de texto que representan libros publicados.</target>       </trans-unit>
        <trans-unit id="727" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Run``1(System.Func{``0})">
          <source>Each task is responsible for opening a file, reading its entire contents asynchronously, and calculating the word count by using a regular expression.</source>
          <target state="translated">Cada tarea es responsable de abrir un archivo, leer todo su contenido de forma asincrónica y calcular el recuento de palabras, mediante una expresión regular.</target>       </trans-unit>
        <trans-unit id="728" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Run``1(System.Func{``0})">
          <source>The <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.WaitAll%28System.Threading.Tasks.Task%5B%5D%29&gt;</ph> method is called to ensure that all tasks have completed before  displaying the word count of each book to the console.</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.WaitAll%28System.Threading.Tasks.Task%5B%5D%29&gt;</ph> método se llama para asegurarse de que todas las tareas se han completado antes de mostrar el número de palabras de cada libro en la consola.</target>       </trans-unit>
        <trans-unit id="729" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Run``1(System.Func{``0})">
          <source>The regular expression <ph id="ph1">`\p{P}*\s+`</ph> matches zero, one, or more punctuation characters followed by one or more whitespace characters.</source>
          <target state="translated">La expresión regular <ph id="ph1">`\p{P}*\s+`</ph> coincide con cero, uno o más caracteres de puntuación, seguidos de uno o más caracteres de espacio en blanco.</target>       </trans-unit>
        <trans-unit id="730" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Run``1(System.Func{``0})">
          <source>It assumes that the total number of matches equals the approximate word count.</source>
          <target state="translated">Se supone que el número total de coincidencias es igual que el recuento de palabras aproximado.</target>       </trans-unit>
        <trans-unit id="731" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Run``1(System.Func{``0})">
          <source>The <ph id="ph1">&lt;paramref name="function" /&gt;</ph> parameter is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">El parámetro <ph id="ph1">&lt;paramref name="function" /&gt;</ph> es <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="732" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Run``1(System.Func{System.Threading.Tasks.Task{``0}},System.Threading.CancellationToken)">
          <source>The type of the result returned by the proxy task.</source>
          <target state="translated">Tipo de resultado devuelto por la tarea del proxy.</target>       </trans-unit>
        <trans-unit id="733" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Run``1(System.Func{System.Threading.Tasks.Task{``0}},System.Threading.CancellationToken)">
          <source>The work to execute asynchronously</source>
          <target state="translated">Trabajo que se va a ejecutar de forma asincrónica.</target>       </trans-unit>
        <trans-unit id="734" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Run``1(System.Func{System.Threading.Tasks.Task{``0}},System.Threading.CancellationToken)">
          <source>A cancellation token that should be used to cancel the work</source>
          <target state="translated">Token de cancelación que se debe usar para cancelar el trabajo.</target>       </trans-unit>
        <trans-unit id="735" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Run``1(System.Func{System.Threading.Tasks.Task{``0}},System.Threading.CancellationToken)">
          <source>Queues the specified work to run on the thread pool and returns a proxy for the <ph id="ph1">&lt;see langword="Task(TResult)" /&gt;</ph> returned by <ph id="ph2">&lt;paramref name="function" /&gt;</ph>.</source>
          <target state="translated">Pone en cola el trabajo especificado para ejecutarlo en el grupo de subprocesos y devuelve un proxy para <ph id="ph1">&lt;see langword="Task(TResult)" /&gt;</ph> que devuelve <ph id="ph2">&lt;paramref name="function" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="736" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Run``1(System.Func{System.Threading.Tasks.Task{``0}},System.Threading.CancellationToken)">
          <source>A <ph id="ph1">&lt;see langword="Task(TResult)" /&gt;</ph> that represents a proxy for the <ph id="ph2">&lt;see langword="Task(TResult)" /&gt;</ph> returned by <ph id="ph3">&lt;paramref name="function" /&gt;</ph>.</source>
          <target state="translated">Una <ph id="ph1">&lt;see langword="Task(TResult)" /&gt;</ph> que representa un proxy para <ph id="ph2">&lt;see langword="Task(TResult)" /&gt;</ph> devuelta por <ph id="ph3">&lt;paramref name="function" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="737" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Run``1(System.Func{System.Threading.Tasks.Task{``0}},System.Threading.CancellationToken)">
          <source>For information on handling exceptions thrown by task operations, see <bpt id="p1">[</bpt>Exception Handling<ept id="p1">](~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md)</ept>.</source>
          <target state="translated">Para obtener información sobre cómo controlar las excepciones producidas por las operaciones de tareas, consulte <bpt id="p1">[</bpt>Exception Handling<ept id="p1">](~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md)</ept>.</target>       </trans-unit>
        <trans-unit id="738" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Run``1(System.Func{System.Threading.Tasks.Task{``0}},System.Threading.CancellationToken)">
          <source>The <ph id="ph1">&lt;paramref name="function" /&gt;</ph> parameter was <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">El parámetro <ph id="ph1">&lt;paramref name="function" /&gt;</ph> era <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="739" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Run``1(System.Func{System.Threading.Tasks.Task{``0}},System.Threading.CancellationToken)">
          <source>The task has been canceled.</source>
          <target state="translated">La tarea se canceló.</target>       </trans-unit>
        <trans-unit id="740" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Run``1(System.Func{System.Threading.Tasks.Task{``0}},System.Threading.CancellationToken)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Threading.CancellationTokenSource" /&gt;</ph> associated with <ph id="ph2">&lt;paramref name="cancellationToken" /&gt;</ph> was disposed.</source>
          <target state="translated">Se eliminó el <ph id="ph1">&lt;see cref="T:System.Threading.CancellationTokenSource" /&gt;</ph> asociado a <ph id="ph2">&lt;paramref name="cancellationToken" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="741" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Run``1(System.Func{``0},System.Threading.CancellationToken)">
          <source>The result type of the task.</source>
          <target state="translated">Tipo de resultado de la tarea.</target>       </trans-unit>
        <trans-unit id="742" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Run``1(System.Func{``0},System.Threading.CancellationToken)">
          <source>The work to execute asynchronously</source>
          <target state="translated">Trabajo que se va a ejecutar de forma asincrónica.</target>       </trans-unit>
        <trans-unit id="743" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Run``1(System.Func{``0},System.Threading.CancellationToken)">
          <source>A cancellation token that should be used to cancel the work</source>
          <target state="translated">Token de cancelación que se debe usar para cancelar el trabajo.</target>       </trans-unit>
        <trans-unit id="744" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Run``1(System.Func{``0},System.Threading.CancellationToken)">
          <source>Queues the specified work to run on the thread pool and returns a <ph id="ph1">&lt;see langword="Task(TResult)" /&gt;</ph> object that represents that work.</source>
          <target state="translated">Pone en cola el trabajo especificado para ejecutarlo en el grupo de subprocesos y devuelve un objeto <ph id="ph1">&lt;see langword="Task(TResult)" /&gt;</ph> que representa ese trabajo.</target>       </trans-unit>
        <trans-unit id="745" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Run``1(System.Func{``0},System.Threading.CancellationToken)">
          <source>A cancellation token allows the work to be cancelled.</source>
          <target state="translated">Un token de cancelación permite cancelar el trabajo.</target>       </trans-unit>
        <trans-unit id="746" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Run``1(System.Func{``0},System.Threading.CancellationToken)">
          <source>A <ph id="ph1">&lt;see langword="Task(TResult)" /&gt;</ph> that represents the work queued to execute in the thread pool.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="Task(TResult)" /&gt;</ph> que representa el trabajo en cola que se va a ejecutar en el grupo de subprocesos.</target>       </trans-unit>
        <trans-unit id="747" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Run``1(System.Func{``0},System.Threading.CancellationToken)">
          <source>If cancellation is requested before the task begins execution, the task does not execute.</source>
          <target state="translated">Si se solicita la cancelación antes de que la tarea comienza a ejecutarse, la tarea no se ejecuta.</target>       </trans-unit>
        <trans-unit id="748" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Run``1(System.Func{``0},System.Threading.CancellationToken)">
          <source>Instead it is set to the <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskStatus.Canceled&gt;</ph> state and throws a <ph id="ph2">&lt;xref:System.Threading.Tasks.TaskCanceledException&gt;</ph> exception.</source>
          <target state="translated">En su lugar, se establece en el <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskStatus.Canceled&gt;</ph> estado e inicia un <ph id="ph2">&lt;xref:System.Threading.Tasks.TaskCanceledException&gt;</ph> excepción.</target>       </trans-unit>
        <trans-unit id="749" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Run``1(System.Func{``0},System.Threading.CancellationToken)">
          <source>The <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Run%2A&gt;</ph> method is a simpler alternative to the <ph id="ph2">&lt;xref:System.Threading.Tasks.TaskFactory.StartNew%2A&gt;</ph> method.</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Run%2A&gt;</ph> método es una alternativa más sencilla a la <ph id="ph2">&lt;xref:System.Threading.Tasks.TaskFactory.StartNew%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="750" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Run``1(System.Func{``0},System.Threading.CancellationToken)">
          <source>It creates a task with the following default values:</source>
          <target state="translated">Crea una tarea con los valores predeterminados siguientes:</target>       </trans-unit>
        <trans-unit id="751" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Run``1(System.Func{``0},System.Threading.CancellationToken)">
          <source>Its <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.CreationOptions%2A&gt;</ph> property value is <ph id="ph2">&lt;xref:System.Threading.Tasks.TaskCreationOptions.DenyChildAttach?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Su <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.CreationOptions%2A&gt;</ph> es el valor de la propiedad <ph id="ph2">&lt;xref:System.Threading.Tasks.TaskCreationOptions.DenyChildAttach?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="752" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Run``1(System.Func{``0},System.Threading.CancellationToken)">
          <source>It uses the default task scheduler.</source>
          <target state="translated">Usa al programador de tareas de forma predeterminada.</target>       </trans-unit>
        <trans-unit id="753" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Run``1(System.Func{``0},System.Threading.CancellationToken)">
          <source>For information on handling exceptions thrown by task operations, see <bpt id="p1">[</bpt>Exception Handling<ept id="p1">](~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md)</ept>.</source>
          <target state="translated">Para obtener información sobre cómo controlar las excepciones producidas por las operaciones de tareas, consulte <bpt id="p1">[</bpt>Exception Handling<ept id="p1">](~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md)</ept>.</target>       </trans-unit>
        <trans-unit id="754" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Run``1(System.Func{``0},System.Threading.CancellationToken)">
          <source>The following example creates 20 tasks that will loop until a counter is incremented to a value of 2 million.</source>
          <target state="translated">En el ejemplo siguiente se crea 20 tareas que genere un bucle hasta que se incrementa un contador con un valor de 2 millones.</target>       </trans-unit>
        <trans-unit id="755" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Run``1(System.Func{``0},System.Threading.CancellationToken)">
          <source>When the first 10 tasks reach 2 million, the cancellation token is cancelled, and any tasks whose counters have not reached 2 million are cancelled.</source>
          <target state="translated">Cuando las 10 primeras tareas alcancen 2 millones, el token de cancelación se cancela y se cancelan todas las tareas cuyos contadores no hayan alcanzado 2 millones.</target>       </trans-unit>
        <trans-unit id="756" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Run``1(System.Func{``0},System.Threading.CancellationToken)">
          <source>The example shows possible output.</source>
          <target state="translated">El ejemplo muestra los resultados posibles.</target>       </trans-unit>
        <trans-unit id="757" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Run``1(System.Func{``0},System.Threading.CancellationToken)">
          <source>Instead of using the <ph id="ph1">&lt;xref:System.AggregateException.InnerExceptions%2A&gt;</ph> property to   examine exceptions, the example iterates all tasks to determine which have completed successfully and which have been cancelled.</source>
          <target state="translated">En lugar de utilizar el <ph id="ph1">&lt;xref:System.AggregateException.InnerExceptions%2A&gt;</ph> propiedad para examinar las excepciones, el ejemplo recorre en iteración todas las tareas para determinar que se han completado correctamente y que se han cancelado.</target>       </trans-unit>
        <trans-unit id="758" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Run``1(System.Func{``0},System.Threading.CancellationToken)">
          <source>For those that have completed, it displays the value returned by the task.</source>
          <target state="translated">Para los que se ha completado, muestra el valor devuelto por la tarea.</target>       </trans-unit>
        <trans-unit id="759" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Run``1(System.Func{``0},System.Threading.CancellationToken)">
          <source>Because cancellation is cooperative, each task can decide how to respond to cancellation.</source>
          <target state="translated">Dado que la cancelación es cooperativa, cada tarea puede decidir cómo responder a la cancelación.</target>       </trans-unit>
        <trans-unit id="760" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Run``1(System.Func{``0},System.Threading.CancellationToken)">
          <source>The following example is like the first, except that, once the token is cancelled, tasks return the number of iterations they've completed rather than throw an exception.</source>
          <target state="translated">El ejemplo siguiente es parecida a la primera, salvo que, cuando se cancela el token, tareas devuelven el número de iteraciones que han completado en lugar de producirán una excepción.</target>       </trans-unit>
        <trans-unit id="761" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Run``1(System.Func{``0},System.Threading.CancellationToken)">
          <source>The example still must handle the <ph id="ph1">&lt;xref:System.AggregateException&gt;</ph> exception,   since any tasks that have not started when cancellation is requested still throw an exception.</source>
          <target state="translated">El ejemplo todavía debe controlar la <ph id="ph1">&lt;xref:System.AggregateException&gt;</ph> excepción, ya que las tareas que no han iniciado cuando se solicita la cancelación todavía producen una excepción.</target>       </trans-unit>
        <trans-unit id="762" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Run``1(System.Func{``0},System.Threading.CancellationToken)">
          <source>The <ph id="ph1">&lt;paramref name="function" /&gt;</ph> parameter is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">El parámetro <ph id="ph1">&lt;paramref name="function" /&gt;</ph> es <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="763" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Run``1(System.Func{``0},System.Threading.CancellationToken)">
          <source>The task has been canceled.</source>
          <target state="translated">La tarea se canceló.</target>       </trans-unit>
        <trans-unit id="764" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Run``1(System.Func{``0},System.Threading.CancellationToken)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Threading.CancellationTokenSource" /&gt;</ph> associated with <ph id="ph2">&lt;paramref name="cancellationToken" /&gt;</ph> was disposed.</source>
          <target state="translated">Se eliminó el <ph id="ph1">&lt;see cref="T:System.Threading.CancellationTokenSource" /&gt;</ph> asociado a <ph id="ph2">&lt;paramref name="cancellationToken" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="765" translate="yes" xml:space="preserve" uid="T:System.Threading.Tasks.Task">
          <source>Runs the <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> synchronously on the current <ph id="ph2">&lt;see cref="T:System.Threading.Tasks.TaskScheduler" /&gt;</ph>.</source>
          <target state="translated">Ejecuta sincrónicamente el objeto <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> en el objeto <ph id="ph2">&lt;see cref="T:System.Threading.Tasks.TaskScheduler" /&gt;</ph> actual.</target>       </trans-unit>
        <trans-unit id="766" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.RunSynchronously">
          <source>Runs the <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> synchronously on the current <ph id="ph2">&lt;see cref="T:System.Threading.Tasks.TaskScheduler" /&gt;</ph>.</source>
          <target state="translated">Ejecuta sincrónicamente el objeto <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> en el objeto <ph id="ph2">&lt;see cref="T:System.Threading.Tasks.TaskScheduler" /&gt;</ph> actual.</target>       </trans-unit>
        <trans-unit id="767" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.RunSynchronously">
          <source>Ordinarily, tasks are executed asynchronously on a thread pool thread and do not block the calling thread.</source>
          <target state="translated">Por lo general, las tareas se ejecutan de forma asincrónica en un subproceso del grupo y no bloquean el subproceso que realiza la llamada.</target>       </trans-unit>
        <trans-unit id="768" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.RunSynchronously">
          <source>Tasks executed by calling the <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.RunSynchronously&gt;</ph> method are associated with the current <ph id="ph2">&lt;xref:System.Threading.Tasks.TaskScheduler&gt;</ph> and are run on the calling thread.</source>
          <target state="translated">Las tareas ejecutadas mediante una llamada a la <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.RunSynchronously&gt;</ph> están asociados con el actual método <ph id="ph2">&lt;xref:System.Threading.Tasks.TaskScheduler&gt;</ph> y se ejecutan en el subproceso que realiza la llamada.</target>       </trans-unit>
        <trans-unit id="769" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.RunSynchronously">
          <source>If the target scheduler does not support running this task on the calling thread, the task will be scheduled for execution on the scheduler, and the calling thread will block until the task has completed execution.</source>
          <target state="translated">Si el programador de destino no admite la ejecución de esta tarea en el subproceso que realiza la llamada, la tarea se programará para su ejecución en el programador y el subproceso que realiza la llamada se bloqueará hasta que la tarea ha completado su ejecución.</target>       </trans-unit>
        <trans-unit id="770" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.RunSynchronously">
          <source>Even though the task runs synchronously, the calling thread should still call <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Wait%2A&gt;</ph> to handle any exceptions that the task might throw.</source>
          <target state="translated">Aunque la tarea se ejecuta de forma sincrónica, el subproceso que realiza la llamada debe seguir llamando a <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Wait%2A&gt;</ph> para controlar las excepciones que puede iniciar la tarea.</target>       </trans-unit>
        <trans-unit id="771" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.RunSynchronously">
          <source>For more information on exception handling, see <bpt id="p1">[</bpt>Exception Handling<ept id="p1">](~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md)</ept>.</source>
          <target state="translated">Para obtener más información sobre el control de excepciones, vea <bpt id="p1">[</bpt>Exception Handling<ept id="p1">](~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md)</ept>.</target>       </trans-unit>
        <trans-unit id="772" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.RunSynchronously">
          <source>Tasks executed by calling the <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.RunSynchronously%2A&gt;</ph> method are instantiated by calling a <ph id="ph2">&lt;xref:System.Threading.Tasks.Task&gt;</ph> or <ph id="ph3">&lt;xref:System.Threading.Tasks.Task%601&gt;</ph> class constructor.</source>
          <target state="translated">Las tareas ejecutadas mediante una llamada a la <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.RunSynchronously%2A&gt;</ph> se crea una instancia de método mediante una llamada a un <ph id="ph2">&lt;xref:System.Threading.Tasks.Task&gt;</ph> o <ph id="ph3">&lt;xref:System.Threading.Tasks.Task%601&gt;</ph> constructor de clase.</target>       </trans-unit>
        <trans-unit id="773" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.RunSynchronously">
          <source>The task to be run synchronously must be in the <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskStatus.Created&gt;</ph> state.</source>
          <target state="translated">La tarea se ejecute sincrónicamente debe estar en el <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskStatus.Created&gt;</ph> estado.</target>       </trans-unit>
        <trans-unit id="774" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.RunSynchronously">
          <source>A task may be started and run only once.</source>
          <target state="translated">Una tarea se puede iniciar y ejecutar una sola vez.</target>       </trans-unit>
        <trans-unit id="775" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.RunSynchronously">
          <source>Any attempts to schedule a task a second time results in an exception.</source>
          <target state="translated">Cualquier intento para programar una tarea de un segundo tiempo da como resultado una excepción.</target>       </trans-unit>
        <trans-unit id="776" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.RunSynchronously">
          <source>The following example compares a task executed by calling the <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.RunSynchronously%2A&gt;</ph> method with one executed asynchronously.</source>
          <target state="translated">El ejemplo siguiente compara una tarea que se ejecuta mediante una llamada a la <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.RunSynchronously%2A&gt;</ph> método con una ejecución asincrónica.</target>       </trans-unit>
        <trans-unit id="777" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.RunSynchronously">
          <source>In both cases, the tasks execute identical lambda expressions that display the task ID and the ID of the thread on which the task is running.</source>
          <target state="translated">En ambos casos, las tareas ejecutan expresiones de lambda idénticos que muestran el identificador de tarea y el identificador del subproceso en el que se ejecuta la tarea.</target>       </trans-unit>
        <trans-unit id="778" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.RunSynchronously">
          <source>The task calculates the sum of the integers between 1 and 1,000,000.</source>
          <target state="translated">La tarea calcula la suma de los enteros entre 1 y 1.000.000.</target>       </trans-unit>
        <trans-unit id="779" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.RunSynchronously">
          <source>As the output from the example shows, the task executed by calling the <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.RunSynchronously%2A&gt;</ph> method runs on the application thread, while the asynchronous task does not.</source>
          <target state="translated">Como se muestra en el resultado del ejemplo, la tarea se ejecuta mediante una llamada a la <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.RunSynchronously%2A&gt;</ph> método se ejecuta en el subproceso de la aplicación, mientras que la tarea asincrónica no.</target>       </trans-unit>
        <trans-unit id="780" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.RunSynchronously">
          <source>The <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> instance has been disposed.</source>
          <target state="translated">Se eliminó la instancia de <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="781" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.RunSynchronously">
          <source>The <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> is not in a valid state to be started.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> no se encuentra en un estado válido para iniciarse.</target>       </trans-unit>
        <trans-unit id="782" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.RunSynchronously">
          <source>It may have already been started, executed, or canceled, or it may have been created in a manner that doesn't support direct scheduling.</source>
          <target state="translated">Puede que ya se iniciase, se ejecutase o se cancelase, o puede que se crease de una manera que no admite la programación directa.</target>       </trans-unit>
        <trans-unit id="783" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.RunSynchronously(System.Threading.Tasks.TaskScheduler)">
          <source>The scheduler on which to attempt to run this task inline.</source>
          <target state="translated">Programador en el que se va a intentar ejecutar esta tarea insertada.</target>       </trans-unit>
        <trans-unit id="784" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.RunSynchronously(System.Threading.Tasks.TaskScheduler)">
          <source>Runs the <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> synchronously on the <ph id="ph2">&lt;see cref="T:System.Threading.Tasks.TaskScheduler" /&gt;</ph> provided.</source>
          <target state="translated">Ejecuta sincrónicamente el objeto <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> en el objeto <ph id="ph2">&lt;see cref="T:System.Threading.Tasks.TaskScheduler" /&gt;</ph> proporcionado.</target>       </trans-unit>
        <trans-unit id="785" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.RunSynchronously(System.Threading.Tasks.TaskScheduler)">
          <source>Tasks executed by calling the <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.RunSynchronously%2A&gt;</ph> method are instantiated by calling a <ph id="ph2">&lt;xref:System.Threading.Tasks.Task&gt;</ph> or <ph id="ph3">&lt;xref:System.Threading.Tasks.Task%601&gt;</ph> class constructor.</source>
          <target state="translated">Las tareas ejecutadas mediante una llamada a la <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.RunSynchronously%2A&gt;</ph> se crea una instancia de método mediante una llamada a un <ph id="ph2">&lt;xref:System.Threading.Tasks.Task&gt;</ph> o <ph id="ph3">&lt;xref:System.Threading.Tasks.Task%601&gt;</ph> constructor de clase.</target>       </trans-unit>
        <trans-unit id="786" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.RunSynchronously(System.Threading.Tasks.TaskScheduler)">
          <source>The task to be run synchronously must be in the <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskStatus.Created&gt;</ph> state.</source>
          <target state="translated">La tarea se ejecute sincrónicamente debe estar en el <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskStatus.Created&gt;</ph> estado.</target>       </trans-unit>
        <trans-unit id="787" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.RunSynchronously(System.Threading.Tasks.TaskScheduler)">
          <source>A task may be started and run only once.</source>
          <target state="translated">Una tarea se puede iniciar y ejecutar una sola vez.</target>       </trans-unit>
        <trans-unit id="788" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.RunSynchronously(System.Threading.Tasks.TaskScheduler)">
          <source>Any attempts to schedule a task a second time results in an exception.</source>
          <target state="translated">Cualquier intento para programar una tarea de un segundo tiempo da como resultado una excepción.</target>       </trans-unit>
        <trans-unit id="789" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.RunSynchronously(System.Threading.Tasks.TaskScheduler)">
          <source>If the target scheduler does not support running this task on the current thread, the task will be scheduled for execution on the scheduler, and the current thread will block until the task has completed execution.</source>
          <target state="translated">Si el programador de destino no admite la ejecución de esta tarea en el subproceso actual, la tarea se programará para su ejecución en el programador y el subproceso actual se bloqueará hasta que la tarea ha completado su ejecución.</target>       </trans-unit>
        <trans-unit id="790" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.RunSynchronously(System.Threading.Tasks.TaskScheduler)">
          <source>Because of this, the calling thread does not need to call a method such as <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Wait%2A&gt;</ph> to ensure that the task has completed execution.</source>
          <target state="translated">Por este motivo, el subproceso que realiza la llamada no necesita llamar a un método como <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Wait%2A&gt;</ph> para asegurarse de que la tarea ha completado su ejecución.</target>       </trans-unit>
        <trans-unit id="791" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.RunSynchronously(System.Threading.Tasks.TaskScheduler)">
          <source>For more information on exception handling for task operations, see <bpt id="p1">[</bpt>Exception Handling<ept id="p1">](~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md)</ept>.</source>
          <target state="translated">Para obtener más información sobre el control de excepciones para las operaciones de tareas, consulte <bpt id="p1">[</bpt>Exception Handling<ept id="p1">](~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md)</ept>.</target>       </trans-unit>
        <trans-unit id="792" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.RunSynchronously(System.Threading.Tasks.TaskScheduler)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> instance has been disposed.</source>
          <target state="translated">Se eliminó la instancia de <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="793" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.RunSynchronously(System.Threading.Tasks.TaskScheduler)">
          <source>The <ph id="ph1">&lt;paramref name="scheduler" /&gt;</ph> argument is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">El argumento <ph id="ph1">&lt;paramref name="scheduler" /&gt;</ph> es <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="794" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.RunSynchronously(System.Threading.Tasks.TaskScheduler)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> is not in a valid state to be started.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> no se encuentra en un estado válido para iniciarse.</target>       </trans-unit>
        <trans-unit id="795" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.RunSynchronously(System.Threading.Tasks.TaskScheduler)">
          <source>It may have already been started, executed, or canceled, or it may have been created in a manner that doesn't support direct scheduling.</source>
          <target state="translated">Puede que ya se iniciase, se ejecutase o se cancelase, o puede que se crease de una manera que no admite la programación directa.</target>       </trans-unit>
        <trans-unit id="796" translate="yes" xml:space="preserve" uid="T:System.Threading.Tasks.Task">
          <source>Starts the <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph>.</source>
          <target state="translated">Inicia <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="797" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Start">
          <source>Starts the <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph>, scheduling it for execution to the current <ph id="ph2">&lt;see cref="T:System.Threading.Tasks.TaskScheduler" /&gt;</ph>.</source>
          <target state="translated">Inicia el objeto <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph>, programando su ejecución en el objeto <ph id="ph2">&lt;see cref="T:System.Threading.Tasks.TaskScheduler" /&gt;</ph> actual.</target>       </trans-unit>
        <trans-unit id="798" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Start">
          <source>A task may be started and run only once.</source>
          <target state="translated">Una tarea se puede iniciar y ejecutar una sola vez.</target>       </trans-unit>
        <trans-unit id="799" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Start">
          <source>Any attempts to schedule a task a second time will result in an exception.</source>
          <target state="translated">Cualquier intento de programar una tarea una segunda vez se producirá una excepción.</target>       </trans-unit>
        <trans-unit id="800" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Start">
          <source>The <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Start%2A&gt;</ph> is used to execute a task that has been created by calling one of the <ph id="ph2">&lt;xref:System.Threading.Tasks.Task&gt;</ph> constructors.</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Start%2A&gt;</ph> se usa para ejecutar una tarea que se ha creado llamando a uno de los <ph id="ph2">&lt;xref:System.Threading.Tasks.Task&gt;</ph> constructores.</target>       </trans-unit>
        <trans-unit id="801" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Start">
          <source>Typically, you do this when you need to separate the task's creation from its execution, such as when you conditionally execute tasks that you've created.</source>
          <target state="translated">Normalmente, esto se realiza cuando es necesario separar la creación de la tarea de su ejecución, por ejemplo, cuando se ejecutan condicionalmente las tareas que ha creado.</target>       </trans-unit>
        <trans-unit id="802" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Start">
          <source>For the more common case in which you don't need to separate  task instantiation from execution, we recommend that you call an overload of the <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Run%2A?displayProperty=nameWithType&gt;</ph> or <ph id="ph2">&lt;xref:System.Threading.Tasks.TaskFactory.StartNew%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">En el caso más común en el que no es necesario separar la creación de instancias de tareas de ejecución, se recomienda llamar a una sobrecarga de la <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Run%2A?displayProperty=nameWithType&gt;</ph> o <ph id="ph2">&lt;xref:System.Threading.Tasks.TaskFactory.StartNew%2A?displayProperty=nameWithType&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="803" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Start">
          <source>For information on handling exceptions thrown by task operations, see <bpt id="p1">[</bpt>Exception Handling<ept id="p1">](~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md)</ept>.</source>
          <target state="translated">Para obtener información sobre cómo controlar las excepciones producidas por las operaciones de tareas, consulte <bpt id="p1">[</bpt>Exception Handling<ept id="p1">](~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md)</ept>.</target>       </trans-unit>
        <trans-unit id="804" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Start">
          <source>The following example calls the <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.%23ctor%28System.Action%29&gt;</ph> constructor to instantiate a new <ph id="ph2">&lt;xref:System.Threading.Tasks.Task&gt;</ph> object that displays its task ID and managed thread ID and then executes a loop.</source>
          <target state="translated">El ejemplo siguiente se llama el <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.%23ctor%28System.Action%29&gt;</ph> constructor para crear instancias de un nuevo <ph id="ph2">&lt;xref:System.Threading.Tasks.Task&gt;</ph> objeto que muestra su tarea identificador y el identificador de subproceso administrado y, a continuación, ejecuta un bucle.</target>       </trans-unit>
        <trans-unit id="805" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Start">
          <source>It then calls the <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Start%2A&gt;</ph> method to execute the task.</source>
          <target state="translated">A continuación, llama el <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Start%2A&gt;</ph> método para ejecutar la tarea.</target>       </trans-unit>
        <trans-unit id="806" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Start">
          <source>Since this is a console app, the call to the <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Wait%2A&gt;</ph> method is necessary to prevent the app from terminating before the task finishes execution.</source>
          <target state="translated">Puesto que se trata de una aplicación de consola, la llamada a la <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Wait%2A&gt;</ph> método es necesario para evitar que la aplicación finalice antes de que la tarea finaliza la ejecución.</target>       </trans-unit>
        <trans-unit id="807" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Start">
          <source>The <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> instance has been disposed.</source>
          <target state="translated">Se eliminó la instancia de <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="808" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Start">
          <source>The <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> is not in a valid state to be started.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> no se encuentra en un estado válido para iniciarse.</target>       </trans-unit>
        <trans-unit id="809" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Start">
          <source>It may have already been started, executed, or canceled, or it may have been created in a manner that doesn't support direct scheduling.</source>
          <target state="translated">Puede que ya se iniciase, se ejecutase o se cancelase, o puede que se crease de una manera que no admite la programación directa.</target>       </trans-unit>
        <trans-unit id="810" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Start(System.Threading.Tasks.TaskScheduler)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.TaskScheduler" /&gt;</ph> with which to associate and execute this task.</source>
          <target state="translated">Objeto <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.TaskScheduler" /&gt;</ph> con el que se va a asociar y ejecutar esta tarea.</target>       </trans-unit>
        <trans-unit id="811" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Start(System.Threading.Tasks.TaskScheduler)">
          <source>Starts the <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph>, scheduling it for execution to the specified <ph id="ph2">&lt;see cref="T:System.Threading.Tasks.TaskScheduler" /&gt;</ph>.</source>
          <target state="translated">Inicia el objeto <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph>, programando su ejecución en el objeto <ph id="ph2">&lt;see cref="T:System.Threading.Tasks.TaskScheduler" /&gt;</ph> especificado.</target>       </trans-unit>
        <trans-unit id="812" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Start(System.Threading.Tasks.TaskScheduler)">
          <source>A task may only be started and run only once.</source>
          <target state="translated">Una tarea solo se inicia y ejecuta una sola vez.</target>       </trans-unit>
        <trans-unit id="813" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Start(System.Threading.Tasks.TaskScheduler)">
          <source>Any attempts to schedule a task a second time will result in an exception.</source>
          <target state="translated">Cualquier intento de programar una tarea una segunda vez se producirá una excepción.</target>       </trans-unit>
        <trans-unit id="814" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Start(System.Threading.Tasks.TaskScheduler)">
          <source>For information on handling exceptions thrown by task operations, see <bpt id="p1">[</bpt>Exception Handling<ept id="p1">](~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md)</ept>.</source>
          <target state="translated">Para obtener información sobre cómo controlar las excepciones producidas por las operaciones de tareas, consulte <bpt id="p1">[</bpt>Exception Handling<ept id="p1">](~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md)</ept>.</target>       </trans-unit>
        <trans-unit id="815" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Start(System.Threading.Tasks.TaskScheduler)">
          <source>The <ph id="ph1">&lt;paramref name="scheduler" /&gt;</ph> argument is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">El argumento <ph id="ph1">&lt;paramref name="scheduler" /&gt;</ph> es <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="816" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Start(System.Threading.Tasks.TaskScheduler)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> is not in a valid state to be started.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> no se encuentra en un estado válido para iniciarse.</target>       </trans-unit>
        <trans-unit id="817" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Start(System.Threading.Tasks.TaskScheduler)">
          <source>It may have already been started, executed, or canceled, or it may have been created in a manner that doesn't support direct scheduling.</source>
          <target state="translated">Puede que ya se iniciase, se ejecutase o se cancelase, o puede que se crease de una manera que no admite la programación directa.</target>       </trans-unit>
        <trans-unit id="818" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Start(System.Threading.Tasks.TaskScheduler)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> instance has been disposed.</source>
          <target state="translated">Se eliminó la instancia de <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="819" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Start(System.Threading.Tasks.TaskScheduler)">
          <source>The scheduler was unable to queue this task.</source>
          <target state="translated">El programador no pudo poner en cola esta tarea.</target>       </trans-unit>
        <trans-unit id="820" translate="yes" xml:space="preserve" uid="P:System.Threading.Tasks.Task.Status">
          <source>Gets the <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.TaskStatus" /&gt;</ph> of this task.</source>
          <target state="translated">Obtiene el objeto <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.TaskStatus" /&gt;</ph> de esta tarea.</target>       </trans-unit>
        <trans-unit id="821" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Tasks.Task.Status">
          <source>The current <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.TaskStatus" /&gt;</ph> of this task instance.</source>
          <target state="translated">Valor actual de la propiedad <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.TaskStatus" /&gt;</ph> de esta instancia de la tarea.</target>       </trans-unit>
        <trans-unit id="822" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Tasks.Task.Status">
          <source>Retrieving the value of the <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Status%2A?displayProperty=nameWithType&gt;</ph> property does not block the calling thread until the task has completed.</source>
          <target state="translated">Recuperación del valor de la <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Status%2A?displayProperty=nameWithType&gt;</ph> propiedad no bloquea el subproceso que realiza la llamada hasta que la tarea se ha completado.</target>       </trans-unit>
        <trans-unit id="823" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Tasks.Task.Status">
          <source>For more information and an example, see <bpt id="p1">[</bpt>Chaining Tasks by Using Continuation Tasks<ept id="p1">](~/docs/standard/parallel-programming/chaining-tasks-by-using-continuation-tasks.md)</ept> and <bpt id="p2">[</bpt>How to: Cancel a Task and Its Children<ept id="p2">](~/docs/standard/parallel-programming/how-to-cancel-a-task-and-its-children.md)</ept>.</source>
          <target state="translated">Para obtener más información y un ejemplo, vea <bpt id="p1">[</bpt>encadenar tareas mediante tareas de continuación<ept id="p1">](~/docs/standard/parallel-programming/chaining-tasks-by-using-continuation-tasks.md)</ept> y <bpt id="p2">[</bpt>Cómo: cancelar una tarea y sus elementos secundarios<ept id="p2">](~/docs/standard/parallel-programming/how-to-cancel-a-task-and-its-children.md)</ept>.</target>       </trans-unit>
        <trans-unit id="824" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Tasks.Task.Status">
          <source>The following example creates 20 tasks that will loop until a counter is incremented to a value of 2 million.</source>
          <target state="translated">En el ejemplo siguiente se crea 20 tareas que genere un bucle hasta que se incrementa un contador con un valor de 2 millones.</target>       </trans-unit>
        <trans-unit id="825" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Tasks.Task.Status">
          <source>When the first 10 tasks reach 2 million, the cancellation token is cancelled, and any tasks whose counters have not reached 2 million are cancelled.</source>
          <target state="translated">Cuando las 10 primeras tareas alcancen 2 millones, el token de cancelación se cancela y se cancelan todas las tareas cuyos contadores no hayan alcanzado 2 millones.</target>       </trans-unit>
        <trans-unit id="826" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Tasks.Task.Status">
          <source>The example then examines the <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Status%2A&gt;</ph> property of each task to indicate whether it completed successfully or was cancelled.</source>
          <target state="translated">En el ejemplo, a continuación, examina el <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Status%2A&gt;</ph> propiedad de cada tarea para indicar si se completó correctamente o se canceló.</target>       </trans-unit>
        <trans-unit id="827" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Tasks.Task.Status">
          <source>For those that completed, it displays the value returned by the task.</source>
          <target state="translated">Para los que se completa, muestra el valor devuelto por la tarea.</target>       </trans-unit>
        <trans-unit id="828" translate="yes" xml:space="preserve" uid="P:System.Threading.Tasks.Task.System#IAsyncResult#AsyncWaitHandle">
          <source>Gets a <ph id="ph1">&lt;see cref="T:System.Threading.WaitHandle" /&gt;</ph> that can be used to wait for the task to complete.</source>
          <target state="translated">Obtiene un identificador <ph id="ph1">&lt;see cref="T:System.Threading.WaitHandle" /&gt;</ph> que se puede usar para esperar a que se complete la tarea.</target>       </trans-unit>
        <trans-unit id="829" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Tasks.Task.System#IAsyncResult#AsyncWaitHandle">
          <source>A <ph id="ph1">&lt;see cref="T:System.Threading.WaitHandle" /&gt;</ph> that can be used to wait for the task to complete.</source>
          <target state="translated">Identificador <ph id="ph1">&lt;see cref="T:System.Threading.WaitHandle" /&gt;</ph> que se puede usar para esperar a que se complete la tarea.</target>       </trans-unit>
        <trans-unit id="830" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Tasks.Task.System#IAsyncResult#AsyncWaitHandle">
          <source>Using the wait functionality provided by <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Wait%2A?displayProperty=nameWithType&gt;</ph> is preferable to using <ph id="ph2">&lt;xref:System.IAsyncResult.AsyncWaitHandle%2A&gt;</ph> for similar functionality.</source>
          <target state="translated">Mediante la funcionalidad de espera proporcionada por <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Wait%2A?displayProperty=nameWithType&gt;</ph> es preferible al uso de <ph id="ph2">&lt;xref:System.IAsyncResult.AsyncWaitHandle%2A&gt;</ph> para una funcionalidad similar.</target>       </trans-unit>
        <trans-unit id="831" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Tasks.Task.System#IAsyncResult#AsyncWaitHandle">
          <source>For more information, see the "Waiting on Tasks" section in <bpt id="p1">[</bpt>Task-based Asynchronous Programming<ept id="p1">](~/docs/standard/parallel-programming/task-based-asynchronous-programming.md)</ept> and <bpt id="p2">[</bpt>Using TPL with Other Asynchronous Patterns<ept id="p2">](~/docs/standard/parallel-programming/using-tpl-with-other-asynchronous-patterns.md)</ept>.</source>
          <target state="translated">Para obtener más información, consulte la sección "Esperando en tareas" en <bpt id="p1">[</bpt>basado en tareas de programación asincrónica<ept id="p1">](~/docs/standard/parallel-programming/task-based-asynchronous-programming.md)</ept> y <bpt id="p2">[</bpt>usar TPL con otros modelos asincrónicos<ept id="p2">](~/docs/standard/parallel-programming/using-tpl-with-other-asynchronous-patterns.md)</ept>.</target>       </trans-unit>
        <trans-unit id="832" translate="yes" xml:space="preserve" uid="P:System.Threading.Tasks.Task.System#IAsyncResult#AsyncWaitHandle">
          <source>The <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> has been disposed.</source>
          <target state="translated">Se ha eliminado <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="833" translate="yes" xml:space="preserve" uid="P:System.Threading.Tasks.Task.System#IAsyncResult#CompletedSynchronously">
          <source>Gets an indication of whether the operation completed synchronously.</source>
          <target state="translated">Obtiene un valor que indica si la operación se ha completado sincrónicamente.</target>       </trans-unit>
        <trans-unit id="834" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.Tasks.Task.System#IAsyncResult#CompletedSynchronously">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the operation completed synchronously; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> si la operación se completó de forma sincrónica; en caso contrario, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="835" translate="yes" xml:space="preserve" uid="T:System.Threading.Tasks.Task">
          <source>Waits for the <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> to complete execution.</source>
          <target state="translated">Espera a que se complete la ejecución del objeto <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="836" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Wait">
          <source>Waits for the <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> to complete execution.</source>
          <target state="translated">Espera a que se complete la ejecución del objeto <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="837" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Wait">
          <source><ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Wait%2A&gt;</ph> is a synchronization method that causes the calling thread to wait until the current task has completed.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Wait%2A&gt;</ph> es un método de sincronización que hace que el subproceso que realiza la llamada esperar hasta que se ha completado la tarea actual.</target>       </trans-unit>
        <trans-unit id="838" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Wait">
          <source>If the current task has not started execution, the Wait method attempts to remove the task from the scheduler and execute it inline on the current thread.</source>
          <target state="translated">Si la tarea actual no ha iniciado la ejecución, el método espera intenta quitar la tarea del programador y lo ejecuta en línea en el subproceso actual.</target>       </trans-unit>
        <trans-unit id="839" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Wait">
          <source>If it is unable to do that, or if the current task has already started execution, it blocks the calling thread until the task completes.</source>
          <target state="translated">Si no es capaz de hacerlo, o si la tarea actual ya ha iniciado la ejecución, se bloquea el subproceso que realiza la llamada hasta que se complete la tarea.</target>       </trans-unit>
        <trans-unit id="840" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Wait">
          <source>For more information, see <bpt id="p1">[</bpt>Task.Wait and "Inlining"<ept id="p1">](http://blogs.msdn.com/b/pfxteam/archive/2009/10/15/9907713.aspx)</ept> in the Parallel Programming with .NET blog.</source>
          <target state="translated">Para obtener más información, consulte <bpt id="p1">[</bpt>Task.Wait y "Inserción"<ept id="p1">](http://blogs.msdn.com/b/pfxteam/archive/2009/10/15/9907713.aspx)</ept> en la programación en paralelo con .NET blog.</target>       </trans-unit>
        <trans-unit id="841" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Wait">
          <source>For more information and an example, see <bpt id="p1">[</bpt>How to: Wait on One or More Tasks to Complete<ept id="p1">](http://msdn.microsoft.com/library/79cb522b-9c93-46ed-b23a-c06908f3a374)</ept>.</source>
          <target state="translated">Para obtener más información y un ejemplo, vea <bpt id="p1">[</bpt>Cómo: esperar a que una o varias tareas se completen<ept id="p1">](http://msdn.microsoft.com/library/79cb522b-9c93-46ed-b23a-c06908f3a374)</ept>.</target>       </trans-unit>
        <trans-unit id="842" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Wait">
          <source>The following example starts a task that generates one million random integers between 0 and 100 and computes their mean.</source>
          <target state="translated">En el ejemplo siguiente se inicia una tarea que genera un millón de números enteros aleatorios entre 0 y 100 y calcula su Media.</target>       </trans-unit>
        <trans-unit id="843" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Wait">
          <source>The example uses the <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Wait%2A&gt;</ph> method to ensure that the task completes before the application terminates.</source>
          <target state="translated">El ejemplo se utiliza la <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Wait%2A&gt;</ph> método para asegurarse de que la tarea se complete antes de que finalice la aplicación.</target>       </trans-unit>
        <trans-unit id="844" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Wait">
          <source>Otherwise, because this is a console application, the example would terminate before the task can compute and display the mean.</source>
          <target state="translated">En caso contrario, se trata de una aplicación de consola, en el ejemplo finalizaría antes de que la tarea puede calcular y mostrar la Media.</target>       </trans-unit>
        <trans-unit id="845" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Wait">
          <source>The <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> has been disposed.</source>
          <target state="translated">Se ha eliminado <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="846" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Wait">
          <source>The task was canceled.</source>
          <target state="translated">Se canceló la tarea.</target>       </trans-unit>
        <trans-unit id="847" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Wait">
          <source>The <ph id="ph1">&lt;see cref="P:System.AggregateException.InnerExceptions" /&gt;</ph> collection contains a <ph id="ph2">&lt;see cref="T:System.Threading.Tasks.TaskCanceledException" /&gt;</ph> object.</source>
          <target state="translated">La colección <ph id="ph1">&lt;see cref="P:System.AggregateException.InnerExceptions" /&gt;</ph> contiene un objeto <ph id="ph2">&lt;see cref="T:System.Threading.Tasks.TaskCanceledException" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="848" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Wait">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="849" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Wait">
          <source>An exception was thrown during the execution of the task.</source>
          <target state="translated">Se inició una excepción durante la ejecución de la tarea.</target>       </trans-unit>
        <trans-unit id="850" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Wait">
          <source>The <ph id="ph1">&lt;see cref="P:System.AggregateException.InnerExceptions" /&gt;</ph> collection contains information about the exception or exceptions.</source>
          <target state="translated">La colección <ph id="ph1">&lt;see cref="P:System.AggregateException.InnerExceptions" /&gt;</ph> contiene información sobre la excepción o excepciones.</target>       </trans-unit>
        <trans-unit id="851" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Wait(System.Int32)">
          <source>The number of milliseconds to wait, or <ph id="ph1">&lt;see cref="F:System.Threading.Timeout.Infinite" /&gt;</ph> (-1) to wait indefinitely.</source>
          <target state="translated">Número de milisegundos de espera o <ph id="ph1">&lt;see cref="F:System.Threading.Timeout.Infinite" /&gt;</ph> (-1) para esperar indefinidamente.</target>       </trans-unit>
        <trans-unit id="852" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Wait(System.Int32)">
          <source>Waits for the <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> to complete execution within a specified number of milliseconds.</source>
          <target state="translated">Espera a que el objeto <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> complete la ejecución dentro de un número especificado de milisegundos.</target>       </trans-unit>
        <trans-unit id="853" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Wait(System.Int32)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the <ph id="ph2">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> completed execution within the allotted time; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> si <ph id="ph2">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> completó su ejecución en el tiempo asignado; en caso contrario, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="854" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Wait(System.Int32)">
          <source><ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Wait%28System.Int32%29&gt;</ph> is a synchronization method that causes the calling thread to wait for the current task instance to complete until one of the following occurs:</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Wait%28System.Int32%29&gt;</ph> es un método de sincronización que hace que el subproceso que realiza la llamada debe esperar para que la instancia actual de la tarea completar hasta que se produzca uno de los siguientes:</target>       </trans-unit>
        <trans-unit id="855" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Wait(System.Int32)">
          <source>The task completes successfully.</source>
          <target state="translated">La tarea se completa correctamente.</target>       </trans-unit>
        <trans-unit id="856" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Wait(System.Int32)">
          <source>The task itself is canceled or throws an exception.</source>
          <target state="translated">La tarea propiamente dicha se cancela o inicia una excepción.</target>       </trans-unit>
        <trans-unit id="857" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Wait(System.Int32)">
          <source>In this case, you handle an <ph id="ph1">&lt;xref:System.AggregateException&gt;</ph> exception.</source>
          <target state="translated">En este caso, controlar un <ph id="ph1">&lt;xref:System.AggregateException&gt;</ph> excepción.</target>       </trans-unit>
        <trans-unit id="858" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Wait(System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.AggregateException.InnerExceptions%2A?displayProperty=nameWithType&gt;</ph> property contains details about the exception or exceptions.</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.AggregateException.InnerExceptions%2A?displayProperty=nameWithType&gt;</ph> propiedad contiene información detallada sobre la excepción o excepciones.</target>       </trans-unit>
        <trans-unit id="859" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Wait(System.Int32)">
          <source>The interval defined by <ph id="ph1">`millisecondsTimeout`</ph> elapses.</source>
          <target state="translated">El intervalo que define <ph id="ph1">`millisecondsTimeout`</ph> transcurre.</target>       </trans-unit>
        <trans-unit id="860" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Wait(System.Int32)">
          <source>In this case, the current thread resumes execution and the method returns <ph id="ph1">`false`</ph>.</source>
          <target state="translated">En este caso, el subproceso actual reanuda la ejecución y el método devuelve <ph id="ph1">`false`</ph>.</target>       </trans-unit>
        <trans-unit id="861" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Wait(System.Int32)">
          <source>The following example starts a task that generates five million random integers between 0 and 100 and computes their mean.</source>
          <target state="translated">En el ejemplo siguiente se inicia una tarea que genera números enteros aleatorios de cinco millones entre 0 y 100 y calcula su Media.</target>       </trans-unit>
        <trans-unit id="862" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Wait(System.Int32)">
          <source>The example uses the <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Wait%28System.Int32%29&gt;</ph> method to wait for the application to complete within 150 milliseconds.</source>
          <target state="translated">El ejemplo se utiliza la <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Wait%28System.Int32%29&gt;</ph> método para esperar la aplicación pueda completar dentro de 150 milisegundos.</target>       </trans-unit>
        <trans-unit id="863" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Wait(System.Int32)">
          <source>If the application completes normally, the task displays the sum and mean of the random numbers that it has generated.</source>
          <target state="translated">Si la aplicación se completa con normalidad, la tarea muestra la suma y promedio de los números aleatorios que ha generado.</target>       </trans-unit>
        <trans-unit id="864" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Wait(System.Int32)">
          <source>If the timeout interval has elapsed, the example displays a message before it terminates.</source>
          <target state="translated">Si ha transcurrido el intervalo de tiempo de espera, en el ejemplo se muestra un mensaje antes de finalizar.</target>       </trans-unit>
        <trans-unit id="865" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Wait(System.Int32)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> has been disposed.</source>
          <target state="translated">Se ha eliminado <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="866" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Wait(System.Int32)">
          <source><ph id="ph1">&lt;paramref name="millisecondsTimeout" /&gt;</ph> is a negative number other than -1, which represents an infinite time-out.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="millisecondsTimeout" /&gt;</ph> es un número negativo distinto de-1, que representa un tiempo de espera infinito.</target>       </trans-unit>
        <trans-unit id="867" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Wait(System.Int32)">
          <source>The task was canceled.</source>
          <target state="translated">Se canceló la tarea.</target>       </trans-unit>
        <trans-unit id="868" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Wait(System.Int32)">
          <source>The <ph id="ph1">&lt;see cref="P:System.AggregateException.InnerExceptions" /&gt;</ph> collection contains a <ph id="ph2">&lt;see cref="T:System.Threading.Tasks.TaskCanceledException" /&gt;</ph> object.</source>
          <target state="translated">La colección <ph id="ph1">&lt;see cref="P:System.AggregateException.InnerExceptions" /&gt;</ph> contiene un objeto <ph id="ph2">&lt;see cref="T:System.Threading.Tasks.TaskCanceledException" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="869" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Wait(System.Int32)">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="870" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Wait(System.Int32)">
          <source>An exception was thrown during the execution of the task.</source>
          <target state="translated">Se inició una excepción durante la ejecución de la tarea.</target>       </trans-unit>
        <trans-unit id="871" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Wait(System.Int32)">
          <source>The <ph id="ph1">&lt;see cref="P:System.AggregateException.InnerExceptions" /&gt;</ph> collection contains information about the exception or exceptions.</source>
          <target state="translated">La colección <ph id="ph1">&lt;see cref="P:System.AggregateException.InnerExceptions" /&gt;</ph> contiene información sobre la excepción o excepciones.</target>       </trans-unit>
        <trans-unit id="872" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Wait(System.Threading.CancellationToken)">
          <source>A cancellation token to observe while waiting for the task to complete.</source>
          <target state="translated">Un token de cancelación que se observará mientras se espera a que se complete la tarea.</target>       </trans-unit>
        <trans-unit id="873" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Wait(System.Threading.CancellationToken)">
          <source>Waits for the <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> to complete execution.</source>
          <target state="translated">Espera a que se complete la ejecución del objeto <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="874" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Wait(System.Threading.CancellationToken)">
          <source>The wait terminates if a cancellation token is canceled before the task completes.</source>
          <target state="translated">La espera finalizará si un token de cancelación se cancela antes de que finalice la tarea.</target>       </trans-unit>
        <trans-unit id="875" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Wait(System.Threading.CancellationToken)">
          <source>The <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Wait%28System.Threading.CancellationToken%29&gt;</ph> method creates a cancelable wait; that is, it causes the current thread to wait until one of the following occurs:</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Wait%28System.Threading.CancellationToken%29&gt;</ph> método crea una espera puede cancelarse; es decir, hace que el subproceso actual esperar hasta que se produce uno de los siguientes valores:</target>       </trans-unit>
        <trans-unit id="876" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Wait(System.Threading.CancellationToken)">
          <source>The task completes.</source>
          <target state="translated">La tarea se complete.</target>       </trans-unit>
        <trans-unit id="877" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Wait(System.Threading.CancellationToken)">
          <source>The cancellation token is canceled.</source>
          <target state="translated">El token de cancelación se cancela.</target>       </trans-unit>
        <trans-unit id="878" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Wait(System.Threading.CancellationToken)">
          <source>In this case, the call to the <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Wait%28System.Threading.CancellationToken%29&gt;</ph> method throws an <ph id="ph2">&lt;xref:System.OperationCanceledException&gt;</ph>.</source>
          <target state="translated">En este caso, la llamada a la <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Wait%28System.Threading.CancellationToken%29&gt;</ph> método produce un <ph id="ph2">&lt;xref:System.OperationCanceledException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="879" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Wait(System.Threading.CancellationToken)">
          <source>Canceling the <ph id="ph1">`cancellationToken`</ph> cancellation token has no effect on the running task unless it has also been passed the cancellation token and is prepared to handle cancellation.</source>
          <target state="translated">Cancelar la <ph id="ph1">`cancellationToken`</ph> token de cancelación no tiene ningún efecto en la tarea en ejecución a menos que también se ha pasado el token de cancelación y está preparado para administrar su cancelación.</target>       </trans-unit>
        <trans-unit id="880" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Wait(System.Threading.CancellationToken)">
          <source>Passing the <ph id="ph1">`cancellationToken`</ph> object to this method simply allows the wait to be canceled.</source>
          <target state="translated">Pasar la <ph id="ph1">`cancellationToken`</ph> objeto a este método simplemente permite la espera se cancele.</target>       </trans-unit>
        <trans-unit id="881" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Wait(System.Threading.CancellationToken)">
          <source>The following example illustrates the simple use of a cancellation token to cancel waiting for a task's completion.</source>
          <target state="translated">En el ejemplo siguiente se muestra el uso simple de un token de cancelación para cancelar esperar la finalización de una tarea.</target>       </trans-unit>
        <trans-unit id="882" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Wait(System.Threading.CancellationToken)">
          <source>A task is launched, calls the <ph id="ph1">&lt;xref:System.Threading.CancellationTokenSource.Cancel%2A?displayProperty=nameWithType&gt;</ph> method to cancel any of the token source's cancellation tokens, and then delays for five seconds.</source>
          <target state="translated">Una tarea se inicia, se llama a la <ph id="ph1">&lt;xref:System.Threading.CancellationTokenSource.Cancel%2A?displayProperty=nameWithType&gt;</ph> método cancelar cualquiera del origen de token tokens de cancelación y, a continuación, retrasos durante cinco segundos.</target>       </trans-unit>
        <trans-unit id="883" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Wait(System.Threading.CancellationToken)">
          <source>Note that the task itself has not been passed the cancellation token and is not cancelable.</source>
          <target state="translated">Tenga en cuenta que la propia tarea no se ha pasado el token de cancelación y no puede cancelar.</target>       </trans-unit>
        <trans-unit id="884" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Wait(System.Threading.CancellationToken)">
          <source>The application thread calls the task's <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Wait%2A?displayProperty=nameWithType&gt;</ph> method to wait for the task to complete, but the wait is canceled once the cancellation token is cancelled and an <ph id="ph2">&lt;xref:System.OperationCanceledException&gt;</ph> is thrown.</source>
          <target state="translated">El subproceso de la aplicación llama a la tarea <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Wait%2A?displayProperty=nameWithType&gt;</ph> método para esperar a que complete la tarea, pero la espera se cancela una vez que se cancela el token de cancelación y un <ph id="ph2">&lt;xref:System.OperationCanceledException&gt;</ph> se produce.</target>       </trans-unit>
        <trans-unit id="885" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Wait(System.Threading.CancellationToken)">
          <source>The exception handler reports the exception and then sleeps for six seconds.</source>
          <target state="translated">El controlador de excepciones notifica la excepción y, a continuación, se suspende durante seis segundos.</target>       </trans-unit>
        <trans-unit id="886" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Wait(System.Threading.CancellationToken)">
          <source>As the output from the example shows, that delay allows the task to complete in the <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskStatus.RanToCompletion&gt;</ph> state.</source>
          <target state="translated">Como se muestra en el resultado del ejemplo, ese retraso permite que la tarea se complete en el <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskStatus.RanToCompletion&gt;</ph> estado.</target>       </trans-unit>
        <trans-unit id="887" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Wait(System.Threading.CancellationToken)">
          <source>The <ph id="ph1">&lt;paramref name="cancellationToken" /&gt;</ph> was canceled.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="cancellationToken" /&gt;</ph> se canceló.</target>       </trans-unit>
        <trans-unit id="888" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Wait(System.Threading.CancellationToken)">
          <source>The task has been disposed.</source>
          <target state="translated">Se ha desechado la tarea.</target>       </trans-unit>
        <trans-unit id="889" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Wait(System.Threading.CancellationToken)">
          <source>The task was canceled.</source>
          <target state="translated">Se canceló la tarea.</target>       </trans-unit>
        <trans-unit id="890" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Wait(System.Threading.CancellationToken)">
          <source>The <ph id="ph1">&lt;see cref="P:System.AggregateException.InnerExceptions" /&gt;</ph> collection contains a <ph id="ph2">&lt;see cref="T:System.Threading.Tasks.TaskCanceledException" /&gt;</ph> object.</source>
          <target state="translated">La colección <ph id="ph1">&lt;see cref="P:System.AggregateException.InnerExceptions" /&gt;</ph> contiene un objeto <ph id="ph2">&lt;see cref="T:System.Threading.Tasks.TaskCanceledException" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="891" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Wait(System.Threading.CancellationToken)">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="892" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Wait(System.Threading.CancellationToken)">
          <source>An exception was thrown during the execution of the task.</source>
          <target state="translated">Se inició una excepción durante la ejecución de la tarea.</target>       </trans-unit>
        <trans-unit id="893" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Wait(System.Threading.CancellationToken)">
          <source>The <ph id="ph1">&lt;see cref="P:System.AggregateException.InnerExceptions" /&gt;</ph> collection contains information about the exception or exceptions.</source>
          <target state="translated">La colección <ph id="ph1">&lt;see cref="P:System.AggregateException.InnerExceptions" /&gt;</ph> contiene información sobre la excepción o excepciones.</target>       </trans-unit>
        <trans-unit id="894" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Wait(System.TimeSpan)">
          <source>A <ph id="ph1">&lt;see cref="T:System.TimeSpan" /&gt;</ph> that represents the number of milliseconds to wait, or a <ph id="ph2">&lt;see cref="T:System.TimeSpan" /&gt;</ph> that represents -1 milliseconds to wait indefinitely.</source>
          <target state="translated">Estructura <ph id="ph1">&lt;see cref="T:System.TimeSpan" /&gt;</ph> que representa el número de milisegundos de espera o estructura <ph id="ph2">&lt;see cref="T:System.TimeSpan" /&gt;</ph> que representa -1 milisegundos para esperar indefinidamente.</target>       </trans-unit>
        <trans-unit id="895" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Wait(System.TimeSpan)">
          <source>Waits for the <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> to complete execution within a specified time interval.</source>
          <target state="translated">Espera a que <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> complete la ejecución dentro de un intervalo de tiempo especificado.</target>       </trans-unit>
        <trans-unit id="896" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Wait(System.TimeSpan)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the <ph id="ph2">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> completed execution within the allotted time; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> si <ph id="ph2">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> completó su ejecución en el tiempo asignado; en caso contrario, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="897" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Wait(System.TimeSpan)">
          <source><ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Wait%28System.TimeSpan%29&gt;</ph> is a synchronization method that causes the calling thread to wait for the current task instance to complete until one of the following occurs:</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Wait%28System.TimeSpan%29&gt;</ph> es un método de sincronización que hace que el subproceso que realiza la llamada debe esperar para que la instancia actual de la tarea completar hasta que se produzca uno de los siguientes:</target>       </trans-unit>
        <trans-unit id="898" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Wait(System.TimeSpan)">
          <source>The task completes successfully.</source>
          <target state="translated">La tarea se completa correctamente.</target>       </trans-unit>
        <trans-unit id="899" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Wait(System.TimeSpan)">
          <source>The task itself is canceled or throws an exception.</source>
          <target state="translated">La tarea propiamente dicha se cancela o inicia una excepción.</target>       </trans-unit>
        <trans-unit id="900" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Wait(System.TimeSpan)">
          <source>In this case, you handle an <ph id="ph1">&lt;xref:System.AggregateException&gt;</ph> exception.</source>
          <target state="translated">En este caso, controlar un <ph id="ph1">&lt;xref:System.AggregateException&gt;</ph> excepción.</target>       </trans-unit>
        <trans-unit id="901" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Wait(System.TimeSpan)">
          <source>The <ph id="ph1">&lt;xref:System.AggregateException.InnerExceptions%2A?displayProperty=nameWithType&gt;</ph> property contains details about the exception or exceptions.</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.AggregateException.InnerExceptions%2A?displayProperty=nameWithType&gt;</ph> propiedad contiene información detallada sobre la excepción o excepciones.</target>       </trans-unit>
        <trans-unit id="902" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Wait(System.TimeSpan)">
          <source>The interval defined by <ph id="ph1">`timeout`</ph> elapses.</source>
          <target state="translated">El intervalo que define <ph id="ph1">`timeout`</ph> transcurre.</target>       </trans-unit>
        <trans-unit id="903" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Wait(System.TimeSpan)">
          <source>In this case, the current thread resumes execution and the method returns <ph id="ph1">`false`</ph>.</source>
          <target state="translated">En este caso, el subproceso actual reanuda la ejecución y el método devuelve <ph id="ph1">`false`</ph>.</target>       </trans-unit>
        <trans-unit id="904" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Wait(System.TimeSpan)">
          <source>The following example starts a task that generates five million random integers between 0 and 100 and computes their mean.</source>
          <target state="translated">En el ejemplo siguiente se inicia una tarea que genera números enteros aleatorios de cinco millones entre 0 y 100 y calcula su Media.</target>       </trans-unit>
        <trans-unit id="905" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Wait(System.TimeSpan)">
          <source>The example uses the <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Wait%28System.TimeSpan%29&gt;</ph> method to wait for the application to complete within 150 milliseconds.</source>
          <target state="translated">El ejemplo se utiliza la <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Wait%28System.TimeSpan%29&gt;</ph> método para esperar la aplicación pueda completar dentro de 150 milisegundos.</target>       </trans-unit>
        <trans-unit id="906" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Wait(System.TimeSpan)">
          <source>If the application completes normally, the task displays the sum and mean of the random numbers that it has generated.</source>
          <target state="translated">Si la aplicación se completa con normalidad, la tarea muestra la suma y promedio de los números aleatorios que ha generado.</target>       </trans-unit>
        <trans-unit id="907" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Wait(System.TimeSpan)">
          <source>If the timeout interval has elapsed, the example displays a message before it terminates.</source>
          <target state="translated">Si ha transcurrido el intervalo de tiempo de espera, en el ejemplo se muestra un mensaje antes de finalizar.</target>       </trans-unit>
        <trans-unit id="908" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Wait(System.TimeSpan)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> has been disposed.</source>
          <target state="translated">Se ha eliminado <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="909" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Wait(System.TimeSpan)">
          <source><ph id="ph1">&lt;paramref name="timeout" /&gt;</ph> is a negative number other than -1 milliseconds, which represents an infinite time-out.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="timeout" /&gt;</ph> es un número negativo distinto de -1 milisegundos, que representa un tiempo de espera infinito.</target>       </trans-unit>
        <trans-unit id="910" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Wait(System.TimeSpan)">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="911" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Wait(System.TimeSpan)">
          <source><ph id="ph1">&lt;paramref name="timeout" /&gt;</ph> is greater than <ph id="ph2">&lt;see cref="F:System.Int32.MaxValue" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="timeout" /&gt;</ph> es mayor que <ph id="ph2">&lt;see cref="F:System.Int32.MaxValue" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="912" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Wait(System.TimeSpan)">
          <source>The task was canceled.</source>
          <target state="translated">Se canceló la tarea.</target>       </trans-unit>
        <trans-unit id="913" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Wait(System.TimeSpan)">
          <source>The <ph id="ph1">&lt;see cref="P:System.AggregateException.InnerExceptions" /&gt;</ph> collection contains a <ph id="ph2">&lt;see cref="T:System.Threading.Tasks.TaskCanceledException" /&gt;</ph> object.</source>
          <target state="translated">La colección <ph id="ph1">&lt;see cref="P:System.AggregateException.InnerExceptions" /&gt;</ph> contiene un objeto <ph id="ph2">&lt;see cref="T:System.Threading.Tasks.TaskCanceledException" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="914" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Wait(System.TimeSpan)">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="915" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Wait(System.TimeSpan)">
          <source>An exception was thrown during the execution of the task.</source>
          <target state="translated">Se inició una excepción durante la ejecución de la tarea.</target>       </trans-unit>
        <trans-unit id="916" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Wait(System.TimeSpan)">
          <source>The <ph id="ph1">&lt;see cref="P:System.AggregateException.InnerExceptions" /&gt;</ph> collection contains information about the exception or exceptions.</source>
          <target state="translated">La colección <ph id="ph1">&lt;see cref="P:System.AggregateException.InnerExceptions" /&gt;</ph> contiene información sobre la excepción o excepciones.</target>       </trans-unit>
        <trans-unit id="917" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Wait(System.Int32,System.Threading.CancellationToken)">
          <source>The number of milliseconds to wait, or <ph id="ph1">&lt;see cref="F:System.Threading.Timeout.Infinite" /&gt;</ph> (-1) to wait indefinitely.</source>
          <target state="translated">Número de milisegundos de espera o <ph id="ph1">&lt;see cref="F:System.Threading.Timeout.Infinite" /&gt;</ph> (-1) para esperar indefinidamente.</target>       </trans-unit>
        <trans-unit id="918" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Wait(System.Int32,System.Threading.CancellationToken)">
          <source>A cancellation token to observe while waiting for the task to complete.</source>
          <target state="translated">Un token de cancelación que se observará mientras se espera a que se complete la tarea.</target>       </trans-unit>
        <trans-unit id="919" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Wait(System.Int32,System.Threading.CancellationToken)">
          <source>Waits for the <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> to complete execution.</source>
          <target state="translated">Espera a que se complete la ejecución del objeto <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="920" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Wait(System.Int32,System.Threading.CancellationToken)">
          <source>The wait terminates if a timeout interval elapses or a cancellation token is canceled before the task completes.</source>
          <target state="translated">La espera finalizará si transcurre un intervalo de tiempo de espera o un token de cancelación se cancela antes de que finalice la tarea.</target>       </trans-unit>
        <trans-unit id="921" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Wait(System.Int32,System.Threading.CancellationToken)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the <ph id="ph2">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> completed execution within the allotted time; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> si <ph id="ph2">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> completó su ejecución en el tiempo asignado; en caso contrario, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="922" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Wait(System.Int32,System.Threading.CancellationToken)">
          <source><ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Wait%28System.Int32%2CSystem.Threading.CancellationToken%29&gt;</ph> is a synchronization method that causes the calling thread to wait for the current task instance to complete until one of the following occurs:</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Wait%28System.Int32%2CSystem.Threading.CancellationToken%29&gt;</ph> es un método de sincronización que hace que el subproceso que realiza la llamada debe esperar para que la instancia actual de la tarea completar hasta que se produzca uno de los siguientes:</target>       </trans-unit>
        <trans-unit id="923" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Wait(System.Int32,System.Threading.CancellationToken)">
          <source>The task completes successfully.</source>
          <target state="translated">La tarea se completa correctamente.</target>       </trans-unit>
        <trans-unit id="924" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Wait(System.Int32,System.Threading.CancellationToken)">
          <source>The task itself is canceled or throws an exception.</source>
          <target state="translated">La tarea propiamente dicha se cancela o inicia una excepción.</target>       </trans-unit>
        <trans-unit id="925" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Wait(System.Int32,System.Threading.CancellationToken)">
          <source>In this case, you handle an <ph id="ph1">&lt;xref:System.AggregateException&gt;</ph> exception.</source>
          <target state="translated">En este caso, controlar un <ph id="ph1">&lt;xref:System.AggregateException&gt;</ph> excepción.</target>       </trans-unit>
        <trans-unit id="926" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Wait(System.Int32,System.Threading.CancellationToken)">
          <source>The <ph id="ph1">&lt;xref:System.AggregateException.InnerExceptions%2A?displayProperty=nameWithType&gt;</ph> property contains details about the exception or exceptions.</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.AggregateException.InnerExceptions%2A?displayProperty=nameWithType&gt;</ph> propiedad contiene información detallada sobre la excepción o excepciones.</target>       </trans-unit>
        <trans-unit id="927" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Wait(System.Int32,System.Threading.CancellationToken)">
          <source>The <ph id="ph1">`cancellationToken`</ph> cancellation token is canceled.</source>
          <target state="translated">El <ph id="ph1">`cancellationToken`</ph> se cancela el token de cancelación.</target>       </trans-unit>
        <trans-unit id="928" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Wait(System.Int32,System.Threading.CancellationToken)">
          <source>In this case, the call to the <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Wait%28System.Int32%2CSystem.Threading.CancellationToken%29&gt;</ph> method throws an <ph id="ph2">&lt;xref:System.OperationCanceledException&gt;</ph>.</source>
          <target state="translated">En este caso, la llamada a la <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Wait%28System.Int32%2CSystem.Threading.CancellationToken%29&gt;</ph> método produce un <ph id="ph2">&lt;xref:System.OperationCanceledException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="929" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Wait(System.Int32,System.Threading.CancellationToken)">
          <source>The interval defined by <ph id="ph1">`millisecondsTimeout`</ph> elapses.</source>
          <target state="translated">El intervalo que define <ph id="ph1">`millisecondsTimeout`</ph> transcurre.</target>       </trans-unit>
        <trans-unit id="930" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Wait(System.Int32,System.Threading.CancellationToken)">
          <source>In this case, the current thread resumes execution and the method returns <ph id="ph1">`false`</ph>.</source>
          <target state="translated">En este caso, el subproceso actual reanuda la ejecución y el método devuelve <ph id="ph1">`false`</ph>.</target>       </trans-unit>
        <trans-unit id="931" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Wait(System.Int32,System.Threading.CancellationToken)">
          <source>Canceling the <ph id="ph1">`cancellationToken`</ph> cancellation token has no effect on the running task unless it has also been passed the cancellation token and is prepared to handle cancellation.</source>
          <target state="translated">Cancelar la <ph id="ph1">`cancellationToken`</ph> token de cancelación no tiene ningún efecto en la tarea en ejecución a menos que también se ha pasado el token de cancelación y está preparado para administrar su cancelación.</target>       </trans-unit>
        <trans-unit id="932" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Wait(System.Int32,System.Threading.CancellationToken)">
          <source>Passing the <ph id="ph1">`cancellationToken`</ph> object to this method simply allows the wait to be canceled based on some condition.</source>
          <target state="translated">Pasar la <ph id="ph1">`cancellationToken`</ph> objeto a este método simplemente permite la espera cancelarse basándose en alguna condición.</target>       </trans-unit>
        <trans-unit id="933" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Wait(System.Int32,System.Threading.CancellationToken)">
          <source>The following example calls the <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Wait%28System.Int32%2CSystem.Threading.CancellationToken%29&gt;</ph> method to provide both a timeout value and a cancellation token that can end the wait for a task's completion.</source>
          <target state="translated">El ejemplo siguiente se llama el <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Wait%28System.Int32%2CSystem.Threading.CancellationToken%29&gt;</ph> método para proporcionar un valor de tiempo de espera y una cancelación de tokens que puede finalizar la espera de finalización de una tarea.</target>       </trans-unit>
        <trans-unit id="934" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Wait(System.Int32,System.Threading.CancellationToken)">
          <source>A new thread is started and executes the <ph id="ph1">`CancelToken`</ph> method, which pauses and then calls the <ph id="ph2">&lt;xref:System.Threading.CancellationTokenSource.Cancel%2A?displayProperty=nameWithType&gt;</ph> method to cancel the cancellation tokens.</source>
          <target state="translated">Un nuevo subproceso se inicia y ejecuta el <ph id="ph1">`CancelToken`</ph> método, que pone en pausa y, a continuación, llama a la <ph id="ph2">&lt;xref:System.Threading.CancellationTokenSource.Cancel%2A?displayProperty=nameWithType&gt;</ph> método para cancelar los tokens de cancelación.</target>       </trans-unit>
        <trans-unit id="935" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Wait(System.Int32,System.Threading.CancellationToken)">
          <source>A task is then launched and delays for 5 seconds.</source>
          <target state="translated">Una tarea es, a continuación, inicia y retrasa durante 5 segundos.</target>       </trans-unit>
        <trans-unit id="936" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Wait(System.Int32,System.Threading.CancellationToken)">
          <source>The <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Wait%2A&gt;</ph> method is then called to wait for the task's completion and is provided both a brief timeout value and a cancellation token.</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Wait%2A&gt;</ph> , a continuación, se llama para esperar la finalización de la tarea de método y se proporciona un valor de tiempo de espera breve y un token de cancelación.</target>       </trans-unit>
        <trans-unit id="937" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Wait(System.Int32,System.Threading.CancellationToken)">
          <source>Note that the precise output from the example depends on whether the wait was canceled because of the cancellation token or because the timeout interval elapsed.</source>
          <target state="translated">Tenga en cuenta que el resultado del ejemplo preciso depende de si se canceló la espera por el token de cancelación o porque se agotó el intervalo de tiempo de espera.</target>       </trans-unit>
        <trans-unit id="938" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Wait(System.Int32,System.Threading.CancellationToken)">
          <source>The <ph id="ph1">&lt;paramref name="cancellationToken" /&gt;</ph> was canceled.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="cancellationToken" /&gt;</ph> se canceló.</target>       </trans-unit>
        <trans-unit id="939" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Wait(System.Int32,System.Threading.CancellationToken)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> has been disposed.</source>
          <target state="translated">Se ha eliminado <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="940" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Wait(System.Int32,System.Threading.CancellationToken)">
          <source><ph id="ph1">&lt;paramref name="millisecondsTimeout" /&gt;</ph> is a negative number other than -1, which represents an infinite time-out.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="millisecondsTimeout" /&gt;</ph> es un número negativo distinto de-1, que representa un tiempo de espera infinito.</target>       </trans-unit>
        <trans-unit id="941" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Wait(System.Int32,System.Threading.CancellationToken)">
          <source>The task was canceled.</source>
          <target state="translated">Se canceló la tarea.</target>       </trans-unit>
        <trans-unit id="942" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Wait(System.Int32,System.Threading.CancellationToken)">
          <source>The <ph id="ph1">&lt;see cref="P:System.AggregateException.InnerExceptions" /&gt;</ph> collection contains a <ph id="ph2">&lt;see cref="T:System.Threading.Tasks.TaskCanceledException" /&gt;</ph> object.</source>
          <target state="translated">La colección <ph id="ph1">&lt;see cref="P:System.AggregateException.InnerExceptions" /&gt;</ph> contiene un objeto <ph id="ph2">&lt;see cref="T:System.Threading.Tasks.TaskCanceledException" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="943" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Wait(System.Int32,System.Threading.CancellationToken)">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="944" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Wait(System.Int32,System.Threading.CancellationToken)">
          <source>An exception was thrown during the execution of the task.</source>
          <target state="translated">Se inició una excepción durante la ejecución de la tarea.</target>       </trans-unit>
        <trans-unit id="945" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Wait(System.Int32,System.Threading.CancellationToken)">
          <source>The <ph id="ph1">&lt;see cref="P:System.AggregateException.InnerExceptions" /&gt;</ph> collection contains information about the exception or exceptions.</source>
          <target state="translated">La colección <ph id="ph1">&lt;see cref="P:System.AggregateException.InnerExceptions" /&gt;</ph> contiene información sobre la excepción o excepciones.</target>       </trans-unit>
        <trans-unit id="946" translate="yes" xml:space="preserve" uid="T:System.Threading.Tasks.Task">
          <source>Waits for all of the provided <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> objects to complete execution.</source>
          <target state="translated">Espera que se complete la ejecución de todos los objetos <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> proporcionados.</target>       </trans-unit>
        <trans-unit id="947" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[])">
          <source>An array of <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> instances on which to wait.</source>
          <target state="translated">Matriz de instancias de <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> en las que se va a esperar.</target>       </trans-unit>
        <trans-unit id="948" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[])">
          <source>Waits for all of the provided <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> objects to complete execution.</source>
          <target state="translated">Espera que se complete la ejecución de todos los objetos <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> proporcionados.</target>       </trans-unit>
        <trans-unit id="949" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[])">
          <source>The following example starts 10 tasks, each of which is passed an index as a state object.</source>
          <target state="translated">El ejemplo siguiente inicia 10 tareas, cada uno de los cuales se pasa un índice como un objeto de estado.</target>       </trans-unit>
        <trans-unit id="950" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[])">
          <source>Tasks with an index from two to five throw exceptions.</source>
          <target state="translated">Tareas con un índice de dos a cinco producen excepciones.</target>       </trans-unit>
        <trans-unit id="951" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[])">
          <source>The call to the <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.WaitAll%2A&gt;</ph> method wraps all exceptions in an <ph id="ph2">&lt;xref:System.AggregateException&gt;</ph> object and propagates it to the calling thread.</source>
          <target state="translated">La llamada a la <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.WaitAll%2A&gt;</ph> método ajusta todas las excepciones en un <ph id="ph2">&lt;xref:System.AggregateException&gt;</ph> de objetos y propaga al subproceso que realiza la llamada.</target>       </trans-unit>
        <trans-unit id="952" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[])">
          <source>One or more of the <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> objects in <ph id="ph2">&lt;paramref name="tasks" /&gt;</ph> has been disposed.</source>
          <target state="translated">Se eliminaron uno o varios de los objetos <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> de <ph id="ph2">&lt;paramref name="tasks" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="953" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[])">
          <source>The <ph id="ph1">&lt;paramref name="tasks" /&gt;</ph> argument is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">El argumento <ph id="ph1">&lt;paramref name="tasks" /&gt;</ph> es <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="954" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[])">
          <source>The <ph id="ph1">&lt;paramref name="tasks" /&gt;</ph> argument contains a null element.</source>
          <target state="translated">El argumento <ph id="ph1">&lt;paramref name="tasks" /&gt;</ph> contiene un elemento null.</target>       </trans-unit>
        <trans-unit id="955" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[])">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="956" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[])">
          <source>The <ph id="ph1">&lt;paramref name="tasks" /&gt;</ph> argument is an empty array.</source>
          <target state="translated">El argumento <ph id="ph1">&lt;paramref name="tasks" /&gt;</ph> es una matriz vacía.</target>       </trans-unit>
        <trans-unit id="957" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[])">
          <source>At least one of the <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> instances was canceled.</source>
          <target state="translated">Se canceló al menos una de las instancias <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="958" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[])">
          <source>If a task was canceled, the <ph id="ph1">&lt;see cref="T:System.AggregateException" /&gt;</ph> exception contains an <ph id="ph2">&lt;see cref="T:System.OperationCanceledException" /&gt;</ph> exception in its <ph id="ph3">&lt;see cref="P:System.AggregateException.InnerExceptions" /&gt;</ph> collection.</source>
          <target state="translated">Si se canceló una tarea, la excepción <ph id="ph1">&lt;see cref="T:System.AggregateException" /&gt;</ph> contiene una excepción <ph id="ph2">&lt;see cref="T:System.OperationCanceledException" /&gt;</ph> en su colección <ph id="ph3">&lt;see cref="P:System.AggregateException.InnerExceptions" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="959" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[])">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="960" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[])">
          <source>An exception was thrown during the execution of at least one of the <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> instances.</source>
          <target state="translated">Se inició una excepción durante la ejecución de al menos una de las instancias <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="961" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[],System.Int32)">
          <source>An array of <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> instances on which to wait.</source>
          <target state="translated">Matriz de instancias de <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> en las que se va a esperar.</target>       </trans-unit>
        <trans-unit id="962" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[],System.Int32)">
          <source>The number of milliseconds to wait, or <ph id="ph1">&lt;see cref="F:System.Threading.Timeout.Infinite" /&gt;</ph> (-1) to wait indefinitely.</source>
          <target state="translated">Número de milisegundos de espera o <ph id="ph1">&lt;see cref="F:System.Threading.Timeout.Infinite" /&gt;</ph> (-1) para esperar indefinidamente.</target>       </trans-unit>
        <trans-unit id="963" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[],System.Int32)">
          <source>Waits for all of the provided <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> objects to complete execution within a specified number of milliseconds.</source>
          <target state="translated">Espera a que todos los objetos proporcionados de <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> completen la ejecución dentro de un número especificado de milisegundos.</target>       </trans-unit>
        <trans-unit id="964" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[],System.Int32)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if all of the <ph id="ph2">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> instances completed execution within the allotted time; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> si todas las instancias de <ph id="ph2">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> completan su ejecución en el tiempo asignado; en caso contrario, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="965" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[],System.Int32)">
          <source>One or more of the <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> objects in <ph id="ph2">&lt;paramref name="tasks" /&gt;</ph> has been disposed.</source>
          <target state="translated">Se eliminaron uno o varios de los objetos <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> de <ph id="ph2">&lt;paramref name="tasks" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="966" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[],System.Int32)">
          <source>The <ph id="ph1">&lt;paramref name="tasks" /&gt;</ph> argument is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">El argumento <ph id="ph1">&lt;paramref name="tasks" /&gt;</ph> es <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="967" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[],System.Int32)">
          <source>At least one of the <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> instances was canceled.</source>
          <target state="translated">Se canceló al menos una de las instancias <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="968" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[],System.Int32)">
          <source>If a task was canceled, the <ph id="ph1">&lt;see cref="T:System.AggregateException" /&gt;</ph> contains an <ph id="ph2">&lt;see cref="T:System.OperationCanceledException" /&gt;</ph> in its <ph id="ph3">&lt;see cref="P:System.AggregateException.InnerExceptions" /&gt;</ph> collection.</source>
          <target state="translated">Si se canceló una tarea, la <ph id="ph1">&lt;see cref="T:System.AggregateException" /&gt;</ph> contiene una <ph id="ph2">&lt;see cref="T:System.OperationCanceledException" /&gt;</ph> en su colección <ph id="ph3">&lt;see cref="P:System.AggregateException.InnerExceptions" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="969" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[],System.Int32)">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="970" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[],System.Int32)">
          <source>An exception was thrown during the execution of at least one of the <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> instances.</source>
          <target state="translated">Se inició una excepción durante la ejecución de al menos una de las instancias <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="971" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[],System.Int32)">
          <source><ph id="ph1">&lt;paramref name="millisecondsTimeout" /&gt;</ph> is a negative number other than -1, which represents an infinite time-out.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="millisecondsTimeout" /&gt;</ph> es un número negativo distinto de-1, que representa un tiempo de espera infinito.</target>       </trans-unit>
        <trans-unit id="972" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[],System.Int32)">
          <source>The <ph id="ph1">&lt;paramref name="tasks" /&gt;</ph> argument contains a null element.</source>
          <target state="translated">El argumento <ph id="ph1">&lt;paramref name="tasks" /&gt;</ph> contiene un elemento null.</target>       </trans-unit>
        <trans-unit id="973" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[],System.Int32)">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="974" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[],System.Int32)">
          <source>The <ph id="ph1">&lt;paramref name="tasks" /&gt;</ph> argument is an empty array.</source>
          <target state="translated">El argumento <ph id="ph1">&lt;paramref name="tasks" /&gt;</ph> es una matriz vacía.</target>       </trans-unit>
        <trans-unit id="975" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[],System.Threading.CancellationToken)">
          <source>An array of <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> instances on which to wait.</source>
          <target state="translated">Matriz de instancias de <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> en las que se va a esperar.</target>       </trans-unit>
        <trans-unit id="976" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[],System.Threading.CancellationToken)">
          <source>A <ph id="ph1">&lt;see cref="P:System.Threading.Tasks.TaskFactory.CancellationToken" /&gt;</ph> to observe while waiting for the tasks to complete.</source>
          <target state="translated">Un <ph id="ph1">&lt;see cref="P:System.Threading.Tasks.TaskFactory.CancellationToken" /&gt;</ph> que se observará mientras se espera a que se complete la tarea.</target>       </trans-unit>
        <trans-unit id="977" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[],System.Threading.CancellationToken)">
          <source>Waits for all of the provided <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> objects to complete execution unless the wait is cancelled.</source>
          <target state="translated">Espera que se complete la ejecución de todos los objetos <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> proporcionados, a menos que se cancele la espera.</target>       </trans-unit>
        <trans-unit id="978" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[],System.Threading.CancellationToken)">
          <source>The <ph id="ph1">`cancellationToken`</ph> argument is used to cancel the wait operation.</source>
          <target state="translated">El <ph id="ph1">`cancellationToken`</ph> argumento se utiliza para cancelar la operación de espera.</target>       </trans-unit>
        <trans-unit id="979" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[],System.Threading.CancellationToken)">
          <source>Cancellation of the tasks is a distinct operation, and is signaled by the <ph id="ph1">&lt;xref:System.AggregateException&gt;</ph> as noted above.</source>
          <target state="translated">Cancelación de la tarea es una operación distinta y se señaliza mediante el <ph id="ph1">&lt;xref:System.AggregateException&gt;</ph> como se indicó anteriormente.</target>       </trans-unit>
        <trans-unit id="980" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[],System.Threading.CancellationToken)">
          <source>The <ph id="ph1">&lt;paramref name="cancellationToken" /&gt;</ph> was canceled.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="cancellationToken" /&gt;</ph> se canceló.</target>       </trans-unit>
        <trans-unit id="981" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[],System.Threading.CancellationToken)">
          <source>The <ph id="ph1">&lt;paramref name="tasks" /&gt;</ph> argument is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">El argumento <ph id="ph1">&lt;paramref name="tasks" /&gt;</ph> es <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="982" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[],System.Threading.CancellationToken)">
          <source>At least one of the <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> instances was canceled.</source>
          <target state="translated">Se canceló al menos una de las instancias <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="983" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[],System.Threading.CancellationToken)">
          <source>If a task was canceled, the <ph id="ph1">&lt;see cref="T:System.AggregateException" /&gt;</ph> contains an <ph id="ph2">&lt;see cref="T:System.OperationCanceledException" /&gt;</ph> in its <ph id="ph3">&lt;see cref="P:System.AggregateException.InnerExceptions" /&gt;</ph> collection.</source>
          <target state="translated">Si se canceló una tarea, la <ph id="ph1">&lt;see cref="T:System.AggregateException" /&gt;</ph> contiene una <ph id="ph2">&lt;see cref="T:System.OperationCanceledException" /&gt;</ph> en su colección <ph id="ph3">&lt;see cref="P:System.AggregateException.InnerExceptions" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="984" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[],System.Threading.CancellationToken)">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="985" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[],System.Threading.CancellationToken)">
          <source>An exception was thrown during the execution of at least one of the <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> instances.</source>
          <target state="translated">Se inició una excepción durante la ejecución de al menos una de las instancias <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="986" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[],System.Threading.CancellationToken)">
          <source>The <ph id="ph1">&lt;paramref name="tasks" /&gt;</ph> argument contains a null element.</source>
          <target state="translated">El argumento <ph id="ph1">&lt;paramref name="tasks" /&gt;</ph> contiene un elemento null.</target>       </trans-unit>
        <trans-unit id="987" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[],System.Threading.CancellationToken)">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="988" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[],System.Threading.CancellationToken)">
          <source>The <ph id="ph1">&lt;paramref name="tasks" /&gt;</ph> argument is an empty array.</source>
          <target state="translated">El argumento <ph id="ph1">&lt;paramref name="tasks" /&gt;</ph> es una matriz vacía.</target>       </trans-unit>
        <trans-unit id="989" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[],System.Threading.CancellationToken)">
          <source>One or more of the <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> objects in <ph id="ph2">&lt;paramref name="tasks" /&gt;</ph> has been disposed.</source>
          <target state="translated">Se eliminaron uno o varios de los objetos <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> de <ph id="ph2">&lt;paramref name="tasks" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="990" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[],System.TimeSpan)">
          <source>An array of <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> instances on which to wait.</source>
          <target state="translated">Matriz de instancias de <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> en las que se va a esperar.</target>       </trans-unit>
        <trans-unit id="991" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[],System.TimeSpan)">
          <source>A <ph id="ph1">&lt;see cref="T:System.TimeSpan" /&gt;</ph> that represents the number of milliseconds to wait, or a <ph id="ph2">&lt;see cref="T:System.TimeSpan" /&gt;</ph> that represents -1 milliseconds to wait indefinitely.</source>
          <target state="translated">Estructura <ph id="ph1">&lt;see cref="T:System.TimeSpan" /&gt;</ph> que representa el número de milisegundos de espera o estructura <ph id="ph2">&lt;see cref="T:System.TimeSpan" /&gt;</ph> que representa -1 milisegundos para esperar indefinidamente.</target>       </trans-unit>
        <trans-unit id="992" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[],System.TimeSpan)">
          <source>Waits for all of the provided cancellable <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> objects to complete execution within a specified time interval.</source>
          <target state="translated">Espera a que todos los objetos <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> cancelables que se hayan proporcionado completen la ejecución en un intervalo de tiempo especificado.</target>       </trans-unit>
        <trans-unit id="993" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[],System.TimeSpan)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if all of the <ph id="ph2">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> instances completed execution within the allotted time; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> si todas las instancias de <ph id="ph2">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> completan su ejecución en el tiempo asignado; en caso contrario, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="994" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[],System.TimeSpan)">
          <source>One or more of the <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> objects in <ph id="ph2">&lt;paramref name="tasks" /&gt;</ph> has been disposed.</source>
          <target state="translated">Se eliminaron uno o varios de los objetos <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> de <ph id="ph2">&lt;paramref name="tasks" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="995" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[],System.TimeSpan)">
          <source>The <ph id="ph1">&lt;paramref name="tasks" /&gt;</ph> argument is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">El argumento <ph id="ph1">&lt;paramref name="tasks" /&gt;</ph> es <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="996" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[],System.TimeSpan)">
          <source>At least one of the <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> instances was canceled.</source>
          <target state="translated">Se canceló al menos una de las instancias <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="997" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[],System.TimeSpan)">
          <source>If a task was canceled, the <ph id="ph1">&lt;see cref="T:System.AggregateException" /&gt;</ph> contains an <ph id="ph2">&lt;see cref="T:System.OperationCanceledException" /&gt;</ph> in its <ph id="ph3">&lt;see cref="P:System.AggregateException.InnerExceptions" /&gt;</ph> collection.</source>
          <target state="translated">Si se canceló una tarea, la <ph id="ph1">&lt;see cref="T:System.AggregateException" /&gt;</ph> contiene una <ph id="ph2">&lt;see cref="T:System.OperationCanceledException" /&gt;</ph> en su colección <ph id="ph3">&lt;see cref="P:System.AggregateException.InnerExceptions" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="998" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[],System.TimeSpan)">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="999" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[],System.TimeSpan)">
          <source>An exception was thrown during the execution of at least one of the <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> instances.</source>
          <target state="translated">Se inició una excepción durante la ejecución de al menos una de las instancias <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1000" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[],System.TimeSpan)">
          <source><ph id="ph1">&lt;paramref name="timeout" /&gt;</ph> is a negative number other than -1 milliseconds, which represents an infinite time-out.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="timeout" /&gt;</ph> es un número negativo distinto de -1 milisegundos, que representa un tiempo de espera infinito.</target>       </trans-unit>
        <trans-unit id="1001" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[],System.TimeSpan)">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="1002" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[],System.TimeSpan)">
          <source><ph id="ph1">&lt;paramref name="timeout" /&gt;</ph> is greater than <ph id="ph2">&lt;see cref="F:System.Int32.MaxValue" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="timeout" /&gt;</ph> es mayor que <ph id="ph2">&lt;see cref="F:System.Int32.MaxValue" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1003" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[],System.TimeSpan)">
          <source>The <ph id="ph1">&lt;paramref name="tasks" /&gt;</ph> argument contains a null element.</source>
          <target state="translated">El argumento <ph id="ph1">&lt;paramref name="tasks" /&gt;</ph> contiene un elemento null.</target>       </trans-unit>
        <trans-unit id="1004" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[],System.TimeSpan)">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="1005" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[],System.TimeSpan)">
          <source>The <ph id="ph1">&lt;paramref name="tasks" /&gt;</ph> argument is an empty array.</source>
          <target state="translated">El argumento <ph id="ph1">&lt;paramref name="tasks" /&gt;</ph> es una matriz vacía.</target>       </trans-unit>
        <trans-unit id="1006" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[],System.Int32,System.Threading.CancellationToken)">
          <source>An array of <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> instances on which to wait.</source>
          <target state="translated">Matriz de instancias de <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> en las que se va a esperar.</target>       </trans-unit>
        <trans-unit id="1007" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[],System.Int32,System.Threading.CancellationToken)">
          <source>The number of milliseconds to wait, or <ph id="ph1">&lt;see cref="F:System.Threading.Timeout.Infinite" /&gt;</ph> (-1) to wait indefinitely.</source>
          <target state="translated">Número de milisegundos de espera o <ph id="ph1">&lt;see cref="F:System.Threading.Timeout.Infinite" /&gt;</ph> (-1) para esperar indefinidamente.</target>       </trans-unit>
        <trans-unit id="1008" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[],System.Int32,System.Threading.CancellationToken)">
          <source>A <ph id="ph1">&lt;see cref="P:System.Threading.Tasks.TaskFactory.CancellationToken" /&gt;</ph> to observe while waiting for the tasks to complete.</source>
          <target state="translated">Un <ph id="ph1">&lt;see cref="P:System.Threading.Tasks.TaskFactory.CancellationToken" /&gt;</ph> que se observará mientras se espera a que se complete la tarea.</target>       </trans-unit>
        <trans-unit id="1009" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[],System.Int32,System.Threading.CancellationToken)">
          <source>Waits for all of the provided <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> objects to complete execution within a specified number of milliseconds or until the wait is cancelled.</source>
          <target state="translated">Espera a que todos los objetos <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> proporcionados completen la ejecución dentro de un número especificado de milisegundos o hasta que se cancele la espera.</target>       </trans-unit>
        <trans-unit id="1010" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[],System.Int32,System.Threading.CancellationToken)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if all of the <ph id="ph2">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> instances completed execution within the allotted time; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> si todas las instancias de <ph id="ph2">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> completan su ejecución en el tiempo asignado; en caso contrario, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1011" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[],System.Int32,System.Threading.CancellationToken)">
          <source>The <ph id="ph1">`cancellationToken`</ph> argument is used to cancel the wait operation.</source>
          <target state="translated">El <ph id="ph1">`cancellationToken`</ph> argumento se utiliza para cancelar la operación de espera.</target>       </trans-unit>
        <trans-unit id="1012" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[],System.Int32,System.Threading.CancellationToken)">
          <source>Cancellation of the tasks is a distinct operation, and is signaled by the <ph id="ph1">&lt;xref:System.AggregateException&gt;</ph> noted above.</source>
          <target state="translated">Cancelación de la tarea es una operación distinta y se señaliza mediante el <ph id="ph1">&lt;xref:System.AggregateException&gt;</ph> indicados anteriormente.</target>       </trans-unit>
        <trans-unit id="1013" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[],System.Int32,System.Threading.CancellationToken)">
          <source>One or more of the <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> objects in <ph id="ph2">&lt;paramref name="tasks" /&gt;</ph> has been disposed.</source>
          <target state="translated">Se eliminaron uno o varios de los objetos <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> de <ph id="ph2">&lt;paramref name="tasks" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1014" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[],System.Int32,System.Threading.CancellationToken)">
          <source>The <ph id="ph1">&lt;paramref name="tasks" /&gt;</ph> argument is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">El argumento <ph id="ph1">&lt;paramref name="tasks" /&gt;</ph> es <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1015" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[],System.Int32,System.Threading.CancellationToken)">
          <source>At least one of the <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> instances was canceled.</source>
          <target state="translated">Se canceló al menos una de las instancias <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1016" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[],System.Int32,System.Threading.CancellationToken)">
          <source>If a task was canceled, the <ph id="ph1">&lt;see cref="T:System.AggregateException" /&gt;</ph> contains an <ph id="ph2">&lt;see cref="T:System.OperationCanceledException" /&gt;</ph> in its <ph id="ph3">&lt;see cref="P:System.AggregateException.InnerExceptions" /&gt;</ph> collection.</source>
          <target state="translated">Si se canceló una tarea, la <ph id="ph1">&lt;see cref="T:System.AggregateException" /&gt;</ph> contiene una <ph id="ph2">&lt;see cref="T:System.OperationCanceledException" /&gt;</ph> en su colección <ph id="ph3">&lt;see cref="P:System.AggregateException.InnerExceptions" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1017" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[],System.Int32,System.Threading.CancellationToken)">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="1018" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[],System.Int32,System.Threading.CancellationToken)">
          <source>An exception was thrown during the execution of at least one of the <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> instances.</source>
          <target state="translated">Se inició una excepción durante la ejecución de al menos una de las instancias <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1019" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[],System.Int32,System.Threading.CancellationToken)">
          <source><ph id="ph1">&lt;paramref name="millisecondsTimeout" /&gt;</ph> is a negative number other than -1, which represents an infinite time-out.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="millisecondsTimeout" /&gt;</ph> es un número negativo distinto de-1, que representa un tiempo de espera infinito.</target>       </trans-unit>
        <trans-unit id="1020" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[],System.Int32,System.Threading.CancellationToken)">
          <source>The <ph id="ph1">&lt;paramref name="tasks" /&gt;</ph> argument contains a null element.</source>
          <target state="translated">El argumento <ph id="ph1">&lt;paramref name="tasks" /&gt;</ph> contiene un elemento null.</target>       </trans-unit>
        <trans-unit id="1021" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[],System.Int32,System.Threading.CancellationToken)">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="1022" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[],System.Int32,System.Threading.CancellationToken)">
          <source>The <ph id="ph1">&lt;paramref name="tasks" /&gt;</ph> argument is an empty array.</source>
          <target state="translated">El argumento <ph id="ph1">&lt;paramref name="tasks" /&gt;</ph> es una matriz vacía.</target>       </trans-unit>
        <trans-unit id="1023" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[],System.Int32,System.Threading.CancellationToken)">
          <source>The <ph id="ph1">&lt;paramref name="cancellationToken" /&gt;</ph> was canceled.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="cancellationToken" /&gt;</ph> se canceló.</target>       </trans-unit>
        <trans-unit id="1024" translate="yes" xml:space="preserve" uid="T:System.Threading.Tasks.Task">
          <source>Waits for any of the provided <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> objects to complete execution.</source>
          <target state="translated">Espera a que se complete la ejecución de cualquiera de los objetos <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> proporcionados.</target>       </trans-unit>
        <trans-unit id="1025" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WaitAny(System.Threading.Tasks.Task[])">
          <source>An array of <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> instances on which to wait.</source>
          <target state="translated">Matriz de instancias de <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> en las que se va a esperar.</target>       </trans-unit>
        <trans-unit id="1026" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WaitAny(System.Threading.Tasks.Task[])">
          <source>Waits for any of the provided <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> objects to complete execution.</source>
          <target state="translated">Espera a que se complete la ejecución de cualquiera de los objetos <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> proporcionados.</target>       </trans-unit>
        <trans-unit id="1027" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WaitAny(System.Threading.Tasks.Task[])">
          <source>The index of the completed <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> object in the <ph id="ph2">&lt;paramref name="tasks" /&gt;</ph> array.</source>
          <target state="translated">Índice del objeto <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> completado en la matriz <ph id="ph2">&lt;paramref name="tasks" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1028" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.WaitAny(System.Threading.Tasks.Task[])">
          <source>The following example launches five tasks, each of which sleeps for a minimum of 50 milliseconds or a maximum of 1,050 milliseconds.</source>
          <target state="translated">En el ejemplo siguiente se inicia tareas de cinco, cada uno de los cuales se suspende durante un mínimo de 50 milisegundos o un máximo de 1050 milisegundos.</target>       </trans-unit>
        <trans-unit id="1029" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.WaitAny(System.Threading.Tasks.Task[])">
          <source>The <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.WaitAny%2A&gt;</ph> method then waits for any of the tasks to complete.</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.WaitAny%2A&gt;</ph> método espera a que cualquiera de las tareas que se complete.</target>       </trans-unit>
        <trans-unit id="1030" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.WaitAny(System.Threading.Tasks.Task[])">
          <source>The example displays the task ID of the task that ended the wait, as well as the current status of all the tasks.</source>
          <target state="translated">En el ejemplo se muestra el identificador de tarea de la tarea que finalizó la espera, así como el estado actual de todas las tareas.</target>       </trans-unit>
        <trans-unit id="1031" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WaitAny(System.Threading.Tasks.Task[])">
          <source>The <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> has been disposed.</source>
          <target state="translated">Se ha eliminado <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1032" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WaitAny(System.Threading.Tasks.Task[])">
          <source>The <ph id="ph1">&lt;paramref name="tasks" /&gt;</ph> argument is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">El argumento <ph id="ph1">&lt;paramref name="tasks" /&gt;</ph> es <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1033" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WaitAny(System.Threading.Tasks.Task[])">
          <source>The <ph id="ph1">&lt;paramref name="tasks" /&gt;</ph> argument contains a null element.</source>
          <target state="translated">El argumento <ph id="ph1">&lt;paramref name="tasks" /&gt;</ph> contiene un elemento null.</target>       </trans-unit>
        <trans-unit id="1034" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WaitAny(System.Threading.Tasks.Task[],System.Int32)">
          <source>An array of <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> instances on which to wait.</source>
          <target state="translated">Matriz de instancias de <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> en las que se va a esperar.</target>       </trans-unit>
        <trans-unit id="1035" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WaitAny(System.Threading.Tasks.Task[],System.Int32)">
          <source>The number of milliseconds to wait, or <ph id="ph1">&lt;see cref="F:System.Threading.Timeout.Infinite" /&gt;</ph> (-1) to wait indefinitely.</source>
          <target state="translated">Número de milisegundos de espera o <ph id="ph1">&lt;see cref="F:System.Threading.Timeout.Infinite" /&gt;</ph> (-1) para esperar indefinidamente.</target>       </trans-unit>
        <trans-unit id="1036" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WaitAny(System.Threading.Tasks.Task[],System.Int32)">
          <source>Waits for any of the provided <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> objects to complete execution within a specified number of milliseconds.</source>
          <target state="translated">Espera a que cualquiera de los objetos <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> que se hayan proporcionado complete su ejecución dentro de un número especificado de milisegundos.</target>       </trans-unit>
        <trans-unit id="1037" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WaitAny(System.Threading.Tasks.Task[],System.Int32)">
          <source>The index of the completed task in the <ph id="ph1">&lt;paramref name="tasks" /&gt;</ph> array argument, or -1 if the timeout occurred.</source>
          <target state="translated">Índice de la tarea completada en la matriz especificada por el parámetro <ph id="ph1">&lt;paramref name="tasks" /&gt;</ph> o -1 si se agotó el tiempo de espera.</target>       </trans-unit>
        <trans-unit id="1038" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WaitAny(System.Threading.Tasks.Task[],System.Int32)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> has been disposed.</source>
          <target state="translated">Se ha eliminado <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1039" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WaitAny(System.Threading.Tasks.Task[],System.Int32)">
          <source>The <ph id="ph1">&lt;paramref name="tasks" /&gt;</ph> argument is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">El argumento <ph id="ph1">&lt;paramref name="tasks" /&gt;</ph> es <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1040" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WaitAny(System.Threading.Tasks.Task[],System.Int32)">
          <source><ph id="ph1">&lt;paramref name="millisecondsTimeout" /&gt;</ph> is a negative number other than -1, which represents an infinite time-out.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="millisecondsTimeout" /&gt;</ph> es un número negativo distinto de-1, que representa un tiempo de espera infinito.</target>       </trans-unit>
        <trans-unit id="1041" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WaitAny(System.Threading.Tasks.Task[],System.Int32)">
          <source>The <ph id="ph1">&lt;paramref name="tasks" /&gt;</ph> argument contains a null element.</source>
          <target state="translated">El argumento <ph id="ph1">&lt;paramref name="tasks" /&gt;</ph> contiene un elemento null.</target>       </trans-unit>
        <trans-unit id="1042" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WaitAny(System.Threading.Tasks.Task[],System.Threading.CancellationToken)">
          <source>An array of <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> instances on which to wait.</source>
          <target state="translated">Matriz de instancias de <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> en las que se va a esperar.</target>       </trans-unit>
        <trans-unit id="1043" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WaitAny(System.Threading.Tasks.Task[],System.Threading.CancellationToken)">
          <source>A <ph id="ph1">&lt;see cref="P:System.Threading.Tasks.TaskFactory.CancellationToken" /&gt;</ph> to observe while waiting for a task to complete.</source>
          <target state="translated">Un <ph id="ph1">&lt;see cref="P:System.Threading.Tasks.TaskFactory.CancellationToken" /&gt;</ph> que se observará mientras se espera a que se complete la tarea.</target>       </trans-unit>
        <trans-unit id="1044" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WaitAny(System.Threading.Tasks.Task[],System.Threading.CancellationToken)">
          <source>Waits for any of the provided <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> objects to complete execution unless the wait is cancelled.</source>
          <target state="translated">Espera que se complete la ejecución de cualquiera de los objetos <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> proporcionados, a menos que se cancele la espera.</target>       </trans-unit>
        <trans-unit id="1045" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WaitAny(System.Threading.Tasks.Task[],System.Threading.CancellationToken)">
          <source>The index of the completed task in the <ph id="ph1">&lt;paramref name="tasks" /&gt;</ph> array argument.</source>
          <target state="translated">Índice de la tarea completada en la matriz especificada por el parámetro <ph id="ph1">&lt;paramref name="tasks" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1046" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WaitAny(System.Threading.Tasks.Task[],System.Threading.CancellationToken)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> has been disposed.</source>
          <target state="translated">Se ha eliminado <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1047" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WaitAny(System.Threading.Tasks.Task[],System.Threading.CancellationToken)">
          <source>The <ph id="ph1">&lt;paramref name="tasks" /&gt;</ph> argument is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">El argumento <ph id="ph1">&lt;paramref name="tasks" /&gt;</ph> es <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1048" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WaitAny(System.Threading.Tasks.Task[],System.Threading.CancellationToken)">
          <source>The <ph id="ph1">&lt;paramref name="tasks" /&gt;</ph> argument contains a null element.</source>
          <target state="translated">El argumento <ph id="ph1">&lt;paramref name="tasks" /&gt;</ph> contiene un elemento null.</target>       </trans-unit>
        <trans-unit id="1049" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WaitAny(System.Threading.Tasks.Task[],System.Threading.CancellationToken)">
          <source>The <ph id="ph1">&lt;paramref name="cancellationToken" /&gt;</ph> was canceled.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="cancellationToken" /&gt;</ph> se canceló.</target>       </trans-unit>
        <trans-unit id="1050" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WaitAny(System.Threading.Tasks.Task[],System.TimeSpan)">
          <source>An array of <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> instances on which to wait.</source>
          <target state="translated">Matriz de instancias de <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> en las que se va a esperar.</target>       </trans-unit>
        <trans-unit id="1051" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WaitAny(System.Threading.Tasks.Task[],System.TimeSpan)">
          <source>A <ph id="ph1">&lt;see cref="T:System.TimeSpan" /&gt;</ph> that represents the number of milliseconds to wait, or a <ph id="ph2">&lt;see cref="T:System.TimeSpan" /&gt;</ph> that represents -1 milliseconds to wait indefinitely.</source>
          <target state="translated">Estructura <ph id="ph1">&lt;see cref="T:System.TimeSpan" /&gt;</ph> que representa el número de milisegundos de espera o estructura <ph id="ph2">&lt;see cref="T:System.TimeSpan" /&gt;</ph> que representa -1 milisegundos para esperar indefinidamente.</target>       </trans-unit>
        <trans-unit id="1052" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WaitAny(System.Threading.Tasks.Task[],System.TimeSpan)">
          <source>Waits for any of the provided <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> objects to complete execution within a specified time interval.</source>
          <target state="translated">Espera a que se complete la ejecución de cualquier objeto <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> proporcionado en un intervalo de tiempo especificado.</target>       </trans-unit>
        <trans-unit id="1053" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WaitAny(System.Threading.Tasks.Task[],System.TimeSpan)">
          <source>The index of the completed task in the <ph id="ph1">&lt;paramref name="tasks" /&gt;</ph> array argument, or -1 if the timeout occurred.</source>
          <target state="translated">Índice de la tarea completada en la matriz especificada por el parámetro <ph id="ph1">&lt;paramref name="tasks" /&gt;</ph> o -1 si se agotó el tiempo de espera.</target>       </trans-unit>
        <trans-unit id="1054" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WaitAny(System.Threading.Tasks.Task[],System.TimeSpan)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> has been disposed.</source>
          <target state="translated">Se ha eliminado <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1055" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WaitAny(System.Threading.Tasks.Task[],System.TimeSpan)">
          <source>The <ph id="ph1">&lt;paramref name="tasks" /&gt;</ph> argument is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">El argumento <ph id="ph1">&lt;paramref name="tasks" /&gt;</ph> es <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1056" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WaitAny(System.Threading.Tasks.Task[],System.TimeSpan)">
          <source><ph id="ph1">&lt;paramref name="timeout" /&gt;</ph> is a negative number other than -1 milliseconds, which represents an infinite time-out.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="timeout" /&gt;</ph> es un número negativo distinto de -1 milisegundos, que representa un tiempo de espera infinito.</target>       </trans-unit>
        <trans-unit id="1057" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WaitAny(System.Threading.Tasks.Task[],System.TimeSpan)">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="1058" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WaitAny(System.Threading.Tasks.Task[],System.TimeSpan)">
          <source><ph id="ph1">&lt;paramref name="timeout" /&gt;</ph> is greater than <ph id="ph2">&lt;see cref="F:System.Int32.MaxValue" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="timeout" /&gt;</ph> es mayor que <ph id="ph2">&lt;see cref="F:System.Int32.MaxValue" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1059" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WaitAny(System.Threading.Tasks.Task[],System.TimeSpan)">
          <source>The <ph id="ph1">&lt;paramref name="tasks" /&gt;</ph> argument contains a null element.</source>
          <target state="translated">El argumento <ph id="ph1">&lt;paramref name="tasks" /&gt;</ph> contiene un elemento null.</target>       </trans-unit>
        <trans-unit id="1060" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WaitAny(System.Threading.Tasks.Task[],System.Int32,System.Threading.CancellationToken)">
          <source>An array of <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> instances on which to wait.</source>
          <target state="translated">Matriz de instancias de <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> en las que se va a esperar.</target>       </trans-unit>
        <trans-unit id="1061" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WaitAny(System.Threading.Tasks.Task[],System.Int32,System.Threading.CancellationToken)">
          <source>The number of milliseconds to wait, or <ph id="ph1">&lt;see cref="F:System.Threading.Timeout.Infinite" /&gt;</ph> (-1) to wait indefinitely.</source>
          <target state="translated">Número de milisegundos de espera o <ph id="ph1">&lt;see cref="F:System.Threading.Timeout.Infinite" /&gt;</ph> (-1) para esperar indefinidamente.</target>       </trans-unit>
        <trans-unit id="1062" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WaitAny(System.Threading.Tasks.Task[],System.Int32,System.Threading.CancellationToken)">
          <source>A <ph id="ph1">&lt;see cref="P:System.Threading.Tasks.TaskFactory.CancellationToken" /&gt;</ph> to observe while waiting for a task to complete.</source>
          <target state="translated">Un <ph id="ph1">&lt;see cref="P:System.Threading.Tasks.TaskFactory.CancellationToken" /&gt;</ph> que se observará mientras se espera a que se complete la tarea.</target>       </trans-unit>
        <trans-unit id="1063" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WaitAny(System.Threading.Tasks.Task[],System.Int32,System.Threading.CancellationToken)">
          <source>Waits for any of the provided <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> objects to complete execution within a specified number of milliseconds or until a cancellation token is cancelled.</source>
          <target state="translated">Espera a que cualquiera de los objetos <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> proporcionados complete la ejecución dentro de un número especificado de milisegundos o hasta que se cancele un token de cancelación.</target>       </trans-unit>
        <trans-unit id="1064" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WaitAny(System.Threading.Tasks.Task[],System.Int32,System.Threading.CancellationToken)">
          <source>The index of the completed task in the <ph id="ph1">&lt;paramref name="tasks" /&gt;</ph> array argument, or -1 if the timeout occurred.</source>
          <target state="translated">Índice de la tarea completada en la matriz especificada por el parámetro <ph id="ph1">&lt;paramref name="tasks" /&gt;</ph> o -1 si se agotó el tiempo de espera.</target>       </trans-unit>
        <trans-unit id="1065" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WaitAny(System.Threading.Tasks.Task[],System.Int32,System.Threading.CancellationToken)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> has been disposed.</source>
          <target state="translated">Se ha eliminado <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1066" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WaitAny(System.Threading.Tasks.Task[],System.Int32,System.Threading.CancellationToken)">
          <source>The <ph id="ph1">&lt;paramref name="tasks" /&gt;</ph> argument is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">El argumento <ph id="ph1">&lt;paramref name="tasks" /&gt;</ph> es <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1067" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WaitAny(System.Threading.Tasks.Task[],System.Int32,System.Threading.CancellationToken)">
          <source><ph id="ph1">&lt;paramref name="millisecondsTimeout" /&gt;</ph> is a negative number other than -1, which represents an infinite time-out.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="millisecondsTimeout" /&gt;</ph> es un número negativo distinto de-1, que representa un tiempo de espera infinito.</target>       </trans-unit>
        <trans-unit id="1068" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WaitAny(System.Threading.Tasks.Task[],System.Int32,System.Threading.CancellationToken)">
          <source>The <ph id="ph1">&lt;paramref name="tasks" /&gt;</ph> argument contains a null element.</source>
          <target state="translated">El argumento <ph id="ph1">&lt;paramref name="tasks" /&gt;</ph> contiene un elemento null.</target>       </trans-unit>
        <trans-unit id="1069" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WaitAny(System.Threading.Tasks.Task[],System.Int32,System.Threading.CancellationToken)">
          <source>The <ph id="ph1">&lt;paramref name="cancellationToken" /&gt;</ph> was canceled.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="cancellationToken" /&gt;</ph> se canceló.</target>       </trans-unit>
        <trans-unit id="1070" translate="yes" xml:space="preserve" uid="T:System.Threading.Tasks.Task">
          <source>Creates a task that will complete when all of the supplied tasks have completed.</source>
          <target state="translated">Crea una tarea que finalizará cuando se hayan completado todas las tareas proporcionadas.</target>       </trans-unit>
        <trans-unit id="1071" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WhenAll(System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task})">
          <source>The tasks to wait on for completion.</source>
          <target state="translated">Tareas cuya finalización hay que esperar.</target>       </trans-unit>
        <trans-unit id="1072" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WhenAll(System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task})">
          <source>Creates a task that will complete when all of the <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> objects in an enumerable collection have completed.</source>
          <target state="translated">Crea una tarea que se completará cuando todos los objetos <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> de una colección enumerable se hayan completado.</target>       </trans-unit>
        <trans-unit id="1073" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WhenAll(System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task})">
          <source>A task that represents the completion of all of the supplied tasks.</source>
          <target state="translated">Tarea que representa la finalización de todas las tareas proporcionadas.</target>       </trans-unit>
        <trans-unit id="1074" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.WhenAll(System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task})">
          <source>The overloads of the <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.WhenAll%2A&gt;</ph> method that return a <ph id="ph2">&lt;xref:System.Threading.Tasks.Task&gt;</ph> object are typically called when you are interested in the status of a set of tasks or in the exceptions thrown by a set of tasks.</source>
          <target state="translated">Las sobrecargas de la <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.WhenAll%2A&gt;</ph> método que devuelve un <ph id="ph2">&lt;xref:System.Threading.Tasks.Task&gt;</ph> objeto se suelen denominar simplemente cuando está interesado en el estado de un conjunto de tareas o en las excepciones producidas por un conjunto de tareas.</target>       </trans-unit>
        <trans-unit id="1075" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.WhenAll(System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task})">
          <source>The call to <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.WhenAll%28System.Collections.Generic.IEnumerable%7BSystem.Threading.Tasks.Task%7D%29&gt;</ph> method does not block the calling thread.</source>
          <target state="translated">La llamada a <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.WhenAll%28System.Collections.Generic.IEnumerable%7BSystem.Threading.Tasks.Task%7D%29&gt;</ph> método no bloquea el subproceso que realiza la llamada.</target>       </trans-unit>
        <trans-unit id="1076" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.WhenAll(System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task})">
          <source>If any of the supplied tasks completes in a faulted state, the returned task will also complete in a <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskStatus.Faulted&gt;</ph> state,  where its exceptions will contain the aggregation of the set of unwrapped exceptions from each of the supplied tasks.</source>
          <target state="translated">Si cualquiera de las tareas proporcionadas se completa con un estado de error, la tarea devuelta también finalizará con un <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskStatus.Faulted&gt;</ph> estado, donde sus excepciones contendrá la agregación del conjunto de excepciones sin ajustar de cada una de las tareas proporcionadas.</target>       </trans-unit>
        <trans-unit id="1077" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.WhenAll(System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task})">
          <source>If none of the supplied tasks faulted but at least one of them was canceled, the returned task will end in the <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskStatus.Canceled&gt;</ph> state.</source>
          <target state="translated">Si ninguna de las tareas proporcionadas con errores, pero al menos uno de ellos se ha cancelado, la tarea devuelta finalizará en el <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskStatus.Canceled&gt;</ph> estado.</target>       </trans-unit>
        <trans-unit id="1078" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.WhenAll(System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task})">
          <source>If none of the tasks faulted and none of the tasks were canceled, the resulting task will end in the <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskStatus.RanToCompletion&gt;</ph> state.</source>
          <target state="translated">Si ninguna de las tareas con errores y ninguna de las tareas se han cancelado, la tarea resultante finalizará en el <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskStatus.RanToCompletion&gt;</ph> estado.</target>       </trans-unit>
        <trans-unit id="1079" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.WhenAll(System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task})">
          <source>If the supplied array/enumerable contains no tasks, the returned task will immediately transition to a <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskStatus.RanToCompletion&gt;</ph> state before it's returned to the caller.</source>
          <target state="translated">Si el proporcionado matriz/enumerable no contenga ninguna tarea, la tarea devuelta cambiará inmediatamente a un <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskStatus.RanToCompletion&gt;</ph> estado antes de que se devuelve al llamador.</target>       </trans-unit>
        <trans-unit id="1080" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.WhenAll(System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task})">
          <source>The following example creates a set of tasks that ping the URLs in an array.</source>
          <target state="translated">En el ejemplo siguiente se crea un conjunto de tareas que hacer ping a las direcciones URL en una matriz.</target>       </trans-unit>
        <trans-unit id="1081" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.WhenAll(System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task})">
          <source>The tasks are stored in a <ph id="ph1">`List&lt;Task&gt;`</ph> collection that is passed to the <ph id="ph2">&lt;xref:System.Threading.Tasks.Task.WhenAll%28System.Collections.Generic.IEnumerable%7BSystem.Threading.Tasks.Task%7D%29&gt;</ph> method.</source>
          <target state="translated">Las tareas se almacenan en un <ph id="ph1">`List&lt;Task&gt;`</ph> colección que se pasa a la <ph id="ph2">&lt;xref:System.Threading.Tasks.Task.WhenAll%28System.Collections.Generic.IEnumerable%7BSystem.Threading.Tasks.Task%7D%29&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="1082" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.WhenAll(System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task})">
          <source>After the call to the <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Wait%2A&gt;</ph> method ensures that all threads have completed, the example examines the <ph id="ph2">&lt;xref:System.Threading.Tasks.Task.Status%2A?displayProperty=nameWithType&gt;</ph> property to determine whether any tasks have faulted.</source>
          <target state="translated">Después de llamar a la <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Wait%2A&gt;</ph> método se asegura de que han completado todos los subprocesos, en el ejemplo se examina la <ph id="ph2">&lt;xref:System.Threading.Tasks.Task.Status%2A?displayProperty=nameWithType&gt;</ph> propiedad para determinar si las tareas se generó un error.</target>       </trans-unit>
        <trans-unit id="1083" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WhenAll(System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task})">
          <source>The <ph id="ph1">&lt;paramref name="tasks" /&gt;</ph> argument was <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">El argumento <ph id="ph1">&lt;paramref name="tasks" /&gt;</ph> era <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1084" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WhenAll(System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task})">
          <source>The <ph id="ph1">&lt;paramref name="tasks" /&gt;</ph> collection contained a <ph id="ph2">&lt;see langword="null" /&gt;</ph> task.</source>
          <target state="translated">La colección <ph id="ph1">&lt;paramref name="tasks" /&gt;</ph> contiene una tarea <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1085" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WhenAll(System.Threading.Tasks.Task[])">
          <source>The tasks to wait on for completion.</source>
          <target state="translated">Tareas cuya finalización hay que esperar.</target>       </trans-unit>
        <trans-unit id="1086" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WhenAll(System.Threading.Tasks.Task[])">
          <source>Creates a task that will complete when all of the <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> objects in an array have completed.</source>
          <target state="translated">Crea una tarea que se completará cuando todos los objetos <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task" /&gt;</ph> de una matriz se hayan completado.</target>       </trans-unit>
        <trans-unit id="1087" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WhenAll(System.Threading.Tasks.Task[])">
          <source>A task that represents the completion of all of the supplied tasks.</source>
          <target state="translated">Tarea que representa la finalización de todas las tareas proporcionadas.</target>       </trans-unit>
        <trans-unit id="1088" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.WhenAll(System.Threading.Tasks.Task[])">
          <source>The overloads of the <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.WhenAll%2A&gt;</ph> method that return a <ph id="ph2">&lt;xref:System.Threading.Tasks.Task&gt;</ph> object are typically called when you are interested in the status of a set of tasks or in the exceptions thrown by a set of tasks.</source>
          <target state="translated">Las sobrecargas de la <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.WhenAll%2A&gt;</ph> método que devuelve un <ph id="ph2">&lt;xref:System.Threading.Tasks.Task&gt;</ph> objeto se suelen denominar simplemente cuando está interesado en el estado de un conjunto de tareas o en las excepciones producidas por un conjunto de tareas.</target>       </trans-unit>
        <trans-unit id="1089" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.WhenAll(System.Threading.Tasks.Task[])">
          <source>The call to <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.WhenAll%28System.Threading.Tasks.Task%5B%5D%29&gt;</ph> method does not block the calling thread.</source>
          <target state="translated">La llamada a <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.WhenAll%28System.Threading.Tasks.Task%5B%5D%29&gt;</ph> método no bloquea el subproceso que realiza la llamada.</target>       </trans-unit>
        <trans-unit id="1090" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.WhenAll(System.Threading.Tasks.Task[])">
          <source>If any of the supplied tasks completes in a faulted state, the returned task will also complete in a <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskStatus.Faulted&gt;</ph> state, where its exceptions will contain the aggregation of the set of unwrapped exceptions from each of the supplied tasks.</source>
          <target state="translated">Si cualquiera de las tareas proporcionadas se completa con un estado de error, la tarea devuelta también finalizará con un <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskStatus.Faulted&gt;</ph> estado, donde sus excepciones contendrá la agregación del conjunto de excepciones sin ajustar de cada una de las tareas proporcionadas.</target>       </trans-unit>
        <trans-unit id="1091" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.WhenAll(System.Threading.Tasks.Task[])">
          <source>If none of the supplied tasks faulted but at least one of them was canceled, the returned task will end in the <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskStatus.Canceled&gt;</ph> state.</source>
          <target state="translated">Si ninguna de las tareas proporcionadas con errores, pero al menos uno de ellos se ha cancelado, la tarea devuelta finalizará en el <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskStatus.Canceled&gt;</ph> estado.</target>       </trans-unit>
        <trans-unit id="1092" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.WhenAll(System.Threading.Tasks.Task[])">
          <source>If none of the tasks faulted and none of the tasks were canceled, the resulting task will end in the <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskStatus.RanToCompletion&gt;</ph> state.</source>
          <target state="translated">Si ninguna de las tareas con errores y ninguna de las tareas se han cancelado, la tarea resultante finalizará en el <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskStatus.RanToCompletion&gt;</ph> estado.</target>       </trans-unit>
        <trans-unit id="1093" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.WhenAll(System.Threading.Tasks.Task[])">
          <source>If the supplied array/enumerable contains no tasks, the returned task will immediately transition to a <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskStatus.RanToCompletion&gt;</ph> state before it's returned to the caller.</source>
          <target state="translated">Si el proporcionado matriz/enumerable no contenga ninguna tarea, la tarea devuelta cambiará inmediatamente a un <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskStatus.RanToCompletion&gt;</ph> estado antes de que se devuelve al llamador.</target>       </trans-unit>
        <trans-unit id="1094" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.WhenAll(System.Threading.Tasks.Task[])">
          <source>The following example creates a set of tasks that ping the URLs in an array.</source>
          <target state="translated">En el ejemplo siguiente se crea un conjunto de tareas que hacer ping a las direcciones URL en una matriz.</target>       </trans-unit>
        <trans-unit id="1095" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.WhenAll(System.Threading.Tasks.Task[])">
          <source>The tasks are stored in a <ph id="ph1">`List&lt;Task&gt;`</ph> collection that is converted to an array and passed to the <ph id="ph2">&lt;xref:System.Threading.Tasks.Task.WhenAll%28System.Collections.Generic.IEnumerable%7BSystem.Threading.Tasks.Task%7D%29&gt;</ph> method.</source>
          <target state="translated">Las tareas se almacenan en un <ph id="ph1">`List&lt;Task&gt;`</ph> colección que se convierte en una matriz y se pasa a la <ph id="ph2">&lt;xref:System.Threading.Tasks.Task.WhenAll%28System.Collections.Generic.IEnumerable%7BSystem.Threading.Tasks.Task%7D%29&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="1096" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.WhenAll(System.Threading.Tasks.Task[])">
          <source>After the call to the <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Wait%2A&gt;</ph> method ensures that all threads have completed, the example examines the <ph id="ph2">&lt;xref:System.Threading.Tasks.Task.Status%2A?displayProperty=nameWithType&gt;</ph> property to determine whether any tasks have faulted.</source>
          <target state="translated">Después de llamar a la <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Wait%2A&gt;</ph> método se asegura de que han completado todos los subprocesos, en el ejemplo se examina la <ph id="ph2">&lt;xref:System.Threading.Tasks.Task.Status%2A?displayProperty=nameWithType&gt;</ph> propiedad para determinar si las tareas se generó un error.</target>       </trans-unit>
        <trans-unit id="1097" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WhenAll(System.Threading.Tasks.Task[])">
          <source>The <ph id="ph1">&lt;paramref name="tasks" /&gt;</ph> argument was <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">El argumento <ph id="ph1">&lt;paramref name="tasks" /&gt;</ph> era <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1098" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WhenAll(System.Threading.Tasks.Task[])">
          <source>The <ph id="ph1">&lt;paramref name="tasks" /&gt;</ph> array contained a <ph id="ph2">&lt;see langword="null" /&gt;</ph> task.</source>
          <target state="translated">La matriz <ph id="ph1">&lt;paramref name="tasks" /&gt;</ph> contiene una tarea <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1099" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.WhenAll``1(System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task{``0}})">
          <source>The type of the completed task.</source>
          <target state="translated">Tipo de la tarea completada.</target>       </trans-unit>
        <trans-unit id="1100" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WhenAll``1(System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task{``0}})">
          <source>The tasks to wait on for completion.</source>
          <target state="translated">Tareas cuya finalización hay que esperar.</target>       </trans-unit>
        <trans-unit id="1101" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WhenAll``1(System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task{``0}})">
          <source>Creates a task that will complete when all of the <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task`1" /&gt;</ph> objects in an enumerable collection have completed.</source>
          <target state="translated">Crea una tarea que se completará cuando todos los objetos <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task`1" /&gt;</ph> de una colección enumerable se hayan completado.</target>       </trans-unit>
        <trans-unit id="1102" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WhenAll``1(System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task{``0}})">
          <source>A task that represents the completion of all of the supplied tasks.</source>
          <target state="translated">Tarea que representa la finalización de todas las tareas proporcionadas.</target>       </trans-unit>
        <trans-unit id="1103" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.WhenAll``1(System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task{``0}})">
          <source>The call to <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.WhenAll%60%601%28System.Collections.Generic.IEnumerable%7BSystem.Threading.Tasks.Task%7B%60%600%7D%7D%29&gt;</ph> method does not block the calling thread.</source>
          <target state="translated">La llamada a <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.WhenAll%60%601%28System.Collections.Generic.IEnumerable%7BSystem.Threading.Tasks.Task%7B%60%600%7D%7D%29&gt;</ph> método no bloquea el subproceso que realiza la llamada.</target>       </trans-unit>
        <trans-unit id="1104" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.WhenAll``1(System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task{``0}})">
          <source>However, a call to the returned <ph id="ph1">&lt;xref:System.Threading.Tasks.Task%601.Result%2A&gt;</ph> property does block the calling thread.</source>
          <target state="translated">Sin embargo, una llamada a devuelto <ph id="ph1">&lt;xref:System.Threading.Tasks.Task%601.Result%2A&gt;</ph> propiedad bloquea el subproceso que realiza la llamada.</target>       </trans-unit>
        <trans-unit id="1105" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.WhenAll``1(System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task{``0}})">
          <source>If any of the supplied tasks completes in a faulted state, the returned task will also complete in a <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskStatus.Faulted&gt;</ph> state, where its exceptions will contain the aggregation of the set of unwrapped exceptions from each of the supplied tasks.</source>
          <target state="translated">Si cualquiera de las tareas proporcionadas se completa con un estado de error, la tarea devuelta también finalizará con un <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskStatus.Faulted&gt;</ph> estado, donde sus excepciones contendrá la agregación del conjunto de excepciones sin ajustar de cada una de las tareas proporcionadas.</target>       </trans-unit>
        <trans-unit id="1106" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.WhenAll``1(System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task{``0}})">
          <source>If none of the supplied tasks faulted but at least one of them was canceled, the returned task will end in the <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskStatus.Canceled&gt;</ph> state.</source>
          <target state="translated">Si ninguna de las tareas proporcionadas con errores, pero al menos uno de ellos se ha cancelado, la tarea devuelta finalizará en el <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskStatus.Canceled&gt;</ph> estado.</target>       </trans-unit>
        <trans-unit id="1107" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.WhenAll``1(System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task{``0}})">
          <source>If none of the tasks faulted and none of the tasks were canceled, the resulting task will end in the <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskStatus.RanToCompletion&gt;</ph> state.</source>
          <target state="translated">Si ninguna de las tareas con errores y ninguna de las tareas se han cancelado, la tarea resultante finalizará en el <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskStatus.RanToCompletion&gt;</ph> estado.</target>       </trans-unit>
        <trans-unit id="1108" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.WhenAll``1(System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task{``0}})">
          <source>The <ph id="ph1">&lt;xref:System.Threading.Tasks.Task%601.Result%2A?displayProperty=nameWithType&gt;</ph> property of the returned task will be set to an array containing all of the results of the supplied tasks in the same order as they were provided (e.g. if the input tasks array contained t1, t2, t3, the output task's <ph id="ph2">&lt;xref:System.Threading.Tasks.Task%601.Result%2A?displayProperty=nameWithType&gt;</ph> property will return an <ph id="ph3">`TResult[]`</ph> where <ph id="ph4">`arr[0] == t1.Result, arr[1] == t2.Result, and arr[2] == t3.Result)`</ph>.</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.Threading.Tasks.Task%601.Result%2A?displayProperty=nameWithType&gt;</ph> se establecerá la propiedad de la tarea devuelta a una matriz que contiene todos los resultados de las tareas proporcionadas en el mismo orden como se proporcionan (por ejemplo, si la entrada tareas matriz incluida t1, t2, t3, la tarea de salida <ph id="ph2">&lt;xref:System.Threading.Tasks.Task%601.Result%2A?displayProperty=nameWithType&gt;</ph> propiedad devolverá una <ph id="ph3">`TResult[]`</ph> donde <ph id="ph4">`arr[0] == t1.Result, arr[1] == t2.Result, and arr[2] == t3.Result)`</ph>.</target>       </trans-unit>
        <trans-unit id="1109" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.WhenAll``1(System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task{``0}})">
          <source>If the <ph id="ph1">`tasks`</ph> argument contains no tasks, the returned task will immediately transition to a <ph id="ph2">&lt;xref:System.Threading.Tasks.TaskStatus.RanToCompletion&gt;</ph> state before it's returned to the caller.</source>
          <target state="translated">Si el <ph id="ph1">`tasks`</ph> argumento no contiene ninguna tarea, la tarea devuelta cambiará inmediatamente a un <ph id="ph2">&lt;xref:System.Threading.Tasks.TaskStatus.RanToCompletion&gt;</ph> estado antes de que se devuelve al llamador.</target>       </trans-unit>
        <trans-unit id="1110" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.WhenAll``1(System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task{``0}})">
          <source>The returned <ph id="ph1">`TResult[]`</ph> will be an array of 0 elements.</source>
          <target state="translated">El valor devuelto <ph id="ph1">`TResult[]`</ph> será una matriz de 0 elementos.</target>       </trans-unit>
        <trans-unit id="1111" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.WhenAll``1(System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task{``0}})">
          <source>The following example creates ten tasks, each of which instantiates a random number generator that creates 1,000 random numbers between 1 and 1,000 and computes their mean.</source>
          <target state="translated">En el ejemplo siguiente se crea diez tareas, cada uno de los cuales crea una instancia de un generador de números aleatorios que crea 1.000 números aleatorios entre 1 y 1.000 y calcula su Media.</target>       </trans-unit>
        <trans-unit id="1112" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.WhenAll``1(System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task{``0}})">
          <source>The <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Delay%28System.Int32%29&gt;</ph> method is used to delay instantiation of the random number generators so that they are not created with identical seed values.</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Delay%28System.Int32%29&gt;</ph> método se usa para retrasar la creación de instancias de los generadores de números aleatorios para que no se crean con valores de inicialización idénticos.</target>       </trans-unit>
        <trans-unit id="1113" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.WhenAll``1(System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task{``0}})">
          <source>The call to the <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.WhenAll%2A&gt;</ph> method then returns an <ph id="ph2">&lt;xref:System.Int64&gt;</ph> array that contains the mean computed by each task.</source>
          <target state="translated">La llamada a la <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.WhenAll%2A&gt;</ph> método, a continuación, devuelve un <ph id="ph2">&lt;xref:System.Int64&gt;</ph> matriz que contiene el promedio calculado por cada tarea.</target>       </trans-unit>
        <trans-unit id="1114" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.WhenAll``1(System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task{``0}})">
          <source>These are then used to calculate the overall mean.</source>
          <target state="translated">A continuación, estos se utilizan para calcular la media general.</target>       </trans-unit>
        <trans-unit id="1115" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.WhenAll``1(System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task{``0}})">
          <source>In this case, the ten individual tasks are stored in a <ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph> object.</source>
          <target state="translated">En este caso, se almacenan las diez tareas individuales en un <ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph> objeto.</target>       </trans-unit>
        <trans-unit id="1116" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.WhenAll``1(System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task{``0}})">
          <source><ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph> implements the <ph id="ph2">&lt;xref:System.Collections.Generic.IEnumerable%601&gt;</ph> interface.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph> implementa la interfaz <ph id="ph2">&lt;xref:System.Collections.Generic.IEnumerable%601&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1117" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WhenAll``1(System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task{``0}})">
          <source>The <ph id="ph1">&lt;paramref name="tasks" /&gt;</ph> argument was <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">El argumento <ph id="ph1">&lt;paramref name="tasks" /&gt;</ph> era <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1118" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WhenAll``1(System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task{``0}})">
          <source>The <ph id="ph1">&lt;paramref name="tasks" /&gt;</ph> collection contained a <ph id="ph2">&lt;see langword="null" /&gt;</ph> task.</source>
          <target state="translated">La colección <ph id="ph1">&lt;paramref name="tasks" /&gt;</ph> contiene una tarea <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1119" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.WhenAll``1(System.Threading.Tasks.Task{``0}[])">
          <source>The type of the completed task.</source>
          <target state="translated">Tipo de la tarea completada.</target>       </trans-unit>
        <trans-unit id="1120" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WhenAll``1(System.Threading.Tasks.Task{``0}[])">
          <source>The tasks to wait on for completion.</source>
          <target state="translated">Tareas cuya finalización hay que esperar.</target>       </trans-unit>
        <trans-unit id="1121" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WhenAll``1(System.Threading.Tasks.Task{``0}[])">
          <source>Creates a task that will complete when all of the <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task`1" /&gt;</ph> objects in an array have completed.</source>
          <target state="translated">Crea una tarea que se completará cuando todos los objetos <ph id="ph1">&lt;see cref="T:System.Threading.Tasks.Task`1" /&gt;</ph> de una matriz se hayan completado.</target>       </trans-unit>
        <trans-unit id="1122" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WhenAll``1(System.Threading.Tasks.Task{``0}[])">
          <source>A task that represents the completion of all of the supplied tasks.</source>
          <target state="translated">Tarea que representa la finalización de todas las tareas proporcionadas.</target>       </trans-unit>
        <trans-unit id="1123" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.WhenAll``1(System.Threading.Tasks.Task{``0}[])">
          <source>The call to <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.WhenAll%60%601%28System.Threading.Tasks.Task%7B%60%600%7D%5B%5D%29&gt;</ph> method does not block the calling thread.</source>
          <target state="translated">La llamada a <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.WhenAll%60%601%28System.Threading.Tasks.Task%7B%60%600%7D%5B%5D%29&gt;</ph> método no bloquea el subproceso que realiza la llamada.</target>       </trans-unit>
        <trans-unit id="1124" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.WhenAll``1(System.Threading.Tasks.Task{``0}[])">
          <source>However, a call to the returned <ph id="ph1">&lt;xref:System.Threading.Tasks.Task%601.Result%2A&gt;</ph> property does block the calling thread.</source>
          <target state="translated">Sin embargo, una llamada a devuelto <ph id="ph1">&lt;xref:System.Threading.Tasks.Task%601.Result%2A&gt;</ph> propiedad bloquea el subproceso que realiza la llamada.</target>       </trans-unit>
        <trans-unit id="1125" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.WhenAll``1(System.Threading.Tasks.Task{``0}[])">
          <source>If any of the supplied tasks completes in a faulted state, the returned task will also complete in a <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskStatus.Faulted&gt;</ph> state, where its exceptions will contain the aggregation of the set of unwrapped exceptions from each of the supplied tasks.</source>
          <target state="translated">Si cualquiera de las tareas proporcionadas se completa con un estado de error, la tarea devuelta también finalizará con un <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskStatus.Faulted&gt;</ph> estado, donde sus excepciones contendrá la agregación del conjunto de excepciones sin ajustar de cada una de las tareas proporcionadas.</target>       </trans-unit>
        <trans-unit id="1126" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.WhenAll``1(System.Threading.Tasks.Task{``0}[])">
          <source>If none of the supplied tasks faulted but at least one of them was canceled, the returned task will end in the <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskStatus.Canceled&gt;</ph> state.</source>
          <target state="translated">Si ninguna de las tareas proporcionadas con errores, pero al menos uno de ellos se ha cancelado, la tarea devuelta finalizará en el <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskStatus.Canceled&gt;</ph> estado.</target>       </trans-unit>
        <trans-unit id="1127" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.WhenAll``1(System.Threading.Tasks.Task{``0}[])">
          <source>If none of the tasks faulted and none of the tasks were canceled, the resulting task will end in the <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskStatus.RanToCompletion&gt;</ph> state.</source>
          <target state="translated">Si ninguna de las tareas con errores y ninguna de las tareas se han cancelado, la tarea resultante finalizará en el <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskStatus.RanToCompletion&gt;</ph> estado.</target>       </trans-unit>
        <trans-unit id="1128" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.WhenAll``1(System.Threading.Tasks.Task{``0}[])">
          <source>The <ph id="ph1">&lt;xref:System.Threading.Tasks.Task%601.Result%2A&gt;</ph> of the returned task will be set to an array containing all of the results of the supplied tasks in the same order as they were provided (e.g. if the input tasks array contained t1, t2, t3, the output   task's <ph id="ph2">&lt;xref:System.Threading.Tasks.Task%601.Result%2A&gt;</ph> will return an <ph id="ph3">`TResult[]`</ph> where <ph id="ph4">`arr[0] == t1.Result, arr[1] == t2.Result, and arr[2] == t3.Result)`</ph>.</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.Threading.Tasks.Task%601.Result%2A&gt;</ph> de la tarea devuelta se establecerá en una matriz que contiene todos los resultados de las tareas proporcionadas en el mismo orden como se proporcionan (por ejemplo, si la entrada tareas matriz incluida t1, t2, t3, la tarea de salida <ph id="ph2">&lt;xref:System.Threading.Tasks.Task%601.Result%2A&gt;</ph> devolverá un <ph id="ph3">`TResult[]`</ph> donde <ph id="ph4">`arr[0] == t1.Result, arr[1] == t2.Result, and arr[2] == t3.Result)`</ph>.</target>       </trans-unit>
        <trans-unit id="1129" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.WhenAll``1(System.Threading.Tasks.Task{``0}[])">
          <source>If the supplied array/enumerable contains no tasks, the returned task will immediately transition to a <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskStatus.RanToCompletion&gt;</ph> state before it's returned to the caller.</source>
          <target state="translated">Si el proporcionado matriz/enumerable no contenga ninguna tarea, la tarea devuelta cambiará inmediatamente a un <ph id="ph1">&lt;xref:System.Threading.Tasks.TaskStatus.RanToCompletion&gt;</ph> estado antes de que se devuelve al llamador.</target>       </trans-unit>
        <trans-unit id="1130" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.WhenAll``1(System.Threading.Tasks.Task{``0}[])">
          <source>The returned <ph id="ph1">`TResult[]`</ph> will be an array of 0 elements.</source>
          <target state="translated">El valor devuelto <ph id="ph1">`TResult[]`</ph> será una matriz de 0 elementos.</target>       </trans-unit>
        <trans-unit id="1131" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.WhenAll``1(System.Threading.Tasks.Task{``0}[])">
          <source>The following example creates ten tasks, each of which instantiates a random number generator that creates 1,000 random numbers between 1 and 1,000 and computes their mean.</source>
          <target state="translated">En el ejemplo siguiente se crea diez tareas, cada uno de los cuales crea una instancia de un generador de números aleatorios que crea 1.000 números aleatorios entre 1 y 1.000 y calcula su Media.</target>       </trans-unit>
        <trans-unit id="1132" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.WhenAll``1(System.Threading.Tasks.Task{``0}[])">
          <source>In this case, the ten individual tasks are stored in a <ph id="ph1">`Task&lt;Int64&gt;`</ph> array.</source>
          <target state="translated">En este caso, se almacenan las diez tareas individuales en un <ph id="ph1">`Task&lt;Int64&gt;`</ph> matriz.</target>       </trans-unit>
        <trans-unit id="1133" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.WhenAll``1(System.Threading.Tasks.Task{``0}[])">
          <source>The <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Delay%28System.Int32%29&gt;</ph> method is used to delay instantiation of the random number generators so that they are not created with identical seed values.</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.Delay%28System.Int32%29&gt;</ph> método se usa para retrasar la creación de instancias de los generadores de números aleatorios para que no se crean con valores de inicialización idénticos.</target>       </trans-unit>
        <trans-unit id="1134" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.WhenAll``1(System.Threading.Tasks.Task{``0}[])">
          <source>The call to the <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.WhenAll%2A&gt;</ph> method then returns an <ph id="ph2">&lt;xref:System.Int64&gt;</ph> array that contains the mean computed by each task.</source>
          <target state="translated">La llamada a la <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.WhenAll%2A&gt;</ph> método, a continuación, devuelve un <ph id="ph2">&lt;xref:System.Int64&gt;</ph> matriz que contiene el promedio calculado por cada tarea.</target>       </trans-unit>
        <trans-unit id="1135" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.WhenAll``1(System.Threading.Tasks.Task{``0}[])">
          <source>These are then used to calculate the overall mean.</source>
          <target state="translated">A continuación, estos se utilizan para calcular la media general.</target>       </trans-unit>
        <trans-unit id="1136" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WhenAll``1(System.Threading.Tasks.Task{``0}[])">
          <source>The <ph id="ph1">&lt;paramref name="tasks" /&gt;</ph> argument was <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">El argumento <ph id="ph1">&lt;paramref name="tasks" /&gt;</ph> era <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1137" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WhenAll``1(System.Threading.Tasks.Task{``0}[])">
          <source>The <ph id="ph1">&lt;paramref name="tasks" /&gt;</ph> array contained a <ph id="ph2">&lt;see langword="null" /&gt;</ph> task.</source>
          <target state="translated">La matriz <ph id="ph1">&lt;paramref name="tasks" /&gt;</ph> contiene una tarea <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1138" translate="yes" xml:space="preserve" uid="T:System.Threading.Tasks.Task">
          <source>Creates a task that will complete when any of the supplied tasks have completed.</source>
          <target state="translated">Crea una tarea que finalizará cuando se haya completado cualquiera de las tareas proporcionadas.</target>       </trans-unit>
        <trans-unit id="1139" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WhenAny(System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task})">
          <source>The tasks to wait on for completion.</source>
          <target state="translated">Tareas cuya finalización hay que esperar.</target>       </trans-unit>
        <trans-unit id="1140" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WhenAny(System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task})">
          <source>Creates a task that will complete when any of the supplied tasks have completed.</source>
          <target state="translated">Crea una tarea que finalizará cuando se haya completado cualquiera de las tareas proporcionadas.</target>       </trans-unit>
        <trans-unit id="1141" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WhenAny(System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task})">
          <source>A task that represents the completion of one of the supplied tasks.</source>
          <target state="translated">Tarea que representa la finalización de una de las tareas proporcionadas.</target>       </trans-unit>
        <trans-unit id="1142" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WhenAny(System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task})">
          <source>The return task's Result is the task that completed.</source>
          <target state="translated">El resultado de la tarea devuelto es la tarea completada.</target>       </trans-unit>
        <trans-unit id="1143" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.WhenAny(System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task})">
          <source>The returned task will complete when any of the supplied tasks has completed.</source>
          <target state="translated">La tarea devuelta completará cuando haya completado cualquiera de las tareas proporcionadas.</target>       </trans-unit>
        <trans-unit id="1144" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.WhenAny(System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task})">
          <source>The returned task will always end in the <ph id="ph1">`RanToCompletion`</ph> state  with its Result set to the first task to complete.</source>
          <target state="translated">La tarea devuelta finalizará siempre en el <ph id="ph1">`RanToCompletion`</ph> estado con su conjunto de resultados a la primera tarea para completar.</target>       </trans-unit>
        <trans-unit id="1145" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.WhenAny(System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task})">
          <source>This is true even if the first task to complete ended in the <ph id="ph1">`Canceled`</ph> or <ph id="ph2">`Faulted`</ph> state.</source>
          <target state="translated">Esto es cierto incluso si ha finalizado la primera tarea para completar con el <ph id="ph1">`Canceled`</ph> o <ph id="ph2">`Faulted`</ph> estado.</target>       </trans-unit>
        <trans-unit id="1146" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WhenAny(System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task})">
          <source>The <ph id="ph1">&lt;paramref name="tasks" /&gt;</ph> argument was <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">El argumento <ph id="ph1">&lt;paramref name="tasks" /&gt;</ph> era <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1147" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WhenAny(System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task})">
          <source>The <ph id="ph1">&lt;paramref name="tasks" /&gt;</ph> array contained a null task, or was empty.</source>
          <target state="translated">La matriz <ph id="ph1">&lt;paramref name="tasks" /&gt;</ph> contenía una tarea NULL o estaba vacía.</target>       </trans-unit>
        <trans-unit id="1148" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WhenAny(System.Threading.Tasks.Task[])">
          <source>The tasks to wait on for completion.</source>
          <target state="translated">Tareas cuya finalización hay que esperar.</target>       </trans-unit>
        <trans-unit id="1149" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WhenAny(System.Threading.Tasks.Task[])">
          <source>Creates a task that will complete when any of the supplied tasks have completed.</source>
          <target state="translated">Crea una tarea que finalizará cuando se haya completado cualquiera de las tareas proporcionadas.</target>       </trans-unit>
        <trans-unit id="1150" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WhenAny(System.Threading.Tasks.Task[])">
          <source>A task that represents the completion of one of the supplied tasks.</source>
          <target state="translated">Tarea que representa la finalización de una de las tareas proporcionadas.</target>       </trans-unit>
        <trans-unit id="1151" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WhenAny(System.Threading.Tasks.Task[])">
          <source>The return task's Result is the task that completed.</source>
          <target state="translated">El resultado de la tarea devuelto es la tarea completada.</target>       </trans-unit>
        <trans-unit id="1152" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.WhenAny(System.Threading.Tasks.Task[])">
          <source>The returned task will complete when any of the supplied tasks has completed.</source>
          <target state="translated">La tarea devuelta completará cuando haya completado cualquiera de las tareas proporcionadas.</target>       </trans-unit>
        <trans-unit id="1153" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.WhenAny(System.Threading.Tasks.Task[])">
          <source>The returned task will always end in the <ph id="ph1">`RanToCompletion`</ph> state   with its <ph id="ph2">`Result`</ph> set to the first task to complete.</source>
          <target state="translated">La tarea devuelta finalizará siempre en el <ph id="ph1">`RanToCompletion`</ph> estado con su <ph id="ph2">`Result`</ph> se establece en la primera tarea para completar.</target>       </trans-unit>
        <trans-unit id="1154" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.WhenAny(System.Threading.Tasks.Task[])">
          <source>This is true even if the first task to complete ended in the <ph id="ph1">`Canceled`</ph> or <ph id="ph2">`Faulted`</ph> state.</source>
          <target state="translated">Esto es cierto incluso si ha finalizado la primera tarea para completar con el <ph id="ph1">`Canceled`</ph> o <ph id="ph2">`Faulted`</ph> estado.</target>       </trans-unit>
        <trans-unit id="1155" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WhenAny(System.Threading.Tasks.Task[])">
          <source>The <ph id="ph1">&lt;paramref name="tasks" /&gt;</ph> argument was null.</source>
          <target state="translated">El argumento de <ph id="ph1">&lt;paramref name="tasks" /&gt;</ph> fue nulo.</target>       </trans-unit>
        <trans-unit id="1156" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WhenAny(System.Threading.Tasks.Task[])">
          <source>The <ph id="ph1">&lt;paramref name="tasks" /&gt;</ph> array contained a null task, or was empty.</source>
          <target state="translated">La matriz <ph id="ph1">&lt;paramref name="tasks" /&gt;</ph> contenía una tarea NULL o estaba vacía.</target>       </trans-unit>
        <trans-unit id="1157" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.WhenAny``1(System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task{``0}})">
          <source>The type of the completed task.</source>
          <target state="translated">Tipo de la tarea completada.</target>       </trans-unit>
        <trans-unit id="1158" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WhenAny``1(System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task{``0}})">
          <source>The tasks to wait on for completion.</source>
          <target state="translated">Tareas cuya finalización hay que esperar.</target>       </trans-unit>
        <trans-unit id="1159" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WhenAny``1(System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task{``0}})">
          <source>Creates a task that will complete when any of the supplied tasks have completed.</source>
          <target state="translated">Crea una tarea que finalizará cuando se haya completado cualquiera de las tareas proporcionadas.</target>       </trans-unit>
        <trans-unit id="1160" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WhenAny``1(System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task{``0}})">
          <source>A task that represents the completion of one of the supplied tasks.</source>
          <target state="translated">Tarea que representa la finalización de una de las tareas proporcionadas.</target>       </trans-unit>
        <trans-unit id="1161" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WhenAny``1(System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task{``0}})">
          <source>The return task's Result is the task that completed.</source>
          <target state="translated">El resultado de la tarea devuelto es la tarea completada.</target>       </trans-unit>
        <trans-unit id="1162" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.WhenAny``1(System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task{``0}})">
          <source>The returned task will complete when any of the supplied tasks has completed.</source>
          <target state="translated">La tarea devuelta completará cuando haya completado cualquiera de las tareas proporcionadas.</target>       </trans-unit>
        <trans-unit id="1163" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.WhenAny``1(System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task{``0}})">
          <source>The returned task will always end in the RanToCompletion state with its Result set to the first task to complete.</source>
          <target state="translated">La tarea devuelta finalizará siempre en el estado RanToCompletion con su conjunto de resultados a la primera tarea para completar.</target>       </trans-unit>
        <trans-unit id="1164" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.WhenAny``1(System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task{``0}})">
          <source>This is true even if the first task to complete ended in the Canceled or Faulted state.</source>
          <target state="translated">Esto es cierto incluso si ha finalizado la primera tarea para completar con el estado cancelado o con errores.</target>       </trans-unit>
        <trans-unit id="1165" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WhenAny``1(System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task{``0}})">
          <source>The <ph id="ph1">&lt;paramref name="tasks" /&gt;</ph> argument was <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">El argumento <ph id="ph1">&lt;paramref name="tasks" /&gt;</ph> era <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1166" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WhenAny``1(System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task{``0}})">
          <source>The <ph id="ph1">&lt;paramref name="tasks" /&gt;</ph> array contained a null task, or was empty.</source>
          <target state="translated">La matriz <ph id="ph1">&lt;paramref name="tasks" /&gt;</ph> contenía una tarea NULL o estaba vacía.</target>       </trans-unit>
        <trans-unit id="1167" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.WhenAny``1(System.Threading.Tasks.Task{``0}[])">
          <source>The type of the completed task.</source>
          <target state="translated">Tipo de la tarea completada.</target>       </trans-unit>
        <trans-unit id="1168" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WhenAny``1(System.Threading.Tasks.Task{``0}[])">
          <source>The tasks to wait on for completion.</source>
          <target state="translated">Tareas cuya finalización hay que esperar.</target>       </trans-unit>
        <trans-unit id="1169" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WhenAny``1(System.Threading.Tasks.Task{``0}[])">
          <source>Creates a task that will complete when any of the supplied tasks have completed.</source>
          <target state="translated">Crea una tarea que finalizará cuando se haya completado cualquiera de las tareas proporcionadas.</target>       </trans-unit>
        <trans-unit id="1170" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WhenAny``1(System.Threading.Tasks.Task{``0}[])">
          <source>A task that represents the completion of one of the supplied tasks.</source>
          <target state="translated">Tarea que representa la finalización de una de las tareas proporcionadas.</target>       </trans-unit>
        <trans-unit id="1171" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WhenAny``1(System.Threading.Tasks.Task{``0}[])">
          <source>The return task's Result is the task that completed.</source>
          <target state="translated">El resultado de la tarea devuelto es la tarea completada.</target>       </trans-unit>
        <trans-unit id="1172" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.WhenAny``1(System.Threading.Tasks.Task{``0}[])">
          <source>The returned task will complete when any of the supplied tasks has completed.</source>
          <target state="translated">La tarea devuelta completará cuando haya completado cualquiera de las tareas proporcionadas.</target>       </trans-unit>
        <trans-unit id="1173" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.WhenAny``1(System.Threading.Tasks.Task{``0}[])">
          <source>The returned task will always end in the RanToCompletion state with its Result set to the first task to complete.</source>
          <target state="translated">La tarea devuelta finalizará siempre en el estado RanToCompletion con su conjunto de resultados a la primera tarea para completar.</target>       </trans-unit>
        <trans-unit id="1174" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.WhenAny``1(System.Threading.Tasks.Task{``0}[])">
          <source>This is true even if the first task to complete ended in the Canceled or Faulted state.</source>
          <target state="translated">Esto es cierto incluso si ha finalizado la primera tarea para completar con el estado cancelado o con errores.</target>       </trans-unit>
        <trans-unit id="1175" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WhenAny``1(System.Threading.Tasks.Task{``0}[])">
          <source>The <ph id="ph1">&lt;paramref name="tasks" /&gt;</ph> argument was null.</source>
          <target state="translated">El argumento de <ph id="ph1">&lt;paramref name="tasks" /&gt;</ph> fue nulo.</target>       </trans-unit>
        <trans-unit id="1176" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.WhenAny``1(System.Threading.Tasks.Task{``0}[])">
          <source>The <ph id="ph1">&lt;paramref name="tasks" /&gt;</ph> array contained a null task, or was empty.</source>
          <target state="translated">La matriz <ph id="ph1">&lt;paramref name="tasks" /&gt;</ph> contenía una tarea NULL o estaba vacía.</target>       </trans-unit>
        <trans-unit id="1177" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Yield">
          <source>Creates an awaitable task that asynchronously yields back to the current context when awaited.</source>
          <target state="translated">Crea una tarea que admite "await" que, de forma asincrónica, devuelve al contexto actual cuando es "awaited".</target>       </trans-unit>
        <trans-unit id="1178" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Yield">
          <source>A context that, when awaited, will asynchronously transition back into the current context at the time of the await.</source>
          <target state="translated">Contexto que, cuando se espera, hará la transición de vuelta de forma asincrónica en el contexto actual en el momento de la espera.</target>       </trans-unit>
        <trans-unit id="1179" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Yield">
          <source>If the current <ph id="ph1">&lt;see cref="T:System.Threading.SynchronizationContext" /&gt;</ph> is non-null, it is treated as the current context.</source>
          <target state="translated">Si el objeto <ph id="ph1">&lt;see cref="T:System.Threading.SynchronizationContext" /&gt;</ph> actual no es null, se trata como el contexto actual.</target>       </trans-unit>
        <trans-unit id="1180" translate="yes" xml:space="preserve" uid="M:System.Threading.Tasks.Task.Yield">
          <source>Otherwise, the task scheduler that is associated with the currently executing task is treated as the current context.</source>
          <target state="translated">Si no, el programador de tareas que está asociado a la tarea que se está ejecutando actualmente se trata como el contexto actual.</target>       </trans-unit>
        <trans-unit id="1181" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Yield">
          <source>You can use <ph id="ph1">`await Task.Yield();`</ph> in an asynchronous method to force the method to complete asynchronously.</source>
          <target state="translated">Puede usar <ph id="ph1">`await Task.Yield();`</ph> en un método asincrónico para aplicar el método para completar de forma asincrónica.</target>       </trans-unit>
        <trans-unit id="1182" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Yield">
          <source>If there is a current synchronization context (<ph id="ph1">&lt;xref:System.Threading.SynchronizationContext&gt;</ph> object), this will post the remainder of the method’s execution back to that context.</source>
          <target state="translated">Si no hay un contexto de sincronización actual (<ph id="ph1">&lt;xref:System.Threading.SynchronizationContext&gt;</ph> objeto), se registrará el resto de la ejecución del método a ese contexto.</target>       </trans-unit>
        <trans-unit id="1183" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Yield">
          <source>However, the context will decide how to prioritize this work relative to other work that may be pending.</source>
          <target state="translated">Sin embargo, el contexto que decida cómo asignar prioridades a este trabajo en relación con otro trabajo que puede estar pendiente.</target>       </trans-unit>
        <trans-unit id="1184" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Yield">
          <source>The synchronization context that is present on a UI thread in most UI environments will often prioritize work posted to the context higher than input and rendering work.</source>
          <target state="translated">El contexto de sincronización que se encuentra en un subproceso de interfaz de usuario en la mayoría de los entornos de interfaz de usuario a menudo priorizar el trabajo que se publican en el contexto de mayor que la entrada y el trabajo de representación.</target>       </trans-unit>
        <trans-unit id="1185" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Yield">
          <source>For this reason, do not rely on <ph id="ph1">`await Task.Yield();`</ph> to keep a UI responsive.</source>
          <target state="translated">Por esta razón, no debe confiar en que <ph id="ph1">`await Task.Yield();`</ph> que una interfaz de usuario siga respondiendo.</target>       </trans-unit>
        <trans-unit id="1186" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.Tasks.Task.Yield">
          <source>For more information, see the entry <bpt id="p1">[</bpt>Useful Abstractions Enabled with ContinueWith<ept id="p1">](http://blogs.msdn.com/b/pfxteam/archive/2008/07/23/8768673.aspx)</ept> in the Parallel Programming with .NET blog.</source>
          <target state="translated">Para obtener más información, vea la entrada <bpt id="p1">[</bpt>útil abstracciones habilitada con el método ContinueWith<ept id="p1">](http://blogs.msdn.com/b/pfxteam/archive/2008/07/23/8768673.aspx)</ept> en la programación en paralelo con .NET blog.</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>