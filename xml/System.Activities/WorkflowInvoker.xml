<Type Name="WorkflowInvoker" FullName="System.Activities.WorkflowInvoker">
  <Metadata><Meta Name="ms.openlocfilehash" Value="73cad7482ec89c2404cb253c90cebeaaff316196" /><Meta Name="ms.sourcegitcommit" Value="0e1f030650a307c745ee84ed547ef858acaea587" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="es-ES" /><Meta Name="ms.lasthandoff" Value="11/29/2018" /><Meta Name="ms.locfileid" Value="52590236" /></Metadata><TypeSignature Language="C#" Value="public sealed class WorkflowInvoker" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit WorkflowInvoker extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Activities.WorkflowInvoker" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class WorkflowInvoker" />
  <TypeSignature Language="C++ CLI" Value="public ref class WorkflowInvoker sealed" />
  <TypeSignature Language="F#" Value="type WorkflowInvoker = class" />
  <AssemblyInfo>
    <AssemblyName>System.Activities</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Proporciona un medio para invocar un flujo de trabajo como si fuera una llamada a método.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La clase <xref:System.Activities.WorkflowInvoker> contiene métodos tanto de instancia como estáticos para invocar flujos de trabajo sincrónicamente y métodos de instancia para invocarlos de forma asincrónica.  
  
 La clase <xref:System.Activities.WorkflowInvoker> no permite el control de instancias, por ejemplo, almacenar, descargar o reanudar marcadores. Si se desea realizar un control de instancias, use <xref:System.Activities.WorkflowApplication> en su lugar.  
  
 Para ejecutar flujos de trabajo sincrónicamente sin control de instancias, llame al método <xref:System.Activities.WorkflowInvoker.Invoke%2A>. Para ejecutar un flujo de trabajo de forma asincrónica sin control de instancias, use los métodos <xref:System.Activities.WorkflowInvoker.BeginInvoke%2A> y <xref:System.Activities.WorkflowInvoker.EndInvoke%2A> o el método <xref:System.Activities.WorkflowInvoker.InvokeAsync%2A>.  
  
   
  
## Examples  
 En el siguiente ejemplo se invoca sincrónicamente un flujo de trabajo formado por una sola actividad de la clase <xref:System.Activities.Statements.WriteLine> mediante la clase <xref:System.Activities.WorkflowInvoker>.  
  
 [!code-csharp[CFX_WorkflowInvokerExample#1](~/samples/snippets/csharp/VS_Snippets_CFX/cfx_workflowinvokerexample/cs/program.cs#1)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public WorkflowInvoker (System.Activities.Activity workflow);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Activities.Activity workflow) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowInvoker.#ctor(System.Activities.Activity)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (workflow As Activity)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; WorkflowInvoker(System::Activities::Activity ^ workflow);" />
      <MemberSignature Language="F#" Value="new System.Activities.WorkflowInvoker : System.Activities.Activity -&gt; System.Activities.WorkflowInvoker" Usage="new System.Activities.WorkflowInvoker workflow" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="workflow" Type="System.Activities.Activity" />
      </Parameters>
      <Docs>
        <param name="workflow">La definición del flujo de trabajo que va a invocar esta instancia de la clase <see cref="T:System.Activities.WorkflowInvoker" />.</param>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Activities.WorkflowInvoker" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La clase <xref:System.Activities.WorkflowInvoker> contiene métodos tanto de instancia como estáticos para invocar flujos de trabajo sincrónicamente y métodos de instancia para invocarlos de forma asincrónica.  
  
   
  
## Examples  
 En el siguiente ejemplo se invoca un flujo de trabajo formado por una sola actividad <xref:System.Activities.Statements.WriteLine>.  
  
 [!code-csharp[CFX_WorkflowInvokerExample#2](~/samples/snippets/csharp/VS_Snippets_CFX/cfx_workflowinvokerexample/cs/program.cs#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginInvoke">
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Invoca de forma asincrónica un flujo de trabajo usando el modelo de diseño asincrónico de la interfaz <see cref="T:System.IAsyncResult" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para obtener más información, consulte [Asynchronous Programming Overview](~/docs/standard/asynchronous-programming-patterns/asynchronous-programming-model-apm.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginInvoke">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginInvoke (AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginInvoke(class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowInvoker.BeginInvoke(System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginInvoke (callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginInvoke(AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginInvoke : AsyncCallback * obj -&gt; IAsyncResult" Usage="workflowInvoker.BeginInvoke (callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="callback">El método al que llamar cuando se ha completado el flujo de trabajo.</param>
        <param name="state">Objeto opcional específico de la aplicación que contiene información sobre la operación asincrónica.</param>
        <summary>Invoca un flujo de trabajo de forma asincrónica usando el objeto <see cref="T:System.AsyncCallback" /> especificado y el estado proporcionado por el usuario.</summary>
        <returns>Referencia a la operación de invocación asincrónica.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para recibir una notificación cuando se complete el flujo de trabajo y recuperar los parámetros de salida de dicho flujo de trabajo, llame a <xref:System.Activities.WorkflowInvoker.EndInvoke%2A> desde el método `callback`. Si se llama al método <xref:System.Activities.WorkflowInvoker.EndInvoke%2A> antes de que se complete el flujo de trabajo, la llamada queda bloqueada hasta que se completa el flujo de trabajo. Para configurar un intervalo de tiempo de espera en el que se debe completar el flujo de trabajo, use una de las sobrecargas <xref:System.Activities.WorkflowInvoker.BeginInvoke%2A> que toman una estructura <xref:System.TimeSpan>.  
  
 Este método invoca de forma asincrónica un flujo de trabajo usando el modelo de diseño asincrónico de la interfaz <xref:System.IAsyncResult>. Para obtener más información, consulte [Asynchronous Programming Overview](~/docs/standard/asynchronous-programming-patterns/asynchronous-programming-model-apm.md).  
  
   
  
## Examples  
 En el siguiente ejemplo se invoca un flujo de trabajo formado por una actividad `LongRunningDiceRoll`. La actividad `LongRunningDiceRoll` tiene dos argumentos de salida que representan los resultados de la operación de tirar los dados. Se recuperan llamando al método <xref:System.Activities.WorkflowInvoker.EndInvoke%2A>. Cuando la llamada al método <xref:System.Activities.WorkflowInvoker.EndInvoke%2A> devuelve resultados, cada uno de los argumentos de salida se devuelve en el diccionario de salidas, ordenados por nombre de argumento.  
  
 [!code-csharp[CFX_WorkflowInvokerExample#131](~/samples/snippets/csharp/VS_Snippets_CFX/cfx_workflowinvokerexample/cs/program.cs#131)]  
  
 [!code-csharp[CFX_WorkflowInvokerExample#32](~/samples/snippets/csharp/VS_Snippets_CFX/cfx_workflowinvokerexample/cs/program.cs#32)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginInvoke">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginInvoke (System.Collections.Generic.IDictionary&lt;string,object&gt; inputs, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginInvoke(class System.Collections.Generic.IDictionary`2&lt;string, object&gt; inputs, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowInvoker.BeginInvoke(System.Collections.Generic.IDictionary{System.String,System.Object},System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginInvoke (inputs As IDictionary(Of String, Object), callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginInvoke(System::Collections::Generic::IDictionary&lt;System::String ^, System::Object ^&gt; ^ inputs, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginInvoke : System.Collections.Generic.IDictionary&lt;string, obj&gt; * AsyncCallback * obj -&gt; IAsyncResult" Usage="workflowInvoker.BeginInvoke (inputs, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="inputs" Type="System.Collections.Generic.IDictionary&lt;System.String,System.Object&gt;" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="inputs">El diccionario de parámetros de entrada para el flujo de trabajo, ordenados por nombre de argumento.</param>
        <param name="callback">El método al que llamar cuando se ha completado el flujo de trabajo.</param>
        <param name="state">Objeto opcional específico de la aplicación que contiene información sobre la operación asincrónica.</param>
        <summary>Invoca un flujo de trabajo de forma asincrónica utilizando el diccionario de parámetros de entrada <see cref="T:System.Collections.Generic.IDictionary`2" /> especificado, el delegado <see cref="T:System.AsyncCallback" /> y el estado proporcionado por el usuario.</summary>
        <returns>Referencia a la operación de invocación asincrónica.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para recibir una notificación cuando se complete el flujo de trabajo y recuperar los parámetros de salida de dicho flujo de trabajo, llame a <xref:System.Activities.WorkflowInvoker.EndInvoke%2A> desde el método `callback`. Si se llama al método <xref:System.Activities.WorkflowInvoker.EndInvoke%2A> antes de que se complete el flujo de trabajo, la llamada queda bloqueada hasta que se completa el flujo de trabajo.  Para configurar un intervalo de tiempo de espera en el que se debe completar el flujo de trabajo, use una de las sobrecargas <xref:System.Activities.WorkflowInvoker.BeginInvoke%2A> que toman una estructura <xref:System.TimeSpan>.  
  
 Este método invoca de forma asincrónica un flujo de trabajo usando el modelo de diseño asincrónico de la interfaz <xref:System.IAsyncResult>. Para obtener más información, consulte [Asynchronous Programming Overview](~/docs/standard/asynchronous-programming-patterns/asynchronous-programming-model-apm.md).  
  
   
  
## Examples  
 En el siguiente ejemplo se invoca un flujo de trabajo formado por una actividad `LongRunningDiceRoll`. La actividad `LongRunningDiceRoll` tiene dos argumentos de salida que representan los resultados de la operación de tirar los dados. Se recuperan llamando al método <xref:System.Activities.WorkflowInvoker.EndInvoke%2A>. Cuando la llamada al método <xref:System.Activities.WorkflowInvoker.EndInvoke%2A> devuelve resultados, cada uno de los argumentos de salida se devuelve en el diccionario de salidas, ordenados por nombre de argumento.  
  
 [!code-csharp[CFX_WorkflowInvokerExample#131](~/samples/snippets/csharp/VS_Snippets_CFX/cfx_workflowinvokerexample/cs/program.cs#131)]  
  
 [!code-csharp[CFX_WorkflowInvokerExample#32](~/samples/snippets/csharp/VS_Snippets_CFX/cfx_workflowinvokerexample/cs/program.cs#32)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginInvoke">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginInvoke (TimeSpan timeout, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginInvoke(valuetype System.TimeSpan timeout, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowInvoker.BeginInvoke(System.TimeSpan,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginInvoke (timeout As TimeSpan, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginInvoke(TimeSpan timeout, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginInvoke : TimeSpan * AsyncCallback * obj -&gt; IAsyncResult" Usage="workflowInvoker.BeginInvoke (timeout, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="timeout">Intervalo de tiempo en el que se debe completar el flujo de trabajo antes de quedar anulado y de que se produzca una excepción <see cref="T:System.TimeoutException" />.</param>
        <param name="callback">El método al que llamar cuando se ha completado el flujo de trabajo.</param>
        <param name="state">Objeto opcional específico de la aplicación que contiene información sobre la operación asincrónica.</param>
        <summary>Invoca un flujo de trabajo de forma asincrónica usando el intervalo de tiempo de espera, el delegado <see cref="T:System.AsyncCallback" /> y el estado proporcionado por el usuario especificados.</summary>
        <returns>Referencia a la operación de invocación asincrónica.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para recibir una notificación cuando se complete el flujo de trabajo y recuperar los parámetros de salida de dicho flujo de trabajo, llame a <xref:System.Activities.WorkflowInvoker.EndInvoke%2A> desde el método `callback`. Si se llama al método <xref:System.Activities.WorkflowInvoker.EndInvoke%2A> antes de que se complete el flujo de trabajo, la llamada queda bloqueada hasta que se completa el flujo de trabajo. Si el flujo de trabajo no se completa dentro del intervalo de tiempo de espera especificado, se anula el flujo de trabajo y se produce una excepción <xref:System.TimeoutException> cuando se llama al método <xref:System.Activities.WorkflowInvoker.EndInvoke%2A>.  
  
> [!NOTE]
>  La excepción <xref:System.TimeoutException> solo se produce si se agota el tiempo de espera y el flujo de trabajo queda inactivo durante la ejecución. Un flujo de trabajo que tarda en completarse más tiempo que el especificado por el intervalo de tiempo de espera se completa correctamente si el flujo de trabajo no queda inactivo.  
  
 Este método invoca de forma asincrónica un flujo de trabajo usando el modelo de diseño asincrónico de la interfaz <xref:System.IAsyncResult>. Para obtener más información, consulte [Asynchronous Programming Overview](~/docs/standard/asynchronous-programming-patterns/asynchronous-programming-model-apm.md).  
  
   
  
## Examples  
 En el siguiente ejemplo se invoca un flujo de trabajo formado por una actividad `LongRunningDiceRoll`. La actividad `LongRunningDiceRoll` tiene dos argumentos de salida que representan los resultados de la operación de tirar los dados. Se recuperan llamando al método <xref:System.Activities.WorkflowInvoker.EndInvoke%2A>. Cuando la llamada al método <xref:System.Activities.WorkflowInvoker.EndInvoke%2A> devuelve resultados, cada uno de los argumentos de salida se devuelve en el diccionario de salidas, ordenados por nombre de argumento.  
  
 [!code-csharp[CFX_WorkflowInvokerExample#131](~/samples/snippets/csharp/VS_Snippets_CFX/cfx_workflowinvokerexample/cs/program.cs#131)]  
  
 [!code-csharp[CFX_WorkflowInvokerExample#32](~/samples/snippets/csharp/VS_Snippets_CFX/cfx_workflowinvokerexample/cs/program.cs#32)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginInvoke">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginInvoke (System.Collections.Generic.IDictionary&lt;string,object&gt; inputs, TimeSpan timeout, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginInvoke(class System.Collections.Generic.IDictionary`2&lt;string, object&gt; inputs, valuetype System.TimeSpan timeout, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowInvoker.BeginInvoke(System.Collections.Generic.IDictionary{System.String,System.Object},System.TimeSpan,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginInvoke (inputs As IDictionary(Of String, Object), timeout As TimeSpan, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginInvoke(System::Collections::Generic::IDictionary&lt;System::String ^, System::Object ^&gt; ^ inputs, TimeSpan timeout, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginInvoke : System.Collections.Generic.IDictionary&lt;string, obj&gt; * TimeSpan * AsyncCallback * obj -&gt; IAsyncResult" Usage="workflowInvoker.BeginInvoke (inputs, timeout, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="inputs" Type="System.Collections.Generic.IDictionary&lt;System.String,System.Object&gt;" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="inputs">El diccionario de parámetros de entrada para el flujo de trabajo, ordenados por nombre de argumento.</param>
        <param name="timeout">Intervalo de tiempo en el que se debe completar el flujo de trabajo antes de quedar anulado y de que se produzca una excepción <see cref="T:System.TimeoutException" />.</param>
        <param name="callback">El método al que llamar cuando se ha completado el flujo de trabajo.</param>
        <param name="state">Objeto opcional específico de la aplicación que contiene información sobre la operación asincrónica.</param>
        <summary>Invoca un flujo de trabajo de forma asincrónica usando la interfaz <see cref="T:System.Collections.Generic.IDictionary`2" /> de parámetros de entrada, el intervalo de tiempo de espera, el delegado <see cref="T:System.AsyncCallback" /> y el estado proporcionado por el usuario especificados.</summary>
        <returns>Referencia a la operación de invocación asincrónica.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para recibir una notificación cuando se complete el flujo de trabajo y recuperar los parámetros de salida de dicho flujo de trabajo, llame a <xref:System.Activities.WorkflowInvoker.EndInvoke%2A> desde el método `callback`. Si se llama al método <xref:System.Activities.WorkflowInvoker.EndInvoke%2A> antes de que se complete el flujo de trabajo, la llamada queda bloqueada hasta que se completa el flujo de trabajo. Si el flujo de trabajo no se completa dentro del intervalo de tiempo de espera especificado, se anula el flujo de trabajo y se produce una excepción <xref:System.TimeoutException> cuando se llama a <xref:System.Activities.WorkflowInvoker.EndInvoke%2A>.  
  
> [!NOTE]
>  La excepción <xref:System.TimeoutException> solo se produce si se agota el tiempo de espera y el flujo de trabajo queda inactivo durante la ejecución. Un flujo de trabajo que tarda en completarse más tiempo que el especificado por el intervalo de tiempo de espera se completa correctamente si el flujo de trabajo no queda inactivo.  
  
 Este método invoca de forma asincrónica un flujo de trabajo usando el modelo de diseño asincrónico de la interfaz <xref:System.IAsyncResult>. Para obtener más información, consulte [Asynchronous Programming Overview](~/docs/standard/asynchronous-programming-patterns/asynchronous-programming-model-apm.md).  
  
   
  
## Examples  
 En el siguiente ejemplo se invoca un flujo de trabajo formado por una actividad `LongRunningDiceRoll`. La actividad `LongRunningDiceRoll` tiene dos argumentos de salida que representan los resultados de la operación de tirar los dados. Se recuperan llamando al método <xref:System.Activities.WorkflowInvoker.EndInvoke%2A>. Cuando la llamada al método <xref:System.Activities.WorkflowInvoker.EndInvoke%2A> devuelve resultados, cada uno de los argumentos de salida se devuelve en el diccionario de salidas, ordenados por nombre de argumento.  
  
 [!code-csharp[CFX_WorkflowInvokerExample#131](~/samples/snippets/csharp/VS_Snippets_CFX/cfx_workflowinvokerexample/cs/program.cs#131)]  
  
 [!code-csharp[CFX_WorkflowInvokerExample#32](~/samples/snippets/csharp/VS_Snippets_CFX/cfx_workflowinvokerexample/cs/program.cs#32)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CancelAsync">
      <MemberSignature Language="C#" Value="public void CancelAsync (object userState);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CancelAsync(object userState) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowInvoker.CancelAsync(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub CancelAsync (userState As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CancelAsync(System::Object ^ userState);" />
      <MemberSignature Language="F#" Value="member this.CancelAsync : obj -&gt; unit" Usage="workflowInvoker.CancelAsync userState" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="userState" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="userState">El token para cancelar el flujo de trabajo.</param>
        <summary>Intenta cancelar el flujo de trabajo que se invocó con el parámetro <paramref name="userState" /> especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Solo se pueden cancelar los flujos de trabajo invocados por una de las sobrecargas de <xref:System.Activities.WorkflowInvoker.InvokeAsync%2A> que toma un parámetro `userState`.  
  
 Si se realiza correctamente la cancelación, el <xref:System.ComponentModel.AsyncCompletedEventArgs.Cancelled%2A> propiedad de la <xref:System.Activities.InvokeCompletedEventArgs> pasa a la <xref:System.Activities.WorkflowInvoker.InvokeCompleted> configuración del controlador de `true`; en caso contrario, se establece en `false`.  
  
   
  
## Examples  
 En el siguiente ejemplo se invoca un flujo de trabajo formado por una actividad `LongRunningDiceRoll`. La actividad `LongRunningDiceRoll` tiene dos argumentos de salida que representan los resultados de la operación de tirar los dados. Una vez invocado el flujo de trabajo, el host intenta cancelarlo.  
  
 [!code-csharp[CFX_WorkflowInvokerExample#131](~/samples/snippets/csharp/VS_Snippets_CFX/cfx_workflowinvokerexample/cs/program.cs#131)]  
  
 [!code-csharp[CFX_WorkflowInvokerExample#34](~/samples/snippets/csharp/VS_Snippets_CFX/cfx_workflowinvokerexample/cs/program.cs#34)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EndInvoke">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IDictionary&lt;string,object&gt; EndInvoke (IAsyncResult result);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.IDictionary`2&lt;string, object&gt; EndInvoke(class System.IAsyncResult result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowInvoker.EndInvoke(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndInvoke (result As IAsyncResult) As IDictionary(Of String, Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::IDictionary&lt;System::String ^, System::Object ^&gt; ^ EndInvoke(IAsyncResult ^ result);" />
      <MemberSignature Language="F#" Value="member this.EndInvoke : IAsyncResult -&gt; System.Collections.Generic.IDictionary&lt;string, obj&gt;" Usage="workflowInvoker.EndInvoke result" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IDictionary&lt;System.String,System.Object&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="result" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="result"><see cref="T:System.IAsyncResult" /> que hace referencia a la operación del método <see cref="Overload:System.Activities.WorkflowInvoker.BeginInvoke" /> que inició el flujo de trabajo.</param>
        <summary>Devuelve los resultados de un flujo de trabajo invocado mediante una de las sobrecargas <see cref="Overload:System.Activities.WorkflowInvoker.BeginInvoke" />.</summary>
        <returns>Diccionario de los valores <see cref="T:System.Activities.OutArgument" /> e <see cref="T:System.Activities.InOutArgument" /> de la actividad raíz ordenados por nombre de argumento que representan las salidas del flujo de trabajo.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para recibir una notificación cuando se complete el flujo de trabajo y recuperar los parámetros de salida de dicho flujo de trabajo, llame a <xref:System.Activities.WorkflowInvoker.EndInvoke%2A> desde el método `callback` especificado por <xref:System.Activities.WorkflowInvoker.BeginInvoke%2A>. Si se llama al método <xref:System.Activities.WorkflowInvoker.EndInvoke%2A> antes de que se complete el flujo de trabajo, la llamada queda bloqueada hasta que se completa el flujo de trabajo.  
  
 Este método devuelve el resultado de un flujo de trabajo invocado de forma asincrónica usando el modelo de diseño asincrónico de la interfaz <xref:System.IAsyncResult>. Para obtener más información, consulte [Asynchronous Programming Overview](~/docs/standard/asynchronous-programming-patterns/asynchronous-programming-model-apm.md).  
  
   
  
## Examples  
 En el siguiente ejemplo se invoca un flujo de trabajo formado por una actividad `LongRunningDiceRoll`. La actividad `LongRunningDiceRoll` tiene dos argumentos de salida que representan los resultados de la operación de tirar los dados. Se recuperan llamando al método <xref:System.Activities.WorkflowInvoker.EndInvoke%2A>. Cuando la llamada al método <xref:System.Activities.WorkflowInvoker.EndInvoke%2A> devuelve resultados, cada uno de los argumentos de salida se devuelve en el diccionario de salidas, ordenados por nombre de argumento.  
  
 [!code-csharp[CFX_WorkflowInvokerExample#131](~/samples/snippets/csharp/VS_Snippets_CFX/cfx_workflowinvokerexample/cs/program.cs#131)]  
  
 [!code-csharp[CFX_WorkflowInvokerExample#32](~/samples/snippets/csharp/VS_Snippets_CFX/cfx_workflowinvokerexample/cs/program.cs#32)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Extensions">
      <MemberSignature Language="C#" Value="public System.Activities.Hosting.WorkflowInstanceExtensionManager Extensions { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Activities.Hosting.WorkflowInstanceExtensionManager Extensions" />
      <MemberSignature Language="DocId" Value="P:System.Activities.WorkflowInvoker.Extensions" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Extensions As WorkflowInstanceExtensionManager" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Activities::Hosting::WorkflowInstanceExtensionManager ^ Extensions { System::Activities::Hosting::WorkflowInstanceExtensionManager ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Extensions : System.Activities.Hosting.WorkflowInstanceExtensionManager" Usage="System.Activities.WorkflowInvoker.Extensions" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Activities.Hosting.WorkflowInstanceExtensionManager</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene la colección <see cref="T:System.Collections.ObjectModel.Collection`1" /> de extensiones que están disponibles para los flujos de trabajo invocados por una instancia de <see cref="T:System.Activities.WorkflowInvoker" />.</summary>
        <value>La colección <see cref="T:System.Collections.ObjectModel.Collection`1" /> de extensiones que están disponibles para los flujos de trabajo invocados por una instancia de <see cref="T:System.Activities.WorkflowInvoker" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esta propiedad la usan los autores de host de flujo de trabajo con el fin de agregar extensiones a la instancia de la clase <xref:System.Activities.WorkflowInvoker> para que estén disponibles para los flujos de trabajo que invoque.  
  
   
  
## Examples  
 En el siguiente ejemplo se registra una clase <xref:System.Activities.Tracking.TrackingParticipant> personalizada con la colección <xref:System.Activities.WorkflowInvoker.Extensions%2A> de una instancia de la clase <xref:System.Activities.WorkflowInvoker>. Este ejemplo de código forma parte de la [seguimiento personalizado](~/docs/framework/windows-workflow-foundation/samples/custom-tracking.md) ejemplo.  
  
 [!code-csharp[CFX_WorkflowInvokerExample#40](~/samples/snippets/csharp/VS_Snippets_CFX/cfx_workflowinvokerexample/cs/program.cs#40)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Invoke">
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Invoca un flujo de trabajo de manera sincrónica y devuelve un diccionario de los valores <see cref="T:System.Activities.OutArgument" /> e <see cref="T:System.Activities.InOutArgument" /> de la actividad raíz ordenados por nombre de argumento que representan las salidas del flujo de trabajo.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método se bloquea hasta que se ha completado el flujo de trabajo, incluido el tiempo de inactividad. Se garantiza que toda la ejecución del flujo de trabajo se realiza en el subproceso que lo invoca. Para configurar un intervalo de tiempo de espera en el que se debe completar el flujo de trabajo, use una de las sobrecargas <xref:System.Activities.WorkflowInvoker.Invoke%2A> que toman una estructura <xref:System.TimeSpan>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Invoke">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IDictionary&lt;string,object&gt; Invoke ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.IDictionary`2&lt;string, object&gt; Invoke() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowInvoker.Invoke" />
      <MemberSignature Language="VB.NET" Value="Public Function Invoke () As IDictionary(Of String, Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::IDictionary&lt;System::String ^, System::Object ^&gt; ^ Invoke();" />
      <MemberSignature Language="F#" Value="member this.Invoke : unit -&gt; System.Collections.Generic.IDictionary&lt;string, obj&gt;" Usage="workflowInvoker.Invoke " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IDictionary&lt;System.String,System.Object&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Invoca un flujo de trabajo de forma sincrónica mediante la definición de flujo de trabajo pasada al constructor <see cref="M:System.Activities.WorkflowInvoker.#ctor(System.Activities.Activity)" />.</summary>
        <returns>Diccionario de los valores <see cref="T:System.Activities.OutArgument" /> e <see cref="T:System.Activities.InOutArgument" /> de la actividad raíz ordenados por nombre de argumento que representan las salidas del flujo de trabajo.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método se bloquea hasta que se ha completado el flujo de trabajo, incluido el tiempo de inactividad. Se garantiza que toda la ejecución del flujo de trabajo se realiza en el subproceso que lo invoca. Para configurar un intervalo de tiempo de espera en el que se debe completar el flujo de trabajo, use una de las sobrecargas <xref:System.Activities.WorkflowInvoker.Invoke%2A> que toman una estructura <xref:System.TimeSpan>.  
  
   
  
## Examples  
 En el siguiente ejemplo se invoca un flujo de trabajo formado por una sola actividad `DiceRoll`. La actividad `DiceRoll` tiene dos argumentos de salida que representan los resultados de la operación de tirar los dados. Cuando la llamada al método `Invoke` devuelve resultados, cada uno de los argumentos de salida se devuelve en el diccionario de salidas, ordenados por nombre de argumento. El flujo de trabajo se invoca dos veces, mediante la definición de flujo de trabajo pasada en el `WorkflowInvoker` constructor.  
  
 [!code-csharp[CFX_WorkflowInvokerExample#130](~/samples/snippets/csharp/VS_Snippets_CFX/cfx_workflowinvokerexample/cs/program.cs#130)]  
  
 [!code-csharp[CFX_WorkflowInvokerExample#31](~/samples/snippets/csharp/VS_Snippets_CFX/cfx_workflowinvokerexample/cs/program.cs#31)]  
  
 Si la actividad raíz del flujo de trabajo no tiene argumentos de salida o no los necesita el host, se pueden omitir. En el siguiente ejemplo se invoca un flujo de trabajo formado por una sola actividad de la clase <xref:System.Activities.Statements.WriteLine> que no tiene argumentos de salida.  
  
 [!code-csharp[CFX_WorkflowInvokerExample#2](~/samples/snippets/csharp/VS_Snippets_CFX/cfx_workflowinvokerexample/cs/program.cs#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Invoke">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IDictionary&lt;string,object&gt; Invoke (System.Activities.Activity workflow);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IDictionary`2&lt;string, object&gt; Invoke(class System.Activities.Activity workflow) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowInvoker.Invoke(System.Activities.Activity)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Invoke (workflow As Activity) As IDictionary(Of String, Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Collections::Generic::IDictionary&lt;System::String ^, System::Object ^&gt; ^ Invoke(System::Activities::Activity ^ workflow);" />
      <MemberSignature Language="F#" Value="static member Invoke : System.Activities.Activity -&gt; System.Collections.Generic.IDictionary&lt;string, obj&gt;" Usage="System.Activities.WorkflowInvoker.Invoke workflow" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IDictionary&lt;System.String,System.Object&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="workflow" Type="System.Activities.Activity" />
      </Parameters>
      <Docs>
        <param name="workflow">La definición del flujo de trabajo que se va a invocar.</param>
        <summary>Invoca un flujo de trabajo sincrónicamente usando la definición de flujo de trabajo especificada.</summary>
        <returns>Diccionario de los valores <see cref="T:System.Activities.OutArgument" /> e <see cref="T:System.Activities.InOutArgument" /> de la actividad raíz ordenados por nombre de argumento que representan las salidas del flujo de trabajo.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método se bloquea hasta que se ha completado el flujo de trabajo, incluido el tiempo de inactividad. Se garantiza que toda la ejecución del flujo de trabajo se realiza en el subproceso que lo invoca. Para configurar un intervalo de tiempo de espera en el que se debe completar el flujo de trabajo, use una de las sobrecargas <xref:System.Activities.WorkflowInvoker.Invoke%2A> que toman una estructura <xref:System.TimeSpan>.  
  
   
  
## Examples  
 En el siguiente ejemplo se invoca un flujo de trabajo formado por una sola actividad `DiceRoll`. La actividad `DiceRoll` tiene dos argumentos de salida que representan los resultados de la operación de tirar los dados. Cuando la llamada al método `Invoke` devuelve resultados, cada uno de los argumentos de salida se devuelve en el diccionario de salidas, ordenados por nombre de argumento.  
  
 [!code-csharp[CFX_WorkflowInvokerExample#130](~/samples/snippets/csharp/VS_Snippets_CFX/cfx_workflowinvokerexample/cs/program.cs#130)]  
  
 [!code-csharp[CFX_WorkflowInvokerExample#30](~/samples/snippets/csharp/VS_Snippets_CFX/cfx_workflowinvokerexample/cs/program.cs#30)]  
  
 Si la actividad raíz del flujo de trabajo no tiene argumentos de salida o no los necesita el host, se pueden omitir. En el siguiente ejemplo se invoca un flujo de trabajo formado por una sola actividad de la clase <xref:System.Activities.Statements.WriteLine> que no tiene argumentos de salida.  
  
 [!code-csharp[CFX_WorkflowInvokerExample#1](~/samples/snippets/csharp/VS_Snippets_CFX/cfx_workflowinvokerexample/cs/program.cs#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Invoke">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IDictionary&lt;string,object&gt; Invoke (System.Collections.Generic.IDictionary&lt;string,object&gt; inputs);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.IDictionary`2&lt;string, object&gt; Invoke(class System.Collections.Generic.IDictionary`2&lt;string, object&gt; inputs) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowInvoker.Invoke(System.Collections.Generic.IDictionary{System.String,System.Object})" />
      <MemberSignature Language="VB.NET" Value="Public Function Invoke (inputs As IDictionary(Of String, Object)) As IDictionary(Of String, Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::IDictionary&lt;System::String ^, System::Object ^&gt; ^ Invoke(System::Collections::Generic::IDictionary&lt;System::String ^, System::Object ^&gt; ^ inputs);" />
      <MemberSignature Language="F#" Value="member this.Invoke : System.Collections.Generic.IDictionary&lt;string, obj&gt; -&gt; System.Collections.Generic.IDictionary&lt;string, obj&gt;" Usage="workflowInvoker.Invoke inputs" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IDictionary&lt;System.String,System.Object&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="inputs" Type="System.Collections.Generic.IDictionary&lt;System.String,System.Object&gt;" />
      </Parameters>
      <Docs>
        <param name="inputs">El diccionario de parámetros de entrada para el flujo de trabajo, ordenados por nombre de argumento.</param>
        <summary>Invoca la actividad pasada al constructor <see cref="M:System.Activities.WorkflowInvoker.#ctor(System.Activities.Activity)" /> sincrónicamente con la interfaz <see cref="T:System.Collections.Generic.IDictionary`2" /> especificada de parámetros de entrada.</summary>
        <returns>Diccionario de los valores <see cref="T:System.Activities.OutArgument" /> e <see cref="T:System.Activities.InOutArgument" /> de la actividad raíz ordenados por nombre de argumento que representan las salidas del flujo de trabajo.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método se bloquea hasta que se ha completado el flujo de trabajo, incluido el tiempo de inactividad. Se garantiza que toda la ejecución del flujo de trabajo se realiza en el subproceso que lo invoca. Para configurar un intervalo de tiempo de espera en el que se debe completar el flujo de trabajo, use una de las sobrecargas <xref:System.Activities.WorkflowInvoker.Invoke%2A> que toman una estructura <xref:System.TimeSpan>.  
  
   
  
## Examples  
 En el siguiente ejemplo se invoca un flujo de trabajo formado por una sola actividad `Divide` que tiene dos argumentos de entrada y dos argumentos de salida. Cuando se invoca el flujo de trabajo, se pasa el diccionario de `arguments` que contiene los valores de cada argumento de entrada, ordenados por nombre de argumento. Cuando la llamada a `Invoke` devuelve resultados, cada uno de los argumentos de salida se devuelve en el diccionario `outputs`, ordenados por nombre de argumento.  
  
 [!code-csharp[CFX_WorkflowInvokerExample#120](~/samples/snippets/csharp/VS_Snippets_CFX/cfx_workflowinvokerexample/cs/program.cs#120)]  
  
 [!code-csharp[CFX_WorkflowInvokerExample#22](~/samples/snippets/csharp/VS_Snippets_CFX/cfx_workflowinvokerexample/cs/program.cs#22)]  
  
 Si el flujo de trabajo se deriva de <xref:System.Activities.ActivityWithResult>, tales como `CodeActivity<TResult>` o `Activity<TResult>`, y hay argumentos de salida además bien definidos <xref:System.Activities.Activity%601.Result%2A> una sobrecarga no genérica del argumento de salida `Invoke`, como éste, se debe usar en orden para recuperar los argumentos adicionales. Para ello, la definición de flujo de trabajo pasada en el `WorkflowInvoker` constructor debe ser del tipo <xref:System.Activities.Activity>. En este ejemplo el `Divide` actividad deriva `CodeActivity<int>`, pero se declara como <xref:System.Activities.Activity> para que esta sobrecarga de `Invoke`, que devuelve un diccionario de argumentos en lugar de un único valor devuelto, se utiliza.  
  
 [!code-csharp[CFX_WorkflowInvokerExample#121](~/samples/snippets/csharp/VS_Snippets_CFX/cfx_workflowinvokerexample/cs/program.cs#121)]  
  
 [!code-csharp[CFX_WorkflowInvokerExample#23](~/samples/snippets/csharp/VS_Snippets_CFX/cfx_workflowinvokerexample/cs/program.cs#23)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Invoke">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IDictionary&lt;string,object&gt; Invoke (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.IDictionary`2&lt;string, object&gt; Invoke(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowInvoker.Invoke(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Function Invoke (timeout As TimeSpan) As IDictionary(Of String, Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::IDictionary&lt;System::String ^, System::Object ^&gt; ^ Invoke(TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="member this.Invoke : TimeSpan -&gt; System.Collections.Generic.IDictionary&lt;string, obj&gt;" Usage="workflowInvoker.Invoke timeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IDictionary&lt;System.String,System.Object&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout">Intervalo de tiempo en el que se debe completar el flujo de trabajo antes de quedar anulado y de que se produzca una excepción <see cref="T:System.TimeoutException" />.</param>
        <summary>Invoca un flujo de trabajo sincrónicamente con el intervalo de tiempo de espera especificado.</summary>
        <returns>Diccionario de los valores <see cref="T:System.Activities.OutArgument" /> e <see cref="T:System.Activities.InOutArgument" /> de la actividad raíz ordenados por nombre de argumento que representan las salidas del flujo de trabajo.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método se bloquea hasta que se ha completado el flujo de trabajo, incluido el tiempo de inactividad. Se garantiza que toda la ejecución del flujo de trabajo se realiza en el subproceso que lo invoca. Si el flujo de trabajo no se completa dentro del intervalo de tiempo de espera especificado, se anula el flujo de trabajo y se produce una excepción <xref:System.TimeoutException>.  
  
> [!NOTE]
>  La excepción <xref:System.TimeoutException> solo se produce si se agota el tiempo de espera y el flujo de trabajo queda inactivo durante la ejecución. Un flujo de trabajo que tarda en completarse más tiempo que el especificado por el intervalo de tiempo de espera se completa correctamente si el flujo de trabajo no queda inactivo.  
  
   
  
## Examples  
 En el siguiente ejemplo se invoca un flujo de trabajo que contiene dos actividades de la clase <xref:System.Activities.Statements.WriteLine> y una actividad de la clase <xref:System.Activities.Statements.Delay> configurada con una propiedad <xref:System.Activities.Statements.Delay.Duration%2A> de un minuto. Este flujo de trabajo se invoca dos veces; la primera vez con un intervalo de tiempo de espera de dos minutos y la segunda con un intervalo de tiempo de espera de 30 segundos. El primer flujo de trabajo se completa correctamente, pero el segundo no y se produce una excepción <xref:System.TimeoutException>, mostrándose además el siguiente mensaje.  
  
```Output  
The operation did not complete within the allotted timeout of 00:00:30.   
The time allotted to this operation may have been a portion of a longer timeout.  
```  
  
 [!code-csharp[CFX_WorkflowInvokerExample#51](~/samples/snippets/csharp/VS_Snippets_CFX/cfx_workflowinvokerexample/cs/program.cs#51)]  
  
 Para obtener un ejemplo del uso de `Invoke` con argumentos de salida, vea la sobrecarga de <xref:System.Activities.WorkflowInvoker.Invoke%2A> con los mismos parámetros que esta sobrecarga sin el intervalo de tiempo de espera.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Invoke">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IDictionary&lt;string,object&gt; Invoke (System.Activities.Activity workflow, System.Collections.Generic.IDictionary&lt;string,object&gt; inputs);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IDictionary`2&lt;string, object&gt; Invoke(class System.Activities.Activity workflow, class System.Collections.Generic.IDictionary`2&lt;string, object&gt; inputs) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowInvoker.Invoke(System.Activities.Activity,System.Collections.Generic.IDictionary{System.String,System.Object})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Invoke (workflow As Activity, inputs As IDictionary(Of String, Object)) As IDictionary(Of String, Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Collections::Generic::IDictionary&lt;System::String ^, System::Object ^&gt; ^ Invoke(System::Activities::Activity ^ workflow, System::Collections::Generic::IDictionary&lt;System::String ^, System::Object ^&gt; ^ inputs);" />
      <MemberSignature Language="F#" Value="static member Invoke : System.Activities.Activity * System.Collections.Generic.IDictionary&lt;string, obj&gt; -&gt; System.Collections.Generic.IDictionary&lt;string, obj&gt;" Usage="System.Activities.WorkflowInvoker.Invoke (workflow, inputs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IDictionary&lt;System.String,System.Object&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="workflow" Type="System.Activities.Activity" />
        <Parameter Name="inputs" Type="System.Collections.Generic.IDictionary&lt;System.String,System.Object&gt;" />
      </Parameters>
      <Docs>
        <param name="workflow">La definición del flujo de trabajo que se va a invocar.</param>
        <param name="inputs">El diccionario de parámetros de entrada para el flujo de trabajo, ordenados por nombre de argumento.</param>
        <summary>Invoca un flujo de trabajo sincrónicamente usando la definición de flujo de trabajo y la interfaz <see cref="T:System.Collections.Generic.IDictionary`2" /> de parámetros de entrada especificados.</summary>
        <returns>Diccionario de los valores <see cref="T:System.Activities.OutArgument" /> e <see cref="T:System.Activities.InOutArgument" /> de la actividad raíz ordenados por nombre de argumento que representan las salidas del flujo de trabajo.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método se bloquea hasta que se ha completado el flujo de trabajo, incluido el tiempo de inactividad. Se garantiza que toda la ejecución del flujo de trabajo se realiza en el subproceso que lo invoca. Para configurar un intervalo de tiempo de espera en el que se debe completar el flujo de trabajo, use una de las sobrecargas <xref:System.Activities.WorkflowInvoker.Invoke%2A> que toman una estructura <xref:System.TimeSpan>.  
  
   
  
## Examples  
 En el siguiente ejemplo se invoca un flujo de trabajo formado por una sola actividad `Divide` que tiene dos argumentos de entrada y dos argumentos de salida. Cuando se invoca el flujo de trabajo, se pasa el diccionario de `arguments` que contiene los valores de cada argumento de entrada, ordenados por nombre de argumento. Cuando la llamada a `Invoke` devuelve resultados, cada uno de los argumentos de salida se devuelve en el diccionario `outputs`, ordenados por nombre de argumento.  
  
 [!code-csharp[CFX_WorkflowInvokerExample#120](~/samples/snippets/csharp/VS_Snippets_CFX/cfx_workflowinvokerexample/cs/program.cs#120)]  
  
 [!code-csharp[CFX_WorkflowInvokerExample#20](~/samples/snippets/csharp/VS_Snippets_CFX/cfx_workflowinvokerexample/cs/program.cs#20)]  
  
 Si el flujo de trabajo se deriva de <xref:System.Activities.ActivityWithResult>, tales como `CodeActivity<TResult>` o `Activity<TResult>`, y hay argumentos de salida además bien definidos <xref:System.Activities.Activity%601.Result%2A> una sobrecarga no genérica del argumento de salida `Invoke`, como éste, se debe usar en orden para recuperar los argumentos adicionales. Para ello, la definición de flujo de trabajo pasada a `Invoke` debe ser de tipo <xref:System.Activities.Activity>. En este ejemplo el `Divide` actividad deriva `CodeActivity<int>`, pero se declara como <xref:System.Activities.Activity> para que esta sobrecarga de `Invoke`, que devuelve un diccionario de argumentos en lugar de un único valor devuelto, se utiliza.  
  
 [!code-csharp[CFX_WorkflowInvokerExample#121](~/samples/snippets/csharp/VS_Snippets_CFX/cfx_workflowinvokerexample/cs/program.cs#121)]  
  
 [!code-csharp[CFX_WorkflowInvokerExample#21](~/samples/snippets/csharp/VS_Snippets_CFX/cfx_workflowinvokerexample/cs/program.cs#21)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Invoke">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IDictionary&lt;string,object&gt; Invoke (System.Activities.Activity workflow, TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IDictionary`2&lt;string, object&gt; Invoke(class System.Activities.Activity workflow, valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowInvoker.Invoke(System.Activities.Activity,System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Invoke (workflow As Activity, timeout As TimeSpan) As IDictionary(Of String, Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Collections::Generic::IDictionary&lt;System::String ^, System::Object ^&gt; ^ Invoke(System::Activities::Activity ^ workflow, TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="static member Invoke : System.Activities.Activity * TimeSpan -&gt; System.Collections.Generic.IDictionary&lt;string, obj&gt;" Usage="System.Activities.WorkflowInvoker.Invoke (workflow, timeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IDictionary&lt;System.String,System.Object&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="workflow" Type="System.Activities.Activity" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="workflow">La definición del flujo de trabajo que se va a invocar.</param>
        <param name="timeout">Intervalo de tiempo en el que se debe completar el flujo de trabajo antes de quedar anulado y de que se produzca una excepción <see cref="T:System.TimeoutException" />.</param>
        <summary>Invoca un flujo de trabajo sincrónicamente usando la definición de flujo de trabajo y el intervalo de tiempo de espera especificados.</summary>
        <returns>Diccionario de los valores <see cref="T:System.Activities.OutArgument" /> e <see cref="T:System.Activities.InOutArgument" /> de la actividad raíz ordenados por nombre de argumento que representan las salidas del flujo de trabajo.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método se bloquea hasta que se ha completado el flujo de trabajo, incluido el tiempo de inactividad. Se garantiza que toda la ejecución del flujo de trabajo se realiza en el subproceso que lo invoca. Si el flujo de trabajo no se completa dentro del intervalo de tiempo de espera especificado, se anula el flujo de trabajo y se produce una excepción <xref:System.TimeoutException>.  
  
> [!NOTE]
>  La excepción <xref:System.TimeoutException> solo se produce si se agota el tiempo de espera y el flujo de trabajo queda inactivo durante la ejecución. Un flujo de trabajo que tarda en completarse más tiempo que el especificado por el intervalo de tiempo de espera se completa correctamente si el flujo de trabajo no queda inactivo.  
  
   
  
## Examples  
 En el siguiente ejemplo se invoca un flujo de trabajo que contiene dos actividades de la clase <xref:System.Activities.Statements.WriteLine> y una actividad de la clase <xref:System.Activities.Statements.Delay> configurada con una propiedad <xref:System.Activities.Statements.Delay.Duration%2A> de un minuto. Este flujo de trabajo se invoca dos veces; la primera vez con un intervalo de tiempo de espera de dos minutos y la segunda con un intervalo de tiempo de espera de 30 segundos. El primer flujo de trabajo se completa correctamente, pero el segundo no y se produce una excepción <xref:System.TimeoutException>.  
  
 [!code-csharp[CFX_WorkflowInvokerExample#50](~/samples/snippets/csharp/VS_Snippets_CFX/cfx_workflowinvokerexample/cs/program.cs#50)]  
  
 Para obtener un ejemplo del uso de `Invoke` con argumentos de salida, vea la sobrecarga de <xref:System.Activities.WorkflowInvoker.Invoke%2A> con los mismos parámetros que esta sobrecarga sin el intervalo de tiempo de espera.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Invoke">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IDictionary&lt;string,object&gt; Invoke (System.Collections.Generic.IDictionary&lt;string,object&gt; inputs, TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.IDictionary`2&lt;string, object&gt; Invoke(class System.Collections.Generic.IDictionary`2&lt;string, object&gt; inputs, valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowInvoker.Invoke(System.Collections.Generic.IDictionary{System.String,System.Object},System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Function Invoke (inputs As IDictionary(Of String, Object), timeout As TimeSpan) As IDictionary(Of String, Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::IDictionary&lt;System::String ^, System::Object ^&gt; ^ Invoke(System::Collections::Generic::IDictionary&lt;System::String ^, System::Object ^&gt; ^ inputs, TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="member this.Invoke : System.Collections.Generic.IDictionary&lt;string, obj&gt; * TimeSpan -&gt; System.Collections.Generic.IDictionary&lt;string, obj&gt;" Usage="workflowInvoker.Invoke (inputs, timeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IDictionary&lt;System.String,System.Object&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="inputs" Type="System.Collections.Generic.IDictionary&lt;System.String,System.Object&gt;" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="inputs">El diccionario de parámetros de entrada para el flujo de trabajo, ordenados por nombre de argumento.</param>
        <param name="timeout">Intervalo de tiempo en el que se debe completar el flujo de trabajo antes de quedar anulado y de que se produzca una excepción <see cref="T:System.TimeoutException" />.</param>
        <summary>Invoca la actividad pasada al constructor <see cref="M:System.Activities.WorkflowInvoker.#ctor(System.Activities.Activity)" /> sincrónicamente con la interfaz <see cref="T:System.Collections.Generic.IDictionary`2" /> de parámetros de entrada y el intervalo de tiempo de espera especificados.</summary>
        <returns>Diccionario de los valores <see cref="T:System.Activities.OutArgument" /> e <see cref="T:System.Activities.InOutArgument" /> de la actividad raíz ordenados por nombre de argumento que representan las salidas del flujo de trabajo.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método se bloquea hasta que se ha completado el flujo de trabajo, incluido el tiempo de inactividad. Se garantiza que toda la ejecución del flujo de trabajo se realiza en el subproceso que lo invoca. Si el flujo de trabajo no se completa dentro del intervalo de tiempo de espera especificado, se anula el flujo de trabajo y se produce una excepción <xref:System.TimeoutException>.  
  
> [!NOTE]
>  La excepción <xref:System.TimeoutException> solo se produce si se agota el tiempo de espera y el flujo de trabajo queda inactivo durante la ejecución. Un flujo de trabajo que tarda en completarse más tiempo que el especificado por el intervalo de tiempo de espera se completa correctamente si el flujo de trabajo no queda inactivo.  
  
   
  
## Examples  
 En el siguiente ejemplo se invoca un flujo de trabajo que contiene dos actividades de la clase <xref:System.Activities.Statements.WriteLine> y una actividad de la clase <xref:System.Activities.Statements.Delay> configurada con una propiedad <xref:System.Activities.Statements.Delay.Duration%2A> de un minuto. Este flujo de trabajo se invoca dos veces; la primera vez con un intervalo de tiempo de espera de dos minutos y la segunda con un intervalo de tiempo de espera de 30 segundos. El primer flujo de trabajo se completa correctamente, pero el segundo no y se produce una excepción <xref:System.TimeoutException>, mostrándose además el siguiente mensaje.  
  
```Output  
The operation did not complete within the allotted timeout of 00:00:30.   
The time allotted to this operation may have been a portion of a longer timeout.  
```  
  
 [!code-csharp[CFX_WorkflowInvokerExample#51](~/samples/snippets/csharp/VS_Snippets_CFX/cfx_workflowinvokerexample/cs/program.cs#51)]  
  
 Para obtener un ejemplo del uso de `Invoke` con argumentos de entrada y salidos, vea la sobrecarga de <xref:System.Activities.WorkflowInvoker.Invoke%2A> con los mismos parámetros que esta sobrecarga sin el intervalo de tiempo de espera.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Invoke">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IDictionary&lt;string,object&gt; Invoke (System.Activities.Activity workflow, System.Collections.Generic.IDictionary&lt;string,object&gt; inputs, TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IDictionary`2&lt;string, object&gt; Invoke(class System.Activities.Activity workflow, class System.Collections.Generic.IDictionary`2&lt;string, object&gt; inputs, valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowInvoker.Invoke(System.Activities.Activity,System.Collections.Generic.IDictionary{System.String,System.Object},System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Invoke (workflow As Activity, inputs As IDictionary(Of String, Object), timeout As TimeSpan) As IDictionary(Of String, Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Collections::Generic::IDictionary&lt;System::String ^, System::Object ^&gt; ^ Invoke(System::Activities::Activity ^ workflow, System::Collections::Generic::IDictionary&lt;System::String ^, System::Object ^&gt; ^ inputs, TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="static member Invoke : System.Activities.Activity * System.Collections.Generic.IDictionary&lt;string, obj&gt; * TimeSpan -&gt; System.Collections.Generic.IDictionary&lt;string, obj&gt;" Usage="System.Activities.WorkflowInvoker.Invoke (workflow, inputs, timeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IDictionary&lt;System.String,System.Object&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="workflow" Type="System.Activities.Activity" />
        <Parameter Name="inputs" Type="System.Collections.Generic.IDictionary&lt;System.String,System.Object&gt;" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="workflow">La definición del flujo de trabajo que se va a invocar.</param>
        <param name="inputs">El diccionario de parámetros de entrada para el flujo de trabajo, ordenados por nombre de argumento.</param>
        <param name="timeout">Intervalo de tiempo en el que se debe completar el flujo de trabajo antes de quedar anulado y de que se produzca una excepción <see cref="T:System.TimeoutException" />.</param>
        <summary>Invoca un flujo de trabajo sincrónicamente usando la definición de flujo de trabajo, la interfaz <see cref="T:System.Collections.Generic.IDictionary`2" /> de parámetros de entrada y el intervalo de tiempo de espera especificados.</summary>
        <returns>Diccionario de los valores <see cref="T:System.Activities.OutArgument" /> e <see cref="T:System.Activities.InOutArgument" /> de la actividad raíz ordenados por nombre de argumento que representan las salidas del flujo de trabajo.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método se bloquea hasta que se ha completado el flujo de trabajo, incluido el tiempo de inactividad. Se garantiza que toda la ejecución del flujo de trabajo se realiza en el subproceso que lo invoca. Si el flujo de trabajo no se completa dentro del intervalo de tiempo de espera especificado, se anula el flujo de trabajo y se produce una excepción <xref:System.TimeoutException>.  
  
> [!NOTE]
>  La excepción <xref:System.TimeoutException> solo se produce si se agota el tiempo de espera y el flujo de trabajo queda inactivo durante la ejecución. Un flujo de trabajo que tarda en completarse más tiempo que el especificado por el intervalo de tiempo de espera se completa correctamente si el flujo de trabajo no queda inactivo.  
  
   
  
## Examples  
 En el siguiente ejemplo se invoca un flujo de trabajo que contiene dos actividades de la clase <xref:System.Activities.Statements.WriteLine> y una actividad de la clase <xref:System.Activities.Statements.Delay> configurada con una propiedad <xref:System.Activities.Statements.Delay.Duration%2A> de un minuto. Este flujo de trabajo se invoca dos veces; la primera vez con un intervalo de tiempo de espera de dos minutos y la segunda con un intervalo de tiempo de espera de 30 segundos. El primer flujo de trabajo se completa correctamente, pero el segundo no y se produce una excepción <xref:System.TimeoutException>.  
  
 [!code-csharp[CFX_WorkflowInvokerExample#50](~/samples/snippets/csharp/VS_Snippets_CFX/cfx_workflowinvokerexample/cs/program.cs#50)]  
  
 Para obtener un ejemplo del uso de `Invoke` con argumentos de entrada y salidos, vea la sobrecarga de <xref:System.Activities.WorkflowInvoker.Invoke%2A> con los mismos parámetros que esta sobrecarga sin el intervalo de tiempo de espera.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Invoke&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public static TResult Invoke&lt;TResult&gt; (System.Activities.Activity&lt;TResult&gt; workflow);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TResult Invoke&lt;TResult&gt;(class System.Activities.Activity`1&lt;!!TResult&gt; workflow) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowInvoker.Invoke``1(System.Activities.Activity{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Invoke(Of TResult) (workflow As Activity(Of TResult)) As TResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; static TResult Invoke(System::Activities::Activity&lt;TResult&gt; ^ workflow);" />
      <MemberSignature Language="F#" Value="static member Invoke : System.Activities.Activity&lt;'Result&gt; -&gt; 'Result" Usage="System.Activities.WorkflowInvoker.Invoke workflow" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>TResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="workflow" Type="System.Activities.Activity&lt;TResult&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">El tipo del flujo de trabajo.</typeparam>
        <param name="workflow">La definición del flujo de trabajo que se va a invocar. La definición del flujo de trabajo debe derivarse de la clase <see cref="T:System.Activities.ActivityWithResult" />.</param>
        <summary>Invoca un flujo de trabajo de forma sincrónica mediante la definición de flujo de trabajo pasada al constructor <see cref="M:System.Activities.WorkflowInvoker.#ctor(System.Activities.Activity)" />.</summary>
        <returns>Valor de tipo TResult que tiene el resultado de la ejecución de la actividad.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método se bloquea hasta que se ha completado el flujo de trabajo, incluido el tiempo de inactividad. Se garantiza que toda la ejecución del flujo de trabajo se realiza en el subproceso que lo invoca. Para configurar un intervalo de tiempo de espera en el que se debe completar el flujo de trabajo, use una de las sobrecargas <xref:System.Activities.WorkflowInvoker.Invoke%2A> que toman una estructura <xref:System.TimeSpan>.  
  
   
  
## Examples  
 En el ejemplo siguiente se invoca un flujo de trabajo que consta de una sola `Add` actividad que tiene dos argumentos de entrada y, dado que se deriva de `CodeActivity<int>` lo tiene bien definidos <xref:System.Activities.Activity%601.Result%2A> argumento de salida. Cuando se invoca el flujo de trabajo, se pasa el diccionario de `arguments` que contiene los valores de cada argumento de entrada, ordenados por nombre de argumento. Cuando la llamada a `Invoke` devuelve el valor de la <xref:System.Activities.Activity%601.Result%2A> los argumentos de salida se devuelven. Este ejemplo de código se basa en el [mediante la clase WorkflowInvoker](~/docs/framework/windows-workflow-foundation/samples/using-the-workflowinvoker-class.md) ejemplo.  
  
 [!code-csharp[CFX_WorkflowInvokerExample#110](~/samples/snippets/csharp/VS_Snippets_CFX/cfx_workflowinvokerexample/cs/program.cs#110)]  
  
 [!code-csharp[CFX_WorkflowInvokerExample#10](~/samples/snippets/csharp/VS_Snippets_CFX/cfx_workflowinvokerexample/cs/program.cs#10)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Invoke&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public static TResult Invoke&lt;TResult&gt; (System.Activities.Activity&lt;TResult&gt; workflow, System.Collections.Generic.IDictionary&lt;string,object&gt; inputs);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TResult Invoke&lt;TResult&gt;(class System.Activities.Activity`1&lt;!!TResult&gt; workflow, class System.Collections.Generic.IDictionary`2&lt;string, object&gt; inputs) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowInvoker.Invoke``1(System.Activities.Activity{``0},System.Collections.Generic.IDictionary{System.String,System.Object})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Invoke(Of TResult) (workflow As Activity(Of TResult), inputs As IDictionary(Of String, Object)) As TResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; static TResult Invoke(System::Activities::Activity&lt;TResult&gt; ^ workflow, System::Collections::Generic::IDictionary&lt;System::String ^, System::Object ^&gt; ^ inputs);" />
      <MemberSignature Language="F#" Value="static member Invoke : System.Activities.Activity&lt;'Result&gt; * System.Collections.Generic.IDictionary&lt;string, obj&gt; -&gt; 'Result" Usage="System.Activities.WorkflowInvoker.Invoke (workflow, inputs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="workflow" Type="System.Activities.Activity&lt;TResult&gt;" />
        <Parameter Name="inputs" Type="System.Collections.Generic.IDictionary&lt;System.String,System.Object&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">El tipo del flujo de trabajo.</typeparam>
        <param name="workflow">La definición del flujo de trabajo que se va a invocar.</param>
        <param name="inputs">El diccionario de parámetros de entrada para el flujo de trabajo, ordenados por nombre de argumento.</param>
        <summary>Invoca un flujo de trabajo sincrónicamente usando la definición de flujo de trabajo y la interfaz <see cref="T:System.Collections.Generic.IDictionary`2" /> de parámetros de entrada especificados.</summary>
        <returns>Valor de tipo TResult que tiene el resultado de la ejecución de la actividad.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método se bloquea hasta que se ha completado el flujo de trabajo, incluido el tiempo de inactividad. Se garantiza que toda la ejecución del flujo de trabajo se realiza en el subproceso que lo invoca. Para configurar un intervalo de tiempo de espera en el que se debe completar el flujo de trabajo, use una de las sobrecargas <xref:System.Activities.WorkflowInvoker.Invoke%2A> que toman una estructura <xref:System.TimeSpan>.  
  
> [!NOTE]
>  La excepción <xref:System.TimeoutException> solo se produce si se agota el tiempo de espera y el flujo de trabajo queda inactivo durante la ejecución. Un flujo de trabajo que tarda en completarse más tiempo que el especificado por el intervalo de tiempo de espera se completa correctamente si el flujo de trabajo no queda inactivo.  
  
   
  
## Examples  
 En el ejemplo siguiente se invoca un flujo de trabajo que consta de una sola `Add` actividad que tiene dos argumentos de entrada y, dado que se deriva de `CodeActivity<int>` lo tiene bien definidos <xref:System.Activities.Activity%601.Result%2A> argumento de salida. Cuando se invoca el flujo de trabajo, se pasa el diccionario de `arguments` que contiene los valores de cada argumento de entrada, ordenados por nombre de argumento. Cuando la llamada a `Invoke` devuelve el valor de la <xref:System.Activities.Activity%601.Result%2A> los argumentos de salida se devuelven. Este ejemplo de código se basa en el [mediante la clase WorkflowInvoker](~/docs/framework/windows-workflow-foundation/samples/using-the-workflowinvoker-class.md) ejemplo.  
  
 [!code-csharp[CFX_WorkflowInvokerExample#110](~/samples/snippets/csharp/VS_Snippets_CFX/cfx_workflowinvokerexample/cs/program.cs#110)]  
  
 [!code-csharp[CFX_WorkflowInvokerExample#10](~/samples/snippets/csharp/VS_Snippets_CFX/cfx_workflowinvokerexample/cs/program.cs#10)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Invoke&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public static TResult Invoke&lt;TResult&gt; (System.Activities.Activity&lt;TResult&gt; workflow, System.Collections.Generic.IDictionary&lt;string,object&gt; inputs, TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TResult Invoke&lt;TResult&gt;(class System.Activities.Activity`1&lt;!!TResult&gt; workflow, class System.Collections.Generic.IDictionary`2&lt;string, object&gt; inputs, valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowInvoker.Invoke``1(System.Activities.Activity{``0},System.Collections.Generic.IDictionary{System.String,System.Object},System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Invoke(Of TResult) (workflow As Activity(Of TResult), inputs As IDictionary(Of String, Object), timeout As TimeSpan) As TResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; static TResult Invoke(System::Activities::Activity&lt;TResult&gt; ^ workflow, System::Collections::Generic::IDictionary&lt;System::String ^, System::Object ^&gt; ^ inputs, TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="static member Invoke : System.Activities.Activity&lt;'Result&gt; * System.Collections.Generic.IDictionary&lt;string, obj&gt; * TimeSpan -&gt; 'Result" Usage="System.Activities.WorkflowInvoker.Invoke (workflow, inputs, timeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="workflow" Type="System.Activities.Activity&lt;TResult&gt;" />
        <Parameter Name="inputs" Type="System.Collections.Generic.IDictionary&lt;System.String,System.Object&gt;" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">El tipo del flujo de trabajo.</typeparam>
        <param name="workflow">La definición del flujo de trabajo que se va a invocar.</param>
        <param name="inputs">El diccionario de parámetros de entrada para el flujo de trabajo, ordenados por nombre de argumento.</param>
        <param name="timeout">Intervalo de tiempo en el que se debe completar el flujo de trabajo antes de quedar anulado y de que se produzca una excepción <see cref="T:System.TimeoutException" />.</param>
        <summary>Invoca un flujo de trabajo sincrónicamente usando la definición de flujo de trabajo, la interfaz <see cref="T:System.Collections.Generic.IDictionary`2" /> de parámetros de entrada y el intervalo de tiempo de espera especificados.</summary>
        <returns>Valor de tipo TResult que tiene el resultado de la ejecución de la actividad.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método se bloquea hasta que se ha completado el flujo de trabajo, incluido el tiempo de inactividad. Se garantiza que toda la ejecución del flujo de trabajo se realiza en el subproceso que lo invoca. Si el flujo de trabajo no se completa dentro del intervalo de tiempo de espera especificado, se anula el flujo de trabajo y se produce una excepción <xref:System.TimeoutException>.  
  
> [!NOTE]
>  La excepción <xref:System.TimeoutException> solo se produce si se agota el tiempo de espera y el flujo de trabajo queda inactivo durante la ejecución. Un flujo de trabajo que tarda en completarse más tiempo que el especificado por el intervalo de tiempo de espera se completa correctamente si el flujo de trabajo no queda inactivo.  
  
   
  
## Examples  
 En el ejemplo siguiente se invoca un flujo de trabajo que consta de una sola `Add` actividad que tiene dos argumentos de entrada y, dado que se deriva de `CodeActivity<int>` lo tiene bien definidos <xref:System.Activities.Activity%601.Result%2A> argumento de salida. Cuando se invoca el flujo de trabajo, se pasa el diccionario de `arguments` que contiene los valores de cada argumento de entrada, ordenados por nombre de argumento. Cuando la llamada a `Invoke` devuelve el valor de la <xref:System.Activities.Activity%601.Result%2A> los argumentos de salida se devuelven. Este ejemplo de código se basa en el [mediante la clase WorkflowInvoker](~/docs/framework/windows-workflow-foundation/samples/using-the-workflowinvoker-class.md) ejemplo.  
  
 [!code-csharp[CFX_WorkflowInvokerExample#110](~/samples/snippets/csharp/VS_Snippets_CFX/cfx_workflowinvokerexample/cs/program.cs#110)]  
  
 [!code-csharp[CFX_WorkflowInvokerExample#10](~/samples/snippets/csharp/VS_Snippets_CFX/cfx_workflowinvokerexample/cs/program.cs#10)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Invoke&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public static TResult Invoke&lt;TResult&gt; (System.Activities.Activity&lt;TResult&gt; workflow, System.Collections.Generic.IDictionary&lt;string,object&gt; inputs, out System.Collections.Generic.IDictionary&lt;string,object&gt; additionalOutputs, TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TResult Invoke&lt;TResult&gt;(class System.Activities.Activity`1&lt;!!TResult&gt; workflow, class System.Collections.Generic.IDictionary`2&lt;string, object&gt; inputs, [out] class System.Collections.Generic.IDictionary`2&lt;string, object&gt;&amp; additionalOutputs, valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowInvoker.Invoke``1(System.Activities.Activity{``0},System.Collections.Generic.IDictionary{System.String,System.Object},System.Collections.Generic.IDictionary{System.String,System.Object}@,System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Invoke(Of TResult) (workflow As Activity(Of TResult), inputs As IDictionary(Of String, Object), ByRef additionalOutputs As IDictionary(Of String, Object), timeout As TimeSpan) As TResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; static TResult Invoke(System::Activities::Activity&lt;TResult&gt; ^ workflow, System::Collections::Generic::IDictionary&lt;System::String ^, System::Object ^&gt; ^ inputs, [Runtime::InteropServices::Out] System::Collections::Generic::IDictionary&lt;System::String ^, System::Object ^&gt; ^ % additionalOutputs, TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="static member Invoke : System.Activities.Activity&lt;'Result&gt; * System.Collections.Generic.IDictionary&lt;string, obj&gt; *  * TimeSpan -&gt; 'Result" Usage="System.Activities.WorkflowInvoker.Invoke (workflow, inputs, additionalOutputs, timeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="workflow" Type="System.Activities.Activity&lt;TResult&gt;" />
        <Parameter Name="inputs" Type="System.Collections.Generic.IDictionary&lt;System.String,System.Object&gt;" />
        <Parameter Name="additionalOutputs" Type="System.Collections.Generic.IDictionary&lt;System.String,System.Object&gt;" RefType="out" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">El tipo del flujo de trabajo.</typeparam>
        <param name="workflow">La definición del flujo de trabajo que se va a invocar.</param>
        <param name="inputs">El diccionario de parámetros de entrada para el flujo de trabajo, ordenados por nombre de argumento.</param>
        <param name="additionalOutputs">Diccionario de parámetros de salida del flujo de trabajo adicionales, organizados por nombre de argumento.</param>
        <param name="timeout">Intervalo de tiempo en el que se debe completar el flujo de trabajo antes de quedar anulado y de que se produzca una excepción <see cref="T:System.TimeoutException" />.</param>
        <summary>Invoca un flujo de trabajo sincrónicamente mediante la definición de flujo de trabajo, la interfaz <see cref="T:System.Collections.Generic.IDictionary`2" /> de parámetros de entrada, la interfaz <see cref="T:System.Collections.Generic.IDictionary`2" /> de parámetros de salida adicionales y el intervalo de tiempo de espera especificados.</summary>
        <returns>Valor de tipo TResult que tiene el resultado de la ejecución de la actividad.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método se bloquea hasta que se ha completado el flujo de trabajo, incluido el tiempo de inactividad. Se garantiza que toda la ejecución del flujo de trabajo se realiza en el subproceso que lo invoca. Si el flujo de trabajo no se completa dentro del intervalo de tiempo de espera especificado, se anula el flujo de trabajo y se produce una excepción <xref:System.TimeoutException>.  
  
> [!NOTE]
>  La excepción <xref:System.TimeoutException> solo se produce si se agota el tiempo de espera y el flujo de trabajo queda inactivo durante la ejecución. Un flujo de trabajo que tarda en completarse más tiempo que el especificado por el intervalo de tiempo de espera se completa correctamente si el flujo de trabajo no queda inactivo.  
  
   
  
## Examples  
 En el ejemplo siguiente se invoca un flujo de trabajo que consta de una sola `Add` actividad que tiene dos argumentos de entrada y, dado que se deriva de `CodeActivity<int>` lo tiene bien definidos <xref:System.Activities.Activity%601.Result%2A> argumento de salida. Cuando se invoca el flujo de trabajo, se pasa el diccionario de `arguments` que contiene los valores de cada argumento de entrada, ordenados por nombre de argumento. Cuando la llamada a `Invoke` devuelve el valor de la <xref:System.Activities.Activity%601.Result%2A> los argumentos de salida se devuelven. Este ejemplo de código se basa en el [mediante la clase WorkflowInvoker](~/docs/framework/windows-workflow-foundation/samples/using-the-workflowinvoker-class.md) ejemplo.  
  
 [!code-csharp[CFX_WorkflowInvokerExample#110](~/samples/snippets/csharp/VS_Snippets_CFX/cfx_workflowinvokerexample/cs/program.cs#110)]  
  
 [!code-csharp[CFX_WorkflowInvokerExample#10](~/samples/snippets/csharp/VS_Snippets_CFX/cfx_workflowinvokerexample/cs/program.cs#10)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="InvokeAsync">
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Invoca de forma asincrónica un flujo de trabajo usando el modelo de diseño asincrónico basado en eventos.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para recibir una notificación cuando se complete el flujo de trabajo, controle el evento <xref:System.Activities.WorkflowInvoker.InvokeCompleted>. Para configurar un intervalo de tiempo de espera en el que se debe completar el flujo de trabajo, use una de las sobrecargas <xref:System.Activities.WorkflowInvoker.InvokeAsync%2A> que toman una estructura <xref:System.TimeSpan>.  
  
 Este método invoca de forma asincrónica un flujo de trabajo usando el modelo de diseño asincrónico basado en eventos. Para más información, consulte [Event-based Asynchronous Pattern Overview](https://go.microsoft.com/fwlink/?LinkId=141765) (Introducción al patrón asincrónico basado en eventos).  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="InvokeAsync">
      <MemberSignature Language="C#" Value="public void InvokeAsync ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void InvokeAsync() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowInvoker.InvokeAsync" />
      <MemberSignature Language="VB.NET" Value="Public Sub InvokeAsync ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void InvokeAsync();" />
      <MemberSignature Language="F#" Value="member this.InvokeAsync : unit -&gt; unit" Usage="workflowInvoker.InvokeAsync " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Invoca un flujo de trabajo de forma asincrónica.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para recibir una notificación cuando se complete el flujo de trabajo, controle el evento <xref:System.Activities.WorkflowInvoker.InvokeCompleted>. Para configurar un intervalo de tiempo de espera en el que se debe completar el flujo de trabajo, use una de las sobrecargas <xref:System.Activities.WorkflowInvoker.InvokeAsync%2A> que toman una estructura <xref:System.TimeSpan>.  
  
 Este método invoca de forma asincrónica un flujo de trabajo usando el modelo de diseño asincrónico basado en eventos. Para más información, consulte [Event-based Asynchronous Pattern Overview](https://go.microsoft.com/fwlink/?LinkId=141765) (Introducción al patrón asincrónico basado en eventos).  
  
   
  
## Examples  
 En el siguiente ejemplo se invoca un flujo de trabajo formado por una actividad `LongRunningDiceRoll`. La actividad `LongRunningDiceRoll` tiene dos argumentos de salida que representan los resultados de la operación de tirar los dados. Cuando se completa el flujo de trabajo, se recuperan en el controlador del evento <xref:System.Activities.WorkflowInvoker.InvokeCompleted>.  
  
 [!code-csharp[CFX_WorkflowInvokerExample#131](~/samples/snippets/csharp/VS_Snippets_CFX/cfx_workflowinvokerexample/cs/program.cs#131)]  
  
 [!code-csharp[CFX_WorkflowInvokerExample#33](~/samples/snippets/csharp/VS_Snippets_CFX/cfx_workflowinvokerexample/cs/program.cs#33)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="InvokeAsync">
      <MemberSignature Language="C#" Value="public void InvokeAsync (System.Collections.Generic.IDictionary&lt;string,object&gt; inputs);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void InvokeAsync(class System.Collections.Generic.IDictionary`2&lt;string, object&gt; inputs) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowInvoker.InvokeAsync(System.Collections.Generic.IDictionary{System.String,System.Object})" />
      <MemberSignature Language="VB.NET" Value="Public Sub InvokeAsync (inputs As IDictionary(Of String, Object))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void InvokeAsync(System::Collections::Generic::IDictionary&lt;System::String ^, System::Object ^&gt; ^ inputs);" />
      <MemberSignature Language="F#" Value="member this.InvokeAsync : System.Collections.Generic.IDictionary&lt;string, obj&gt; -&gt; unit" Usage="workflowInvoker.InvokeAsync inputs" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="inputs" Type="System.Collections.Generic.IDictionary&lt;System.String,System.Object&gt;" />
      </Parameters>
      <Docs>
        <param name="inputs">El diccionario de parámetros de entrada para el flujo de trabajo, ordenados por nombre de argumento.</param>
        <summary>Invoca un flujo de trabajo de forma asincrónica utilizando la <see cref="T:System.Collections.Generic.IDictionary`2" /> de parámetros de entrada especificada.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para recibir una notificación cuando se complete el flujo de trabajo, controle el evento <xref:System.Activities.WorkflowInvoker.InvokeCompleted>. Para configurar un intervalo de tiempo de espera en el que se debe completar el flujo de trabajo, use una de las sobrecargas <xref:System.Activities.WorkflowInvoker.InvokeAsync%2A> que toman una estructura <xref:System.TimeSpan>.  
  
 Este método invoca de forma asincrónica un flujo de trabajo usando el modelo de diseño asincrónico basado en eventos. Para más información, consulte [Event-based Asynchronous Pattern Overview](https://go.microsoft.com/fwlink/?LinkId=141765) (Introducción al patrón asincrónico basado en eventos).  
  
   
  
## Examples  
 En el siguiente ejemplo se invoca un flujo de trabajo formado por una actividad `LongRunningDiceRoll`. La actividad `LongRunningDiceRoll` tiene dos argumentos de salida que representan los resultados de la operación de tirar los dados. Cuando se completa el flujo de trabajo, se recuperan en el controlador del evento <xref:System.Activities.WorkflowInvoker.InvokeCompleted>.  
  
 [!code-csharp[CFX_WorkflowInvokerExample#131](~/samples/snippets/csharp/VS_Snippets_CFX/cfx_workflowinvokerexample/cs/program.cs#131)]  
  
 [!code-csharp[CFX_WorkflowInvokerExample#33](~/samples/snippets/csharp/VS_Snippets_CFX/cfx_workflowinvokerexample/cs/program.cs#33)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="InvokeAsync">
      <MemberSignature Language="C#" Value="public void InvokeAsync (object userState);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void InvokeAsync(object userState) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowInvoker.InvokeAsync(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub InvokeAsync (userState As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void InvokeAsync(System::Object ^ userState);" />
      <MemberSignature Language="F#" Value="member this.InvokeAsync : obj -&gt; unit" Usage="workflowInvoker.InvokeAsync userState" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="userState" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="userState">Objeto proporcionado por el usuario que se utiliza para distinguir esta operación concreta de invocación asincrónica de otras operaciones de invocación asincrónicas actuales.</param>
        <summary>Invoca un flujo de trabajo de forma asincrónica usando el identificador único especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El parámetro `userState` debe ser único para todas las operaciones <xref:System.Activities.WorkflowInvoker.InvokeAsync%2A> que se estén ejecutando en ese momento para la actividad actual. Si el parámetro `userState` no es único, se produce <xref:System.ArgumentException>. El parámetro `userState` se usa para identificar el flujo de trabajo del evento <xref:System.Activities.WorkflowInvoker.InvokeCompleted> y para cancelarlo mediante el método <xref:System.Activities.WorkflowInvoker.CancelAsync%2A>.  
  
 Para recibir una notificación cuando se complete el flujo de trabajo, controle el evento <xref:System.Activities.WorkflowInvoker.InvokeCompleted>. Para configurar un intervalo de tiempo de espera en el que se debe completar el flujo de trabajo, use una de las sobrecargas <xref:System.Activities.WorkflowInvoker.InvokeAsync%2A> que toman una estructura <xref:System.TimeSpan>.  
  
 Este método invoca de forma asincrónica un flujo de trabajo usando el modelo de diseño asincrónico basado en eventos. Para más información, consulte [Event-based Asynchronous Pattern Overview](https://go.microsoft.com/fwlink/?LinkId=141765) (Introducción al patrón asincrónico basado en eventos).  
  
   
  
## Examples  
 En el siguiente ejemplo se invoca un flujo de trabajo formado por una actividad `LongRunningDiceRoll`. La actividad `LongRunningDiceRoll` tiene dos argumentos de salida que representan los resultados de la operación de tirar los dados. Cuando se completa el flujo de trabajo, se recuperan en el controlador del evento <xref:System.Activities.WorkflowInvoker.InvokeCompleted>.  
  
 [!code-csharp[CFX_WorkflowInvokerExample#131](~/samples/snippets/csharp/VS_Snippets_CFX/cfx_workflowinvokerexample/cs/program.cs#131)]  
  
 [!code-csharp[CFX_WorkflowInvokerExample#33](~/samples/snippets/csharp/VS_Snippets_CFX/cfx_workflowinvokerexample/cs/program.cs#33)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="InvokeAsync">
      <MemberSignature Language="C#" Value="public void InvokeAsync (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void InvokeAsync(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowInvoker.InvokeAsync(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Sub InvokeAsync (timeout As TimeSpan)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void InvokeAsync(TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="member this.InvokeAsync : TimeSpan -&gt; unit" Usage="workflowInvoker.InvokeAsync timeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout">Intervalo de tiempo en el que se debe completar el flujo de trabajo antes de quedar anulado y de que se produzca una excepción <see cref="T:System.TimeoutException" />.</param>
        <summary>Invoca un flujo de trabajo de forma asincrónica con el intervalo de tiempo de espera especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para recibir una notificación cuando se complete el flujo de trabajo, controle el evento <xref:System.Activities.WorkflowInvoker.InvokeCompleted>. Si el flujo de trabajo no se completa dentro del intervalo de tiempo de espera especificado, se anula el flujo de trabajo y se produce una excepción <xref:System.TimeoutException>.  
  
> [!NOTE]
>  La excepción <xref:System.TimeoutException> solo se produce si se agota el tiempo de espera y el flujo de trabajo queda inactivo durante la ejecución. Un flujo de trabajo que tarda en completarse más tiempo que el especificado por el intervalo de tiempo de espera se completa correctamente si el flujo de trabajo no queda inactivo.  
  
 Este método invoca de forma asincrónica un flujo de trabajo usando el modelo de diseño asincrónico basado en eventos. Para más información, consulte [Event-based Asynchronous Pattern Overview](https://go.microsoft.com/fwlink/?LinkId=141765) (Introducción al patrón asincrónico basado en eventos).  
  
   
  
## Examples  
 En el siguiente ejemplo se invoca un flujo de trabajo formado por una actividad `LongRunningDiceRoll`. La actividad `LongRunningDiceRoll` tiene dos argumentos de salida que representan los resultados de la operación de tirar los dados. Cuando se completa el flujo de trabajo, se recuperan en el controlador del evento <xref:System.Activities.WorkflowInvoker.InvokeCompleted>.  
  
 [!code-csharp[CFX_WorkflowInvokerExample#131](~/samples/snippets/csharp/VS_Snippets_CFX/cfx_workflowinvokerexample/cs/program.cs#131)]  
  
 [!code-csharp[CFX_WorkflowInvokerExample#33](~/samples/snippets/csharp/VS_Snippets_CFX/cfx_workflowinvokerexample/cs/program.cs#33)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="InvokeAsync">
      <MemberSignature Language="C#" Value="public void InvokeAsync (System.Collections.Generic.IDictionary&lt;string,object&gt; inputs, object userState);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void InvokeAsync(class System.Collections.Generic.IDictionary`2&lt;string, object&gt; inputs, object userState) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowInvoker.InvokeAsync(System.Collections.Generic.IDictionary{System.String,System.Object},System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub InvokeAsync (inputs As IDictionary(Of String, Object), userState As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void InvokeAsync(System::Collections::Generic::IDictionary&lt;System::String ^, System::Object ^&gt; ^ inputs, System::Object ^ userState);" />
      <MemberSignature Language="F#" Value="member this.InvokeAsync : System.Collections.Generic.IDictionary&lt;string, obj&gt; * obj -&gt; unit" Usage="workflowInvoker.InvokeAsync (inputs, userState)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="inputs" Type="System.Collections.Generic.IDictionary&lt;System.String,System.Object&gt;" />
        <Parameter Name="userState" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="inputs">El diccionario de parámetros de entrada para el flujo de trabajo, ordenados por nombre de argumento.</param>
        <param name="userState">Objeto proporcionado por el usuario que se utiliza para distinguir esta operación concreta de invocación asincrónica de otras operaciones de invocación asincrónicas actuales.</param>
        <summary>Invoca un flujo de trabajo de forma asincrónica usando la interfaz <see cref="T:System.Collections.Generic.IDictionary`2" /> de parámetros de entrada especificada y un identificador único.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El parámetro `userState` debe ser único para todas las operaciones <xref:System.Activities.WorkflowInvoker.InvokeAsync%2A> que se estén ejecutando en ese momento para la actividad actual. Si `userState` no es único, se produce <xref:System.ArgumentException>. El parámetro `userState` se usa para identificar el flujo de trabajo del evento <xref:System.Activities.WorkflowInvoker.InvokeCompleted> y para cancelarlo mediante el método <xref:System.Activities.WorkflowInvoker.CancelAsync%2A>.  
  
 Para recibir una notificación cuando se complete el flujo de trabajo, controle el evento <xref:System.Activities.WorkflowInvoker.InvokeCompleted>. Para configurar un intervalo de tiempo de espera en el que se debe completar el flujo de trabajo, use una de las sobrecargas <xref:System.Activities.WorkflowInvoker.InvokeAsync%2A> que toman una estructura <xref:System.TimeSpan>.  
  
 Este método invoca de forma asincrónica un flujo de trabajo usando el modelo de diseño asincrónico basado en eventos. Para más información, consulte [Event-based Asynchronous Pattern Overview](https://go.microsoft.com/fwlink/?LinkId=141765) (Introducción al patrón asincrónico basado en eventos).  
  
   
  
## Examples  
 En el siguiente ejemplo se invoca un flujo de trabajo formado por una actividad `LongRunningDiceRoll`. La actividad `LongRunningDiceRoll` tiene dos argumentos de salida que representan los resultados de la operación de tirar los dados. Cuando se completa el flujo de trabajo, se recuperan en el controlador del evento <xref:System.Activities.WorkflowInvoker.InvokeCompleted>.  
  
 [!code-csharp[CFX_WorkflowInvokerExample#131](~/samples/snippets/csharp/VS_Snippets_CFX/cfx_workflowinvokerexample/cs/program.cs#131)]  
  
 [!code-csharp[CFX_WorkflowInvokerExample#33](~/samples/snippets/csharp/VS_Snippets_CFX/cfx_workflowinvokerexample/cs/program.cs#33)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="InvokeAsync">
      <MemberSignature Language="C#" Value="public void InvokeAsync (System.Collections.Generic.IDictionary&lt;string,object&gt; inputs, TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void InvokeAsync(class System.Collections.Generic.IDictionary`2&lt;string, object&gt; inputs, valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowInvoker.InvokeAsync(System.Collections.Generic.IDictionary{System.String,System.Object},System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Sub InvokeAsync (inputs As IDictionary(Of String, Object), timeout As TimeSpan)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void InvokeAsync(System::Collections::Generic::IDictionary&lt;System::String ^, System::Object ^&gt; ^ inputs, TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="member this.InvokeAsync : System.Collections.Generic.IDictionary&lt;string, obj&gt; * TimeSpan -&gt; unit" Usage="workflowInvoker.InvokeAsync (inputs, timeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="inputs" Type="System.Collections.Generic.IDictionary&lt;System.String,System.Object&gt;" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="inputs">El diccionario de parámetros de entrada para el flujo de trabajo, ordenados por nombre de argumento.</param>
        <param name="timeout">Intervalo de tiempo en el que se debe completar el flujo de trabajo antes de quedar anulado y de que se produzca una excepción <see cref="T:System.TimeoutException" />.</param>
        <summary>Invoca de forma asincrónica un flujo de trabajo con la interfaz <see cref="T:System.Collections.Generic.IDictionary`2" /> de parámetros de entrada y el intervalo de tiempo de espera especificados.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para recibir una notificación cuando se complete el flujo de trabajo, controle el evento <xref:System.Activities.WorkflowInvoker.InvokeCompleted>. Si el flujo de trabajo no se completa dentro del intervalo de tiempo de espera especificado, se anula el flujo de trabajo y se produce una excepción <xref:System.TimeoutException>.  
  
> [!NOTE]
>  La excepción <xref:System.TimeoutException> solo se produce si se agota el tiempo de espera y el flujo de trabajo queda inactivo durante la ejecución. Un flujo de trabajo que tarda en completarse más tiempo que el especificado por el intervalo de tiempo de espera se completa correctamente si el flujo de trabajo no queda inactivo.  
  
 Este método invoca de forma asincrónica un flujo de trabajo usando el modelo de diseño asincrónico basado en eventos. Para más información, consulte [Event-based Asynchronous Pattern Overview](https://go.microsoft.com/fwlink/?LinkId=141765) (Introducción al patrón asincrónico basado en eventos).  
  
   
  
## Examples  
 En el siguiente ejemplo se invoca un flujo de trabajo formado por una actividad `LongRunningDiceRoll`. La actividad `LongRunningDiceRoll` tiene dos argumentos de salida que representan los resultados de la operación de tirar los dados. Cuando se completa el flujo de trabajo, se recuperan en el controlador del evento <xref:System.Activities.WorkflowInvoker.InvokeCompleted>.  
  
 [!code-csharp[CFX_WorkflowInvokerExample#131](~/samples/snippets/csharp/VS_Snippets_CFX/cfx_workflowinvokerexample/cs/program.cs#131)]  
  
 [!code-csharp[CFX_WorkflowInvokerExample#33](~/samples/snippets/csharp/VS_Snippets_CFX/cfx_workflowinvokerexample/cs/program.cs#33)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="InvokeAsync">
      <MemberSignature Language="C#" Value="public void InvokeAsync (TimeSpan timeout, object userState);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void InvokeAsync(valuetype System.TimeSpan timeout, object userState) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowInvoker.InvokeAsync(System.TimeSpan,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub InvokeAsync (timeout As TimeSpan, userState As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void InvokeAsync(TimeSpan timeout, System::Object ^ userState);" />
      <MemberSignature Language="F#" Value="member this.InvokeAsync : TimeSpan * obj -&gt; unit" Usage="workflowInvoker.InvokeAsync (timeout, userState)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="userState" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="timeout">Intervalo de tiempo en el que se debe completar el flujo de trabajo antes de quedar anulado y de que se produzca una excepción <see cref="T:System.TimeoutException" />.</param>
        <param name="userState">Objeto proporcionado por el usuario que se utiliza para distinguir esta operación concreta de invocación asincrónica de otras operaciones de invocación asincrónicas actuales.</param>
        <summary>Invoca de forma asincrónica un flujo de trabajo con el intervalo de tiempo de espera especificado y un identificador único.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El parámetro `userState` debe ser único para todas las operaciones <xref:System.Activities.WorkflowInvoker.InvokeAsync%2A> que se estén ejecutando en ese momento para la actividad actual. Si `userState` no es único, se produce <xref:System.ArgumentException>. El parámetro `userState` se usa para identificar el flujo de trabajo del evento <xref:System.Activities.WorkflowInvoker.InvokeCompleted> y para cancelarlo mediante el método <xref:System.Activities.WorkflowInvoker.CancelAsync%2A>.  
  
 Para recibir una notificación cuando se complete el flujo de trabajo, controle el evento <xref:System.Activities.WorkflowInvoker.InvokeCompleted>. Si el flujo de trabajo no se completa dentro del intervalo de tiempo de espera especificado, se anula el flujo de trabajo y se produce una excepción <xref:System.TimeoutException>.  
  
> [!NOTE]
>  La excepción <xref:System.TimeoutException> solo se produce si se agota el tiempo de espera y el flujo de trabajo queda inactivo durante la ejecución. Un flujo de trabajo que tarda en completarse más tiempo que el especificado por el intervalo de tiempo de espera se completa correctamente si el flujo de trabajo no queda inactivo.  
  
 Este método invoca de forma asincrónica un flujo de trabajo usando el modelo de diseño asincrónico basado en eventos. Para más información, consulte [Event-based Asynchronous Pattern Overview](https://go.microsoft.com/fwlink/?LinkId=141765) (Introducción al patrón asincrónico basado en eventos).  
  
   
  
## Examples  
 En el siguiente ejemplo se invoca un flujo de trabajo formado por una actividad `LongRunningDiceRoll`. La actividad `LongRunningDiceRoll` tiene dos argumentos de salida que representan los resultados de la operación de tirar los dados. Cuando se completa el flujo de trabajo, se recuperan en el controlador del evento <xref:System.Activities.WorkflowInvoker.InvokeCompleted>.  
  
 [!code-csharp[CFX_WorkflowInvokerExample#131](~/samples/snippets/csharp/VS_Snippets_CFX/cfx_workflowinvokerexample/cs/program.cs#131)]  
  
 [!code-csharp[CFX_WorkflowInvokerExample#33](~/samples/snippets/csharp/VS_Snippets_CFX/cfx_workflowinvokerexample/cs/program.cs#33)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="InvokeAsync">
      <MemberSignature Language="C#" Value="public void InvokeAsync (System.Collections.Generic.IDictionary&lt;string,object&gt; inputs, TimeSpan timeout, object userState);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void InvokeAsync(class System.Collections.Generic.IDictionary`2&lt;string, object&gt; inputs, valuetype System.TimeSpan timeout, object userState) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activities.WorkflowInvoker.InvokeAsync(System.Collections.Generic.IDictionary{System.String,System.Object},System.TimeSpan,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub InvokeAsync (inputs As IDictionary(Of String, Object), timeout As TimeSpan, userState As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void InvokeAsync(System::Collections::Generic::IDictionary&lt;System::String ^, System::Object ^&gt; ^ inputs, TimeSpan timeout, System::Object ^ userState);" />
      <MemberSignature Language="F#" Value="member this.InvokeAsync : System.Collections.Generic.IDictionary&lt;string, obj&gt; * TimeSpan * obj -&gt; unit" Usage="workflowInvoker.InvokeAsync (inputs, timeout, userState)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="inputs" Type="System.Collections.Generic.IDictionary&lt;System.String,System.Object&gt;" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="userState" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="inputs">El diccionario de parámetros de entrada para el flujo de trabajo, ordenados por nombre de argumento.</param>
        <param name="timeout">Intervalo de tiempo en el que se debe completar el flujo de trabajo antes de quedar anulado y de que se produzca una excepción <see cref="T:System.TimeoutException" />.</param>
        <param name="userState">Objeto proporcionado por el usuario que se utiliza para distinguir esta operación concreta de invocación asincrónica de otras operaciones de invocación asincrónicas actuales.</param>
        <summary>Invoca de forma asincrónica un flujo de trabajo con la interfaz <see cref="T:System.Collections.Generic.IDictionary`2" /> de parámetros de entrada especificada, el intervalo de tiempo de espera especificado y un identificador único.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El parámetro `userState` debe ser único para todas las operaciones <xref:System.Activities.WorkflowInvoker.InvokeAsync%2A> que se estén ejecutando en ese momento para la actividad actual. Si `userState` no es único, se produce <xref:System.ArgumentException>. El parámetro `userState` se usa para identificar el flujo de trabajo del evento <xref:System.Activities.WorkflowInvoker.InvokeCompleted> y para cancelarlo mediante el método <xref:System.Activities.WorkflowInvoker.CancelAsync%2A>.  
  
 Para recibir una notificación cuando se complete el flujo de trabajo, controle el evento <xref:System.Activities.WorkflowInvoker.InvokeCompleted>. Si el flujo de trabajo no se completa dentro del intervalo de tiempo de espera especificado, se anula el flujo de trabajo y se produce una excepción <xref:System.TimeoutException>.  
  
> [!NOTE]
>  La excepción <xref:System.TimeoutException> solo se produce si se agota el tiempo de espera y el flujo de trabajo queda inactivo durante la ejecución. Un flujo de trabajo que tarda en completarse más tiempo que el especificado por el intervalo de tiempo de espera se completa correctamente si el flujo de trabajo no queda inactivo.  
  
 Este método invoca de forma asincrónica un flujo de trabajo usando el modelo de diseño asincrónico basado en eventos. Para más información, consulte [Event-based Asynchronous Pattern Overview](https://go.microsoft.com/fwlink/?LinkId=141765) (Introducción al patrón asincrónico basado en eventos).  
  
   
  
## Examples  
 En el siguiente ejemplo se invoca un flujo de trabajo formado por una actividad `LongRunningDiceRoll`. La actividad `LongRunningDiceRoll` tiene dos argumentos de salida que representan los resultados de la operación de tirar los dados. Cuando se completa el flujo de trabajo, se recuperan en el controlador del evento <xref:System.Activities.WorkflowInvoker.InvokeCompleted>.  
  
 [!code-csharp[CFX_WorkflowInvokerExample#131](~/samples/snippets/csharp/VS_Snippets_CFX/cfx_workflowinvokerexample/cs/program.cs#131)]  
  
 [!code-csharp[CFX_WorkflowInvokerExample#33](~/samples/snippets/csharp/VS_Snippets_CFX/cfx_workflowinvokerexample/cs/program.cs#33)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="InvokeCompleted">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Activities.InvokeCompletedEventArgs&gt; InvokeCompleted;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Activities.InvokeCompletedEventArgs&gt; InvokeCompleted" />
      <MemberSignature Language="DocId" Value="E:System.Activities.WorkflowInvoker.InvokeCompleted" />
      <MemberSignature Language="VB.NET" Value="Public Event InvokeCompleted As EventHandler(Of InvokeCompletedEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler&lt;System::Activities::InvokeCompletedEventArgs ^&gt; ^ InvokeCompleted;" />
      <MemberSignature Language="F#" Value="member this.InvokeCompleted : EventHandler&lt;System.Activities.InvokeCompletedEventArgs&gt; " Usage="member this.InvokeCompleted : System.EventHandler&lt;System.Activities.InvokeCompletedEventArgs&gt; " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Activities</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Activities.InvokeCompletedEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produce cuando se completa o se cancela el flujo de trabajo invocado por una de las sobrecargas <see cref="Overload:System.Activities.WorkflowInvoker.InvokeAsync" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Controle este evento para determinar si un flujo de trabajo invocado con una de las sobrecargas <xref:System.Activities.WorkflowInvoker.InvokeAsync%2A> se completó correctamente y recuperar los argumentos de salida del flujo de trabajo completado.  
  
   
  
## Examples  
 En el siguiente ejemplo se invoca un flujo de trabajo formado por una actividad `LongRunningDiceRoll`. La actividad `LongRunningDiceRoll` tiene dos argumentos de salida que representan los resultados de la operación de tirar los dados. Cuando se completa el flujo de trabajo, se recuperan en el controlador del evento <xref:System.Activities.WorkflowInvoker.InvokeCompleted>.  
  
 [!code-csharp[CFX_WorkflowInvokerExample#131](~/samples/snippets/csharp/VS_Snippets_CFX/cfx_workflowinvokerexample/cs/program.cs#131)]  
  
 [!code-csharp[CFX_WorkflowInvokerExample#33](~/samples/snippets/csharp/VS_Snippets_CFX/cfx_workflowinvokerexample/cs/program.cs#33)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>