<Type Name="Enum" FullName="System.Enum">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="7fbf78cb66a29f9b14bfa93ea0c7f6c82fc2d8b1" />
    <Meta Name="ms.sourcegitcommit" Value="d877ae76e9e11799bf919379507239e2c4072742" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="es-ES" />
    <Meta Name="ms.lasthandoff" Value="08/09/2018" />
    <Meta Name="ms.locfileid" Value="39766193" />
  </Metadata>
  <TypeSignature Language="C#" Value="public abstract class Enum : ValueType, IComparable, IConvertible, IFormattable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract serializable beforefieldinit Enum extends System.ValueType implements class System.IComparable, class System.IConvertible, class System.IFormattable" />
  <TypeSignature Language="DocId" Value="T:System.Enum" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class Enum&#xA;Inherits ValueType&#xA;Implements IComparable, IConvertible, IFormattable" />
  <TypeSignature Language="C++ CLI" Value="public ref class Enum abstract : ValueType, IComparable, IConvertible, IFormattable" />
  <TypeSignature Language="F#" Value="type Enum = class&#xA;    inherit ValueType&#xA;    interface IComparable&#xA;    interface IFormattable&#xA;    interface IConvertible" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.ValueType</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IComparable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IConvertible</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IFormattable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Proporciona la clase base para las enumeraciones.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Una enumeración es un conjunto de constantes con nombre cuyo tipo subyacente es cualquier tipo entero. Si no hay ningún tipo subyacente se declara explícitamente, <xref:System.Int32> se utiliza. <xref:System.Enum> es la clase base para todas las enumeraciones de .NET Framework. Tipos de enumeración se definen mediante la `enum` palabra clave en C# y el `Enum`... `End Enum` construir en Visual Basic.  
  
 <xref:System.Enum> Proporciona métodos para comparar instancias de esta clase, convertir el valor de una instancia en su representación de cadena, convertir la representación de cadena de un número a una instancia de esta clase y crear una instancia de una enumeración y valor especificados.  
  
 También puede tratar una enumeración como un campo de bits. Para obtener más información, consulte el [miembros no exclusiva y el atributo Flags](#Flags) sección y el <xref:System.FlagsAttribute> tema.  
  
 En este tema:  
  
 [Creación de un tipo de enumeración](#Creating)   
 [Crear una instancia de un tipo de enumeración](#Instantiating)   
 [Prácticas recomendadas de enumeración](#BestPractices)   
 [Realizar operaciones con enumeraciones](#Operations)   
 [Realizar conversión](#conversions)  
 [Análisis de los valores de enumeración](#parsing)  
 [Dar formato a valores de enumeración](#formatting)  
[Recorrer en iteración los miembros de enumeración](#iterating)  
[Los miembros no exclusiva y el atributo Flags](#Flags)  
[Adición de métodos de enumeración](#methods)  
  
<a name="Creating"></a>   
## <a name="creating-an-enumeration-type"></a>Creación de un tipo de enumeración  
 Normalmente, los lenguajes de programación proporcionan sintaxis para declarar una enumeración que consta de un conjunto de constantes con nombre y sus valores. El ejemplo siguiente muestra la sintaxis que usa C# y Visual Basic para definir una enumeración. Crea una enumeración denominada `ArrivalStatus` que tiene tres miembros: `ArrivalStatus.Early`, `ArrivalStatus.OnTime`, y `ArrivalStatus.Late`. Tenga en cuenta que en ambos casos, la enumeración no heredar explícitamente de <xref:System.Enum>; la relación de herencia se trata implícitamente por el compilador.  
  
 [!code-csharp[System.Enum.Class#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.enum.class/cs/class1.cs#1)]
 [!code-vb[System.Enum.Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.enum.class/vb/class1.vb#1)]  
  
> [!WARNING]
>  Nunca se debe crear un tipo de enumeración cuyo tipo subyacente es que no sean enteros o <xref:System.Char>. Aunque puede crear un tipo de enumeración de este tipo mediante la reflexión, las llamadas de método que usan el tipo resultante no son confiables y también pueden producir excepciones adicionales.  
  
<a name="Instantiating"></a>   
## <a name="instantiating-an-enumeration-type"></a>Crear una instancia de un tipo de enumeración  
 Puede crear instancias de un tipo de enumeración como crear una instancia de cualquier otro tipo de valor: declarando una variable y asignarle una de las constantes de la enumeración. El ejemplo siguiente crea un `ArrivalStatus` cuyo valor es `ArrivalStatus.OnTime`.  
  
 [!code-csharp[System.Enum.Class#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.enum.class/cs/class1.cs#2)]
 [!code-vb[System.Enum.Class#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.enum.class/vb/class1.vb#2)]  
  
 También puede crear una instancia de un valor de enumeración de las maneras siguientes:  
  
-   Mediante el uso de las características de un lenguaje de programación determinado para convertir (como en C#) o convertir un valor entero (como en Visual Basic) a un valor de enumeración. En el ejemplo siguiente se crea un `ArrivalStatus` objeto cuyo valor es `ArrivalStatus.Early` de esta manera.  
  
     [!code-csharp[System.Enum.Class#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.enum.class/cs/class2.cs#4)]
     [!code-vb[System.Enum.Class#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.enum.class/vb/class2.vb#4)]  
  
-   Mediante una llamada a su constructor predeterminado implícito. Como se muestra en el ejemplo siguiente, en este caso el valor subyacente de la instancia de enumeración es 0. Sin embargo, esto no es necesariamente el valor de una constante válida en la enumeración.  
  
     [!code-csharp[System.Enum.Class#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.enum.class/cs/class2.cs#3)]
     [!code-vb[System.Enum.Class#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.enum.class/vb/class2.vb#3)]  
  
-   Mediante una llamada a la <xref:System.Enum.Parse%2A> o <xref:System.Enum.TryParse%2A> método para analizar una cadena que contiene el nombre de una constante de la enumeración. Para obtener más información, consulte el [analizar valores de enumeración](#parsing) sección.  
  
-   Mediante una llamada a la <xref:System.Enum.ToObject%2A> método para convertir un valor entero en un tipo de enumeración. Para obtener más información, consulte el [realizar conversiones](#conversions) sección.  
  
<a name="BestPractices"></a>   
## <a name="enumeration-best-practices"></a>Prácticas recomendadas de enumeración  
 Se recomienda usar los siguientes procedimientos recomendados al definir los tipos de enumeración:  
  
-   Si no ha definido un miembro de enumeración cuyo valor es 0, considere la posibilidad de crear un `None` constante enumerada. De forma predeterminada, la memoria utilizada para la enumeración se inicializa en cero por common language runtime. Por lo tanto, si no se define una constante cuyo valor es cero, la enumeración contendrá un valor no válido cuando se crea.  
  
-   Si hay un caso predeterminado obvio que la aplicación tiene que representar, considere el uso de enumerado constante cuyo valor es cero para representarlo. Si no hay ningún caso predeterminado, considere el uso de una constante enumerada cuyo valor es cero para especificar el caso de que no está representado por cualquiera de las otras constantes enumeradas.  
  
-   No especifique constantes enumeradas que se reservan para uso futuro.  
  
-   Al definir un método o propiedad que toma una constante enumerada como un valor, considere la posibilidad de validar el valor. El motivo es que puede convertir un valor numérico para el tipo de enumeración, incluso si ese valor numérico no está definido en la enumeración.  
  
 Recomendaciones adicionales para tipos de enumeración cuyos constantes son campos de bits se muestran en el [miembros no exclusiva y el atributo Flags](#Flags) sección.  
  
<a name="Operations"></a>   
## <a name="performing-operations-with-enumerations"></a>Realizar operaciones con enumeraciones  
 No se puede definir nuevos métodos al crear una enumeración. Sin embargo, un tipo de enumeración hereda un conjunto completo de estático y los métodos de instancia desde la <xref:System.Enum> clase. La mayoría de estos métodos, además de otros métodos que se usan con frecuencia cuando se trabaja con valores de enumeración de la encuesta en las secciones siguientes.  
  
<a name="conversions"></a>   
### <a name="performing-conversions"></a>Realizar conversión  
 Puede convertir entre un miembro de enumeración y su tipo subyacente mediante una conversión (en C#) o el operador de conversión (en Visual Basic). El ejemplo siguiente utiliza los operadores de conversión o realizar las conversiones de entero a un valor de enumeración y de un valor de enumeración en un entero.  
  
 [!code-csharp[System.Enum.Class#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.enum.class/cs/class2.cs#5)]
 [!code-vb[System.Enum.Class#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.enum.class/vb/class2.vb#5)]  
  
 El <xref:System.Enum> clase también incluye un <xref:System.Enum.ToObject%2A> método que convierte un valor de cualquier tipo entero a un valor de enumeración. En el ejemplo siguiente se usa el <xref:System.Enum.ToObject%28System.Type%2CSystem.Int32%29> método para convertir un <xref:System.Int32> a un `ArrivalStatus` valor. Tenga en cuenta que, dado el <xref:System.Enum.ToObject%2A> devuelve un valor de tipo <xref:System.Object>, el uso de un operador de conversión puede seguir siendo necesario convertir el objeto en el tipo de enumeración.  
  
 [!code-csharp[System.Enum.Class#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.enum.class/cs/class2.cs#6)]
 [!code-vb[System.Enum.Class#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.enum.class/vb/class2.vb#6)]  
  
 Al convertir a un entero en un valor de enumeración, es posible asignar un valor que no es realmente un miembro de la enumeración. Para evitar esto, puede pasar el entero para el <xref:System.Enum.IsDefined%2A> método antes de realizar la conversión. En el ejemplo siguiente se usa este método para determinar si se pueden convertir los elementos de una matriz de valores enteros en `ArrivalStatus` valores.  
  
 [!code-csharp[System.Enum.Class#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.enum.class/cs/classconversion1.cs#7)]
 [!code-vb[System.Enum.Class#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.enum.class/vb/classconversion1.vb#7)]  
  
 Aunque el <xref:System.Enum> clase proporciona las implementaciones de interfaz explícita de la <xref:System.IConvertible> interfaz para convertir un valor de enumeración en un tipo entero, debe usar los métodos de la <xref:System.Convert> clase, como <xref:System.Convert.ToInt32%2A>, a realizar estas conversiones. El ejemplo siguiente muestra cómo puede usar el <xref:System.Enum.GetUnderlyingType%2A> método junto con el <xref:System.Convert.ChangeType%2A?displayProperty=nameWithType> método para convertir un valor de enumeración en su tipo subyacente. Tenga en cuenta que este ejemplo no requiere el tipo subyacente de la enumeración que se conoce en tiempo de compilación.  
  
 [!code-csharp[System.Enum.Class#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.enum.class/cs/classconversion2.cs#8)]
 [!code-vb[System.Enum.Class#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.enum.class/vb/classconversion2.vb#8)]  
  
<a name="parsing"></a>   
### <a name="parsing-enumeration-values"></a>Análisis de los valores de enumeración  
 El <xref:System.Enum.Parse%2A> y <xref:System.Enum.TryParse%2A> métodos permiten convertir la representación de cadena de un valor de enumeración en ese valor. La representación de cadena puede ser el nombre o el valor subyacente de una constante de enumeración. Tenga en cuenta que los métodos de análisis convertirá correctamente las representaciones de cadena de números que no son miembros de una enumeración determinado si las cadenas se pueden convertir en un valor de tipo subyacente de la enumeración. Para evitar esto, el <xref:System.Enum.IsDefined%2A> se puede llamar el método para asegurarse de que el resultado del método de análisis es un valor de enumeración válido. En el ejemplo se muestra este enfoque y muestra las llamadas a ambos el <xref:System.Enum.Parse%28System.Type%2CSystem.String%29> y <xref:System.Enum.TryParse%60%601%28System.String%2C%60%600%40%29?displayProperty=nameWithType> métodos. Tenga en cuenta que el método de análisis no genérica devuelve un objeto que es posible que deba convierta (en C#) o (en Visual Basic) para el tipo de enumeración adecuados.  
  
 [!code-csharp[System.Enum.Class#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.enum.class/cs/classparse1.cs#9)]
 [!code-vb[System.Enum.Class#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.enum.class/vb/classparse1.vb#9)]  
  
<a name="formatting"></a>   
### <a name="formatting-enumeration-values"></a>Dar formato a valores de enumeración  
 Puede convertir los valores de enumeración en sus representaciones de cadena mediante una llamada a estático <xref:System.Enum.Format%2A> método, así como las sobrecargas de la instancia <xref:System.Enum.ToString%2A> método. Puede usar una cadena de formato para controlar la manera precisa en el que un valor de enumeración se representa como una cadena. Para obtener más información, consulte [Enumeration Format Strings](~/docs/standard/base-types/enumeration-format-strings.md). El ejemplo siguiente usa cada una de las cadenas de formato de enumeración admitidos ("G" o "g", "D" o "d", "X" o "x" y "F" o "f") para convertir un miembro de la `ArrivalStatus` enumeración en sus representaciones de cadena.  
  
 [!code-csharp[System.Enum.Class#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.enum.class/cs/classformat1.cs#10)]
 [!code-vb[System.Enum.Class#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.enum.class/vb/classformat1.vb#10)]  
  
<a name="iterating"></a>   
### <a name="iterating-enumeration-members"></a>Recorrer en iteración los miembros de enumeración  
 El <xref:System.Enum> tipo no implementa la <xref:System.Collections.IEnumerable> o <xref:System.Collections.Generic.IEnumerable%601> interfaz, que le permitirá recorrer en iteración los miembros de una colección mediante el uso de un `foreach` (en C#) o `For Each` (en Visual Basic) construir. Sin embargo, puede enumerar a los miembros de dos maneras.  
  
-   Puede llamar a la <xref:System.Enum.GetNames%2A> método para recuperar una matriz de cadenas que contiene los nombres de los miembros de enumeración. A continuación, para cada elemento de la matriz de cadenas, puede llamar a la <xref:System.Enum.Parse%2A> método para convertir la cadena en su valor de enumeración equivalente. En el ejemplo siguiente se muestra este enfoque.  
  
     [!code-csharp[System.Enum.Class#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.enum.class/cs/classiterate.cs#11)]
     [!code-vb[System.Enum.Class#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.enum.class/vb/classiterate.vb#11)]  
  
-   Puede llamar a la <xref:System.Enum.GetValues%2A> método para recuperar una matriz que contiene la base de los valores de la enumeración. A continuación, para cada elemento de la matriz, puede llamar a la <xref:System.Enum.ToObject%2A> método para convertir el entero en su valor de enumeración equivalente. En el ejemplo siguiente se muestra este enfoque.  
  
     [!code-csharp[System.Enum.Class#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.enum.class/cs/classiterate.cs#12)]
     [!code-vb[System.Enum.Class#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.enum.class/vb/classiterate.vb#12)]  
  
<a name="Flags"></a>   
## <a name="non-exclusive-members-and-the-flags-attribute"></a>Los miembros no exclusiva y el atributo Flags  
 Un uso común de una enumeración que se va a representar un conjunto de valores mutuamente exclusivos. Por ejemplo, un `ArrivalStatus` instancia puede tener un valor de `Early`, `OnTime`, o `Late`. No tiene sentido para el valor de un `ArrivalStatus` instancia para reflejar más de una constante de enumeración.  
  
 Sin embargo, en otros casos, el valor de un objeto de enumeración puede incluir a varios miembros de enumeración y cada miembro representa un campo de bits en el valor de enumeración. El <xref:System.FlagsAttribute> atributo se puede usar para indicar que la enumeración se compone de campos de bits. Por ejemplo, una enumeración denominada `Pets` podría utilizarse para indicar los tipos de mascotas en una casa. Puede definirse como sigue.  
  
 [!code-csharp[System.Enum.Class#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.enum.class/cs/classbitwise1.cs#13)]
 [!code-vb[System.Enum.Class#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.enum.class/vb/classbitwise1.vb#13)]  
  
 El `Pets` , a continuación, se puede usar la enumeración como se muestra en el ejemplo siguiente.  
  
 [!code-csharp[System.Enum.Class#14](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.enum.class/cs/classbitwise1.cs#14)]
 [!code-vb[System.Enum.Class#14](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.enum.class/vb/classbitwise1.vb#14)]  
  
 Se deben usar los siguientes procedimientos recomendados al definir un bit a bit de enumeración y aplicar el <xref:System.FlagsAttribute> atributo.  
  
-   Use el <xref:System.FlagsAttribute> atributo personalizado para una enumeración solo si es una operación bit a bit (AND, OR exclusivo o) que se realizará en un valor numérico.  
  
-   Constantes de enumeración se definen en potencias de dos, es decir, 1, 2, 4, 8 y así sucesivamente. Esto significa que no se superponen las marcas individuales en constantes de enumeración combinadas.  
  
-   Considere la posibilidad de crear una constante enumerada para combinaciones de marcadores usados. Por ejemplo, si tiene una enumeración que se usa para las operaciones de E/S de archivo que contiene las constantes enumeradas `Read = 1` y `Write = 2`, considere la posibilidad de crear la constante enumerada `ReadWrite = Read OR Write`, que combina el `Read` y `Write` marcas. Además, la operación OR bit a bit utilizada para combinar las marcas podría considerarse un concepto avanzado en algunas circunstancias que no debería requerirse para tareas sencillas.  
  
-   Tenga cuidado si define un número negativo como una constante enumerada marca porque muchas de las posiciones indicador pueden establecerse en 1, lo que podría hacer que el código confuso y animar a errores de codificación.  
  
-   Una manera cómoda para comprobar si se establece una marca de un valor numérico es llamar a la instancia <xref:System.Enum.HasFlag%2A> método, como se muestra en el ejemplo siguiente.  
  
     [!code-csharp[System.Enum.Class#15](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.enum.class/cs/classbitwise1.cs#15)]
     [!code-vb[System.Enum.Class#15](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.enum.class/vb/classbitwise1.vb#15)]  
  
     Es equivalente a realizar una operación AND bit a bit entre el valor numérico y la constante enumerada de marca, que establece todos los bits del valor numérico de cero que no corresponden a la marca, y, a continuación, comprobar si el resultado de esa operación es igual a la constante enumerada del indicador. Esto se muestra en el ejemplo siguiente.  
  
     [!code-csharp[System.Enum.Class#16](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.enum.class/cs/classbitwise1.cs#16)]
     [!code-vb[System.Enum.Class#16](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.enum.class/vb/classbitwise1.vb#16)]  
  
-   Use `None` como el nombre de la marca enumerada constante cuyo valor es cero. No puede usar el `None` constante enumerada en una operación AND bit a bit para probar un marcador porque el resultado siempre es cero. Sin embargo, puede realizar una operación lógica, no una comparación bit a bit, entre el valor numérico y el `None` constante enumerada para determinar si están establecidos los bits del valor numérico. Esto se muestra en el ejemplo siguiente.  
  
     [!code-csharp[System.Enum.Class#17](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.enum.class/cs/classbitwise1.cs#17)]
     [!code-vb[System.Enum.Class#17](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.enum.class/vb/classbitwise1.vb#17)]  
  
-   No defina un valor de enumeración únicamente para reflejar el estado de la propia enumeración. Por ejemplo, no se define una constante enumerada que simplemente marca el final de la enumeración. Si necesita determinar el último valor de la enumeración, comprobar explícitamente si ese valor. Además, puede realizar una comprobación de intervalo para la constante enumerada primera y última si todos los valores dentro del intervalo son válidos.  
  
<a name="methods"></a>   
## <a name="adding-enumeration-methods"></a>Adición de métodos de enumeración  
 Dado que los tipos de enumeración se definen como estructuras de lenguaje, `enum` (C#) y `Enum` (Visual Basic), no se puede definir los métodos personalizados para un tipo de enumeración distinto de esos métodos heredados de la <xref:System.Enum> clase.  Sin embargo, puede usar los métodos de extensión para agregar funcionalidad a un tipo de enumeración concreto.  
  
 En el ejemplo siguiente, la enumeración `Grades` representa las posibles calificaciones con letras que un alumno puede recibir en una clase. Un método de extensión denominado `Passing` se agrega al tipo `Grades` para que cada instancia de ese tipo "sepa" ahora si representa una calificación de aprobado o no.       La `Extensions` clase también contiene una variable de lectura y escritura estática que define la calificación de aprobado mínimo. El valor devuelto de la `Passing` método de extensión refleja el valor actual de esa variable.  
  
 [!code-csharp[System.Enum.Class#18](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.enum.class/cs/Extensions.cs#18)]
 [!code-vb[System.Enum.Class#18](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.enum.class/vb/Extensions.vb#18)]  
  
   
  
## Examples  
 El ejemplo siguiente se muestra cómo utilizar una enumeración para representar valores con nombre y otra enumeración para representar los campos de bits con nombre.  
  
 [!code-cpp[enummain#1](~/samples/snippets/cpp/VS_Snippets_CLR/enummain/CPP/EnumMain.cpp#1)]
 [!code-csharp[enummain#1](~/samples/snippets/csharp/VS_Snippets_CLR/enummain/CS/EnumMain.cs#1)]
 [!code-vb[enummain#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/enummain/VB/EnumMain.vb#1)]  
  
 ]]></format>
    </remarks>
    <threadsafe>Este tipo es seguro para la ejecución de subprocesos.</threadsafe>
    <altmember cref="T:System.ValueType" />
    <altmember cref="T:System.FlagsAttribute" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Enum ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Enum.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; Enum();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Enum" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CompareTo">
      <MemberSignature Language="C#" Value="public int CompareTo (object target);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 CompareTo(object target) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Enum.CompareTo(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function CompareTo (target As Object) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int CompareTo(System::Object ^ target);" />
      <MemberSignature Language="F#" Value="abstract member CompareTo : obj -&gt; int&#xA;override this.CompareTo : obj -&gt; int" Usage="enum.CompareTo target" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IComparable.CompareTo(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="target">Objeto que se va a comparar o <see langword="null" />.</param>
        <summary>Compara esta instancia con un objeto especificado y devuelve una indicación de los valores relativos.</summary>
        <returns>Un número con signo que indica los valores relativos de la instancia en concreto y de <paramref name="target" />.  
  
 <list type="table"><listheader><term> Valor </term><description> Significado </description></listheader><item><term> Menor que cero </term><description> El valor de esta instancia es menor que el valor de <paramref name="target" />.  </description></item><item><term> Cero </term><description> El valor de esta instancia es igual al valor de <paramref name="target" />.  </description></item><item><term> Mayor que cero </term><description> El valor de esta instancia es mayor que el valor de <paramref name="target" />. -o bien- <paramref name="target" /> es <see langword="null" />. </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 El ejemplo siguiente muestra el uso de `CompareTo` en el contexto de `Enum`.  
  
 [!code-cpp[enumcompareto#1](~/samples/snippets/cpp/VS_Snippets_CLR/enumcompareto/CPP/EnumCompareTo.cpp#1)]
 [!code-csharp[enumcompareto#1](~/samples/snippets/csharp/VS_Snippets_CLR/enumcompareto/CS/EnumCompareTo.cs#1)]
 [!code-vb[enumcompareto#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/enumcompareto/VB/EnumCompareTo.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="target" /> y esta instancia no son del mismo tipo.</exception>
        <exception cref="T:System.InvalidOperationException">Esta instancia no es de tipo <see cref="T:System.SByte" />, <see cref="T:System.Int16" />, <see cref="T:System.Int32" />, <see cref="T:System.Int64" />, <see cref="T:System.Byte" />, <see cref="T:System.UInt16" />, <see cref="T:System.UInt32" /> o <see cref="T:System.UInt64" />.</exception>
        <altmember cref="M:System.Enum.Equals(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Enum.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (obj As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="override this.Equals : obj -&gt; bool" Usage="enum.Equals obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">Objeto que se va a comparar con esta instancia o <see langword="null" />.</param>
        <summary>Devuelve un valor que indica si esta instancia equivale a un objeto especificado.</summary>
        <returns>
          <see langword="true" /> si <paramref name="obj" /> es un valor de enumeración del mismo tipo y con el mismo valor subyacente que esta instancia; de lo contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Enum.Equals%28System.Object%29?displayProperty=nameWithType> reemplazos de método <xref:System.ValueType.Equals%28System.Object%29?displayProperty=nameWithType> para definir cómo se evalúan los miembros de la enumeración de igualdad.  
  
   
  
## Examples  
 En el ejemplo siguiente se muestra el uso del método <xref:System.Enum.Equals%2A>.  
  
 [!code-cpp[enumequals#1](~/samples/snippets/cpp/VS_Snippets_CLR/enumequals/CPP/EnumEquals.cpp#1)]
 [!code-csharp[enumequals#1](~/samples/snippets/csharp/VS_Snippets_CLR/enumequals/CS/EnumEquals.cs#1)]
 [!code-vb[enumequals#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/enumequals/VB/EnumEquals.vb#1)]  
  
 El siguiente ejemplo define dos tipos de enumeración, `SledDog` y `WorkDog`. El `SledDog` enumeración tiene dos miembros, `SledDog.AlaskanMalamute` y `SledDog.Malamute`, que tienen el mismo valor subyacente. La llamada a la <xref:System.Enum.Equals%2A> método indica que estos valores son iguales porque sus valores subyacentes son los mismos. El `SledDog.Malamute` y `WorkDog.Newfoundland` los miembros tienen el mismo valor subyacente, aunque representan los tipos de enumeración diferentes. Una llamada a la <xref:System.Enum.Equals%2A> método indica que estos valores no son iguales.  
  
 [!code-csharp[System.Enum.Equals#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.enum.equals/cs/enumequals.cs#1)]
 [!code-vb[System.Enum.Equals#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.enum.equals/vb/enumequals.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Enum.CompareTo(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Format">
      <MemberSignature Language="C#" Value="public static string Format (Type enumType, object value, string format);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Format(class System.Type enumType, object value, string format) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Enum.Format(System.Type,System.Object,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Format (enumType As Type, value As Object, format As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Format(Type ^ enumType, System::Object ^ value, System::String ^ format);" />
      <MemberSignature Language="F#" Value="static member Format : Type * obj * string -&gt; string" Usage="System.Enum.Format (enumType, value, format)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="enumType" Type="System.Type" />
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="format" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="enumType">Tipo de enumeración del valor que se va a convertir.</param>
        <param name="value">Valor que se va a convertir.</param>
        <param name="format">Formato de resultados que se va a usar.</param>
        <summary>Convierte el valor especificado de un tipo enumerado especificado en la representación de cadena equivalente de acuerdo con el formato especificado.</summary>
        <returns>Representación de cadena de <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La siguiente tabla muestra los valores válidos para el `format` parámetro.  
  
|Formato|Descripción|  
|------------|-----------------|  
|"G" o "g"|Si `value` es igual a una constante enumerada con nombre, el nombre de esta constante es devuelta; de lo contrario, el valor decimal equivalente `value` se devuelve.<br /><br /> Por ejemplo, supongamos que la única constante enumerada se denomina rojo y su valor es 1. Si `value` se especifica como 1, este formato devuelve "Red". Sin embargo, si `value` se especifica como 2, este formato devuelve "2".<br /><br /> O bien<br /><br /> Si el <xref:System.FlagsAttribute> atributo personalizado se aplica a la enumeración, `value` se trata como un campo de bits que contiene uno o más marcadores que se componen de uno o más bits.<br /><br /> Si `value` es igual a una combinación de nombre constantes enumeradas, se devuelve una lista separada por delimitador de los nombres de las constantes. `value` se buscan los indicadores, pasar de la marca con el valor máximo para el valor más pequeño. Para cada marca que corresponde a un campo de bits en `value`, el nombre de la constante se concatena a la lista separada por delimitador. El valor de esa marca, a continuación, se tendrán en cuenta aún más, y continúa la búsqueda de la siguiente marca.<br /><br /> Si `value` no es igual a una combinación de constantes enumeradas, el valor decimal equivalente con nombre `value` se devuelve.|  
|"X" o "x"|Representa `value` en formato hexadecimal sin un "0 x".|  
|"D" o "d"|Representa `value` en formato decimal.|  
|"F" o "f"|Se comporta igual que "G" o "g", salvo que el <xref:System.FlagsAttribute> no debe estar presente en el <xref:System.Enum> declaración.|  
  
   
  
## Examples  
 El ejemplo siguiente muestra el uso de `Format` en el contexto de `Enum`.  
  
 [!code-cpp[enumformat#1](~/samples/snippets/cpp/VS_Snippets_CLR/enumformat/CPP/EnumFormat.cpp#1)]
 [!code-csharp[enumformat#1](~/samples/snippets/csharp/VS_Snippets_CLR/enumformat/CS/EnumFormat.cs#1)]
 [!code-vb[enumformat#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/enumformat/VB/EnumFormat.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Los parámetros <paramref name="enumType" />, <paramref name="value" /> o <paramref name="format" /> son <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">El parámetro <paramref name="enumType" /> no es un tipo <see cref="T:System.Enum" />.  -o bien- <paramref name="value" /> procede de una enumeración que difiere en tipo de <paramref name="enumType" />.  -o bien- El tipo de <paramref name="value" /> no es un tipo subyacente de <paramref name="enumType" />.</exception>
        <exception cref="T:System.FormatException">El parámetro <paramref name="format" /> contiene un valor que no es válido.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="format" /> es igual a "X", pero el tipo de enumeración es desconocido.</exception>
        <altmember cref="M:System.Enum.ToString(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Enum.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="enum.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Devuelve el código hash del valor de esta instancia.</summary>
        <returns>Código hash de un entero de 32 bits con signo.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetName">
      <MemberSignature Language="C#" Value="public static string GetName (Type enumType, object value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetName(class System.Type enumType, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Enum.GetName(System.Type,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetName (enumType As Type, value As Object) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetName(Type ^ enumType, System::Object ^ value);" />
      <MemberSignature Language="F#" Value="static member GetName : Type * obj -&gt; string" Usage="System.Enum.GetName (enumType, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="enumType" Type="System.Type" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="enumType">Tipo de enumeración.</param>
        <param name="value">Valor de una constante enumerada concreta en términos de su tipo subyacente.</param>
        <summary>Recupera el nombre de la constante de la enumeración especificada que tiene el valor especificado.</summary>
        <returns>Una cadena que contiene el nombre de la constante enumerada en <paramref name="enumType" /> cuyo valor es <paramref name="value" />; o bien, <see langword="null" /> si no se encuentra tal constante.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si varios miembros de enumeración tienen el mismo valor subyacente, el <xref:System.Enum.GetName%2A> método garantiza que devolverá el nombre de uno de esos miembros de enumeración. Sin embargo, no garantiza que siempre devolverá el nombre del mismo miembro de enumeración. Como resultado, cuando varios miembros de enumeración tienen el mismo valor, el código de aplicación nunca debe dependen del método que devuelve el nombre de un miembro determinado.  
  
   
  
## Examples  
 El ejemplo siguiente muestra el uso de `GetName`.  
  
 [!code-cpp[enumgetname#1](~/samples/snippets/cpp/VS_Snippets_CLR/enumgetname/CPP/EnumGetName.cpp#1)]
 [!code-csharp[enumgetname#1](~/samples/snippets/csharp/VS_Snippets_CLR/enumgetname/CS/EnumGetName.cs#1)]
 [!code-vb[enumgetname#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/enumgetname/VB/EnumGetName.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El valor de <paramref name="enumType" /> o <paramref name="value" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="enumType" /> no es un objeto <see cref="T:System.Enum" />.  -o bien- <paramref name="value" /> no es ni del tipo <paramref name="enumType" /> ni tiene el mismo tipo subyacente que <paramref name="enumType" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetNames">
      <MemberSignature Language="C#" Value="public static string[] GetNames (Type enumType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string[] GetNames(class System.Type enumType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Enum.GetNames(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetNames (enumType As Type) As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::String ^&gt; ^ GetNames(Type ^ enumType);" />
      <MemberSignature Language="F#" Value="static member GetNames : Type -&gt; string[]" Usage="System.Enum.GetNames enumType" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="enumType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="enumType">Tipo de enumeración.</param>
        <summary>Recupera una matriz con los nombres de las constantes de una enumeración especificada.</summary>
        <returns>Matriz de cadenas con los nombres de las constantes de <paramref name="enumType" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Los elementos de la matriz de valores devueltos se ordenan por los valores binarios de las constantes enumeradas (es decir, su magnitud sin signo). En el ejemplo siguiente se proporciona muestra información acerca de la matriz devuelta por la <xref:System.Enum.GetNames%2A> método para una enumeración que incluye un valor negativo, cero y un valor positivo.  
  
 [!code-csharp[System.Enum.GetNames#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.enum.getnames/cs/getnames1.cs#1)]
 [!code-vb[System.Enum.GetNames#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.enum.getnames/vb/getnames1.vb#1)]  
  
 Si no hay constantes enumeradas con el mismo valor, se especifica el orden de los nombres correspondientes.  
  
   
  
## Examples  
 En el ejemplo siguiente se muestra el uso del método <xref:System.Enum.GetNames%2A>.  
  
 [!code-cpp[enumgetnames#1](~/samples/snippets/cpp/VS_Snippets_CLR/enumgetnames/CPP/EnumGetNames.cpp#1)]
 [!code-csharp[enumgetnames#1](~/samples/snippets/csharp/VS_Snippets_CLR/enumgetnames/CS/EnumGetNames.cs#1)]
 [!code-vb[enumgetnames#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/enumgetnames/VB/EnumGetNames.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="enumType" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">El parámetro <paramref name="enumType" /> no es un objeto <see cref="T:System.Enum" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetTypeCode">
      <MemberSignature Language="C#" Value="public TypeCode GetTypeCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.TypeCode GetTypeCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Enum.GetTypeCode" />
      <MemberSignature Language="VB.NET" Value="Public Function GetTypeCode () As TypeCode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual TypeCode GetTypeCode();" />
      <MemberSignature Language="F#" Value="abstract member GetTypeCode : unit -&gt; TypeCode&#xA;override this.GetTypeCode : unit -&gt; TypeCode" Usage="enum.GetTypeCode " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.GetTypeCode</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.TypeCode</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Devuelve el código de tipo del tipo subyacente de este miembro de enumeración.</summary>
        <returns>El código de tipo del tipo subyacente de esta instancia.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException">Se desconoce el tipo de enumeración.</exception>
        <altmember cref="M:System.Enum.GetUnderlyingType(System.Type)" />
      </Docs>
    </Member>
    <Member MemberName="GetUnderlyingType">
      <MemberSignature Language="C#" Value="public static Type GetUnderlyingType (Type enumType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetUnderlyingType(class System.Type enumType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Enum.GetUnderlyingType(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetUnderlyingType (enumType As Type) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetUnderlyingType(Type ^ enumType);" />
      <MemberSignature Language="F#" Value="static member GetUnderlyingType : Type -&gt; Type" Usage="System.Enum.GetUnderlyingType enumType" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="enumType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="enumType">Enumeración cuyo tipo subyacente se recuperará.</param>
        <summary>Devuelve el tipo subyacente de la enumeración especificada.</summary>
        <returns>Tipo subyacente de <paramref name="enumType" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Enum> estructura permite que los valores para representarse como constantes con nombre. El tipo de datos de valores de enumeración se conoce como su tipo subyacente. Por ejemplo, el tipo subyacente de la <xref:System.DayOfWeek> enumeración, que consta de las constantes que representan cada día de la semana (<xref:System.DayOfWeek.Monday?displayProperty=nameWithType>, <xref:System.DayOfWeek.Tuesday?displayProperty=nameWithType>, y así sucesivamente), es <xref:System.Int32>.  
  
   
  
## Examples  
 El ejemplo siguiente se llama el <xref:System.Enum.GetUnderlyingType%2A> método para mostrar el tipo subyacente de algunos miembros de enumeración.  
  
 [!code-csharp[System.Enum.GetUnderlyingType#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.enum.getunderlyingtype/cs/getunderlyingtype1.cs#1)]
 [!code-vb[System.Enum.GetUnderlyingType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.enum.getunderlyingtype/vb/getunderlyingtype1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="enumType" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="enumType" /> no es un objeto <see cref="T:System.Enum" />.</exception>
        <altmember cref="M:System.Enum.GetTypeCode" />
      </Docs>
    </Member>
    <Member MemberName="GetValues">
      <MemberSignature Language="C#" Value="public static Array GetValues (Type enumType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Array GetValues(class System.Type enumType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Enum.GetValues(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetValues (enumType As Type) As Array" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Array ^ GetValues(Type ^ enumType);" />
      <MemberSignature Language="F#" Value="static member GetValues : Type -&gt; Array" Usage="System.Enum.GetValues enumType" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Array</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="enumType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="enumType">Tipo de enumeración.</param>
        <summary>Recupera una matriz con los valores de las constantes de una enumeración especificada.</summary>
        <returns>Matriz que contiene los valores de las constantes de <paramref name="enumType" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Los elementos de la matriz se ordenan por los valores binarios de las constantes de enumeración (es decir, su magnitud sin signo). En el ejemplo siguiente se muestra información acerca de la matriz devuelta por la <xref:System.Enum.GetValues%2A> método para una enumeración que incluye un valor negativo, cero y un valor positivo.  
  
 [!code-csharp[System.Enum.GetValues#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.enum.getvalues/cs/getvalues1.cs#1)]
 [!code-vb[System.Enum.GetValues#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.enum.getvalues/vb/getvalues1.vb#1)]  
  
 El <xref:System.Enum.GetValues%2A> método devuelve una matriz que contiene un valor para cada miembro de la `enumType` enumeración. Si varios miembros tienen el mismo valor, la matriz devuelta incluye valores duplicados. En este caso, una llamada a la <xref:System.Enum.GetName%2A> método con cada valor de la matriz devuelta no restaura los nombres únicos asignados a los miembros que tienen valores duplicados. Para recuperar todos los nombres de miembros de enumeración correctamente, llame el <xref:System.Enum.GetNames%2A> método.  
  
 El <xref:System.Enum.GetValues%2A> no se puede invocar el método mediante el uso de reflexión en un contexto de solo reflexión. En su lugar, puede recuperar el valor de todos los miembros de enumeración mediante el <xref:System.Type.GetFields%2A?displayProperty=nameWithType> método para obtener una matriz de <xref:System.Reflection.FieldInfo> objetos que representan los miembros de enumeración y, a continuación, llame a la <xref:System.Reflection.FieldInfo.GetRawConstantValue%2A?displayProperty=nameWithType> método en cada elemento de la matriz. El ejemplo siguiente ilustra esta técnica. Requiere que se defina la siguiente enumeración en un ensamblado denominado Enumerations.dll:  
  
 [!code-csharp[System.Enum.GetValues#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.enum.getvalues/cs/getvalues_reflectiononly.cs#2)]
 [!code-vb[System.Enum.GetValues#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.enum.getvalues/vb/getvalues_reflectiononly.vb#2)]  
  
 El ensamblado se carga en un contexto de solo reflexión, un <xref:System.Type> objeto que representa el `Pets` se crea una instancia de enumeración, una matriz de <xref:System.Reflection.FieldInfo> se recuperan los objetos y los valores de campo se muestran en la consola.  
  
 [!code-csharp[System.Enum.GetValues#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.enum.getvalues/cs/getvalues_reflectiononly.cs#3)]
 [!code-vb[System.Enum.GetValues#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.enum.getvalues/vb/getvalues_reflectiononly.vb#3)]  
  
   
  
## Examples  
 El ejemplo siguiente muestra el uso de <xref:System.Enum.GetValues%2A>.  
  
 [!code-cpp[enumgetvalues#1](~/samples/snippets/cpp/VS_Snippets_CLR/enumgetvalues/CPP/EnumGetValues.cpp#1)]
 [!code-csharp[enumgetvalues#1](~/samples/snippets/csharp/VS_Snippets_CLR/enumgetvalues/CS/EnumGetValues.cs#1)]
 [!code-vb[enumgetvalues#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/enumgetvalues/VB/EnumGetValues.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="enumType" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="enumType" /> no es un objeto <see cref="T:System.Enum" />.</exception>
        <exception cref="T:System.InvalidOperationException">El método se invoca por la reflexión en un contexto de solo reflexión, -o bien- <paramref name="enumType" /> es un tipo de un ensamblado cargado en un contexto de solo reflexión.</exception>
      </Docs>
    </Member>
    <Member MemberName="HasFlag">
      <MemberSignature Language="C#" Value="public bool HasFlag (Enum flag);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool HasFlag(class System.Enum flag) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Enum.HasFlag(System.Enum)" />
      <MemberSignature Language="VB.NET" Value="Public Function HasFlag (flag As Enum) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool HasFlag(Enum ^ flag);" />
      <MemberSignature Language="F#" Value="member this.HasFlag : Enum -&gt; bool" Usage="enum.HasFlag flag" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="flag" Type="System.Enum" />
      </Parameters>
      <Docs>
        <param name="flag">Valor de enumeración.</param>
        <summary>Determina si hay uno o varios campos de bits establecidos en la instancia actual.</summary>
        <returns>
          <see langword="true" /> si los campos de bits establecidos en <paramref name="flag" /> también están establecidos en la instancia actual; en caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Enum.HasFlag%2A> método devuelve el resultado de la siguiente expresión booleana.  
  
```  
thisInstance And flag = flag   
```  
  
 Si el valor subyacente de `flag` es cero, el método devuelve `true`. Si este comportamiento no es deseable, puede usar el <xref:System.Enum.Equals%2A> método para comprobar la igualdad con cero y llamada <xref:System.Enum.HasFlag%2A> solo si el valor subyacente de `flag` es distinto de cero, como se muestra en el ejemplo siguiente.  
  
 [!code-csharp[System.Enum.HasFlag#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.enum.hasflag/cs/hasflag0.cs#1)]
 [!code-vb[System.Enum.HasFlag#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.enum.hasflag/vb/hasflag0.vb#1)]  
  
 El <xref:System.Enum.HasFlag%2A> método está diseñado para usarse con tipos de enumeración que se marcan con el <xref:System.FlagsAttribute> de atributo y puede usarse para determinar si se establecen varios campos de bits. Para los tipos de enumeración que no están marcados con el <xref:System.FlagsAttribute> atributo, llame a la <xref:System.Enum.Equals%2A> método o la <xref:System.Enum.CompareTo%2A> método.  
  
   
  
## Examples  
 En el ejemplo siguiente se define un `ItemsOrdered` enumeración que refleja las categorías de elementos que un cliente puede ordenar en un restaurante. En el ejemplo se comprueba si el cliente ha solicitado una entrante y una bebida.  
  
 [!code-csharp[System.Enum.HasFlag#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.enum.hasflag/cs/hasflag1.cs#2)]
 [!code-vb[System.Enum.HasFlag#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.enum.hasflag/vb/hasflag1.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="flag" /> es un tipo diferente de la instancia actual.</exception>
        <altmember cref="T:System.FlagsAttribute" />
        <altmember cref="M:System.Enum.Equals(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="IsDefined">
      <MemberSignature Language="C#" Value="public static bool IsDefined (Type enumType, object value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsDefined(class System.Type enumType, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Enum.IsDefined(System.Type,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsDefined (enumType As Type, value As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsDefined(Type ^ enumType, System::Object ^ value);" />
      <MemberSignature Language="F#" Value="static member IsDefined : Type * obj -&gt; bool" Usage="System.Enum.IsDefined (enumType, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="enumType" Type="System.Type" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="enumType">Tipo de enumeración.</param>
        <param name="value">Valor o nombre de una constante de <c>enumType</c>.</param>
        <summary>Devuelve un booleano que indica si un valor integral especificado, o bien su nombre en forma de cadena, existe en una enumeración especifica.</summary>
        <returns>
          <see langword="true" /> si una constante de <paramref name="enumType" /> tiene un valor igual a <paramref name="value" />; en caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El `value` parámetro puede ser cualquiera de las siguientes acciones:  
  
-   Cualquier miembro del tipo `enumType`.  
  
-   Una variable cuyo valor es un miembro de enumeración de tipo `enumType`.  
  
-   La representación de cadena del nombre de un miembro de enumeración. Los caracteres de la cadena deben tener el mismo caso de que el nombre de miembro de enumeración.  
  
-   Un valor del tipo subyacente de `enumType`.  
  
 Si las constantes de `enumType` definir un conjunto de campos de bits y `value` contiene los valores, los nombres o los valores subyacentes de varios campos de bits, el <xref:System.Enum.IsDefined%2A> devuelve del método `false`. En otras palabras, para las enumeraciones que definen un conjunto de campos de bits, el método sólo determina si un campo de bits pertenece a la enumeración. Para determinar si se establecen varios campos de bits en un tipo de enumeración que esté etiquetado con el <xref:System.FlagsAttribute> atributo, puede llamar a la <xref:System.Enum.HasFlag%2A> método.  
  
   
  
## Examples  
 En el ejemplo siguiente se define una enumeración denominada `PetType` que consta de campos de bits individuales. A continuación, llama el <xref:System.Enum.IsDefined%2A> método subyacente compuestos valores resultantes de la configuración de varios campos de bits, los nombres de cadena y valores de enumeración de posibles.  
  
 [!code-csharp[System.Enum.IsDefined#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Enum.IsDefined/cs/isdefined1.cs#1)]
 [!code-vb[System.Enum.IsDefined#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Enum.IsDefined/vb/IsDefined1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El valor de <paramref name="enumType" /> o <paramref name="value" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="enumType" /> no es un objeto <see langword="Enum" />.  -o bien- El tipo de <paramref name="value" /> es una enumeración, pero no es una enumeración de tipo <paramref name="enumType" />.  -o bien- El tipo de <paramref name="value" /> no es un tipo subyacente de <paramref name="enumType" />.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="value" /> no es del tipo <see cref="T:System.SByte" />, <see cref="T:System.Int16" />, <see cref="T:System.Int32" />, <see cref="T:System.Int64" />, <see cref="T:System.Byte" />, <see cref="T:System.UInt16" />, <see cref="T:System.UInt32" />, <see cref="T:System.UInt64" /> o <see cref="T:System.String" />.</exception>
        <block subset="none" type="usage">
          <para>Si <paramref name="enumType" /> es una enumeración que se define utilizando el <see cref="T:System.FlagsAttribute" /> de atributo, el método devuelve <see langword="false" /> si varios bits campos en <paramref name="value" /> se establecen pero <paramref name="value" /> no corresponde a un valor de enumeración compuesto, o si <paramref name="value" /> es una concatenación de cadenas de los nombres de varias marcas de bits. En el ejemplo siguiente, un <c>mascotas</c> enumeración se define con el <see cref="T:System.FlagsAttribute" /> atributo. El <see cref="M:System.Enum.IsDefined(System.Type,System.Object)" /> devuelve del método <see langword="false" /> cuando se pasa un valor de enumeración que tiene campos de dos bits (<c>Pets.Dog</c> y <c>Pets.Cat</c>) establecido, y cuando se pasa la representación de cadena de la que valor de enumeración ("perro, gato").  [! código csharp[System.Enum.IsDefined#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Enum.IsDefined/cs/isdefined2.cs#2)] [! código vb[System.Enum.IsDefined#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Enum.IsDefined/vb/isdefined2.vb#2)] puede determinar si varios campos de bits se establecen mediante una llamada a la <see cref="M:System.Enum.HasFlag(System.Enum)" /> método.</para>
        </block>
        <altmember cref="M:System.Enum.GetName(System.Type,System.Object)" />
        <altmember cref="M:System.Enum.GetNames(System.Type)" />
        <altmember cref="M:System.Enum.GetValues(System.Type)" />
        <altmember cref="M:System.Enum.HasFlag(System.Enum)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Parse">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Convierte la representación de cadena del nombre o valor numérico de una o varias constantes enumeradas en un objeto enumerado equivalente.</summary>
        <altmember cref="M:System.Enum.TryParse``1(System.String,``0@)" />
      </Docs>
    </MemberGroup>
    <Member MemberName="Parse">
      <MemberSignature Language="C#" Value="public static object Parse (Type enumType, string value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object Parse(class System.Type enumType, string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Enum.Parse(System.Type,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Parse (enumType As Type, value As String) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ Parse(Type ^ enumType, System::String ^ value);" />
      <MemberSignature Language="F#" Value="static member Parse : Type * string -&gt; obj" Usage="System.Enum.Parse (enumType, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="enumType" Type="System.Type" />
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="enumType">Tipo de enumeración.</param>
        <param name="value">Cadena que contiene el nombre o valor que se va a convertir.</param>
        <summary>Convierte la representación de cadena del nombre o valor numérico de una o varias constantes enumeradas en un objeto enumerado equivalente.</summary>
        <returns>Objeto de tipo <paramref name="enumType" /> cuyo valor está representado por <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El `value` parámetro contiene la representación de cadena del valor subyacente o la constante con nombre de un miembro de enumeración o una lista de denominado constantes delimitadas por comas (,). Uno o más espacios en blanco pueden ir precedidas o seguidas de cada valor, el nombre o por comas en `value`. Si `value` es una lista, el valor devuelto es el valor de los nombres especificados combinados con un bit a bit `OR` operación.  
  
 Si `value` es un nombre que no corresponde a una constante con nombre de `enumType`, el método produce una <xref:System.ArgumentException>. Si `value` es la representación de cadena de un entero que no representa un valor subyacente de la `enumType` enumeración, el método devuelve un miembro de enumeración cuyo valor subyacente es `value` convertir a un tipo entero. Si no desea este comportamiento, llame a la <xref:System.Enum.IsDefined%2A> método para asegurarse de que una representación de cadena concreta de un entero es realmente un miembro de `enumType`. En el ejemplo siguiente se define un `Colors` enumeración, llama el <xref:System.Enum.Parse%28System.Type%2CSystem.String%29> método para convertir cadenas en sus correspondientes valores de enumeración y llama a la <xref:System.Enum.IsDefined%2A> valores del método para asegurarse de que determinados valores integrales son subyacentes en el `Colors` enumeración.  
  
 [!code-csharp[System.Enum.Parse#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Enum.Parse/cs/ParseExample1.cs#1)]
 [!code-vb[System.Enum.Parse#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Enum.Parse/vb/ParseExample1.vb#1)]  
  
 Esta operación distingue mayúsculas de minúsculas.  
  
   
  
## Examples  
 En el ejemplo siguiente se usa el <xref:System.Enum.Parse%28System.Type%2CSystem.String%29> método para analizar una matriz de cadenas que se crean mediante una llamada a la <xref:System.Enum.GetNames%2A> método. También usa el <xref:System.Enum.Parse%28System.Type%2CSystem.String%29> método para analizar un valor de enumeración que consta de un campo de bits.  
  
 [!code-cpp[enumparse#1](~/samples/snippets/cpp/VS_Snippets_CLR/enumparse/CPP/EnumParse.cpp#1)]
 [!code-csharp[enumparse#1](~/samples/snippets/csharp/VS_Snippets_CLR/enumparse/CS/EnumParse.cs#1)]
 [!code-vb[enumparse#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/enumparse/VB/EnumParse.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El valor de <paramref name="enumType" /> o <paramref name="value" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="enumType" /> no es un objeto <see cref="T:System.Enum" />.  -o bien- <paramref name="value" /> es una cadena vacía o solo contiene espacios en blanco.  -o bien- <paramref name="value" /> es un nombre, pero no una de las constantes con nombre definidas para la enumeración.</exception>
        <exception cref="T:System.OverflowException">
          <paramref name="value" /> está fuera del intervalo del tipo subyacente de <paramref name="enumType" />.</exception>
        <altmember cref="M:System.Enum.IsDefined(System.Type,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Parse">
      <MemberSignature Language="C#" Value="public static object Parse (Type enumType, string value, bool ignoreCase);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object Parse(class System.Type enumType, string value, bool ignoreCase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Enum.Parse(System.Type,System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Parse (enumType As Type, value As String, ignoreCase As Boolean) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ Parse(Type ^ enumType, System::String ^ value, bool ignoreCase);" />
      <MemberSignature Language="F#" Value="static member Parse : Type * string * bool -&gt; obj" Usage="System.Enum.Parse (enumType, value, ignoreCase)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="enumType" Type="System.Type" />
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="enumType">Tipo de enumeración.</param>
        <param name="value">Cadena que contiene el nombre o valor que se va a convertir.</param>
        <param name="ignoreCase">
          <see langword="true" /> para no distinguir entre mayúsculas y minúsculas; <see langword="false" /> para tener en cuenta la distinción entre mayúsculas y minúsculas.</param>
        <summary>Convierte la representación de cadena del nombre o valor numérico de una o varias constantes enumeradas en un objeto enumerado equivalente. Un parámetro especifica si la operación no distingue mayúsculas de minúsculas.</summary>
        <returns>Objeto de tipo <paramref name="enumType" /> cuyo valor está representado por <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El `value` parámetro contiene la representación de cadena del valor subyacente o la constante con nombre de un miembro de enumeración o una lista de denominado constantes delimitadas por comas (,). Uno o más espacios en blanco pueden ir precedidas o seguidas de cada valor, el nombre o por comas en `value`. Si `value` es una lista, el valor devuelto es el valor de los nombres especificados combinados con un bit a bit `OR` operación.  
  
 Si `value` es un nombre que no corresponde a una constante con nombre de `enumType`, el método produce una <xref:System.ArgumentException>. Si `value` es la representación de cadena de un entero que no representa un valor subyacente de la `enumType` enumeración, el método devuelve un miembro de enumeración cuyo valor subyacente es `value` convertir a un tipo entero. Si no desea este comportamiento, llame a la <xref:System.Enum.IsDefined%2A> método para asegurarse de que una representación de cadena concreta de un entero es realmente un miembro de `enumType`. En el ejemplo siguiente se define un `Colors` enumeración, llama el <xref:System.Enum.Parse%28System.Type%2CSystem.String%2CSystem.Boolean%29> método para convertir cadenas en sus correspondientes valores de enumeración y llama a la <xref:System.Enum.IsDefined%2A> valores del método para asegurarse de que determinados valores integrales son subyacentes en el `Colors` enumeración.  
  
 [!code-csharp[System.Enum.Parse#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Enum.Parse/cs/ParseExample2.cs#2)]
 [!code-vb[System.Enum.Parse#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Enum.Parse/vb/ParseExample2.vb#2)]  
  
 El `ignoreCase` parámetro especifica si esta operación distingue mayúsculas de minúsculas.  
  
   
  
## Examples  
 En el ejemplo siguiente se usa el <xref:System.Enum.Parse%28System.Type%2CSystem.String%2CSystem.Boolean%29> método para analizar una matriz de cadenas que se crean mediante una llamada a la <xref:System.Enum.GetNames%2A> método. También usa el <xref:System.Enum.Parse%28System.Type%2CSystem.String%29> método para analizar un valor de enumeración que consta de un campo de bits.  
  
 [!code-csharp[System.Enum.Parse#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Enum.Parse/cs/ParseExample2.cs#2)]
 [!code-vb[System.Enum.Parse#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Enum.Parse/vb/ParseExample2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El valor de <paramref name="enumType" /> o <paramref name="value" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="enumType" /> no es un objeto <see cref="T:System.Enum" />.  -o bien- <paramref name="value" /> es una cadena vacía ("") o solo contiene espacios en blanco.  -o bien- <paramref name="value" /> es un nombre, pero no una de las constantes con nombre definidas para la enumeración.</exception>
        <exception cref="T:System.OverflowException">
          <paramref name="value" /> está fuera del intervalo del tipo subyacente de <paramref name="enumType" />.</exception>
        <altmember cref="M:System.Enum.IsDefined(System.Type,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Parse&lt;TEnum&gt;">
      <MemberSignature Language="C#" Value="public static TEnum Parse&lt;TEnum&gt; (string value) where TEnum : struct;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TEnum Parse&lt;struct .ctor (class System.ValueType) TEnum&gt;(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Enum.Parse``1(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Parse(Of TEnum As Structure) (value As String) As TEnum" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TEnum&gt;&#xA; where TEnum : value class static TEnum Parse(System::String ^ value);" />
      <MemberSignature Language="F#" Value="static member Parse : string -&gt; 'Enum (requires 'Enum : struct)" Usage="System.Enum.Parse value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TEnum</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TEnum">
          <Constraints>
            <ParameterAttribute>DefaultConstructorConstraint</ParameterAttribute>
            <ParameterAttribute>NotNullableValueTypeConstraint</ParameterAttribute>
            <BaseTypeName>System.ValueType</BaseTypeName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <typeparam name="TEnum">To be added.</typeparam>
        <param name="value">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Parse&lt;TEnum&gt;">
      <MemberSignature Language="C#" Value="public static TEnum Parse&lt;TEnum&gt; (string value, bool ignoreCase) where TEnum : struct;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TEnum Parse&lt;struct .ctor (class System.ValueType) TEnum&gt;(string value, bool ignoreCase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Enum.Parse``1(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Parse(Of TEnum As Structure) (value As String, ignoreCase As Boolean) As TEnum" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TEnum&gt;&#xA; where TEnum : value class static TEnum Parse(System::String ^ value, bool ignoreCase);" />
      <MemberSignature Language="F#" Value="static member Parse : string * bool -&gt; 'Enum (requires 'Enum : struct)" Usage="System.Enum.Parse (value, ignoreCase)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TEnum</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TEnum">
          <Constraints>
            <ParameterAttribute>DefaultConstructorConstraint</ParameterAttribute>
            <ParameterAttribute>NotNullableValueTypeConstraint</ParameterAttribute>
            <BaseTypeName>System.ValueType</BaseTypeName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <typeparam name="TEnum">To be added.</typeparam>
        <param name="value">To be added.</param>
        <param name="ignoreCase">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.GetTypeCode">
      <MemberSignature Language="C#" Value="TypeCode IConvertible.GetTypeCode ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance valuetype System.TypeCode System.IConvertible.GetTypeCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Enum.System#IConvertible#GetTypeCode" />
      <MemberSignature Language="VB.NET" Value="Function GetTypeCode () As TypeCode Implements IConvertible.GetTypeCode" />
      <MemberSignature Language="C++ CLI" Value=" virtual TypeCode System.IConvertible.GetTypeCode() = IConvertible::GetTypeCode;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.GetTypeCode</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.TypeCode</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToBoolean">
      <MemberSignature Language="C#" Value="bool IConvertible.ToBoolean (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool System.IConvertible.ToBoolean(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Enum.System#IConvertible#ToBoolean(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToBoolean (provider As IFormatProvider) As Boolean Implements IConvertible.ToBoolean" />
      <MemberSignature Language="C++ CLI" Value=" virtual bool System.IConvertible.ToBoolean(IFormatProvider ^ provider) = IConvertible::ToBoolean;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToBoolean(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Objeto que proporciona información de formato específica de la referencia cultural.</param>
        <summary>Convierte el valor actual en un valor booleano basado en el tipo subyacente.</summary>
        <returns>Este miembro siempre produce una excepción.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 No implementado actualmente. Siempre produce una excepción.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidCastException">En todos los casos.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToByte">
      <MemberSignature Language="C#" Value="byte IConvertible.ToByte (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance unsigned int8 System.IConvertible.ToByte(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Enum.System#IConvertible#ToByte(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToByte (provider As IFormatProvider) As Byte Implements IConvertible.ToByte" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Byte System.IConvertible.ToByte(IFormatProvider ^ provider) = IConvertible::ToByte;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToByte(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Objeto que proporciona información de formato específica de la referencia cultural.</param>
        <summary>Convierte el valor actual en un entero de 8 bits sin signo basado en el tipo subyacente.</summary>
        <returns>El valor convertido.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Usa <xref:System.Convert> para realizar la conversión.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToChar">
      <MemberSignature Language="C#" Value="char IConvertible.ToChar (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance char System.IConvertible.ToChar(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Enum.System#IConvertible#ToChar(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToChar (provider As IFormatProvider) As Char Implements IConvertible.ToChar" />
      <MemberSignature Language="C++ CLI" Value=" virtual char System.IConvertible.ToChar(IFormatProvider ^ provider) = IConvertible::ToChar;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToChar(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Objeto que proporciona información de formato específica de la referencia cultural.</param>
        <summary>Convierte el valor actual en un carácter Unicode basado en el tipo subyacente.</summary>
        <returns>Este miembro siempre produce una excepción.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 No implementado actualmente. Siempre produce una excepción.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidCastException">En todos los casos.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToDateTime">
      <MemberSignature Language="C#" Value="DateTime IConvertible.ToDateTime (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance valuetype System.DateTime System.IConvertible.ToDateTime(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Enum.System#IConvertible#ToDateTime(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToDateTime (provider As IFormatProvider) As DateTime Implements IConvertible.ToDateTime" />
      <MemberSignature Language="C++ CLI" Value=" virtual DateTime System.IConvertible.ToDateTime(IFormatProvider ^ provider) = IConvertible::ToDateTime;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToDateTime(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Objeto que proporciona información de formato específica de la referencia cultural.</param>
        <summary>Convierte el valor actual en <see cref="T:System.DateTime" /> basado en el tipo subyacente.</summary>
        <returns>Este miembro siempre produce una excepción.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 No implementado actualmente. Siempre produce una excepción.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidCastException">En todos los casos.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToDecimal">
      <MemberSignature Language="C#" Value="decimal IConvertible.ToDecimal (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance valuetype System.Decimal System.IConvertible.ToDecimal(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Enum.System#IConvertible#ToDecimal(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToDecimal (provider As IFormatProvider) As Decimal Implements IConvertible.ToDecimal" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Decimal System.IConvertible.ToDecimal(IFormatProvider ^ provider) = IConvertible::ToDecimal;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToDecimal(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Objeto que proporciona información de formato específica de la referencia cultural.</param>
        <summary>Convierte el valor actual en <see cref="T:System.Decimal" /> basado en el tipo subyacente.</summary>
        <returns>Este miembro siempre produce una excepción.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 No implementado actualmente. Siempre produce una excepción.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidCastException">En todos los casos.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToDouble">
      <MemberSignature Language="C#" Value="double IConvertible.ToDouble (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance float64 System.IConvertible.ToDouble(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Enum.System#IConvertible#ToDouble(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToDouble (provider As IFormatProvider) As Double Implements IConvertible.ToDouble" />
      <MemberSignature Language="C++ CLI" Value=" virtual double System.IConvertible.ToDouble(IFormatProvider ^ provider) = IConvertible::ToDouble;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToDouble(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Objeto que proporciona información de formato específica de la referencia cultural.</param>
        <summary>Convierte el valor actual en número de punto flotante de precisión doble basado en el tipo subyacente.</summary>
        <returns>Este miembro siempre produce una excepción.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 No implementado actualmente. Siempre produce una excepción.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidCastException">En todos los casos.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToInt16">
      <MemberSignature Language="C#" Value="short IConvertible.ToInt16 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int16 System.IConvertible.ToInt16(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Enum.System#IConvertible#ToInt16(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToInt16 (provider As IFormatProvider) As Short Implements IConvertible.ToInt16" />
      <MemberSignature Language="C++ CLI" Value=" virtual short System.IConvertible.ToInt16(IFormatProvider ^ provider) = IConvertible::ToInt16;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToInt16(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Objeto que proporciona información de formato específica de la referencia cultural.</param>
        <summary>Convierte el valor actual en un entero de 16 bits con signo basado en el tipo subyacente.</summary>
        <returns>El valor convertido.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Usa <xref:System.Convert> para realizar la conversión.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToInt32">
      <MemberSignature Language="C#" Value="int IConvertible.ToInt32 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int32 System.IConvertible.ToInt32(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Enum.System#IConvertible#ToInt32(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToInt32 (provider As IFormatProvider) As Integer Implements IConvertible.ToInt32" />
      <MemberSignature Language="C++ CLI" Value=" virtual int System.IConvertible.ToInt32(IFormatProvider ^ provider) = IConvertible::ToInt32;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToInt32(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Objeto que proporciona información de formato específica de la referencia cultural.</param>
        <summary>Convierte el valor actual en un entero de 32 bits con signo basado en el tipo subyacente.</summary>
        <returns>El valor convertido.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Usa <xref:System.Convert> para realizar la conversión.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToInt64">
      <MemberSignature Language="C#" Value="long IConvertible.ToInt64 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int64 System.IConvertible.ToInt64(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Enum.System#IConvertible#ToInt64(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToInt64 (provider As IFormatProvider) As Long Implements IConvertible.ToInt64" />
      <MemberSignature Language="C++ CLI" Value=" virtual long System.IConvertible.ToInt64(IFormatProvider ^ provider) = IConvertible::ToInt64;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToInt64(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Objeto que proporciona información de formato específica de la referencia cultural.</param>
        <summary>Convierte el valor actual en un entero de 64 bits con signo basado en el tipo subyacente.</summary>
        <returns>El valor convertido.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Usa <xref:System.Convert> para realizar la conversión.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToSByte">
      <MemberSignature Language="C#" Value="sbyte IConvertible.ToSByte (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int8 System.IConvertible.ToSByte(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Enum.System#IConvertible#ToSByte(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToSByte (provider As IFormatProvider) As SByte Implements IConvertible.ToSByte" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::SByte System.IConvertible.ToSByte(IFormatProvider ^ provider) = IConvertible::ToSByte;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToSByte(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.SByte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Objeto que proporciona información de formato específica de la referencia cultural.</param>
        <summary>Convierte el valor actual en un entero de 8 bits con signo basado en el tipo subyacente.</summary>
        <returns>El valor convertido.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Usa <xref:System.Convert> para realizar la conversión.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToSingle">
      <MemberSignature Language="C#" Value="float IConvertible.ToSingle (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance float32 System.IConvertible.ToSingle(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Enum.System#IConvertible#ToSingle(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToSingle (provider As IFormatProvider) As Single Implements IConvertible.ToSingle" />
      <MemberSignature Language="C++ CLI" Value=" virtual float System.IConvertible.ToSingle(IFormatProvider ^ provider) = IConvertible::ToSingle;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToSingle(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Objeto que proporciona información de formato específica de la referencia cultural.</param>
        <summary>Convierte el valor actual en un número de punto flotante de precisión sencilla basándose en el tipo subyacente.</summary>
        <returns>Este miembro siempre produce una excepción.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 No implementado actualmente. Siempre produce una excepción.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidCastException">En todos los casos.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToString">
      <MemberSignature Language="C#" Value="string IConvertible.ToString (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance string System.IConvertible.ToString(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Enum.System#IConvertible#ToString(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToString (provider As IFormatProvider) As String Implements IConvertible.ToString" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::String ^ System.IConvertible.ToString(IFormatProvider ^ provider) = IConvertible::ToString;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToString(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6">
          <AttributeName>System.Obsolete("The provider argument is not used. Please use ToString().")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToType">
      <MemberSignature Language="C#" Value="object IConvertible.ToType (Type type, IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance object System.IConvertible.ToType(class System.Type type, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Enum.System#IConvertible#ToType(System.Type,System.IFormatProvider)" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Object ^ System.IConvertible.ToType(Type ^ type, IFormatProvider ^ provider) = IConvertible::ToType;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToType(System.Type,System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="type">Tipo al que se va a convertir.</param>
        <param name="provider">Objeto que proporciona información de formato específica de la referencia cultural.</param>
        <summary>Convierte el valor actual en un tipo especificado basado en el tipo subyacente.</summary>
        <returns>El valor convertido.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Usa <xref:System.Convert> para realizar la conversión.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToUInt16">
      <MemberSignature Language="C#" Value="ushort IConvertible.ToUInt16 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance unsigned int16 System.IConvertible.ToUInt16(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Enum.System#IConvertible#ToUInt16(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToUInt16 (provider As IFormatProvider) As UShort Implements IConvertible.ToUInt16" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::UInt16 System.IConvertible.ToUInt16(IFormatProvider ^ provider) = IConvertible::ToUInt16;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToUInt16(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Objeto que proporciona información de formato específica de la referencia cultural.</param>
        <summary>Convierte el valor actual en un entero de 16 bits sin signo basado en el tipo subyacente.</summary>
        <returns>El valor convertido.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Usa <xref:System.Convert> para realizar la conversión.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToUInt32">
      <MemberSignature Language="C#" Value="uint IConvertible.ToUInt32 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance unsigned int32 System.IConvertible.ToUInt32(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Enum.System#IConvertible#ToUInt32(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToUInt32 (provider As IFormatProvider) As UInteger Implements IConvertible.ToUInt32" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::UInt32 System.IConvertible.ToUInt32(IFormatProvider ^ provider) = IConvertible::ToUInt32;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToUInt32(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Objeto que proporciona información de formato específica de la referencia cultural.</param>
        <summary>Convierte el valor actual en un entero de 32 bits sin signo basado en el tipo subyacente.</summary>
        <returns>El valor convertido.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Usa <xref:System.Convert> para realizar la conversión.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToUInt64">
      <MemberSignature Language="C#" Value="ulong IConvertible.ToUInt64 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance unsigned int64 System.IConvertible.ToUInt64(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Enum.System#IConvertible#ToUInt64(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToUInt64 (provider As IFormatProvider) As ULong Implements IConvertible.ToUInt64" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::UInt64 System.IConvertible.ToUInt64(IFormatProvider ^ provider) = IConvertible::ToUInt64;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToUInt64(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Objeto que proporciona información de formato específica de la referencia cultural.</param>
        <summary>Convierte el valor actual en un entero de 64 bits sin signo basado en el tipo subyacente.</summary>
        <returns>El valor convertido.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Usa <xref:System.Convert> para realizar la conversión.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IFormattable.ToString">
      <MemberSignature Language="C#" Value="string IFormattable.ToString (string format, IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance string System.IFormattable.ToString(string format, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Enum.System#IFormattable#ToString(System.String,System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToString (format As String, provider As IFormatProvider) As String Implements IFormattable.ToString" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::String ^ System.IFormattable.ToString(System::String ^ format, IFormatProvider ^ provider) = IFormattable::ToString;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IFormattable.ToString(System.String,System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6">
          <AttributeName>System.Obsolete("The provider argument is not used. Please use ToString(String).")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="format">To be added.</param>
        <param name="provider">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="ToObject">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Convierte un valor entero especificado en un miembro de enumeración.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ToObject">
      <MemberSignature Language="C#" Value="public static object ToObject (Type enumType, byte value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object ToObject(class System.Type enumType, unsigned int8 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Enum.ToObject(System.Type,System.Byte)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ToObject (enumType As Type, value As Byte) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ ToObject(Type ^ enumType, System::Byte value);" />
      <MemberSignature Language="F#" Value="static member ToObject : Type * byte -&gt; obj" Usage="System.Enum.ToObject (enumType, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="enumType" Type="System.Type" />
        <Parameter Name="value" Type="System.Byte" />
      </Parameters>
      <Docs>
        <param name="enumType">Tipo de enumeración que se va a devolver.</param>
        <param name="value">Valor que se va a convertir en un miembro de enumeración.</param>
        <summary>Convierte el entero de 8 bits sin signo especificado en un miembro de enumeración.</summary>
        <returns>Instancia de la enumeración establecida en <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Enum.ToObject%28System.Type%2CSystem.Byte%29> método convierte `value` a un miembro de enumeración cuyo valor subyacente es `value`. Tenga en cuenta que la conversión se realiza correctamente incluso si el valor está fuera de los límites `enumType` miembros. Para asegurarse de que `value` es un valor subyacente válido de la `enumType` enumeración, páselo a la <xref:System.Enum.IsDefined%2A> método.  
  
 Este método de conversión devuelve un valor de tipo <xref:System.Object>. A continuación, puede convertirlo o convertirlo en un objeto de tipo `enumType`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="enumType" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="enumType" /> no es un objeto <see cref="T:System.Enum" />.</exception>
        <altmember cref="M:System.Enum.IsDefined(System.Type,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="ToObject">
      <MemberSignature Language="C#" Value="public static object ToObject (Type enumType, short value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object ToObject(class System.Type enumType, int16 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Enum.ToObject(System.Type,System.Int16)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ToObject (enumType As Type, value As Short) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ ToObject(Type ^ enumType, short value);" />
      <MemberSignature Language="F#" Value="static member ToObject : Type * int16 -&gt; obj" Usage="System.Enum.ToObject (enumType, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="enumType" Type="System.Type" />
        <Parameter Name="value" Type="System.Int16" />
      </Parameters>
      <Docs>
        <param name="enumType">Tipo de enumeración que se va a devolver.</param>
        <param name="value">Valor que se va a convertir en un miembro de enumeración.</param>
        <summary>Convierte el entero de 16 bits con signo especificado en un miembro de enumeración.</summary>
        <returns>Instancia de la enumeración establecida en <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Enum.ToObject%28System.Type%2CSystem.Int16%29> método convierte `value` a un miembro de enumeración cuyo valor subyacente es `value`. Tenga en cuenta que la conversión se realiza correctamente incluso si el valor está fuera de los límites `enumType` miembros. Para asegurarse de que `value` es un valor subyacente válido de la `enumType` enumeración, páselo a la <xref:System.Enum.IsDefined%2A> método.  
  
 Este método de conversión devuelve un valor de tipo <xref:System.Object>. A continuación, puede convertirlo o convertirlo en un objeto de tipo `enumType`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="enumType" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="enumType" /> no es un objeto <see cref="T:System.Enum" />.</exception>
        <altmember cref="M:System.Enum.IsDefined(System.Type,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="ToObject">
      <MemberSignature Language="C#" Value="public static object ToObject (Type enumType, int value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object ToObject(class System.Type enumType, int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Enum.ToObject(System.Type,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ToObject (enumType As Type, value As Integer) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ ToObject(Type ^ enumType, int value);" />
      <MemberSignature Language="F#" Value="static member ToObject : Type * int -&gt; obj" Usage="System.Enum.ToObject (enumType, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="enumType" Type="System.Type" />
        <Parameter Name="value" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="enumType">Tipo de enumeración que se va a devolver.</param>
        <param name="value">Valor que se va a convertir en un miembro de enumeración.</param>
        <summary>Convierte el entero de 32 bits con signo especificado en un miembro de enumeración.</summary>
        <returns>Instancia de la enumeración establecida en <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Enum.ToObject%28System.Type%2CSystem.Int32%29> método convierte `value` a un miembro de enumeración cuyo valor subyacente es `value`. Tenga en cuenta que la conversión se realiza correctamente incluso si el valor está fuera de los límites `enumType` miembros. Para asegurarse de que `value` es un valor subyacente válido de la `enumType` enumeración, páselo a la <xref:System.Enum.IsDefined%2A> método.  
  
 Este método de conversión devuelve un valor de tipo <xref:System.Object>. A continuación, puede convertirlo o convertirlo en un objeto de tipo `enumType`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="enumType" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="enumType" /> no es un objeto <see cref="T:System.Enum" />.</exception>
        <altmember cref="M:System.Enum.IsDefined(System.Type,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="ToObject">
      <MemberSignature Language="C#" Value="public static object ToObject (Type enumType, long value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object ToObject(class System.Type enumType, int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Enum.ToObject(System.Type,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ToObject (enumType As Type, value As Long) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ ToObject(Type ^ enumType, long value);" />
      <MemberSignature Language="F#" Value="static member ToObject : Type * int64 -&gt; obj" Usage="System.Enum.ToObject (enumType, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="enumType" Type="System.Type" />
        <Parameter Name="value" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="enumType">Tipo de enumeración que se va a devolver.</param>
        <param name="value">Valor que se va a convertir en un miembro de enumeración.</param>
        <summary>Convierte el entero de 64 bits con signo especificado en un miembro de enumeración.</summary>
        <returns>Instancia de la enumeración establecida en <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Enum.ToObject%28System.Type%2CSystem.Int64%29> método convierte `value` a un miembro de enumeración cuyo valor subyacente es `value`. Tenga en cuenta que la conversión se realiza correctamente incluso si el valor está fuera de los límites `enumType` miembros. Para asegurarse de que `value` es un valor subyacente válido de la `enumType` enumeración, páselo a la <xref:System.Enum.IsDefined%2A> método.  
  
 Este método de conversión devuelve un valor de tipo <xref:System.Object>. A continuación, puede convertirlo o convertirlo en un objeto de tipo `enumType`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="enumType" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="enumType" /> no es un objeto <see cref="T:System.Enum" />.</exception>
        <altmember cref="M:System.Enum.IsDefined(System.Type,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="ToObject">
      <MemberSignature Language="C#" Value="public static object ToObject (Type enumType, object value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object ToObject(class System.Type enumType, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Enum.ToObject(System.Type,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ToObject (enumType As Type, value As Object) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ ToObject(Type ^ enumType, System::Object ^ value);" />
      <MemberSignature Language="F#" Value="static member ToObject : Type * obj -&gt; obj" Usage="System.Enum.ToObject (enumType, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="enumType" Type="System.Type" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="enumType">Tipo de enumeración que se va a devolver.</param>
        <param name="value">Valor que se va a convertir en un miembro de enumeración.</param>
        <summary>Convierte el objeto especificado con un valor entero en un miembro de enumeración.</summary>
        <returns>Objeto de enumeración cuyo valor es <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Enum.ToObject%28System.Type%2CSystem.Object%29> método convierte el valor entero `value` a un miembro de enumeración cuyo valor subyacente es `value`. Tenga en cuenta que la conversión se realiza correctamente incluso si el valor está fuera de los límites `enumType` miembros. Para asegurarse de que `value` es un valor subyacente válido de la `enumType` enumeración, páselo a la <xref:System.Enum.IsDefined%2A> método.  
  
 Este método de conversión devuelve un valor de tipo <xref:System.Object>. A continuación, puede convertirlo o convertirlo en un objeto de tipo `enumType`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El valor de <paramref name="enumType" /> o <paramref name="value" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="enumType" /> no es un objeto <see cref="T:System.Enum" />.  ("") <paramref name="value" /> no es de tipo <see cref="T:System.SByte" />, <see cref="T:System.Int16" />, <see cref="T:System.Int32" />, <see cref="T:System.Int64" />, <see cref="T:System.Byte" />, <see cref="T:System.UInt16" />, <see cref="T:System.UInt32" /> o <see cref="T:System.UInt64" />.</exception>
        <altmember cref="M:System.Enum.IsDefined(System.Type,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="ToObject">
      <MemberSignature Language="C#" Value="public static object ToObject (Type enumType, sbyte value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object ToObject(class System.Type enumType, int8 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Enum.ToObject(System.Type,System.SByte)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ToObject (enumType As Type, value As SByte) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ ToObject(Type ^ enumType, System::SByte value);" />
      <MemberSignature Language="F#" Value="static member ToObject : Type * sbyte -&gt; obj" Usage="System.Enum.ToObject (enumType, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="enumType" Type="System.Type" />
        <Parameter Name="value" Type="System.SByte" />
      </Parameters>
      <Docs>
        <param name="enumType">Tipo de enumeración que se va a devolver.</param>
        <param name="value">Valor que se va a convertir en un miembro de enumeración.</param>
        <summary>Convierte el valor entero de 8 bits con signo especificado en un miembro de enumeración.</summary>
        <returns>Instancia de la enumeración establecida en <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Enum.ToObject%28System.Type%2CSystem.SByte%29> método convierte `value` a un miembro de enumeración cuyo valor subyacente es `value`. Tenga en cuenta que la conversión se realiza correctamente incluso si el valor está fuera de los límites `enumType` miembros. Para asegurarse de que `value` es un valor subyacente válido de la `enumType` enumeración, páselo a la <xref:System.Enum.IsDefined%2A> método.  
  
 Este método de conversión devuelve un valor de tipo <xref:System.Object>. A continuación, puede convertirlo o convertirlo en un objeto de tipo `enumType`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="enumType" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="enumType" /> no es un objeto <see cref="T:System.Enum" />.</exception>
        <altmember cref="M:System.Enum.IsDefined(System.Type,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="ToObject">
      <MemberSignature Language="C#" Value="public static object ToObject (Type enumType, ushort value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object ToObject(class System.Type enumType, unsigned int16 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Enum.ToObject(System.Type,System.UInt16)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ToObject (enumType As Type, value As UShort) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ ToObject(Type ^ enumType, System::UInt16 value);" />
      <MemberSignature Language="F#" Value="static member ToObject : Type * uint16 -&gt; obj" Usage="System.Enum.ToObject (enumType, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="enumType" Type="System.Type" />
        <Parameter Name="value" Type="System.UInt16" />
      </Parameters>
      <Docs>
        <param name="enumType">Tipo de enumeración que se va a devolver.</param>
        <param name="value">Valor que se va a convertir en un miembro de enumeración.</param>
        <summary>Convierte el valor entero de 16 bits sin signo especificado en un miembro de enumeración.</summary>
        <returns>Instancia de la enumeración establecida en <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Enum.ToObject%28System.Type%2CSystem.UInt16%29> método convierte `value` a un miembro de enumeración cuyo valor subyacente es `value`. Tenga en cuenta que la conversión se realiza correctamente incluso si el valor está fuera de los límites `enumType` miembros. Para asegurarse de que `value` es un valor subyacente válido de la `enumType` enumeración, páselo a la <xref:System.Enum.IsDefined%2A> método.  
  
 Este método de conversión devuelve un valor de tipo <xref:System.Object>. A continuación, puede convertirlo o convertirlo en un objeto de tipo `enumType`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="enumType" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="enumType" /> no es un objeto <see cref="T:System.Enum" />.</exception>
        <altmember cref="M:System.Enum.IsDefined(System.Type,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="ToObject">
      <MemberSignature Language="C#" Value="public static object ToObject (Type enumType, uint value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object ToObject(class System.Type enumType, unsigned int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Enum.ToObject(System.Type,System.UInt32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ToObject (enumType As Type, value As UInteger) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ ToObject(Type ^ enumType, System::UInt32 value);" />
      <MemberSignature Language="F#" Value="static member ToObject : Type * uint32 -&gt; obj" Usage="System.Enum.ToObject (enumType, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="enumType" Type="System.Type" />
        <Parameter Name="value" Type="System.UInt32" />
      </Parameters>
      <Docs>
        <param name="enumType">Tipo de enumeración que se va a devolver.</param>
        <param name="value">Valor que se va a convertir en un miembro de enumeración.</param>
        <summary>Convierte el valor entero de 32 bits sin signo especificado en un miembro de enumeración.</summary>
        <returns>Instancia de la enumeración establecida en <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Enum.ToObject%28System.Type%2CSystem.UInt32%29> método convierte `value` a un miembro de enumeración cuyo valor subyacente es `value`. Tenga en cuenta que la conversión se realiza correctamente incluso si el valor está fuera de los límites `enumType` miembros. Para asegurarse de que `value` es un valor subyacente válido de la `enumType` enumeración, páselo a la <xref:System.Enum.IsDefined%2A> método.  
  
 Este método de conversión devuelve un valor de tipo <xref:System.Object>. A continuación, puede convertirlo o convertirlo en un objeto de tipo `enumType`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="enumType" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="enumType" /> no es un objeto <see cref="T:System.Enum" />.</exception>
        <altmember cref="M:System.Enum.IsDefined(System.Type,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="ToObject">
      <MemberSignature Language="C#" Value="public static object ToObject (Type enumType, ulong value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object ToObject(class System.Type enumType, unsigned int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Enum.ToObject(System.Type,System.UInt64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ToObject (enumType As Type, value As ULong) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ ToObject(Type ^ enumType, System::UInt64 value);" />
      <MemberSignature Language="F#" Value="static member ToObject : Type * uint64 -&gt; obj" Usage="System.Enum.ToObject (enumType, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="enumType" Type="System.Type" />
        <Parameter Name="value" Type="System.UInt64" />
      </Parameters>
      <Docs>
        <param name="enumType">Tipo de enumeración que se va a devolver.</param>
        <param name="value">Valor que se va a convertir en un miembro de enumeración.</param>
        <summary>Convierte el valor entero de 64 bits sin signo especificado en un miembro de enumeración.</summary>
        <returns>Instancia de la enumeración establecida en <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Enum.ToObject%28System.Type%2CSystem.UInt64%29> método convierte `value` a un miembro de enumeración cuyo valor subyacente es `value`. Tenga en cuenta que la conversión se realiza correctamente incluso si el valor está fuera de los límites `enumType` miembros. Para asegurarse de que `value` es un valor subyacente válido de la `enumType` enumeración, páselo a la <xref:System.Enum.IsDefined%2A> método.  
  
 Este método de conversión devuelve un valor de tipo <xref:System.Object>. A continuación, puede convertirlo o convertirlo en un objeto de tipo `enumType`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="enumType" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="enumType" /> no es un objeto <see cref="T:System.Enum" />.</exception>
        <altmember cref="M:System.Enum.IsDefined(System.Type,System.Object)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="ToString">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Convierte el valor de esta instancia en la representación de cadena equivalente.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Enum.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="enum.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Convierte el valor de esta instancia en la representación de cadena equivalente.</summary>
        <returns>Representación de cadena del valor de esta instancia.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El valor devuelto se formatea con el especificador de formato general ("G"). Es decir, si la <xref:System.FlagsAttribute> no se aplica a este tipo enumerado y hay una constante con nombre igual al valor de esta instancia y, a continuación, el valor devuelto es una cadena que contiene el nombre de la constante. Si el <xref:System.FlagsAttribute> se aplica y hay una combinación de uno o más constantes con nombre igual al valor de esta instancia, entonces el valor devuelto es una cadena que contiene una lista separada por delimitador de los nombres de las constantes. En caso contrario, el valor devuelto es la representación de cadena del valor numérico de esta instancia. Para obtener más información sobre el formato de los valores de enumeración, vea [Enumeration Format Strings](~/docs/standard/base-types/enumeration-format-strings.md). Para obtener más información sobre el formato en general, consulte [aplicar formato a tipos](~/docs/standard/base-types/formatting-types.md).  
  
   
  
## Examples  
 En el ejemplo siguiente se muestra cómo convertir un valor enumerado en una cadena.  
  
 [!code-cpp[Classic Enum.ToString2 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Enum.ToString2 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Enum.ToString2 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Enum.ToString2 Example/CS/source.cs#1)]
 [!code-vb[Classic Enum.ToString2 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Enum.ToString2 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage">
          <para>Si varios miembros de enumeración tienen el mismo valor subyacente e intenta recuperar la representación de cadena del nombre de un miembro de la enumeración basada en su valor subyacente, el código no debe hacer ninguna suposición sobre el nombre que el método devolverá. Por ejemplo, la siguiente enumeración define dos miembros, <c>Shade.Gray</c> y <c>Shade.Grey</c>, que tienen el mismo valor subyacente.  [! código csharp[System.Enum.ToString#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.enum.tostring/cs/tostringbyvalue1.cs#1)] [! código vb[System.Enum.ToString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.enum.tostring/vb/tostringbyvalue1.vb#1)] la siguiente llamada de método intenta recuperar el nombre de un miembro de la <c>Shade</c> enumeración cuyo valor subyacente es 1. El método puede devolver "Gray" o "Grey" y el código no debe hacer ninguna suposición sobre la que se devolverá la cadena.  [! código csharp[System.Enum.ToString#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.enum.tostring/cs/tostringbyvalue1.cs#2)] [! código vb[System.Enum.ToString#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.enum.tostring/vb/tostringbyvalue1.vb#2)]</para>
        </block>
        <altmember cref="M:System.Enum.Format(System.Type,System.Object,System.String)" />
        <altmember cref="M:System.Enum.Parse(System.Type,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public string ToString (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string ToString(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Enum.ToString(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToString (provider As IFormatProvider) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ ToString(IFormatProvider ^ provider);" />
      <MemberSignature Language="F#" Value="override this.ToString : IFormatProvider -&gt; string" Usage="enum.ToString provider" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToString(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("The provider argument is not used. Please use ToString().")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">(obsoleto)</param>
        <summary>Esta sobrecarga del método está en desuso; utilice <see cref="M:System.Enum.ToString" />.</summary>
        <returns>Representación de cadena del valor de esta instancia.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public string ToString (string format);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ToString(string format) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Enum.ToString(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToString (format As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ToString(System::String ^ format);" />
      <MemberSignature Language="F#" Value="override this.ToString : string -&gt; string" Usage="enum.ToString format" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="format">Cadena de formato.</param>
        <summary>Convierte el valor de esta instancia en la representación de cadena equivalente usando el formato especificado.</summary>
        <returns>Representación en forma de cadena del valor de esta instancia, tal y como especifica <paramref name="format" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El `format` parámetro puede ser una de las siguientes cadenas de formato: "G" o "g", "D" o "d", "X" o "x" y "F" o "f" (la cadena de formato no distingue mayúsculas de minúsculas). Si `format` es `null` o una cadena vacía (""), se usa el especificador de formato general ("G"). Para obtener más información sobre las cadenas de formato de enumeración y el formato de los valores de enumeración, vea [Enumeration Format Strings](~/docs/standard/base-types/enumeration-format-strings.md). Para obtener más información sobre el formato en general, consulte [aplicar formato a tipos](~/docs/standard/base-types/formatting-types.md).  
  
   
  
## Examples  
 El ejemplo siguiente muestra cómo convertir un valor enumerado en una cadena.  
  
 [!code-cpp[enum.tostring#1](~/samples/snippets/cpp/VS_Snippets_CLR/enum.tostring/CPP/tostr.cpp#1)]
 [!code-csharp[enum.tostring#1](~/samples/snippets/csharp/VS_Snippets_CLR/enum.tostring/CS/tostr.cs#1)]
 [!code-vb[enum.tostring#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/enum.tostring/VB/tostr.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException">
          <paramref name="format" /> contiene una especificación que no es válida.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="format" /> es igual a "X", pero el tipo de enumeración es desconocido.</exception>
        <block subset="none" type="usage">
          <para>Si varios miembros de enumeración tienen el mismo valor subyacente e intenta recuperar la representación de cadena del nombre de un miembro de la enumeración basada en su valor subyacente, el código no debe hacer ninguna suposición sobre el nombre que el método devolverá. Por ejemplo, la siguiente enumeración define dos miembros, <c>Shade.Gray</c> y <c>Shade.Grey</c>, que tienen el mismo valor subyacente.  [! código csharp[System.Enum.ToString#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.enum.tostring/cs/tostringbyvalue1.cs#1)] [! código vb[System.Enum.ToString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.enum.tostring/vb/tostringbyvalue1.vb#1)] la siguiente llamada de método intenta recuperar el nombre de un miembro de la <c>Shade</c> enumeración cuyo valor subyacente es 1. El método puede devolver "Gray" o "Grey" y el código no debe hacer ninguna suposición sobre la que se devolverá la cadena.  [! código csharp[System.Enum.ToString#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.enum.tostring/cs/tostringbyvalue1.cs#3)] [! código vb[System.Enum.ToString#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.enum.tostring/vb/tostringbyvalue1.vb#3)]</para>
        </block>
        <altmember cref="M:System.Enum.Format(System.Type,System.Object,System.String)" />
        <altmember cref="M:System.Enum.Parse(System.Type,System.String)" />
        <altmember cref="M:System.IFormattable.ToString(System.String,System.IFormatProvider)" />
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public string ToString (string format, IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string ToString(string format, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Enum.ToString(System.String,System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToString (format As String, provider As IFormatProvider) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ ToString(System::String ^ format, IFormatProvider ^ provider);" />
      <MemberSignature Language="F#" Value="override this.ToString : string * IFormatProvider -&gt; string" Usage="enum.ToString (format, provider)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IFormattable.ToString(System.String,System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("The provider argument is not used. Please use ToString(String).")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="format">Especificación de formato.</param>
        <param name="provider">(Obsoleto).</param>
        <summary>Esta sobrecarga del método está en desuso; utilice <see cref="M:System.Enum.ToString(System.String)" />.</summary>
        <returns>Representación en forma de cadena del valor de esta instancia, tal y como especifica <paramref name="format" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El `format` parámetro puede ser una de las siguientes cadenas de formato: "G" o "g", "D" o "d", "X" o "x" y "F" o "f" (la cadena de formato no distingue mayúsculas de minúsculas). Si `format` es `null` o una cadena vacía (""), se usa el especificador de formato general ("G"). Para obtener más información sobre las cadenas de formato de enumeración y el formato de los valores de enumeración, vea [Enumeration Format Strings](~/docs/standard/base-types/enumeration-format-strings.md). Para obtener más información sobre el formato en general, consulte [aplicar formato a tipos](~/docs/standard/base-types/formatting-types.md).  
  
 Especifique solo `format`; el `provider` parámetro está obsoleto.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException">
          <paramref name="format" /> no contiene una especificación de formato válida.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="format" /> es igual a "X", pero el tipo de enumeración es desconocido.</exception>
        <altmember cref="M:System.Enum.Format(System.Type,System.Object,System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="TryParse">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Convierte la representación de cadena del nombre o valor numérico de una o varias constantes enumeradas en un objeto enumerado equivalente. El valor devuelto indica si la conversión se realizó correctamente.</summary>
        <altmember cref="M:System.Enum.Parse(System.Type,System.String)" />
      </Docs>
    </MemberGroup>
    <Member MemberName="TryParse">
      <MemberSignature Language="C#" Value="public static bool TryParse (Type enumType, string value, out object result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryParse(class System.Type enumType, string value, [out] object&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Enum.TryParse(System.Type,System.String,System.Object@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryParse (enumType As Type, value As String, ByRef result As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryParse(Type ^ enumType, System::String ^ value, [Runtime::InteropServices::Out] System::Object ^ % result);" />
      <MemberSignature Language="F#" Value="static member TryParse : Type * string *  -&gt; bool" Usage="System.Enum.TryParse (enumType, value, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="enumType" Type="System.Type" />
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="result" Type="System.Object" RefType="out" />
      </Parameters>
      <Docs>
        <param name="enumType">To be added.</param>
        <param name="value">To be added.</param>
        <param name="result">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryParse">
      <MemberSignature Language="C#" Value="public static bool TryParse (Type enumType, string value, bool ignoreCase, out object result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryParse(class System.Type enumType, string value, bool ignoreCase, [out] object&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Enum.TryParse(System.Type,System.String,System.Boolean,System.Object@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryParse (enumType As Type, value As String, ignoreCase As Boolean, ByRef result As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryParse(Type ^ enumType, System::String ^ value, bool ignoreCase, [Runtime::InteropServices::Out] System::Object ^ % result);" />
      <MemberSignature Language="F#" Value="static member TryParse : Type * string * bool *  -&gt; bool" Usage="System.Enum.TryParse (enumType, value, ignoreCase, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="enumType" Type="System.Type" />
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
        <Parameter Name="result" Type="System.Object" RefType="out" />
      </Parameters>
      <Docs>
        <param name="enumType">To be added.</param>
        <param name="value">To be added.</param>
        <param name="ignoreCase">To be added.</param>
        <param name="result">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryParse&lt;TEnum&gt;">
      <MemberSignature Language="C#" Value="public static bool TryParse&lt;TEnum&gt; (string value, out TEnum result) where TEnum : struct;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryParse&lt;struct .ctor (class System.ValueType) TEnum&gt;(string value, [out] !!TEnum&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Enum.TryParse``1(System.String,``0@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryParse(Of TEnum As Structure) (value As String, ByRef result As TEnum) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TEnum&gt;&#xA; where TEnum : value class static bool TryParse(System::String ^ value, [Runtime::InteropServices::Out] TEnum % result);" />
      <MemberSignature Language="F#" Value="static member TryParse : string *  -&gt; bool (requires 'Enum : struct)" Usage="System.Enum.TryParse (value, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TEnum">
          <Constraints>
            <ParameterAttribute>DefaultConstructorConstraint</ParameterAttribute>
            <ParameterAttribute>NotNullableValueTypeConstraint</ParameterAttribute>
            <BaseTypeName>System.ValueType</BaseTypeName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="result" Type="TEnum" RefType="out" />
      </Parameters>
      <Docs>
        <typeparam name="TEnum">El tipo de enumeración que se va a convertir <c>valor</c>.</typeparam>
        <param name="value">Representación de cadena que distingue mayúsculas de minúsculas del nombre de enumeración o valor subyacente que se va a convertir.</param>
        <param name="result">Cuando este método devuelve un valor, <c>result</c> contiene un objeto de tipo <c>TEnum</c> cuyo valor está representado por <c>value</c> si la operación de análisis es correcta. Si se produce un error en la operación de análisis, <c>result</c> contiene el valor predeterminado del tipo subyacente de <c>TEnum</c>. Observe que este valor no tiene que ser un miembro de la enumeración <c>TEnum</c>. Este parámetro se pasa sin inicializar.</param>
        <summary>Convierte la representación de cadena del nombre o valor numérico de una o varias constantes enumeradas en un objeto enumerado equivalente. El valor devuelto indica si la conversión se realizó correctamente.</summary>
        <returns>
          <see langword="true" /> si el parámetro <paramref name="value" /> se convierte correctamente; en caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Enum.TryParse%60%601%28System.String%2C%60%600%40%29> es idéntica a la <xref:System.Enum.Parse%28System.Type%2CSystem.String%29> método, salvo que en lugar de producir una excepción, devuelve `false` si se produce un error en la conversión. Elimina la necesidad de control de excepciones al analizar la representación de cadena de un valor de enumeración.  
  
 El `value` parámetro contiene la representación de cadena del valor subyacente o la constante con nombre de un miembro de enumeración o una lista de constantes con nombre o los valores subyacentes delimitados por comas (,). Si `value` incluye varios denominado constantes o valores, uno o más espacios en blanco pueden ir precedidas o seguidas de cada valor, el nombre o por comas en `value`. Si `value` es una lista, `result` refleja el valor de los nombres especificados o combinados con un bit a bit de los valores subyacentes `OR` operación. Si `value` es la representación de cadena del nombre de un valor de enumeración, la comparación de `value` con enumeración nombres distingue mayúsculas de minúsculas.  
  
 Si `value` es un nombre que no corresponde a una constante con nombre de `TEnum`, el método devuelve `false`. Si `value` es la representación de cadena de un entero que no representa un valor subyacente de la `TEnum` enumeración, el método devuelve un miembro de enumeración cuyo valor subyacente es `value` convertir a un tipo entero. Si no desea este comportamiento, llame a la <xref:System.Enum.IsDefined%2A> método para asegurarse de que una representación de cadena concreta de un entero es realmente un miembro de `TEnum`.  
  
   
  
## Examples  
 En el ejemplo siguiente se define un `Colors` enumeración, llama el <xref:System.Enum.TryParse%60%601%28System.String%2C%60%600%40%29> método para convertir cadenas en sus correspondientes valores de enumeración y llama a la <xref:System.Enum.IsDefined%2A> valores del método para asegurarse de que determinados valores integrales son subyacentes en el `Colors` enumeración.  
  
 [!code-csharp[System.Enum.TryParse#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.enum.tryparse/cs/tryparse1.cs#1)]
 [!code-vb[System.Enum.TryParse#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.enum.tryparse/vb/tryparse1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="TEnum" /> no es un tipo de enumeración.</exception>
        <altmember cref="M:System.Enum.Parse(System.Type,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="TryParse&lt;TEnum&gt;">
      <MemberSignature Language="C#" Value="public static bool TryParse&lt;TEnum&gt; (string value, bool ignoreCase, out TEnum result) where TEnum : struct;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryParse&lt;struct .ctor (class System.ValueType) TEnum&gt;(string value, bool ignoreCase, [out] !!TEnum&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Enum.TryParse``1(System.String,System.Boolean,``0@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryParse(Of TEnum As Structure) (value As String, ignoreCase As Boolean, ByRef result As TEnum) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TEnum&gt;&#xA; where TEnum : value class static bool TryParse(System::String ^ value, bool ignoreCase, [Runtime::InteropServices::Out] TEnum % result);" />
      <MemberSignature Language="F#" Value="static member TryParse : string * bool *  -&gt; bool (requires 'Enum : struct)" Usage="System.Enum.TryParse (value, ignoreCase, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TEnum">
          <Constraints>
            <ParameterAttribute>DefaultConstructorConstraint</ParameterAttribute>
            <ParameterAttribute>NotNullableValueTypeConstraint</ParameterAttribute>
            <BaseTypeName>System.ValueType</BaseTypeName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
        <Parameter Name="result" Type="TEnum" RefType="out" />
      </Parameters>
      <Docs>
        <typeparam name="TEnum">El tipo de enumeración que se va a convertir <c>valor</c>.</typeparam>
        <param name="value">Representación de cadena del nombre de enumeración o valor subyacente que se va a convertir.</param>
        <param name="ignoreCase">Es <see langword="true" /> para no distinguir entre mayúsculas y minúsculas; es <see langword="false" /> para tener en cuenta la distinción entre mayúsculas y minúsculas.</param>
        <param name="result">Cuando este método devuelve un valor, <c>result</c> contiene un objeto de tipo <c>TEnum</c> cuyo valor está representado por <c>value</c> si la operación de análisis es correcta. Si se produce un error en la operación de análisis, <c>result</c> contiene el valor predeterminado del tipo subyacente de <c>TEnum</c>. Observe que este valor no tiene que ser un miembro de la enumeración <c>TEnum</c>. Este parámetro se pasa sin inicializar.</param>
        <summary>Convierte la representación de cadena del nombre o valor numérico de una o varias constantes enumeradas en un objeto enumerado equivalente. Un parámetro especifica si la operación distingue mayúsculas de minúsculas. El valor devuelto indica si la conversión se realizó correctamente.</summary>
        <returns>
          <see langword="true" /> si el parámetro <paramref name="value" /> se convierte correctamente; en caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Enum.TryParse%60%601%28System.String%2CSystem.Boolean%2C%60%600%40%29> es idéntica a la <xref:System.Enum.Parse%28System.Type%2CSystem.String%2CSystem.Boolean%29> método, salvo que en lugar de producir una excepción, devuelve `false` si se produce un error en la conversión. Elimina la necesidad de control de excepciones al analizar la representación de cadena de un valor de enumeración.  
  
 El `value` parámetro contiene la representación de cadena del valor subyacente o la constante con nombre de un miembro de enumeración o una lista de constantes con nombre o los valores subyacentes delimitados por comas (,). Si `value` incluye varios denominado constantes o valores, uno o más espacios en blanco pueden ir precedidas o seguidas de cada valor, el nombre o por comas en `value`. Si `value` es una lista, `result` refleja el valor de los nombres especificados o combinados con un bit a bit de los valores subyacentes `OR` operación. Si `value` es la representación de cadena del nombre de un valor de enumeración, la comparación de `value` con enumeración nombres depende el `ignoreCase` parámetro. Si `true`, la comparación distingue mayúsculas de minúsculas; si `false`, distingue mayúsculas de minúsculas.  
  
 Si `value` es un nombre que no corresponde a una constante con nombre de `TEnum`, el método devuelve `false`. Si `value` es la representación de cadena de un entero que no representa un valor subyacente de la `TEnum` enumeración, el método devuelve un miembro de enumeración cuyo valor subyacente es `value` convertir a un tipo entero. Si no desea este comportamiento, llame a la <xref:System.Enum.IsDefined%2A> método para asegurarse de que una representación de cadena concreta de un entero es realmente un miembro de `TEnum`.  
  
   
  
## Examples  
 En el ejemplo siguiente se define un `Colors` enumeración, llama el <xref:System.Enum.TryParse%60%601%28System.String%2CSystem.Boolean%2C%60%600%40%29> método para convertir cadenas en sus correspondientes valores de enumeración y llama a la <xref:System.Enum.IsDefined%2A> valores del método para asegurarse de que determinados valores integrales son subyacentes en el `Colors` enumeración. El <xref:System.Enum.TryParse%60%601%28System.String%2CSystem.Boolean%2C%60%600%40%29> método utiliza la comparación entre mayúsculas y minúsculas al intentar convertir las representaciones de cadena de nombre constantes a sus valores de enumeración equivalente.  
  
 [!code-csharp[System.Enum.TryParse#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.enum.tryparse/cs/tryparse2.cs#2)]
 [!code-vb[System.Enum.TryParse#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.enum.tryparse/vb/tryparse2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="TEnum" /> no es un tipo de enumeración.</exception>
        <altmember cref="M:System.Enum.Parse(System.Type,System.String,System.Boolean)" />
      </Docs>
    </Member>
  </Members>
</Type>