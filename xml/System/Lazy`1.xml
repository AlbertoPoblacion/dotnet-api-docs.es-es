<Type Name="Lazy&lt;T&gt;" FullName="System.Lazy&lt;T&gt;">
  <Metadata><Meta Name="ms.openlocfilehash" Value="11826166fef32f2564da98bcfb9954709a20fbc7" /><Meta Name="ms.sourcegitcommit" Value="42a3c35677e9d87eeb503607ae50c9d39827d414" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="es-ES" /><Meta Name="ms.lasthandoff" Value="12/17/2018" /><Meta Name="ms.locfileid" Value="53524024" /></Metadata><TypeSignature Language="C#" Value="public class Lazy&lt;T&gt;" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable beforefieldinit Lazy`1&lt;T&gt; extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Lazy`1" />
  <TypeSignature Language="VB.NET" Value="Public Class Lazy(Of T)" />
  <TypeSignature Language="C++ CLI" Value="generic &lt;typename T&gt;&#xA;public ref class Lazy" />
  <TypeSignature Language="F#" Value="type Lazy&lt;'T&gt; = class" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Core</AssemblyName>
  </AssemblyInfo>
  <TypeParameters>
    <TypeParameter Name="T" />
  </TypeParameters>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0">
      <AttributeName>System.Diagnostics.DebuggerDisplay("ThreadSafetyMode={Mode}, IsValueCreated={IsValueCreated}, IsValueFaulted={IsValueFaulted}, Value={ValueForDebugDisplay}")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0">
      <AttributeName>System.Diagnostics.DebuggerTypeProxy(typeof(System.System_LazyDebugView`1))</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0">
      <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0">
      <AttributeName>System.Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <typeparam name="T">Tipo de objeto que se inicializa de forma diferida.</typeparam>
    <summary>Proporciona compatibilidad para la inicialización diferida.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use la inicialización diferida para aplazar la creación de un objeto grande o que consumen muchos recursos o la ejecución de una tarea que consume muchos recursos, especialmente cuando la creación o la ejecución podría no producirse durante la vigencia del programa.  
  
 Para prepararse para la inicialización diferida, se crea una instancia de <xref:System.Lazy%601>. El argumento de tipo de la <xref:System.Lazy%601> objetos que creas especifica el tipo del objeto que se va a inicializar de forma diferida. El constructor que se usa para crear el <xref:System.Lazy%601> objeto determina las características de la inicialización. La inicialización diferida se produce la primera vez que se accede a la propiedad <xref:System.Lazy%601.Value%2A?displayProperty=nameWithType>.  
  
 En la mayoría de los casos, elección de un constructor depende de las respuestas a dos preguntas:  
  
-   ¿El objeto inicializado de forma diferida se tendrá acceso desde varios subprocesos? Si es así, la <xref:System.Lazy%601> objeto podría crear en cualquier subproceso. Puede usar uno de los constructores simple cuyo comportamiento predeterminado consiste en crear un seguro para subprocesos <xref:System.Lazy%601> objeto, por lo que solo una instancia del objeto con instancias de forma diferida se crea independientemente de cuántos subprocesos intentan obtener acceso a él. Para crear un <xref:System.Lazy%601> objeto que no es seguro para subprocesos, debe usar un constructor que le permite no especificar ninguna seguridad para subprocesos.  
  
    > [!CAUTION]
    >  Realizar la <xref:System.Lazy%601> seguro para subprocesos de objeto no protege el objeto inicializado de forma diferida. Si varios subprocesos pueden tener acceso al objeto inicializado de forma diferida, debe realizar sus propiedades y métodos seguros para el acceso multiproceso.  
  
-   ¿La inicialización diferida requiere una gran cantidad de código o el objeto inicializado de forma diferida tiene un constructor predeterminado que se hace todo lo que necesita y no produce excepciones? Si tiene que escribir código de inicialización o si es necesario controlar las excepciones, use uno de los constructores que toma un método de fábrica. Escriba el código de inicialización en el método de fábrica.  
  
 La siguiente tabla muestra qué constructor para elegir, en función de estos dos factores:  
  
|Objeto tendrán acceso a|Si se requiere ningún código de inicialización (constructor predeterminado), usar|Si se requiere código de inicialización, utilice|  
|--------------------------------|------------------------------------------------------------------------|---------------------------------------------|  
|Varios subprocesos|<xref:System.Lazy%601.%23ctor>|<xref:System.Lazy%601.%23ctor%28System.Func%7B%600%7D%29>|  
|Un subproceso|<xref:System.Lazy%601.%23ctor%28System.Boolean%29> con `isThreadSafe` establecido en `false`.|<xref:System.Lazy%601.%23ctor%28System.Func%7B%600%7D%2CSystem.Boolean%29> con `isThreadSafe` establecido en `false`.|  
  
 Puede usar una expresión lambda para especificar el método de fábrica. Esto evita que todo el código de inicialización en un solo lugar. La expresión lambda captura el contexto, incluidos los argumentos que se pasan al constructor del objeto inicializado de forma diferida.  
  
 **Excepción de almacenamiento en caché** cuando se usan métodos de fábrica, las excepciones se almacenan en caché. Es decir, si el método de fábrica produce un tiempo de la primera excepción un subproceso intenta tener acceso a la <xref:System.Lazy%601.Value%2A> propiedad de la <xref:System.Lazy%601> de objeto, la misma excepción se produce en cada intento posterior. Esto garantiza que todas las llamadas a la <xref:System.Lazy%601.Value%2A> propiedad produce el mismo resultado y evita errores sutiles que pueden surgir si diferentes subprocesos obtención resultados diferentes. El <xref:System.Lazy%601> reemplaza reales `T` que en caso contrario, habría inicializado en algún momento anterior, normalmente durante el inicio. Es grave normalmente un error en ese momento anterior. Si hay una posibilidad de un error recuperable, se recomienda crear la lógica de reintento a la rutina de inicialización (en este caso, el método de fábrica), como haría si usara la inicialización diferida.  
  
 **Alternativa al bloqueo** en determinadas situaciones, es posible que desee evitar la sobrecarga de la <xref:System.Lazy%601> objeto predeterminado el comportamiento de bloqueo. En raras ocasiones, podría ser una posibilidad de interbloqueos. En tales casos, puede usar el <xref:System.Lazy%601.%23ctor%28System.Threading.LazyThreadSafetyMode%29> o <xref:System.Lazy%601.%23ctor%28System.Func%7B%600%7D%2CSystem.Threading.LazyThreadSafetyMode%29> constructor y especifique <xref:System.Threading.LazyThreadSafetyMode.PublicationOnly?displayProperty=nameWithType>. Esto permite la <xref:System.Lazy%601> objeto para crear una copia del objeto inicializado de forma diferida en cada uno de varios subprocesos si llama los subprocesos del <xref:System.Lazy%601.Value%2A> propiedad simultáneamente. La <xref:System.Lazy%601> objeto garantiza que todos los subprocesos usan la misma instancia del objeto inicializado de forma diferida y descarta las instancias que no se utilizan. Por lo tanto, el costo de reducir la sobrecarga de bloqueo es que el programa podría en ocasiones, crear y descartar copias adicionales de un objeto costoso. En la mayoría de los casos, esto es improbable. Los ejemplos para el <xref:System.Lazy%601.%23ctor%28System.Threading.LazyThreadSafetyMode%29> y <xref:System.Lazy%601.%23ctor%28System.Func%7B%600%7D%2CSystem.Threading.LazyThreadSafetyMode%29> constructores demuestran este comportamiento.  
  
> [!IMPORTANT]
>  Cuando se especifica <xref:System.Threading.LazyThreadSafetyMode.PublicationOnly?displayProperty=nameWithType>, las excepciones no están nunca en caché, incluso si se especifica un método de fábrica.  
  
 **Constructores equivalente** además de habilitar el uso de <xref:System.Threading.LazyThreadSafetyMode.PublicationOnly?displayProperty=nameWithType>, <xref:System.Lazy%601.%23ctor%28System.Threading.LazyThreadSafetyMode%29> y <xref:System.Lazy%601.%23ctor%28System.Func%7B%600%7D%2CSystem.Threading.LazyThreadSafetyMode%29> constructores pueden duplicar la funcionalidad de los otros constructores. En la siguiente tabla muestra los valores de parámetro que producen un comportamiento equivalente.  
  
|Para crear un <xref:System.Lazy%601> objeto que se|Para los constructores que tienen un `LazyThreadSafetyMode` `mode` conjunto de parámetros, `mode` a|Para los constructores que tienen un valor booleano `isThreadSafe` conjunto de parámetros, `isThreadSafe` a|Para los constructores sin parámetros de seguridad para subprocesos|  
|-------------------------------------------------------------------------------------------------------------------------------------------------------|-----------------------------------------------------------------------------------------|------------------------------------------------------------------------------------------|-------------------------------------------------------|  
|Totalmente seguro para subprocesos; se usa el bloqueo para garantizar que sólo un subproceso inicializa el valor.|<xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication>|`true`|Todos los constructores de este tipo son totalmente seguros para subprocesos.|  
|No es seguro para subprocesos.|<xref:System.Threading.LazyThreadSafetyMode.None>|`false`|No es aplicable.|  
|Totalmente seguro para subprocesos; anticipación de subprocesos para inicializar el valor.|<xref:System.Threading.LazyThreadSafetyMode.PublicationOnly>|No es aplicable.|No es aplicable.|  
  
 **Otras funcionalidades** para obtener información sobre el uso de <xref:System.Lazy%601> con campos de subproceso estático, o como almacén de respaldo para las propiedades, consulte [la inicialización diferida](~/docs/framework/performance/lazy-initialization.md).  
  
   
  
## Examples  
 En el ejemplo siguiente se muestra el uso de la <xref:System.Lazy%601> clase para proporcionar la inicialización diferida con acceso desde varios subprocesos.  
  
> [!NOTE]
>  El ejemplo se usa el <xref:System.Lazy%601.%23ctor%28System.Func%7B%600%7D%29> constructor. También se muestra el uso de la <xref:System.Lazy%601.%23ctor%28System.Func%7B%600%7D%2CSystem.Boolean%29> constructor (especificar `true` para `isThreadSafe`) y el <xref:System.Lazy%601.%23ctor%28System.Func%7B%600%7D%2CSystem.Threading.LazyThreadSafetyMode%29> constructor (especificar <xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication?displayProperty=nameWithType> para `mode`). Para cambiar a un constructor diferente, cambie los constructores que están comentados.  
>   
>  Para obtener un ejemplo que muestra la excepción de almacenamiento en caché mediante los constructores de la mismos, consulte el <xref:System.Lazy%601.%23ctor%28System.Func%7B%600%7D%29> constructor.  
  
 El ejemplo define una clase `LargeObject` que uno de varios subprocesos inicializará de forma diferida. La claves cuatro secciones de código muestran la creación de inicializador, el método de fábrica, la inicialización real y el constructor de la `LargeObject` (clase), que muestra un mensaje cuando se crea el objeto. Al principio del método `Main`, el ejemplo crea el inicializador diferido seguro para subprocesos para `LargeObject`:  
  
 [!code-csharp[System.Lazy\`1#NewLazy](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1/cs/example.cs#newlazy)]
 [!code-vb[System.Lazy\`1#NewLazy](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1/vb/example.vb#newlazy)]  
  
 El método de fábrica, muestra la creación del objeto, con un marcador de posición para una posterior inicialización:  
  
 [!code-csharp[System.Lazy\`1#FactoryFunc](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1/cs/example.cs#factoryfunc)]
 [!code-vb[System.Lazy\`1#FactoryFunc](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1/vb/example.vb#factoryfunc)]  
  
 Tenga en cuenta que las secciones de código primero dos podrían combinarse con una función lambda, como se muestra aquí:  
  
 [!code-csharp[System.Lazy\`1#InitWithLambda](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1/cs/lambda.cs#initwithlambda)]
 [!code-vb[System.Lazy\`1#InitWithLambda](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1/vb/lambda.vb#initwithlambda)]  
  
 En el ejemplo se pone en pausa, para indicar que es posible que transcurra un período indeterminado antes de que se produce la inicialización diferida. Cuando presiona el **ENTRAR** clave, el ejemplo crea e inicia tres subprocesos. El `ThreadProc` método utilizado por todas las llamadas de tres subprocesos el <xref:System.Lazy%601.Value%2A> propiedad. La primera vez que esto sucede, el `LargeObject` se crea la instancia:  
  
 [!code-csharp[System.Lazy\`1#ValueProp](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1/cs/example.cs#valueprop)]
 [!code-vb[System.Lazy\`1#ValueProp](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1/vb/example.vb#valueprop)]  
  
 El constructor de la `LargeObject` (clase), que incluye la última sección clave de código, se muestra un mensaje y se registra la identidad del subproceso de inicialización. El resultado del programa aparece al final de la lista de código completa.  
  
 [!code-csharp[System.Lazy\`1#LargeCtor](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1/cs/example.cs#largector)]
 [!code-vb[System.Lazy\`1#LargeCtor](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1/vb/example.vb#largector)]  
  
> [!NOTE]
>  Por simplificar, en este ejemplo se emplea una instancia global de <xref:System.Lazy%601> y todos los métodos son `static` (`Shared` en Visual Basic). No son requisitos para el uso de la inicialización diferida.  
  
 [!code-csharp[System.Lazy\`1#All](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1/cs/example.cs#all)]
 [!code-vb[System.Lazy\`1#All](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1/vb/example.vb#all)]  
  
 ]]></format>
    </remarks>
    <threadsafe>De forma predeterminada, todos los miembros públicos y protegidos de la <see cref="T:System.Lazy`1" /> clase son seguros para subprocesos y se pueden usar simultáneamente desde varios subprocesos. Si lo desea y por instancia, usar parámetros para los constructores del tipo, se pueden quitar estas garantías de seguridad para subprocesos.</threadsafe>
    <altmember cref="T:System.Threading.LazyThreadSafetyMode" />
    <related type="Article" href="~/docs/framework/performance/lazy-initialization.md">Inicialización diferida</related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Lazy`1" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Lazy ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Lazy`1.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Lazy();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Lazy`1" />. Cuando se produce la inicialización diferida, se usa el constructor predeterminado del tipo de destino.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Una instancia que se crea con este constructor se puede usar simultáneamente desde varios subprocesos.  
  
 El modo de seguridad para subprocesos de un <xref:System.Lazy%601> instancia que se inicializa con este constructor es <xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication?displayProperty=nameWithType>. El modo de seguridad para subprocesos describe el comportamiento cuando varios subprocesos intentan inicializar el <xref:System.Lazy%601> instancia.  
  
 Un <xref:System.Lazy%601> instancia que se crea con este constructor no almacena en caché las excepciones. Para obtener más información, vea la clase <xref:System.Lazy%601> o la enumeración <xref:System.Threading.LazyThreadSafetyMode?displayProperty=nameWithType>.  
  
   
  
## Examples  
 El ejemplo siguiente muestra el uso de este constructor. También muestra el uso de la <xref:System.Lazy%601.%23ctor%28System.Boolean%29> constructor (especificar `true` para `isThreadSafe`) y el <xref:System.Lazy%601.%23ctor%28System.Threading.LazyThreadSafetyMode%29> constructor (especificar <xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication?displayProperty=nameWithType> para `mode`). Para cambiar a un constructor diferente, cambie los constructores que están comentados.  
  
 El ejemplo define una clase `LargeObject` que uno de varios subprocesos inicializará de forma diferida. Las dos líneas claves del código en este ejemplo son la creación de inicializador y la inicialización real. Al principio del método `Main`, el ejemplo crea el inicializador diferido seguro para subprocesos para `LargeObject`:  
  
 [!code-csharp[System.Lazy\`1.ctor#NewLazy](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1.ctor/cs/example.cs#newlazy)]
 [!code-vb[System.Lazy\`1.ctor#NewLazy](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1.ctor/vb/example.vb#newlazy)]  
  
 En el ejemplo se crea e inicia tres subprocesos se bloquean en un <xref:System.Threading.ManualResetEvent> de objeto, por lo que en el ejemplo se puede liberar los subprocesos a la vez. El `ThreadProc` método utilizado por todas las llamadas de tres subprocesos el <xref:System.Lazy%601.Value%2A> propiedad va a obtener el `LargeObject` instancia:  
  
 [!code-csharp[System.Lazy\`1.ctor#ValueProp](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1.ctor/cs/example.cs#valueprop)]
 [!code-vb[System.Lazy\`1.ctor#ValueProp](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1.ctor/vb/example.vb#valueprop)]  
  
 El <xref:System.Lazy%601> clase proporciona un bloqueo, por lo que solo un subproceso tiene permiso para crear el `LargeObject` instancia. El ejemplo se muestra que los demás subprocesos todos obtienen la misma instancia.  
  
> [!NOTE]
>  Por simplificar, en este ejemplo se emplea una instancia global de <xref:System.Lazy%601> y todos los métodos son `static` (`Shared` en Visual Basic). No son requisitos para el uso de la inicialización diferida.  
  
 [!code-csharp[System.Lazy\`1.ctor#All](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1.ctor/cs/example.cs#all)]
 [!code-vb[System.Lazy\`1.ctor#All](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1.ctor/vb/example.vb#all)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/performance/lazy-initialization.md">Inicialización diferida</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Lazy (bool isThreadSafe);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(bool isThreadSafe) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Lazy`1.#ctor(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (isThreadSafe As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Lazy(bool isThreadSafe);" />
      <MemberSignature Language="F#" Value="new Lazy&lt;'T&gt; : bool -&gt; Lazy&lt;'T&gt;" Usage="new System.Lazy&lt;'T&gt; isThreadSafe" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="isThreadSafe" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="isThreadSafe"><see langword="true" /> para que varios subprocesos puedan usar esta instancia simultáneamente; <see langword="false" /> para que un solo subproceso pueda usar esta instancia cada vez.</param>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Lazy`1" />. Cuando se produce la inicialización diferida, se usan el constructor predeterminado del tipo de destino y el modo de inicialización especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El modo de seguridad para subprocesos de un <xref:System.Lazy%601> instancia que se inicializa con este constructor es <xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication?displayProperty=nameWithType> si `isThreadSafe` es `true`; en caso contrario, es el modo <xref:System.Threading.LazyThreadSafetyMode.None?displayProperty=nameWithType>. El modo de seguridad para subprocesos describe el comportamiento cuando varios subprocesos intentan inicializar el <xref:System.Lazy%601> instancia. Para especificar el <xref:System.Threading.LazyThreadSafetyMode.PublicationOnly?displayProperty=nameWithType> modo, use el <xref:System.Lazy%601.%23ctor%28System.Func%7B%600%7D%2CSystem.Threading.LazyThreadSafetyMode%29> o <xref:System.Lazy%601.%23ctor%28System.Threading.LazyThreadSafetyMode%29> constructor.  
  
 Un <xref:System.Lazy%601> instancia que se crea con este constructor no almacena en caché las excepciones. Para obtener más información, vea la clase <xref:System.Lazy%601> o la enumeración <xref:System.Threading.LazyThreadSafetyMode?displayProperty=nameWithType>.  
  
   
  
## Examples  
 El ejemplo siguiente muestra el uso de este constructor para crear a un inicializador diferido que no es seguro para subprocesos para escenarios donde se produce todo el acceso al objeto inicializado de forma diferida en el mismo subproceso. También se muestra el uso de la <xref:System.Lazy%601.%23ctor%28System.Threading.LazyThreadSafetyMode%29> constructor (especificar <xref:System.Threading.LazyThreadSafetyMode.None?displayProperty=nameWithType> para `mode`. Para cambiar a un constructor diferente, cambiar qué constructor está marcada como comentario.  
  
> [!NOTE]
>  Para el código que se muestra cómo utilizar este constructor en escenarios multiproceso (especificar `true` para `isThreadSafe`), vea el ejemplo de la <xref:System.Lazy%601.%23ctor> constructor.  
  
 El ejemplo define un `LargeObject` clase que se inicializará de forma diferida. En el `Main` método, en el ejemplo se crea un <xref:System.Lazy%601> instancia y, a continuación, en pausa. Cuando presiona el **ENTRAR** clave, el ejemplo accede a la <xref:System.Lazy%601.Value%2A> propiedad de la <xref:System.Lazy%601> instancia, lo que hace que la inicialización que se produzca. El constructor de la `LargeObject` clase muestra un mensaje de consola.  
  
> [!NOTE]
>  Por simplificar, en este ejemplo se emplea una instancia global de <xref:System.Lazy%601> y todos los métodos son `static` (`Shared` en Visual Basic). No son requisitos para el uso de la inicialización diferida.  
  
 [!code-csharp[System.Lazy\`1.ctorBool#All](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1.ctorbool/cs/example.cs#all)]
 [!code-vb[System.Lazy\`1.ctorBool#All](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1.ctorbool/vb/example.vb#all)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/performance/lazy-initialization.md">Inicialización diferida</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Lazy (Func&lt;T&gt; valueFactory);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Func`1&lt;!T&gt; valueFactory) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Lazy`1.#ctor(System.Func{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (valueFactory As Func(Of T))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Lazy(Func&lt;T&gt; ^ valueFactory);" />
      <MemberSignature Language="F#" Value="new Lazy&lt;'T&gt; : Func&lt;'T&gt; -&gt; Lazy&lt;'T&gt;" Usage="new System.Lazy&lt;'T&gt; valueFactory" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="valueFactory" Type="System.Func&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="valueFactory">Delegado que se invoca para generar el valor inicializado de forma diferida cuando sea necesario.</param>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Lazy`1" />. Cuando se produce la inicialización diferida, se usa la función de inicialización especificada.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Una instancia que se crea con este constructor se puede usar simultáneamente desde varios subprocesos.  
  
 El modo de seguridad para subprocesos de un <xref:System.Lazy%601> instancia que se inicializa con este constructor es <xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication?displayProperty=nameWithType>. El modo de seguridad para subprocesos describe el comportamiento cuando varios subprocesos intentan inicializar el <xref:System.Lazy%601> instancia.  
  
 Las excepciones producidas por `valueFactory` se almacenan en caché. Para obtener más información, vea la clase <xref:System.Lazy%601> o la enumeración <xref:System.Threading.LazyThreadSafetyMode?displayProperty=nameWithType>.  
  
   
  
## Examples  
 El ejemplo siguiente muestra el uso de este constructor para proporcionar la inicialización diferida con excepción de almacenamiento en caché. También se muestra el uso de la <xref:System.Lazy%601.%23ctor%28System.Func%7B%600%7D%2CSystem.Boolean%29> constructor (especificar `true` para `isThreadSafe`) y el <xref:System.Lazy%601.%23ctor%28System.Func%7B%600%7D%2CSystem.Threading.LazyThreadSafetyMode%29> constructor (especificar <xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication?displayProperty=nameWithType> para `mode`). Para cambiar a un constructor diferente, cambie los constructores que están comentados.  
  
 El ejemplo define una clase `LargeObject` que uno de varios subprocesos inicializará de forma diferida. Las tres secciones principales de código muestran la creación de inicializador, la inicialización real y el constructor de la `LargeObject` (clase), que muestra la excepción de almacenamiento en caché. Al principio del método `Main`, el ejemplo crea el inicializador diferido seguro para subprocesos para `LargeObject`:  
  
 [!code-csharp[System.Lazy\`1.ctorFunc#NewLazy](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1.ctorfunc/cs/example.cs#newlazy)]
 [!code-vb[System.Lazy\`1.ctorFunc#NewLazy](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1.ctorfunc/vb/example.vb#newlazy)]  
  
 En el ejemplo se crea y se inicia tres subprocesos. El `ThreadProc` método utilizado por todas las llamadas de tres subprocesos el <xref:System.Lazy%601.Value%2A> propiedad va a obtener el `LargeObject` instancia:  
  
 [!code-csharp[System.Lazy\`1.ctorFunc#ValueProp](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1.ctorfunc/cs/example.cs#valueprop)]
 [!code-vb[System.Lazy\`1.ctorFunc#ValueProp](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1.ctorfunc/vb/example.vb#valueprop)]  
  
 En el constructor de la `LargeObject` (clase), la tercera sección clave de código produce una excepción por primera vez un `LargeObject` instancia se crea, pero a partir de entonces permite la creación de instancias que se produzca:  
  
 [!code-csharp[System.Lazy\`1.ctorFunc#LargeCtor](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1.ctorfunc/cs/example.cs#largector)]
 [!code-vb[System.Lazy\`1.ctorFunc#LargeCtor](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1.ctorfunc/vb/example.vb#largector)]  
  
 Cuando se ejecuta el ejemplo, el primer subproceso que intenta crear una instancia de `LargeObject` se produce un error y la excepción se detecta. Es de esperar que el subproceso siguiente crearía correctamente una instancia, pero la <xref:System.Lazy%601> objeto ha almacenado en caché la excepción. Por este motivo, los tres subprocesos producen la excepción.  
  
> [!NOTE]
>  Por simplificar, en este ejemplo se emplea una instancia global de <xref:System.Lazy%601> y todos los métodos son `static` (`Shared` en Visual Basic). No son requisitos para el uso de la inicialización diferida.  
  
 [!code-csharp[System.Lazy\`1.ctorFunc#All](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1.ctorfunc/cs/example.cs#all)]
 [!code-vb[System.Lazy\`1.ctorFunc#All](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1.ctorfunc/vb/example.vb#all)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El valor de <paramref name="valueFactory" /> es <see langword="null" />.</exception>
        <related type="Article" href="~/docs/framework/performance/lazy-initialization.md">Inicialización diferida</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Lazy (System.Threading.LazyThreadSafetyMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(valuetype System.Threading.LazyThreadSafetyMode mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Lazy`1.#ctor(System.Threading.LazyThreadSafetyMode)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (mode As LazyThreadSafetyMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Lazy(System::Threading::LazyThreadSafetyMode mode);" />
      <MemberSignature Language="F#" Value="new Lazy&lt;'T&gt; : System.Threading.LazyThreadSafetyMode -&gt; Lazy&lt;'T&gt;" Usage="new System.Lazy&lt;'T&gt; mode" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="mode" Type="System.Threading.LazyThreadSafetyMode" />
      </Parameters>
      <Docs>
        <param name="mode">Uno de los valores de enumeración que especifica el modo de seguridad para subprocesos.</param>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Lazy`1" /> que usa el constructor predeterminado de <paramref name="T" /> y el modo de seguridad para subprocesos especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El modo de seguridad para subprocesos de un <xref:System.Lazy%601> instancia describe el comportamiento cuando varios subprocesos intentan inicializar el <xref:System.Lazy%601> instancia.  
  
 Un <xref:System.Lazy%601> instancia que se crea con este constructor no almacena en caché las excepciones. Para obtener más información, vea la clase <xref:System.Lazy%601> o la enumeración <xref:System.Threading.LazyThreadSafetyMode?displayProperty=nameWithType>.  
  
   
  
## Examples  
 El ejemplo siguiente muestra el uso de este constructor para crear a un inicializador diferido que permite que varios subprocesos que competir para crear un objeto de forma diferida. Podrían realizarse correctamente si varios subprocesos en la creación de instancias, pero todos los subprocesos usan la instancia que se crea en primer lugar.  
  
> [!NOTE]
>  Para obtener un ejemplo que muestra cómo utilizar este constructor en escenarios de un único subproceso (especificar <xref:System.Threading.LazyThreadSafetyMode.None?displayProperty=nameWithType> para `mode`), consulte el <xref:System.Lazy%601.%23ctor%28System.Boolean%29> constructor. Para obtener un ejemplo que muestra cómo utilizar este constructor para proporcionar el bloqueo en lugar de las condiciones de carrera en escenarios multiproceso (especificar <xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication?displayProperty=nameWithType> para `mode`), consulte el <xref:System.Lazy%601.%23ctor> constructor.  
  
 El ejemplo define un `LargeObject` clase que se inicializará de forma diferida por cualquiera de varios subprocesos. Las tres secciones principales de código muestran la creación de inicializador, la inicialización real y el constructor y el finalizador de la `LargeObject` clase. Al principio de la `Main` método, en el ejemplo se crea el <xref:System.Lazy%601> objeto que realiza la inicialización diferida de la `LargeObject`:  
  
 [!code-csharp[System.Lazy\`1.ctorLTSM#NewLazy](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1.ctorltsm/cs/example.cs#newlazy)]
 [!code-vb[System.Lazy\`1.ctorLTSM#NewLazy](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1.ctorltsm/vb/example.vb#newlazy)]  
  
 En el ejemplo se crea e inicia tres subprocesos se bloquean en un <xref:System.Threading.ManualResetEvent> de objeto, por lo que en el ejemplo se puede liberar los subprocesos a la vez. En el `ThreadProc` método utilizado por los tres subprocesos, llamar a la <xref:System.Lazy%601.Value%2A> propiedad crea el `LargeObject` instancia:  
  
 [!code-csharp[System.Lazy\`1.ctorLTSM#ValueProp](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1.ctorltsm/cs/example.cs#valueprop)]
 [!code-vb[System.Lazy\`1.ctorLTSM#ValueProp](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1.ctorltsm/vb/example.vb#valueprop)]  
  
 Dado que el constructor para la <xref:System.Lazy%601> instancia especificada <xref:System.Threading.LazyThreadSafetyMode.PublicationOnly?displayProperty=nameWithType>, los tres subprocesos tienen permiso para crear `LargeObject` instancias. El ejemplo muestra al mostrar mensajes de la consola en el constructor y en el finalizador de la `LargeObject` clase:  
  
 [!code-csharp[System.Lazy\`1.ctorLTSM#CtorFinalizer](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1.ctorltsm/cs/example.cs#ctorfinalizer)]
 [!code-vb[System.Lazy\`1.ctorLTSM#CtorFinalizer](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1.ctorltsm/vb/example.vb#ctorfinalizer)]  
  
 Sin embargo, la <xref:System.Lazy%601> objeto garantiza que solo una instancia se usa por todos los subprocesos. El resultado del ejemplo muestra que los tres subprocesos usan la misma instancia y también muestra que las otras dos instancias pueden ser reclamadas por la recolección.  
  
> [!NOTE]
>  Por simplificar, en este ejemplo se emplea una instancia global de <xref:System.Lazy%601> y todos los métodos son `static` (`Shared` en Visual Basic). No son requisitos para el uso de la inicialización diferida.  
  
 [!code-csharp[System.Lazy\`1.ctorLTSM#All](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1.ctorltsm/cs/example.cs#all)]
 [!code-vb[System.Lazy\`1.ctorLTSM#All](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1.ctorltsm/vb/example.vb#all)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="mode" /> contiene un valor no válido.</exception>
        <altmember cref="T:System.Threading.LazyThreadSafetyMode" />
        <related type="Article" href="~/docs/framework/performance/lazy-initialization.md">Inicialización diferida</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Lazy (T value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(!T value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Lazy`1.#ctor(`0)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (value As T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Lazy(T value);" />
      <MemberSignature Language="F#" Value="new Lazy&lt;'T&gt; : 'T -&gt; Lazy&lt;'T&gt;" Usage="new System.Lazy&lt;'T&gt; value" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="value" Type="T" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Lazy (Func&lt;T&gt; valueFactory, bool isThreadSafe);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Func`1&lt;!T&gt; valueFactory, bool isThreadSafe) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Lazy`1.#ctor(System.Func{`0},System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (valueFactory As Func(Of T), isThreadSafe As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Lazy(Func&lt;T&gt; ^ valueFactory, bool isThreadSafe);" />
      <MemberSignature Language="F#" Value="new Lazy&lt;'T&gt; : Func&lt;'T&gt; * bool -&gt; Lazy&lt;'T&gt;" Usage="new System.Lazy&lt;'T&gt; (valueFactory, isThreadSafe)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="valueFactory" Type="System.Func&lt;T&gt;" />
        <Parameter Name="isThreadSafe" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="valueFactory">Delegado que se invoca para generar el valor inicializado de forma diferida cuando sea necesario.</param>
        <param name="isThreadSafe"><see langword="true" /> para hacer que varios subprocesos puedan usar esta instancia simultáneamente; <see langword="false" /> para hacer que un solo subproceso pueda usar esta instancia de cada vez.</param>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Lazy`1" />. Cuando se produce la inicialización diferida, se usan la función de inicialización y el modo de inicialización especificados.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El modo de seguridad para subprocesos de un <xref:System.Lazy%601> instancia que se inicializa con este constructor es <xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication?displayProperty=nameWithType> si `isThreadSafe` es `true`; en caso contrario, es el modo <xref:System.Threading.LazyThreadSafetyMode.None?displayProperty=nameWithType>. El modo de seguridad para subprocesos describe el comportamiento cuando varios subprocesos intentan inicializar el <xref:System.Lazy%601> instancia.  
  
 Para especificar el <xref:System.Threading.LazyThreadSafetyMode.PublicationOnly?displayProperty=nameWithType> modo, use el <xref:System.Lazy%601.%23ctor%28System.Func%7B%600%7D%2CSystem.Threading.LazyThreadSafetyMode%29> o <xref:System.Lazy%601.%23ctor%28System.Threading.LazyThreadSafetyMode%29> constructor.  
  
 Las excepciones producidas por `valueFactory` se almacenan en caché. Para obtener más información, vea la clase <xref:System.Lazy%601> o la enumeración <xref:System.Threading.LazyThreadSafetyMode?displayProperty=nameWithType>.  
  
   
  
## Examples  
 El ejemplo siguiente muestra el uso de este constructor para proporcionar la inicialización diferida, con excepción de almacenamiento en caché, en un escenario con un único subproceso. También se muestra el uso de la <xref:System.Lazy%601.%23ctor%2A> constructor (especificar <xref:System.Threading.LazyThreadSafetyMode.None?displayProperty=nameWithType> para `mode`). Para cambiar a ese constructor, cambiar qué constructor está marcada como comentario.  
  
> [!NOTE]
>  Para el código que se muestra cómo utilizar este constructor en escenarios multiproceso (especificar `true` para `isThreadSafe`), vea el ejemplo de la <xref:System.Lazy%601.%23ctor%28System.Func%7B%600%7D%29> constructor.  
  
 El ejemplo define una clase `LargeObject` que uno de varios subprocesos inicializará de forma diferida. Las tres secciones principales de código muestran la creación de inicializador, la inicialización real y el constructor de la `LargeObject` (clase), que muestra la excepción de almacenamiento en caché. Al principio del método `Main`, el ejemplo crea el inicializador diferido seguro para subprocesos para `LargeObject`:  
  
 [!code-csharp[System.Lazy\`1.ctorFuncBool#NewLazy](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1.ctorfuncbool/cs/example.cs#newlazy)]
 [!code-vb[System.Lazy\`1.ctorFuncBool#NewLazy](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1.ctorfuncbool/vb/example.vb#newlazy)]  
  
 En la llamada al constructor, el `isThreadSafe` parámetro es `false`, por lo que <xref:System.Lazy%601> no es segura de subprocesos. Dado que no es seguro para subprocesos, el ejemplo llama a la <xref:System.Lazy%601.Value%2A> propiedad tres veces en el mismo subproceso:  
  
 [!code-csharp[System.Lazy\`1.ctorFuncBool#ValueProp](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1.ctorfuncbool/cs/example.cs#valueprop)]
 [!code-vb[System.Lazy\`1.ctorFuncBool#ValueProp](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1.ctorfuncbool/vb/example.vb#valueprop)]  
  
 En el constructor de la `LargeObject` (clase), la tercera sección clave de código produce una excepción por primera vez un `LargeObject` instancia se crea, pero a partir de entonces permite la creación de instancias que se produzca:  
  
 [!code-csharp[System.Lazy\`1.ctorFuncBool#LargeCtor](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1.ctorfuncbool/cs/example.cs#largector)]
 [!code-vb[System.Lazy\`1.ctorFuncBool#LargeCtor](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1.ctorfuncbool/vb/example.vb#largector)]  
  
 Cuando se ejecuta el ejemplo, el primer intento de crear una instancia de `LargeObject` se produce un error y la excepción se detecta. Es de esperar que el próximo intento se realizaría correctamente, pero la <xref:System.Lazy%601> objeto ha almacenado en caché la excepción. Por este motivo, todos los tres intentos de iniciar la excepción.  
  
> [!NOTE]
>  Por simplificar, en este ejemplo se emplea una instancia global de <xref:System.Lazy%601> y todos los métodos son `static` (`Shared` en Visual Basic). No son requisitos para el uso de la inicialización diferida.  
  
 [!code-csharp[System.Lazy\`1.ctorFuncBool#All](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1.ctorfuncbool/cs/example.cs#all)]
 [!code-vb[System.Lazy\`1.ctorFuncBool#All](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1.ctorfuncbool/vb/example.vb#all)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El valor de <paramref name="valueFactory" /> es <see langword="null" />.</exception>
        <related type="Article" href="~/docs/framework/performance/lazy-initialization.md">Inicialización diferida</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Lazy (Func&lt;T&gt; valueFactory, System.Threading.LazyThreadSafetyMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Func`1&lt;!T&gt; valueFactory, valuetype System.Threading.LazyThreadSafetyMode mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Lazy`1.#ctor(System.Func{`0},System.Threading.LazyThreadSafetyMode)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (valueFactory As Func(Of T), mode As LazyThreadSafetyMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Lazy(Func&lt;T&gt; ^ valueFactory, System::Threading::LazyThreadSafetyMode mode);" />
      <MemberSignature Language="F#" Value="new Lazy&lt;'T&gt; : Func&lt;'T&gt; * System.Threading.LazyThreadSafetyMode -&gt; Lazy&lt;'T&gt;" Usage="new System.Lazy&lt;'T&gt; (valueFactory, mode)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="valueFactory" Type="System.Func&lt;T&gt;" />
        <Parameter Name="mode" Type="System.Threading.LazyThreadSafetyMode" />
      </Parameters>
      <Docs>
        <param name="valueFactory">Delegado que se invoca para generar el valor inicializado de forma diferida cuando sea necesario.</param>
        <param name="mode">Uno de los valores de enumeración que especifica el modo de seguridad para subprocesos.</param>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Lazy`1" /> que usa la función de inicialización especificada y el modo de seguridad para subprocesos.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El modo de seguridad para subprocesos de un <xref:System.Lazy%601> instancia describe el comportamiento cuando varios subprocesos intentan inicializar el <xref:System.Lazy%601> instancia.  
  
 Las excepciones producidas por `valueFactory` se almacenan en caché, a menos que `mode` es <xref:System.Threading.LazyThreadSafetyMode.PublicationOnly?displayProperty=nameWithType>. Para obtener más información, vea la clase <xref:System.Lazy%601> o la enumeración <xref:System.Threading.LazyThreadSafetyMode?displayProperty=nameWithType>.  
  
   
  
## Examples  
 El ejemplo siguiente muestra el uso de este constructor para crear a un inicializador diferido que permite que varios subprocesos que competir para crear un objeto de forma diferida. Podrían realizarse correctamente si varios subprocesos en la creación de instancias, pero todos los subprocesos usan la instancia que se crea en primer lugar. Además, el ejemplo se muestra que las excepciones no son nunca almacenar en caché cuando se especifica <xref:System.Threading.LazyThreadSafetyMode.PublicationOnly?displayProperty=nameWithType>, incluso si la inicialización se realiza por una función en lugar de por el constructor predeterminado del tipo creado de forma diferida.  
  
> [!NOTE]
>  Para obtener un ejemplo que muestra cómo utilizar este constructor en escenarios de un único subproceso (especificar <xref:System.Threading.LazyThreadSafetyMode.None?displayProperty=nameWithType> para `mode`), consulte el <xref:System.Lazy%601.%23ctor%28System.Boolean%29> constructor. Para obtener un ejemplo que muestra cómo utilizar este constructor para proporcionar el bloqueo en lugar de las condiciones de carrera en escenarios multiproceso (especificar <xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication?displayProperty=nameWithType> para `mode`), consulte el <xref:System.Lazy%601.%23ctor> constructor.  
  
 El ejemplo define un `LargeObject` clase que se inicializará de forma diferida por cualquiera de varios subprocesos. La claves cuatro secciones de código muestran la creación de inicializador, la inicialización real, la función de inicialización y el constructor y el finalizador de la `LargeObject` clase. Al principio de la `Main` método, en el ejemplo se crea el <xref:System.Lazy%601> objeto que realiza la inicialización diferida de la `LargeObject`:  
  
 [!code-csharp[System.Lazy\`1.ctorFuncLTSM#NewLazy](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1.ctorfuncltsm/cs/example.cs#newlazy)]
 [!code-vb[System.Lazy\`1.ctorFuncLTSM#NewLazy](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1.ctorfuncltsm/vb/example.vb#newlazy)]  
  
 El inicializador diferido usa una función para realizar la inicialización. En este caso, se requiere una función porque no hay ningún constructor predeterminado para el `LargeObject` clase.  
  
 En el ejemplo se crea e inicia tres subprocesos se bloquean en un <xref:System.Threading.ManualResetEvent> de objeto, por lo que en el ejemplo se puede liberar los subprocesos a la vez. En el `ThreadProc` método utilizado por los tres subprocesos, llamar a la <xref:System.Lazy%601.Value%2A> propiedad crea el `LargeObject` instancia:  
  
 [!code-csharp[System.Lazy\`1.ctorFuncLTSM#ValueProp](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1.ctorfuncltsm/cs/example.cs#valueprop)]
 [!code-vb[System.Lazy\`1.ctorFuncLTSM#ValueProp](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1.ctorfuncltsm/vb/example.vb#valueprop)]  
  
 En la tercera sección clave de código, se llama a la función de inicialización diferida para crear el `LargeObject` instancia. La función produce una vez la primera excepción que se llama:  
  
 [!code-csharp[System.Lazy\`1.ctorFuncLTSM#FactoryFunc](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1.ctorfuncltsm/cs/example.cs#factoryfunc)]
 [!code-vb[System.Lazy\`1.ctorFuncLTSM#FactoryFunc](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1.ctorfuncltsm/vb/example.vb#factoryfunc)]  
  
 Con cualquier otro <xref:System.Threading.LazyThreadSafetyMode> establecer, una excepción no controlada en la función de inicialización almacenaría en caché. Sin embargo, <xref:System.Threading.LazyThreadSafetyMode.PublicationOnly?displayProperty=nameWithType> suprime la excepción de almacenamiento en caché. El resultado del ejemplo muestra que un intento posterior para inicializar el objeto se realiza correctamente.  
  
> [!NOTE]
>  Normalmente, aparece el mensaje de excepción después de los mensajes que indican que otros subprocesos han inicializado correctamente el objeto. Esto es debido a los retrasos introducidos por producir y detectar la excepción.  
  
 Dado que el constructor para la <xref:System.Lazy%601> instancia especificada <xref:System.Threading.LazyThreadSafetyMode.PublicationOnly?displayProperty=nameWithType>, los tres subprocesos tienen permiso para crear `LargeObject` instancias. El ejemplo muestra al mostrar mensajes de la consola en el constructor y en el finalizador de la `LargeObject` clase:  
  
 [!code-csharp[System.Lazy\`1.ctorFuncLTSM#CtorFinalizer](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1.ctorfuncltsm/cs/example.cs#ctorfinalizer)]
 [!code-vb[System.Lazy\`1.ctorFuncLTSM#CtorFinalizer](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1.ctorfuncltsm/vb/example.vb#ctorfinalizer)]  
  
 La <xref:System.Lazy%601> objeto garantiza que solo una instancia se usa por todos los subprocesos (salvo el subproceso donde la función de inicialización inicia una excepción). El resultado del ejemplo muestra esto.  
  
> [!NOTE]
>  Por simplificar, en este ejemplo se emplea una instancia global de <xref:System.Lazy%601> y todos los métodos son `static` (`Shared` en Visual Basic). No son requisitos para el uso de la inicialización diferida.  
  
 [!code-csharp[System.Lazy\`1.ctorFuncLTSM#All](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1.ctorfuncltsm/cs/example.cs#all)]
 [!code-vb[System.Lazy\`1.ctorFuncLTSM#All](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1.ctorfuncltsm/vb/example.vb#all)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="mode" /> contiene un valor no válido.</exception>
        <exception cref="T:System.ArgumentNullException">El valor de <paramref name="valueFactory" /> es <see langword="null" />.</exception>
        <related type="Article" href="~/docs/framework/performance/lazy-initialization.md">Inicialización diferida</related>
      </Docs>
    </Member>
    <Member MemberName="IsValueCreated">
      <MemberSignature Language="C#" Value="public bool IsValueCreated { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsValueCreated" />
      <MemberSignature Language="DocId" Value="P:System.Lazy`1.IsValueCreated" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsValueCreated As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsValueCreated { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsValueCreated : bool" Usage="System.Lazy&lt;'T&gt;.IsValueCreated" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene un valor que indica si se se creó un valor para esta instancia <see cref="T:System.Lazy`1" />.</summary>
        <value><see langword="true" /> si se creó un valor para esta instancia <see cref="T:System.Lazy`1" />; en caso contrario, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cuando se produce la inicialización diferida para un <xref:System.Lazy%601> instancia, se podrían producir en un valor que se creó o se producirá una excepción. Si una excepción es el comportamiento se produce, las posterior de la <xref:System.Lazy%601> instancia depende de si el almacenamiento en caché de excepción está en vigor. Si el <xref:System.Lazy%601> instancia se creó mediante un constructor que no especifica una función de inicialización, a continuación, el almacenamiento en caché de excepción no está en vigor. Un intento posterior para inicializar el <xref:System.Lazy%601> podría realizarse correctamente y después de la inicialización correcta del <xref:System.Lazy%601.IsValueCreated%2A> propiedad devuelve `true`. Si el <xref:System.Lazy%601> instancia se creó con una función de inicialización (especificado por el `valueFactory` parámetro de la <xref:System.Lazy%601> constructor), a continuación, el almacenamiento en caché de excepción se controla mediante el modo de seguridad para subprocesos.  
  
-   Si el modo es <xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication?displayProperty=nameWithType> o <xref:System.Threading.LazyThreadSafetyMode.None?displayProperty=nameWithType>, no hay ninguna segunda oportunidad para inicializar el <xref:System.Lazy%601> instancia. Si se produce una excepción y no se controla en la función de inicialización, esa excepción se almacena en caché y vuelve a iniciar en accesos posteriores de la <xref:System.Lazy%601.Value%2A?displayProperty=nameWithType> propiedad. No se crea ningún valor si se produce una excepción, así que en esos casos <xref:System.Lazy%601.IsValueCreated%2A> devuelve `false`.  
  
-   Si el modo es <xref:System.Threading.LazyThreadSafetyMode.PublicationOnly?displayProperty=nameWithType>, el primer subproceso que se ejecuta correctamente en la ejecución de la función de inicialización (o el constructor predeterminado) crea el valor para el <xref:System.Lazy%601> instancia. Si la función de inicialización inicia una excepción en un subproceso, otros subprocesos aún pueden intentar inicializar el <xref:System.Lazy%601> instancia. Hasta que se cree el valor, el <xref:System.Lazy%601.IsValueCreated%2A> propiedad devuelve `false`.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Threading.LazyThreadSafetyMode" />
        <related type="Article" href="~/docs/framework/performance/lazy-initialization.md">Inicialización diferida</related>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Lazy`1.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="lazy.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Crea y devuelve una representación de cadena de la propiedad <see cref="P:System.Lazy`1.Value" /> de esta instancia.</summary>
        <returns>Resultado de llamar al método <see cref="M:System.Object.ToString" /> en la propiedad <see cref="P:System.Lazy`1.Value" /> de esta instancia, si se ha creado el valor (es decir, si la propiedad <see cref="P:System.Lazy`1.IsValueCreated" /> devuelve <see langword="true" />). De lo contrario, una cadena que indica que el valor no se ha creado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Llamar a este método no hace que la inicialización.  
  
 El <xref:System.Lazy%601.Value%2A?displayProperty=nameWithType> propiedad puede ser `null` después de la inicialización diferida si el método de generador que se ha especificado para el `valueFactory` parámetro de la <xref:System.Lazy%601.%23ctor%28System.Func%7B%600%7D%29>, <xref:System.Lazy%601.%23ctor%28System.Func%7B%600%7D%2CSystem.Threading.LazyThreadSafetyMode%29>, o <xref:System.Lazy%601.%23ctor%28System.Func%7B%600%7D%2CSystem.Boolean%29> constructor devuelve `null`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NullReferenceException">La propiedad <see cref="P:System.Lazy`1.Value" /> es <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Value">
      <MemberSignature Language="C#" Value="public T Value { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance !T Value" />
      <MemberSignature Language="DocId" Value="P:System.Lazy`1.Value" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Value As T" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property T Value { T get(); };" />
      <MemberSignature Language="F#" Value="member this.Value : 'T" Usage="System.Lazy&lt;'T&gt;.Value" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.DebuggerBrowsable(System.Diagnostics.DebuggerBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene el valor inicializado de forma diferida de la instancia actual de <see cref="T:System.Lazy`1" />.</summary>
        <value>Valor inicializado de forma diferida de la instancia actual de <see cref="T:System.Lazy`1" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si el <xref:System.Lazy%601.IsValueCreated%2A?displayProperty=nameWithType> propiedad es `false`, al acceder a la <xref:System.Lazy%601.Value%2A> propiedad fuerza la inicialización.  
  
 Además de las excepciones que aparecen, el <xref:System.Lazy%601.Value%2A> propiedad puede producir cualquier excepción no controlada producida por el método de generador que se pasó a la `valueFactory` parámetro de la <xref:System.Lazy%601.%23ctor%28System.Func%7B%600%7D%29>, <xref:System.Lazy%601.%23ctor%28System.Func%7B%600%7D%2CSystem.Threading.LazyThreadSafetyMode%29>, o <xref:System.Lazy%601.%23ctor%28System.Func%7B%600%7D%2CSystem.Boolean%29> constructor.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.MemberAccessException">La instancia de <see cref="T:System.Lazy`1" /> está inicializada para usar el constructor predeterminado del tipo que se inicializa de forma diferida y faltan permisos para tener acceso al constructor.</exception>
        <exception cref="T:System.MissingMemberException">La instancia de <see cref="T:System.Lazy`1" /> está inicializada para usar el constructor predeterminado del tipo que se inicializa de forma diferida y este tipo no tiene un constructor público, sin parámetros.</exception>
        <exception cref="T:System.InvalidOperationException">La función de inicialización intenta obtener acceso a <see cref="P:System.Lazy`1.Value" /> en esta instancia.</exception>
        <related type="Article" href="~/docs/framework/performance/lazy-initialization.md">Inicialización diferida</related>
      </Docs>
    </Member>
  </Members>
</Type>