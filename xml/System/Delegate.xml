<Type Name="Delegate" FullName="System.Delegate">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="3f0536eac77f3171e3a7eeb74486cfcf863ec3d8" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="es-ES" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
  </Metadata>
  <TypeSignature Language="C#" Value="public abstract class Delegate : ICloneable, System.Runtime.Serialization.ISerializable" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi abstract serializable beforefieldinit Delegate extends System.Object implements class System.ICloneable, class System.Runtime.Serialization.ISerializable" />
  <TypeSignature Language="DocId" Value="T:System.Delegate" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class Delegate&#xA;Implements ICloneable, ISerializable" />
  <TypeSignature Language="C++ CLI" Value="public ref class Delegate abstract : ICloneable, System::Runtime::Serialization::ISerializable" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.ICloneable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Runtime.Serialization.ISerializable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ClassInterface(System.Runtime.InteropServices.ClassInterfaceType.AutoDual)</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>
      <span data-ttu-id="28044-101">Representa un delegado, que es una estructura de datos que hace referencia a un método estático o a una instancia de clase y a un método de instancia de dicha clase.</span>
      <span class="sxs-lookup">
        <span data-stu-id="28044-101">Represents a delegate, which is a data structure that refers to a static method or to a class instance and an instance method of that class.</span>
      </span>
    </summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="28044-102">La <xref:System.Delegate> clase es la clase base para tipos de delegado.</span><span class="sxs-lookup"><span data-stu-id="28044-102">The <xref:System.Delegate> class is the base class for delegate types.</span></span> <span data-ttu-id="28044-103">Sin embargo, solamente el sistema y los compiladores pueden derivar explícitamente de la <xref:System.Delegate> clase o desde la <xref:System.MulticastDelegate> clase.</span><span class="sxs-lookup"><span data-stu-id="28044-103">However, only the system and compilers can derive explicitly from the <xref:System.Delegate> class or from the <xref:System.MulticastDelegate> class.</span></span> <span data-ttu-id="28044-104">También no es permitida para derivar un nuevo tipo de un tipo de delegado.</span><span class="sxs-lookup"><span data-stu-id="28044-104">It is also not permissible to derive a new type from a delegate type.</span></span> <span data-ttu-id="28044-105">La <xref:System.Delegate> clase no se considera un tipo de delegado; es una clase que se utiliza para derivar tipos de delegado.</span><span class="sxs-lookup"><span data-stu-id="28044-105">The <xref:System.Delegate> class is not considered a delegate type; it is a class used to derive delegate types.</span></span>  
  
 <span data-ttu-id="28044-106">Implementa la mayoría de los lenguajes un `delegate` palabra clave y los compiladores de esos lenguajes son puede derivar desde la <xref:System.MulticastDelegate> clase; por lo tanto, los usuarios deben utilizar el `delegate` palabra clave proporcionado por el lenguaje.</span><span class="sxs-lookup"><span data-stu-id="28044-106">Most languages implement a `delegate` keyword, and compilers for those languages are able to derive from the <xref:System.MulticastDelegate> class; therefore, users should use the `delegate` keyword provided by the language.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="28044-107">Common language runtime proporciona un `Invoke` método para cada tipo de delegado, con la misma firma que el delegado.</span><span class="sxs-lookup"><span data-stu-id="28044-107">The common language runtime provides an `Invoke` method for each delegate type, with the same signature as the delegate.</span></span> <span data-ttu-id="28044-108">No es necesario llamar explícitamente a este método de C#, Visual Basic o Visual C++, porque los compiladores llaman automáticamente.</span><span class="sxs-lookup"><span data-stu-id="28044-108">You do not have to call this method explicitly from C#, Visual Basic, or Visual C++, because the compilers call it automatically.</span></span> <span data-ttu-id="28044-109">El `Invoke` método resulta útil en [reflexión](~/docs/framework/reflection-and-codedom/reflection.md) cuando desee buscar la firma del tipo de delegado.</span><span class="sxs-lookup"><span data-stu-id="28044-109">The `Invoke` method is useful in [reflection](~/docs/framework/reflection-and-codedom/reflection.md) when you want to find the signature of the delegate type.</span></span>  
  
 <span data-ttu-id="28044-110">Common language runtime proporciona cada tipo de delegado con `BeginInvoke` y `EndInvoke` métodos para habilitar la llamada asincrónica del delegado.</span><span class="sxs-lookup"><span data-stu-id="28044-110">The common language runtime provides each delegate type with `BeginInvoke` and `EndInvoke` methods, to enable asynchronous invocation of the delegate.</span></span> <span data-ttu-id="28044-111">Para obtener más información acerca de estos métodos, consulte [al llamar a métodos sincrónicos asincrónicamente](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md).</span><span class="sxs-lookup"><span data-stu-id="28044-111">For more information about these methods, see [Calling Synchronous Methods Asynchronously](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md).</span></span>  
  
 <span data-ttu-id="28044-112">La declaración de un tipo de delegado establece un contrato que especifica la firma de uno o varios métodos.</span><span class="sxs-lookup"><span data-stu-id="28044-112">The declaration of a delegate type establishes a contract that specifies the signature of one or more methods.</span></span> <span data-ttu-id="28044-113">Un delegado es una instancia de un tipo de delegado que incluya referencias a:</span><span class="sxs-lookup"><span data-stu-id="28044-113">A delegate is an instance of a delegate type that has references to:</span></span>  
  
-   <span data-ttu-id="28044-114">Un método de instancia de un tipo y un objeto de destino asignable a ese tipo.</span><span class="sxs-lookup"><span data-stu-id="28044-114">An instance method of a type and a target object assignable to that type.</span></span>  
  
-   <span data-ttu-id="28044-115">Un método de instancia de un tipo, con el texto oculto `this` parámetro expuesto en la lista de parámetros formales.</span><span class="sxs-lookup"><span data-stu-id="28044-115">An instance method of a type, with the hidden `this` parameter exposed in the formal parameter list.</span></span> <span data-ttu-id="28044-116">El delegado se dice que un delegado de instancia abierto.</span><span class="sxs-lookup"><span data-stu-id="28044-116">The delegate is said to be an open instance delegate.</span></span>  
  
-   <span data-ttu-id="28044-117">Un método estático.</span><span class="sxs-lookup"><span data-stu-id="28044-117">A static method.</span></span>  
  
-   <span data-ttu-id="28044-118">Un método estático y un objeto de destino asignable al primer parámetro del método.</span><span class="sxs-lookup"><span data-stu-id="28044-118">A static method and a target object assignable to the first parameter of the method.</span></span> <span data-ttu-id="28044-119">Se dice que el delegado se cierra en su primer argumento.</span><span class="sxs-lookup"><span data-stu-id="28044-119">The delegate is said to be closed over its first argument.</span></span>  
  
 <span data-ttu-id="28044-120">Para obtener más información sobre el enlace a delegados, vea la <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Object%2CSystem.Reflection.MethodInfo%2CSystem.Boolean%29> sobrecarga del método.</span><span class="sxs-lookup"><span data-stu-id="28044-120">For more information on delegate binding, see the <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Object%2CSystem.Reflection.MethodInfo%2CSystem.Boolean%29> method overload.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="28044-121">En las versiones 1.0 y 1.1 de .NET Framework, un delegado puede representar un método sólo si la firma del método coincide exactamente con la firma especificada por el tipo de delegado.</span><span class="sxs-lookup"><span data-stu-id="28044-121">In the .NET Framework versions 1.0 and 1.1, a delegate can represent a method only if the signature of the method exactly matches the signature specified by the delegate type.</span></span> <span data-ttu-id="28044-122">Por lo tanto, se admiten sólo las viñetas primeros y terceros en la lista anterior, y la primera viñeta requiere a una coincidencia exacta de tipos.</span><span class="sxs-lookup"><span data-stu-id="28044-122">Thus, only the first and third bullets in the preceding list are supported, and the first bullet requires an exact type match.</span></span>  
  
 <span data-ttu-id="28044-123">Cuando un delegado representa un método de instancia cerrado en su primer argumento (el caso más común), el delegado almacena una referencia al punto de entrada del método y una referencia a un objeto, denominado el destino, que es de un tipo asignable al tipo que define el método.</span><span class="sxs-lookup"><span data-stu-id="28044-123">When a delegate represents an instance method closed over its first argument (the most common case), the delegate stores a reference to the method's entry point and a reference to an object, called the target, which is of a type assignable to the type that defined the method.</span></span> <span data-ttu-id="28044-124">Cuando un delegado representa un método de instancia abierto, almacena una referencia al punto de entrada del método.</span><span class="sxs-lookup"><span data-stu-id="28044-124">When a delegate represents an open instance method, it stores a reference to the method's entry point.</span></span> <span data-ttu-id="28044-125">La firma del delegado debe incluir el texto oculto `this` parámetro en su lista de parámetros formales; en este caso, el delegado no tiene una referencia a un objeto de destino y un objeto de destino debe proporcionarse cuando se invoca el delegado.</span><span class="sxs-lookup"><span data-stu-id="28044-125">The delegate signature must include the hidden `this` parameter in its formal parameter list; in this case, the delegate does not have a reference to a target object, and a target object must be supplied when the delegate is invoked.</span></span>  
  
 <span data-ttu-id="28044-126">Cuando un delegado representa un método estático, el delegado almacena una referencia al punto de entrada del método.</span><span class="sxs-lookup"><span data-stu-id="28044-126">When a delegate represents a static method, the delegate stores a reference to the method's entry point.</span></span> <span data-ttu-id="28044-127">Cuando un delegado representa un método estático cerrado en su primer argumento, el delegado almacena una referencia al punto de entrada del método y una referencia a un objeto de destino asignable al tipo del primer argumento del método.</span><span class="sxs-lookup"><span data-stu-id="28044-127">When a delegate represents a static method closed over its first argument, the delegate stores a reference to the method's entry point and a reference to a target object assignable to the type of the method's first argument.</span></span> <span data-ttu-id="28044-128">Cuando se invoca el delegado, el primer argumento del método estático recibe el objeto de destino.</span><span class="sxs-lookup"><span data-stu-id="28044-128">When the delegate is invoked, the first argument of the static method receives the target object.</span></span>  
  
 <span data-ttu-id="28044-129">La lista de invocaciones de un delegado es un conjunto ordenado de delegados donde cada elemento de la lista invoca exactamente a uno de los métodos representados por el delegado.</span><span class="sxs-lookup"><span data-stu-id="28044-129">The invocation list of a delegate is an ordered set of delegates in which each element of the list invokes exactly one of the methods represented by the delegate.</span></span> <span data-ttu-id="28044-130">Una lista de invocaciones puede contener métodos duplicados.</span><span class="sxs-lookup"><span data-stu-id="28044-130">An invocation list can contain duplicate methods.</span></span> <span data-ttu-id="28044-131">Durante una invocación, los métodos se invocan en el orden en que aparecen en la lista de invocación.</span><span class="sxs-lookup"><span data-stu-id="28044-131">During an invocation, methods are invoked in the order in which they appear in the invocation list.</span></span> <span data-ttu-id="28044-132">Un delegado intenta invocar todos los métodos de su lista de invocación; duplicados se invocan una vez por cada vez que aparecen en la lista de invocación.</span><span class="sxs-lookup"><span data-stu-id="28044-132">A delegate attempts to invoke every method in its invocation list; duplicates are invoked once for each time they appear in the invocation list.</span></span> <span data-ttu-id="28044-133">Los delegados son inmutables; una vez creado, no cambia la lista de invocaciones de un delegado.</span><span class="sxs-lookup"><span data-stu-id="28044-133">Delegates are immutable; once created, the invocation list of a delegate does not change.</span></span>  
  
 <span data-ttu-id="28044-134">Los delegados se conocen como multidifusión o combinables, porque un delegado puede invocar uno o varios métodos y puede utilizarse en operaciones de combinación.</span><span class="sxs-lookup"><span data-stu-id="28044-134">Delegates are referred to as multicast, or combinable, because a delegate can invoke one or more methods and can be used in combining operations.</span></span>  
  
 <span data-ttu-id="28044-135">Combinar las operaciones, como <xref:System.Delegate.Combine%2A> y <xref:System.Delegate.Remove%2A>, no se modifican los delegados existentes.</span><span class="sxs-lookup"><span data-stu-id="28044-135">Combining operations, such as <xref:System.Delegate.Combine%2A> and <xref:System.Delegate.Remove%2A>, do not alter existing delegates.</span></span> <span data-ttu-id="28044-136">En su lugar, este tipo de operación devuelve un nuevo delegado que contiene los resultados de la operación, un delegado sin modificar, o `null`.</span><span class="sxs-lookup"><span data-stu-id="28044-136">Instead, such an operation returns a new delegate that contains the results of the operation, an unchanged delegate, or `null`.</span></span> <span data-ttu-id="28044-137">Una operación de combinación devuelve `null` cuando el resultado de la operación es un delegado que no hace referencia al menos un método.</span><span class="sxs-lookup"><span data-stu-id="28044-137">A combining operation returns `null` when the result of the operation is a delegate that does not reference at least one method.</span></span> <span data-ttu-id="28044-138">Una operación de combinación devuelve a un delegado sin modificar cuando la operación solicitada no tiene ningún efecto.</span><span class="sxs-lookup"><span data-stu-id="28044-138">A combining operation returns an unchanged delegate when the requested operation has no effect.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="28044-139">Administrado idiomas utilizan el <xref:System.Delegate.Combine%2A> y <xref:System.Delegate.Remove%2A> métodos para implementar operaciones de delegado.</span><span class="sxs-lookup"><span data-stu-id="28044-139">Managed languages use the <xref:System.Delegate.Combine%2A> and <xref:System.Delegate.Remove%2A> methods to implement delegate operations.</span></span> <span data-ttu-id="28044-140">Algunos ejemplos son la `AddHandler` y `RemoveHandler` instrucciones en Visual Basic y los operadores += y -= en tipos de delegados en C#.</span><span class="sxs-lookup"><span data-stu-id="28044-140">Examples include the `AddHandler` and `RemoveHandler` statements in Visual Basic and the += and -= operators on delegate types in C#.</span></span>  
  
 <span data-ttu-id="28044-141">A partir de la [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], tipos de delegado genérico pueden tener parámetros de tipo variante.</span><span class="sxs-lookup"><span data-stu-id="28044-141">Starting with the [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], generic delegate types can have variant type parameters.</span></span> <span data-ttu-id="28044-142">Parámetros de tipo contravariante se pueden usar como tipos de parámetro del delegado y un parámetro de tipo covariante se puede utilizar como el tipo de valor devuelto.</span><span class="sxs-lookup"><span data-stu-id="28044-142">Contravariant type parameters can be used as parameter types of the delegate, and a covariant type parameter can be used as the return type.</span></span> <span data-ttu-id="28044-143">Esta característica permite delegado genérico que los tipos que se construyen a partir de la misma definición de tipo genérico para ser compatible con la asignación si sus argumentos de tipo son tipos de referencia con una relación de herencia, tal como se describe en [covarianza y contravarianza](~/docs/standard/generics/covariance-and-contravariance.md).</span><span class="sxs-lookup"><span data-stu-id="28044-143">This feature allows generic delegate types that are constructed from the same generic type definition to be assignment-compatible if their type arguments are reference types with an inheritance relationship, as explained in [Covariance and Contravariance](~/docs/standard/generics/covariance-and-contravariance.md).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="28044-144">Delegados genéricos que son compatibles con la asignación debido a la variación no son necesariamente combinables.</span><span class="sxs-lookup"><span data-stu-id="28044-144">Generic delegates that are assignment-compatible because of variance are not necessarily combinable.</span></span> <span data-ttu-id="28044-145">Para ser combinables, los tipos deben coincidir exactamente.</span><span class="sxs-lookup"><span data-stu-id="28044-145">To be combinable, the types must match exactly.</span></span> <span data-ttu-id="28044-146">Por ejemplo, supongamos que una clase denominada `Derived` se deriva de una clase denominada `Base`.</span><span class="sxs-lookup"><span data-stu-id="28044-146">For example, suppose that a class named `Derived` is derived from a class named `Base`.</span></span> <span data-ttu-id="28044-147">Un delegado del tipo `Action<Base>` (`Action(Of Base)` en Visual Basic) puede asignarse a una variable de tipo `Action<Derived>`, pero no se puede combinar los dos delegados porque los tipos no coinciden exactamente.</span><span class="sxs-lookup"><span data-stu-id="28044-147">A delegate of type `Action<Base>` (`Action(Of Base)` in Visual Basic) can be assigned to a variable of type `Action<Derived>`, but the two delegates cannot be combined because the types do not match exactly.</span></span>  
  
 <span data-ttu-id="28044-148">Si un método invocado produce una excepción, el método deja de ejecutarse, la excepción se pasa de vuelta al llamador del delegado y no se invocan los métodos restantes en la lista de invocación.</span><span class="sxs-lookup"><span data-stu-id="28044-148">If an invoked method throws an exception, the method stops executing, the exception is passed back to the caller of the delegate, and remaining methods in the invocation list are not invoked.</span></span> <span data-ttu-id="28044-149">Detectar la excepción en el llamador no modifica este comportamiento.</span><span class="sxs-lookup"><span data-stu-id="28044-149">Catching the exception in the caller does not alter this behavior.</span></span>  
  
 <span data-ttu-id="28044-150">Cuando la firma de los métodos invocados por un delegado incluye un valor devuelto, el delegado devuelve el valor devuelto del último elemento en la lista de invocación.</span><span class="sxs-lookup"><span data-stu-id="28044-150">When the signature of the methods invoked by a delegate includes a return value, the delegate returns the return value of the last element in the invocation list.</span></span> <span data-ttu-id="28044-151">Cuando la firma incluye un parámetro que se pasa por referencia, el valor final del parámetro es el resultado de todos los métodos de la lista de invocaciones ejecute secuencialmente y actualice el valor del parámetro.</span><span class="sxs-lookup"><span data-stu-id="28044-151">When the signature includes a parameter that is passed by reference, the final value of the parameter is the result of every method in the invocation list executing sequentially and updating the parameter's value.</span></span>  
  
 <span data-ttu-id="28044-152">El equivalente más cercano de un delegado en C o C++ es un puntero a función.</span><span class="sxs-lookup"><span data-stu-id="28044-152">The closest equivalent of a delegate in C or C++ is a function pointer.</span></span> <span data-ttu-id="28044-153">Un delegado puede representar un método estático o un método de instancia.</span><span class="sxs-lookup"><span data-stu-id="28044-153">A delegate can represent a static method or an instance method.</span></span> <span data-ttu-id="28044-154">Cuando el delegado representa un método de instancia, el delegado almacena una referencia al punto de entrada del método pero una referencia a la instancia de clase.</span><span class="sxs-lookup"><span data-stu-id="28044-154">When the delegate represents an instance method, the delegate stores not only a reference to the method's entry point, but also a reference to the class instance.</span></span> <span data-ttu-id="28044-155">A diferencia de los punteros de función, los delegados están orientados a objetos y la seguridad de tipos.</span><span class="sxs-lookup"><span data-stu-id="28044-155">Unlike function pointers, delegates are object oriented and type safe.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="28044-156">En el ejemplo siguiente se muestra cómo definir un delegado denominado `myMethodDelegate`.</span><span class="sxs-lookup"><span data-stu-id="28044-156">The following example shows how to define a delegate named `myMethodDelegate`.</span></span> <span data-ttu-id="28044-157">Se crean instancias de este delegado para un método de instancia y un método estático de anidamiento `mySampleClass` clase.</span><span class="sxs-lookup"><span data-stu-id="28044-157">Instances of this delegate are created for an instance method and a static method of the nested `mySampleClass` class.</span></span> <span data-ttu-id="28044-158">El delegado para el método de instancia requiere una instancia de `mySampleClass`.</span><span class="sxs-lookup"><span data-stu-id="28044-158">The delegate for the instance method requires an instance of `mySampleClass`.</span></span> <span data-ttu-id="28044-159">El `mySampleClass` instancia se guarda en una variable denominada `mySC`.</span><span class="sxs-lookup"><span data-stu-id="28044-159">The `mySampleClass` instance is saved in a variable named `mySC`.</span></span>  
  
 [!code-cpp[Classic Delegate Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Delegate Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Delegate Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Delegate Example/CS/source.cs#1)]
 [!code-vb[Classic Delegate Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Delegate Example/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.MulticastDelegate" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="28044-160">Inicializa un nuevo delegado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="28044-160">Initializes a new delegate.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Delegate (object target, string method);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(object target, string method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.#ctor(System.Object,System.String)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New (target As Object, method As String)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; Delegate(System::Object ^ target, System::String ^ method);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="target" Type="System.Object" />
        <Parameter Name="method" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="target">
          <span data-ttu-id="28044-161">Instancia de clase donde el delegado invoca a <c>method</c>.</span>
          <span class="sxs-lookup">
            <span data-stu-id="28044-161">The class instance on which the delegate invokes <c>method</c>.</span>
          </span>
        </param>
        <param name="method">
          <span data-ttu-id="28044-162">Nombre del método de instancia que representa el delegado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="28044-162">The name of the instance method that the delegate represents.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="28044-163">Inicializa un delegado que invoca al método de instancia especificado en la instancia de clase especificada.</span>
          <span class="sxs-lookup">
            <span data-stu-id="28044-163">Initializes a delegate that invokes the specified instance method on the specified class instance.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="28044-164">Este constructor no se puede usar en código de aplicación.</span><span class="sxs-lookup"><span data-stu-id="28044-164">This constructor cannot be used in application code.</span></span> <span data-ttu-id="28044-165">Para crear un delegado especificando el nombre de un método de instancia, use una sobrecarga de la <xref:System.Delegate.CreateDelegate%2A> método que especifica un nombre de método y un objeto de destino.</span><span class="sxs-lookup"><span data-stu-id="28044-165">To create a delegate by specifying the name of an instance method, use an overload of the <xref:System.Delegate.CreateDelegate%2A> method that specifies a method name and a target object.</span></span> <span data-ttu-id="28044-166">Por ejemplo, el <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Object%2CSystem.String%29> sobrecarga del método crea un delegado para un método de instancia con un nombre especificado.</span><span class="sxs-lookup"><span data-stu-id="28044-166">For example, the <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Object%2CSystem.String%29> method overload creates a delegate for an instance method with a specified name.</span></span>  
  
 <span data-ttu-id="28044-167">Este constructor sólo crea a delegados para la instancia métodos.</span><span class="sxs-lookup"><span data-stu-id="28044-167">This constructor creates delegates for instance methods only.</span></span> <span data-ttu-id="28044-168">Un método de instancia es un método que está asociado a una instancia de una clase; un método estático es un método que está asociado a la propia clase.</span><span class="sxs-lookup"><span data-stu-id="28044-168">An instance method is a method that is associated with an instance of a class; a static method is a method that is associated with the class itself.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="28044-169">
            <paramref name="target" /> es <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="28044-169">
              <paramref name="target" /> is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="28044-170">O bien</span>
          <span class="sxs-lookup">
            <span data-stu-id="28044-170">-or-</span>
          </span>
          <span data-ttu-id="28044-171">
            <paramref name="method" /> es <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="28044-171">
              <paramref name="method" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="28044-172">Se produjo un error al enlazar al método de destino.</span>
          <span class="sxs-lookup">
            <span data-stu-id="28044-172">There was an error binding to the target method.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">
          <span data-ttu-id="28044-173">Cuando se invoca en tiempo de ejecución a través de mecanismos como <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="28044-173">when invoked late-bound through mechanisms such as <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span>
          </span>
          <span data-ttu-id="28044-174">Enumeración asociada: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span>
          <span class="sxs-lookup">
            <span data-stu-id="28044-174">Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span>
          </span>
        </permission>
        <altmember cref="T:System.Object" />
        <altmember cref="T:System.String" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Delegate (Type target, string method);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(class System.Type target, string method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.#ctor(System.Type,System.String)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New (target As Type, method As String)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; Delegate(Type ^ target, System::String ^ method);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="target" Type="System.Type" />
        <Parameter Name="method" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="target">
          <span data-ttu-id="28044-175">
            <see cref="T:System.Type" /> que representa la clase que define <c>method</c>.</span>
          <span class="sxs-lookup">
            <span data-stu-id="28044-175">The <see cref="T:System.Type" /> representing the class that defines <c>method</c>.</span>
          </span>
        </param>
        <param name="method">
          <span data-ttu-id="28044-176">Nombre del método estático que representa el delegado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="28044-176">The name of the static method that the delegate represents.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="28044-177">Inicializa un delegado que invoca al método estático especificado a partir de la clase especificada.</span>
          <span class="sxs-lookup">
            <span data-stu-id="28044-177">Initializes a delegate that invokes the specified static method from the specified class.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="28044-178">Este constructor no se puede usar en código de aplicación.</span><span class="sxs-lookup"><span data-stu-id="28044-178">This constructor cannot be used in application code.</span></span> <span data-ttu-id="28044-179">Para crear un delegado especificando el nombre de un método estático, use una sobrecarga de la <xref:System.Delegate.CreateDelegate%2A> método que especifica un nombre de método, pero no especifica un objeto de destino.</span><span class="sxs-lookup"><span data-stu-id="28044-179">To create a delegate by specifying the name of a static method, use an overload of the <xref:System.Delegate.CreateDelegate%2A> method that specifies a method name but does not specify a target object.</span></span> <span data-ttu-id="28044-180">Por ejemplo, el <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Type%2CSystem.String%29> sobrecarga del método crea un delegado para un método estático con el nombre especificado.</span><span class="sxs-lookup"><span data-stu-id="28044-180">For example, the <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Type%2CSystem.String%29> method overload creates a static delegate for a method with a specified name.</span></span>  
  
 <span data-ttu-id="28044-181">Este constructor crea a delegados para los métodos estáticos solo.</span><span class="sxs-lookup"><span data-stu-id="28044-181">This constructor creates delegates for static methods only.</span></span> <span data-ttu-id="28044-182">Un método de instancia es un método que está asociado a una instancia de una clase; un método estático es un método que está asociado a la propia clase.</span><span class="sxs-lookup"><span data-stu-id="28044-182">An instance method is a method that is associated with an instance of a class; a static method is a method that is associated with the class itself.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="28044-183">
            <paramref name="target" /> es <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="28044-183">
              <paramref name="target" /> is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="28044-184">O bien</span>
          <span class="sxs-lookup">
            <span data-stu-id="28044-184">-or-</span>
          </span>
          <span data-ttu-id="28044-185">
            <paramref name="method" /> es <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="28044-185">
              <paramref name="method" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="28044-186">
            <paramref name="target" /> no es un <see langword="RuntimeType" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="28044-186">
              <paramref name="target" /> is not a <see langword="RuntimeType" />.</span>
          </span>
          <span data-ttu-id="28044-187">Vea [Tipos de reflexión en tiempo de ejecución](http://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858).</span>
          <span class="sxs-lookup">
            <span data-stu-id="28044-187">See [Runtime Types in Reflection](http://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858).</span>
          </span>
          <span data-ttu-id="28044-188">O bien</span>
          <span class="sxs-lookup">
            <span data-stu-id="28044-188">-or-</span>
          </span>
          <span data-ttu-id="28044-189">
            <paramref name="target" /> representa un tipo genérico abierto.</span>
          <span class="sxs-lookup">
            <span data-stu-id="28044-189">
              <paramref name="target" /> represents an open generic type.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">
          <span data-ttu-id="28044-190">Cuando se invoca en tiempo de ejecución a través de mecanismos como <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="28044-190">when invoked late-bound through mechanisms such as <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span>
          </span>
          <span data-ttu-id="28044-191">Enumeración asociada: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span>
          <span class="sxs-lookup">
            <span data-stu-id="28044-191">Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span>
          </span>
        </permission>
        <altmember cref="T:System.Type" />
        <altmember cref="T:System.String" />
      </Docs>
    </Member>
    <Member MemberName="Clone">
      <MemberSignature Language="C#" Value="public virtual object Clone ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object Clone() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.Clone" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Clone () As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ Clone();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ICloneable.Clone</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="28044-192">Crea una copia superficial del delegado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="28044-192">Creates a shallow copy of the delegate.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="28044-193">Copia superficial del delegado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="28044-193">A shallow copy of the delegate.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="28044-194">El clon tiene el mismo <xref:System.Type>, destino, método y lista de invocaciones que el delegado original.</span><span class="sxs-lookup"><span data-stu-id="28044-194">The clone has the same <xref:System.Type>, target, method, and invocation list as the original delegate.</span></span>  
  
 <span data-ttu-id="28044-195">Una copia superficial crea una nueva instancia del mismo tipo que el objeto original y, a continuación, copia los campos no estáticos del objeto original.</span><span class="sxs-lookup"><span data-stu-id="28044-195">A shallow copy creates a new instance of the same type as the original object, and then copies the nonstatic fields of the original object.</span></span> <span data-ttu-id="28044-196">Si el campo es un tipo de valor, se realiza una copia bit a bit del campo.</span><span class="sxs-lookup"><span data-stu-id="28044-196">If the field is a value type, a bit-by-bit copy of the field is performed.</span></span> <span data-ttu-id="28044-197">Si el campo es un tipo de referencia, la referencia se copia, pero el objeto que se hace referencia es no; por lo tanto, la referencia en el objeto original y la referencia en el clon que señalan al mismo objeto.</span><span class="sxs-lookup"><span data-stu-id="28044-197">If the field is a reference type, the reference is copied but the referred object is not; therefore, the reference in the original object and the reference in the clone point to the same object.</span></span> <span data-ttu-id="28044-198">En cambio, una copia en profundidad de un objeto duplica todo lo que hace referencia directa o indirectamente por los campos del objeto.</span><span class="sxs-lookup"><span data-stu-id="28044-198">In contrast, a deep copy of an object duplicates everything directly or indirectly referenced by the fields in the object.</span></span>  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">
          <span data-ttu-id="28044-199">Cuando se invoca en tiempo de ejecución a través de mecanismos como <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="28044-199">when invoked late-bound through mechanisms such as <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span>
          </span>
          <span data-ttu-id="28044-200">Enumeración asociada: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span>
          <span class="sxs-lookup">
            <span data-stu-id="28044-200">Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span>
          </span>
        </permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="Combine">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="28044-201">Concatena las listas de invocaciones de los delegados de multidifusión (combinables) especificados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="28044-201">Concatenates the invocation lists of the specified multicast (combinable) delegates.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Combine">
      <MemberSignature Language="C#" Value="public static Delegate Combine (params Delegate[] delegates);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Delegate Combine(class System.Delegate[] delegates) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.Combine(System.Delegate[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Combine (ParamArray delegates As Delegate()) As Delegate" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Delegate ^ Combine(... cli::array &lt;Delegate ^&gt; ^ delegates);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="delegates" Type="System.Delegate[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="delegates">
          <span data-ttu-id="28044-202">Matriz de delegados que se combinará.</span>
          <span class="sxs-lookup">
            <span data-stu-id="28044-202">The array of delegates to combine.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="28044-203">Concatena las listas de invocaciones de una matriz de delegados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="28044-203">Concatenates the invocation lists of an array of delegates.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="28044-204">Nuevo delegado con una lista de invocación que concatena las listas de invocación de los delegados de la matriz <paramref name="delegates" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="28044-204">A new delegate with an invocation list that concatenates the invocation lists of the delegates in the <paramref name="delegates" /> array.</span>
          </span>
          <span data-ttu-id="28044-205">Devuelve <see langword="null" /> si <paramref name="delegates" /> es <see langword="null" />, si <paramref name="delegates" /> no contiene ningún elemento o si todas las entradas de <paramref name="delegates" /> son <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="28044-205">Returns <see langword="null" /> if <paramref name="delegates" /> is <see langword="null" />, if <paramref name="delegates" /> contains zero elements, or if every entry in <paramref name="delegates" /> is <see langword="null" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="28044-206">Si el `delegates` matriz contiene entradas que son `null`, se omiten las entradas.</span><span class="sxs-lookup"><span data-stu-id="28044-206">If the `delegates` array contains entries that are `null`, those entries are ignored.</span></span>  
  
 <span data-ttu-id="28044-207">La lista de invocaciones puede contener entradas duplicadas; es decir, las entradas que hacen referencia al mismo método en el mismo objeto.</span><span class="sxs-lookup"><span data-stu-id="28044-207">The invocation list can contain duplicate entries; that is, entries that refer to the same method on the same object.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="28044-208">Delegados genéricos que son compatibles con la asignación debido a la variación no son necesariamente combinables.</span><span class="sxs-lookup"><span data-stu-id="28044-208">Generic delegates that are assignment-compatible because of variance are not necessarily combinable.</span></span> <span data-ttu-id="28044-209">Para ser combinables, los tipos deben coincidir exactamente.</span><span class="sxs-lookup"><span data-stu-id="28044-209">To be combinable, the types must match exactly.</span></span> <span data-ttu-id="28044-210">Por ejemplo, supongamos que una clase denominada `Derived` se deriva de una clase denominada `Base`.</span><span class="sxs-lookup"><span data-stu-id="28044-210">For example, suppose that a class named `Derived` is derived from a class named `Base`.</span></span> <span data-ttu-id="28044-211">Un delegado del tipo `Action<Base>` (`Action(Of Base)` en Visual Basic) puede asignarse a una variable de tipo `Action<Derived>`, como se explica en [covarianza y contravarianza](~/docs/standard/generics/covariance-and-contravariance.md), pero no se puede combinar los dos delegados porque los tipos no coinciden exactamente.</span><span class="sxs-lookup"><span data-stu-id="28044-211">A delegate of type `Action<Base>` (`Action(Of Base)` in Visual Basic) can be assigned to a variable of type `Action<Derived>`, as explained in [Covariance and Contravariance](~/docs/standard/generics/covariance-and-contravariance.md), but the two delegates cannot be combined because the types do not match exactly.</span></span>  
  
 <span data-ttu-id="28044-212"><xref:System.Delegate.Combine%2A> es útil para crear controladores de eventos que llamen a que varios métodos cada vez un evento tiene lugar.</span><span class="sxs-lookup"><span data-stu-id="28044-212"><xref:System.Delegate.Combine%2A> is useful for creating event handlers that call multiple methods each time an event occurs.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="28044-213">No todas las entradas que no son null de <paramref name="delegates" /> son instancias del mismo tipo de delegado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="28044-213">Not all the non-null entries in <paramref name="delegates" /> are instances of the same delegate type.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">
          <span data-ttu-id="28044-214">Cuando se invoca en tiempo de ejecución a través de mecanismos como <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="28044-214">when invoked late-bound through mechanisms such as <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span>
          </span>
          <span data-ttu-id="28044-215">Enumeración asociada: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span>
          <span class="sxs-lookup">
            <span data-stu-id="28044-215">Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span>
          </span>
        </permission>
        <altmember cref="T:System.MulticastDelegate" />
        <altmember cref="M:System.Delegate.CombineImpl(System.Delegate)" />
      </Docs>
    </Member>
    <Member MemberName="Combine">
      <MemberSignature Language="C#" Value="public static Delegate Combine (Delegate a, Delegate b);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Delegate Combine(class System.Delegate a, class System.Delegate b) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.Combine(System.Delegate,System.Delegate)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Combine (a As Delegate, b As Delegate) As Delegate" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Delegate ^ Combine(Delegate ^ a, Delegate ^ b);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="a" Type="System.Delegate" />
        <Parameter Name="b" Type="System.Delegate" />
      </Parameters>
      <Docs>
        <param name="a">
          <span data-ttu-id="28044-216">Delegado cuya lista de invocaciones está en primer lugar.</span>
          <span class="sxs-lookup">
            <span data-stu-id="28044-216">The delegate whose invocation list comes first.</span>
          </span>
        </param>
        <param name="b">
          <span data-ttu-id="28044-217">Delegado cuya lista de invocaciones está en último lugar.</span>
          <span class="sxs-lookup">
            <span data-stu-id="28044-217">The delegate whose invocation list comes last.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="28044-218">Concatena las listas de invocaciones de dos delegados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="28044-218">Concatenates the invocation lists of two delegates.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="28044-219">Nuevo delegado con una lista de invocaciones que concatena las listas de invocaciones de <paramref name="a" /> y <paramref name="b" /> en ese orden.</span>
          <span class="sxs-lookup">
            <span data-stu-id="28044-219">A new delegate with an invocation list that concatenates the invocation lists of <paramref name="a" /> and <paramref name="b" /> in that order.</span>
          </span>
          <span data-ttu-id="28044-220">Devuelve <paramref name="a" /> si <paramref name="b" /> es <see langword="null" />, devuelve <paramref name="b" /> si <paramref name="a" /> es una referencia nula y devuelve una referencia nula cuando tanto <paramref name="a" /> como <paramref name="b" /> son referencias nulas.</span>
          <span class="sxs-lookup">
            <span data-stu-id="28044-220">Returns <paramref name="a" /> if <paramref name="b" /> is <see langword="null" />, returns <paramref name="b" /> if <paramref name="a" /> is a null reference, and returns a null reference if both <paramref name="a" /> and <paramref name="b" /> are null references.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="28044-221">La lista de invocaciones puede contener entradas duplicadas; es decir, las entradas que hacen referencia al mismo método en el mismo objeto.</span><span class="sxs-lookup"><span data-stu-id="28044-221">The invocation list can contain duplicate entries; that is, entries that refer to the same method on the same object.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="28044-222">Delegados genéricos que son compatibles con la asignación debido a la variación no son necesariamente combinables.</span><span class="sxs-lookup"><span data-stu-id="28044-222">Generic delegates that are assignment-compatible because of variance are not necessarily combinable.</span></span> <span data-ttu-id="28044-223">Para ser combinables, los tipos deben coincidir exactamente.</span><span class="sxs-lookup"><span data-stu-id="28044-223">To be combinable, the types must match exactly.</span></span> <span data-ttu-id="28044-224">Por ejemplo, supongamos que una clase denominada `Derived` se deriva de una clase denominada `Base`.</span><span class="sxs-lookup"><span data-stu-id="28044-224">For example, suppose that a class named `Derived` is derived from a class named `Base`.</span></span> <span data-ttu-id="28044-225">Un delegado del tipo `Action<Base>` (`Action(Of Base)` en Visual Basic) puede asignarse a una variable de tipo `Action<Derived>`, como se explica en [covarianza y contravarianza](~/docs/standard/generics/covariance-and-contravariance.md), pero no se puede combinar los dos delegados porque los tipos no coinciden exactamente.</span><span class="sxs-lookup"><span data-stu-id="28044-225">A delegate of type `Action<Base>` (`Action(Of Base)` in Visual Basic) can be assigned to a variable of type `Action<Derived>`, as explained in [Covariance and Contravariance](~/docs/standard/generics/covariance-and-contravariance.md), but the two delegates cannot be combined because the types do not match exactly.</span></span>  
  
 <span data-ttu-id="28044-226"><xref:System.Delegate.Combine%2A> es útil para crear controladores de eventos que llamen a que varios métodos cada vez un evento tiene lugar.</span><span class="sxs-lookup"><span data-stu-id="28044-226"><xref:System.Delegate.Combine%2A> is useful for creating event handlers that call multiple methods each time an event occurs.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="28044-227">
            <paramref name="a" /> y <paramref name="b" /> no son <see langword="null" />, y <paramref name="a" /> y <paramref name="b" /> no son instancias del mismo tipo de delegado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="28044-227">Both <paramref name="a" /> and <paramref name="b" /> are not <see langword="null" />, and <paramref name="a" /> and <paramref name="b" /> are not instances of the same delegate type.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">
          <span data-ttu-id="28044-228">Cuando se invoca en tiempo de ejecución a través de mecanismos como <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="28044-228">when invoked late-bound through mechanisms such as <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span>
          </span>
          <span data-ttu-id="28044-229">Enumeración asociada: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span>
          <span class="sxs-lookup">
            <span data-stu-id="28044-229">Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span>
          </span>
        </permission>
        <altmember cref="T:System.MulticastDelegate" />
        <altmember cref="M:System.Delegate.CombineImpl(System.Delegate)" />
      </Docs>
    </Member>
    <Member MemberName="CombineImpl">
      <MemberSignature Language="C#" Value="protected virtual Delegate CombineImpl (Delegate d);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Delegate CombineImpl(class System.Delegate d) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.CombineImpl(System.Delegate)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function CombineImpl (d As Delegate) As Delegate" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual Delegate ^ CombineImpl(Delegate ^ d);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d" Type="System.Delegate" />
      </Parameters>
      <Docs>
        <param name="d">
          <span data-ttu-id="28044-230">Delegado de multidifusión (combinable) cuya lista de invocaciones se agrega al final de la lista de invocaciones del delegado de multidifusión (combinable) actual.</span>
          <span class="sxs-lookup">
            <span data-stu-id="28044-230">The multicast (combinable) delegate whose invocation list to append to the end of the invocation list of the current multicast (combinable) delegate.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="28044-231">Concatena las listas de invocaciones del delegado de multidifusión (combinable) especificado y del delegado de multidifusión (combinable) actual.</span>
          <span class="sxs-lookup">
            <span data-stu-id="28044-231">Concatenates the invocation lists of the specified multicast (combinable) delegate and the current multicast (combinable) delegate.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="28044-232">Nuevo delegado de multidifusión (combinable) con una lista de invocaciones que concatena la lista de invocaciones del delegado de multidifusión (combinable) actual y la lista de invocaciones de <paramref name="d" />; o delegado de multidifusión (combinable) actual si <paramref name="d" /> es <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="28044-232">A new multicast (combinable) delegate with an invocation list that concatenates the invocation list of the current multicast (combinable) delegate and the invocation list of <paramref name="d" />, or the current multicast (combinable) delegate if <paramref name="d" /> is <see langword="null" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="28044-233">Este método solo se aplica si el delegado actual es de multidifusión (combinables).</span><span class="sxs-lookup"><span data-stu-id="28044-233">This method applies only if the current delegate is multicast (combinable).</span></span>  
  
 <span data-ttu-id="28044-234">La implementación actual simplemente produce un <xref:System.MulticastNotSupportedException>.</span><span class="sxs-lookup"><span data-stu-id="28044-234">The current implementation simply throws a <xref:System.MulticastNotSupportedException>.</span></span>  
  
 <span data-ttu-id="28044-235">La lista de invocaciones puede contener entradas duplicadas; es decir, las entradas que hacen referencia al mismo método en el mismo objeto.</span><span class="sxs-lookup"><span data-stu-id="28044-235">The invocation list can contain duplicate entries; that is, entries that refer to the same method on the same object.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.MulticastNotSupportedException">
          <span data-ttu-id="28044-236">Siempre se produce.</span>
          <span class="sxs-lookup">
            <span data-stu-id="28044-236">Always thrown.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">
          <span data-ttu-id="28044-237">Cuando se invoca en tiempo de ejecución a través de mecanismos como <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="28044-237">when invoked late-bound through mechanisms such as <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span>
          </span>
          <span data-ttu-id="28044-238">Enumeración asociada: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span>
          <span class="sxs-lookup">
            <span data-stu-id="28044-238">Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span>
          </span>
        </permission>
        <altmember cref="M:System.Delegate.Combine(System.Delegate,System.Delegate)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateDelegate">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="28044-239">Crea un delegado del tipo especificado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="28044-239">Creates a delegate of the specified type.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateDelegate">
      <MemberSignature Language="C#" Value="public static Delegate CreateDelegate (Type type, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Delegate CreateDelegate(class System.Type type, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Delegate ^ CreateDelegate(Type ^ type, System::Reflection::MethodInfo ^ method);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="type">
          <span data-ttu-id="28044-240">
            <see cref="T:System.Type" /> de delegado que se va a crear.</span>
          <span class="sxs-lookup">
            <span data-stu-id="28044-240">The <see cref="T:System.Type" /> of delegate to create.</span>
          </span>
        </param>
        <param name="method">
          <span data-ttu-id="28044-241">
            <see cref="T:System.Reflection.MethodInfo" /> que describe el método estático o de instancia que va a representar el delegado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="28044-241">The <see cref="T:System.Reflection.MethodInfo" /> describing the static or instance method the delegate is to represent.</span>
          </span>
          <span data-ttu-id="28044-242">Solo se admiten métodos estáticos en las versiones 1.0 y 1.1 de .NET Framework.</span>
          <span class="sxs-lookup">
            <span data-stu-id="28044-242">Only static methods are supported in the .NET Framework version 1.0 and 1.1.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="28044-243">Crea un delegado del tipo especificado para representar el método estático especificado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="28044-243">Creates a delegate of the specified type to represent the specified static method.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="28044-244">Delegado del tipo especificado para representar el método estático especificado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="28044-244">A delegate of the specified type to represent the specified static method.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="28044-245">En la versión 1.0 y 1.1 de .NET Framework, esta sobrecarga del método crea a delegados para los métodos estáticos solo.</span><span class="sxs-lookup"><span data-stu-id="28044-245">In the .NET Framework version 1.0 and 1.1, this method overload creates delegates for static methods only.</span></span> <span data-ttu-id="28044-246">En la versión 2.0 de .NET Framework, esta sobrecarga del método también puede crear instancia abierta delegados de método; es decir, los delegados que proporcionan explícitamente el primer argumento oculto de métodos de instancia.</span><span class="sxs-lookup"><span data-stu-id="28044-246">In the .NET Framework version 2.0, this method overload also can create open instance method delegates; that is, delegates that explicitly supply the hidden first argument of instance methods.</span></span> <span data-ttu-id="28044-247">Para obtener una explicación detallada, vea más general <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Object%2CSystem.Reflection.MethodInfo%29> sobrecarga del método, que le permite crear todas las combinaciones de delegados abiertos o cerrados para los métodos estáticos o de instancia y, opcionalmente, para especificar un primer argumento.</span><span class="sxs-lookup"><span data-stu-id="28044-247">For a detailed explanation, see the more general <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Object%2CSystem.Reflection.MethodInfo%29> method overload, which allows you to create all combinations of open or closed delegates for instance or static methods, and optionally to specify a first argument.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="28044-248">Esta sobrecarga del método se debe usar cuando el delegado no se cierra en su primer argumento, porque en ese caso es algo más rápido.</span><span class="sxs-lookup"><span data-stu-id="28044-248">This method overload should be used when the delegate is not closed over its first argument, because it is somewhat faster in that case.</span></span>  
  
 <span data-ttu-id="28044-249">Esta sobrecarga del método es equivalente a llamar a la <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Reflection.MethodInfo%2CSystem.Boolean%29> sobrecarga del método y especificando `true` para `throwOnBindFailure`.</span><span class="sxs-lookup"><span data-stu-id="28044-249">This method overload is equivalent to calling the <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Reflection.MethodInfo%2CSystem.Boolean%29> method overload and specifying `true` for `throwOnBindFailure`.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="28044-250">A partir de la [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], este método se puede utilizar para tener acceso a los métodos no públicos si se ha concedido el autor de llamada <xref:System.Security.Permissions.ReflectionPermission> con el <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> marca y, si el conjunto de permisos de los métodos no públicos se restringe al llamador conceda conjunto o un subconjunto de los mismos.</span><span class="sxs-lookup"><span data-stu-id="28044-250">Starting with the [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], this method can be used to access non-public methods if the caller has been granted <xref:System.Security.Permissions.ReflectionPermission> with the <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> flag and if the grant set of the non-public methods is restricted to the caller’s grant set, or a subset thereof.</span></span> <span data-ttu-id="28044-251">(Consulte [consideraciones de seguridad para la reflexión](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)</span><span class="sxs-lookup"><span data-stu-id="28044-251">(See [Security Considerations for Reflection](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)</span></span>  
>   
>  <span data-ttu-id="28044-252">Para utilizar esta funcionalidad, la aplicación debe utilizar [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] o posterior como destino.</span><span class="sxs-lookup"><span data-stu-id="28044-252">To use this functionality, your application should target the [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] or later.</span></span>  
  
## <a name="compatible-parameter-types-and-return-type"></a><span data-ttu-id="28044-253">Tipos de parámetro compatible y tipo de valor devuelto</span><span class="sxs-lookup"><span data-stu-id="28044-253">Compatible Parameter Types and Return Type</span></span>  
 <span data-ttu-id="28044-254">En la versión 2.0 de .NET Framework, los tipos de parámetro y el tipo de valor devuelto de un delegado creado mediante esta sobrecarga de método deben ser compatibles con los tipos de parámetro y el tipo de valor devuelto del método que representa el delegado; los tipos no tienen que coincidir exactamente.</span><span class="sxs-lookup"><span data-stu-id="28044-254">In the .NET Framework version 2.0, the parameter types and return type of a delegate created using this method overload must be compatible with the parameter types and return type of the method the delegate represents; the types do not have to match exactly.</span></span> <span data-ttu-id="28044-255">Esto representa un relajación del comportamiento de enlace en .NET Framework versiones 1.0 y 1.1, donde los tipos deben coincidir exactamente.</span><span class="sxs-lookup"><span data-stu-id="28044-255">This represents a relaxation of the binding behavior in the .NET Framework version 1.0 and 1.1, where the types must match exactly.</span></span>  
  
 <span data-ttu-id="28044-256">Un parámetro de un delegado es compatible con el parámetro correspondiente de un método si el tipo del parámetro del delegado es más restrictivo que el del método, porque así se garantiza que el argumento que se pase al delegado también se podrá pasar de forma segura al método.</span><span class="sxs-lookup"><span data-stu-id="28044-256">A parameter of a delegate is compatible with the corresponding parameter of a method if the type of the delegate parameter is more restrictive than the type of the method parameter, because this guarantees that an argument passed to the delegate can be passed safely to the method.</span></span>  
  
 <span data-ttu-id="28044-257">De forma similar, el tipo de devolución de un delegado es compatible con el tipo de devolución de un método si el del método es más restrictivo que el del delegado, porque así se garantiza que el valor devuelto por el método se puede convertir con seguridad al tipo de devolución del delegado.</span><span class="sxs-lookup"><span data-stu-id="28044-257">Similarly, the return type of a delegate is compatible with the return type of a method if the return type of the method is more restrictive than the return type of the delegate, because this guarantees that the return value of the method can be cast safely to the return type of the delegate.</span></span>  
  
 <span data-ttu-id="28044-258">Por ejemplo, un delegado con un parámetro de tipo <xref:System.Collections.Hashtable> y un tipo de valor devuelto de <xref:System.Object> puede representar un método con un parámetro de tipo <xref:System.Object> y un valor devuelto de tipo <xref:System.Collections.Hashtable>.</span><span class="sxs-lookup"><span data-stu-id="28044-258">For example, a delegate with a parameter of type <xref:System.Collections.Hashtable> and a return type of <xref:System.Object> can represent a method with a parameter of type <xref:System.Object> and a return value of type <xref:System.Collections.Hashtable>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="28044-259">Esta sección contiene dos ejemplos de código.</span><span class="sxs-lookup"><span data-stu-id="28044-259">This section contains two code examples.</span></span> <span data-ttu-id="28044-260">El primer ejemplo muestra los dos tipos de delegados que se pueden crear con esta sobrecarga del método: abra a través de un método de instancia y a través de un método estático.</span><span class="sxs-lookup"><span data-stu-id="28044-260">The first example demonstrates the two kinds of delegates that can be created with this method overload: open over an instance method and open over a static method.</span></span>  
  
 <span data-ttu-id="28044-261">El segundo ejemplo de código muestra los tipos de parámetros compatibles y tipos de valor devuelto.</span><span class="sxs-lookup"><span data-stu-id="28044-261">The second code example demonstrates compatible parameter types and return types.</span></span>  
  
 <span data-ttu-id="28044-262">**Ejemplo 1**</span><span class="sxs-lookup"><span data-stu-id="28044-262">**Example 1**</span></span>  
  
 <span data-ttu-id="28044-263">En el ejemplo de código siguiente se muestra las dos maneras se puede crear un delegado utilizando esta sobrecarga de la <xref:System.Delegate.CreateDelegate%2A> método.</span><span class="sxs-lookup"><span data-stu-id="28044-263">The following code example demonstrates the two ways a delegate can be created using this overload of the <xref:System.Delegate.CreateDelegate%2A> method.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="28044-264">Hay dos sobrecargas de la <xref:System.Delegate.CreateDelegate%2A> método que especifican un <xref:System.Reflection.MethodInfo> pero no un primer argumento; su funcionalidad es el mismo, salvo que uno le permite especificar si se producirá en error en el enlace y el otro siempre produce una excepción.</span><span class="sxs-lookup"><span data-stu-id="28044-264">There are two overloads of the <xref:System.Delegate.CreateDelegate%2A> method that specify a <xref:System.Reflection.MethodInfo> but not a first argument; their functionality is the same except that one allows you to specify whether to throw on failure to bind, and the other always throws.</span></span> <span data-ttu-id="28044-265">Este ejemplo de código utiliza ambas sobrecargas.</span><span class="sxs-lookup"><span data-stu-id="28044-265">This code example uses both overloads.</span></span>  
  
 <span data-ttu-id="28044-266">En el ejemplo se declara una clase `C` con un método estático `M2` y un método de instancia `M1`, y dos tipos de delegado: `D1` toma una instancia de `C` y una cadena, y `D2` toma una cadena.</span><span class="sxs-lookup"><span data-stu-id="28044-266">The example declares a class `C` with a static method `M2` and an instance method `M1`, and two delegate types: `D1` takes an instance of `C` and a string, and `D2` takes a string.</span></span>  
  
 <span data-ttu-id="28044-267">Una segunda clase denominada `Example` contiene el código que crea los delegados.</span><span class="sxs-lookup"><span data-stu-id="28044-267">A second class named `Example` contains the code that creates the delegates.</span></span>  
  
-   <span data-ttu-id="28044-268">Un delegado del tipo `D1`, que representa un método de instancia abierta, se crea para el método de instancia `M1`.</span><span class="sxs-lookup"><span data-stu-id="28044-268">A delegate of type `D1`, representing an open instance method, is created for the instance method `M1`.</span></span> <span data-ttu-id="28044-269">Debe pasar una instancia cuando se invoca el delegado.</span><span class="sxs-lookup"><span data-stu-id="28044-269">An instance must be passed when the delegate is invoked.</span></span>  
  
-   <span data-ttu-id="28044-270">Un delegado del tipo `D2`, que representa un método estático abierto, se crea para el método estático `M2`.</span><span class="sxs-lookup"><span data-stu-id="28044-270">A delegate of type `D2`, representing an open static method, is created for the static method `M2`.</span></span>  
  
 [!code-csharp[Delegate.CreateDelegateTOM#1](~/samples/snippets/csharp/VS_Snippets_CLR/Delegate.CreateDelegateTOM/cs/openClosedOver.cs#1)]
 [!code-vb[Delegate.CreateDelegateTOM#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Delegate.CreateDelegateTOM/VB/openClosedOver.vb#1)]  
  
 <span data-ttu-id="28044-271">**Ejemplo 2**</span><span class="sxs-lookup"><span data-stu-id="28044-271">**Example 2**</span></span>  
  
 <span data-ttu-id="28044-272">En el ejemplo de código siguiente se muestra la compatibilidad de tipos de parámetro y tipos de valor devuelto.</span><span class="sxs-lookup"><span data-stu-id="28044-272">The following code example demonstrates compatibility of parameter types and return types.</span></span>  
  
 <span data-ttu-id="28044-273">El ejemplo de código define una clase base denominada `Base` y una clase denominada `Derived` que se deriva de `Base`.</span><span class="sxs-lookup"><span data-stu-id="28044-273">The code example defines a base class named `Base` and a class named `Derived` that derives from `Base`.</span></span> <span data-ttu-id="28044-274">La clase derivada tiene un `static` (`Shared` en Visual Basic) con el nombre de método `MyMethod` con un parámetro de tipo `Base` y un tipo de valor devuelto de `Derived`.</span><span class="sxs-lookup"><span data-stu-id="28044-274">The derived class has a `static` (`Shared` in Visual Basic) method named `MyMethod` with one parameter of type `Base` and a return type of `Derived`.</span></span> <span data-ttu-id="28044-275">El ejemplo de código también define un delegado denominado `Example` que tiene un parámetro de tipo `Derived` y un tipo de valor devuelto de `Base`.</span><span class="sxs-lookup"><span data-stu-id="28044-275">The code example also defines a delegate named `Example` that has one parameter of type `Derived` and a return type of `Base`.</span></span>  
  
 <span data-ttu-id="28044-276">El ejemplo de código se muestra que el delegado denominado `Example` puede usarse para representar el método `MyMethod`.</span><span class="sxs-lookup"><span data-stu-id="28044-276">The code example demonstrates that the delegate named `Example` can be used to represent the method `MyMethod`.</span></span> <span data-ttu-id="28044-277">El método se puede enlazar al delegado porque:</span><span class="sxs-lookup"><span data-stu-id="28044-277">The method can be bound to the delegate because:</span></span>  
  
-   <span data-ttu-id="28044-278">El tipo de parámetro del delegado (`Derived`) es más restrictivo que el tipo de parámetro `MyMethod` (`Base`), de modo que siempre es seguro pasar el argumento del delegado al que `MyMethod`.</span><span class="sxs-lookup"><span data-stu-id="28044-278">The parameter type of the delegate (`Derived`) is more restrictive than the parameter type of `MyMethod` (`Base`), so that it is always safe to pass the argument of the delegate to `MyMethod`.</span></span>  
  
-   <span data-ttu-id="28044-279">El tipo de valor devuelto de `MyMethod` (`Derived`) es más restrictivo que el tipo de parámetro del delegado (`Base`), de modo que siempre es seguro convertir el tipo de valor devuelto del método para el tipo de valor devuelto del delegado.</span><span class="sxs-lookup"><span data-stu-id="28044-279">The return type of `MyMethod` (`Derived`) is more restrictive than the parameter type of the delegate (`Base`), so that it is always safe to cast the return type of the method to the return type of the delegate.</span></span>  
  
 <span data-ttu-id="28044-280">El ejemplo de código no produce ningún resultado.</span><span class="sxs-lookup"><span data-stu-id="28044-280">The code example produces no output.</span></span>  
  
 [!code-cpp[Delegate.CreateDelegate_RelaxedFit#1](~/samples/snippets/cpp/VS_Snippets_CLR/Delegate.CreateDelegate_RelaxedFit/cpp/source.cpp#1)]
 [!code-csharp[Delegate.CreateDelegate_RelaxedFit#1](~/samples/snippets/csharp/VS_Snippets_CLR/Delegate.CreateDelegate_RelaxedFit/cs/source.cs#1)]
 [!code-vb[Delegate.CreateDelegate_RelaxedFit#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Delegate.CreateDelegate_RelaxedFit/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="28044-281">
            <paramref name="type" /> es <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="28044-281">
              <paramref name="type" /> is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="28044-282">O bien</span>
          <span class="sxs-lookup">
            <span data-stu-id="28044-282">-or-</span>
          </span>
          <span data-ttu-id="28044-283">
            <paramref name="method" /> es <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="28044-283">
              <paramref name="method" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="28044-284">
            <paramref name="type" /> no hereda <see cref="T:System.MulticastDelegate" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="28044-284">
              <paramref name="type" /> does not inherit <see cref="T:System.MulticastDelegate" />.</span>
          </span>
          <span data-ttu-id="28044-285">O bien</span>
          <span class="sxs-lookup">
            <span data-stu-id="28044-285">-or-</span>
          </span>
          <span data-ttu-id="28044-286">
            <paramref name="type" /> no es un <see langword="RuntimeType" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="28044-286">
              <paramref name="type" /> is not a <see langword="RuntimeType" />.</span>
          </span>
          <span data-ttu-id="28044-287">Vea [Tipos de reflexión en tiempo de ejecución](http://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858).</span>
          <span class="sxs-lookup">
            <span data-stu-id="28044-287">See [Runtime Types in Reflection](http://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858).</span>
          </span>
          <span data-ttu-id="28044-288">O bien</span>
          <span class="sxs-lookup">
            <span data-stu-id="28044-288">-or-</span>
          </span>
          <span data-ttu-id="28044-289">
            <paramref name="method" /> no es un método estático y la versión de .NET Framework es 1.0 o 1.1.</span>
          <span class="sxs-lookup">
            <span data-stu-id="28044-289">
              <paramref name="method" /> is not a static method, and the .NET Framework version is 1.0 or 1.1.</span>
          </span>
          <span data-ttu-id="28044-290">O bien</span>
          <span class="sxs-lookup">
            <span data-stu-id="28044-290">-or-</span>
          </span>
          <span data-ttu-id="28044-291">No se puede enlazar <paramref name="method" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="28044-291">
              <paramref name="method" /> cannot be bound.</span>
          </span>
          <span data-ttu-id="28044-292">O bien</span>
          <span class="sxs-lookup">
            <span data-stu-id="28044-292">-or-</span>
          </span>
          <span data-ttu-id="28044-293">
            <paramref name="method" /> no es un <see langword="RuntimeMethodInfo" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="28044-293">
              <paramref name="method" /> is not a <see langword="RuntimeMethodInfo" />.</span>
          </span>
          <span data-ttu-id="28044-294">Vea [Tipos de reflexión en tiempo de ejecución](http://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858).</span>
          <span class="sxs-lookup">
            <span data-stu-id="28044-294">See [Runtime Types in Reflection](http://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858).</span>
          </span>
        </exception>
        <exception cref="T:System.MissingMethodException">
          <span data-ttu-id="28044-295">No se encuentra el método <see langword="Invoke" /> de <paramref name="type" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="28044-295">The <see langword="Invoke" /> method of <paramref name="type" /> is not found.</span>
          </span>
        </exception>
        <exception cref="T:System.MethodAccessException">
          <span data-ttu-id="28044-296">El autor de la llamada no tiene los permisos necesarios para acceder a <paramref name="method" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="28044-296">The caller does not have the permissions necessary to access <paramref name="method" />.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">
          <span data-ttu-id="28044-297">Cuando se invoca en tiempo de ejecución a través de mecanismos como <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="28044-297">when invoked late-bound through mechanisms such as <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span>
          </span>
          <span data-ttu-id="28044-298">Enumeración asociada: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="28044-298">Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</span>
          </span>
        </permission>
        <altmember cref="T:System.Type" />
        <altmember cref="T:System.MulticastDelegate" />
        <altmember cref="T:System.Security.Permissions.ReflectionPermission" />
        <altmember cref="T:System.Reflection.MethodInfo" />
      </Docs>
    </Member>
    <Member MemberName="CreateDelegate">
      <MemberSignature Language="C#" Value="public static Delegate CreateDelegate (Type type, object firstArgument, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Delegate CreateDelegate(class System.Type type, object firstArgument, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Delegate ^ CreateDelegate(Type ^ type, System::Object ^ firstArgument, System::Reflection::MethodInfo ^ method);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="firstArgument" Type="System.Object" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="type">
          <span data-ttu-id="28044-299">
            <see cref="T:System.Type" /> de delegado que se va a crear.</span>
          <span class="sxs-lookup">
            <span data-stu-id="28044-299">The <see cref="T:System.Type" /> of delegate to create.</span>
          </span>
        </param>
        <param name="firstArgument">
          <span data-ttu-id="28044-300">Objeto al que se enlaza el delegado, o <see langword="null" /> para tratar <c>method</c> como <see langword="static" /> (<see langword="Shared" /> en Visual Basic).</span>
          <span class="sxs-lookup">
            <span data-stu-id="28044-300">The object to which the delegate is bound, or <see langword="null" /> to treat <c>method</c> as <see langword="static" /> (<see langword="Shared" /> in Visual Basic).</span>
          </span>
        </param>
        <param name="method">
          <span data-ttu-id="28044-301">
            <see cref="T:System.Reflection.MethodInfo" /> que describe el método estático o de instancia que va a representar el delegado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="28044-301">The <see cref="T:System.Reflection.MethodInfo" /> describing the static or instance method the delegate is to represent.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="28044-302">Crea un delegado del tipo especificado que representa el método estático o de instancia especificado, con el primer argumento definido.</span>
          <span class="sxs-lookup">
            <span data-stu-id="28044-302">Creates a delegate of the specified type that represents the specified static or instance method, with the specified first argument.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="28044-303">Delegado del tipo especificado que representa el método estático o de instancia definido.</span>
          <span class="sxs-lookup">
            <span data-stu-id="28044-303">A delegate of the specified type that represents the specified static or instance method.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="28044-304">Llamar a esta sobrecarga del método es equivalente a llamar a la <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Object%2CSystem.Reflection.MethodInfo%2CSystem.Boolean%29> sobrecarga del método y especificando `true` para `throwOnBindFailure`.</span><span class="sxs-lookup"><span data-stu-id="28044-304">Calling this method overload is equivalent to calling the <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Object%2CSystem.Reflection.MethodInfo%2CSystem.Boolean%29> method overload and specifying `true` for `throwOnBindFailure`.</span></span> <span data-ttu-id="28044-305">Estas dos sobrecargas proporcionan la manera más flexible para crear a delegados.</span><span class="sxs-lookup"><span data-stu-id="28044-305">These two overloads provide the most flexible way to create delegates.</span></span> <span data-ttu-id="28044-306">Puede usarlos para crear delegados para estáticas o métodos de instancia y, opcionalmente, para especificar el primer argumento.</span><span class="sxs-lookup"><span data-stu-id="28044-306">You can use them to create delegates for either static or instance methods, and optionally to specify the first argument.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="28044-307">Si no proporciona un primer argumento, utilice la <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Reflection.MethodInfo%29> sobrecarga del método para mejorar el rendimiento.</span><span class="sxs-lookup"><span data-stu-id="28044-307">If you do not supply a first argument, use the <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Reflection.MethodInfo%29> method overload for better performance.</span></span>  
  
 <span data-ttu-id="28044-308">El tipo de delegado y el método deben tener tipos de devolución compatibles.</span><span class="sxs-lookup"><span data-stu-id="28044-308">The delegate type and the method must have compatible return types.</span></span> <span data-ttu-id="28044-309">Es decir, el tipo de valor devuelto de `method` debe ser asignable al tipo de valor devuelto de `type`.</span><span class="sxs-lookup"><span data-stu-id="28044-309">That is, the return type of `method` must be assignable to the return type of `type`.</span></span>  
  
 <span data-ttu-id="28044-310">Si `firstArgument` es proporciona, se pasa a `method` cada vez que se invoca el delegado; `firstArgument` se dice que está enlazado al delegado, y se dice que el delegado se cierra en su primer argumento.</span><span class="sxs-lookup"><span data-stu-id="28044-310">If `firstArgument` is supplied, it is passed to `method` every time the delegate is invoked; `firstArgument` is said to be bound to the delegate, and the delegate is said to be closed over its first argument.</span></span> <span data-ttu-id="28044-311">Si `method` es `static` (`Shared` en Visual Basic), la lista proporcionada al invocar al delegado incluye todos los parámetros excepto el primero; si el argumento `method` es un método de instancia, a continuación, `firstArgument` se pasa al parámetro de instancia oculto (representado por `this` en C# o mediante `Me` en Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="28044-311">If `method` is `static` (`Shared` in Visual Basic), the argument list supplied when invoking the delegate includes all parameters except the first; if `method` is an instance method, then `firstArgument` is passed to the hidden instance parameter (represented by `this` in C#, or by `Me` in Visual Basic).</span></span>  
  
 <span data-ttu-id="28044-312">Si `firstArgument` se proporciona, el primer parámetro de `method` debe ser un tipo de referencia y `firstArgument` deben ser compatibles con ese tipo.</span><span class="sxs-lookup"><span data-stu-id="28044-312">If `firstArgument` is supplied, the first parameter of `method` must be a reference type, and `firstArgument` must be compatible with that type.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="28044-313">Si `method` es `static` (`Shared` en Visual Basic) y su primer parámetro es de tipo <xref:System.Object> o <xref:System.ValueType>, a continuación, `firstArgument` puede ser un tipo de valor.</span><span class="sxs-lookup"><span data-stu-id="28044-313">If `method` is `static` (`Shared` in Visual Basic) and its first parameter is of type <xref:System.Object> or <xref:System.ValueType>, then `firstArgument` can be a value type.</span></span> <span data-ttu-id="28044-314">En este caso `firstArgument` automáticamente es una conversión boxing.</span><span class="sxs-lookup"><span data-stu-id="28044-314">In this case `firstArgument` is automatically boxed.</span></span> <span data-ttu-id="28044-315">La conversión boxing automática no se produce para cualquier otro argumento, como en un C# o Visual Basic función llamaría.</span><span class="sxs-lookup"><span data-stu-id="28044-315">Automatic boxing does not occur for any other arguments, as it would in a C# or Visual Basic function call.</span></span>  
  
 <span data-ttu-id="28044-316">Si `firstArgument` es una referencia nula y `method` es un método de instancia, el resultado depende de las firmas del tipo de delegado `type` y de `method`:</span><span class="sxs-lookup"><span data-stu-id="28044-316">If `firstArgument` is a null reference and `method` is an instance method, the result depends on the signatures of the delegate type `type` and of `method`:</span></span>  
  
-   <span data-ttu-id="28044-317">Si la firma de `type` incluya explícitamente el primer parámetro oculto de `method`, se dice que el delegado representa un método de instancia abierto.</span><span class="sxs-lookup"><span data-stu-id="28044-317">If the signature of `type` explicitly includes the hidden first parameter of `method`, the delegate is said to represent an open instance method.</span></span> <span data-ttu-id="28044-318">Cuando se invoca el delegado, el primer argumento de la lista de argumentos se pasa al parámetro de instancia oculto de `method`.</span><span class="sxs-lookup"><span data-stu-id="28044-318">When the delegate is invoked, the first argument in the argument list is passed to the hidden instance parameter of `method`.</span></span>  
  
-   <span data-ttu-id="28044-319">Si las firmas de `method` y `type` coincide con (es decir, todos los tipos de parámetros son compatibles), a continuación, se dice que el delegado se cierra en una referencia nula.</span><span class="sxs-lookup"><span data-stu-id="28044-319">If the signatures of `method` and `type` match (that is, all parameter types are compatible), then the delegate is said to be closed over a null reference.</span></span> <span data-ttu-id="28044-320">Invocar al delegado es similar a llamar a un método de instancia en una instancia null, que no es algo muy útil.</span><span class="sxs-lookup"><span data-stu-id="28044-320">Invoking the delegate is like calling an instance method on a null instance, which is not a particularly useful thing to do.</span></span>  
  
 <span data-ttu-id="28044-321">Si `firstArgument` es una referencia nula y `method` es estático, el resultado depende de las firmas del tipo de delegado `type` y de `method`:</span><span class="sxs-lookup"><span data-stu-id="28044-321">If `firstArgument` is a null reference and `method` is static, the result depends on the signatures of the delegate type `type` and of `method`:</span></span>  
  
-   <span data-ttu-id="28044-322">Si la firma de `method` y `type` coincide con (es decir, todos los tipos de parámetros son compatibles), se dice que el delegado representa un método estático abierto.</span><span class="sxs-lookup"><span data-stu-id="28044-322">If the signature of `method` and `type` match (that is, all parameter types are compatible), the delegate is said to represent an open static method.</span></span> <span data-ttu-id="28044-323">Este es el caso más común para los métodos estáticos.</span><span class="sxs-lookup"><span data-stu-id="28044-323">This is the most common case for static methods.</span></span> <span data-ttu-id="28044-324">En este caso, puede obtener un rendimiento ligeramente mejor mediante el <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Reflection.MethodInfo%29> sobrecarga del método.</span><span class="sxs-lookup"><span data-stu-id="28044-324">In this case, you can get slightly better performance by using the <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Reflection.MethodInfo%29> method overload.</span></span>  
  
-   <span data-ttu-id="28044-325">Si la firma de `type` comienza con el segundo parámetro de `method` y el resto de los tipos de parámetros son compatibles, a continuación, se dice que el delegado se cierra en una referencia nula.</span><span class="sxs-lookup"><span data-stu-id="28044-325">If the signature of `type` begins with the second parameter of `method` and the rest of the parameter types are compatible, then the delegate is said to be closed over a null reference.</span></span> <span data-ttu-id="28044-326">Cuando se invoca el delegado, se pasa una referencia nula al primer parámetro de `method`.</span><span class="sxs-lookup"><span data-stu-id="28044-326">When the delegate is invoked, a null reference is passed to the first parameter of `method`.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="28044-327">A partir de la [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], este método se puede utilizar para tener acceso a los métodos no públicos si se ha concedido el autor de llamada <xref:System.Security.Permissions.ReflectionPermission> con el <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> marca y, si el conjunto de permisos de los métodos no públicos se restringe al llamador conceda conjunto o un subconjunto de los mismos.</span><span class="sxs-lookup"><span data-stu-id="28044-327">Starting with the [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], this method can be used to access non-public methods if the caller has been granted <xref:System.Security.Permissions.ReflectionPermission> with the <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> flag and if the grant set of the non-public methods is restricted to the caller’s grant set, or a subset thereof.</span></span> <span data-ttu-id="28044-328">(Consulte [consideraciones de seguridad para la reflexión](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)</span><span class="sxs-lookup"><span data-stu-id="28044-328">(See [Security Considerations for Reflection](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)</span></span>  
>   
>  <span data-ttu-id="28044-329">Para utilizar esta funcionalidad, la aplicación debe utilizar [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] o posterior como destino.</span><span class="sxs-lookup"><span data-stu-id="28044-329">To use this functionality, your application should target the [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] or later.</span></span>  
  
## <a name="compatible-parameter-types-and-return-type"></a><span data-ttu-id="28044-330">Tipos de parámetro compatible y tipo de valor devuelto</span><span class="sxs-lookup"><span data-stu-id="28044-330">Compatible Parameter Types and Return Type</span></span>  
 <span data-ttu-id="28044-331">Los tipos de parámetro y el tipo de valor devuelto de un delegado deben ser compatibles con los tipos de parámetro y el tipo de valor devuelto del método que representa el delegado; los tipos no tienen que coincidir exactamente.</span><span class="sxs-lookup"><span data-stu-id="28044-331">The parameter types and return type of a delegate must be compatible with the parameter types and return type of the method the delegate represents; the types do not have to match exactly.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="28044-332">En la versión 1.0 y 1.1 de .NET Framework, los tipos deben coincidir exactamente.</span><span class="sxs-lookup"><span data-stu-id="28044-332">In the .NET Framework version 1.0 and 1.1, the types must match exactly.</span></span>  
  
 <span data-ttu-id="28044-333">Un parámetro de un delegado es compatible con el parámetro correspondiente de un método si el tipo del parámetro del delegado es más restrictivo que el del método, porque así se garantiza que el argumento que se pase al delegado también se podrá pasar de forma segura al método.</span><span class="sxs-lookup"><span data-stu-id="28044-333">A parameter of a delegate is compatible with the corresponding parameter of a method if the type of the delegate parameter is more restrictive than the type of the method parameter, because this guarantees that an argument passed to the delegate can be passed safely to the method.</span></span>  
  
 <span data-ttu-id="28044-334">De forma similar, el tipo de devolución de un delegado es compatible con el tipo de devolución de un método si el del método es más restrictivo que el del delegado, porque así se garantiza que el valor devuelto por el método se puede convertir con seguridad al tipo de devolución del delegado.</span><span class="sxs-lookup"><span data-stu-id="28044-334">Similarly, the return type of a delegate is compatible with the return type of a method if the return type of the method is more restrictive than the return type of the delegate, because this guarantees that the return value of the method can be cast safely to the return type of the delegate.</span></span>  
  
 <span data-ttu-id="28044-335">Por ejemplo, un delegado con un parámetro de tipo <xref:System.Collections.Hashtable> y un tipo de valor devuelto de <xref:System.Object> puede representar un método con un parámetro de tipo <xref:System.Object> y un valor devuelto de tipo <xref:System.Collections.Hashtable>.</span><span class="sxs-lookup"><span data-stu-id="28044-335">For example, a delegate with a parameter of type <xref:System.Collections.Hashtable> and a return type of <xref:System.Object> can represent a method with a parameter of type <xref:System.Object> and a return value of type <xref:System.Collections.Hashtable>.</span></span>  
  
## <a name="determining-the-methods-a-delegate-can-represent"></a><span data-ttu-id="28044-336">Determinación de los métodos que puede representar un delegado</span><span class="sxs-lookup"><span data-stu-id="28044-336">Determining the Methods a Delegate Can Represent</span></span>  
 <span data-ttu-id="28044-337">Otra manera útil pensar en la flexibilidad proporcionada por esta sobrecarga de <xref:System.Delegate.CreateDelegate%2A> es que cualquier delegado puede representar cuatro combinaciones diferentes de firma de método y el tipo de método (estático frente a la instancia).</span><span class="sxs-lookup"><span data-stu-id="28044-337">Another useful way to think of the flexibility provided by this overload of <xref:System.Delegate.CreateDelegate%2A> is that any given delegate can represent four different combinations of method signature and method kind (static versus instance).</span></span> <span data-ttu-id="28044-338">Considere la posibilidad de un tipo de delegado `D` con un argumento de tipo `C`.</span><span class="sxs-lookup"><span data-stu-id="28044-338">Consider a delegate type `D` with one argument of type `C`.</span></span> <span data-ttu-id="28044-339">Lo siguiente describe los métodos `D` puede representar, omitiendo el tipo de valor devuelto, puesto que debe coincidir en todos los casos:</span><span class="sxs-lookup"><span data-stu-id="28044-339">The following describes the methods `D` can represent, ignoring the return type since it must match in all cases:</span></span>  
  
-   <span data-ttu-id="28044-340">`D` puede representar cualquier método de instancia que tenga exactamente un argumento de tipo `C`, independientemente de qué tipo pertenece el método de instancia.</span><span class="sxs-lookup"><span data-stu-id="28044-340">`D` can represent any instance method that has exactly one argument of type `C`, regardless of what type the instance method belongs to.</span></span> <span data-ttu-id="28044-341">Cuando <xref:System.Delegate.CreateDelegate%2A> se llama, `firstArgument` es una instancia del tipo `method` pertenece, y se dice que el delegado resultante cerrado en esa instancia.</span><span class="sxs-lookup"><span data-stu-id="28044-341">When <xref:System.Delegate.CreateDelegate%2A> is called, `firstArgument` is an instance of the type `method` belongs to, and the resulting delegate is said to be closed over that instance.</span></span> <span data-ttu-id="28044-342">(Trivial, `D` también se puede cerrar sobre una referencia nula si `firstArgument` es una referencia nula.)</span><span class="sxs-lookup"><span data-stu-id="28044-342">(Trivially, `D` can also be closed over a null reference if `firstArgument` is a null reference.)</span></span>  
  
-   <span data-ttu-id="28044-343">`D` puede representar un método de instancia de `C` que no tiene ningún argumento.</span><span class="sxs-lookup"><span data-stu-id="28044-343">`D` can represent an instance method of `C` that has no arguments.</span></span> <span data-ttu-id="28044-344">Cuando <xref:System.Delegate.CreateDelegate%2A> se llama, `firstArgument` es una referencia nula.</span><span class="sxs-lookup"><span data-stu-id="28044-344">When <xref:System.Delegate.CreateDelegate%2A> is called, `firstArgument` is a null reference.</span></span> <span data-ttu-id="28044-345">El delegado resultante representa un método de instancia abierta y una instancia de `C` debe proporcionarse cada vez que se invoca.</span><span class="sxs-lookup"><span data-stu-id="28044-345">The resulting delegate represents an open instance method, and an instance of `C` must be supplied each time it is invoked.</span></span>  
  
-   <span data-ttu-id="28044-346">`D` puede representar un método estático que toma un argumento de tipo `C`, y que el método puede pertenecer a cualquier tipo.</span><span class="sxs-lookup"><span data-stu-id="28044-346">`D` can represent a static method that takes one argument of type `C`, and that method can belong to any type.</span></span> <span data-ttu-id="28044-347">Cuando <xref:System.Delegate.CreateDelegate%2A> se llama, `firstArgument` es una referencia nula.</span><span class="sxs-lookup"><span data-stu-id="28044-347">When <xref:System.Delegate.CreateDelegate%2A> is called, `firstArgument` is a null reference.</span></span> <span data-ttu-id="28044-348">El delegado resultante representa un método estático abierto y una instancia de `C` debe proporcionarse cada vez que se invoca.</span><span class="sxs-lookup"><span data-stu-id="28044-348">The resulting delegate represents an open static method, and an instance of `C` must be supplied each time it is invoked.</span></span>  
  
-   <span data-ttu-id="28044-349">`D` puede representar un método estático que pertenece al tipo `F` y tiene dos argumentos de tipo `F` y escriba `C`.</span><span class="sxs-lookup"><span data-stu-id="28044-349">`D` can represent a static method that belongs to type `F` and has two arguments, of type `F` and type `C`.</span></span> <span data-ttu-id="28044-350">Cuando <xref:System.Delegate.CreateDelegate%2A> se llama, `firstArgument` es una instancia de `F`.</span><span class="sxs-lookup"><span data-stu-id="28044-350">When <xref:System.Delegate.CreateDelegate%2A> is called, `firstArgument` is an instance of `F`.</span></span> <span data-ttu-id="28044-351">El delegado resultante representa un método estático que se cierra en esa instancia de `F`.</span><span class="sxs-lookup"><span data-stu-id="28044-351">The resulting delegate represents a static method that is closed over that instance of `F`.</span></span> <span data-ttu-id="28044-352">Tenga en cuenta que en el caso donde `F` y `C` son del mismo tipo, el método estático tiene dos argumentos de ese tipo.</span><span class="sxs-lookup"><span data-stu-id="28044-352">Note that in the case where `F` and `C` are the same type, the static method has two arguments of that type.</span></span> <span data-ttu-id="28044-353">(En este caso, `D` se cierra en una referencia nula si `firstArgument` es una referencia nula.)</span><span class="sxs-lookup"><span data-stu-id="28044-353">(In this case, `D` is closed over a null reference if `firstArgument` is a null reference.)</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="28044-354">Esta sección contiene tres ejemplos de código.</span><span class="sxs-lookup"><span data-stu-id="28044-354">This section contains three code examples.</span></span> <span data-ttu-id="28044-355">El primer ejemplo muestra los cuatro tipos de delegados que se pueden crear: cerrados a lo largo de un método de instancia, abra a través de un método de instancia, abra a través de un método estático y cerrados a lo largo de un método estático.</span><span class="sxs-lookup"><span data-stu-id="28044-355">The first example demonstrates the four kinds of delegates that can be created: closed over an instance method, open over an instance method, open over a static method, and closed over a static method.</span></span>  
  
 <span data-ttu-id="28044-356">El segundo ejemplo de código muestra los tipos de parámetros compatibles y tipos de valor devuelto.</span><span class="sxs-lookup"><span data-stu-id="28044-356">The second code example demonstrates compatible parameter types and return types.</span></span>  
  
 <span data-ttu-id="28044-357">El tercer ejemplo de código define un tipo de delegado único y muestra todos los métodos de ese tipo de delegado pueden representar.</span><span class="sxs-lookup"><span data-stu-id="28044-357">The third code example defines a single delegate type, and shows all the methods that delegate type can represent.</span></span>  
  
 <span data-ttu-id="28044-358">**Ejemplo 1**</span><span class="sxs-lookup"><span data-stu-id="28044-358">**Example 1**</span></span>  
  
 <span data-ttu-id="28044-359">En el ejemplo de código siguiente se muestra las cuatro maneras se puede crear un delegado utilizando esta sobrecarga de la <xref:System.Delegate.CreateDelegate%2A> método.</span><span class="sxs-lookup"><span data-stu-id="28044-359">The following code example demonstrates the four ways a delegate can be created using this overload of the <xref:System.Delegate.CreateDelegate%2A> method.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="28044-360">Hay dos sobrecargas de la <xref:System.Delegate.CreateDelegate%2A> método que especifican `firstArgument` y un <xref:System.Reflection.MethodInfo>; su funcionalidad es el mismo, salvo que uno le permite especificar si se producirá en error en el enlace y el otro siempre produce una excepción.</span><span class="sxs-lookup"><span data-stu-id="28044-360">There are two overloads of the <xref:System.Delegate.CreateDelegate%2A> method that specify `firstArgument` and a <xref:System.Reflection.MethodInfo>; their functionality is the same except that one allows you to specify whether to throw on failure to bind, and the other always throws.</span></span> <span data-ttu-id="28044-361">Este ejemplo de código utiliza ambas sobrecargas.</span><span class="sxs-lookup"><span data-stu-id="28044-361">This code example uses both overloads.</span></span>  
  
 <span data-ttu-id="28044-362">En el ejemplo se declara una clase `C` con un método estático `M2` y un método de instancia `M1`, y tres tipos de delegado: `D1` toma una instancia de `C` y una cadena, `D2` toma una cadena y `D3`no tiene ningún argumento.</span><span class="sxs-lookup"><span data-stu-id="28044-362">The example declares a class `C` with a static method `M2` and an instance method `M1`, and three delegate types: `D1` takes an instance of `C` and a string, `D2` takes a string, and `D3` has no arguments.</span></span>  
  
 <span data-ttu-id="28044-363">Una segunda clase denominada `Example` contiene el código que crea los delegados.</span><span class="sxs-lookup"><span data-stu-id="28044-363">A second class named `Example` contains the code that creates the delegates.</span></span>  
  
-   <span data-ttu-id="28044-364">Un delegado del tipo `D2`, cerrado sobre una instancia de `C`, se crea para el método de instancia `M1`.</span><span class="sxs-lookup"><span data-stu-id="28044-364">A delegate of type `D2`, closed over an instance of `C`, is created for the instance method `M1`.</span></span> <span data-ttu-id="28044-365">Se invoca con cadenas diferentes, para mostrar que la instancia enlazada de `C` siempre se utiliza.</span><span class="sxs-lookup"><span data-stu-id="28044-365">It is invoked with different strings, to show that the bound instance of `C` is always used.</span></span>  
  
-   <span data-ttu-id="28044-366">Un delegado del tipo `D1`, que representa un método de instancia abierta, se crea para el método de instancia `M1`.</span><span class="sxs-lookup"><span data-stu-id="28044-366">A delegate of type `D1`, representing an open instance method, is created for the instance method `M1`.</span></span> <span data-ttu-id="28044-367">Debe pasar una instancia cuando se invoca el delegado.</span><span class="sxs-lookup"><span data-stu-id="28044-367">An instance must be passed when the delegate is invoked.</span></span>  
  
-   <span data-ttu-id="28044-368">Un delegado del tipo `D2`, que representa un método estático abierto, se crea para el método estático `M2`.</span><span class="sxs-lookup"><span data-stu-id="28044-368">A delegate of type `D2`, representing an open static method, is created for the static method `M2`.</span></span>  
  
-   <span data-ttu-id="28044-369">Por último, un delegado del tipo `D3`, cerrados a lo largo de una cadena, se crea para el método estático `M2`.</span><span class="sxs-lookup"><span data-stu-id="28044-369">Finally, a delegate of type `D3`, closed over a string, is created for the static method `M2`.</span></span> <span data-ttu-id="28044-370">Se invoca el método para mostrar que utiliza la cadena enlazada.</span><span class="sxs-lookup"><span data-stu-id="28044-370">The method is invoked to show that it uses the bound string.</span></span>  
  
 [!code-csharp[Delegate.CreateDelegateTOM#1](~/samples/snippets/csharp/VS_Snippets_CLR/Delegate.CreateDelegateTOM/cs/openClosedOver.cs#1)]
 [!code-vb[Delegate.CreateDelegateTOM#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Delegate.CreateDelegateTOM/VB/openClosedOver.vb#1)]  
  
 <span data-ttu-id="28044-371">**Ejemplo 2**</span><span class="sxs-lookup"><span data-stu-id="28044-371">**Example 2**</span></span>  
  
 <span data-ttu-id="28044-372">En el ejemplo de código siguiente se muestra la compatibilidad de tipos de parámetro y tipos de valor devuelto.</span><span class="sxs-lookup"><span data-stu-id="28044-372">The following code example demonstrates compatibility of parameter types and return types.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="28044-373">Este ejemplo de código se utiliza el <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Reflection.MethodInfo%29> sobrecarga del método.</span><span class="sxs-lookup"><span data-stu-id="28044-373">This code example uses the <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Reflection.MethodInfo%29> method overload.</span></span> <span data-ttu-id="28044-374">El uso de otras sobrecargas que toman <xref:System.Reflection.MethodInfo> es similar.</span><span class="sxs-lookup"><span data-stu-id="28044-374">The use of other overloads that take <xref:System.Reflection.MethodInfo> is similar.</span></span>  
  
 <span data-ttu-id="28044-375">El ejemplo de código define una clase base denominada `Base` y una clase denominada `Derived` que se deriva de `Base`.</span><span class="sxs-lookup"><span data-stu-id="28044-375">The code example defines a base class named `Base` and a class named `Derived` that derives from `Base`.</span></span> <span data-ttu-id="28044-376">La clase derivada tiene un `static` (`Shared` en Visual Basic) con el nombre de método `MyMethod` con un parámetro de tipo `Base` y un tipo de valor devuelto de `Derived`.</span><span class="sxs-lookup"><span data-stu-id="28044-376">The derived class has a `static` (`Shared` in Visual Basic) method named `MyMethod` with one parameter of type `Base` and a return type of `Derived`.</span></span> <span data-ttu-id="28044-377">El ejemplo de código también define un delegado denominado `Example` que tiene un parámetro de tipo `Derived` y un tipo de valor devuelto de `Base`.</span><span class="sxs-lookup"><span data-stu-id="28044-377">The code example also defines a delegate named `Example` that has one parameter of type `Derived` and a return type of `Base`.</span></span>  
  
 <span data-ttu-id="28044-378">El ejemplo de código se muestra que el delegado denominado `Example` puede usarse para representar el método `MyMethod`.</span><span class="sxs-lookup"><span data-stu-id="28044-378">The code example demonstrates that the delegate named `Example` can be used to represent the method `MyMethod`.</span></span> <span data-ttu-id="28044-379">El método se puede enlazar al delegado porque:</span><span class="sxs-lookup"><span data-stu-id="28044-379">The method can be bound to the delegate because:</span></span>  
  
-   <span data-ttu-id="28044-380">El tipo de parámetro del delegado (`Derived`) es más restrictivo que el tipo de parámetro `MyMethod` (`Base`), de modo que siempre es seguro pasar el argumento del delegado al que `MyMethod`.</span><span class="sxs-lookup"><span data-stu-id="28044-380">The parameter type of the delegate (`Derived`) is more restrictive than the parameter type of `MyMethod` (`Base`), so that it is always safe to pass the argument of the delegate to `MyMethod`.</span></span>  
  
-   <span data-ttu-id="28044-381">El tipo de valor devuelto de `MyMethod` (`Derived`) es más restrictivo que el tipo de parámetro del delegado (`Base`), de modo que siempre es seguro convertir el tipo de valor devuelto del método para el tipo de valor devuelto del delegado.</span><span class="sxs-lookup"><span data-stu-id="28044-381">The return type of `MyMethod` (`Derived`) is more restrictive than the parameter type of the delegate (`Base`), so that it is always safe to cast the return type of the method to the return type of the delegate.</span></span>  
  
 <span data-ttu-id="28044-382">El ejemplo de código no produce ningún resultado.</span><span class="sxs-lookup"><span data-stu-id="28044-382">The code example produces no output.</span></span>  
  
 [!code-cpp[Delegate.CreateDelegate_RelaxedFit#1](~/samples/snippets/cpp/VS_Snippets_CLR/Delegate.CreateDelegate_RelaxedFit/cpp/source.cpp#1)]
 [!code-csharp[Delegate.CreateDelegate_RelaxedFit#1](~/samples/snippets/csharp/VS_Snippets_CLR/Delegate.CreateDelegate_RelaxedFit/cs/source.cs#1)]
 [!code-vb[Delegate.CreateDelegate_RelaxedFit#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Delegate.CreateDelegate_RelaxedFit/vb/source.vb#1)]  
  
 <span data-ttu-id="28044-383">**Ejemplo 3**</span><span class="sxs-lookup"><span data-stu-id="28044-383">**Example 3**</span></span>  
  
 <span data-ttu-id="28044-384">En el ejemplo de código siguiente se muestra todos los métodos puede representar un tipo de delegado único, utilizando el <xref:System.Delegate.CreateDelegate%2A> método para crear los delegados.</span><span class="sxs-lookup"><span data-stu-id="28044-384">The following code example shows all the methods a single delegate type can represent, using the <xref:System.Delegate.CreateDelegate%2A> method to create the delegates.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="28044-385">Hay dos sobrecargas de la <xref:System.Delegate.CreateDelegate%2A> método que especifican `firstArgument` y un <xref:System.Reflection.MethodInfo>; su funcionalidad es el mismo, salvo que uno le permite especificar si se producirá en error en el enlace y el otro siempre produce una excepción.</span><span class="sxs-lookup"><span data-stu-id="28044-385">There are two overloads of the <xref:System.Delegate.CreateDelegate%2A> method that specify `firstArgument` and a <xref:System.Reflection.MethodInfo>; their functionality is the same except that one allows you to specify whether to throw on failure to bind, and the other always throws.</span></span> <span data-ttu-id="28044-386">Este ejemplo de código utiliza ambas sobrecargas.</span><span class="sxs-lookup"><span data-stu-id="28044-386">This code example uses both overloads.</span></span>  
  
 <span data-ttu-id="28044-387">El ejemplo de código define dos clases, `C` y `F`y un tipo de delegado `D` con un argumento de tipo `C`.</span><span class="sxs-lookup"><span data-stu-id="28044-387">The code example defines two classes, `C` and `F`, and a delegate type `D` with one argument of type `C`.</span></span> <span data-ttu-id="28044-388">Las clases tienen coincidentes estáticos y métodos de instancia `M1`, `M3`, y `M4`y la clase `C` también tiene un método de instancia `M2` que no tiene ningún argumento.</span><span class="sxs-lookup"><span data-stu-id="28044-388">The classes have matching static and instance methods `M1`, `M3`, and `M4`, and class `C` also has an instance method `M2` that has no arguments.</span></span>  
  
 <span data-ttu-id="28044-389">Una tercera clase denominada `Example` contiene el código que crea los delegados.</span><span class="sxs-lookup"><span data-stu-id="28044-389">A third class named `Example` contains the code that creates the delegates.</span></span>  
  
-   <span data-ttu-id="28044-390">Los delegados se crean para la instancia método `M1` de tipo `C` y el tipo de `F`; cada uno se cierra sobre una instancia del tipo correspondiente.</span><span class="sxs-lookup"><span data-stu-id="28044-390">Delegates are created for instance method `M1` of type `C` and type `F`; each is closed over an instance of the respective type.</span></span> <span data-ttu-id="28044-391">Método `M1` de tipo `C` muestra la `ID` propiedades de la instancia enlazada y del argumento.</span><span class="sxs-lookup"><span data-stu-id="28044-391">Method `M1` of type `C` displays the `ID` properties of the bound instance and of the argument.</span></span>  
  
-   <span data-ttu-id="28044-392">Se crea un delegado para el método `M2` de tipo `C`.</span><span class="sxs-lookup"><span data-stu-id="28044-392">A delegate is created for method `M2` of type `C`.</span></span> <span data-ttu-id="28044-393">Se trata de un delegado de instancia abierto, en la que el argumento del delegado representa el primer argumento oculto en el método de instancia.</span><span class="sxs-lookup"><span data-stu-id="28044-393">This is an open instance delegate, in which the argument of the delegate represents the hidden first argument on the instance method.</span></span> <span data-ttu-id="28044-394">El método no tiene ningún otro argumento.</span><span class="sxs-lookup"><span data-stu-id="28044-394">The method has no other arguments.</span></span> <span data-ttu-id="28044-395">Se llama como si fuera un método estático.</span><span class="sxs-lookup"><span data-stu-id="28044-395">It is called as if it were a static method.</span></span>  
  
-   <span data-ttu-id="28044-396">Se crean delegados para el método estático `M3` de tipo `C` y tipo `F`; se trata de delegados estáticos abiertos.</span><span class="sxs-lookup"><span data-stu-id="28044-396">Delegates are created for static method `M3` of type `C` and type `F`; these are open static delegates.</span></span>  
  
-   <span data-ttu-id="28044-397">Por último, se crean delegados para el método estático `M4` de tipo `C` y tipo `F`; cada método tiene el tipo declarativo como primer argumento y se proporciona una instancia del tipo, por lo que los delegados se cierran en sus primeros argumentos .</span><span class="sxs-lookup"><span data-stu-id="28044-397">Finally, delegates are created for static method `M4` of type `C` and type `F`; each method has the declaring type as its first argument, and an instance of the type is supplied, so the delegates are closed over their first arguments.</span></span> <span data-ttu-id="28044-398">Método `M4` de tipo `C` muestra la `ID` propiedades de la instancia enlazada y del argumento.</span><span class="sxs-lookup"><span data-stu-id="28044-398">Method `M4` of type `C` displays the `ID` properties of the bound instance and of the argument.</span></span>  
  
 [!code-csharp[Delegate.CreateDelegateTOM_2#1](~/samples/snippets/csharp/VS_Snippets_CLR/Delegate.CreateDelegateTOM_2/cs/source.cs#1)]
 [!code-vb[Delegate.CreateDelegateTOM_2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Delegate.CreateDelegateTOM_2/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="28044-399">
            <paramref name="type" /> es <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="28044-399">
              <paramref name="type" /> is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="28044-400">O bien</span>
          <span class="sxs-lookup">
            <span data-stu-id="28044-400">-or-</span>
          </span>
          <span data-ttu-id="28044-401">
            <paramref name="method" /> es <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="28044-401">
              <paramref name="method" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="28044-402">
            <paramref name="type" /> no hereda <see cref="T:System.MulticastDelegate" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="28044-402">
              <paramref name="type" /> does not inherit <see cref="T:System.MulticastDelegate" />.</span>
          </span>
          <span data-ttu-id="28044-403">O bien</span>
          <span class="sxs-lookup">
            <span data-stu-id="28044-403">-or-</span>
          </span>
          <span data-ttu-id="28044-404">
            <paramref name="type" /> no es un <see langword="RuntimeType" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="28044-404">
              <paramref name="type" /> is not a <see langword="RuntimeType" />.</span>
          </span>
          <span data-ttu-id="28044-405">Vea [Tipos de reflexión en tiempo de ejecución](http://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858).</span>
          <span class="sxs-lookup">
            <span data-stu-id="28044-405">See [Runtime Types in Reflection](http://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858).</span>
          </span>
          <span data-ttu-id="28044-406">O bien</span>
          <span class="sxs-lookup">
            <span data-stu-id="28044-406">-or-</span>
          </span>
          <span data-ttu-id="28044-407">No se puede enlazar <paramref name="method" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="28044-407">
              <paramref name="method" /> cannot be bound.</span>
          </span>
          <span data-ttu-id="28044-408">O bien</span>
          <span class="sxs-lookup">
            <span data-stu-id="28044-408">-or-</span>
          </span>
          <span data-ttu-id="28044-409">
            <paramref name="method" /> no es un <see langword="RuntimeMethodInfo" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="28044-409">
              <paramref name="method" /> is not a <see langword="RuntimeMethodInfo" />.</span>
          </span>
          <span data-ttu-id="28044-410">Vea [Tipos de reflexión en tiempo de ejecución](http://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858).</span>
          <span class="sxs-lookup">
            <span data-stu-id="28044-410">See [Runtime Types in Reflection](http://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858).</span>
          </span>
        </exception>
        <exception cref="T:System.MissingMethodException">
          <span data-ttu-id="28044-411">No se encuentra el método <see langword="Invoke" /> de <paramref name="type" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="28044-411">The <see langword="Invoke" /> method of <paramref name="type" /> is not found.</span>
          </span>
        </exception>
        <exception cref="T:System.MethodAccessException">
          <span data-ttu-id="28044-412">El autor de la llamada no tiene los permisos necesarios para acceder a <paramref name="method" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="28044-412">The caller does not have the permissions necessary to access <paramref name="method" />.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">
          <span data-ttu-id="28044-413">Cuando se invoca en tiempo de ejecución a través de mecanismos como <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="28044-413">when invoked late-bound through mechanisms such as <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span>
          </span>
          <span data-ttu-id="28044-414">Enumeración asociada: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="28044-414">Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</span>
          </span>
        </permission>
        <altmember cref="T:System.Type" />
        <altmember cref="T:System.MulticastDelegate" />
        <altmember cref="T:System.Security.Permissions.ReflectionPermission" />
        <altmember cref="T:System.Reflection.MethodInfo" />
      </Docs>
    </Member>
    <Member MemberName="CreateDelegate">
      <MemberSignature Language="C#" Value="public static Delegate CreateDelegate (Type type, object target, string method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Delegate CreateDelegate(class System.Type type, object target, string method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Delegate ^ CreateDelegate(Type ^ type, System::Object ^ target, System::String ^ method);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="target" Type="System.Object" />
        <Parameter Name="method" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="type">
          <span data-ttu-id="28044-415">
            <see cref="T:System.Type" /> de delegado que se va a crear.</span>
          <span class="sxs-lookup">
            <span data-stu-id="28044-415">The <see cref="T:System.Type" /> of delegate to create.</span>
          </span>
        </param>
        <param name="target">
          <span data-ttu-id="28044-416">Instancia de clase en la que se invoca a <c>method</c>.</span>
          <span class="sxs-lookup">
            <span data-stu-id="28044-416">The class instance on which <c>method</c> is invoked.</span>
          </span>
        </param>
        <param name="method">
          <span data-ttu-id="28044-417">Nombre del método de instancia que el delegado va a representar.</span>
          <span class="sxs-lookup">
            <span data-stu-id="28044-417">The name of the instance method that the delegate is to represent.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="28044-418">Crea un delegado del tipo especificado que representa el método de instancia especificado que se va a invocar en la instancia de clase especificada.</span>
          <span class="sxs-lookup">
            <span data-stu-id="28044-418">Creates a delegate of the specified type that represents the specified instance method to invoke on the specified class instance.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="28044-419">Delegado del tipo especificado que representa el método de instancia especificado que se va a invocar en la instancia de clase especificada.</span>
          <span class="sxs-lookup">
            <span data-stu-id="28044-419">A delegate of the specified type that represents the specified instance method to invoke on the specified class instance.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="28044-420">Este método sólo crea a delegados para la instancia métodos.</span><span class="sxs-lookup"><span data-stu-id="28044-420">This method creates delegates for instance methods only.</span></span> <span data-ttu-id="28044-421">Un método de instancia es un método que está asociado a una instancia de una clase; un método estático es un método que está asociado a la propia clase.</span><span class="sxs-lookup"><span data-stu-id="28044-421">An instance method is a method that is associated with an instance of a class; a static method is a method that is associated with the class itself.</span></span>  
  
 <span data-ttu-id="28044-422">Esta sobrecarga del método es equivalente a llamar a la <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Object%2CSystem.String%2CSystem.Boolean%2CSystem.Boolean%29> sobrecarga del método, especificando `false` para `ignoreCase` y `true` para `throwOnBindFailure`.</span><span class="sxs-lookup"><span data-stu-id="28044-422">This method overload is equivalent to calling the <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Object%2CSystem.String%2CSystem.Boolean%2CSystem.Boolean%29> method overload, specifying `false` for `ignoreCase` and `true` for `throwOnBindFailure`.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="28044-423">A partir de la [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], este método se puede utilizar para tener acceso a los métodos no públicos si se ha concedido el autor de llamada <xref:System.Security.Permissions.ReflectionPermission> con el <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> marca y, si el conjunto de permisos de los métodos no públicos se restringe al llamador conceda conjunto o un subconjunto de los mismos.</span><span class="sxs-lookup"><span data-stu-id="28044-423">Starting with the [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], this method can be used to access non-public methods if the caller has been granted <xref:System.Security.Permissions.ReflectionPermission> with the <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> flag and if the grant set of the non-public methods is restricted to the caller’s grant set, or a subset thereof.</span></span> <span data-ttu-id="28044-424">(Consulte [consideraciones de seguridad para la reflexión](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)</span><span class="sxs-lookup"><span data-stu-id="28044-424">(See [Security Considerations for Reflection](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)</span></span>  
>   
>  <span data-ttu-id="28044-425">Para utilizar esta funcionalidad, la aplicación debe utilizar [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] o posterior como destino.</span><span class="sxs-lookup"><span data-stu-id="28044-425">To use this functionality, your application should target the [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] or later.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="28044-426">
            <paramref name="type" /> es <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="28044-426">
              <paramref name="type" /> is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="28044-427">O bien</span>
          <span class="sxs-lookup">
            <span data-stu-id="28044-427">-or-</span>
          </span>
          <span data-ttu-id="28044-428">
            <paramref name="target" /> es <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="28044-428">
              <paramref name="target" /> is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="28044-429">O bien</span>
          <span class="sxs-lookup">
            <span data-stu-id="28044-429">-or-</span>
          </span>
          <span data-ttu-id="28044-430">
            <paramref name="method" /> es <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="28044-430">
              <paramref name="method" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="28044-431">
            <paramref name="type" /> no hereda <see cref="T:System.MulticastDelegate" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="28044-431">
              <paramref name="type" /> does not inherit <see cref="T:System.MulticastDelegate" />.</span>
          </span>
          <span data-ttu-id="28044-432">O bien</span>
          <span class="sxs-lookup">
            <span data-stu-id="28044-432">-or-</span>
          </span>
          <span data-ttu-id="28044-433">
            <paramref name="type" /> no es un <see langword="RuntimeType" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="28044-433">
              <paramref name="type" /> is not a <see langword="RuntimeType" />.</span>
          </span>
          <span data-ttu-id="28044-434">Vea [Tipos de reflexión en tiempo de ejecución](http://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858).</span>
          <span class="sxs-lookup">
            <span data-stu-id="28044-434">See [Runtime Types in Reflection](http://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858).</span>
          </span>
          <span data-ttu-id="28044-435">O bien</span>
          <span class="sxs-lookup">
            <span data-stu-id="28044-435">-or-</span>
          </span>
          <span data-ttu-id="28044-436">
            <paramref name="method" /> no es un método de instancia.</span>
          <span class="sxs-lookup">
            <span data-stu-id="28044-436">
              <paramref name="method" /> is not an instance method.</span>
          </span>
          <span data-ttu-id="28044-437">O bien</span>
          <span class="sxs-lookup">
            <span data-stu-id="28044-437">-or-</span>
          </span>
          <span data-ttu-id="28044-438">
            <paramref name="method" /> no se puede enlazar, por ejemplo, porque no se encuentra.</span>
          <span class="sxs-lookup">
            <span data-stu-id="28044-438">
              <paramref name="method" /> cannot be bound, for example because it cannot be found.</span>
          </span>
        </exception>
        <exception cref="T:System.MissingMethodException">
          <span data-ttu-id="28044-439">No se encuentra el método <see langword="Invoke" /> de <paramref name="type" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="28044-439">The <see langword="Invoke" /> method of <paramref name="type" /> is not found.</span>
          </span>
        </exception>
        <exception cref="T:System.MethodAccessException">
          <span data-ttu-id="28044-440">El autor de la llamada no tiene los permisos necesarios para acceder a <paramref name="method" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="28044-440">The caller does not have the permissions necessary to access <paramref name="method" />.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">
          <span data-ttu-id="28044-441">Cuando se invoca en tiempo de ejecución a través de mecanismos como <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="28044-441">when invoked late-bound through mechanisms such as <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span>
          </span>
          <span data-ttu-id="28044-442">Enumeración asociada: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="28044-442">Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</span>
          </span>
        </permission>
        <altmember cref="T:System.Type" />
        <altmember cref="T:System.MulticastDelegate" />
        <altmember cref="T:System.Security.Permissions.ReflectionPermission" />
        <altmember cref="T:System.Object" />
      </Docs>
    </Member>
    <Member MemberName="CreateDelegate">
      <MemberSignature Language="C#" Value="public static Delegate CreateDelegate (Type type, System.Reflection.MethodInfo method, bool throwOnBindFailure);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Delegate CreateDelegate(class System.Type type, class System.Reflection.MethodInfo method, bool throwOnBindFailure) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Delegate ^ CreateDelegate(Type ^ type, System::Reflection::MethodInfo ^ method, bool throwOnBindFailure);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
        <Parameter Name="throwOnBindFailure" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="type">
          <span data-ttu-id="28044-443">
            <see cref="T:System.Type" /> de delegado que se va a crear.</span>
          <span class="sxs-lookup">
            <span data-stu-id="28044-443">The <see cref="T:System.Type" /> of delegate to create.</span>
          </span>
        </param>
        <param name="method">
          <span data-ttu-id="28044-444">
            <see cref="T:System.Reflection.MethodInfo" /> que describe el método estático o de instancia que va a representar el delegado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="28044-444">The <see cref="T:System.Reflection.MethodInfo" /> describing the static or instance method the delegate is to represent.</span>
          </span>
        </param>
        <param name="throwOnBindFailure">
          <span data-ttu-id="28044-445">Es <see langword="true" /> para iniciar una excepción si no se puede enlazar <c>method</c>; en caso contrario, es <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="28044-445">
              <see langword="true" /> to throw an exception if <c>method</c> cannot be bound; otherwise, <see langword="false" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="28044-446">Crea un delegado del tipo especificado para representar el método estático especificado, con el comportamiento establecido para el caso de que se produzca un error al enlazar.</span>
          <span class="sxs-lookup">
            <span data-stu-id="28044-446">Creates a delegate of the specified type to represent the specified static method, with the specified behavior on failure to bind.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="28044-447">Delegado del tipo especificado para representar el método estático especificado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="28044-447">A delegate of the specified type to represent the specified static method.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="28044-448">Esta sobrecarga del método puede crear delegados de método estático abierto y abrir los delegados de método de instancia, es decir, los delegados que exponen el primer argumento oculto de métodos de instancia.</span><span class="sxs-lookup"><span data-stu-id="28044-448">This method overload can create open static method delegates and open instance method delegates — that is, delegates that expose the hidden first argument of instance methods.</span></span> <span data-ttu-id="28044-449">Para obtener una explicación detallada, vea más general <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Object%2CSystem.Reflection.MethodInfo%2CSystem.Boolean%29> sobrecarga del método, que le permite crear todas las combinaciones de delegados abiertos o cerrados para la instancia o métodos estáticos.</span><span class="sxs-lookup"><span data-stu-id="28044-449">For a detailed explanation, see the more general <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Object%2CSystem.Reflection.MethodInfo%2CSystem.Boolean%29> method overload, which allows you to create all combinations of open or closed delegates for instance or static methods.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="28044-450">Esta sobrecarga del método se debe usar cuando el delegado no se cierra en su primer argumento, porque en ese caso es algo más rápido.</span><span class="sxs-lookup"><span data-stu-id="28044-450">This method overload should be used when the delegate is not closed over its first argument, because it is somewhat faster in that case.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="28044-451">A partir de la [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], este método se puede utilizar para tener acceso a los métodos no públicos si se ha concedido el autor de llamada <xref:System.Security.Permissions.ReflectionPermission> con el <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> marca y, si el conjunto de permisos de los métodos no públicos se restringe al llamador conceda conjunto o un subconjunto de los mismos.</span><span class="sxs-lookup"><span data-stu-id="28044-451">Starting with the [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], this method can be used to access non-public methods if the caller has been granted <xref:System.Security.Permissions.ReflectionPermission> with the <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> flag and if the grant set of the non-public methods is restricted to the caller’s grant set, or a subset thereof.</span></span> <span data-ttu-id="28044-452">(Consulte [consideraciones de seguridad para la reflexión](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)</span><span class="sxs-lookup"><span data-stu-id="28044-452">(See [Security Considerations for Reflection](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)</span></span>  
>   
>  <span data-ttu-id="28044-453">Para utilizar esta funcionalidad, la aplicación debe utilizar [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] o posterior como destino.</span><span class="sxs-lookup"><span data-stu-id="28044-453">To use this functionality, your application should target the [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] or later.</span></span>  
  
## <a name="compatible-parameter-types-and-return-type"></a><span data-ttu-id="28044-454">Tipos de parámetro compatible y tipo de valor devuelto</span><span class="sxs-lookup"><span data-stu-id="28044-454">Compatible Parameter Types and Return Type</span></span>  
 <span data-ttu-id="28044-455">Los tipos de parámetro y el tipo de valor devuelto de un delegado deben ser compatibles con los tipos de parámetro y el tipo de valor devuelto del método que representa el delegado; los tipos no tienen que coincidir exactamente.</span><span class="sxs-lookup"><span data-stu-id="28044-455">The parameter types and return type of a delegate must be compatible with the parameter types and return type of the method the delegate represents; the types do not have to match exactly.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="28044-456">En la versión 1.0 y 1.1 de .NET Framework, los tipos deben coincidir exactamente.</span><span class="sxs-lookup"><span data-stu-id="28044-456">In the .NET Framework version 1.0 and 1.1, the types must match exactly.</span></span>  
  
 <span data-ttu-id="28044-457">Un parámetro de un delegado es compatible con el parámetro correspondiente de un método si el tipo del parámetro del delegado es más restrictivo que el del método, porque así se garantiza que el argumento que se pase al delegado también se podrá pasar de forma segura al método.</span><span class="sxs-lookup"><span data-stu-id="28044-457">A parameter of a delegate is compatible with the corresponding parameter of a method if the type of the delegate parameter is more restrictive than the type of the method parameter, because this guarantees that an argument passed to the delegate can be passed safely to the method.</span></span>  
  
 <span data-ttu-id="28044-458">De forma similar, el tipo de devolución de un delegado es compatible con el tipo de devolución de un método si el del método es más restrictivo que el del delegado, porque así se garantiza que el valor devuelto por el método se puede convertir con seguridad al tipo de devolución del delegado.</span><span class="sxs-lookup"><span data-stu-id="28044-458">Similarly, the return type of a delegate is compatible with the return type of a method if the return type of the method is more restrictive than the return type of the delegate, because this guarantees that the return value of the method can be cast safely to the return type of the delegate.</span></span>  
  
 <span data-ttu-id="28044-459">Por ejemplo, un delegado con un parámetro de tipo <xref:System.Collections.Hashtable> y un tipo de valor devuelto de <xref:System.Object> puede representar un método con un parámetro de tipo <xref:System.Object> y un valor devuelto de tipo <xref:System.Collections.Hashtable>.</span><span class="sxs-lookup"><span data-stu-id="28044-459">For example, a delegate with a parameter of type <xref:System.Collections.Hashtable> and a return type of <xref:System.Object> can represent a method with a parameter of type <xref:System.Object> and a return value of type <xref:System.Collections.Hashtable>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="28044-460">Esta sección contiene dos ejemplos de código.</span><span class="sxs-lookup"><span data-stu-id="28044-460">This section contains two code examples.</span></span> <span data-ttu-id="28044-461">El primer ejemplo muestra los dos tipos de delegados que se pueden crear con esta sobrecarga del método: abra a través de un método de instancia y a través de un método estático.</span><span class="sxs-lookup"><span data-stu-id="28044-461">The first example demonstrates the two kinds of delegates that can be created with this method overload: open over an instance method and open over a static method.</span></span>  
  
 <span data-ttu-id="28044-462">El segundo ejemplo de código muestra los tipos de parámetros compatibles y tipos de valor devuelto.</span><span class="sxs-lookup"><span data-stu-id="28044-462">The second code example demonstrates compatible parameter types and return types.</span></span>  
  
 <span data-ttu-id="28044-463">**Ejemplo 1**</span><span class="sxs-lookup"><span data-stu-id="28044-463">**Example 1**</span></span>  
  
 <span data-ttu-id="28044-464">En el ejemplo de código siguiente se muestra las dos maneras se puede crear un delegado utilizando esta sobrecarga de la <xref:System.Delegate.CreateDelegate%2A> método.</span><span class="sxs-lookup"><span data-stu-id="28044-464">The following code example demonstrates the two ways a delegate can be created using this overload of the <xref:System.Delegate.CreateDelegate%2A> method.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="28044-465">Hay dos sobrecargas de la <xref:System.Delegate.CreateDelegate%2A> método que especifican un <xref:System.Reflection.MethodInfo> pero no un primer argumento; su funcionalidad es el mismo, salvo que uno le permite especificar si se producirá en error en el enlace y el otro siempre produce una excepción.</span><span class="sxs-lookup"><span data-stu-id="28044-465">There are two overloads of the <xref:System.Delegate.CreateDelegate%2A> method that specify a <xref:System.Reflection.MethodInfo> but not a first argument; their functionality is the same except that one allows you to specify whether to throw on failure to bind, and the other always throws.</span></span> <span data-ttu-id="28044-466">Este ejemplo de código utiliza ambas sobrecargas.</span><span class="sxs-lookup"><span data-stu-id="28044-466">This code example uses both overloads.</span></span>  
  
 <span data-ttu-id="28044-467">En el ejemplo se declara una clase `C` con un método estático `M2` y un método de instancia `M1`, y dos tipos de delegado: `D1` toma una instancia de `C` y una cadena, y `D2` toma una cadena.</span><span class="sxs-lookup"><span data-stu-id="28044-467">The example declares a class `C` with a static method `M2` and an instance method `M1`, and two delegate types: `D1` takes an instance of `C` and a string, and `D2` takes a string.</span></span>  
  
 <span data-ttu-id="28044-468">Una segunda clase denominada `Example` contiene el código que crea los delegados.</span><span class="sxs-lookup"><span data-stu-id="28044-468">A second class named `Example` contains the code that creates the delegates.</span></span>  
  
-   <span data-ttu-id="28044-469">Un delegado del tipo `D1`, que representa un método de instancia abierta, se crea para el método de instancia `M1`.</span><span class="sxs-lookup"><span data-stu-id="28044-469">A delegate of type `D1`, representing an open instance method, is created for the instance method `M1`.</span></span> <span data-ttu-id="28044-470">Debe pasar una instancia cuando se invoca el delegado.</span><span class="sxs-lookup"><span data-stu-id="28044-470">An instance must be passed when the delegate is invoked.</span></span>  
  
-   <span data-ttu-id="28044-471">Un delegado del tipo `D2`, que representa un método estático abierto, se crea para el método estático `M2`.</span><span class="sxs-lookup"><span data-stu-id="28044-471">A delegate of type `D2`, representing an open static method, is created for the static method `M2`.</span></span>  
  
 [!code-csharp[Delegate.CreateDelegateTOM#1](~/samples/snippets/csharp/VS_Snippets_CLR/Delegate.CreateDelegateTOM/cs/openClosedOver.cs#1)]
 [!code-vb[Delegate.CreateDelegateTOM#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Delegate.CreateDelegateTOM/VB/openClosedOver.vb#1)]  
  
 <span data-ttu-id="28044-472">**Ejemplo 2**</span><span class="sxs-lookup"><span data-stu-id="28044-472">**Example 2**</span></span>  
  
 <span data-ttu-id="28044-473">En el ejemplo de código siguiente se muestra la compatibilidad de tipos de parámetro y tipos de valor devuelto.</span><span class="sxs-lookup"><span data-stu-id="28044-473">The following code example demonstrates compatibility of parameter types and return types.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="28044-474">Este ejemplo de código se utiliza el <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Reflection.MethodInfo%29> sobrecarga del método.</span><span class="sxs-lookup"><span data-stu-id="28044-474">This code example uses the <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Reflection.MethodInfo%29> method overload.</span></span> <span data-ttu-id="28044-475">El uso de otras sobrecargas que toman <xref:System.Reflection.MethodInfo> es similar.</span><span class="sxs-lookup"><span data-stu-id="28044-475">The use of other overloads that take <xref:System.Reflection.MethodInfo> is similar.</span></span>  
  
 <span data-ttu-id="28044-476">El ejemplo de código define una clase base denominada `Base` y una clase denominada `Derived` que se deriva de `Base`.</span><span class="sxs-lookup"><span data-stu-id="28044-476">The code example defines a base class named `Base` and a class named `Derived` that derives from `Base`.</span></span> <span data-ttu-id="28044-477">La clase derivada tiene un `static` (`Shared` en Visual Basic) con el nombre de método `MyMethod` con un parámetro de tipo `Base` y un tipo de valor devuelto de `Derived`.</span><span class="sxs-lookup"><span data-stu-id="28044-477">The derived class has a `static` (`Shared` in Visual Basic) method named `MyMethod` with one parameter of type `Base` and a return type of `Derived`.</span></span> <span data-ttu-id="28044-478">El ejemplo de código también define un delegado denominado `Example` que tiene un parámetro de tipo `Derived` y un tipo de valor devuelto de `Base`.</span><span class="sxs-lookup"><span data-stu-id="28044-478">The code example also defines a delegate named `Example` that has one parameter of type `Derived` and a return type of `Base`.</span></span>  
  
 <span data-ttu-id="28044-479">El ejemplo de código se muestra que el delegado denominado `Example` puede usarse para representar el método `MyMethod`.</span><span class="sxs-lookup"><span data-stu-id="28044-479">The code example demonstrates that the delegate named `Example` can be used to represent the method `MyMethod`.</span></span> <span data-ttu-id="28044-480">El método se puede enlazar al delegado porque:</span><span class="sxs-lookup"><span data-stu-id="28044-480">The method can be bound to the delegate because:</span></span>  
  
-   <span data-ttu-id="28044-481">El tipo de parámetro del delegado (`Derived`) es más restrictivo que el tipo de parámetro `MyMethod` (`Base`), de modo que siempre es seguro pasar el argumento del delegado al que `MyMethod`.</span><span class="sxs-lookup"><span data-stu-id="28044-481">The parameter type of the delegate (`Derived`) is more restrictive than the parameter type of `MyMethod` (`Base`), so that it is always safe to pass the argument of the delegate to `MyMethod`.</span></span>  
  
-   <span data-ttu-id="28044-482">El tipo de valor devuelto de `MyMethod` (`Derived`) es más restrictivo que el tipo de parámetro del delegado (`Base`), de modo que siempre es seguro convertir el tipo de valor devuelto del método para el tipo de valor devuelto del delegado.</span><span class="sxs-lookup"><span data-stu-id="28044-482">The return type of `MyMethod` (`Derived`) is more restrictive than the parameter type of the delegate (`Base`), so that it is always safe to cast the return type of the method to the return type of the delegate.</span></span>  
  
 <span data-ttu-id="28044-483">El ejemplo de código no produce ningún resultado.</span><span class="sxs-lookup"><span data-stu-id="28044-483">The code example produces no output.</span></span>  
  
 [!code-cpp[Delegate.CreateDelegate_RelaxedFit#1](~/samples/snippets/cpp/VS_Snippets_CLR/Delegate.CreateDelegate_RelaxedFit/cpp/source.cpp#1)]
 [!code-csharp[Delegate.CreateDelegate_RelaxedFit#1](~/samples/snippets/csharp/VS_Snippets_CLR/Delegate.CreateDelegate_RelaxedFit/cs/source.cs#1)]
 [!code-vb[Delegate.CreateDelegate_RelaxedFit#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Delegate.CreateDelegate_RelaxedFit/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="28044-484">
            <paramref name="type" /> es <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="28044-484">
              <paramref name="type" /> is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="28044-485">O bien</span>
          <span class="sxs-lookup">
            <span data-stu-id="28044-485">-or-</span>
          </span>
          <span data-ttu-id="28044-486">
            <paramref name="method" /> es <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="28044-486">
              <paramref name="method" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="28044-487">
            <paramref name="type" /> no hereda <see cref="T:System.MulticastDelegate" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="28044-487">
              <paramref name="type" /> does not inherit <see cref="T:System.MulticastDelegate" />.</span>
          </span>
          <span data-ttu-id="28044-488">O bien</span>
          <span class="sxs-lookup">
            <span data-stu-id="28044-488">-or-</span>
          </span>
          <span data-ttu-id="28044-489">
            <paramref name="type" /> no es un <see langword="RuntimeType" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="28044-489">
              <paramref name="type" /> is not a <see langword="RuntimeType" />.</span>
          </span>
          <span data-ttu-id="28044-490">Vea [Tipos de reflexión en tiempo de ejecución](http://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858).</span>
          <span class="sxs-lookup">
            <span data-stu-id="28044-490">See [Runtime Types in Reflection](http://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858).</span>
          </span>
          <span data-ttu-id="28044-491">O bien</span>
          <span class="sxs-lookup">
            <span data-stu-id="28044-491">-or-</span>
          </span>
          <span data-ttu-id="28044-492">No se puede enlazar <paramref name="method" /> y <paramref name="throwOnBindFailure" /> es <see langword="true" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="28044-492">
              <paramref name="method" /> cannot be bound, and <paramref name="throwOnBindFailure" /> is <see langword="true" />.</span>
          </span>
          <span data-ttu-id="28044-493">O bien</span>
          <span class="sxs-lookup">
            <span data-stu-id="28044-493">-or-</span>
          </span>
          <span data-ttu-id="28044-494">
            <paramref name="method" /> no es un <see langword="RuntimeMethodInfo" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="28044-494">
              <paramref name="method" /> is not a <see langword="RuntimeMethodInfo" />.</span>
          </span>
          <span data-ttu-id="28044-495">Vea [Tipos de reflexión en tiempo de ejecución](http://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858).</span>
          <span class="sxs-lookup">
            <span data-stu-id="28044-495">See [Runtime Types in Reflection](http://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858).</span>
          </span>
        </exception>
        <exception cref="T:System.MissingMethodException">
          <span data-ttu-id="28044-496">No se encuentra el método <see langword="Invoke" /> de <paramref name="type" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="28044-496">The <see langword="Invoke" /> method of <paramref name="type" /> is not found.</span>
          </span>
        </exception>
        <exception cref="T:System.MethodAccessException">
          <span data-ttu-id="28044-497">El autor de la llamada no tiene los permisos necesarios para acceder a <paramref name="method" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="28044-497">The caller does not have the permissions necessary to access <paramref name="method" />.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">
          <span data-ttu-id="28044-498">Cuando se invoca en tiempo de ejecución a través de mecanismos como <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="28044-498">when invoked late-bound through mechanisms such as <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span>
          </span>
          <span data-ttu-id="28044-499">Enumeración asociada: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="28044-499">Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</span>
          </span>
        </permission>
        <altmember cref="T:System.Type" />
        <altmember cref="T:System.MulticastDelegate" />
        <altmember cref="T:System.Security.Permissions.ReflectionPermission" />
        <altmember cref="T:System.Reflection.MethodInfo" />
      </Docs>
    </Member>
    <Member MemberName="CreateDelegate">
      <MemberSignature Language="C#" Value="public static Delegate CreateDelegate (Type type, Type target, string method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Delegate CreateDelegate(class System.Type type, class System.Type target, string method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Delegate ^ CreateDelegate(Type ^ type, Type ^ target, System::String ^ method);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="target" Type="System.Type" />
        <Parameter Name="method" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="type">
          <span data-ttu-id="28044-500">
            <see cref="T:System.Type" /> de delegado que se va a crear.</span>
          <span class="sxs-lookup">
            <span data-stu-id="28044-500">The <see cref="T:System.Type" /> of delegate to create.</span>
          </span>
        </param>
        <param name="target">
          <span data-ttu-id="28044-501">
            <see cref="T:System.Type" /> que representa la clase que implementa <c>method</c>.</span>
          <span class="sxs-lookup">
            <span data-stu-id="28044-501">The <see cref="T:System.Type" /> representing the class that implements <c>method</c>.</span>
          </span>
        </param>
        <param name="method">
          <span data-ttu-id="28044-502">Nombre del método estático que va a representar el delegado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="28044-502">The name of the static method that the delegate is to represent.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="28044-503">Crea un delegado del tipo especificado que representa el método estático especificado de la clase especificada.</span>
          <span class="sxs-lookup">
            <span data-stu-id="28044-503">Creates a delegate of the specified type that represents the specified static method of the specified class.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="28044-504">Delegado del tipo especificado que representa el método estático especificado de la clase especificada.</span>
          <span class="sxs-lookup">
            <span data-stu-id="28044-504">A delegate of the specified type that represents the specified static method of the specified class.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="28044-505">Este método crea a delegados para los métodos estáticos solo.</span><span class="sxs-lookup"><span data-stu-id="28044-505">This method creates delegates for static methods only.</span></span> <span data-ttu-id="28044-506">Un método de instancia es un método que está asociado a una instancia de una clase; un método estático es un método que está asociado a la propia clase.</span><span class="sxs-lookup"><span data-stu-id="28044-506">An instance method is a method that is associated with an instance of a class; a static method is a method that is associated with the class itself.</span></span>  
  
 <span data-ttu-id="28044-507">Esta sobrecarga del método es equivalente a llamar a la <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Type%2CSystem.String%2CSystem.Boolean%2CSystem.Boolean%29> sobrecarga del método, especificando `false` para `ignoreCase` y `true` para `throwOnBindFailure`.</span><span class="sxs-lookup"><span data-stu-id="28044-507">This method overload is equivalent to calling the <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Type%2CSystem.String%2CSystem.Boolean%2CSystem.Boolean%29> method overload, specifying `false` for `ignoreCase` and `true` for `throwOnBindFailure`.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="28044-508">A partir de la [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], este método se puede utilizar para tener acceso a los métodos no públicos si se ha concedido el autor de llamada <xref:System.Security.Permissions.ReflectionPermission> con el <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> marca y, si el conjunto de permisos de los métodos no públicos se restringe al llamador conceda conjunto o un subconjunto de los mismos.</span><span class="sxs-lookup"><span data-stu-id="28044-508">Starting with the [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], this method can be used to access non-public methods if the caller has been granted <xref:System.Security.Permissions.ReflectionPermission> with the <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> flag and if the grant set of the non-public methods is restricted to the caller’s grant set, or a subset thereof.</span></span> <span data-ttu-id="28044-509">(Consulte [consideraciones de seguridad para la reflexión](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)</span><span class="sxs-lookup"><span data-stu-id="28044-509">(See [Security Considerations for Reflection](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)</span></span>  
>   
>  <span data-ttu-id="28044-510">Para utilizar esta funcionalidad, la aplicación debe utilizar [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] o posterior como destino.</span><span class="sxs-lookup"><span data-stu-id="28044-510">To use this functionality, your application should target the [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] or later.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="28044-511">
            <paramref name="type" /> es <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="28044-511">
              <paramref name="type" /> is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="28044-512">O bien</span>
          <span class="sxs-lookup">
            <span data-stu-id="28044-512">-or-</span>
          </span>
          <span data-ttu-id="28044-513">
            <paramref name="target" /> es <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="28044-513">
              <paramref name="target" /> is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="28044-514">O bien</span>
          <span class="sxs-lookup">
            <span data-stu-id="28044-514">-or-</span>
          </span>
          <span data-ttu-id="28044-515">
            <paramref name="method" /> es <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="28044-515">
              <paramref name="method" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="28044-516">
            <paramref name="type" /> no hereda <see cref="T:System.MulticastDelegate" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="28044-516">
              <paramref name="type" /> does not inherit <see cref="T:System.MulticastDelegate" />.</span>
          </span>
          <span data-ttu-id="28044-517">O bien</span>
          <span class="sxs-lookup">
            <span data-stu-id="28044-517">-or-</span>
          </span>
          <span data-ttu-id="28044-518">
            <paramref name="type" /> no es un <see langword="RuntimeType" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="28044-518">
              <paramref name="type" /> is not a <see langword="RuntimeType" />.</span>
          </span>
          <span data-ttu-id="28044-519">Vea [Tipos de reflexión en tiempo de ejecución](http://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858).</span>
          <span class="sxs-lookup">
            <span data-stu-id="28044-519">See [Runtime Types in Reflection](http://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858).</span>
          </span>
          <span data-ttu-id="28044-520">O bien</span>
          <span class="sxs-lookup">
            <span data-stu-id="28044-520">-or-</span>
          </span>
          <span data-ttu-id="28044-521">
            <paramref name="target" /> no es un <see langword="RuntimeType" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="28044-521">
              <paramref name="target" /> is not a <see langword="RuntimeType" />.</span>
          </span>
          <span data-ttu-id="28044-522">O bien</span>
          <span class="sxs-lookup">
            <span data-stu-id="28044-522">-or-</span>
          </span>
          <span data-ttu-id="28044-523">
            <paramref name="target" /> es un tipo genérico abierto.</span>
          <span class="sxs-lookup">
            <span data-stu-id="28044-523">
              <paramref name="target" /> is an open generic type.</span>
          </span>
          <span data-ttu-id="28044-524">Es decir, su propiedad <see cref="P:System.Type.ContainsGenericParameters" /> es <see langword="true" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="28044-524">That is, its <see cref="P:System.Type.ContainsGenericParameters" /> property is <see langword="true" />.</span>
          </span>
          <span data-ttu-id="28044-525">O bien</span>
          <span class="sxs-lookup">
            <span data-stu-id="28044-525">-or-</span>
          </span>
          <span data-ttu-id="28044-526">
            <paramref name="method" /> no es un método <see langword="static" /> (método <see langword="Shared" /> en Visual Basic).</span>
          <span class="sxs-lookup">
            <span data-stu-id="28044-526">
              <paramref name="method" /> is not a <see langword="static" /> method (<see langword="Shared" /> method in Visual Basic).</span>
          </span>
          <span data-ttu-id="28044-527">O bien</span>
          <span class="sxs-lookup">
            <span data-stu-id="28044-527">-or-</span>
          </span>
          <span data-ttu-id="28044-528">
            <paramref name="method" /> no se puede enlazar (por ejemplo, porque no se encuentra) y <paramref name="throwOnBindFailure" /> es <see langword="true" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="28044-528">
              <paramref name="method" /> cannot be bound, for example because it cannot be found, and <paramref name="throwOnBindFailure" /> is <see langword="true" />.</span>
          </span>
        </exception>
        <exception cref="T:System.MissingMethodException">
          <span data-ttu-id="28044-529">No se encuentra el método <see langword="Invoke" /> de <paramref name="type" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="28044-529">The <see langword="Invoke" /> method of <paramref name="type" /> is not found.</span>
          </span>
        </exception>
        <exception cref="T:System.MethodAccessException">
          <span data-ttu-id="28044-530">El autor de la llamada no tiene los permisos necesarios para acceder a <paramref name="method" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="28044-530">The caller does not have the permissions necessary to access <paramref name="method" />.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">
          <span data-ttu-id="28044-531">Cuando se invoca en tiempo de ejecución a través de mecanismos como <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="28044-531">when invoked late-bound through mechanisms such as <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span>
          </span>
          <span data-ttu-id="28044-532">Enumeración asociada: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="28044-532">Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</span>
          </span>
        </permission>
        <altmember cref="T:System.Type" />
        <altmember cref="T:System.MulticastDelegate" />
        <altmember cref="T:System.Security.Permissions.ReflectionPermission" />
        <altmember cref="T:System.Object" />
      </Docs>
    </Member>
    <Member MemberName="CreateDelegate">
      <MemberSignature Language="C#" Value="public static Delegate CreateDelegate (Type type, object firstArgument, System.Reflection.MethodInfo method, bool throwOnBindFailure);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Delegate CreateDelegate(class System.Type type, object firstArgument, class System.Reflection.MethodInfo method, bool throwOnBindFailure) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Delegate ^ CreateDelegate(Type ^ type, System::Object ^ firstArgument, System::Reflection::MethodInfo ^ method, bool throwOnBindFailure);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="firstArgument" Type="System.Object" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
        <Parameter Name="throwOnBindFailure" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="type">
          <span data-ttu-id="28044-533">
            <see cref="T:System.Type" /> que representa el tipo de delegado que se va a crear.</span>
          <span class="sxs-lookup">
            <span data-stu-id="28044-533">A <see cref="T:System.Type" /> representing the type of delegate to create.</span>
          </span>
        </param>
        <param name="firstArgument">
          <span data-ttu-id="28044-534">
            <see cref="T:System.Object" /> que es el primer argumento del método que representa el delegado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="28044-534">An <see cref="T:System.Object" /> that is the first argument of the method the delegate represents.</span>
          </span>
          <span data-ttu-id="28044-535">Para los métodos de instancia, debe ser compatible con el tipo de instancia.</span>
          <span class="sxs-lookup">
            <span data-stu-id="28044-535">For instance methods, it must be compatible with the instance type.</span>
          </span>
        </param>
        <param name="method">
          <span data-ttu-id="28044-536">
            <see cref="T:System.Reflection.MethodInfo" /> que describe el método estático o de instancia que va a representar el delegado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="28044-536">The <see cref="T:System.Reflection.MethodInfo" /> describing the static or instance method the delegate is to represent.</span>
          </span>
        </param>
        <param name="throwOnBindFailure">
          <span data-ttu-id="28044-537">Es <see langword="true" /> para iniciar una excepción si no se puede enlazar <c>method</c>; en caso contrario, es <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="28044-537">
              <see langword="true" /> to throw an exception if <c>method</c> cannot be bound; otherwise, <see langword="false" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="28044-538">Crea un delegado del tipo especificado que representa el método estático o de instancia determinado, con el primer argumento definido y el comportamiento especificado si se produce un error en el enlace.</span>
          <span class="sxs-lookup">
            <span data-stu-id="28044-538">Creates a delegate of the specified type that represents the specified static or instance method, with the specified first argument and the specified behavior on failure to bind.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="28044-539">Delegado del tipo especificado que representa el método estático o de instancia determinado, o <see langword="null" /> si <paramref name="throwOnBindFailure" /> es <see langword="false" /> y no se puede enlazar el delegado a <paramref name="method" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="28044-539">A delegate of the specified type that represents the specified static or instance method, or <see langword="null" /> if <paramref name="throwOnBindFailure" /> is <see langword="false" /> and the delegate cannot be bound to <paramref name="method" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="28044-540">Esta sobrecarga del método y el <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Object%2CSystem.Reflection.MethodInfo%29> sobrecarga del método, que siempre produce una excepción en caso de error para enlazar, proporcionan la manera más flexible para crear delegados.</span><span class="sxs-lookup"><span data-stu-id="28044-540">This method overload and the <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Object%2CSystem.Reflection.MethodInfo%29> method overload, which always throws on failure to bind, provide the most flexible way to create delegates.</span></span> <span data-ttu-id="28044-541">Puede utilizarlos para crear delegados para estáticas o métodos de instancia, con o sin un primer argumento.</span><span class="sxs-lookup"><span data-stu-id="28044-541">You can use them to create delegates for either static or instance methods, with or without a first argument.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="28044-542">Si no proporciona un primer argumento, utilice la <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Reflection.MethodInfo%2CSystem.Boolean%29> sobrecarga del método para mejorar el rendimiento.</span><span class="sxs-lookup"><span data-stu-id="28044-542">If you do not supply a first argument, use the <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Reflection.MethodInfo%2CSystem.Boolean%29> method overload for better performance.</span></span>  
  
 <span data-ttu-id="28044-543">El tipo de delegado y el método deben tener tipos de devolución compatibles.</span><span class="sxs-lookup"><span data-stu-id="28044-543">The delegate type and the method must have compatible return types.</span></span> <span data-ttu-id="28044-544">Es decir, el tipo de valor devuelto de `method` debe ser asignable al tipo de valor devuelto de `type`.</span><span class="sxs-lookup"><span data-stu-id="28044-544">That is, the return type of `method` must be assignable to the return type of `type`.</span></span>  
  
 <span data-ttu-id="28044-545">Si `firstArgument` es proporciona, se pasa a `method` cada vez que se invoca el delegado; `firstArgument` se dice que está enlazado al delegado, y se dice que el delegado se cierra en su primer argumento.</span><span class="sxs-lookup"><span data-stu-id="28044-545">If `firstArgument` is supplied, it is passed to `method` every time the delegate is invoked; `firstArgument` is said to be bound to the delegate, and the delegate is said to be closed over its first argument.</span></span> <span data-ttu-id="28044-546">Si `method` es `static` (`Shared` en Visual Basic), la lista proporcionada al invocar al delegado incluye todos los parámetros excepto el primero; si el argumento `method` es un método de instancia, a continuación, `firstArgument` se pasa al parámetro de instancia oculto (representado por `this` en C# o mediante `Me` en Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="28044-546">If `method` is `static` (`Shared` in Visual Basic), the argument list supplied when invoking the delegate includes all parameters except the first; if `method` is an instance method, then `firstArgument` is passed to the hidden instance parameter (represented by `this` in C#, or by `Me` in Visual Basic).</span></span>  
  
 <span data-ttu-id="28044-547">Si `firstArgument` se proporciona, el primer parámetro de `method` debe ser un tipo de referencia y `firstArgument` deben ser compatibles con ese tipo.</span><span class="sxs-lookup"><span data-stu-id="28044-547">If `firstArgument` is supplied, the first parameter of `method` must be a reference type, and `firstArgument` must be compatible with that type.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="28044-548">Si `method` es `static` (`Shared` en Visual Basic) y su primer parámetro es de tipo <xref:System.Object> o <xref:System.ValueType>, a continuación, `firstArgument` puede ser un tipo de valor.</span><span class="sxs-lookup"><span data-stu-id="28044-548">If `method` is `static` (`Shared` in Visual Basic) and its first parameter is of type <xref:System.Object> or <xref:System.ValueType>, then `firstArgument` can be a value type.</span></span> <span data-ttu-id="28044-549">En este caso `firstArgument` automáticamente es una conversión boxing.</span><span class="sxs-lookup"><span data-stu-id="28044-549">In this case `firstArgument` is automatically boxed.</span></span> <span data-ttu-id="28044-550">La conversión boxing automática no se produce para cualquier otro argumento, como en un C# o Visual Basic función llamaría.</span><span class="sxs-lookup"><span data-stu-id="28044-550">Automatic boxing does not occur for any other arguments, as it would in a C# or Visual Basic function call.</span></span>  
  
 <span data-ttu-id="28044-551">Si `firstArgument` es una referencia nula y `method` es un método de instancia, el resultado depende de las firmas del tipo de delegado `type` y de `method`:</span><span class="sxs-lookup"><span data-stu-id="28044-551">If `firstArgument` is a null reference and `method` is an instance method, the result depends on the signatures of the delegate type `type` and of `method`:</span></span>  
  
-   <span data-ttu-id="28044-552">Si la firma de `type` incluya explícitamente el primer parámetro oculto de `method`, se dice que el delegado representa un método de instancia abierto.</span><span class="sxs-lookup"><span data-stu-id="28044-552">If the signature of `type` explicitly includes the hidden first parameter of `method`, the delegate is said to represent an open instance method.</span></span> <span data-ttu-id="28044-553">Cuando se invoca el delegado, el primer argumento de la lista de argumentos se pasa al parámetro de instancia oculto de `method`.</span><span class="sxs-lookup"><span data-stu-id="28044-553">When the delegate is invoked, the first argument in the argument list is passed to the hidden instance parameter of `method`.</span></span>  
  
-   <span data-ttu-id="28044-554">Si las firmas de `method` y `type` coincide con (es decir, todos los tipos de parámetros son compatibles), a continuación, se dice que el delegado se cierra en una referencia nula.</span><span class="sxs-lookup"><span data-stu-id="28044-554">If the signatures of `method` and `type` match (that is, all parameter types are compatible), then the delegate is said to be closed over a null reference.</span></span> <span data-ttu-id="28044-555">Invocar al delegado es similar a llamar a un método de instancia en una instancia null, que no es algo muy útil.</span><span class="sxs-lookup"><span data-stu-id="28044-555">Invoking the delegate is like calling an instance method on a null instance, which is not a particularly useful thing to do.</span></span>  
  
 <span data-ttu-id="28044-556">Si `firstArgument` es una referencia nula y `method` es estático, el resultado depende de las firmas del tipo de delegado `type` y de `method`:</span><span class="sxs-lookup"><span data-stu-id="28044-556">If `firstArgument` is a null reference and `method` is static, the result depends on the signatures of the delegate type `type` and of `method`:</span></span>  
  
-   <span data-ttu-id="28044-557">Si la firma de `method` y `type` coincide con (es decir, todos los tipos de parámetros son compatibles), se dice que el delegado representa un método estático abierto.</span><span class="sxs-lookup"><span data-stu-id="28044-557">If the signature of `method` and `type` match (that is, all parameter types are compatible), the delegate is said to represent an open static method.</span></span> <span data-ttu-id="28044-558">Este es el caso más común para los métodos estáticos.</span><span class="sxs-lookup"><span data-stu-id="28044-558">This is the most common case for static methods.</span></span> <span data-ttu-id="28044-559">En este caso, puede obtener un rendimiento ligeramente mejor mediante el <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Reflection.MethodInfo%2CSystem.Boolean%29> sobrecarga del método.</span><span class="sxs-lookup"><span data-stu-id="28044-559">In this case, you can get slightly better performance by using the <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Reflection.MethodInfo%2CSystem.Boolean%29> method overload.</span></span>  
  
-   <span data-ttu-id="28044-560">Si la firma de `type` comienza con el segundo parámetro de `method` y el resto de los tipos de parámetros son compatibles, a continuación, se dice que el delegado se cierra en una referencia nula.</span><span class="sxs-lookup"><span data-stu-id="28044-560">If the signature of `type` begins with the second parameter of `method` and the rest of the parameter types are compatible, then the delegate is said to be closed over a null reference.</span></span> <span data-ttu-id="28044-561">Cuando se invoca el delegado, se pasa una referencia nula al primer parámetro de `method`.</span><span class="sxs-lookup"><span data-stu-id="28044-561">When the delegate is invoked, a null reference is passed to the first parameter of `method`.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="28044-562">A partir de la [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], este método se puede utilizar para tener acceso a los métodos no públicos si se ha concedido el autor de llamada <xref:System.Security.Permissions.ReflectionPermission> con el <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> marca y, si el conjunto de permisos de los métodos no públicos se restringe al llamador conceda conjunto o un subconjunto de los mismos.</span><span class="sxs-lookup"><span data-stu-id="28044-562">Starting with the [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], this method can be used to access non-public methods if the caller has been granted <xref:System.Security.Permissions.ReflectionPermission> with the <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> flag and if the grant set of the non-public methods is restricted to the caller’s grant set, or a subset thereof.</span></span> <span data-ttu-id="28044-563">(Consulte [consideraciones de seguridad para la reflexión](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)</span><span class="sxs-lookup"><span data-stu-id="28044-563">(See [Security Considerations for Reflection](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)</span></span>  
>   
>  <span data-ttu-id="28044-564">Para utilizar esta funcionalidad, la aplicación debe utilizar [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] o posterior como destino.</span><span class="sxs-lookup"><span data-stu-id="28044-564">To use this functionality, your application should target the [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] or later.</span></span>  
  
## <a name="compatible-parameter-types-and-return-type"></a><span data-ttu-id="28044-565">Tipos de parámetro compatible y tipo de valor devuelto</span><span class="sxs-lookup"><span data-stu-id="28044-565">Compatible Parameter Types and Return Type</span></span>  
 <span data-ttu-id="28044-566">Los tipos de parámetro y el tipo de valor devuelto de un delegado deben ser compatibles con los tipos de parámetro y el tipo de valor devuelto del método que representa el delegado; los tipos no tienen que coincidir exactamente.</span><span class="sxs-lookup"><span data-stu-id="28044-566">The parameter types and return type of a delegate must be compatible with the parameter types and return type of the method the delegate represents; the types do not have to match exactly.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="28044-567">En la versión 1.0 y 1.1 de .NET Framework los tipos deben coincidir exactamente.</span><span class="sxs-lookup"><span data-stu-id="28044-567">In the .NET Framework version 1.0 and 1.1 the types must match exactly.</span></span>  
  
 <span data-ttu-id="28044-568">Un parámetro de un delegado es compatible con el parámetro correspondiente de un método si el tipo del parámetro del delegado es más restrictivo que el del método, porque así se garantiza que el argumento que se pase al delegado también se podrá pasar de forma segura al método.</span><span class="sxs-lookup"><span data-stu-id="28044-568">A parameter of a delegate is compatible with the corresponding parameter of a method if the type of the delegate parameter is more restrictive than the type of the method parameter, because this guarantees that an argument passed to the delegate can be passed safely to the method.</span></span>  
  
 <span data-ttu-id="28044-569">De forma similar, el tipo de devolución de un delegado es compatible con el tipo de devolución de un método si el del método es más restrictivo que el del delegado, porque así se garantiza que el valor devuelto por el método se puede convertir con seguridad al tipo de devolución del delegado.</span><span class="sxs-lookup"><span data-stu-id="28044-569">Similarly, the return type of a delegate is compatible with the return type of a method if the return type of the method is more restrictive than the return type of the delegate, because this guarantees that the return value of the method can be cast safely to the return type of the delegate.</span></span>  
  
 <span data-ttu-id="28044-570">Por ejemplo, un delegado con un parámetro de tipo <xref:System.Collections.Hashtable> y un tipo de valor devuelto de <xref:System.Object> puede representar un método con un parámetro de tipo <xref:System.Object> y un valor devuelto de tipo <xref:System.Collections.Hashtable>.</span><span class="sxs-lookup"><span data-stu-id="28044-570">For example, a delegate with a parameter of type <xref:System.Collections.Hashtable> and a return type of <xref:System.Object> can represent a method with a parameter of type <xref:System.Object> and a return value of type <xref:System.Collections.Hashtable>.</span></span>  
  
## <a name="determining-the-methods-a-delegate-can-represent"></a><span data-ttu-id="28044-571">Determinación de los métodos que puede representar un delegado</span><span class="sxs-lookup"><span data-stu-id="28044-571">Determining the Methods a Delegate Can Represent</span></span>  
 <span data-ttu-id="28044-572">Otra manera útil pensar en la flexibilidad proporcionada por esta sobrecarga de <xref:System.Delegate.CreateDelegate%2A> es que cualquier delegado puede representar cuatro combinaciones diferentes de firma de método y el tipo de método (estático frente a la instancia).</span><span class="sxs-lookup"><span data-stu-id="28044-572">Another useful way to think of the flexibility provided by this overload of <xref:System.Delegate.CreateDelegate%2A> is that any given delegate can represent four different combinations of method signature and method kind (static versus instance).</span></span> <span data-ttu-id="28044-573">Considere la posibilidad de un tipo de delegado `D` con un argumento de tipo `C`.</span><span class="sxs-lookup"><span data-stu-id="28044-573">Consider a delegate type `D` with one argument of type `C`.</span></span> <span data-ttu-id="28044-574">Lo siguiente describe los métodos `D` puede representar, omitiendo el tipo de valor devuelto, puesto que debe coincidir en todos los casos:</span><span class="sxs-lookup"><span data-stu-id="28044-574">The following describes the methods `D` can represent, ignoring the return type since it must match in all cases:</span></span>  
  
-   <span data-ttu-id="28044-575">`D` puede representar cualquier método de instancia que tenga exactamente un argumento de tipo `C`, independientemente de qué tipo pertenece el método de instancia.</span><span class="sxs-lookup"><span data-stu-id="28044-575">`D` can represent any instance method that has exactly one argument of type `C`, regardless of what type the instance method belongs to.</span></span> <span data-ttu-id="28044-576">Cuando <xref:System.Delegate.CreateDelegate%2A> se llama, `firstArgument` es una instancia del tipo `method` pertenece, y se dice que el delegado resultante cerrado en esa instancia.</span><span class="sxs-lookup"><span data-stu-id="28044-576">When <xref:System.Delegate.CreateDelegate%2A> is called, `firstArgument` is an instance of the type `method` belongs to, and the resulting delegate is said to be closed over that instance.</span></span> <span data-ttu-id="28044-577">(Trivial, `D` también se puede cerrar sobre una referencia nula si `firstArgument` es `null`.)</span><span class="sxs-lookup"><span data-stu-id="28044-577">(Trivially, `D` can also be closed over a null reference if `firstArgument` is `null`.)</span></span>  
  
-   <span data-ttu-id="28044-578">`D` puede representar un método de instancia de `C` que no tiene ningún argumento.</span><span class="sxs-lookup"><span data-stu-id="28044-578">`D` can represent an instance method of `C` that has no arguments.</span></span> <span data-ttu-id="28044-579">Cuando <xref:System.Delegate.CreateDelegate%2A> se llama, `firstArgument` es una referencia nula.</span><span class="sxs-lookup"><span data-stu-id="28044-579">When <xref:System.Delegate.CreateDelegate%2A> is called, `firstArgument` is a null reference.</span></span> <span data-ttu-id="28044-580">El delegado resultante representa un método de instancia abierta y una instancia de `C` debe proporcionarse cada vez que se invoca.</span><span class="sxs-lookup"><span data-stu-id="28044-580">The resulting delegate represents an open instance method, and an instance of `C` must be supplied each time it is invoked.</span></span>  
  
-   <span data-ttu-id="28044-581">`D` puede representar un método estático que toma un argumento de tipo `C`, y que el método puede pertenecer a cualquier tipo.</span><span class="sxs-lookup"><span data-stu-id="28044-581">`D` can represent a static method that takes one argument of type `C`, and that method can belong to any type.</span></span> <span data-ttu-id="28044-582">Cuando <xref:System.Delegate.CreateDelegate%2A> se llama, `firstArgument` es una referencia nula.</span><span class="sxs-lookup"><span data-stu-id="28044-582">When <xref:System.Delegate.CreateDelegate%2A> is called, `firstArgument` is a null reference.</span></span> <span data-ttu-id="28044-583">El delegado resultante representa un método estático abierto y una instancia de `C` debe proporcionarse cada vez que se invoca.</span><span class="sxs-lookup"><span data-stu-id="28044-583">The resulting delegate represents an open static method, and an instance of `C` must be supplied each time it is invoked.</span></span>  
  
-   <span data-ttu-id="28044-584">`D` puede representar un método estático que pertenece al tipo `F` y tiene dos argumentos de tipo `F` y escriba `C`.</span><span class="sxs-lookup"><span data-stu-id="28044-584">`D` can represent a static method that belongs to type `F` and has two arguments, of type `F` and type `C`.</span></span> <span data-ttu-id="28044-585">Cuando <xref:System.Delegate.CreateDelegate%2A> se llama, `firstArgument` es una instancia de `F`.</span><span class="sxs-lookup"><span data-stu-id="28044-585">When <xref:System.Delegate.CreateDelegate%2A> is called, `firstArgument` is an instance of `F`.</span></span> <span data-ttu-id="28044-586">El delegado resultante representa un método estático que se cierra en esa instancia de `F`.</span><span class="sxs-lookup"><span data-stu-id="28044-586">The resulting delegate represents a static method that is closed over that instance of `F`.</span></span> <span data-ttu-id="28044-587">Tenga en cuenta que en el caso donde `F` y `C` son del mismo tipo, el método estático tiene dos argumentos de ese tipo.</span><span class="sxs-lookup"><span data-stu-id="28044-587">Note that in the case where `F` and `C` are the same type, the static method has two arguments of that type.</span></span> <span data-ttu-id="28044-588">(En este caso, `D` se cierra en una referencia nula si `firstArgument` es `null`.)</span><span class="sxs-lookup"><span data-stu-id="28044-588">(In this case, `D` is closed over a null reference if `firstArgument` is `null`.)</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="28044-589">Esta sección contiene tres ejemplos de código.</span><span class="sxs-lookup"><span data-stu-id="28044-589">This section contains three code examples.</span></span> <span data-ttu-id="28044-590">El primer ejemplo muestra los cuatro tipos de delegados que se pueden crear: cerrados a lo largo de un método de instancia, abra a través de un método de instancia, abra a través de un método estático y cerrados a lo largo de un método estático.</span><span class="sxs-lookup"><span data-stu-id="28044-590">The first example demonstrates the four kinds of delegates that can be created: closed over an instance method, open over an instance method, open over a static method, and closed over a static method.</span></span>  
  
 <span data-ttu-id="28044-591">El segundo ejemplo de código muestra los tipos de parámetros compatibles y tipos de valor devuelto.</span><span class="sxs-lookup"><span data-stu-id="28044-591">The second code example demonstrates compatible parameter types and return types.</span></span>  
  
 <span data-ttu-id="28044-592">El tercer ejemplo de código define un tipo de delegado único y muestra todos los métodos de ese tipo de delegado pueden representar.</span><span class="sxs-lookup"><span data-stu-id="28044-592">The third code example defines a single delegate type, and shows all the methods that delegate type can represent.</span></span>  
  
 <span data-ttu-id="28044-593">**Ejemplo 1**</span><span class="sxs-lookup"><span data-stu-id="28044-593">**Example 1**</span></span>  
  
 <span data-ttu-id="28044-594">En el ejemplo de código siguiente se muestra las cuatro maneras se puede crear un delegado utilizando esta sobrecarga de la <xref:System.Delegate.CreateDelegate%2A> método.</span><span class="sxs-lookup"><span data-stu-id="28044-594">The following code example demonstrates the four ways a delegate can be created using this overload of the <xref:System.Delegate.CreateDelegate%2A> method.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="28044-595">Hay dos sobrecargas de la <xref:System.Delegate.CreateDelegate%2A> método que especifican `firstArgument` y un <xref:System.Reflection.MethodInfo>; su funcionalidad es el mismo, salvo que uno le permite especificar si se producirá en error en el enlace y el otro siempre produce una excepción.</span><span class="sxs-lookup"><span data-stu-id="28044-595">There are two overloads of the <xref:System.Delegate.CreateDelegate%2A> method that specify `firstArgument` and a <xref:System.Reflection.MethodInfo>; their functionality is the same except that one allows you to specify whether to throw on failure to bind, and the other always throws.</span></span> <span data-ttu-id="28044-596">Este ejemplo de código utiliza ambas sobrecargas.</span><span class="sxs-lookup"><span data-stu-id="28044-596">This code example uses both overloads.</span></span>  
  
 <span data-ttu-id="28044-597">En el ejemplo se declara una clase `C` con un método estático `M2` y un método de instancia `M1`, y tres tipos de delegado: `D1` toma una instancia de `C` y una cadena, `D2` toma una cadena y `D3`no tiene ningún argumento.</span><span class="sxs-lookup"><span data-stu-id="28044-597">The example declares a class `C` with a static method `M2` and an instance method `M1`, and three delegate types: `D1` takes an instance of `C` and a string, `D2` takes a string, and `D3` has no arguments.</span></span>  
  
 <span data-ttu-id="28044-598">Una segunda clase denominada `Example` contiene el código que crea los delegados.</span><span class="sxs-lookup"><span data-stu-id="28044-598">A second class named `Example` contains the code that creates the delegates.</span></span>  
  
-   <span data-ttu-id="28044-599">Un delegado del tipo `D2`, cerrado sobre una instancia de `C`, se crea para el método de instancia `M1`.</span><span class="sxs-lookup"><span data-stu-id="28044-599">A delegate of type `D2`, closed over an instance of `C`, is created for the instance method `M1`.</span></span> <span data-ttu-id="28044-600">Se invoca con cadenas diferentes, para mostrar que la instancia enlazada de `C` siempre se utiliza.</span><span class="sxs-lookup"><span data-stu-id="28044-600">It is invoked with different strings, to show that the bound instance of `C` is always used.</span></span>  
  
-   <span data-ttu-id="28044-601">Un delegado del tipo `D1`, que representa un método de instancia abierta, se crea para el método de instancia `M1`.</span><span class="sxs-lookup"><span data-stu-id="28044-601">A delegate of type `D1`, representing an open instance method, is created for the instance method `M1`.</span></span> <span data-ttu-id="28044-602">Debe pasar una instancia cuando se invoca el delegado.</span><span class="sxs-lookup"><span data-stu-id="28044-602">An instance must be passed when the delegate is invoked.</span></span>  
  
-   <span data-ttu-id="28044-603">Un delegado del tipo `D2`, que representa un método estático abierto, se crea para el método estático `M2`.</span><span class="sxs-lookup"><span data-stu-id="28044-603">A delegate of type `D2`, representing an open static method, is created for the static method `M2`.</span></span>  
  
-   <span data-ttu-id="28044-604">Por último, un delegado del tipo `D3`, cerrados a lo largo de una cadena, se crea para el método estático `M2`.</span><span class="sxs-lookup"><span data-stu-id="28044-604">Finally, a delegate of type `D3`, closed over a string, is created for the static method `M2`.</span></span> <span data-ttu-id="28044-605">Se invoca el método para mostrar que utiliza la cadena enlazada.</span><span class="sxs-lookup"><span data-stu-id="28044-605">The method is invoked to show that it uses the bound string.</span></span>  
  
 [!code-csharp[Delegate.CreateDelegateTOM#1](~/samples/snippets/csharp/VS_Snippets_CLR/Delegate.CreateDelegateTOM/cs/openClosedOver.cs#1)]
 [!code-vb[Delegate.CreateDelegateTOM#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Delegate.CreateDelegateTOM/VB/openClosedOver.vb#1)]  
  
 <span data-ttu-id="28044-606">**Ejemplo 2**</span><span class="sxs-lookup"><span data-stu-id="28044-606">**Example 2**</span></span>  
  
 <span data-ttu-id="28044-607">En el ejemplo de código siguiente se muestra la compatibilidad de tipos de parámetro y tipos de valor devuelto.</span><span class="sxs-lookup"><span data-stu-id="28044-607">The following code example demonstrates compatibility of parameter types and return types.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="28044-608">Este ejemplo de código se utiliza el <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Reflection.MethodInfo%29> sobrecarga del método.</span><span class="sxs-lookup"><span data-stu-id="28044-608">This code example uses the <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Reflection.MethodInfo%29> method overload.</span></span> <span data-ttu-id="28044-609">El uso de otras sobrecargas que toman <xref:System.Reflection.MethodInfo> es similar.</span><span class="sxs-lookup"><span data-stu-id="28044-609">The use of other overloads that take <xref:System.Reflection.MethodInfo> is similar.</span></span>  
  
 <span data-ttu-id="28044-610">El ejemplo de código define una clase base denominada `Base` y una clase denominada `Derived` que se deriva de `Base`.</span><span class="sxs-lookup"><span data-stu-id="28044-610">The code example defines a base class named `Base` and a class named `Derived` that derives from `Base`.</span></span> <span data-ttu-id="28044-611">La clase derivada tiene un `static` (`Shared` en Visual Basic) con el nombre de método `MyMethod` con un parámetro de tipo `Base` y un tipo de valor devuelto de `Derived`.</span><span class="sxs-lookup"><span data-stu-id="28044-611">The derived class has a `static` (`Shared` in Visual Basic) method named `MyMethod` with one parameter of type `Base` and a return type of `Derived`.</span></span> <span data-ttu-id="28044-612">El ejemplo de código también define un delegado denominado `Example` que tiene un parámetro de tipo `Derived` y un tipo de valor devuelto de `Base`.</span><span class="sxs-lookup"><span data-stu-id="28044-612">The code example also defines a delegate named `Example` that has one parameter of type `Derived` and a return type of `Base`.</span></span>  
  
 <span data-ttu-id="28044-613">El ejemplo de código se muestra que el delegado denominado `Example` puede usarse para representar el método `MyMethod`.</span><span class="sxs-lookup"><span data-stu-id="28044-613">The code example demonstrates that the delegate named `Example` can be used to represent the method `MyMethod`.</span></span> <span data-ttu-id="28044-614">El método se puede enlazar al delegado porque:</span><span class="sxs-lookup"><span data-stu-id="28044-614">The method can be bound to the delegate because:</span></span>  
  
-   <span data-ttu-id="28044-615">El tipo de parámetro del delegado (`Derived`) es más restrictivo que el tipo de parámetro `MyMethod` (`Base`), de modo que siempre es seguro pasar el argumento del delegado al que `MyMethod`.</span><span class="sxs-lookup"><span data-stu-id="28044-615">The parameter type of the delegate (`Derived`) is more restrictive than the parameter type of `MyMethod` (`Base`), so that it is always safe to pass the argument of the delegate to `MyMethod`.</span></span>  
  
-   <span data-ttu-id="28044-616">El tipo de valor devuelto de `MyMethod` (`Derived`) es más restrictivo que el tipo de parámetro del delegado (`Base`), de modo que siempre es seguro convertir el tipo de valor devuelto del método para el tipo de valor devuelto del delegado.</span><span class="sxs-lookup"><span data-stu-id="28044-616">The return type of `MyMethod` (`Derived`) is more restrictive than the parameter type of the delegate (`Base`), so that it is always safe to cast the return type of the method to the return type of the delegate.</span></span>  
  
 <span data-ttu-id="28044-617">El ejemplo de código no produce ningún resultado.</span><span class="sxs-lookup"><span data-stu-id="28044-617">The code example produces no output.</span></span>  
  
 [!code-cpp[Delegate.CreateDelegate_RelaxedFit#1](~/samples/snippets/cpp/VS_Snippets_CLR/Delegate.CreateDelegate_RelaxedFit/cpp/source.cpp#1)]
 [!code-csharp[Delegate.CreateDelegate_RelaxedFit#1](~/samples/snippets/csharp/VS_Snippets_CLR/Delegate.CreateDelegate_RelaxedFit/cs/source.cs#1)]
 [!code-vb[Delegate.CreateDelegate_RelaxedFit#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Delegate.CreateDelegate_RelaxedFit/vb/source.vb#1)]  
  
 <span data-ttu-id="28044-618">**Ejemplo 3**</span><span class="sxs-lookup"><span data-stu-id="28044-618">**Example 3**</span></span>  
  
 <span data-ttu-id="28044-619">En el ejemplo de código siguiente se muestra todos los métodos que puede representar un tipo de delegado único.</span><span class="sxs-lookup"><span data-stu-id="28044-619">The following code example shows all the methods a single delegate type can represent.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="28044-620">Hay dos sobrecargas de la <xref:System.Delegate.CreateDelegate%2A> método que especifican `firstArgument` y un <xref:System.Reflection.MethodInfo>; su funcionalidad es el mismo, salvo que uno le permite especificar si se producirá en error en el enlace y el otro siempre produce una excepción.</span><span class="sxs-lookup"><span data-stu-id="28044-620">There are two overloads of the <xref:System.Delegate.CreateDelegate%2A> method that specify `firstArgument` and a <xref:System.Reflection.MethodInfo>; their functionality is the same except that one allows you to specify whether to throw on failure to bind, and the other always throws.</span></span> <span data-ttu-id="28044-621">Este ejemplo de código utiliza ambas sobrecargas.</span><span class="sxs-lookup"><span data-stu-id="28044-621">This code example uses both overloads.</span></span>  
  
 <span data-ttu-id="28044-622">El ejemplo de código define dos clases, `C` y `F`y un tipo de delegado `D` con un argumento de tipo `C`.</span><span class="sxs-lookup"><span data-stu-id="28044-622">The code example defines two classes, `C` and `F`, and a delegate type `D` with one argument of type `C`.</span></span> <span data-ttu-id="28044-623">Las clases tienen coincidentes estáticos y métodos de instancia `M1`, `M3`, y `M4`y la clase `C` también tiene un método de instancia `M2` que no tiene ningún argumento.</span><span class="sxs-lookup"><span data-stu-id="28044-623">The classes have matching static and instance methods `M1`, `M3`, and `M4`, and class `C` also has an instance method `M2` that has no arguments.</span></span>  
  
 <span data-ttu-id="28044-624">Una tercera clase denominada `Example` contiene el código que crea los delegados.</span><span class="sxs-lookup"><span data-stu-id="28044-624">A third class named `Example` contains the code that creates the delegates.</span></span>  
  
-   <span data-ttu-id="28044-625">Los delegados se crean para la instancia método `M1` de tipo `C` y el tipo de `F`; cada uno se cierra sobre una instancia del tipo correspondiente.</span><span class="sxs-lookup"><span data-stu-id="28044-625">Delegates are created for instance method `M1` of type `C` and type `F`; each is closed over an instance of the respective type.</span></span> <span data-ttu-id="28044-626">Método `M1` de tipo `C` muestra la `ID` propiedades de la instancia enlazada y del argumento.</span><span class="sxs-lookup"><span data-stu-id="28044-626">Method `M1` of type `C` displays the `ID` properties of the bound instance and of the argument.</span></span>  
  
-   <span data-ttu-id="28044-627">Se crea un delegado para el método `M2` de tipo `C`.</span><span class="sxs-lookup"><span data-stu-id="28044-627">A delegate is created for method `M2` of type `C`.</span></span> <span data-ttu-id="28044-628">Se trata de un delegado de instancia abierto, en la que el argumento del delegado representa el primer argumento oculto en el método de instancia.</span><span class="sxs-lookup"><span data-stu-id="28044-628">This is an open instance delegate, in which the argument of the delegate represents the hidden first argument on the instance method.</span></span> <span data-ttu-id="28044-629">El método no tiene ningún otro argumento.</span><span class="sxs-lookup"><span data-stu-id="28044-629">The method has no other arguments.</span></span>  
  
-   <span data-ttu-id="28044-630">Se crean delegados para el método estático `M3` de tipo `C` y tipo `F`; se trata de delegados estáticos abiertos.</span><span class="sxs-lookup"><span data-stu-id="28044-630">Delegates are created for static method `M3` of type `C` and type `F`; these are open static delegates.</span></span>  
  
-   <span data-ttu-id="28044-631">Por último, se crean delegados para el método estático `M4` de tipo `C` y tipo `F`; cada método tiene el tipo declarativo como primer argumento y se proporciona una instancia del tipo, por lo que los delegados se cierran en sus primeros argumentos .</span><span class="sxs-lookup"><span data-stu-id="28044-631">Finally, delegates are created for static method `M4` of type `C` and type `F`; each method has the declaring type as its first argument, and an instance of the type is supplied, so the delegates are closed over their first arguments.</span></span> <span data-ttu-id="28044-632">Método `M4` de tipo `C` muestra la `ID` propiedades de la instancia enlazada y del argumento.</span><span class="sxs-lookup"><span data-stu-id="28044-632">Method `M4` of type `C` displays the `ID` properties of the bound instance and of the argument.</span></span>  
  
 [!code-csharp[Delegate.CreateDelegateTOM_2#1](~/samples/snippets/csharp/VS_Snippets_CLR/Delegate.CreateDelegateTOM_2/cs/source.cs#1)]
 [!code-vb[Delegate.CreateDelegateTOM_2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Delegate.CreateDelegateTOM_2/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="28044-633">
            <paramref name="type" /> es <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="28044-633">
              <paramref name="type" /> is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="28044-634">O bien</span>
          <span class="sxs-lookup">
            <span data-stu-id="28044-634">-or-</span>
          </span>
          <span data-ttu-id="28044-635">
            <paramref name="method" /> es <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="28044-635">
              <paramref name="method" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="28044-636">
            <paramref name="type" /> no hereda <see cref="T:System.MulticastDelegate" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="28044-636">
              <paramref name="type" /> does not inherit <see cref="T:System.MulticastDelegate" />.</span>
          </span>
          <span data-ttu-id="28044-637">O bien</span>
          <span class="sxs-lookup">
            <span data-stu-id="28044-637">-or-</span>
          </span>
          <span data-ttu-id="28044-638">
            <paramref name="type" /> no es un <see langword="RuntimeType" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="28044-638">
              <paramref name="type" /> is not a <see langword="RuntimeType" />.</span>
          </span>
          <span data-ttu-id="28044-639">Vea [Tipos de reflexión en tiempo de ejecución](http://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858).</span>
          <span class="sxs-lookup">
            <span data-stu-id="28044-639">See [Runtime Types in Reflection](http://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858).</span>
          </span>
          <span data-ttu-id="28044-640">O bien</span>
          <span class="sxs-lookup">
            <span data-stu-id="28044-640">-or-</span>
          </span>
          <span data-ttu-id="28044-641">No se puede enlazar <paramref name="method" /> y <paramref name="throwOnBindFailure" /> es <see langword="true" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="28044-641">
              <paramref name="method" /> cannot be bound, and <paramref name="throwOnBindFailure" /> is <see langword="true" />.</span>
          </span>
          <span data-ttu-id="28044-642">O bien</span>
          <span class="sxs-lookup">
            <span data-stu-id="28044-642">-or-</span>
          </span>
          <span data-ttu-id="28044-643">
            <paramref name="method" /> no es un <see langword="RuntimeMethodInfo" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="28044-643">
              <paramref name="method" /> is not a <see langword="RuntimeMethodInfo" />.</span>
          </span>
          <span data-ttu-id="28044-644">Vea [Tipos de reflexión en tiempo de ejecución](http://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858).</span>
          <span class="sxs-lookup">
            <span data-stu-id="28044-644">See [Runtime Types in Reflection](http://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858).</span>
          </span>
        </exception>
        <exception cref="T:System.MissingMethodException">
          <span data-ttu-id="28044-645">No se encuentra el método <see langword="Invoke" /> de <paramref name="type" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="28044-645">The <see langword="Invoke" /> method of <paramref name="type" /> is not found.</span>
          </span>
        </exception>
        <exception cref="T:System.MethodAccessException">
          <span data-ttu-id="28044-646">El autor de la llamada no tiene los permisos necesarios para acceder a <paramref name="method" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="28044-646">The caller does not have the permissions necessary to access <paramref name="method" />.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">
          <span data-ttu-id="28044-647">Cuando se invoca en tiempo de ejecución a través de mecanismos como <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="28044-647">when invoked late-bound through mechanisms such as <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span>
          </span>
          <span data-ttu-id="28044-648">Enumeración asociada: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="28044-648">Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</span>
          </span>
        </permission>
        <altmember cref="T:System.Type" />
        <altmember cref="T:System.MulticastDelegate" />
        <altmember cref="T:System.Security.Permissions.ReflectionPermission" />
        <altmember cref="T:System.Reflection.MethodInfo" />
      </Docs>
    </Member>
    <Member MemberName="CreateDelegate">
      <MemberSignature Language="C#" Value="public static Delegate CreateDelegate (Type type, object target, string method, bool ignoreCase);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Delegate CreateDelegate(class System.Type type, object target, string method, bool ignoreCase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.String,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Delegate ^ CreateDelegate(Type ^ type, System::Object ^ target, System::String ^ method, bool ignoreCase);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="target" Type="System.Object" />
        <Parameter Name="method" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="type">
          <span data-ttu-id="28044-649">
            <see cref="T:System.Type" /> de delegado que se va a crear.</span>
          <span class="sxs-lookup">
            <span data-stu-id="28044-649">The <see cref="T:System.Type" /> of delegate to create.</span>
          </span>
        </param>
        <param name="target">
          <span data-ttu-id="28044-650">Instancia de clase en la que se invoca a <c>method</c>.</span>
          <span class="sxs-lookup">
            <span data-stu-id="28044-650">The class instance on which <c>method</c> is invoked.</span>
          </span>
        </param>
        <param name="method">
          <span data-ttu-id="28044-651">Nombre del método de instancia que el delegado va a representar.</span>
          <span class="sxs-lookup">
            <span data-stu-id="28044-651">The name of the instance method that the delegate is to represent.</span>
          </span>
        </param>
        <param name="ignoreCase">
          <span data-ttu-id="28044-652">Valor booleano que indica si debe omitirse la distinción de mayúsculas y minúsculas al comparar el nombre del método.</span>
          <span class="sxs-lookup">
            <span data-stu-id="28044-652">A Boolean indicating whether to ignore the case when comparing the name of the method.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="28044-653">Crea un delegado del tipo especificado que representa el método de instancia especificado que se va a invocar en la instancia de clase especificada con la distinción de mayúsculas y minúsculas que se haya especificado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="28044-653">Creates a delegate of the specified type that represents the specified instance method to invoke on the specified class instance with the specified case-sensitivity.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="28044-654">Delegado del tipo especificado que representa el método de instancia especificado que se va a invocar en la instancia de clase especificada.</span>
          <span class="sxs-lookup">
            <span data-stu-id="28044-654">A delegate of the specified type that represents the specified instance method to invoke on the specified class instance.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="28044-655">Este método sólo crea a delegados para la instancia métodos.</span><span class="sxs-lookup"><span data-stu-id="28044-655">This method creates delegates for instance methods only.</span></span> <span data-ttu-id="28044-656">Un método de instancia es un método que está asociado a una instancia de una clase; un método estático es un método que está asociado a la propia clase.</span><span class="sxs-lookup"><span data-stu-id="28044-656">An instance method is a method that is associated with an instance of a class; a static method is a method that is associated with the class itself.</span></span>  
  
 <span data-ttu-id="28044-657">Esta sobrecarga del método es equivalente a llamar a la <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Object%2CSystem.String%2CSystem.Boolean%2CSystem.Boolean%29> sobrecarga del método, especificando `true` para `throwOnBindFailure`.</span><span class="sxs-lookup"><span data-stu-id="28044-657">This method overload is equivalent to calling the <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Object%2CSystem.String%2CSystem.Boolean%2CSystem.Boolean%29> method overload, specifying `true` for `throwOnBindFailure`.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="28044-658">A partir de la [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], este método se puede utilizar para tener acceso a los métodos no públicos si se ha concedido el autor de llamada <xref:System.Security.Permissions.ReflectionPermission> con el <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> marca y, si el conjunto de permisos de los métodos no públicos se restringe al llamador conceda conjunto o un subconjunto de los mismos.</span><span class="sxs-lookup"><span data-stu-id="28044-658">Starting with the [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], this method can be used to access non-public methods if the caller has been granted <xref:System.Security.Permissions.ReflectionPermission> with the <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> flag and if the grant set of the non-public methods is restricted to the caller’s grant set, or a subset thereof.</span></span> <span data-ttu-id="28044-659">(Consulte [consideraciones de seguridad para la reflexión](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)</span><span class="sxs-lookup"><span data-stu-id="28044-659">(See [Security Considerations for Reflection](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)</span></span>  
>   
>  <span data-ttu-id="28044-660">Para utilizar esta funcionalidad, la aplicación debe utilizar [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] o posterior como destino.</span><span class="sxs-lookup"><span data-stu-id="28044-660">To use this functionality, your application should target the [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] or later.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="28044-661">
            <paramref name="type" /> es <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="28044-661">
              <paramref name="type" /> is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="28044-662">O bien</span>
          <span class="sxs-lookup">
            <span data-stu-id="28044-662">-or-</span>
          </span>
          <span data-ttu-id="28044-663">
            <paramref name="target" /> es <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="28044-663">
              <paramref name="target" /> is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="28044-664">O bien</span>
          <span class="sxs-lookup">
            <span data-stu-id="28044-664">-or-</span>
          </span>
          <span data-ttu-id="28044-665">
            <paramref name="method" /> es <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="28044-665">
              <paramref name="method" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="28044-666">
            <paramref name="type" /> no hereda <see cref="T:System.MulticastDelegate" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="28044-666">
              <paramref name="type" /> does not inherit <see cref="T:System.MulticastDelegate" />.</span>
          </span>
          <span data-ttu-id="28044-667">O bien</span>
          <span class="sxs-lookup">
            <span data-stu-id="28044-667">-or-</span>
          </span>
          <span data-ttu-id="28044-668">
            <paramref name="type" /> no es un <see langword="RuntimeType" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="28044-668">
              <paramref name="type" /> is not a <see langword="RuntimeType" />.</span>
          </span>
          <span data-ttu-id="28044-669">Vea [Tipos de reflexión en tiempo de ejecución](http://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858).</span>
          <span class="sxs-lookup">
            <span data-stu-id="28044-669">See [Runtime Types in Reflection](http://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858).</span>
          </span>
          <span data-ttu-id="28044-670">O bien</span>
          <span class="sxs-lookup">
            <span data-stu-id="28044-670">-or-</span>
          </span>
          <span data-ttu-id="28044-671">
            <paramref name="method" /> no es un método de instancia.</span>
          <span class="sxs-lookup">
            <span data-stu-id="28044-671">
              <paramref name="method" /> is not an instance method.</span>
          </span>
          <span data-ttu-id="28044-672">O bien</span>
          <span class="sxs-lookup">
            <span data-stu-id="28044-672">-or-</span>
          </span>
          <span data-ttu-id="28044-673">
            <paramref name="method" /> no se puede enlazar, por ejemplo, porque no se encuentra.</span>
          <span class="sxs-lookup">
            <span data-stu-id="28044-673">
              <paramref name="method" /> cannot be bound, for example because it cannot be found.</span>
          </span>
        </exception>
        <exception cref="T:System.MissingMethodException">
          <span data-ttu-id="28044-674">No se encuentra el método <see langword="Invoke" /> de <paramref name="type" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="28044-674">The <see langword="Invoke" /> method of <paramref name="type" /> is not found.</span>
          </span>
        </exception>
        <exception cref="T:System.MethodAccessException">
          <span data-ttu-id="28044-675">El autor de la llamada no tiene los permisos necesarios para acceder a <paramref name="method" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="28044-675">The caller does not have the permissions necessary to access <paramref name="method" />.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">
          <span data-ttu-id="28044-676">Cuando se invoca en tiempo de ejecución a través de mecanismos como <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="28044-676">when invoked late-bound through mechanisms such as <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span>
          </span>
          <span data-ttu-id="28044-677">Enumeración asociada: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="28044-677">Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</span>
          </span>
        </permission>
        <altmember cref="T:System.Type" />
        <altmember cref="T:System.MulticastDelegate" />
        <altmember cref="T:System.Security.Permissions.ReflectionPermission" />
        <altmember cref="T:System.Object" />
      </Docs>
    </Member>
    <Member MemberName="CreateDelegate">
      <MemberSignature Language="C#" Value="public static Delegate CreateDelegate (Type type, Type target, string method, bool ignoreCase);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Delegate CreateDelegate(class System.Type type, class System.Type target, string method, bool ignoreCase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Delegate ^ CreateDelegate(Type ^ type, Type ^ target, System::String ^ method, bool ignoreCase);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="target" Type="System.Type" />
        <Parameter Name="method" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="type">
          <span data-ttu-id="28044-678">
            <see cref="T:System.Type" /> de delegado que se va a crear.</span>
          <span class="sxs-lookup">
            <span data-stu-id="28044-678">The <see cref="T:System.Type" /> of delegate to create.</span>
          </span>
        </param>
        <param name="target">
          <span data-ttu-id="28044-679">
            <see cref="T:System.Type" /> que representa la clase que implementa <c>method</c>.</span>
          <span class="sxs-lookup">
            <span data-stu-id="28044-679">The <see cref="T:System.Type" /> representing the class that implements <c>method</c>.</span>
          </span>
        </param>
        <param name="method">
          <span data-ttu-id="28044-680">Nombre del método estático que va a representar el delegado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="28044-680">The name of the static method that the delegate is to represent.</span>
          </span>
        </param>
        <param name="ignoreCase">
          <span data-ttu-id="28044-681">Valor booleano que indica si debe omitirse la distinción de mayúsculas y minúsculas al comparar el nombre del método.</span>
          <span class="sxs-lookup">
            <span data-stu-id="28044-681">A Boolean indicating whether to ignore the case when comparing the name of the method.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="28044-682">Crea un delegado del tipo especificado que representa el método estático determinado de la clase especificada, con la distinción de mayúsculas y minúsculas definida.</span>
          <span class="sxs-lookup">
            <span data-stu-id="28044-682">Creates a delegate of the specified type that represents the specified static method of the specified class, with the specified case-sensitivity.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="28044-683">Delegado del tipo especificado que representa el método estático especificado de la clase especificada.</span>
          <span class="sxs-lookup">
            <span data-stu-id="28044-683">A delegate of the specified type that represents the specified static method of the specified class.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="28044-684">Este método crea a delegados para los métodos estáticos solo.</span><span class="sxs-lookup"><span data-stu-id="28044-684">This method creates delegates for static methods only.</span></span> <span data-ttu-id="28044-685">Un método de instancia es un método que está asociado a una instancia de una clase; un método estático es un método que está asociado a la propia clase.</span><span class="sxs-lookup"><span data-stu-id="28044-685">An instance method is a method that is associated with an instance of a class; a static method is a method that is associated with the class itself.</span></span>  
  
 <span data-ttu-id="28044-686">Esta sobrecarga del método es equivalente a llamar a la <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Type%2CSystem.String%2CSystem.Boolean%2CSystem.Boolean%29> sobrecarga del método, especificando `true` para `throwOnBindFailure`.</span><span class="sxs-lookup"><span data-stu-id="28044-686">This method overload is equivalent to calling the <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Type%2CSystem.String%2CSystem.Boolean%2CSystem.Boolean%29> method overload, specifying `true` for `throwOnBindFailure`.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="28044-687">A partir de la [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], este método se puede utilizar para tener acceso a los métodos no públicos si se ha concedido el autor de llamada <xref:System.Security.Permissions.ReflectionPermission> con el <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> marca y, si el conjunto de permisos de los métodos no públicos se restringe al llamador conceda conjunto o un subconjunto de los mismos.</span><span class="sxs-lookup"><span data-stu-id="28044-687">Starting with the [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], this method can be used to access non-public methods if the caller has been granted <xref:System.Security.Permissions.ReflectionPermission> with the <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> flag and if the grant set of the non-public methods is restricted to the caller’s grant set, or a subset thereof.</span></span> <span data-ttu-id="28044-688">(Consulte [consideraciones de seguridad para la reflexión](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)</span><span class="sxs-lookup"><span data-stu-id="28044-688">(See [Security Considerations for Reflection](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)</span></span>  
>   
>  <span data-ttu-id="28044-689">Para utilizar esta funcionalidad, la aplicación debe utilizar [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] o posterior como destino.</span><span class="sxs-lookup"><span data-stu-id="28044-689">To use this functionality, your application should target the [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] or later.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="28044-690">
            <paramref name="type" /> es <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="28044-690">
              <paramref name="type" /> is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="28044-691">O bien</span>
          <span class="sxs-lookup">
            <span data-stu-id="28044-691">-or-</span>
          </span>
          <span data-ttu-id="28044-692">
            <paramref name="target" /> es <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="28044-692">
              <paramref name="target" /> is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="28044-693">O bien</span>
          <span class="sxs-lookup">
            <span data-stu-id="28044-693">-or-</span>
          </span>
          <span data-ttu-id="28044-694">
            <paramref name="method" /> es <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="28044-694">
              <paramref name="method" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="28044-695">
            <paramref name="type" /> no hereda <see cref="T:System.MulticastDelegate" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="28044-695">
              <paramref name="type" /> does not inherit <see cref="T:System.MulticastDelegate" />.</span>
          </span>
          <span data-ttu-id="28044-696">O bien</span>
          <span class="sxs-lookup">
            <span data-stu-id="28044-696">-or-</span>
          </span>
          <span data-ttu-id="28044-697">
            <paramref name="type" /> no es un <see langword="RuntimeType" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="28044-697">
              <paramref name="type" /> is not a <see langword="RuntimeType" />.</span>
          </span>
          <span data-ttu-id="28044-698">Vea [Tipos de reflexión en tiempo de ejecución](http://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858).</span>
          <span class="sxs-lookup">
            <span data-stu-id="28044-698">See [Runtime Types in Reflection](http://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858).</span>
          </span>
          <span data-ttu-id="28044-699">O bien</span>
          <span class="sxs-lookup">
            <span data-stu-id="28044-699">-or-</span>
          </span>
          <span data-ttu-id="28044-700">
            <paramref name="target" /> no es un <see langword="RuntimeType" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="28044-700">
              <paramref name="target" /> is not a <see langword="RuntimeType" />.</span>
          </span>
          <span data-ttu-id="28044-701">O bien</span>
          <span class="sxs-lookup">
            <span data-stu-id="28044-701">-or-</span>
          </span>
          <span data-ttu-id="28044-702">
            <paramref name="target" /> es un tipo genérico abierto.</span>
          <span class="sxs-lookup">
            <span data-stu-id="28044-702">
              <paramref name="target" /> is an open generic type.</span>
          </span>
          <span data-ttu-id="28044-703">Es decir, su propiedad <see cref="P:System.Type.ContainsGenericParameters" /> es <see langword="true" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="28044-703">That is, its <see cref="P:System.Type.ContainsGenericParameters" /> property is <see langword="true" />.</span>
          </span>
          <span data-ttu-id="28044-704">O bien</span>
          <span class="sxs-lookup">
            <span data-stu-id="28044-704">-or-</span>
          </span>
          <span data-ttu-id="28044-705">
            <paramref name="method" /> no es un método <see langword="static" /> (método <see langword="Shared" /> en Visual Basic).</span>
          <span class="sxs-lookup">
            <span data-stu-id="28044-705">
              <paramref name="method" /> is not a <see langword="static" /> method (<see langword="Shared" /> method in Visual Basic).</span>
          </span>
          <span data-ttu-id="28044-706">O bien</span>
          <span class="sxs-lookup">
            <span data-stu-id="28044-706">-or-</span>
          </span>
          <span data-ttu-id="28044-707">
            <paramref name="method" /> no se puede enlazar, por ejemplo, porque no se encuentra.</span>
          <span class="sxs-lookup">
            <span data-stu-id="28044-707">
              <paramref name="method" /> cannot be bound, for example because it cannot be found.</span>
          </span>
        </exception>
        <exception cref="T:System.MissingMethodException">
          <span data-ttu-id="28044-708">No se encuentra el método <see langword="Invoke" /> de <paramref name="type" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="28044-708">The <see langword="Invoke" /> method of <paramref name="type" /> is not found.</span>
          </span>
        </exception>
        <exception cref="T:System.MethodAccessException">
          <span data-ttu-id="28044-709">El autor de la llamada no tiene los permisos necesarios para acceder a <paramref name="method" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="28044-709">The caller does not have the permissions necessary to access <paramref name="method" />.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">
          <span data-ttu-id="28044-710">Cuando se invoca en tiempo de ejecución a través de mecanismos como <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="28044-710">when invoked late-bound through mechanisms such as <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span>
          </span>
          <span data-ttu-id="28044-711">Enumeración asociada: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="28044-711">Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</span>
          </span>
        </permission>
        <altmember cref="T:System.Type" />
        <altmember cref="T:System.MulticastDelegate" />
        <altmember cref="T:System.Security.Permissions.ReflectionPermission" />
        <altmember cref="T:System.Object" />
      </Docs>
    </Member>
    <Member MemberName="CreateDelegate">
      <MemberSignature Language="C#" Value="public static Delegate CreateDelegate (Type type, object target, string method, bool ignoreCase, bool throwOnBindFailure);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Delegate CreateDelegate(class System.Type type, object target, string method, bool ignoreCase, bool throwOnBindFailure) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.String,System.Boolean,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Delegate ^ CreateDelegate(Type ^ type, System::Object ^ target, System::String ^ method, bool ignoreCase, bool throwOnBindFailure);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="target" Type="System.Object" />
        <Parameter Name="method" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
        <Parameter Name="throwOnBindFailure" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="type">
          <span data-ttu-id="28044-712">
            <see cref="T:System.Type" /> de delegado que se va a crear.</span>
          <span class="sxs-lookup">
            <span data-stu-id="28044-712">The <see cref="T:System.Type" /> of delegate to create.</span>
          </span>
        </param>
        <param name="target">
          <span data-ttu-id="28044-713">Instancia de clase en la que se invoca a <c>method</c>.</span>
          <span class="sxs-lookup">
            <span data-stu-id="28044-713">The class instance on which <c>method</c> is invoked.</span>
          </span>
        </param>
        <param name="method">
          <span data-ttu-id="28044-714">Nombre del método de instancia que el delegado va a representar.</span>
          <span class="sxs-lookup">
            <span data-stu-id="28044-714">The name of the instance method that the delegate is to represent.</span>
          </span>
        </param>
        <param name="ignoreCase">
          <span data-ttu-id="28044-715">Valor booleano que indica si debe omitirse la distinción de mayúsculas y minúsculas al comparar el nombre del método.</span>
          <span class="sxs-lookup">
            <span data-stu-id="28044-715">A Boolean indicating whether to ignore the case when comparing the name of the method.</span>
          </span>
        </param>
        <param name="throwOnBindFailure">
          <span data-ttu-id="28044-716">Es <see langword="true" /> para iniciar una excepción si no se puede enlazar <c>method</c>; en caso contrario, es <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="28044-716">
              <see langword="true" /> to throw an exception if <c>method</c> cannot be bound; otherwise, <see langword="false" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="28044-717">Crea un delegado del tipo especificado que representa el método de instancia determinado que se va a invocar en la instancia de clase especificada, con la distinción de mayúsculas y minúsculas y el comportamiento que se hayan concretado para cuando se produce un error al enlazar.</span>
          <span class="sxs-lookup">
            <span data-stu-id="28044-717">Creates a delegate of the specified type that represents the specified instance method to invoke on the specified class instance, with the specified case-sensitivity and the specified behavior on failure to bind.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="28044-718">Delegado del tipo especificado que representa el método de instancia especificado que se va a invocar en la instancia de clase especificada.</span>
          <span class="sxs-lookup">
            <span data-stu-id="28044-718">A delegate of the specified type that represents the specified instance method to invoke on the specified class instance.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="28044-719">Este método sólo crea a delegados para la instancia métodos.</span><span class="sxs-lookup"><span data-stu-id="28044-719">This method creates delegates for instance methods only.</span></span> <span data-ttu-id="28044-720">Un método de instancia es un método que está asociado a una instancia de una clase; un método estático es un método que está asociado a la propia clase.</span><span class="sxs-lookup"><span data-stu-id="28044-720">An instance method is a method that is associated with an instance of a class; a static method is a method that is associated with the class itself.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="28044-721">A partir de la [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], este método se puede utilizar para tener acceso a los métodos no públicos si se ha concedido el autor de llamada <xref:System.Security.Permissions.ReflectionPermission> con el <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> marca y, si el conjunto de permisos de los métodos no públicos se restringe al llamador conceda conjunto o un subconjunto de los mismos.</span><span class="sxs-lookup"><span data-stu-id="28044-721">Starting with the [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], this method can be used to access non-public methods if the caller has been granted <xref:System.Security.Permissions.ReflectionPermission> with the <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> flag and if the grant set of the non-public methods is restricted to the caller’s grant set, or a subset thereof.</span></span> <span data-ttu-id="28044-722">(Consulte [consideraciones de seguridad para la reflexión](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)</span><span class="sxs-lookup"><span data-stu-id="28044-722">(See [Security Considerations for Reflection](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)</span></span>  
>   
>  <span data-ttu-id="28044-723">Para utilizar esta funcionalidad, la aplicación debe utilizar [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] o posterior como destino.</span><span class="sxs-lookup"><span data-stu-id="28044-723">To use this functionality, your application should target the [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] or later.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="28044-724">
            <paramref name="type" /> es <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="28044-724">
              <paramref name="type" /> is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="28044-725">O bien</span>
          <span class="sxs-lookup">
            <span data-stu-id="28044-725">-or-</span>
          </span>
          <span data-ttu-id="28044-726">
            <paramref name="target" /> es <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="28044-726">
              <paramref name="target" /> is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="28044-727">O bien</span>
          <span class="sxs-lookup">
            <span data-stu-id="28044-727">-or-</span>
          </span>
          <span data-ttu-id="28044-728">
            <paramref name="method" /> es <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="28044-728">
              <paramref name="method" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="28044-729">
            <paramref name="type" /> no hereda <see cref="T:System.MulticastDelegate" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="28044-729">
              <paramref name="type" /> does not inherit <see cref="T:System.MulticastDelegate" />.</span>
          </span>
          <span data-ttu-id="28044-730">O bien</span>
          <span class="sxs-lookup">
            <span data-stu-id="28044-730">-or-</span>
          </span>
          <span data-ttu-id="28044-731">
            <paramref name="type" /> no es un <see langword="RuntimeType" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="28044-731">
              <paramref name="type" /> is not a <see langword="RuntimeType" />.</span>
          </span>
          <span data-ttu-id="28044-732">Vea [Tipos de reflexión en tiempo de ejecución](http://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858).</span>
          <span class="sxs-lookup">
            <span data-stu-id="28044-732">See [Runtime Types in Reflection](http://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858).</span>
          </span>
          <span data-ttu-id="28044-733">O bien</span>
          <span class="sxs-lookup">
            <span data-stu-id="28044-733">-or-</span>
          </span>
          <span data-ttu-id="28044-734">
            <paramref name="method" /> no es un método de instancia.</span>
          <span class="sxs-lookup">
            <span data-stu-id="28044-734">
              <paramref name="method" /> is not an instance method.</span>
          </span>
          <span data-ttu-id="28044-735">O bien</span>
          <span class="sxs-lookup">
            <span data-stu-id="28044-735">-or-</span>
          </span>
          <span data-ttu-id="28044-736">
            <paramref name="method" /> no se puede enlazar (por ejemplo, porque no se encuentra) y <paramref name="throwOnBindFailure" /> es <see langword="true" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="28044-736">
              <paramref name="method" /> cannot be bound, for example because it cannot be found, and <paramref name="throwOnBindFailure" /> is <see langword="true" />.</span>
          </span>
        </exception>
        <exception cref="T:System.MissingMethodException">
          <span data-ttu-id="28044-737">No se encuentra el método <see langword="Invoke" /> de <paramref name="type" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="28044-737">The <see langword="Invoke" /> method of <paramref name="type" /> is not found.</span>
          </span>
        </exception>
        <exception cref="T:System.MethodAccessException">
          <span data-ttu-id="28044-738">El autor de la llamada no tiene los permisos necesarios para acceder a <paramref name="method" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="28044-738">The caller does not have the permissions necessary to access <paramref name="method" />.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">
          <span data-ttu-id="28044-739">Cuando se invoca en tiempo de ejecución a través de mecanismos como <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="28044-739">when invoked late-bound through mechanisms such as <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span>
          </span>
          <span data-ttu-id="28044-740">Enumeración asociada: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="28044-740">Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</span>
          </span>
        </permission>
        <altmember cref="T:System.Type" />
        <altmember cref="T:System.MulticastDelegate" />
        <altmember cref="T:System.Security.Permissions.ReflectionPermission" />
        <altmember cref="T:System.Object" />
      </Docs>
    </Member>
    <Member MemberName="CreateDelegate">
      <MemberSignature Language="C#" Value="public static Delegate CreateDelegate (Type type, Type target, string method, bool ignoreCase, bool throwOnBindFailure);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Delegate CreateDelegate(class System.Type type, class System.Type target, string method, bool ignoreCase, bool throwOnBindFailure) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String,System.Boolean,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Delegate ^ CreateDelegate(Type ^ type, Type ^ target, System::String ^ method, bool ignoreCase, bool throwOnBindFailure);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="target" Type="System.Type" />
        <Parameter Name="method" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
        <Parameter Name="throwOnBindFailure" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="type">
          <span data-ttu-id="28044-741">
            <see cref="T:System.Type" /> de delegado que se va a crear.</span>
          <span class="sxs-lookup">
            <span data-stu-id="28044-741">The <see cref="T:System.Type" /> of delegate to create.</span>
          </span>
        </param>
        <param name="target">
          <span data-ttu-id="28044-742">
            <see cref="T:System.Type" /> que representa la clase que implementa <c>method</c>.</span>
          <span class="sxs-lookup">
            <span data-stu-id="28044-742">The <see cref="T:System.Type" /> representing the class that implements <c>method</c>.</span>
          </span>
        </param>
        <param name="method">
          <span data-ttu-id="28044-743">Nombre del método estático que va a representar el delegado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="28044-743">The name of the static method that the delegate is to represent.</span>
          </span>
        </param>
        <param name="ignoreCase">
          <span data-ttu-id="28044-744">Valor booleano que indica si debe omitirse la distinción de mayúsculas y minúsculas al comparar el nombre del método.</span>
          <span class="sxs-lookup">
            <span data-stu-id="28044-744">A Boolean indicating whether to ignore the case when comparing the name of the method.</span>
          </span>
        </param>
        <param name="throwOnBindFailure">
          <span data-ttu-id="28044-745">Es <see langword="true" /> para iniciar una excepción si no se puede enlazar <c>method</c>; en caso contrario, es <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="28044-745">
              <see langword="true" /> to throw an exception if <c>method</c> cannot be bound; otherwise, <see langword="false" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="28044-746">Crea un delegado del tipo especificado que representa el método estático determinado de la clase especificada, con la distinción de mayúsculas y minúsculas definida y el comportamiento que se haya concretado para cuando se produce un error al enlazar.</span>
          <span class="sxs-lookup">
            <span data-stu-id="28044-746">Creates a delegate of the specified type that represents the specified static method of the specified class, with the specified case-sensitivity and the specified behavior on failure to bind.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="28044-747">Delegado del tipo especificado que representa el método estático especificado de la clase especificada.</span>
          <span class="sxs-lookup">
            <span data-stu-id="28044-747">A delegate of the specified type that represents the specified static method of the specified class.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="28044-748">Este método crea a delegados para los métodos estáticos solo.</span><span class="sxs-lookup"><span data-stu-id="28044-748">This method creates delegates for static methods only.</span></span> <span data-ttu-id="28044-749">Un método de instancia es un método que está asociado a una instancia de una clase; un método estático es un método que está asociado a la propia clase.</span><span class="sxs-lookup"><span data-stu-id="28044-749">An instance method is a method that is associated with an instance of a class; a static method is a method that is associated with the class itself.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="28044-750">A partir de la [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], este método se puede utilizar para tener acceso a los métodos no públicos si se ha concedido el autor de llamada <xref:System.Security.Permissions.ReflectionPermission> con el <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> marca y, si el conjunto de permisos de los métodos no públicos se restringe al llamador conceda conjunto o un subconjunto de los mismos.</span><span class="sxs-lookup"><span data-stu-id="28044-750">Starting with the [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], this method can be used to access non-public methods if the caller has been granted <xref:System.Security.Permissions.ReflectionPermission> with the <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> flag and if the grant set of the non-public methods is restricted to the caller’s grant set, or a subset thereof.</span></span> <span data-ttu-id="28044-751">(Consulte [consideraciones de seguridad para la reflexión](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)</span><span class="sxs-lookup"><span data-stu-id="28044-751">(See [Security Considerations for Reflection](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)</span></span>  
>   
>  <span data-ttu-id="28044-752">Para utilizar esta funcionalidad, la aplicación debe utilizar [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] o posterior como destino.</span><span class="sxs-lookup"><span data-stu-id="28044-752">To use this functionality, your application should target the [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] or later.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="28044-753">
            <paramref name="type" /> es <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="28044-753">
              <paramref name="type" /> is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="28044-754">O bien</span>
          <span class="sxs-lookup">
            <span data-stu-id="28044-754">-or-</span>
          </span>
          <span data-ttu-id="28044-755">
            <paramref name="target" /> es <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="28044-755">
              <paramref name="target" /> is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="28044-756">O bien</span>
          <span class="sxs-lookup">
            <span data-stu-id="28044-756">-or-</span>
          </span>
          <span data-ttu-id="28044-757">
            <paramref name="method" /> es <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="28044-757">
              <paramref name="method" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="28044-758">
            <paramref name="type" /> no hereda <see cref="T:System.MulticastDelegate" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="28044-758">
              <paramref name="type" /> does not inherit <see cref="T:System.MulticastDelegate" />.</span>
          </span>
          <span data-ttu-id="28044-759">O bien</span>
          <span class="sxs-lookup">
            <span data-stu-id="28044-759">-or-</span>
          </span>
          <span data-ttu-id="28044-760">
            <paramref name="type" /> no es un <see langword="RuntimeType" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="28044-760">
              <paramref name="type" /> is not a <see langword="RuntimeType" />.</span>
          </span>
          <span data-ttu-id="28044-761">Vea [Tipos de reflexión en tiempo de ejecución](http://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858).</span>
          <span class="sxs-lookup">
            <span data-stu-id="28044-761">See [Runtime Types in Reflection](http://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858).</span>
          </span>
          <span data-ttu-id="28044-762">O bien</span>
          <span class="sxs-lookup">
            <span data-stu-id="28044-762">-or-</span>
          </span>
          <span data-ttu-id="28044-763">
            <paramref name="target" /> no es un <see langword="RuntimeType" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="28044-763">
              <paramref name="target" /> is not a <see langword="RuntimeType" />.</span>
          </span>
          <span data-ttu-id="28044-764">O bien</span>
          <span class="sxs-lookup">
            <span data-stu-id="28044-764">-or-</span>
          </span>
          <span data-ttu-id="28044-765">
            <paramref name="target" /> es un tipo genérico abierto.</span>
          <span class="sxs-lookup">
            <span data-stu-id="28044-765">
              <paramref name="target" /> is an open generic type.</span>
          </span>
          <span data-ttu-id="28044-766">Es decir, su propiedad <see cref="P:System.Type.ContainsGenericParameters" /> es <see langword="true" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="28044-766">That is, its <see cref="P:System.Type.ContainsGenericParameters" /> property is <see langword="true" />.</span>
          </span>
          <span data-ttu-id="28044-767">O bien</span>
          <span class="sxs-lookup">
            <span data-stu-id="28044-767">-or-</span>
          </span>
          <span data-ttu-id="28044-768">
            <paramref name="method" /> no es un método <see langword="static" /> (método <see langword="Shared" /> en Visual Basic).</span>
          <span class="sxs-lookup">
            <span data-stu-id="28044-768">
              <paramref name="method" /> is not a <see langword="static" /> method (<see langword="Shared" /> method in Visual Basic).</span>
          </span>
          <span data-ttu-id="28044-769">O bien</span>
          <span class="sxs-lookup">
            <span data-stu-id="28044-769">-or-</span>
          </span>
          <span data-ttu-id="28044-770">
            <paramref name="method" /> no se puede enlazar (por ejemplo, porque no se encuentra) y <paramref name="throwOnBindFailure" /> es <see langword="true" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="28044-770">
              <paramref name="method" /> cannot be bound, for example because it cannot be found, and <paramref name="throwOnBindFailure" /> is <see langword="true" />.</span>
          </span>
        </exception>
        <exception cref="T:System.MissingMethodException">
          <span data-ttu-id="28044-771">No se encuentra el método <see langword="Invoke" /> de <paramref name="type" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="28044-771">The <see langword="Invoke" /> method of <paramref name="type" /> is not found.</span>
          </span>
        </exception>
        <exception cref="T:System.MethodAccessException">
          <span data-ttu-id="28044-772">El autor de la llamada no tiene los permisos necesarios para acceder a <paramref name="method" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="28044-772">The caller does not have the permissions necessary to access <paramref name="method" />.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">
          <span data-ttu-id="28044-773">Cuando se invoca en tiempo de ejecución a través de mecanismos como <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="28044-773">when invoked late-bound through mechanisms such as <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span>
          </span>
          <span data-ttu-id="28044-774">Enumeración asociada: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="28044-774">Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</span>
          </span>
        </permission>
        <altmember cref="T:System.Type" />
        <altmember cref="T:System.MulticastDelegate" />
        <altmember cref="T:System.Security.Permissions.ReflectionPermission" />
        <altmember cref="T:System.Object" />
      </Docs>
    </Member>
    <Member MemberName="DynamicInvoke">
      <MemberSignature Language="C#" Value="public object DynamicInvoke (params object[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object DynamicInvoke(object[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.DynamicInvoke(System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function DynamicInvoke (ParamArray args As Object()) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ DynamicInvoke(... cli::array &lt;System::Object ^&gt; ^ args);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="args" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="args">
          <span data-ttu-id="28044-775">Matriz de objetos que son los argumentos que se van a pasar al método representado por el delegado actual.</span>
          <span class="sxs-lookup">
            <span data-stu-id="28044-775">An array of objects that are the arguments to pass to the method represented by the current delegate.</span>
          </span>
          <span data-ttu-id="28044-776">O bien</span>
          <span class="sxs-lookup">
            <span data-stu-id="28044-776">-or-</span>
          </span>
          <span data-ttu-id="28044-777">
            <see langword="null" />, si el método representado por el delegado actual no requiere argumentos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="28044-777">
              <see langword="null" />, if the method represented by the current delegate does not require arguments.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="28044-778">Invoca dinámicamente (en tiempo de ejecución) al método representado por el delegado actual.</span>
          <span class="sxs-lookup">
            <span data-stu-id="28044-778">Dynamically invokes (late-bound) the method represented by the current delegate.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="28044-779">Objeto devuelto por el método representado por el delegado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="28044-779">The object returned by the method represented by the delegate.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="28044-780">Este método llama al método <xref:System.Delegate.DynamicInvokeImpl%2A>.</span><span class="sxs-lookup"><span data-stu-id="28044-780">This method calls the <xref:System.Delegate.DynamicInvokeImpl%2A> method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.MemberAccessException">
          <span data-ttu-id="28044-781">El llamador no tiene acceso al método representado por el delegado (por ejemplo, si el método es privado).</span>
          <span class="sxs-lookup">
            <span data-stu-id="28044-781">The caller does not have access to the method represented by the delegate (for example, if the method is private).</span>
          </span>
          <span data-ttu-id="28044-782">O bien</span>
          <span class="sxs-lookup">
            <span data-stu-id="28044-782">-or-</span>
          </span>
          <span data-ttu-id="28044-783">El número, orden o tipo de los parámetros enumerados en <paramref name="args" /> no es válido.</span>
          <span class="sxs-lookup">
            <span data-stu-id="28044-783">The number, order, or type of parameters listed in <paramref name="args" /> is invalid.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="28044-784">El método representado por el delegado se invoca en un objeto o en una clase que no lo admite.</span>
          <span class="sxs-lookup">
            <span data-stu-id="28044-784">The method represented by the delegate is invoked on an object or a class that does not support it.</span>
          </span>
        </exception>
        <exception cref="T:System.Reflection.TargetInvocationException">
          <span data-ttu-id="28044-785">El método representado por el delegado es un método de instancia y el objeto de destino es <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="28044-785">The method represented by the delegate is an instance method and the target object is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="28044-786">O bien</span>
          <span class="sxs-lookup">
            <span data-stu-id="28044-786">-or-</span>
          </span>
          <span data-ttu-id="28044-787">Uno de los métodos encapsulados produce una excepción.</span>
          <span class="sxs-lookup">
            <span data-stu-id="28044-787">One of the encapsulated methods throws an exception.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">
          <span data-ttu-id="28044-788">Cuando se invoca en tiempo de ejecución a través de mecanismos como <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="28044-788">when invoked late-bound through mechanisms such as <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span>
          </span>
          <span data-ttu-id="28044-789">Enumeración asociada: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span>
          <span class="sxs-lookup">
            <span data-stu-id="28044-789">Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span>
          </span>
        </permission>
        <altmember cref="M:System.Delegate.DynamicInvokeImpl(System.Object[])" />
        <altmember cref="T:System.Object" />
      </Docs>
    </Member>
    <Member MemberName="DynamicInvokeImpl">
      <MemberSignature Language="C#" Value="protected virtual object DynamicInvokeImpl (object[] args);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance object DynamicInvokeImpl(object[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.DynamicInvokeImpl(System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function DynamicInvokeImpl (args As Object()) As Object" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Object ^ DynamicInvokeImpl(cli::array &lt;System::Object ^&gt; ^ args);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="args" Type="System.Object[]" />
      </Parameters>
      <Docs>
        <param name="args">
          <span data-ttu-id="28044-790">Matriz de objetos que son los argumentos que se van a pasar al método representado por el delegado actual.</span>
          <span class="sxs-lookup">
            <span data-stu-id="28044-790">An array of objects that are the arguments to pass to the method represented by the current delegate.</span>
          </span>
          <span data-ttu-id="28044-791">O bien</span>
          <span class="sxs-lookup">
            <span data-stu-id="28044-791">-or-</span>
          </span>
          <span data-ttu-id="28044-792">
            <see langword="null" />, si el método representado por el delegado actual no requiere argumentos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="28044-792">
              <see langword="null" />, if the method represented by the current delegate does not require arguments.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="28044-793">Invoca dinámicamente (en tiempo de ejecución) al método representado por el delegado actual.</span>
          <span class="sxs-lookup">
            <span data-stu-id="28044-793">Dynamically invokes (late-bound) the method represented by the current delegate.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="28044-794">Objeto devuelto por el método representado por el delegado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="28044-794">The object returned by the method represented by the delegate.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="28044-795">Este método implementa el método <xref:System.Delegate.DynamicInvoke%2A>.</span><span class="sxs-lookup"><span data-stu-id="28044-795">This method implements the <xref:System.Delegate.DynamicInvoke%2A> method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.MemberAccessException">
          <span data-ttu-id="28044-796">El llamador no tiene acceso al método representado por el delegado (por ejemplo, si el método es privado).</span>
          <span class="sxs-lookup">
            <span data-stu-id="28044-796">The caller does not have access to the method represented by the delegate (for example, if the method is private).</span>
          </span>
          <span data-ttu-id="28044-797">O bien</span>
          <span class="sxs-lookup">
            <span data-stu-id="28044-797">-or-</span>
          </span>
          <span data-ttu-id="28044-798">El número, orden o tipo de los parámetros enumerados en <paramref name="args" /> no es válido.</span>
          <span class="sxs-lookup">
            <span data-stu-id="28044-798">The number, order, or type of parameters listed in <paramref name="args" /> is invalid.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="28044-799">El método representado por el delegado se invoca en un objeto o en una clase que no lo admite.</span>
          <span class="sxs-lookup">
            <span data-stu-id="28044-799">The method represented by the delegate is invoked on an object or a class that does not support it.</span>
          </span>
        </exception>
        <exception cref="T:System.Reflection.TargetInvocationException">
          <span data-ttu-id="28044-800">El método representado por el delegado es un método de instancia y el objeto de destino es <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="28044-800">The method represented by the delegate is an instance method and the target object is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="28044-801">O bien</span>
          <span class="sxs-lookup">
            <span data-stu-id="28044-801">-or-</span>
          </span>
          <span data-ttu-id="28044-802">Uno de los métodos encapsulados produce una excepción.</span>
          <span class="sxs-lookup">
            <span data-stu-id="28044-802">One of the encapsulated methods throws an exception.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">
          <span data-ttu-id="28044-803">Cuando se invoca en tiempo de ejecución a través de mecanismos como <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="28044-803">when invoked late-bound through mechanisms such as <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span>
          </span>
          <span data-ttu-id="28044-804">Enumeración asociada: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span>
          <span class="sxs-lookup">
            <span data-stu-id="28044-804">Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span>
          </span>
        </permission>
        <altmember cref="M:System.Delegate.DynamicInvoke(System.Object[])" />
        <altmember cref="T:System.Object" />
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (obj As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ obj);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">
          <span data-ttu-id="28044-805">Objeto que se va a comparar con el delegado actual.</span>
          <span class="sxs-lookup">
            <span data-stu-id="28044-805">The object to compare with the current delegate.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="28044-806">Determina si el objeto especificado y el delegado actual son del mismo tipo y comparten los mismos destinos, métodos y listas de invocaciones.</span>
          <span class="sxs-lookup">
            <span data-stu-id="28044-806">Determines whether the specified object and the current delegate are of the same type and share the same targets, methods, and invocation list.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="28044-807">
            <see langword="true" /> si <paramref name="obj" /> y el delegado actual tienen los mismos destinos, métodos y listas de invocaciones; de lo contrario, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="28044-807">
              <see langword="true" /> if <paramref name="obj" /> and the current delegate have the same targets, methods, and invocation list; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="28044-808">Si los dos delegados no son del mismo tipo, no se consideran iguales.</span><span class="sxs-lookup"><span data-stu-id="28044-808">If the two delegates are not of the same type, they are not considered equal.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="28044-809">En la versión 1.0 y 1.1 de .NET Framework, se considera que dos delegados eran iguales si sus destinos, métodos y lista de invocaciones eran iguales, aunque los delegados sean de tipos diferentes.</span><span class="sxs-lookup"><span data-stu-id="28044-809">In the .NET Framework version 1.0 and 1.1, two delegates were considered equal if their targets, methods, and invocation list were equal, even if the delegates were of different types.</span></span>  
  
 <span data-ttu-id="28044-810">Los métodos y los destinos se comparan la igualdad como sigue:</span><span class="sxs-lookup"><span data-stu-id="28044-810">The methods and targets are compared for equality as follows:</span></span>  
  
-   <span data-ttu-id="28044-811">Si los dos métodos que se comparan son ambas estático y el mismo método en la misma clase, los métodos se consideran iguales y los destinos también se consideran iguales.</span><span class="sxs-lookup"><span data-stu-id="28044-811">If the two methods being compared are both static and are the same method on the same class, the methods are considered equal and the targets are also considered equal.</span></span>  
  
-   <span data-ttu-id="28044-812">Si los dos métodos que se comparan son métodos de instancia y el mismo método en el mismo objeto, los métodos se consideran iguales y los destinos también se consideran iguales.</span><span class="sxs-lookup"><span data-stu-id="28044-812">If the two methods being compared are instance methods and are the same method on the same object, the methods are considered equal and the targets are also considered equal.</span></span>  
  
-   <span data-ttu-id="28044-813">En caso contrario, los métodos no se consideran iguales y los destinos también se consideran no son iguales.</span><span class="sxs-lookup"><span data-stu-id="28044-813">Otherwise, the methods are not considered to be equal and the targets are also not considered to be equal.</span></span>  
  
 <span data-ttu-id="28044-814">Dos listas de invocaciones se consideran idénticas si tienen el mismo orden y los elementos correspondientes de las dos listas representan el mismo método y destino.</span><span class="sxs-lookup"><span data-stu-id="28044-814">Two invocation lists are considered identical only if they have the same order and the corresponding elements from the two lists represent the same method and target.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.MemberAccessException">
          <span data-ttu-id="28044-815">El llamador no tiene acceso al método representado por el delegado (por ejemplo, si el método es privado).</span>
          <span class="sxs-lookup">
            <span data-stu-id="28044-815">The caller does not have access to the method represented by the delegate (for example, if the method is private).</span>
          </span>
        </exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">
          <span data-ttu-id="28044-816">Cuando se invoca en tiempo de ejecución a través de mecanismos como <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="28044-816">when invoked late-bound through mechanisms such as <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span>
          </span>
          <span data-ttu-id="28044-817">Enumeración asociada: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span>
          <span class="sxs-lookup">
            <span data-stu-id="28044-817">Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span>
          </span>
        </permission>
        <altmember cref="T:System.Object" />
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="28044-818">Devuelve un código hash para el delegado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="28044-818">Returns a hash code for the delegate.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="28044-819">Código hash para el delegado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="28044-819">A hash code for the delegate.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="28044-820">El valor devuelto de este método no debe almacenarse por dos motivos.</span><span class="sxs-lookup"><span data-stu-id="28044-820">The return value of this method must not be persisted for two reasons.</span></span> <span data-ttu-id="28044-821">En primer lugar, la función hash de una clase podría modificarse para generar una mejor distribución inútil los valores de la antigua función hash.</span><span class="sxs-lookup"><span data-stu-id="28044-821">First, the hash function of a class might be altered to generate a better distribution, rendering any values from the old hash function useless.</span></span> <span data-ttu-id="28044-822">En segundo lugar, la implementación predeterminada de esta clase no garantiza que se devolverá el mismo valor en instancias diferentes.</span><span class="sxs-lookup"><span data-stu-id="28044-822">Second, the default implementation of this class does not guarantee that the same value will be returned by different instances.</span></span>  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">
          <span data-ttu-id="28044-823">Cuando se invoca en tiempo de ejecución a través de mecanismos como <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="28044-823">when invoked late-bound through mechanisms such as <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span>
          </span>
          <span data-ttu-id="28044-824">Enumeración asociada: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span>
          <span class="sxs-lookup">
            <span data-stu-id="28044-824">Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span>
          </span>
        </permission>
        <altmember cref="M:System.Object.GetHashCode" />
      </Docs>
    </Member>
    <Member MemberName="GetInvocationList">
      <MemberSignature Language="C#" Value="public virtual Delegate[] GetInvocationList ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Delegate[] GetInvocationList() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.GetInvocationList" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetInvocationList () As Delegate()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;Delegate ^&gt; ^ GetInvocationList();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Delegate[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="28044-825">Devuelve la lista de invocaciones del delegado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="28044-825">Returns the invocation list of the delegate.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="28044-826">Matriz de delegados que representa la lista de invocaciones del delegado actual.</span>
          <span class="sxs-lookup">
            <span data-stu-id="28044-826">An array of delegates representing the invocation list of the current delegate.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="28044-827">Cada delegado de la matriz representa exactamente un método.</span><span class="sxs-lookup"><span data-stu-id="28044-827">Each delegate in the array represents exactly one method.</span></span>  
  
 <span data-ttu-id="28044-828">El orden de los delegados de la matriz es el mismo orden en que el delegado actual invoca los métodos que representan dichos delegados.</span><span class="sxs-lookup"><span data-stu-id="28044-828">The order of the delegates in the array is the same order in which the current delegate invokes the methods that those delegates represent.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="28044-829">En el ejemplo siguiente se asigna tres métodos a un delegado.</span><span class="sxs-lookup"><span data-stu-id="28044-829">The following example assigns three methods to a delegate.</span></span> <span data-ttu-id="28044-830">A continuación, llama el <xref:System.Delegate.GetInvocationList%2A> método para obtener un recuento total de los métodos que se asigna al delegado para ejecutar los delegados en orden inverso así como ejecutar los métodos cuyo nombre no incluyen la subcadena "File".</span><span class="sxs-lookup"><span data-stu-id="28044-830">It then calls the  <xref:System.Delegate.GetInvocationList%2A> method to get a total count of the methods assigned to the delegate, to execute the delegates in reverse order, and to execute the methods whose name do not include the substring "File".</span></span>  
  
 [!code-csharp[System.Delegate.GetInvocationList#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Delegate.GetInvocationList/cs/GetInvocationList1.cs#1)]
 [!code-vb[System.Delegate.GetInvocationList#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Delegate.GetInvocationList/vb/GetInvocationList1.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">
          <span data-ttu-id="28044-831">Cuando se invoca en tiempo de ejecución a través de mecanismos como <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="28044-831">when invoked late-bound through mechanisms such as <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span>
          </span>
          <span data-ttu-id="28044-832">Enumeración asociada: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span>
          <span class="sxs-lookup">
            <span data-stu-id="28044-832">Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span>
          </span>
        </permission>
      </Docs>
    </Member>
    <Member MemberName="GetMethodImpl">
      <MemberSignature Language="C#" Value="protected virtual System.Reflection.MethodInfo GetMethodImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Reflection.MethodInfo GetMethodImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.GetMethodImpl" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function GetMethodImpl () As MethodInfo" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Reflection::MethodInfo ^ GetMethodImpl();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="28044-833">Obtiene el método estático representado por el delegado actual.</span>
          <span class="sxs-lookup">
            <span data-stu-id="28044-833">Gets the static method represented by the current delegate.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="28044-834">
            <see cref="T:System.Reflection.MethodInfo" /> que describe el método estático representado por el delegado actual.</span>
          <span class="sxs-lookup">
            <span data-stu-id="28044-834">A <see cref="T:System.Reflection.MethodInfo" /> describing the static method represented by the current delegate.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="28044-835">Este método solo se aplica si el delegado actual representa un método estático.</span><span class="sxs-lookup"><span data-stu-id="28044-835">This method applies only if the current delegate represents a static method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.MemberAccessException">
          <span data-ttu-id="28044-836">El llamador no tiene acceso al método representado por el delegado (por ejemplo, si el método es privado).</span>
          <span class="sxs-lookup">
            <span data-stu-id="28044-836">The caller does not have access to the method represented by the delegate (for example, if the method is private).</span>
          </span>
        </exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">
          <span data-ttu-id="28044-837">Cuando se invoca en tiempo de ejecución a través de mecanismos como <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="28044-837">when invoked late-bound through mechanisms such as <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span>
          </span>
          <span data-ttu-id="28044-838">Enumeración asociada: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span>
          <span class="sxs-lookup">
            <span data-stu-id="28044-838">Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span>
          </span>
        </permission>
        <altmember cref="T:System.Reflection.MethodInfo" />
        <altmember cref="P:System.Delegate.Method" />
      </Docs>
    </Member>
    <Member MemberName="GetObjectData">
      <MemberSignature Language="C#" Value="public virtual void GetObjectData (System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void GetObjectData(class System.Runtime.Serialization.SerializationInfo info, valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub GetObjectData (info As SerializationInfo, context As StreamingContext)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void GetObjectData(System::Runtime::Serialization::SerializationInfo ^ info, System::Runtime::Serialization::StreamingContext context);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="info" Type="System.Runtime.Serialization.SerializationInfo" />
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" />
      </Parameters>
      <Docs>
        <param name="info">
          <span data-ttu-id="28044-839">No se admite.</span>
          <span class="sxs-lookup">
            <span data-stu-id="28044-839">Not supported.</span>
          </span>
        </param>
        <param name="context">
          <span data-ttu-id="28044-840">No se admite.</span>
          <span class="sxs-lookup">
            <span data-stu-id="28044-840">Not supported.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="28044-841">No se admite.</span>
          <span class="sxs-lookup">
            <span data-stu-id="28044-841">Not supported.</span>
          </span>
        </summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="28044-842">No se admite este método.</span>
          <span class="sxs-lookup">
            <span data-stu-id="28044-842">This method is not supported.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="28044-843">requiere plena confianza para el llamador inmediato.</span>
          <span class="sxs-lookup">
            <span data-stu-id="28044-843">Requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="28044-844">Este miembro no puede usarse por código de confianza parcial o transparente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="28044-844">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
        <altmember cref="T:System.Runtime.Serialization.ISerializable" />
        <altmember cref="T:System.Runtime.Serialization.SerializationInfo" />
        <altmember cref="T:System.Runtime.Serialization.StreamingContext" />
      </Docs>
    </Member>
    <Member MemberName="Method">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo Method { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.MethodInfo Method" />
      <MemberSignature Language="DocId" Value="P:System.Delegate.Method" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Method As MethodInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Reflection::MethodInfo ^ Method { System::Reflection::MethodInfo ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="28044-845">Obtiene el método representado por el delegado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="28044-845">Gets the method represented by the delegate.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="28044-846">
            <see cref="T:System.Reflection.MethodInfo" /> que describe el método representado por el delegado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="28044-846">A <see cref="T:System.Reflection.MethodInfo" /> describing the method represented by the delegate.</span>
          </span>
        </value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.MemberAccessException">
          <span data-ttu-id="28044-847">El llamador no tiene acceso al método representado por el delegado (por ejemplo, si el método es privado).</span>
          <span class="sxs-lookup">
            <span data-stu-id="28044-847">The caller does not have access to the method represented by the delegate (for example, if the method is private).</span>
          </span>
        </exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">
          <span data-ttu-id="28044-848">Cuando se invoca en tiempo de ejecución a través de mecanismos como <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="28044-848">when invoked late-bound through mechanisms such as <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span>
          </span>
          <span data-ttu-id="28044-849">Enumeración asociada: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span>
          <span class="sxs-lookup">
            <span data-stu-id="28044-849">Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span>
          </span>
        </permission>
        <altmember cref="T:System.Reflection.MethodInfo" />
        <altmember cref="M:System.Delegate.GetMethodImpl" />
      </Docs>
    </Member>
    <Member MemberName="op_Equality">
      <MemberSignature Language="C#" Value="public static bool operator == (Delegate d1, Delegate d2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Equality(class System.Delegate d1, class System.Delegate d2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.op_Equality(System.Delegate,System.Delegate)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator == (d1 As Delegate, d2 As Delegate) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator ==(Delegate ^ d1, Delegate ^ d2);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d1" Type="System.Delegate" />
        <Parameter Name="d2" Type="System.Delegate" />
      </Parameters>
      <Docs>
        <param name="d1">
          <span data-ttu-id="28044-850">Primer delegado que se va a comparar.</span>
          <span class="sxs-lookup">
            <span data-stu-id="28044-850">The first delegate to compare.</span>
          </span>
        </param>
        <param name="d2">
          <span data-ttu-id="28044-851">Segundo delegado que se va a comparar.</span>
          <span class="sxs-lookup">
            <span data-stu-id="28044-851">The second delegate to compare.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="28044-852">Determina si los delegados especificados son iguales.</span>
          <span class="sxs-lookup">
            <span data-stu-id="28044-852">Determines whether the specified delegates are equal.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="28044-853">
            <see langword="true" /> si <paramref name="d1" /> es igual a <paramref name="d2" />; en caso contrario, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="28044-853">
              <see langword="true" /> if <paramref name="d1" /> is equal to <paramref name="d2" />; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="28044-854">Dos delegados del mismo tipo con los mismos destinos, métodos y listas de invocaciones se consideran iguales.</span><span class="sxs-lookup"><span data-stu-id="28044-854">Two delegates of the same type with the same targets, methods, and invocation lists are considered equal.</span></span>  
  
 <span data-ttu-id="28044-855">Si los dos delegados no son del mismo tipo, no se consideran iguales.</span><span class="sxs-lookup"><span data-stu-id="28044-855">If the two delegates are not of the same type, they are not considered equal.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="28044-856">En la versión 1.0 y 1.1 de .NET Framework, se considera que dos delegados eran iguales si sus destinos, métodos y lista de invocaciones eran iguales, aunque los delegados sean de tipos diferentes.</span><span class="sxs-lookup"><span data-stu-id="28044-856">In the .NET Framework version 1.0 and 1.1, two delegates were considered equal if their targets, methods, and invocation list were equal, even if the delegates were of different types.</span></span>  
  
 <span data-ttu-id="28044-857">Los métodos y los destinos se comparan la igualdad como sigue:</span><span class="sxs-lookup"><span data-stu-id="28044-857">The methods and targets are compared for equality as follows:</span></span>  
  
-   <span data-ttu-id="28044-858">Si los dos métodos que se comparan son ambas estático y el mismo método en la misma clase, los métodos se consideran iguales y los destinos también se consideran iguales.</span><span class="sxs-lookup"><span data-stu-id="28044-858">If the two methods being compared are both static and are the same method on the same class, the methods are considered equal and the targets are also considered equal.</span></span>  
  
-   <span data-ttu-id="28044-859">Si los dos métodos que se comparan son métodos de instancia y el mismo método en el mismo objeto, los métodos se consideran iguales y los destinos también se consideran iguales.</span><span class="sxs-lookup"><span data-stu-id="28044-859">If the two methods being compared are instance methods and are the same method on the same object, the methods are considered equal and the targets are also considered equal.</span></span>  
  
-   <span data-ttu-id="28044-860">En caso contrario, los métodos no se consideran iguales y los destinos también se consideran no son iguales.</span><span class="sxs-lookup"><span data-stu-id="28044-860">Otherwise, the methods are not considered to be equal and the targets are also not considered to be equal.</span></span>  
  
 <span data-ttu-id="28044-861">Dos listas de invocaciones se consideran idénticas si tienen el mismo orden y los elementos correspondientes de las dos listas representan el mismo método y destino.</span><span class="sxs-lookup"><span data-stu-id="28044-861">Two invocation lists are considered identical if they have the same order and the corresponding elements from the two lists represent the same method and target.</span></span>  
  
 <span data-ttu-id="28044-862">El método equivalente para este operador es <xref:System.Delegate.Equals%28System.Object%29?displayProperty=nameWithType></span><span class="sxs-lookup"><span data-stu-id="28044-862">The equivalent method for this operator is <xref:System.Delegate.Equals%28System.Object%29?displayProperty=nameWithType></span></span>]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">
          <span data-ttu-id="28044-863">Cuando se invoca en tiempo de ejecución a través de mecanismos como <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="28044-863">when invoked late-bound through mechanisms such as <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span>
          </span>
          <span data-ttu-id="28044-864">Enumeración asociada: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span>
          <span class="sxs-lookup">
            <span data-stu-id="28044-864">Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span>
          </span>
        </permission>
        <altmember cref="M:System.Delegate.Equals(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="op_Inequality">
      <MemberSignature Language="C#" Value="public static bool operator != (Delegate d1, Delegate d2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Inequality(class System.Delegate d1, class System.Delegate d2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.op_Inequality(System.Delegate,System.Delegate)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator != (d1 As Delegate, d2 As Delegate) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator !=(Delegate ^ d1, Delegate ^ d2);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d1" Type="System.Delegate" />
        <Parameter Name="d2" Type="System.Delegate" />
      </Parameters>
      <Docs>
        <param name="d1">
          <span data-ttu-id="28044-865">Primer delegado que se va a comparar.</span>
          <span class="sxs-lookup">
            <span data-stu-id="28044-865">The first delegate to compare.</span>
          </span>
        </param>
        <param name="d2">
          <span data-ttu-id="28044-866">Segundo delegado que se va a comparar.</span>
          <span class="sxs-lookup">
            <span data-stu-id="28044-866">The second delegate to compare.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="28044-867">Determina si los delegados especificados no son iguales.</span>
          <span class="sxs-lookup">
            <span data-stu-id="28044-867">Determines whether the specified delegates are not equal.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="28044-868">Es <see langword="true" /> si <paramref name="d1" /> no es igual a <paramref name="d2" />; en caso contrario, es <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="28044-868">
              <see langword="true" /> if <paramref name="d1" /> is not equal to <paramref name="d2" />; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="28044-869">Se consideran que dos delegados no iguales si son de tipos diferentes, o tienen métodos distintos, destinos distintos o listas de invocaciones diferentes.</span><span class="sxs-lookup"><span data-stu-id="28044-869">Two delegates are considered not equal if they are of different types, or have different methods, different targets, or different invocation lists.</span></span>  
  
 <span data-ttu-id="28044-870">Si los dos delegados no son del mismo tipo, no se consideran iguales.</span><span class="sxs-lookup"><span data-stu-id="28044-870">If the two delegates are not of the same type, they are not considered equal.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="28044-871">En la versión 1.0 y 1.1 de .NET Framework, se considera que dos delegados son iguales si sus destinos, métodos y lista de invocaciones eran iguales, aunque los delegados sean de tipos diferentes.</span><span class="sxs-lookup"><span data-stu-id="28044-871">In the .NET Framework version 1.0 and 1.1, two delegates are considered equal if their targets, methods, and invocation list were equal, even if the delegates were of different types.</span></span>  
  
 <span data-ttu-id="28044-872">Los métodos y los destinos se comparan la igualdad como sigue:</span><span class="sxs-lookup"><span data-stu-id="28044-872">The methods and targets are compared for equality as follows:</span></span>  
  
-   <span data-ttu-id="28044-873">Si los dos métodos que se comparan son ambas estático y el mismo método en la misma clase, los métodos se consideran iguales y los destinos también se consideran iguales.</span><span class="sxs-lookup"><span data-stu-id="28044-873">If the two methods being compared are both static and are the same method on the same class, the methods are considered equal and the targets are also considered equal.</span></span>  
  
-   <span data-ttu-id="28044-874">Si los dos métodos que se comparan son métodos de instancia y el mismo método en el mismo objeto, los métodos se consideran iguales y los destinos también se consideran iguales.</span><span class="sxs-lookup"><span data-stu-id="28044-874">If the two methods being compared are instance methods and are the same method on the same object, the methods are considered equal and the targets are also considered equal.</span></span>  
  
-   <span data-ttu-id="28044-875">En caso contrario, los métodos no se consideran iguales y los destinos también se consideran no son iguales.</span><span class="sxs-lookup"><span data-stu-id="28044-875">Otherwise, the methods are not considered to be equal and the targets are also not considered to be equal.</span></span>  
  
 <span data-ttu-id="28044-876">Dos listas de invocaciones no son iguales si tienen tamaños diferentes, si se ordenan de forma diferente, o si al menos un elemento de una lista representa un método o destino diferente del representado por el elemento correspondiente de la otra lista.</span><span class="sxs-lookup"><span data-stu-id="28044-876">Two invocation lists are not equal if they have different sizes, if they are ordered differently, or if at least one element from one list represents a method or target that is different from that represented by its corresponding element in the other list.</span></span>  
  
 <span data-ttu-id="28044-877">El método equivalente para este operador es <xref:System.Delegate.Equals%28System.Object%29?displayProperty=nameWithType></span><span class="sxs-lookup"><span data-stu-id="28044-877">The equivalent method for this operator is <xref:System.Delegate.Equals%28System.Object%29?displayProperty=nameWithType></span></span>]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">
          <span data-ttu-id="28044-878">Cuando se invoca en tiempo de ejecución a través de mecanismos como <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="28044-878">when invoked late-bound through mechanisms such as <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span>
          </span>
          <span data-ttu-id="28044-879">Enumeración asociada: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span>
          <span class="sxs-lookup">
            <span data-stu-id="28044-879">Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span>
          </span>
        </permission>
        <altmember cref="M:System.Delegate.Equals(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Remove">
      <MemberSignature Language="C#" Value="public static Delegate Remove (Delegate source, Delegate value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Delegate Remove(class System.Delegate source, class System.Delegate value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.Remove(System.Delegate,System.Delegate)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Remove (source As Delegate, value As Delegate) As Delegate" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Delegate ^ Remove(Delegate ^ source, Delegate ^ value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Delegate" />
        <Parameter Name="value" Type="System.Delegate" />
      </Parameters>
      <Docs>
        <param name="source">
          <span data-ttu-id="28044-880">Delegado del que se va a quitar la lista de invocaciones de <c>value</c>.</span>
          <span class="sxs-lookup">
            <span data-stu-id="28044-880">The delegate from which to remove the invocation list of <c>value</c>.</span>
          </span>
        </param>
        <param name="value">
          <span data-ttu-id="28044-881">Delegado que proporciona la lista de invocaciones que se va a quitar de la lista de invocaciones de <c>source</c>.</span>
          <span class="sxs-lookup">
            <span data-stu-id="28044-881">The delegate that supplies the invocation list to remove from the invocation list of <c>source</c>.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="28044-882">Quita la última aparición de la lista de invocaciones de un delegado de la lista de invocaciones de otro delegado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="28044-882">Removes the last occurrence of the invocation list of a delegate from the invocation list of another delegate.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="28044-883">Nuevo delegado con una lista de invocaciones creada tomando la lista de invocaciones de <paramref name="source" /> y quitando la última aparición de la lista de invocaciones de <paramref name="value" />, si la lista de invocaciones de <paramref name="value" /> se encuentra dentro de la lista de invocaciones de <paramref name="source" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="28044-883">A new delegate with an invocation list formed by taking the invocation list of <paramref name="source" /> and removing the last occurrence of the invocation list of <paramref name="value" />, if the invocation list of <paramref name="value" /> is found within the invocation list of <paramref name="source" />.</span>
          </span>
          <span data-ttu-id="28044-884">Devuelve <paramref name="source" /> si <paramref name="value" /> es <see langword="null" /> o si la lista de invocaciones de <paramref name="value" /> no se encuentra dentro de la lista de invocaciones de <paramref name="source" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="28044-884">Returns <paramref name="source" /> if <paramref name="value" /> is <see langword="null" /> or if the invocation list of <paramref name="value" /> is not found within the invocation list of <paramref name="source" />.</span>
          </span>
          <span data-ttu-id="28044-885">Devuelve una referencia nula si la lista de invocaciones de <paramref name="value" /> es igual a la lista de invocaciones de <paramref name="source" /> o si <paramref name="source" /> es una referencia nula.</span>
          <span class="sxs-lookup">
            <span data-stu-id="28044-885">Returns a null reference if the invocation list of <paramref name="value" /> is equal to the invocation list of <paramref name="source" /> or if <paramref name="source" /> is a null reference.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="28044-886">Si la lista de invocaciones `value` coincide con un conjunto contiguo de elementos de la lista de invocaciones `source`, a continuación, la lista de invocaciones `value` se dice que se producen dentro de la lista de invocaciones `source`.</span><span class="sxs-lookup"><span data-stu-id="28044-886">If the invocation list of `value` matches a contiguous set of elements in the invocation list of `source`, then the invocation list of `value` is said to occur within the invocation list of `source`.</span></span> <span data-ttu-id="28044-887">Si la lista de invocaciones `value` aparece más de una vez en la lista de invocaciones `source`, se quita la última aparición.</span><span class="sxs-lookup"><span data-stu-id="28044-887">If the invocation list of `value` occurs more than once in the invocation list of `source`, the last occurrence is removed.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.MemberAccessException">
          <span data-ttu-id="28044-888">El llamador no tiene acceso al método representado por el delegado (por ejemplo, si el método es privado).</span>
          <span class="sxs-lookup">
            <span data-stu-id="28044-888">The caller does not have access to the method represented by the delegate (for example, if the method is private).</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="28044-889">Los tipos de delegado no coinciden.</span>
          <span class="sxs-lookup">
            <span data-stu-id="28044-889">The delegate types do not match.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">
          <span data-ttu-id="28044-890">Cuando se invoca en tiempo de ejecución a través de mecanismos como <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="28044-890">when invoked late-bound through mechanisms such as <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span>
          </span>
          <span data-ttu-id="28044-891">Enumeración asociada: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span>
          <span class="sxs-lookup">
            <span data-stu-id="28044-891">Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span>
          </span>
        </permission>
        <altmember cref="M:System.Delegate.RemoveAll(System.Delegate,System.Delegate)" />
        <altmember cref="M:System.Delegate.RemoveImpl(System.Delegate)" />
        <altmember cref="M:System.Delegate.Equals(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="RemoveAll">
      <MemberSignature Language="C#" Value="public static Delegate RemoveAll (Delegate source, Delegate value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Delegate RemoveAll(class System.Delegate source, class System.Delegate value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.RemoveAll(System.Delegate,System.Delegate)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function RemoveAll (source As Delegate, value As Delegate) As Delegate" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Delegate ^ RemoveAll(Delegate ^ source, Delegate ^ value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Delegate" />
        <Parameter Name="value" Type="System.Delegate" />
      </Parameters>
      <Docs>
        <param name="source">
          <span data-ttu-id="28044-892">Delegado del que se va a quitar la lista de invocaciones de <c>value</c>.</span>
          <span class="sxs-lookup">
            <span data-stu-id="28044-892">The delegate from which to remove the invocation list of <c>value</c>.</span>
          </span>
        </param>
        <param name="value">
          <span data-ttu-id="28044-893">Delegado que proporciona la lista de invocaciones que se va a quitar de la lista de invocaciones de <c>source</c>.</span>
          <span class="sxs-lookup">
            <span data-stu-id="28044-893">The delegate that supplies the invocation list to remove from the invocation list of <c>source</c>.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="28044-894">Quita todas las apariciones de la lista de invocaciones de un delegado de la lista de invocaciones de otro delegado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="28044-894">Removes all occurrences of the invocation list of a delegate from the invocation list of another delegate.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="28044-895">Nuevo delegado con una lista de invocaciones creada tomando la lista de invocaciones de <paramref name="source" /> y quitando todas las apariciones de la lista de invocaciones de <paramref name="value" />, si la lista de invocaciones de <paramref name="value" /> se encuentra dentro de la lista de invocaciones de <paramref name="source" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="28044-895">A new delegate with an invocation list formed by taking the invocation list of <paramref name="source" /> and removing all occurrences of the invocation list of <paramref name="value" />, if the invocation list of <paramref name="value" /> is found within the invocation list of <paramref name="source" />.</span>
          </span>
          <span data-ttu-id="28044-896">Devuelve <paramref name="source" /> si <paramref name="value" /> es <see langword="null" /> o si la lista de invocaciones de <paramref name="value" /> no se encuentra dentro de la lista de invocaciones de <paramref name="source" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="28044-896">Returns <paramref name="source" /> if <paramref name="value" /> is <see langword="null" /> or if the invocation list of <paramref name="value" /> is not found within the invocation list of <paramref name="source" />.</span>
          </span>
          <span data-ttu-id="28044-897">Devuelve una referencia nula si la lista de invocaciones de <paramref name="value" /> es igual a la de <paramref name="source" />, si <paramref name="source" /> contiene sólo una serie de listas de invocaciones que son iguales a la lista de invocaciones de <paramref name="value" />, o bien si <paramref name="source" /> es una referencia nula.</span>
          <span class="sxs-lookup">
            <span data-stu-id="28044-897">Returns a null reference if the invocation list of <paramref name="value" /> is equal to the invocation list of <paramref name="source" />, if <paramref name="source" /> contains only a series of invocation lists that are equal to the invocation list of <paramref name="value" />, or if <paramref name="source" /> is a null reference.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="28044-898">Si la lista de invocaciones `value` coincide con un conjunto contiguo de elementos de la lista de invocaciones `source`, a continuación, la lista de invocaciones `value` se dice que se producen dentro de la lista de invocaciones `source`.</span><span class="sxs-lookup"><span data-stu-id="28044-898">If the invocation list of `value` matches a contiguous set of elements in the invocation list of `source`, then the invocation list of `value` is said to occur within the invocation list of `source`.</span></span> <span data-ttu-id="28044-899">Si la lista de invocaciones `value` aparece más de una vez en la lista de invocaciones `source`, se quitan todas las apariciones.</span><span class="sxs-lookup"><span data-stu-id="28044-899">If the invocation list of `value` occurs more than once in the invocation list of `source`, all occurrences are removed.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.MemberAccessException">
          <span data-ttu-id="28044-900">El llamador no tiene acceso al método representado por el delegado (por ejemplo, si el método es privado).</span>
          <span class="sxs-lookup">
            <span data-stu-id="28044-900">The caller does not have access to the method represented by the delegate (for example, if the method is private).</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="28044-901">Los tipos de delegado no coinciden.</span>
          <span class="sxs-lookup">
            <span data-stu-id="28044-901">The delegate types do not match.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">
          <span data-ttu-id="28044-902">Cuando se invoca en tiempo de ejecución a través de mecanismos como <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="28044-902">when invoked late-bound through mechanisms such as <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span>
          </span>
          <span data-ttu-id="28044-903">Enumeración asociada: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span>
          <span class="sxs-lookup">
            <span data-stu-id="28044-903">Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span>
          </span>
        </permission>
        <altmember cref="M:System.Delegate.Remove(System.Delegate,System.Delegate)" />
        <altmember cref="M:System.Delegate.RemoveImpl(System.Delegate)" />
        <altmember cref="M:System.Delegate.Equals(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="RemoveImpl">
      <MemberSignature Language="C#" Value="protected virtual Delegate RemoveImpl (Delegate d);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Delegate RemoveImpl(class System.Delegate d) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.RemoveImpl(System.Delegate)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function RemoveImpl (d As Delegate) As Delegate" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual Delegate ^ RemoveImpl(Delegate ^ d);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d" Type="System.Delegate" />
      </Parameters>
      <Docs>
        <param name="d">
          <span data-ttu-id="28044-904">Delegado que proporciona la lista de invocaciones que se va a quitar de la lista de invocaciones del delegado actual.</span>
          <span class="sxs-lookup">
            <span data-stu-id="28044-904">The delegate that supplies the invocation list to remove from the invocation list of the current delegate.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="28044-905">Quita la lista de invocaciones de un delegado de la lista de invocaciones de otro delegado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="28044-905">Removes the invocation list of a delegate from the invocation list of another delegate.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="28044-906">Nuevo delegado con una lista de invocaciones creada tomando la lista de invocaciones del delegado actual y quitando la lista de invocaciones de <paramref name="value" />, si la lista de invocaciones de <paramref name="value" /> se encuentra dentro de la lista de invocaciones del delegado actual.</span>
          <span class="sxs-lookup">
            <span data-stu-id="28044-906">A new delegate with an invocation list formed by taking the invocation list of the current delegate and removing the invocation list of <paramref name="value" />, if the invocation list of <paramref name="value" /> is found within the current delegate's invocation list.</span>
          </span>
          <span data-ttu-id="28044-907">Devuelve el delegado actual si <paramref name="value" /> es <see langword="null" /> o si la lista de invocaciones de <paramref name="value" /> no se encuentra en la lista de invocaciones del delegado actual.</span>
          <span class="sxs-lookup">
            <span data-stu-id="28044-907">Returns the current delegate if <paramref name="value" /> is <see langword="null" /> or if the invocation list of <paramref name="value" /> is not found within the current delegate's invocation list.</span>
          </span>
          <span data-ttu-id="28044-908">Devuelve <see langword="null" /> si la lista de invocaciones de <paramref name="value" /> es igual que la lista de invocaciones del delegado actual.</span>
          <span class="sxs-lookup">
            <span data-stu-id="28044-908">Returns <see langword="null" /> if the invocation list of <paramref name="value" /> is equal to the current delegate's invocation list.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="28044-909">Si la lista de invocaciones `value` coincide con un conjunto contiguo de elementos de la lista de invocaciones del delegado actual, a continuación, en la lista de invocaciones `value` se dice que se producen dentro de la lista de invocaciones del delegado actual.</span><span class="sxs-lookup"><span data-stu-id="28044-909">If the invocation list of `value` matches a contiguous set of elements in the current delegate's invocation list, then the invocation list of `value` is said to occur within the current delegate's invocation list.</span></span> <span data-ttu-id="28044-910">Si la lista de invocaciones `value` se produce más de una vez en la lista de invocaciones del delegado actual, se quita la última aparición.</span><span class="sxs-lookup"><span data-stu-id="28044-910">If the invocation list of `value` occurs more than once in the current delegate's invocation list, the last occurrence is removed.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.MemberAccessException">
          <span data-ttu-id="28044-911">El llamador no tiene acceso al método representado por el delegado (por ejemplo, si el método es privado).</span>
          <span class="sxs-lookup">
            <span data-stu-id="28044-911">The caller does not have access to the method represented by the delegate (for example, if the method is private).</span>
          </span>
        </exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">
          <span data-ttu-id="28044-912">Cuando se invoca en tiempo de ejecución a través de mecanismos como <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="28044-912">when invoked late-bound through mechanisms such as <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span>
          </span>
          <span data-ttu-id="28044-913">Enumeración asociada: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span>
          <span class="sxs-lookup">
            <span data-stu-id="28044-913">Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span>
          </span>
        </permission>
        <altmember cref="M:System.Delegate.Remove(System.Delegate,System.Delegate)" />
        <altmember cref="M:System.Delegate.Equals(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Target">
      <MemberSignature Language="C#" Value="public object Target { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object Target" />
      <MemberSignature Language="DocId" Value="P:System.Delegate.Target" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Target As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ Target { System::Object ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="28044-914">Obtiene la instancia de clase donde el delegado actual invoca al método de instancia.</span>
          <span class="sxs-lookup">
            <span data-stu-id="28044-914">Gets the class instance on which the current delegate invokes the instance method.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="28044-915">Objeto en el que el delegado actual invoca al método de instancia, en el caso de que el delegado represente un método de instancia; <see langword="null" /> si el delegado representa un método estático.</span>
          <span class="sxs-lookup">
            <span data-stu-id="28044-915">The object on which the current delegate invokes the instance method, if the delegate represents an instance method; <see langword="null" /> if the delegate represents a static method.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="28044-916">Un método de instancia es un método que está asociado a una instancia de una clase; un método estático es un método que está asociado a la propia clase.</span><span class="sxs-lookup"><span data-stu-id="28044-916">An instance method is a method that is associated with an instance of a class; a static method is a method that is associated with the class itself.</span></span>  
  
 <span data-ttu-id="28044-917">Si el delegado invoca uno o varios métodos de instancia, esta propiedad devuelve el destino de este último método de instancia en la lista de invocación.</span><span class="sxs-lookup"><span data-stu-id="28044-917">If the delegate invokes one or more instance methods, this property returns the target of the last instance method in the invocation list.</span></span>  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">
          <span data-ttu-id="28044-918">Cuando se invoca en tiempo de ejecución a través de mecanismos como <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="28044-918">when invoked late-bound through mechanisms such as <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span>
          </span>
          <span data-ttu-id="28044-919">Enumeración asociada: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span>
          <span class="sxs-lookup">
            <span data-stu-id="28044-919">Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span>
          </span>
        </permission>
      </Docs>
    </Member>
  </Members>
</Type>