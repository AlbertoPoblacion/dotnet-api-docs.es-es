<Type Name="Delegate" FullName="System.Delegate">
  <Metadata><Meta Name="ms.openlocfilehash" Value="1b76c85e1e9a70132f964767500d5f63f74d6880" /><Meta Name="ms.sourcegitcommit" Value="bac13a81377b1c4ebf3990e3287a6f1700f73751" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="es-ES" /><Meta Name="ms.lasthandoff" Value="03/19/2019" /><Meta Name="ms.locfileid" Value="57951791" /></Metadata><TypeSignature Language="C#" Value="public abstract class Delegate : ICloneable, System.Runtime.Serialization.ISerializable" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi abstract serializable beforefieldinit Delegate extends System.Object implements class System.ICloneable, class System.Runtime.Serialization.ISerializable" />
  <TypeSignature Language="DocId" Value="T:System.Delegate" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class Delegate&#xA;Implements ICloneable, ISerializable" />
  <TypeSignature Language="C++ CLI" Value="public ref class Delegate abstract : ICloneable, System::Runtime::Serialization::ISerializable" />
  <TypeSignature Language="F#" Value="type Delegate = class&#xA;    interface ICloneable&#xA;    interface ISerializable" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.ICloneable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Runtime.Serialization.ISerializable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ClassInterface(System.Runtime.InteropServices.ClassInterfaceType.AutoDual)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Representa un delegado, que es una estructura de datos que hace referencia a un método estático o a una instancia de clase y a un método de instancia de dicha clase.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La <xref:System.Delegate> clase es la clase base para tipos de delegado. Sin embargo, el sistema y los compiladores pueden derivar explícitamente de la <xref:System.Delegate> clase o desde el <xref:System.MulticastDelegate> clase. También no está permitida para derivar un nuevo tipo de un tipo de delegado. La <xref:System.Delegate> clase no se considera un tipo de delegado; es una clase que se utiliza para derivar tipos de delegado.  
  
 Implementa la mayoría de los lenguajes un `delegate` palabra clave como los compiladores para esos lenguajes son puede derivar de la <xref:System.MulticastDelegate> clase; por lo tanto, los usuarios deben utilizar el `delegate` palabra clave proporcionado por el lenguaje.  
  
> [!NOTE]
>  Common language runtime proporciona un `Invoke` método para cada tipo de delegado, con la misma firma que el delegado. No es necesario llamar explícitamente a este método desde C#, Visual Basic o Visual C++, porque los compiladores llaman automáticamente. El `Invoke` método es útil en [reflexión](~/docs/framework/reflection-and-codedom/reflection.md) cuando desee buscar la firma del tipo de delegado.  
  
 Common language runtime proporciona cada tipo de delegado con `BeginInvoke` y `EndInvoke` métodos para habilitar la invocación asincrónica del delegado. Para obtener más información acerca de estos métodos, consulte [Calling Synchronous Methods Asynchronously](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md).  
  
 La declaración de un tipo de delegado establece un contrato que especifica la firma de uno o varios métodos. Un delegado es una instancia de un tipo de delegado que tiene referencias para:  
  
-   Un método de instancia de un tipo y un objeto de destino que se puede asignar a ese tipo.  
  
-   Un método de instancia de un tipo, con el texto oculto `this` parámetro expuesto en la lista de parámetros formales. El delegado se dice que un delegado de la instancia abierta.  
  
-   Un método estático.  
  
-   Un método estático y un objeto de destino que se puede asignar al primer parámetro del método. Se dice que el delegado se cerrados a lo largo de su primer argumento.  
  
 Para obtener más información sobre el enlace a delegados, vea el <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Object%2CSystem.Reflection.MethodInfo%2CSystem.Boolean%29> sobrecarga del método.  
  
> [!NOTE]
>  En las versiones 1.0 y 1.1 de .NET Framework, un delegado puede representar un método solo si la firma del método coincide exactamente con la firma especificada por el tipo de delegado. Por lo tanto, se admiten solo la primeros y terceros viñetas en la lista anterior, y la primera viñeta requiere a una coincidencia exacta de tipos.  
  
 Cuando un delegado representa un método de instancia cerrado a lo largo de su primer argumento (el caso más común), el delegado almacena una referencia al punto de entrada del método y una referencia a un objeto, denominado el destino, que es de un tipo asignable al tipo que define el método. Cuando un delegado representa un método de instancia abierto, almacena una referencia al punto de entrada del método. La firma del delegado debe incluir el texto oculto `this` parámetro en su lista de parámetros formales; en este caso, el delegado no tiene una referencia a un objeto de destino y un objeto de destino debe especificarse cuando se invoca el delegado.  
  
 Cuando un delegado representa un método estático, el delegado almacena una referencia al punto de entrada del método. Cuando un delegado representa un método estático cerrado a lo largo de su primer argumento, el delegado almacena una referencia al punto de entrada del método y una referencia a un objeto de destino que se puede asignar al tipo del primer argumento del método. Cuando se invoca el delegado, el primer argumento del método estático recibe el objeto de destino.  
  
 La lista de invocaciones de un delegado es un conjunto ordenado de delegados en el que cada elemento de la lista invoca exactamente uno de los métodos representados por el delegado. Una lista de invocaciones puede contener métodos duplicados. Durante una invocación, los métodos se invocan en el orden en que aparecen en la lista de invocación. Un delegado intenta invocar todos los métodos de su lista de invocación; una vez por cada vez que aparecen en la lista de invocación, se invocan los duplicados. Los delegados son inmutables; una vez creado, no cambia la lista de invocaciones de un delegado.  
  
 Los delegados se conocen como multidifusión o combinables, porque un delegado puede invocar uno o varios métodos y puede utilizarse en operaciones de combinación.  
  
 Combinar las operaciones, tales como <xref:System.Delegate.Combine%2A> y <xref:System.Delegate.Remove%2A>, no se modifican los delegados existentes. En su lugar, esta operación devuelve un nuevo delegado que contiene los resultados de la operación, un delegado sin cambios, o `null`. Una operación de combinación devuelve `null` cuando el resultado de la operación es un delegado que no hace referencia al menos un método. Una operación de combinación devuelve a un delegado sin modificar cuando la operación solicitada no tiene ningún efecto.  
  
> [!NOTE]
>  Administrado lenguajes utilizan el <xref:System.Delegate.Combine%2A> y <xref:System.Delegate.Remove%2A> métodos para implementar operaciones de delegado. Algunos ejemplos son el `AddHandler` y `RemoveHandler` instrucciones en Visual Basic y los operadores += y -= en tipos de delegados en C#.  
  
 A partir de la [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], tipos de delegado genérico pueden tener parámetros de tipo variante. Parámetros de tipo contravariante pueden usarse como tipos de parámetro del delegado y un parámetro de tipo covariante puede usarse como el tipo de valor devuelto. Esta característica permite que los tipos que se construyen a partir de la misma definición de tipo genérico para ser compatible con la asignación si sus argumentos de tipo son tipos de referencia con una relación de herencia, como se explica en delegado genérico [covarianza y Contravarianza](~/docs/standard/generics/covariance-and-contravariance.md).  
  
> [!NOTE]
>  Los delegados genéricos que son compatibles con la asignación debido a la variación no son necesariamente combinables. Para ser combinables, los tipos deben coincidir exactamente. Por ejemplo, suponga que una clase denominada `Derived` se deriva una clase denominada `Base`. Un delegado del tipo `Action<Base>` (`Action(Of Base)` en Visual Basic) pueden asignarse a una variable de tipo `Action<Derived>`, pero no se pueden combinar dos delegados porque los tipos no coinciden exactamente.  
  
 Si un método invocado produce una excepción, el método deja de ejecutarse, la excepción se pasa al llamador del delegado y no se invocan los métodos restantes en la lista de invocación. Detectar la excepción en el llamador no modifica este comportamiento.  
  
 Cuando la firma de los métodos invocados por un delegado incluye un valor devuelto, el delegado devuelve el valor devuelto del último elemento en la lista de invocación. Cuando la firma incluye un parámetro que se pasa por referencia, el valor final del parámetro es el resultado de cada método en la lista de invocaciones ejecute secuencialmente y actualice el valor del parámetro.  
  
 El equivalente más cercano de un delegado en C es un puntero de función. Un delegado puede representar un método estático o un método de instancia. Cuando el delegado representa un método de instancia, el delegado almacena una referencia al punto de entrada del método pero una referencia a la instancia de clase. A diferencia de los punteros de función, los delegados están orientados a objetos y de tipos.  
  
   
  
## Examples  
 El ejemplo siguiente muestra cómo definir un delegado denominado `myMethodDelegate`. Se crean instancias de este delegado para un método de instancia y un método estático de anidado `mySampleClass` clase. El delegado para el método de instancia requiere una instancia de `mySampleClass`. El `mySampleClass` instancia se guarda en una variable denominada `mySC`.  
  
 [!code-cpp[Classic Delegate Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Delegate Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Delegate Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Delegate Example/CS/source.cs#1)]
 [!code-vb[Classic Delegate Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Delegate Example/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.MulticastDelegate" />
    <related type="Article" href="https://msdn.microsoft.com/library/41972034-92ed-450a-9664-ab93fcc6f1fb">Llamar a métodos sincrónicos de forma asincrónica</related>
    <related type="Article" href="~/docs/csharp/programming-guide/delegates/index.md">Delegados (Guía de programación de C#)</related>
    <related type="Article" href="~/docs/visual-basic/programming-guide/language-features/delegates/index.md">Delegados (Visual Basic)</related>
    <related type="Article" href="https://msdn.microsoft.com/library/1cdf3420-89c1-47c0-b796-aa984020e0f8">Cómo: Definir y utilizar delegados (C++/CLI)</related>
    <related type="Article" href="https://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f">Controlar y provocar eventos</related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inicializa un nuevo delegado.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Delegate (object target, string method);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(object target, string method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.#ctor(System.Object,System.String)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New (target As Object, method As String)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; Delegate(System::Object ^ target, System::String ^ method);" />
      <MemberSignature Language="F#" Value="new Delegate : obj * string -&gt; Delegate" Usage="new System.Delegate (target, method)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="target" Type="System.Object" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="method" Type="System.String" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="target">Instancia de clase donde el delegado invoca a <paramref name="method" />.</param>
        <param name="method">Nombre del método de instancia que representa el delegado.</param>
        <summary>Inicializa un delegado que invoca al método de instancia especificado en la instancia de clase especificada.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este constructor no se puede usar en código de aplicación. Para crear un delegado especificando el nombre de un método de instancia, use una sobrecarga de la <xref:System.Delegate.CreateDelegate%2A> método que especifica un nombre de método y un objeto de destino. Por ejemplo, el <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Object%2CSystem.String%29> sobrecarga del método crea un delegado para un método de instancia con un nombre especificado.  
  
 Este constructor crea a delegados por métodos de instancia solo. Un método de instancia es un método que está asociado a una instancia de una clase. un método estático es un método que está asociado a la propia clase.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="target" /> es <see langword="null" />.  
  
O bien 
 <paramref name="method" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Se produjo un error al enlazar al método de destino.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Cuando se invoca en tiempo de ejecución a través de mecanismos como <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Enumeración asociada: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="T:System.Object" />
        <altmember cref="T:System.String" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Delegate (Type target, string method);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(class System.Type target, string method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.#ctor(System.Type,System.String)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New (target As Type, method As String)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; Delegate(Type ^ target, System::String ^ method);" />
      <MemberSignature Language="F#" Value="new Delegate : Type * string -&gt; Delegate" Usage="new System.Delegate (target, method)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="target" Type="System.Type" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="method" Type="System.String" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="target"><see cref="T:System.Type" /> que representa la clase que define <paramref name="method" />.</param>
        <param name="method">Nombre del método estático que representa el delegado.</param>
        <summary>Inicializa un delegado que invoca al método estático especificado a partir de la clase especificada.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este constructor no se puede usar en código de aplicación. Para crear un delegado especificando el nombre de un método estático, use una sobrecarga de la <xref:System.Delegate.CreateDelegate%2A> método que especifica un nombre de método pero no especifica un objeto de destino. Por ejemplo, el <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Type%2CSystem.String%29> sobrecarga del método crea un delegado para un método estático con un nombre especificado.  
  
 Este constructor crea a delegados para los métodos estáticos solo. Un método de instancia es un método que está asociado a una instancia de una clase. un método estático es un método que está asociado a la propia clase.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="target" /> es <see langword="null" />.  
  
O bien 
 <paramref name="method" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="target" /> no es un <see langword="RuntimeType" />. Vea [Tipos de reflexión en tiempo de ejecución](https://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858).  
  
O bien 
 <paramref name="target" /> representa un tipo genérico abierto.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Cuando se invoca en tiempo de ejecución a través de mecanismos como <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Enumeración asociada: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="T:System.Type" />
        <altmember cref="T:System.String" />
      </Docs>
    </Member>
    <Member MemberName="Clone">
      <MemberSignature Language="C#" Value="public virtual object Clone ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object Clone() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.Clone" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Clone () As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ Clone();" />
      <MemberSignature Language="F#" Value="abstract member Clone : unit -&gt; obj&#xA;override this.Clone : unit -&gt; obj" Usage="delegate.Clone " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ICloneable.Clone</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Crea una copia superficial del delegado.</summary>
        <returns>Copia superficial del delegado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El clon tiene el mismo <xref:System.Type>, destino, método y lista de invocaciones que el delegado original.  
  
 Una copia superficial crea una nueva instancia del mismo tipo que el objeto original y, a continuación, copia los campos no estáticos del objeto original. Si el campo es un tipo de valor, se realiza una copia bit a bit del campo. Si el campo es un tipo de referencia, se copia la referencia, pero el objeto que se hace referencia no; es por lo tanto, la referencia en el objeto original y la referencia en el clon punto al mismo objeto. En cambio, una copia en profundidad de un objeto duplica todo lo que hace referencia directa o indirectamente por los campos del objeto.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Cuando se invoca en tiempo de ejecución a través de mecanismos como <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Enumeración asociada: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="Combine">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Concatena las listas de invocaciones de los delegados de multidifusión (combinables) especificados.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Combine">
      <MemberSignature Language="C#" Value="public static Delegate Combine (params Delegate[] delegates);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Delegate Combine(class System.Delegate[] delegates) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.Combine(System.Delegate[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Combine (ParamArray delegates As Delegate()) As Delegate" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Delegate ^ Combine(... cli::array &lt;Delegate ^&gt; ^ delegates);" />
      <MemberSignature Language="F#" Value="static member Combine : Delegate[] -&gt; Delegate" Usage="System.Delegate.Combine delegates" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="delegates" Type="System.Delegate[]">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-uwp-10.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="delegates">Matriz de delegados que se combinará.</param>
        <summary>Concatena las listas de invocaciones de una matriz de delegados.</summary>
        <returns>Nuevo delegado con una lista de invocación que concatena las listas de invocación de los delegados de la matriz <paramref name="delegates" />. Devuelve <see langword="null" /> si <paramref name="delegates" /> es <see langword="null" />, si <paramref name="delegates" /> no contiene ningún elemento o si todas las entradas de <paramref name="delegates" /> son <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si el `delegates` matriz contiene entradas que son `null`, estas entradas se omiten.  
  
 La lista de invocación puede contener entradas duplicadas; es decir, las entradas que hacen referencia al mismo método en el mismo objeto.  
  
> [!NOTE]
>  Los delegados genéricos que son compatibles con la asignación debido a la variación no son necesariamente combinables. Para ser combinables, los tipos deben coincidir exactamente. Por ejemplo, suponga que una clase denominada `Derived` se deriva una clase denominada `Base`. Un delegado del tipo `Action<Base>` (`Action(Of Base)` en Visual Basic) pueden asignarse a una variable de tipo `Action<Derived>`, tal y como se explica en [covarianza y contravarianza](~/docs/standard/generics/covariance-and-contravariance.md), pero no se pueden combinar dos delegados dado que los tipos no coinciden exactamente.  
  
 <xref:System.Delegate.Combine%2A> es útil para crear controladores de eventos que se produce un evento de tiempo de varios métodos de llamada.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">No todas las entradas que no son null de <paramref name="delegates" /> son instancias del mismo tipo de delegado.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Cuando se invoca en tiempo de ejecución a través de mecanismos como <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Enumeración asociada: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="T:System.MulticastDelegate" />
        <altmember cref="M:System.Delegate.CombineImpl(System.Delegate)" />
      </Docs>
    </Member>
    <Member MemberName="Combine">
      <MemberSignature Language="C#" Value="public static Delegate Combine (Delegate a, Delegate b);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Delegate Combine(class System.Delegate a, class System.Delegate b) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.Combine(System.Delegate,System.Delegate)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Combine (a As Delegate, b As Delegate) As Delegate" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Delegate ^ Combine(Delegate ^ a, Delegate ^ b);" />
      <MemberSignature Language="F#" Value="static member Combine : Delegate * Delegate -&gt; Delegate" Usage="System.Delegate.Combine (a, b)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="a" Type="System.Delegate" />
        <Parameter Name="b" Type="System.Delegate" />
      </Parameters>
      <Docs>
        <param name="a">Delegado cuya lista de invocaciones está en primer lugar.</param>
        <param name="b">Delegado cuya lista de invocaciones está en último lugar.</param>
        <summary>Concatena las listas de invocaciones de dos delegados.</summary>
        <returns>Nuevo delegado con una lista de invocaciones que concatena las listas de invocaciones de <paramref name="a" /> y <paramref name="b" /> en ese orden. Devuelve <paramref name="a" /> si <paramref name="b" /> es <see langword="null" />, devuelve <paramref name="b" /> si <paramref name="a" /> es una referencia nula y devuelve una referencia nula cuando tanto <paramref name="a" /> como <paramref name="b" /> son referencias nulas.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La lista de invocación puede contener entradas duplicadas; es decir, las entradas que hacen referencia al mismo método en el mismo objeto.  
  
> [!NOTE]
>  Los delegados genéricos que son compatibles con la asignación debido a la variación no son necesariamente combinables. Para ser combinables, los tipos deben coincidir exactamente. Por ejemplo, suponga que una clase denominada `Derived` se deriva una clase denominada `Base`. Un delegado del tipo `Action<Base>` (`Action(Of Base)` en Visual Basic) pueden asignarse a una variable de tipo `Action<Derived>`, tal y como se explica en [covarianza y contravarianza](~/docs/standard/generics/covariance-and-contravariance.md), pero no se pueden combinar dos delegados dado que los tipos no coinciden exactamente.  
  
 <xref:System.Delegate.Combine%2A> es útil para crear controladores de eventos que se produce un evento de tiempo de varios métodos de llamada.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="a" /> y <paramref name="b" /> no son <see langword="null" />, y <paramref name="a" /> y <paramref name="b" /> no son instancias del mismo tipo de delegado.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Cuando se invoca en tiempo de ejecución a través de mecanismos como <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Enumeración asociada: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="T:System.MulticastDelegate" />
        <altmember cref="M:System.Delegate.CombineImpl(System.Delegate)" />
      </Docs>
    </Member>
    <Member MemberName="CombineImpl">
      <MemberSignature Language="C#" Value="protected virtual Delegate CombineImpl (Delegate d);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Delegate CombineImpl(class System.Delegate d) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.CombineImpl(System.Delegate)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function CombineImpl (d As Delegate) As Delegate" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual Delegate ^ CombineImpl(Delegate ^ d);" />
      <MemberSignature Language="F#" Value="abstract member CombineImpl : Delegate -&gt; Delegate&#xA;override this.CombineImpl : Delegate -&gt; Delegate" Usage="delegate.CombineImpl d" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d" Type="System.Delegate" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="d">Delegado de multidifusión (combinable) cuya lista de invocaciones se agrega al final de la lista de invocaciones del delegado de multidifusión (combinable) actual.</param>
        <summary>Concatena las listas de invocaciones del delegado de multidifusión (combinable) especificado y del delegado de multidifusión (combinable) actual.</summary>
        <returns>Nuevo delegado de multidifusión (combinable) con una lista de invocaciones que concatena la lista de invocaciones del delegado de multidifusión (combinable) actual y la lista de invocaciones de <paramref name="d" />; o delegado de multidifusión (combinable) actual si <paramref name="d" /> es <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método solo se aplica si el delegado actual es de multidifusión (combinable).  
  
 La implementación actual simplemente inicia un <xref:System.MulticastNotSupportedException>.  
  
 La lista de invocación puede contener entradas duplicadas; es decir, las entradas que hacen referencia al mismo método en el mismo objeto.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.MulticastNotSupportedException">Siempre se produce.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Cuando se invoca en tiempo de ejecución a través de mecanismos como <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Enumeración asociada: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="M:System.Delegate.Combine(System.Delegate,System.Delegate)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateDelegate">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Crea un delegado del tipo especificado.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateDelegate">
      <MemberSignature Language="C#" Value="public static Delegate CreateDelegate (Type type, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Delegate CreateDelegate(class System.Type type, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Delegate ^ CreateDelegate(Type ^ type, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member CreateDelegate : Type * System.Reflection.MethodInfo -&gt; Delegate" Usage="System.Delegate.CreateDelegate (type, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="type"><see cref="T:System.Type" /> de delegado que se va a crear.</param>
        <param name="method"><see cref="T:System.Reflection.MethodInfo" /> que describe el método estático o de instancia que va a representar el delegado. Sólo se admiten métodos estáticos en las versiones 1.0 y 1.1 de .NET Framework.</param>
        <summary>Crea un delegado del tipo especificado para representar el método estático especificado.</summary>
        <returns>Delegado del tipo especificado para representar el método estático especificado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 En la versión 1.0 y 1.1 de .NET Framework, esta sobrecarga del método crea a los delegados para los métodos estáticos solo. En la versión 2.0 de .NET Framework, esta sobrecarga del método también puede crear instancia abierta delegados de método; es decir, los delegados que proporcionar explícitamente el primer argumento oculto de métodos de instancia. Para obtener una explicación detallada, vea más general <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Object%2CSystem.Reflection.MethodInfo%29> sobrecarga del método, que permite crear todas las combinaciones de delegados abiertos o cerrados para la instancia o métodos estáticos y, opcionalmente, para especificar un primer argumento.  
  
> [!NOTE]
>  Esta sobrecarga del método debe usarse cuando no se cierra el delegado en su primer argumento, porque en ese caso es un poco más rápido.  
  
 Esta sobrecarga del método es equivalente a llamar a la <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Reflection.MethodInfo%2CSystem.Boolean%29> sobrecarga del método y especificando `true` para `throwOnBindFailure`.  
  
> [!NOTE]
>  A partir de la [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], este método puede utilizarse para tener acceso a los métodos no públicos si el llamador tiene concedidos <xref:System.Security.Permissions.ReflectionPermission> con el <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> marca y si el conjunto de permisos de los métodos no públicos se restringe al llamador conceder el conjunto o un subconjunto en ella. (Consulte [consideraciones de seguridad para la reflexión](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)  
>   
>  Para utilizar esta funcionalidad, la aplicación debe utilizar [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] o posterior como destino.  
  
## <a name="compatible-parameter-types-and-return-type"></a>Tipos de parámetros compatibles y el tipo de valor devuelto  
 En la versión 2.0 de .NET Framework, los tipos de parámetro y el tipo de valor devuelto de un delegado que se crea mediante esta sobrecarga del método deben ser compatibles con los tipos de parámetro y el tipo de valor devuelto del método que representa el delegado; los tipos no tienen que coincidir exactamente. Representa una relajación del comportamiento de enlace en .NET Framework versiones 1.0 y 1.1, donde los tipos deben coincidir exactamente.  
  
 Un parámetro de un delegado es compatible con el parámetro correspondiente de un método si el tipo del parámetro del delegado es más restrictivo que el del método, porque así se garantiza que el argumento que se pase al delegado también se podrá pasar de forma segura al método.  
  
 De forma similar, el tipo de valor devuelto de un delegado es compatible con el tipo de valor devuelto de un método si el del método es más restrictivo que el del delegado, porque así se garantiza que el tipo de valor devuelto por el método se puede convertir con seguridad al tipo de valor devuelto del delegado.  
  
 Por ejemplo, un delegado con un parámetro de tipo <xref:System.Collections.Hashtable> y un tipo de valor devuelto de <xref:System.Object> puede representar un método con un parámetro de tipo <xref:System.Object> y un valor devuelto de tipo <xref:System.Collections.Hashtable>.  
  
   
  
## Examples  
 Esta sección contiene dos ejemplos de código. El primer ejemplo muestra los dos tipos de delegados que se pueden crear con esta sobrecarga del método: abra a través de un método de instancia y a través de un método estático.  
  
 El segundo ejemplo de código muestra los tipos de parámetros compatibles y los tipos de valor devuelto.  
  
 **Ejemplo 1**  
  
 El ejemplo de código siguiente muestra las dos maneras en que se puede crear un delegado mediante esta sobrecarga de la <xref:System.Delegate.CreateDelegate%2A> método.  
  
> [!NOTE]
>  Hay dos sobrecargas de los <xref:System.Delegate.CreateDelegate%2A> método que especifican un <xref:System.Reflection.MethodInfo> pero no un primer argumento; su funcionalidad es el mismo, salvo que uno le permite especificar si se debe producir el error al enlazar y el otro siempre produce una excepción. Este ejemplo de código usa las dos sobrecargas.  
  
 En el ejemplo se declara una clase `C` con un método estático `M2` y un método de instancia `M1`, y dos tipos de delegado: `D1` toma una instancia de `C` y una cadena, y `D2` toma una cadena.  
  
 Una segunda clase denominada `Example` contiene el código que crea los delegados.  
  
-   Un delegado del tipo `D1`, que representa un método de instancia abierta, se crea para el método de instancia `M1`. Cuando se invoca el delegado, se debe pasar una instancia.  
  
-   Un delegado del tipo `D2`, que representa un método estático abierto, se crea para el método estático `M2`.  
  
 [!code-csharp[Delegate.CreateDelegateTOM#1](~/samples/snippets/csharp/VS_Snippets_CLR/Delegate.CreateDelegateTOM/cs/openClosedOver.cs#1)]
 [!code-vb[Delegate.CreateDelegateTOM#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Delegate.CreateDelegateTOM/VB/openClosedOver.vb#1)]  
  
 **Ejemplo 2**  
  
 En el ejemplo de código siguiente se muestra la compatibilidad de tipos de parámetro y tipos de valor devuelto.  
  
 El ejemplo de código define una clase base denominada `Base` y una clase denominada `Derived` que se deriva de `Base`. La clase derivada tiene una `static` (`Shared` en Visual Basic) método denominado `MyMethod` con un parámetro de tipo `Base` y un tipo de valor devuelto de `Derived`. El ejemplo de código también define un delegado denominado `Example` que tiene un parámetro de tipo `Derived` y un tipo de valor devuelto de `Base`.  
  
 El ejemplo de código se muestra que el delegado denominado `Example` puede usarse para representar el método `MyMethod`. El método se puede enlazar al delegado porque:  
  
-   El tipo de parámetro del delegado (`Derived`) es más restrictivo que el tipo de parámetro `MyMethod` (`Base`), de modo que siempre es seguro pasar el argumento del delegado para `MyMethod`.  
  
-   El tipo de valor devuelto de `MyMethod` (`Derived`) es más restrictivo que el tipo de parámetro del delegado (`Base`), de modo que siempre es seguro convertir el tipo de valor devuelto del método para el tipo de valor devuelto del delegado.  
  
 El ejemplo de código no genera ninguna salida.  
  
 [!code-cpp[Delegate.CreateDelegate_RelaxedFit#1](~/samples/snippets/cpp/VS_Snippets_CLR/Delegate.CreateDelegate_RelaxedFit/cpp/source.cpp#1)]
 [!code-csharp[Delegate.CreateDelegate_RelaxedFit#1](~/samples/snippets/csharp/VS_Snippets_CLR/Delegate.CreateDelegate_RelaxedFit/cs/source.cs#1)]
 [!code-vb[Delegate.CreateDelegate_RelaxedFit#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Delegate.CreateDelegate_RelaxedFit/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="type" /> es <see langword="null" />.  
  
O bien 
 <paramref name="method" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="type" /> no hereda <see cref="T:System.MulticastDelegate" />.  
  
O bien 
 <paramref name="type" /> no es un <see langword="RuntimeType" />. Vea [Tipos de reflexión en tiempo de ejecución](https://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858).  
  
O bien 
 <paramref name="method" /> no es un método estático y la versión de .NET Framework es 1.0 o 1.1.  
  
O bien 
 No se puede enlazar <paramref name="method" />.  
  
O bien 
 <paramref name="method" /> no es un <see langword="RuntimeMethodInfo" />. Vea [Tipos de reflexión en tiempo de ejecución](https://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858).</exception>
        <exception cref="T:System.MissingMethodException">No se encuentra el método <see langword="Invoke" /> de <paramref name="type" />.</exception>
        <exception cref="T:System.MethodAccessException">El autor de la llamada no tiene los permisos necesarios para acceder a <paramref name="method" />.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Cuando se invoca en tiempo de ejecución a través de mecanismos como <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Enumeración asociada: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</permission>
        <altmember cref="T:System.Type" />
        <altmember cref="T:System.MulticastDelegate" />
        <altmember cref="T:System.Security.Permissions.ReflectionPermission" />
        <altmember cref="T:System.Reflection.MethodInfo" />
      </Docs>
    </Member>
    <Member MemberName="CreateDelegate">
      <MemberSignature Language="C#" Value="public static Delegate CreateDelegate (Type type, object firstArgument, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Delegate CreateDelegate(class System.Type type, object firstArgument, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Delegate ^ CreateDelegate(Type ^ type, System::Object ^ firstArgument, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member CreateDelegate : Type * obj * System.Reflection.MethodInfo -&gt; Delegate" Usage="System.Delegate.CreateDelegate (type, firstArgument, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="firstArgument" Type="System.Object" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="type"><see cref="T:System.Type" /> de delegado que se va a crear.</param>
        <param name="firstArgument">Objeto al que se enlaza el delegado o <see langword="null" /> para tratar <paramref name="method" /> como <see langword="static" /> (<see langword="Shared" /> en Visual Basic).</param>
        <param name="method"><see cref="T:System.Reflection.MethodInfo" /> que describe el método estático o de instancia que va a representar el delegado.</param>
        <summary>Crea un delegado del tipo especificado que representa el método estático o de instancia especificado, con el primer argumento definido.</summary>
        <returns>Delegado del tipo especificado para representar el método estático o de instancia definido.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Llamar a esta sobrecarga del método es equivalente a llamar a la <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Object%2CSystem.Reflection.MethodInfo%2CSystem.Boolean%29> sobrecarga del método y especificando `true` para `throwOnBindFailure`. Estas dos sobrecargas proporcionan la manera más flexible para crear a delegados. Puede usarlos para crear delegados para estáticas o métodos de instancia y, opcionalmente, para especificar el primer argumento.  
  
> [!NOTE]
>  Si no proporciona un primer argumento, utilice el <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Reflection.MethodInfo%29> sobrecarga del método para mejorar el rendimiento.  
  
 El tipo de delegado y el método deben tener tipos de valor devuelto compatibles. Es decir, el tipo de valor devuelto de `method` debe ser asignable al tipo de valor devuelto de `type`.  
  
 Si `firstArgument` es proporciona, se pasa a `method` cada vez que se invoca al delegado; `firstArgument` se dice que está enlazado al delegado, y se dice que el delegado se cerrados a lo largo de su primer argumento. Si `method` es `static` (`Shared` en Visual Basic), la lista de argumentos proporcionado al invocar al delegado incluye todos los parámetros excepto el primero; si `method` es un método de instancia, a continuación, `firstArgument` se pasa a la instancia oculta parámetro (representado por `this` en C# o por `Me` en Visual Basic).  
  
 Si `firstArgument` se proporciona, el primer parámetro de `method` debe ser un tipo de referencia y `firstArgument` debe ser compatible con ese tipo.  
  
> [!IMPORTANT]
>  Si `method` es `static` (`Shared` en Visual Basic) y su primer parámetro es de tipo <xref:System.Object> o <xref:System.ValueType>, a continuación, `firstArgument` puede ser un tipo de valor. En este caso `firstArgument` se aplica automáticamente. La conversión boxing automática no se produce para los demás argumentos, como en C# o Visual Basic función llamaría.  
  
 Si `firstArgument` es una referencia nula y `method` es un método de instancia, el resultado depende de las firmas del tipo de delegado `type` y de `method`:  
  
-   Si la firma de `type` incluya explícitamente el primer parámetro oculto de `method`, se dice que el delegado representa un método de instancia abierta. Cuando se invoca el delegado, el primer argumento de la lista de argumentos se pasa al parámetro de instancia oculta `method`.  
  
-   Si las firmas de `method` y `type` coinciden (es decir, todos los tipos de parámetro son compatibles), a continuación, se dice que el delegado se cerrados a lo largo de una referencia nula. Invocación del delegado es como una llamada a un método de instancia en una instancia null, que no es algo especialmente útil.  
  
 Si `firstArgument` es una referencia nula y `method` es estático, el resultado depende de las firmas del tipo de delegado `type` y de `method`:  
  
-   Si la firma de `method` y `type` coinciden (es decir, todos los tipos de parámetro son compatibles), se dice que el delegado para representar un método estático abierto. Este es el caso más común para los métodos estáticos. En este caso, puede obtener un rendimiento ligeramente mejor mediante el <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Reflection.MethodInfo%29> sobrecarga del método.  
  
-   Si la firma de `type` comienza con el segundo parámetro de `method` y el resto de los tipos de parámetros son compatibles y, después, se dice que el delegado se cerrados a lo largo de una referencia nula. Cuando se invoca el delegado, se pasa una referencia nula al primer parámetro de `method`.  
  
> [!NOTE]
>  A partir de la [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], este método puede utilizarse para tener acceso a los métodos no públicos si el llamador tiene concedidos <xref:System.Security.Permissions.ReflectionPermission> con el <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> marca y si el conjunto de permisos de los métodos no públicos se restringe al llamador conceder el conjunto o un subconjunto en ella. (Consulte [consideraciones de seguridad para la reflexión](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)  
>   
>  Para utilizar esta funcionalidad, la aplicación debe utilizar [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] o posterior como destino.  
  
## <a name="compatible-parameter-types-and-return-type"></a>Tipos de parámetros compatibles y el tipo de valor devuelto  
 Los tipos de parámetro y el tipo de valor devuelto de un delegado deben ser compatibles con los tipos de parámetro y el tipo de valor devuelto del método que representa el delegado; los tipos no tienen que coincidir exactamente.  
  
> [!NOTE]
>  En la versión 1.0 y 1.1 de .NET Framework, los tipos deben coincidir exactamente.  
  
 Un parámetro de un delegado es compatible con el parámetro correspondiente de un método si el tipo del parámetro del delegado es más restrictivo que el del método, porque así se garantiza que el argumento que se pase al delegado también se podrá pasar de forma segura al método.  
  
 De forma similar, el tipo de valor devuelto de un delegado es compatible con el tipo de valor devuelto de un método si el del método es más restrictivo que el del delegado, porque así se garantiza que el tipo de valor devuelto por el método se puede convertir con seguridad al tipo de valor devuelto del delegado.  
  
 Por ejemplo, un delegado con un parámetro de tipo <xref:System.Collections.Hashtable> y un tipo de valor devuelto de <xref:System.Object> puede representar un método con un parámetro de tipo <xref:System.Object> y un valor devuelto de tipo <xref:System.Collections.Hashtable>.  
  
## <a name="determining-the-methods-a-delegate-can-represent"></a>Determinación de los métodos que puede representar un delegado  
 Otra manera útil pensar en la flexibilidad proporcionada por esta sobrecarga de <xref:System.Delegate.CreateDelegate%2A> es que cualquier delegado puede representar cuatro combinaciones diferentes de firma de método y el tipo de método (estático frente a la instancia). Considere la posibilidad de un tipo de delegado `D` con un argumento de tipo `C`. Lo siguiente describe los métodos `D` puede representar, omitiendo el tipo de valor devuelto, puesto que debe coincidir en todos los casos:  
  
-   `D` puede representar cualquier método de instancia que tiene exactamente un argumento de tipo `C`, independientemente de qué tipo pertenece el método de instancia. Cuando <xref:System.Delegate.CreateDelegate%2A> se llama, `firstArgument` es una instancia del tipo `method` pertenece, y se dice que el delegado resultante se cerrados a lo largo de esa instancia. (De forma trivial, `D` también se puede cerrar a través de una referencia nula si `firstArgument` es una referencia nula.)  
  
-   `D` puede representar un método de instancia de `C` que no tiene ningún argumento. Cuando <xref:System.Delegate.CreateDelegate%2A> se llama, `firstArgument` es una referencia nula. El delegado resultante representa un método de instancia abierta y una instancia de `C` se debe proporcionar cada vez que se invoca.  
  
-   `D` puede representar un método estático que toma un argumento de tipo `C`, y que el método puede pertenecer a cualquier tipo. Cuando <xref:System.Delegate.CreateDelegate%2A> se llama, `firstArgument` es una referencia nula. El delegado resultante representa un método estático abierto y una instancia de `C` se debe proporcionar cada vez que se invoca.  
  
-   `D` puede representar un método estático que pertenece al tipo `F` y tiene dos argumentos de tipo `F` y tipo `C`. Cuando <xref:System.Delegate.CreateDelegate%2A> se llama, `firstArgument` es una instancia de `F`. El delegado resultante representa un método estático que se cierra en esa instancia de `F`. Tenga en cuenta que en el caso donde `F` y `C` son del mismo tipo, el método estático tiene dos argumentos de ese tipo. (En este caso, `D` se cierra en una referencia nula si `firstArgument` es una referencia nula.)  
  
   
  
## Examples  
 Esta sección contiene tres ejemplos de código. El primer ejemplo muestra los cuatro tipos de delegados que se pueden crear: cerrados a lo largo de un método de instancia, abra a través de un método de instancia, abra a través de un método estático y cerrados a lo largo de un método estático.  
  
 El segundo ejemplo de código muestra los tipos de parámetros compatibles y los tipos de valor devuelto.  
  
 El tercer ejemplo de código define un tipo de delegado único y muestra todos los métodos de ese tipo de delegado pueden representar.  
  
 **Ejemplo 1**  
  
 En el ejemplo de código siguiente se muestra las cuatro maneras se puede crear un delegado mediante esta sobrecarga de la <xref:System.Delegate.CreateDelegate%2A> método.  
  
> [!NOTE]
>  Hay dos sobrecargas de los <xref:System.Delegate.CreateDelegate%2A> método que especifique `firstArgument` y un <xref:System.Reflection.MethodInfo>; su funcionalidad es el mismo, salvo que uno le permite especificar si se debe producir el error al enlazar y el otro siempre produce una excepción. Este ejemplo de código usa las dos sobrecargas.  
  
 En el ejemplo se declara una clase `C` con un método estático `M2` y un método de instancia `M1`, y tres tipos de delegado: `D1` toma una instancia de `C` y una cadena, `D2` toma una cadena y `D3`no tiene ningún argumento.  
  
 Una segunda clase denominada `Example` contiene el código que crea los delegados.  
  
-   Un delegado del tipo `D2`, cerrado a través de una instancia de `C`, se crea para el método de instancia `M1`. Se invoca con cadenas diferentes, para mostrar que la instancia enlazada de `C` siempre se utiliza.  
  
-   Un delegado del tipo `D1`, que representa un método de instancia abierta, se crea para el método de instancia `M1`. Cuando se invoca el delegado, se debe pasar una instancia.  
  
-   Un delegado del tipo `D2`, que representa un método estático abierto, se crea para el método estático `M2`.  
  
-   Por último, un delegado del tipo `D3`, cerrados a lo largo de una cadena, se crea para el método estático `M2`. El método se invoca para mostrar que utiliza la cadena enlazada.  
  
 [!code-csharp[Delegate.CreateDelegateTOM#1](~/samples/snippets/csharp/VS_Snippets_CLR/Delegate.CreateDelegateTOM/cs/openClosedOver.cs#1)]
 [!code-vb[Delegate.CreateDelegateTOM#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Delegate.CreateDelegateTOM/VB/openClosedOver.vb#1)]  
  
 **Ejemplo 2**  
  
 En el ejemplo de código siguiente se muestra la compatibilidad de tipos de parámetro y tipos de valor devuelto.  
  
> [!NOTE]
>  Este ejemplo de código utiliza el <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Reflection.MethodInfo%29> sobrecarga del método. El uso de otras sobrecargas que toman <xref:System.Reflection.MethodInfo> es similar.  
  
 El ejemplo de código define una clase base denominada `Base` y una clase denominada `Derived` que se deriva de `Base`. La clase derivada tiene una `static` (`Shared` en Visual Basic) método denominado `MyMethod` con un parámetro de tipo `Base` y un tipo de valor devuelto de `Derived`. El ejemplo de código también define un delegado denominado `Example` que tiene un parámetro de tipo `Derived` y un tipo de valor devuelto de `Base`.  
  
 El ejemplo de código se muestra que el delegado denominado `Example` puede usarse para representar el método `MyMethod`. El método se puede enlazar al delegado porque:  
  
-   El tipo de parámetro del delegado (`Derived`) es más restrictivo que el tipo de parámetro `MyMethod` (`Base`), de modo que siempre es seguro pasar el argumento del delegado para `MyMethod`.  
  
-   El tipo de valor devuelto de `MyMethod` (`Derived`) es más restrictivo que el tipo de parámetro del delegado (`Base`), de modo que siempre es seguro convertir el tipo de valor devuelto del método para el tipo de valor devuelto del delegado.  
  
 El ejemplo de código no genera ninguna salida.  
  
 [!code-cpp[Delegate.CreateDelegate_RelaxedFit#1](~/samples/snippets/cpp/VS_Snippets_CLR/Delegate.CreateDelegate_RelaxedFit/cpp/source.cpp#1)]
 [!code-csharp[Delegate.CreateDelegate_RelaxedFit#1](~/samples/snippets/csharp/VS_Snippets_CLR/Delegate.CreateDelegate_RelaxedFit/cs/source.cs#1)]
 [!code-vb[Delegate.CreateDelegate_RelaxedFit#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Delegate.CreateDelegate_RelaxedFit/vb/source.vb#1)]  
  
 **Ejemplo 3**  
  
 En el ejemplo de código siguiente se muestra todos los métodos puede representar un tipo de delegado único, utilizando el <xref:System.Delegate.CreateDelegate%2A> método para crear los delegados.  
  
> [!NOTE]
>  Hay dos sobrecargas de los <xref:System.Delegate.CreateDelegate%2A> método que especifique `firstArgument` y un <xref:System.Reflection.MethodInfo>; su funcionalidad es el mismo, salvo que uno le permite especificar si se debe producir el error al enlazar y el otro siempre produce una excepción. Este ejemplo de código usa las dos sobrecargas.  
  
 El ejemplo de código define dos clases, `C` y `F`y un tipo de delegado `D` con un argumento de tipo `C`. Las clases tienen coincidentes estáticos y métodos de instancia `M1`, `M3`, y `M4`y la clase `C` también tiene un método de instancia `M2` que no tiene ningún argumento.  
  
 Una tercera clase denominada `Example` contiene el código que crea los delegados.  
  
-   Los delegados se crean, por ejemplo, método `M1` de tipo `C` y tipo `F`; cada uno se cierra sobre una instancia del tipo correspondiente. Método `M1` typu `C` muestra el `ID` las propiedades de la instancia enlazada y del argumento.  
  
-   Se crea un delegado para método `M2` de tipo `C`. Se trata de un delegado de la instancia abierta, en el que el argumento del delegado representa el primer argumento oculto en el método de instancia. El método no tiene ningún otro argumento. Se llama como si fuera un método estático.  
  
-   Se crean delegados para el método estático `M3` de tipo `C` y tipo `F`; estos son delegados estáticos abiertos.  
  
-   Por último, se crean los delegados de método estático `M4` typu `C` y tipo `F`; cada método tiene el tipo declarativo como primer argumento y se proporciona una instancia del tipo, por lo que los delegados se cierran en sus primeros argumentos . Método `M4` typu `C` muestra el `ID` las propiedades de la instancia enlazada y del argumento.  
  
 [!code-csharp[Delegate.CreateDelegateTOM_2#1](~/samples/snippets/csharp/VS_Snippets_CLR/Delegate.CreateDelegateTOM_2/cs/source.cs#1)]
 [!code-vb[Delegate.CreateDelegateTOM_2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Delegate.CreateDelegateTOM_2/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="type" /> es <see langword="null" />.  
  
O bien 
 <paramref name="method" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="type" /> no hereda <see cref="T:System.MulticastDelegate" />.  
  
O bien 
 <paramref name="type" /> no es un <see langword="RuntimeType" />. Vea [Tipos de reflexión en tiempo de ejecución](https://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858).  
  
O bien 
 No se puede enlazar <paramref name="method" />.  
  
O bien 
 <paramref name="method" /> no es un <see langword="RuntimeMethodInfo" />. Vea [Tipos de reflexión en tiempo de ejecución](https://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858).</exception>
        <exception cref="T:System.MissingMethodException">No se encuentra el método <see langword="Invoke" /> de <paramref name="type" />.</exception>
        <exception cref="T:System.MethodAccessException">El autor de la llamada no tiene los permisos necesarios para acceder a <paramref name="method" />.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Cuando se invoca en tiempo de ejecución a través de mecanismos como <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Enumeración asociada: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</permission>
        <altmember cref="T:System.Type" />
        <altmember cref="T:System.MulticastDelegate" />
        <altmember cref="T:System.Security.Permissions.ReflectionPermission" />
        <altmember cref="T:System.Reflection.MethodInfo" />
      </Docs>
    </Member>
    <Member MemberName="CreateDelegate">
      <MemberSignature Language="C#" Value="public static Delegate CreateDelegate (Type type, object target, string method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Delegate CreateDelegate(class System.Type type, object target, string method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Delegate ^ CreateDelegate(Type ^ type, System::Object ^ target, System::String ^ method);" />
      <MemberSignature Language="F#" Value="static member CreateDelegate : Type * obj * string -&gt; Delegate" Usage="System.Delegate.CreateDelegate (type, target, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="target" Type="System.Object" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="method" Type="System.String" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="type"><see cref="T:System.Type" /> de delegado que se va a crear.</param>
        <param name="target">Instancia de clase en la que se invoca a <paramref name="method" />.</param>
        <param name="method">Nombre del método de instancia que el delegado va a representar.</param>
        <summary>Crea un delegado del tipo especificado que representa el método de instancia especificado que se va a invocar en la instancia de clase especificada.</summary>
        <returns>Delegado del tipo especificado que representa el método de instancia especificado que se va a invocar en la instancia de clase especificada.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método crea a los delegados por métodos de instancia solo. Un método de instancia es un método que está asociado a una instancia de una clase. un método estático es un método que está asociado a la propia clase.  
  
 Esta sobrecarga del método es equivalente a llamar a la <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Object%2CSystem.String%2CSystem.Boolean%2CSystem.Boolean%29> sobrecarga del método, especifica `false` para `ignoreCase` y `true` para `throwOnBindFailure`.  
  
> [!NOTE]
>  A partir de la [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], este método puede utilizarse para tener acceso a los métodos no públicos si el llamador tiene concedidos <xref:System.Security.Permissions.ReflectionPermission> con el <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> marca y si el conjunto de permisos de los métodos no públicos se restringe al llamador conceder el conjunto o un subconjunto en ella. (Consulte [consideraciones de seguridad para la reflexión](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)  
>   
>  Para utilizar esta funcionalidad, la aplicación debe utilizar [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] o posterior como destino.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="type" /> es <see langword="null" />.  
  
O bien 
 <paramref name="target" /> es <see langword="null" />.  
  
O bien 
 <paramref name="method" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="type" /> no hereda <see cref="T:System.MulticastDelegate" />.  
  
O bien 
 <paramref name="type" /> no es un <see langword="RuntimeType" />. Vea [Tipos de reflexión en tiempo de ejecución](https://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858).  
  
O bien 
 <paramref name="method" /> no es un método de instancia.  
  
O bien 
 <paramref name="method" /> no se puede enlazar, por ejemplo, porque no se encuentra.</exception>
        <exception cref="T:System.MissingMethodException">No se encuentra el método <see langword="Invoke" /> de <paramref name="type" />.</exception>
        <exception cref="T:System.MethodAccessException">El autor de la llamada no tiene los permisos necesarios para acceder a <paramref name="method" />.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Cuando se invoca en tiempo de ejecución a través de mecanismos como <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Enumeración asociada: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</permission>
        <altmember cref="T:System.Type" />
        <altmember cref="T:System.MulticastDelegate" />
        <altmember cref="T:System.Security.Permissions.ReflectionPermission" />
        <altmember cref="T:System.Object" />
      </Docs>
    </Member>
    <Member MemberName="CreateDelegate">
      <MemberSignature Language="C#" Value="public static Delegate CreateDelegate (Type type, System.Reflection.MethodInfo method, bool throwOnBindFailure);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Delegate CreateDelegate(class System.Type type, class System.Reflection.MethodInfo method, bool throwOnBindFailure) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Delegate ^ CreateDelegate(Type ^ type, System::Reflection::MethodInfo ^ method, bool throwOnBindFailure);" />
      <MemberSignature Language="F#" Value="static member CreateDelegate : Type * System.Reflection.MethodInfo * bool -&gt; Delegate" Usage="System.Delegate.CreateDelegate (type, method, throwOnBindFailure)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="throwOnBindFailure" Type="System.Boolean" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="type"><see cref="T:System.Type" /> de delegado que se va a crear.</param>
        <param name="method"><see cref="T:System.Reflection.MethodInfo" /> que describe el método estático o de instancia que va a representar el delegado.</param>
        <param name="throwOnBindFailure">Es <see langword="true" /> para iniciar una excepción si no se puede enlazar <paramref name="method" />; en caso contrario, es <see langword="false" />.</param>
        <summary>Crea un delegado del tipo especificado para representar el método estático especificado, con el comportamiento establecido para el caso de que se produzca un error al enlazar.</summary>
        <returns>Delegado del tipo especificado para representar el método estático especificado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esta sobrecarga del método puede crear a delegados de método estático abierto y abrir instancia delegados de método: es decir, los delegados que exponen el primer argumento oculto de los métodos de instancia. Para obtener una explicación detallada, vea más general <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Object%2CSystem.Reflection.MethodInfo%2CSystem.Boolean%29> sobrecarga del método, que le permite crear todas las combinaciones de delegados abiertos o cerrados por ejemplo o métodos estáticos.  
  
> [!NOTE]
>  Esta sobrecarga del método debe usarse cuando no se cierra el delegado en su primer argumento, porque en ese caso es un poco más rápido.  
  
> [!NOTE]
>  A partir de la [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], este método puede utilizarse para tener acceso a los métodos no públicos si el llamador tiene concedidos <xref:System.Security.Permissions.ReflectionPermission> con el <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> marca y si el conjunto de permisos de los métodos no públicos se restringe al llamador conceder el conjunto o un subconjunto en ella. (Consulte [consideraciones de seguridad para la reflexión](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)  
>   
>  Para utilizar esta funcionalidad, la aplicación debe utilizar [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] o posterior como destino.  
  
## <a name="compatible-parameter-types-and-return-type"></a>Tipos de parámetros compatibles y el tipo de valor devuelto  
 Los tipos de parámetro y el tipo de valor devuelto de un delegado deben ser compatibles con los tipos de parámetro y el tipo de valor devuelto del método que representa el delegado; los tipos no tienen que coincidir exactamente.  
  
> [!NOTE]
>  En la versión 1.0 y 1.1 de .NET Framework, los tipos deben coincidir exactamente.  
  
 Un parámetro de un delegado es compatible con el parámetro correspondiente de un método si el tipo del parámetro del delegado es más restrictivo que el del método, porque así se garantiza que el argumento que se pase al delegado también se podrá pasar de forma segura al método.  
  
 De forma similar, el tipo de valor devuelto de un delegado es compatible con el tipo de valor devuelto de un método si el del método es más restrictivo que el del delegado, porque así se garantiza que el tipo de valor devuelto por el método se puede convertir con seguridad al tipo de valor devuelto del delegado.  
  
 Por ejemplo, un delegado con un parámetro de tipo <xref:System.Collections.Hashtable> y un tipo de valor devuelto de <xref:System.Object> puede representar un método con un parámetro de tipo <xref:System.Object> y un valor devuelto de tipo <xref:System.Collections.Hashtable>.  
  
   
  
## Examples  
 Esta sección contiene dos ejemplos de código. El primer ejemplo muestra los dos tipos de delegados que se pueden crear con esta sobrecarga del método: abra a través de un método de instancia y a través de un método estático.  
  
 El segundo ejemplo de código muestra los tipos de parámetros compatibles y los tipos de valor devuelto.  
  
 **Ejemplo 1**  
  
 El ejemplo de código siguiente muestra las dos maneras en que se puede crear un delegado mediante esta sobrecarga de la <xref:System.Delegate.CreateDelegate%2A> método.  
  
> [!NOTE]
>  Hay dos sobrecargas de los <xref:System.Delegate.CreateDelegate%2A> método que especifican un <xref:System.Reflection.MethodInfo> pero no un primer argumento; su funcionalidad es el mismo, salvo que uno le permite especificar si se debe producir el error al enlazar y el otro siempre produce una excepción. Este ejemplo de código usa las dos sobrecargas.  
  
 En el ejemplo se declara una clase `C` con un método estático `M2` y un método de instancia `M1`, y dos tipos de delegado: `D1` toma una instancia de `C` y una cadena, y `D2` toma una cadena.  
  
 Una segunda clase denominada `Example` contiene el código que crea los delegados.  
  
-   Un delegado del tipo `D1`, que representa un método de instancia abierta, se crea para el método de instancia `M1`. Cuando se invoca el delegado, se debe pasar una instancia.  
  
-   Un delegado del tipo `D2`, que representa un método estático abierto, se crea para el método estático `M2`.  
  
 [!code-csharp[Delegate.CreateDelegateTOM#1](~/samples/snippets/csharp/VS_Snippets_CLR/Delegate.CreateDelegateTOM/cs/openClosedOver.cs#1)]
 [!code-vb[Delegate.CreateDelegateTOM#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Delegate.CreateDelegateTOM/VB/openClosedOver.vb#1)]  
  
 **Ejemplo 2**  
  
 En el ejemplo de código siguiente se muestra la compatibilidad de tipos de parámetro y tipos de valor devuelto.  
  
> [!NOTE]
>  Este ejemplo de código utiliza el <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Reflection.MethodInfo%29> sobrecarga del método. El uso de otras sobrecargas que toman <xref:System.Reflection.MethodInfo> es similar.  
  
 El ejemplo de código define una clase base denominada `Base` y una clase denominada `Derived` que se deriva de `Base`. La clase derivada tiene una `static` (`Shared` en Visual Basic) método denominado `MyMethod` con un parámetro de tipo `Base` y un tipo de valor devuelto de `Derived`. El ejemplo de código también define un delegado denominado `Example` que tiene un parámetro de tipo `Derived` y un tipo de valor devuelto de `Base`.  
  
 El ejemplo de código se muestra que el delegado denominado `Example` puede usarse para representar el método `MyMethod`. El método se puede enlazar al delegado porque:  
  
-   El tipo de parámetro del delegado (`Derived`) es más restrictivo que el tipo de parámetro `MyMethod` (`Base`), de modo que siempre es seguro pasar el argumento del delegado para `MyMethod`.  
  
-   El tipo de valor devuelto de `MyMethod` (`Derived`) es más restrictivo que el tipo de parámetro del delegado (`Base`), de modo que siempre es seguro convertir el tipo de valor devuelto del método para el tipo de valor devuelto del delegado.  
  
 El ejemplo de código no genera ninguna salida.  
  
 [!code-cpp[Delegate.CreateDelegate_RelaxedFit#1](~/samples/snippets/cpp/VS_Snippets_CLR/Delegate.CreateDelegate_RelaxedFit/cpp/source.cpp#1)]
 [!code-csharp[Delegate.CreateDelegate_RelaxedFit#1](~/samples/snippets/csharp/VS_Snippets_CLR/Delegate.CreateDelegate_RelaxedFit/cs/source.cs#1)]
 [!code-vb[Delegate.CreateDelegate_RelaxedFit#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Delegate.CreateDelegate_RelaxedFit/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="type" /> es <see langword="null" />.  
  
O bien 
 <paramref name="method" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="type" /> no hereda <see cref="T:System.MulticastDelegate" />.  
  
O bien 
 <paramref name="type" /> no es un <see langword="RuntimeType" />. Vea [Tipos de reflexión en tiempo de ejecución](https://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858).  
  
O bien 
 No se puede enlazar <paramref name="method" /> y <paramref name="throwOnBindFailure" /> es <see langword="true" />.  
  
O bien 
 <paramref name="method" /> no es un <see langword="RuntimeMethodInfo" />. Vea [Tipos de reflexión en tiempo de ejecución](https://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858).</exception>
        <exception cref="T:System.MissingMethodException">No se encuentra el método <see langword="Invoke" /> de <paramref name="type" />.</exception>
        <exception cref="T:System.MethodAccessException">El autor de la llamada no tiene los permisos necesarios para acceder a <paramref name="method" />.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Cuando se invoca en tiempo de ejecución a través de mecanismos como <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Enumeración asociada: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</permission>
        <altmember cref="T:System.Type" />
        <altmember cref="T:System.MulticastDelegate" />
        <altmember cref="T:System.Security.Permissions.ReflectionPermission" />
        <altmember cref="T:System.Reflection.MethodInfo" />
      </Docs>
    </Member>
    <Member MemberName="CreateDelegate">
      <MemberSignature Language="C#" Value="public static Delegate CreateDelegate (Type type, Type target, string method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Delegate CreateDelegate(class System.Type type, class System.Type target, string method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Delegate ^ CreateDelegate(Type ^ type, Type ^ target, System::String ^ method);" />
      <MemberSignature Language="F#" Value="static member CreateDelegate : Type * Type * string -&gt; Delegate" Usage="System.Delegate.CreateDelegate (type, target, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="target" Type="System.Type" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="method" Type="System.String" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="type"><see cref="T:System.Type" /> de delegado que se va a crear.</param>
        <param name="target"><see cref="T:System.Type" /> que representa la clase que implementa <paramref name="method" />.</param>
        <param name="method">Nombre del método estático que va a representar el delegado.</param>
        <summary>Crea un delegado del tipo especificado que representa el método estático especificado de la clase especificada.</summary>
        <returns>Delegado del tipo especificado que representa el método estático especificado de la clase especificada.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método crea a los delegados para los métodos estáticos solo. Un método de instancia es un método que está asociado a una instancia de una clase. un método estático es un método que está asociado a la propia clase.  
  
 Esta sobrecarga del método es equivalente a llamar a la <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Type%2CSystem.String%2CSystem.Boolean%2CSystem.Boolean%29> sobrecarga del método, especifica `false` para `ignoreCase` y `true` para `throwOnBindFailure`.  
  
> [!NOTE]
>  A partir de la [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], este método puede utilizarse para tener acceso a los métodos no públicos si el llamador tiene concedidos <xref:System.Security.Permissions.ReflectionPermission> con el <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> marca y si el conjunto de permisos de los métodos no públicos se restringe al llamador conceder el conjunto o un subconjunto en ella. (Consulte [consideraciones de seguridad para la reflexión](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)  
>   
>  Para utilizar esta funcionalidad, la aplicación debe utilizar [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] o posterior como destino.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="type" /> es <see langword="null" />.  
  
O bien 
 <paramref name="target" /> es <see langword="null" />.  
  
O bien 
 <paramref name="method" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="type" /> no hereda <see cref="T:System.MulticastDelegate" />.  
  
O bien 
 <paramref name="type" /> no es un <see langword="RuntimeType" />. Vea [Tipos de reflexión en tiempo de ejecución](https://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858).  
  
O bien 
 <paramref name="target" /> no es un <see langword="RuntimeType" />.  
  
O bien 
 <paramref name="target" /> es un tipo genérico abierto. Es decir, su propiedad <see cref="P:System.Type.ContainsGenericParameters" /> es <see langword="true" />.  
  
O bien 
 <paramref name="method" /> no es un método <see langword="static" /> (método <see langword="Shared" /> en Visual Basic).  
  
O bien 
 <paramref name="method" /> no se puede enlazar (por ejemplo, porque no se encuentra) y <paramref name="throwOnBindFailure" /> es <see langword="true" />.</exception>
        <exception cref="T:System.MissingMethodException">No se encuentra el método <see langword="Invoke" /> de <paramref name="type" />.</exception>
        <exception cref="T:System.MethodAccessException">El autor de la llamada no tiene los permisos necesarios para acceder a <paramref name="method" />.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Cuando se invoca en tiempo de ejecución a través de mecanismos como <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Enumeración asociada: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</permission>
        <altmember cref="T:System.Type" />
        <altmember cref="T:System.MulticastDelegate" />
        <altmember cref="T:System.Security.Permissions.ReflectionPermission" />
        <altmember cref="T:System.Object" />
      </Docs>
    </Member>
    <Member MemberName="CreateDelegate">
      <MemberSignature Language="C#" Value="public static Delegate CreateDelegate (Type type, object firstArgument, System.Reflection.MethodInfo method, bool throwOnBindFailure);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Delegate CreateDelegate(class System.Type type, object firstArgument, class System.Reflection.MethodInfo method, bool throwOnBindFailure) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Delegate ^ CreateDelegate(Type ^ type, System::Object ^ firstArgument, System::Reflection::MethodInfo ^ method, bool throwOnBindFailure);" />
      <MemberSignature Language="F#" Value="static member CreateDelegate : Type * obj * System.Reflection.MethodInfo * bool -&gt; Delegate" Usage="System.Delegate.CreateDelegate (type, firstArgument, method, throwOnBindFailure)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="firstArgument" Type="System.Object" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="throwOnBindFailure" Type="System.Boolean" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="type"><see cref="T:System.Type" /> que representa el tipo de delegado que se va a crear.</param>
        <param name="firstArgument"><see cref="T:System.Object" /> que es el primer argumento del método que representa el delegado. Para los métodos de instancia, debe ser compatible con el tipo de instancia.</param>
        <param name="method"><see cref="T:System.Reflection.MethodInfo" /> que describe el método estático o de instancia que el delegado va a representar.</param>
        <param name="throwOnBindFailure">Es <see langword="true" /> para iniciar una excepción si no se puede enlazar <paramref name="method" />; en caso contrario, es <see langword="false" />.</param>
        <summary>Crea un delegado del tipo especificado que representa el método estático o de instancia determinado, con el primer argumento definido y el comportamiento especificado si se produce un error en el enlace.</summary>
        <returns>Delegado del tipo especificado que representa el método estático o de instancia determinado, o <see langword="null" /> si <paramref name="throwOnBindFailure" /> es <see langword="false" /> y no se puede enlazar el delegado a <paramref name="method" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esta sobrecarga del método y el <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Object%2CSystem.Reflection.MethodInfo%29> sobrecarga del método siempre produce una excepción en caso de error para enlazar, proporcionan la manera más flexible para crear delegados. Puede usarlos para crear delegados para estáticas o métodos de instancia, con o sin un primer argumento.  
  
> [!NOTE]
>  Si no proporciona un primer argumento, utilice el <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Reflection.MethodInfo%2CSystem.Boolean%29> sobrecarga del método para mejorar el rendimiento.  
  
 El tipo de delegado y el método deben tener tipos de valor devuelto compatibles. Es decir, el tipo de valor devuelto de `method` debe ser asignable al tipo de valor devuelto de `type`.  
  
 Si `firstArgument` es proporciona, se pasa a `method` cada vez que se invoca al delegado; `firstArgument` se dice que está enlazado al delegado, y se dice que el delegado se cerrados a lo largo de su primer argumento. Si `method` es `static` (`Shared` en Visual Basic), la lista de argumentos proporcionado al invocar al delegado incluye todos los parámetros excepto el primero; si `method` es un método de instancia, a continuación, `firstArgument` se pasa a la instancia oculta parámetro (representado por `this` en C# o por `Me` en Visual Basic).  
  
 Si `firstArgument` se proporciona, el primer parámetro de `method` debe ser un tipo de referencia y `firstArgument` debe ser compatible con ese tipo.  
  
> [!IMPORTANT]
>  Si `method` es `static` (`Shared` en Visual Basic) y su primer parámetro es de tipo <xref:System.Object> o <xref:System.ValueType>, a continuación, `firstArgument` puede ser un tipo de valor. En este caso `firstArgument` se aplica automáticamente. La conversión boxing automática no se produce para los demás argumentos, como en C# o Visual Basic función llamaría.  
  
 Si `firstArgument` es una referencia nula y `method` es un método de instancia, el resultado depende de las firmas del tipo de delegado `type` y de `method`:  
  
-   Si la firma de `type` incluya explícitamente el primer parámetro oculto de `method`, se dice que el delegado representa un método de instancia abierta. Cuando se invoca el delegado, el primer argumento de la lista de argumentos se pasa al parámetro de instancia oculta `method`.  
  
-   Si las firmas de `method` y `type` coinciden (es decir, todos los tipos de parámetro son compatibles), a continuación, se dice que el delegado se cerrados a lo largo de una referencia nula. Invocación del delegado es como una llamada a un método de instancia en una instancia null, que no es algo especialmente útil.  
  
 Si `firstArgument` es una referencia nula y `method` es estático, el resultado depende de las firmas del tipo de delegado `type` y de `method`:  
  
-   Si la firma de `method` y `type` coinciden (es decir, todos los tipos de parámetro son compatibles), se dice que el delegado para representar un método estático abierto. Este es el caso más común para los métodos estáticos. En este caso, puede obtener un rendimiento ligeramente mejor mediante el <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Reflection.MethodInfo%2CSystem.Boolean%29> sobrecarga del método.  
  
-   Si la firma de `type` comienza con el segundo parámetro de `method` y el resto de los tipos de parámetros son compatibles y, después, se dice que el delegado se cerrados a lo largo de una referencia nula. Cuando se invoca el delegado, se pasa una referencia nula al primer parámetro de `method`.  
  
> [!NOTE]
>  A partir de la [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], este método puede utilizarse para tener acceso a los métodos no públicos si el llamador tiene concedidos <xref:System.Security.Permissions.ReflectionPermission> con el <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> marca y si el conjunto de permisos de los métodos no públicos se restringe al llamador conceder el conjunto o un subconjunto en ella. (Consulte [consideraciones de seguridad para la reflexión](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)  
>   
>  Para utilizar esta funcionalidad, la aplicación debe utilizar [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] o posterior como destino.  
  
## <a name="compatible-parameter-types-and-return-type"></a>Tipos de parámetros compatibles y el tipo de valor devuelto  
 Los tipos de parámetro y el tipo de valor devuelto de un delegado deben ser compatibles con los tipos de parámetro y el tipo de valor devuelto del método que representa el delegado; los tipos no tienen que coincidir exactamente.  
  
> [!NOTE]
>  En la versión 1.0 y 1.1 de .NET Framework los tipos deben coincidir exactamente.  
  
 Un parámetro de un delegado es compatible con el parámetro correspondiente de un método si el tipo del parámetro del delegado es más restrictivo que el del método, porque así se garantiza que el argumento que se pase al delegado también se podrá pasar de forma segura al método.  
  
 De forma similar, el tipo de valor devuelto de un delegado es compatible con el tipo de valor devuelto de un método si el del método es más restrictivo que el del delegado, porque así se garantiza que el tipo de valor devuelto por el método se puede convertir con seguridad al tipo de valor devuelto del delegado.  
  
 Por ejemplo, un delegado con un parámetro de tipo <xref:System.Collections.Hashtable> y un tipo de valor devuelto de <xref:System.Object> puede representar un método con un parámetro de tipo <xref:System.Object> y un valor devuelto de tipo <xref:System.Collections.Hashtable>.  
  
## <a name="determining-the-methods-a-delegate-can-represent"></a>Determinación de los métodos que puede representar un delegado  
 Otra manera útil pensar en la flexibilidad proporcionada por esta sobrecarga de <xref:System.Delegate.CreateDelegate%2A> es que cualquier delegado puede representar cuatro combinaciones diferentes de firma de método y el tipo de método (estático frente a la instancia). Considere la posibilidad de un tipo de delegado `D` con un argumento de tipo `C`. Lo siguiente describe los métodos `D` puede representar, omitiendo el tipo de valor devuelto, puesto que debe coincidir en todos los casos:  
  
-   `D` puede representar cualquier método de instancia que tiene exactamente un argumento de tipo `C`, independientemente de qué tipo pertenece el método de instancia. Cuando <xref:System.Delegate.CreateDelegate%2A> se llama, `firstArgument` es una instancia del tipo `method` pertenece, y se dice que el delegado resultante se cerrados a lo largo de esa instancia. (De forma trivial, `D` también se puede cerrar a través de una referencia nula si `firstArgument` es `null`.)  
  
-   `D` puede representar un método de instancia de `C` que no tiene ningún argumento. Cuando <xref:System.Delegate.CreateDelegate%2A> se llama, `firstArgument` es una referencia nula. El delegado resultante representa un método de instancia abierta y una instancia de `C` se debe proporcionar cada vez que se invoca.  
  
-   `D` puede representar un método estático que toma un argumento de tipo `C`, y que el método puede pertenecer a cualquier tipo. Cuando <xref:System.Delegate.CreateDelegate%2A> se llama, `firstArgument` es una referencia nula. El delegado resultante representa un método estático abierto y una instancia de `C` se debe proporcionar cada vez que se invoca.  
  
-   `D` puede representar un método estático que pertenece al tipo `F` y tiene dos argumentos de tipo `F` y tipo `C`. Cuando <xref:System.Delegate.CreateDelegate%2A> se llama, `firstArgument` es una instancia de `F`. El delegado resultante representa un método estático que se cierra en esa instancia de `F`. Tenga en cuenta que en el caso donde `F` y `C` son del mismo tipo, el método estático tiene dos argumentos de ese tipo. (En este caso, `D` se cierra en una referencia nula si `firstArgument` es `null`.)  
  
   
  
## Examples  
 Esta sección contiene tres ejemplos de código. El primer ejemplo muestra los cuatro tipos de delegados que se pueden crear: cerrados a lo largo de un método de instancia, abra a través de un método de instancia, abra a través de un método estático y cerrados a lo largo de un método estático.  
  
 El segundo ejemplo de código muestra los tipos de parámetros compatibles y los tipos de valor devuelto.  
  
 El tercer ejemplo de código define un tipo de delegado único y muestra todos los métodos de ese tipo de delegado pueden representar.  
  
 **Ejemplo 1**  
  
 En el ejemplo de código siguiente se muestra las cuatro maneras se puede crear un delegado mediante esta sobrecarga de la <xref:System.Delegate.CreateDelegate%2A> método.  
  
> [!NOTE]
>  Hay dos sobrecargas de los <xref:System.Delegate.CreateDelegate%2A> método que especifique `firstArgument` y un <xref:System.Reflection.MethodInfo>; su funcionalidad es el mismo, salvo que uno le permite especificar si se debe producir el error al enlazar y el otro siempre produce una excepción. Este ejemplo de código usa las dos sobrecargas.  
  
 En el ejemplo se declara una clase `C` con un método estático `M2` y un método de instancia `M1`, y tres tipos de delegado: `D1` toma una instancia de `C` y una cadena, `D2` toma una cadena y `D3`no tiene ningún argumento.  
  
 Una segunda clase denominada `Example` contiene el código que crea los delegados.  
  
-   Un delegado del tipo `D2`, cerrado a través de una instancia de `C`, se crea para el método de instancia `M1`. Se invoca con cadenas diferentes, para mostrar que la instancia enlazada de `C` siempre se utiliza.  
  
-   Un delegado del tipo `D1`, que representa un método de instancia abierta, se crea para el método de instancia `M1`. Cuando se invoca el delegado, se debe pasar una instancia.  
  
-   Un delegado del tipo `D2`, que representa un método estático abierto, se crea para el método estático `M2`.  
  
-   Por último, un delegado del tipo `D3`, cerrados a lo largo de una cadena, se crea para el método estático `M2`. El método se invoca para mostrar que utiliza la cadena enlazada.  
  
 [!code-csharp[Delegate.CreateDelegateTOM#1](~/samples/snippets/csharp/VS_Snippets_CLR/Delegate.CreateDelegateTOM/cs/openClosedOver.cs#1)]
 [!code-vb[Delegate.CreateDelegateTOM#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Delegate.CreateDelegateTOM/VB/openClosedOver.vb#1)]  
  
 **Ejemplo 2**  
  
 En el ejemplo de código siguiente se muestra la compatibilidad de tipos de parámetro y tipos de valor devuelto.  
  
> [!NOTE]
>  Este ejemplo de código utiliza el <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Reflection.MethodInfo%29> sobrecarga del método. El uso de otras sobrecargas que toman <xref:System.Reflection.MethodInfo> es similar.  
  
 El ejemplo de código define una clase base denominada `Base` y una clase denominada `Derived` que se deriva de `Base`. La clase derivada tiene una `static` (`Shared` en Visual Basic) método denominado `MyMethod` con un parámetro de tipo `Base` y un tipo de valor devuelto de `Derived`. El ejemplo de código también define un delegado denominado `Example` que tiene un parámetro de tipo `Derived` y un tipo de valor devuelto de `Base`.  
  
 El ejemplo de código se muestra que el delegado denominado `Example` puede usarse para representar el método `MyMethod`. El método se puede enlazar al delegado porque:  
  
-   El tipo de parámetro del delegado (`Derived`) es más restrictivo que el tipo de parámetro `MyMethod` (`Base`), de modo que siempre es seguro pasar el argumento del delegado para `MyMethod`.  
  
-   El tipo de valor devuelto de `MyMethod` (`Derived`) es más restrictivo que el tipo de parámetro del delegado (`Base`), de modo que siempre es seguro convertir el tipo de valor devuelto del método para el tipo de valor devuelto del delegado.  
  
 El ejemplo de código no genera ninguna salida.  
  
 [!code-cpp[Delegate.CreateDelegate_RelaxedFit#1](~/samples/snippets/cpp/VS_Snippets_CLR/Delegate.CreateDelegate_RelaxedFit/cpp/source.cpp#1)]
 [!code-csharp[Delegate.CreateDelegate_RelaxedFit#1](~/samples/snippets/csharp/VS_Snippets_CLR/Delegate.CreateDelegate_RelaxedFit/cs/source.cs#1)]
 [!code-vb[Delegate.CreateDelegate_RelaxedFit#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Delegate.CreateDelegate_RelaxedFit/vb/source.vb#1)]  
  
 **Ejemplo 3**  
  
 El ejemplo de código siguiente muestra todos los métodos que puede representar un tipo de delegado único.  
  
> [!NOTE]
>  Hay dos sobrecargas de los <xref:System.Delegate.CreateDelegate%2A> método que especifique `firstArgument` y un <xref:System.Reflection.MethodInfo>; su funcionalidad es el mismo, salvo que uno le permite especificar si se debe producir el error al enlazar y el otro siempre produce una excepción. Este ejemplo de código usa las dos sobrecargas.  
  
 El ejemplo de código define dos clases, `C` y `F`y un tipo de delegado `D` con un argumento de tipo `C`. Las clases tienen coincidentes estáticos y métodos de instancia `M1`, `M3`, y `M4`y la clase `C` también tiene un método de instancia `M2` que no tiene ningún argumento.  
  
 Una tercera clase denominada `Example` contiene el código que crea los delegados.  
  
-   Los delegados se crean, por ejemplo, método `M1` de tipo `C` y tipo `F`; cada uno se cierra sobre una instancia del tipo correspondiente. Método `M1` typu `C` muestra el `ID` las propiedades de la instancia enlazada y del argumento.  
  
-   Se crea un delegado para método `M2` de tipo `C`. Se trata de un delegado de la instancia abierta, en el que el argumento del delegado representa el primer argumento oculto en el método de instancia. El método no tiene ningún otro argumento.  
  
-   Se crean delegados para el método estático `M3` de tipo `C` y tipo `F`; estos son delegados estáticos abiertos.  
  
-   Por último, se crean los delegados de método estático `M4` typu `C` y tipo `F`; cada método tiene el tipo declarativo como primer argumento y se proporciona una instancia del tipo, por lo que los delegados se cierran en sus primeros argumentos . Método `M4` typu `C` muestra el `ID` las propiedades de la instancia enlazada y del argumento.  
  
 [!code-csharp[Delegate.CreateDelegateTOM_2#1](~/samples/snippets/csharp/VS_Snippets_CLR/Delegate.CreateDelegateTOM_2/cs/source.cs#1)]
 [!code-vb[Delegate.CreateDelegateTOM_2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Delegate.CreateDelegateTOM_2/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="type" /> es <see langword="null" />.  
  
O bien 
 <paramref name="method" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="type" /> no hereda <see cref="T:System.MulticastDelegate" />.  
  
O bien 
 <paramref name="type" /> no es un <see langword="RuntimeType" />. Vea [Tipos de reflexión en tiempo de ejecución](https://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858).  
  
O bien 
 No se puede enlazar <paramref name="method" /> y <paramref name="throwOnBindFailure" /> es <see langword="true" />.  
  
O bien 
 <paramref name="method" /> no es un <see langword="RuntimeMethodInfo" />. Vea [Tipos de reflexión en tiempo de ejecución](https://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858).</exception>
        <exception cref="T:System.MissingMethodException">No se encuentra el método <see langword="Invoke" /> de <paramref name="type" />.</exception>
        <exception cref="T:System.MethodAccessException">El autor de la llamada no tiene los permisos necesarios para acceder a <paramref name="method" />.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Cuando se invoca en tiempo de ejecución a través de mecanismos como <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Enumeración asociada: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</permission>
        <altmember cref="T:System.Type" />
        <altmember cref="T:System.MulticastDelegate" />
        <altmember cref="T:System.Security.Permissions.ReflectionPermission" />
        <altmember cref="T:System.Reflection.MethodInfo" />
      </Docs>
    </Member>
    <Member MemberName="CreateDelegate">
      <MemberSignature Language="C#" Value="public static Delegate CreateDelegate (Type type, object target, string method, bool ignoreCase);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Delegate CreateDelegate(class System.Type type, object target, string method, bool ignoreCase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.String,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Delegate ^ CreateDelegate(Type ^ type, System::Object ^ target, System::String ^ method, bool ignoreCase);" />
      <MemberSignature Language="F#" Value="static member CreateDelegate : Type * obj * string * bool -&gt; Delegate" Usage="System.Delegate.CreateDelegate (type, target, method, ignoreCase)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="target" Type="System.Object" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="method" Type="System.String" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="ignoreCase" Type="System.Boolean" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="type"><see cref="T:System.Type" /> de delegado que se va a crear.</param>
        <param name="target">Instancia de clase en la que se invoca a <paramref name="method" />.</param>
        <param name="method">Nombre del método de instancia que el delegado va a representar.</param>
        <param name="ignoreCase">Valor booleano que indica si debe omitirse la distinción de mayúsculas y minúsculas al comparar el nombre del método.</param>
        <summary>Crea un delegado del tipo especificado que representa el método de instancia especificado que se va a invocar en la instancia de clase especificada con la distinción de mayúsculas y minúsculas que se haya especificado.</summary>
        <returns>Delegado del tipo especificado que representa el método de instancia especificado que se va a invocar en la instancia de clase especificada.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método crea a los delegados por métodos de instancia solo. Un método de instancia es un método que está asociado a una instancia de una clase. un método estático es un método que está asociado a la propia clase.  
  
 Esta sobrecarga del método es equivalente a llamar a la <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Object%2CSystem.String%2CSystem.Boolean%2CSystem.Boolean%29> sobrecarga del método, especifica `true` para `throwOnBindFailure`.  
  
> [!NOTE]
>  A partir de la [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], este método puede utilizarse para tener acceso a los métodos no públicos si el llamador tiene concedidos <xref:System.Security.Permissions.ReflectionPermission> con el <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> marca y si el conjunto de permisos de los métodos no públicos se restringe al llamador conceder el conjunto o un subconjunto en ella. (Consulte [consideraciones de seguridad para la reflexión](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)  
>   
>  Para utilizar esta funcionalidad, la aplicación debe utilizar [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] o posterior como destino.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="type" /> es <see langword="null" />.  
  
O bien 
 <paramref name="target" /> es <see langword="null" />.  
  
O bien 
 <paramref name="method" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="type" /> no hereda <see cref="T:System.MulticastDelegate" />.  
  
O bien 
 <paramref name="type" /> no es un <see langword="RuntimeType" />. Vea [Tipos de reflexión en tiempo de ejecución](https://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858).  
  
O bien 
 <paramref name="method" /> no es un método de instancia.  
  
O bien 
 <paramref name="method" /> no se puede enlazar, por ejemplo, porque no se encuentra.</exception>
        <exception cref="T:System.MissingMethodException">No se encuentra el método <see langword="Invoke" /> de <paramref name="type" />.</exception>
        <exception cref="T:System.MethodAccessException">El autor de la llamada no tiene los permisos necesarios para acceder a <paramref name="method" />.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Cuando se invoca en tiempo de ejecución a través de mecanismos como <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Enumeración asociada: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</permission>
        <altmember cref="T:System.Type" />
        <altmember cref="T:System.MulticastDelegate" />
        <altmember cref="T:System.Security.Permissions.ReflectionPermission" />
        <altmember cref="T:System.Object" />
      </Docs>
    </Member>
    <Member MemberName="CreateDelegate">
      <MemberSignature Language="C#" Value="public static Delegate CreateDelegate (Type type, Type target, string method, bool ignoreCase);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Delegate CreateDelegate(class System.Type type, class System.Type target, string method, bool ignoreCase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Delegate ^ CreateDelegate(Type ^ type, Type ^ target, System::String ^ method, bool ignoreCase);" />
      <MemberSignature Language="F#" Value="static member CreateDelegate : Type * Type * string * bool -&gt; Delegate" Usage="System.Delegate.CreateDelegate (type, target, method, ignoreCase)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="target" Type="System.Type" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="method" Type="System.String" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="ignoreCase" Type="System.Boolean" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="type"><see cref="T:System.Type" /> de delegado que se va a crear.</param>
        <param name="target"><see cref="T:System.Type" /> que representa la clase que implementa <paramref name="method" />.</param>
        <param name="method">Nombre del método estático que va a representar el delegado.</param>
        <param name="ignoreCase">Valor booleano que indica si debe omitirse la distinción de mayúsculas y minúsculas al comparar el nombre del método.</param>
        <summary>Crea un delegado del tipo especificado que representa el método estático determinado de la clase especificada, con la distinción de mayúsculas y minúsculas definida.</summary>
        <returns>Delegado del tipo especificado que representa el método estático especificado de la clase especificada.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método crea a los delegados para los métodos estáticos solo. Un método de instancia es un método que está asociado a una instancia de una clase. un método estático es un método que está asociado a la propia clase.  
  
 Esta sobrecarga del método es equivalente a llamar a la <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Type%2CSystem.String%2CSystem.Boolean%2CSystem.Boolean%29> sobrecarga del método, especifica `true` para `throwOnBindFailure`.  
  
> [!NOTE]
>  A partir de la [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], este método puede utilizarse para tener acceso a los métodos no públicos si el llamador tiene concedidos <xref:System.Security.Permissions.ReflectionPermission> con el <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> marca y si el conjunto de permisos de los métodos no públicos se restringe al llamador conceder el conjunto o un subconjunto en ella. (Consulte [consideraciones de seguridad para la reflexión](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)  
>   
>  Para utilizar esta funcionalidad, la aplicación debe utilizar [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] o posterior como destino.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="type" /> es <see langword="null" />.  
  
O bien 
 <paramref name="target" /> es <see langword="null" />.  
  
O bien 
 <paramref name="method" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="type" /> no hereda <see cref="T:System.MulticastDelegate" />.  
  
O bien 
 <paramref name="type" /> no es un <see langword="RuntimeType" />. Vea [Tipos de reflexión en tiempo de ejecución](https://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858).  
  
O bien 
 <paramref name="target" /> no es un <see langword="RuntimeType" />.  
  
O bien 
 <paramref name="target" /> es un tipo genérico abierto. Es decir, su propiedad <see cref="P:System.Type.ContainsGenericParameters" /> es <see langword="true" />.  
  
O bien 
 <paramref name="method" /> no es un método <see langword="static" /> (método <see langword="Shared" /> en Visual Basic).  
  
O bien 
 <paramref name="method" /> no se puede enlazar, por ejemplo, porque no se encuentra.</exception>
        <exception cref="T:System.MissingMethodException">No se encuentra el método <see langword="Invoke" /> de <paramref name="type" />.</exception>
        <exception cref="T:System.MethodAccessException">El autor de la llamada no tiene los permisos necesarios para acceder a <paramref name="method" />.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Cuando se invoca en tiempo de ejecución a través de mecanismos como <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Enumeración asociada: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</permission>
        <altmember cref="T:System.Type" />
        <altmember cref="T:System.MulticastDelegate" />
        <altmember cref="T:System.Security.Permissions.ReflectionPermission" />
        <altmember cref="T:System.Object" />
      </Docs>
    </Member>
    <Member MemberName="CreateDelegate">
      <MemberSignature Language="C#" Value="public static Delegate CreateDelegate (Type type, object target, string method, bool ignoreCase, bool throwOnBindFailure);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Delegate CreateDelegate(class System.Type type, object target, string method, bool ignoreCase, bool throwOnBindFailure) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.String,System.Boolean,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Delegate ^ CreateDelegate(Type ^ type, System::Object ^ target, System::String ^ method, bool ignoreCase, bool throwOnBindFailure);" />
      <MemberSignature Language="F#" Value="static member CreateDelegate : Type * obj * string * bool * bool -&gt; Delegate" Usage="System.Delegate.CreateDelegate (type, target, method, ignoreCase, throwOnBindFailure)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="target" Type="System.Object" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="method" Type="System.String" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="ignoreCase" Type="System.Boolean" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="throwOnBindFailure" Type="System.Boolean" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="type"><see cref="T:System.Type" /> de delegado que se va a crear.</param>
        <param name="target">Instancia de clase en la que se invoca a <paramref name="method" />.</param>
        <param name="method">Nombre del método de instancia que el delegado va a representar.</param>
        <param name="ignoreCase">Valor booleano que indica si debe omitirse la distinción de mayúsculas y minúsculas al comparar el nombre del método.</param>
        <param name="throwOnBindFailure">Es <see langword="true" /> para iniciar una excepción si no se puede enlazar <paramref name="method" />; en caso contrario, es <see langword="false" />.</param>
        <summary>Crea un delegado del tipo especificado que representa el método de instancia determinado que se va a invocar en la instancia de clase especificada, con la distinción de mayúsculas y minúsculas y el comportamiento que se hayan concretado para cuando se produce un error al enlazar.</summary>
        <returns>Delegado del tipo especificado que representa el método de instancia especificado que se va a invocar en la instancia de clase especificada.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método crea a los delegados por métodos de instancia solo. Un método de instancia es un método que está asociado a una instancia de una clase. un método estático es un método que está asociado a la propia clase.  
  
> [!NOTE]
>  A partir de la [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], este método puede utilizarse para tener acceso a los métodos no públicos si el llamador tiene concedidos <xref:System.Security.Permissions.ReflectionPermission> con el <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> marca y si el conjunto de permisos de los métodos no públicos se restringe al llamador conceder el conjunto o un subconjunto en ella. (Consulte [consideraciones de seguridad para la reflexión](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)  
>   
>  Para utilizar esta funcionalidad, la aplicación debe utilizar [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] o posterior como destino.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="type" /> es <see langword="null" />.  
  
O bien 
 <paramref name="target" /> es <see langword="null" />.  
  
O bien 
 <paramref name="method" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="type" /> no hereda <see cref="T:System.MulticastDelegate" />.  
  
O bien 
 <paramref name="type" /> no es un <see langword="RuntimeType" />. Vea [Tipos de reflexión en tiempo de ejecución](https://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858).  
  
O bien 
 <paramref name="method" /> no es un método de instancia.  
  
O bien 
 <paramref name="method" /> no se puede enlazar (por ejemplo, porque no se encuentra) y <paramref name="throwOnBindFailure" /> es <see langword="true" />.</exception>
        <exception cref="T:System.MissingMethodException">No se encuentra el método <see langword="Invoke" /> de <paramref name="type" />.</exception>
        <exception cref="T:System.MethodAccessException">El autor de la llamada no tiene los permisos necesarios para acceder a <paramref name="method" />.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Cuando se invoca en tiempo de ejecución a través de mecanismos como <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Enumeración asociada: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</permission>
        <altmember cref="T:System.Type" />
        <altmember cref="T:System.MulticastDelegate" />
        <altmember cref="T:System.Security.Permissions.ReflectionPermission" />
        <altmember cref="T:System.Object" />
      </Docs>
    </Member>
    <Member MemberName="CreateDelegate">
      <MemberSignature Language="C#" Value="public static Delegate CreateDelegate (Type type, Type target, string method, bool ignoreCase, bool throwOnBindFailure);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Delegate CreateDelegate(class System.Type type, class System.Type target, string method, bool ignoreCase, bool throwOnBindFailure) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String,System.Boolean,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Delegate ^ CreateDelegate(Type ^ type, Type ^ target, System::String ^ method, bool ignoreCase, bool throwOnBindFailure);" />
      <MemberSignature Language="F#" Value="static member CreateDelegate : Type * Type * string * bool * bool -&gt; Delegate" Usage="System.Delegate.CreateDelegate (type, target, method, ignoreCase, throwOnBindFailure)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="target" Type="System.Type" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="method" Type="System.String" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="ignoreCase" Type="System.Boolean" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="throwOnBindFailure" Type="System.Boolean" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="type"><see cref="T:System.Type" /> de delegado que se va a crear.</param>
        <param name="target"><see cref="T:System.Type" /> que representa la clase que implementa <paramref name="method" />.</param>
        <param name="method">Nombre del método estático que va a representar el delegado.</param>
        <param name="ignoreCase">Valor booleano que indica si debe omitirse la distinción de mayúsculas y minúsculas al comparar el nombre del método.</param>
        <param name="throwOnBindFailure">Es <see langword="true" /> para iniciar una excepción si no se puede enlazar <paramref name="method" />; en caso contrario, es <see langword="false" />.</param>
        <summary>Crea un delegado del tipo especificado que representa el método estático determinado de la clase especificada, con la distinción de mayúsculas y minúsculas definida y el comportamiento que se haya concretado para cuando se produce un error al enlazar.</summary>
        <returns>Delegado del tipo especificado que representa el método estático especificado de la clase especificada.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método crea a los delegados para los métodos estáticos solo. Un método de instancia es un método que está asociado a una instancia de una clase. un método estático es un método que está asociado a la propia clase.  
  
> [!NOTE]
>  A partir de la [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], este método puede utilizarse para tener acceso a los métodos no públicos si el llamador tiene concedidos <xref:System.Security.Permissions.ReflectionPermission> con el <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> marca y si el conjunto de permisos de los métodos no públicos se restringe al llamador conceder el conjunto o un subconjunto en ella. (Consulte [consideraciones de seguridad para la reflexión](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)  
>   
>  Para utilizar esta funcionalidad, la aplicación debe utilizar [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] o posterior como destino.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="type" /> es <see langword="null" />.  
  
O bien 
 <paramref name="target" /> es <see langword="null" />.  
  
O bien 
 <paramref name="method" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="type" /> no hereda <see cref="T:System.MulticastDelegate" />.  
  
O bien 
 <paramref name="type" /> no es un <see langword="RuntimeType" />. Vea [Tipos de reflexión en tiempo de ejecución](https://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858).  
  
O bien 
 <paramref name="target" /> no es un <see langword="RuntimeType" />.  
  
O bien 
 <paramref name="target" /> es un tipo genérico abierto. Es decir, su propiedad <see cref="P:System.Type.ContainsGenericParameters" /> es <see langword="true" />.  
  
O bien 
 <paramref name="method" /> no es un método <see langword="static" /> (método <see langword="Shared" /> en Visual Basic).  
  
O bien 
 <paramref name="method" /> no se puede enlazar (por ejemplo, porque no se encuentra) y <paramref name="throwOnBindFailure" /> es <see langword="true" />.</exception>
        <exception cref="T:System.MissingMethodException">No se encuentra el método <see langword="Invoke" /> de <paramref name="type" />.</exception>
        <exception cref="T:System.MethodAccessException">El autor de la llamada no tiene los permisos necesarios para acceder a <paramref name="method" />.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Cuando se invoca en tiempo de ejecución a través de mecanismos como <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Enumeración asociada: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</permission>
        <altmember cref="T:System.Type" />
        <altmember cref="T:System.MulticastDelegate" />
        <altmember cref="T:System.Security.Permissions.ReflectionPermission" />
        <altmember cref="T:System.Object" />
      </Docs>
    </Member>
    <Member MemberName="DynamicInvoke">
      <MemberSignature Language="C#" Value="public object DynamicInvoke (params object[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object DynamicInvoke(object[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.DynamicInvoke(System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function DynamicInvoke (ParamArray args As Object()) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ DynamicInvoke(... cli::array &lt;System::Object ^&gt; ^ args);" />
      <MemberSignature Language="F#" Value="member this.DynamicInvoke : obj[] -&gt; obj" Usage="delegate.DynamicInvoke args" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="args" Type="System.Object[]">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-uwp-10.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="args">Matriz de objetos que son los argumentos que se van a pasar al método representado por el delegado actual.  
  
O bien 
 <see langword="null" />, si el método representado por el delegado actual no requiere argumentos.</param>
        <summary>Invoca dinámicamente (en tiempo de ejecución) al método representado por el delegado actual.</summary>
        <returns>Objeto devuelto por el método representado por el delegado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método llama al método <xref:System.Delegate.DynamicInvokeImpl%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.MemberAccessException">El llamador no tiene acceso al método representado por el delegado (por ejemplo, si el método es privado).  
  
O bien 
El número, orden o tipo de los parámetros enumerados en <paramref name="args" /> no es válido.</exception>
        <exception cref="T:System.ArgumentException">El método representado por el delegado se invoca en un objeto o en una clase que no lo admite.</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">El método representado por el delegado es un método de instancia y el objeto de destino es <see langword="null" />.  
  
O bien 
Uno de los métodos encapsulados produce una excepción.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Cuando se invoca en tiempo de ejecución a través de mecanismos como <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Enumeración asociada: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="M:System.Delegate.DynamicInvokeImpl(System.Object[])" />
        <altmember cref="T:System.Object" />
      </Docs>
    </Member>
    <Member MemberName="DynamicInvokeImpl">
      <MemberSignature Language="C#" Value="protected virtual object DynamicInvokeImpl (object[] args);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance object DynamicInvokeImpl(object[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.DynamicInvokeImpl(System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function DynamicInvokeImpl (args As Object()) As Object" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Object ^ DynamicInvokeImpl(cli::array &lt;System::Object ^&gt; ^ args);" />
      <MemberSignature Language="F#" Value="abstract member DynamicInvokeImpl : obj[] -&gt; obj&#xA;override this.DynamicInvokeImpl : obj[] -&gt; obj" Usage="delegate.DynamicInvokeImpl args" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="args" Type="System.Object[]" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="args">Matriz de objetos que son los argumentos que se van a pasar al método representado por el delegado actual.  
  
O bien 
 <see langword="null" />, si el método representado por el delegado actual no requiere argumentos.</param>
        <summary>Invoca dinámicamente (en tiempo de ejecución) al método representado por el delegado actual.</summary>
        <returns>Objeto devuelto por el método representado por el delegado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método implementa el método <xref:System.Delegate.DynamicInvoke%2A> .  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.MemberAccessException">El llamador no tiene acceso al método representado por el delegado (por ejemplo, si el método es privado).  
  
O bien 
El número, orden o tipo de los parámetros enumerados en <paramref name="args" /> no es válido.</exception>
        <exception cref="T:System.ArgumentException">El método representado por el delegado se invoca en un objeto o en una clase que no lo admite.</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">El método representado por el delegado es un método de instancia y el objeto de destino es <see langword="null" />.  
  
O bien 
Uno de los métodos encapsulados produce una excepción.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Cuando se invoca en tiempo de ejecución a través de mecanismos como <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Enumeración asociada: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="M:System.Delegate.DynamicInvoke(System.Object[])" />
        <altmember cref="T:System.Object" />
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (obj As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="override this.Equals : obj -&gt; bool" Usage="delegate.Equals obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">Objeto que se va a comparar con el delegado actual.</param>
        <summary>Determina si el objeto especificado y el delegado actual son del mismo tipo y comparten los mismos destinos, métodos y listas de invocaciones.</summary>
        <returns><see langword="true" /> si <paramref name="obj" /> y el delegado actual tienen los mismos destinos, métodos y listas de invocaciones; de lo contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si los dos delegados no son del mismo tipo, no se consideran iguales.  
  
> [!IMPORTANT]
>  En la versión 1.0 y 1.1 de .NET Framework, dos delegados se consideran iguales si sus destinos, métodos y listas de invocaciones eran iguales, aunque los delegados sean de tipos diferentes.  
  
 Los métodos y los destinos se comparan la igualdad como sigue:  
  
-   Si los dos métodos que se están comparados ambos son estáticos y el mismo método en la misma clase, los métodos se consideran iguales y los destinos también se consideran iguales.  
  
-   Si los dos métodos que se comparan son métodos de instancia y el mismo método en el mismo objeto, los métodos se consideran iguales y los destinos también se consideran iguales.  
  
-   En caso contrario, los métodos no se consideran iguales y los destinos no también se consideran iguales.  
  
 Dos listas de invocaciones se consideran idénticas si tienen el mismo orden y los elementos correspondientes de las dos listas representan el mismo método y destino.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.MemberAccessException">El llamador no tiene acceso al método representado por el delegado (por ejemplo, si el método es privado).</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Cuando se invoca en tiempo de ejecución a través de mecanismos como <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Enumeración asociada: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="T:System.Object" />
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="delegate.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Devuelve un código hash para el delegado.</summary>
        <returns>Código hash para el delegado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El valor devuelto de este método no debe conservarse por dos motivos. En primer lugar, es posible que se puede modificar la función hash de una clase para generar una mejor distribución inútil los valores de la antigua función hash. En segundo lugar, la implementación predeterminada de esta clase no garantiza que se devolverá el mismo valor en instancias diferentes.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Cuando se invoca en tiempo de ejecución a través de mecanismos como <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Enumeración asociada: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="M:System.Object.GetHashCode" />
      </Docs>
    </Member>
    <Member MemberName="GetInvocationList">
      <MemberSignature Language="C#" Value="public virtual Delegate[] GetInvocationList ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Delegate[] GetInvocationList() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.GetInvocationList" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetInvocationList () As Delegate()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;Delegate ^&gt; ^ GetInvocationList();" />
      <MemberSignature Language="F#" Value="abstract member GetInvocationList : unit -&gt; Delegate[]&#xA;override this.GetInvocationList : unit -&gt; Delegate[]" Usage="delegate.GetInvocationList " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Delegate[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Devuelve la lista de invocaciones del delegado.</summary>
        <returns>Matriz de delegados que representa la lista de invocaciones del delegado actual.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cada delegado de la matriz representa exactamente un método.  
  
 El orden de los delegados de la matriz es el mismo orden en que el delegado actual invoca los métodos que representan los delegados.  
  
   
  
## Examples  
 El ejemplo siguiente asigna los tres métodos a un delegado. A continuación, llama el <xref:System.Delegate.GetInvocationList%2A> método para obtener un recuento total de los métodos asignado al delegado para ejecutar los delegados en orden inverso y para ejecutar los métodos cuyo nombre no incluya la subcadena "File".  
  
 [!code-csharp[System.Delegate.GetInvocationList#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Delegate.GetInvocationList/cs/GetInvocationList1.cs#1)]
 [!code-vb[System.Delegate.GetInvocationList#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Delegate.GetInvocationList/vb/GetInvocationList1.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Cuando se invoca en tiempo de ejecución a través de mecanismos como <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Enumeración asociada: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
      </Docs>
    </Member>
    <Member MemberName="GetMethodImpl">
      <MemberSignature Language="C#" Value="protected virtual System.Reflection.MethodInfo GetMethodImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Reflection.MethodInfo GetMethodImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.GetMethodImpl" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function GetMethodImpl () As MethodInfo" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Reflection::MethodInfo ^ GetMethodImpl();" />
      <MemberSignature Language="F#" Value="abstract member GetMethodImpl : unit -&gt; System.Reflection.MethodInfo&#xA;override this.GetMethodImpl : unit -&gt; System.Reflection.MethodInfo" Usage="delegate.GetMethodImpl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Obtiene el método estático representado por el delegado actual.</summary>
        <returns><see cref="T:System.Reflection.MethodInfo" /> que describe el método estático representado por el delegado actual.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método solo se aplica si el delegado actual representa un método estático.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.MemberAccessException">El llamador no tiene acceso al método representado por el delegado (por ejemplo, si el método es privado).</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Cuando se invoca en tiempo de ejecución a través de mecanismos como <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Enumeración asociada: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="T:System.Reflection.MethodInfo" />
        <altmember cref="P:System.Delegate.Method" />
      </Docs>
    </Member>
    <Member MemberName="GetObjectData">
      <MemberSignature Language="C#" Value="public virtual void GetObjectData (System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void GetObjectData(class System.Runtime.Serialization.SerializationInfo info, valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub GetObjectData (info As SerializationInfo, context As StreamingContext)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void GetObjectData(System::Runtime::Serialization::SerializationInfo ^ info, System::Runtime::Serialization::StreamingContext context);" />
      <MemberSignature Language="F#" Value="abstract member GetObjectData : System.Runtime.Serialization.SerializationInfo * System.Runtime.Serialization.StreamingContext -&gt; unit&#xA;override this.GetObjectData : System.Runtime.Serialization.SerializationInfo * System.Runtime.Serialization.StreamingContext -&gt; unit" Usage="delegate.GetObjectData (info, context)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="info" Type="System.Runtime.Serialization.SerializationInfo" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="info">No se admite.</param>
        <param name="context">No se admite.</param>
        <summary>No se admite.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.NotSupportedException">No se admite este método.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requiere plena confianza para el llamador inmediato. Este miembro no se puede usar código de confianza parcial o transparente.</permission>
        <altmember cref="T:System.Runtime.Serialization.ISerializable" />
        <altmember cref="T:System.Runtime.Serialization.SerializationInfo" />
        <altmember cref="T:System.Runtime.Serialization.StreamingContext" />
      </Docs>
    </Member>
    <Member MemberName="Method">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo Method { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.MethodInfo Method" />
      <MemberSignature Language="DocId" Value="P:System.Delegate.Method" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Method As MethodInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Reflection::MethodInfo ^ Method { System::Reflection::MethodInfo ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Method : System.Reflection.MethodInfo" Usage="System.Delegate.Method" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene el método representado por el delegado.</summary>
        <value><see cref="T:System.Reflection.MethodInfo" /> que describe el método representado por el delegado.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.MemberAccessException">El llamador no tiene acceso al método representado por el delegado (por ejemplo, si el método es privado).</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Cuando se invoca en tiempo de ejecución a través de mecanismos como <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Enumeración asociada: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="T:System.Reflection.MethodInfo" />
        <altmember cref="M:System.Delegate.GetMethodImpl" />
      </Docs>
    </Member>
    <Member MemberName="op_Equality">
      <MemberSignature Language="C#" Value="public static bool operator == (Delegate d1, Delegate d2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Equality(class System.Delegate d1, class System.Delegate d2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.op_Equality(System.Delegate,System.Delegate)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator == (d1 As Delegate, d2 As Delegate) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator ==(Delegate ^ d1, Delegate ^ d2);" />
      <MemberSignature Language="F#" Value="static member ( = ) : Delegate * Delegate -&gt; bool" Usage="d1 = d2" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d1" Type="System.Delegate" />
        <Parameter Name="d2" Type="System.Delegate" />
      </Parameters>
      <Docs>
        <param name="d1">Primer delegado que se va a comparar.</param>
        <param name="d2">Segundo delegado que se va a comparar.</param>
        <summary>Determina si los delegados especificados son iguales.</summary>
        <returns><see langword="true" /> si <paramref name="d1" /> es igual a <paramref name="d2" />; en caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dos delegados del mismo tipo con los mismos destinos, métodos y listas de invocaciones se consideran iguales.  
  
 Si los dos delegados no son del mismo tipo, no se consideran iguales.  
  
> [!IMPORTANT]
>  En la versión 1.0 y 1.1 de .NET Framework, dos delegados se consideran iguales si sus destinos, métodos y listas de invocaciones eran iguales, aunque los delegados sean de tipos diferentes.  
  
 Los métodos y los destinos se comparan la igualdad como sigue:  
  
-   Si los dos métodos que se están comparados ambos son estáticos y el mismo método en la misma clase, los métodos se consideran iguales y los destinos también se consideran iguales.  
  
-   Si los dos métodos que se comparan son métodos de instancia y el mismo método en el mismo objeto, los métodos se consideran iguales y los destinos también se consideran iguales.  
  
-   En caso contrario, los métodos no se consideran iguales y los destinos no también se consideran iguales.  
  
 Dos listas de invocaciones se consideran idénticas si tienen el mismo orden y los elementos correspondientes de las dos listas representan el mismo método y destino.  
  
 Es el método equivalente para este operador <xref:System.Delegate.Equals%28System.Object%29?displayProperty=nameWithType>]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Cuando se invoca en tiempo de ejecución a través de mecanismos como <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Enumeración asociada: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="M:System.Delegate.Equals(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="op_Inequality">
      <MemberSignature Language="C#" Value="public static bool operator != (Delegate d1, Delegate d2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Inequality(class System.Delegate d1, class System.Delegate d2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.op_Inequality(System.Delegate,System.Delegate)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator != (d1 As Delegate, d2 As Delegate) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator !=(Delegate ^ d1, Delegate ^ d2);" />
      <MemberSignature Language="F#" Value="static member op_Inequality : Delegate * Delegate -&gt; bool" Usage="System.Delegate.op_Inequality (d1, d2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d1" Type="System.Delegate" />
        <Parameter Name="d2" Type="System.Delegate" />
      </Parameters>
      <Docs>
        <param name="d1">Primer delegado que se va a comparar.</param>
        <param name="d2">Segundo delegado que se va a comparar.</param>
        <summary>Determina si los delegados especificados no son iguales.</summary>
        <returns>Es <see langword="true" /> si <paramref name="d1" /> no es igual a <paramref name="d2" />; en caso contrario, es <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dos delegados se consideran iguales si son de tipos diferentes, o tienen métodos distintos, destinos distintos o listas de invocaciones diferentes.  
  
 Si los dos delegados no son del mismo tipo, no se consideran iguales.  
  
> [!IMPORTANT]
>  En la versión 1.0 y 1.1 de .NET Framework, dos delegados se consideran iguales si sus destinos, métodos y listas de invocaciones eran iguales, aunque los delegados sean de tipos diferentes.  
  
 Los métodos y los destinos se comparan la igualdad como sigue:  
  
-   Si los dos métodos que se están comparados ambos son estáticos y el mismo método en la misma clase, los métodos se consideran iguales y los destinos también se consideran iguales.  
  
-   Si los dos métodos que se comparan son métodos de instancia y el mismo método en el mismo objeto, los métodos se consideran iguales y los destinos también se consideran iguales.  
  
-   En caso contrario, los métodos no se consideran iguales y los destinos no también se consideran iguales.  
  
 Dos listas de invocación no son iguales si tienen tamaños diferentes, si se ordenan de forma diferente, o si al menos un elemento de una lista representa un método o destino diferente del representado por su elemento correspondiente en la lista de otros.  
  
 Es el método equivalente para este operador <xref:System.Delegate.Equals%28System.Object%29?displayProperty=nameWithType>]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Cuando se invoca en tiempo de ejecución a través de mecanismos como <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Enumeración asociada: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="M:System.Delegate.Equals(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Remove">
      <MemberSignature Language="C#" Value="public static Delegate Remove (Delegate source, Delegate value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Delegate Remove(class System.Delegate source, class System.Delegate value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.Remove(System.Delegate,System.Delegate)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Remove (source As Delegate, value As Delegate) As Delegate" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Delegate ^ Remove(Delegate ^ source, Delegate ^ value);" />
      <MemberSignature Language="F#" Value="static member Remove : Delegate * Delegate -&gt; Delegate" Usage="System.Delegate.Remove (source, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Delegate" />
        <Parameter Name="value" Type="System.Delegate" />
      </Parameters>
      <Docs>
        <param name="source">Delegado del que se va a quitar la lista de invocaciones de <paramref name="value" />.</param>
        <param name="value">Delegado que proporciona la lista de invocaciones que se va a quitar de la lista de invocaciones de <paramref name="source" />.</param>
        <summary>Quita la última aparición de la lista de invocaciones de un delegado de la lista de invocaciones de otro delegado.</summary>
        <returns>Nuevo delegado con una lista de invocaciones creada tomando la lista de invocaciones de <paramref name="source" /> y quitando la última aparición de la lista de invocaciones de <paramref name="value" />, si la lista de invocaciones de <paramref name="value" /> se encuentra dentro de la lista de invocaciones de <paramref name="source" />. Devuelve <paramref name="source" /> si <paramref name="value" /> es <see langword="null" /> o si la lista de invocaciones de <paramref name="value" /> no se encuentra dentro de la lista de invocaciones de <paramref name="source" />. Devuelve una referencia nula si la lista de invocaciones de <paramref name="value" /> es igual a la lista de invocaciones de <paramref name="source" /> o si <paramref name="source" /> es una referencia nula.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si la lista de invocaciones `value` coincide con un conjunto contiguo de elementos de la lista de invocaciones `source`, a continuación, la lista de invocaciones `value` se dice que se producen dentro de la lista de invocaciones `source`. Si la lista de invocaciones `value` aparece más de una vez en la lista de invocaciones `source`, se quita la última aparición.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.MemberAccessException">El llamador no tiene acceso al método representado por el delegado (por ejemplo, si el método es privado).</exception>
        <exception cref="T:System.ArgumentException">Los tipos de delegado no coinciden.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Cuando se invoca en tiempo de ejecución a través de mecanismos como <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Enumeración asociada: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="M:System.Delegate.RemoveAll(System.Delegate,System.Delegate)" />
        <altmember cref="M:System.Delegate.RemoveImpl(System.Delegate)" />
        <altmember cref="M:System.Delegate.Equals(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="RemoveAll">
      <MemberSignature Language="C#" Value="public static Delegate RemoveAll (Delegate source, Delegate value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Delegate RemoveAll(class System.Delegate source, class System.Delegate value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.RemoveAll(System.Delegate,System.Delegate)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function RemoveAll (source As Delegate, value As Delegate) As Delegate" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Delegate ^ RemoveAll(Delegate ^ source, Delegate ^ value);" />
      <MemberSignature Language="F#" Value="static member RemoveAll : Delegate * Delegate -&gt; Delegate" Usage="System.Delegate.RemoveAll (source, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Delegate" />
        <Parameter Name="value" Type="System.Delegate" />
      </Parameters>
      <Docs>
        <param name="source">Delegado del que se va a quitar la lista de invocaciones de <paramref name="value" />.</param>
        <param name="value">Delegado que proporciona la lista de invocaciones que se va a quitar de la lista de invocaciones de <paramref name="source" />.</param>
        <summary>Quita todas las apariciones de la lista de invocaciones de un delegado de la lista de invocaciones de otro delegado.</summary>
        <returns>Nuevo delegado con una lista de invocaciones creada tomando la lista de invocaciones de <paramref name="source" /> y quitando todas las apariciones de la lista de invocaciones de <paramref name="value" />, si la lista de invocaciones de <paramref name="value" /> se encuentra dentro de la lista de invocaciones de <paramref name="source" />. Devuelve <paramref name="source" /> si <paramref name="value" /> es <see langword="null" /> o si la lista de invocaciones de <paramref name="value" /> no se encuentra dentro de la lista de invocaciones de <paramref name="source" />. Devuelve una referencia nula si la lista de invocaciones de <paramref name="value" /> es igual a la de <paramref name="source" />, si <paramref name="source" /> contiene sólo una serie de listas de invocaciones que son iguales a la lista de invocaciones de <paramref name="value" />, o bien si <paramref name="source" /> es una referencia nula.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si la lista de invocaciones `value` coincide con un conjunto contiguo de elementos de la lista de invocaciones `source`, a continuación, la lista de invocaciones `value` se dice que se producen dentro de la lista de invocaciones `source`. Si la lista de invocaciones `value` aparece más de una vez en la lista de invocaciones `source`, se quitan todas las apariciones.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.MemberAccessException">El llamador no tiene acceso al método representado por el delegado (por ejemplo, si el método es privado).</exception>
        <exception cref="T:System.ArgumentException">Los tipos de delegado no coinciden.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Cuando se invoca en tiempo de ejecución a través de mecanismos como <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Enumeración asociada: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="M:System.Delegate.Remove(System.Delegate,System.Delegate)" />
        <altmember cref="M:System.Delegate.RemoveImpl(System.Delegate)" />
        <altmember cref="M:System.Delegate.Equals(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="RemoveImpl">
      <MemberSignature Language="C#" Value="protected virtual Delegate RemoveImpl (Delegate d);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Delegate RemoveImpl(class System.Delegate d) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.RemoveImpl(System.Delegate)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function RemoveImpl (d As Delegate) As Delegate" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual Delegate ^ RemoveImpl(Delegate ^ d);" />
      <MemberSignature Language="F#" Value="abstract member RemoveImpl : Delegate -&gt; Delegate&#xA;override this.RemoveImpl : Delegate -&gt; Delegate" Usage="delegate.RemoveImpl d" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d" Type="System.Delegate" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="d">Delegado que proporciona la lista de invocaciones que se va a quitar de la lista de invocaciones del delegado actual.</param>
        <summary>Quita la lista de invocaciones de un delegado de la lista de invocaciones de otro delegado.</summary>
        <returns>Nuevo delegado con una lista de invocaciones creada tomando la lista de invocaciones del delegado actual y quitando la lista de invocaciones de <paramref name="value" />, si la lista de invocaciones de <paramref name="value" /> se encuentra dentro de la lista de invocaciones del delegado actual. Devuelve el delegado actual si <paramref name="value" /> es <see langword="null" /> o si la lista de invocaciones de <paramref name="value" /> no se encuentra en la lista de invocaciones del delegado actual. Devuelve <see langword="null" /> si la lista de invocaciones de <paramref name="value" /> es igual que la lista de invocaciones del delegado actual.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si la lista de invocaciones `value` coincide con un conjunto contiguo de elementos de lista de invocaciones del delegado actual y, después, en la lista de invocaciones `value` se dice que se producen dentro de la lista de invocaciones del delegado actual. Si la lista de invocaciones `value` aparece varias veces en la lista de invocaciones del delegado actual, se quita la última aparición.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.MemberAccessException">El llamador no tiene acceso al método representado por el delegado (por ejemplo, si el método es privado).</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Cuando se invoca en tiempo de ejecución a través de mecanismos como <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Enumeración asociada: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="M:System.Delegate.Remove(System.Delegate,System.Delegate)" />
        <altmember cref="M:System.Delegate.Equals(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Target">
      <MemberSignature Language="C#" Value="public object Target { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object Target" />
      <MemberSignature Language="DocId" Value="P:System.Delegate.Target" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Target As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ Target { System::Object ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Target : obj" Usage="System.Delegate.Target" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene la instancia de clase donde el delegado actual invoca al método de instancia.</summary>
        <value>Objeto en el que el delegado actual invoca al método de instancia, en el caso de que el delegado represente un método de instancia; <see langword="null" /> si el delegado representa un método estático.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un método de instancia es un método que está asociado a una instancia de una clase. un método estático es un método que está asociado a la propia clase.  
  
 Si el delegado invoca a uno o varios métodos de instancia, esta propiedad devuelve el destino de este último método de instancia en la lista de invocación.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Cuando se invoca en tiempo de ejecución a través de mecanismos como <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Enumeración asociada: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
      </Docs>
    </Member>
  </Members>
</Type>