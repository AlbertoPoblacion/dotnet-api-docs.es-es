<Type Name="MarshalByRefObject" FullName="System.MarshalByRefObject">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="581d775aac81241d975e88cf7c586e38dbe64827" />
    <Meta Name="ms.sourcegitcommit" Value="6a0b904069161bbaec4ffd02aa7d9cf38c61e72e" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="es-ES" />
    <Meta Name="ms.lasthandoff" Value="06/24/2018" />
    <Meta Name="ms.locfileid" Value="36430089" />
  </Metadata>
  <TypeSignature Language="C#" Value="public abstract class MarshalByRefObject" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi abstract serializable beforefieldinit MarshalByRefObject extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.MarshalByRefObject" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class MarshalByRefObject" />
  <TypeSignature Language="C++ CLI" Value="public ref class MarshalByRefObject abstract" />
  <TypeSignature Language="F#" Value="type MarshalByRefObject = class" />
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Permite obtener acceso a objetos a través de los límites de los dominios de las aplicaciones que admiten la comunicación remota.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un dominio de aplicación es una partición en un proceso de sistema operativo que residen una o varias aplicaciones. Objetos en el mismo dominio de aplicación se comunican directamente. Objetos en distintos dominios de aplicación se comunican mediante el transporte de copias de los objetos en los límites del dominio de aplicación, o mediante un proxy para intercambiar mensajes.  
  
 <xref:System.MarshalByRefObject> es la clase base para los objetos que se comunican a través de los límites del dominio de aplicación mediante el intercambio de mensajes mediante un servidor proxy. Objetos que no heredan de <xref:System.MarshalByRefObject> son implícitamente calcular las referencias por valor. Cuando una aplicación remota hace referencia a un cálculo de referencias al objeto de valor, una copia del objeto se pasa a través de los límites del dominio de aplicación.  
  
 <xref:System.MarshalByRefObject> se tiene acceso a objetos directamente dentro de los límites del dominio de aplicación local. Dominio de aplicación de la primera vez que una aplicación en un equipo remoto tiene acceso a un <xref:System.MarshalByRefObject>, se pasa un proxy a la aplicación remota. Las llamadas subsiguientes en el servidor proxy se calculan las referencias al objeto que reside en el dominio de aplicación local.  
  
 Los tipos deben heredar de <xref:System.MarshalByRefObject> cuando el tipo se utiliza en los límites del dominio de aplicación y no se debe copiar el estado del objeto porque los miembros del objeto no se puede usar fuera del dominio de aplicación donde se crearon.  
  
 Al derivar un objeto de <xref:System.MarshalByRefObject> para su uso en los límites del dominio de aplicación, no se debe reemplazar cualquiera de sus miembros, así como tampoco debe llamar a sus métodos directamente. El tiempo de ejecución reconoce que las clases derivadas de <xref:System.MarshalByRefObject> debe calcularse en los límites del dominio de aplicación.  
  
   
  
## Examples  
 Esta sección contiene dos ejemplos de código. El primer ejemplo de código muestra cómo crear una instancia de una clase en otro dominio de aplicación. El segundo ejemplo de código muestra una clase simple que se puede usar para la comunicación remota.  
  
 **Ejemplo 1**  
  
 En el ejemplo de código siguiente se muestra la manera más sencilla de ejecutar el código en otro dominio de aplicación. En el ejemplo se define una clase denominada `Worker` que herede <xref:System.MarshalByRefObject>, con un método que muestra el nombre del dominio de aplicación en el que está ejecutando. El ejemplo crea instancias de `Worker` en el dominio de aplicación predeterminado y en un nuevo dominio de aplicación.  
  
> [!NOTE]
>  El ensamblado que contiene `Worker` se deben cargar en ambos dominios de aplicación, pero ha pudieron cargar otros ensamblados que existieran solo en el nuevo dominio de aplicación.  
  
 [!code-cpp[CreateInstanceAndUnwrap2#1](~/samples/snippets/cpp/VS_Snippets_CLR/CreateInstanceAndUnwrap2/cpp/source.cpp#1)]
 [!code-csharp[CreateInstanceAndUnwrap2#1](~/samples/snippets/csharp/VS_Snippets_CLR/CreateInstanceAndUnwrap2/cs/source.cs#1)]
 [!code-vb[CreateInstanceAndUnwrap2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/CreateInstanceAndUnwrap2/VB/source.vb#1)]  
  
 **Ejemplo 2**  
  
 En el ejemplo siguiente se muestra una clase derivada de <xref:System.MarshalByRefObject> que es usado más adelante en remoting.  
  
 [!code-cpp[RemotingServices.SetObjectUriForMarshal#1](~/samples/snippets/cpp/VS_Snippets_CLR/RemotingServices.SetObjectUriForMarshal/CPP/source.cpp#1)]
 [!code-csharp[RemotingServices.SetObjectUriForMarshal#1](~/samples/snippets/csharp/VS_Snippets_CLR/RemotingServices.SetObjectUriForMarshal/CS/source.cs#1)]
 [!code-vb[RemotingServices.SetObjectUriForMarshal#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/RemotingServices.SetObjectUriForMarshal/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected MarshalByRefObject ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MarshalByRefObject.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; MarshalByRefObject();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.MarshalByRefObject" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateObjRef">
      <MemberSignature Language="C#" Value="public virtual System.Runtime.Remoting.ObjRef CreateObjRef (Type requestedType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Runtime.Remoting.ObjRef CreateObjRef(class System.Type requestedType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MarshalByRefObject.CreateObjRef(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function CreateObjRef (requestedType As Type) As ObjRef" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Runtime::Remoting::ObjRef ^ CreateObjRef(Type ^ requestedType);" />
      <MemberSignature Language="F#" Value="abstract member CreateObjRef : Type -&gt; System.Runtime.Remoting.ObjRef&#xA;override this.CreateObjRef : Type -&gt; System.Runtime.Remoting.ObjRef" Usage="marshalByRefObject.CreateObjRef requestedType" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjRef</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="requestedType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="requestedType">
          <see cref="T:System.Type" /> del objeto al que hará referencia el nuevo <see cref="T:System.Runtime.Remoting.ObjRef" />.</param>
        <summary>Crea un objeto que contiene toda la información relevante necesaria para generar un proxy utilizado para comunicarse con un objeto remoto.</summary>
        <returns>Información necesaria para generar un proxy.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.MarshalByRefObject.CreateObjRef%2A> método llama a métodos de creación del objeto remoto como <xref:System.AppDomain.CreateInstance%2A?displayProperty=nameWithType> y <xref:System.AppDomain.CreateInstanceAndUnwrap%2A?displayProperty=nameWithType>. En la mayoría de los casos, no hay ninguna necesidad de invalidar este método.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Runtime.Remoting.RemotingException">Esta instancia no es un objeto de comunicación remota válido.</exception>
        <exception cref="T:System.Security.SecurityException">El llamador inmediato no tiene permisos de infraestructura.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Requiere plena confianza para el llamador inmediato. Este miembro no puede usarse por código de confianza parcial o transparente.</permission>
      </Docs>
    </Member>
    <Member MemberName="GetLifetimeService">
      <MemberSignature Language="C#" Value="public object GetLifetimeService ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object GetLifetimeService() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MarshalByRefObject.GetLifetimeService" />
      <MemberSignature Language="VB.NET" Value="Public Function GetLifetimeService () As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ GetLifetimeService();" />
      <MemberSignature Language="F#" Value="abstract member GetLifetimeService : unit -&gt; obj&#xA;override this.GetLifetimeService : unit -&gt; obj" Usage="marshalByRefObject.GetLifetimeService " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Recupera el objeto de servicio de duración actual que controla la directiva de duración de esta instancia.</summary>
        <returns>Objeto de tipo <see cref="T:System.Runtime.Remoting.Lifetime.ILease" /> utilizado para controlar la directiva de duración de esta instancia.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para obtener más información acerca de los servicios de duración, consulte la <xref:System.Runtime.Remoting.Lifetime.LifetimeServices> clase.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">El llamador inmediato no tiene permisos de infraestructura.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Requiere plena confianza para el llamador inmediato. Este miembro no puede usarse por código de confianza parcial o transparente.</permission>
      </Docs>
    </Member>
    <Member MemberName="InitializeLifetimeService">
      <MemberSignature Language="C#" Value="public virtual object InitializeLifetimeService ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object InitializeLifetimeService() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MarshalByRefObject.InitializeLifetimeService" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function InitializeLifetimeService () As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ InitializeLifetimeService();" />
      <MemberSignature Language="F#" Value="abstract member InitializeLifetimeService : unit -&gt; obj&#xA;override this.InitializeLifetimeService : unit -&gt; obj" Usage="marshalByRefObject.InitializeLifetimeService " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Obtiene un objeto de servicio de duración para controlar la directiva de duración de esta instancia.</summary>
        <returns>Objeto de tipo <see cref="T:System.Runtime.Remoting.Lifetime.ILease" /> utilizado para controlar la directiva de duración de esta instancia. Éste es el objeto de servicio de duración actual de esta instancia si existe una; en caso contrario, un nuevo objeto de servicio de duración inicializado en el valor de la propiedad <see cref="P:System.Runtime.Remoting.Lifetime.LifetimeServices.LeaseManagerPollTime" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para obtener más información acerca de los servicios de duración, consulte la <xref:System.Runtime.Remoting.Lifetime.LifetimeServices> clase.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra cómo crear una concesión.  
  
 [!code-cpp[Classic MarshalByRefObject.InitializeLifetimeService Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic MarshalByRefObject.InitializeLifetimeService Example/CPP/source.cpp#1)]
 [!code-csharp[Classic MarshalByRefObject.InitializeLifetimeService Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic MarshalByRefObject.InitializeLifetimeService Example/CS/source.cs#1)]
 [!code-vb[Classic MarshalByRefObject.InitializeLifetimeService Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic MarshalByRefObject.InitializeLifetimeService Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">El llamador inmediato no tiene permisos de infraestructura.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Requiere plena confianza para el llamador inmediato. Este miembro no puede usarse por código de confianza parcial o transparente.</permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="MemberwiseClone">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Crea una copia superficial del objeto actual.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="MemberwiseClone">
      <MemberSignature Language="C#" Value="protected MarshalByRefObject MemberwiseClone (bool cloneIdentity);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance class System.MarshalByRefObject MemberwiseClone(bool cloneIdentity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MarshalByRefObject.MemberwiseClone(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Function MemberwiseClone (cloneIdentity As Boolean) As MarshalByRefObject" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; MarshalByRefObject ^ MemberwiseClone(bool cloneIdentity);" />
      <MemberSignature Language="F#" Value="override this.MemberwiseClone : bool -&gt; MarshalByRefObject" Usage="marshalByRefObject.MemberwiseClone cloneIdentity" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.MarshalByRefObject</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="cloneIdentity" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="cloneIdentity">
          <see langword="false" /> para eliminar la identidad actual del objeto <see cref="T:System.MarshalByRefObject" />, que provocará la asignación de una nueva identidad al objeto cuando se calculan sus referencias a través de un límite de comunicación remota. El valor <see langword="false" /> suele ser el adecuado. Es <see langword="true" /> para copiar la identidad actual del objeto <see cref="T:System.MarshalByRefObject" /> en su copia, que hará que las llamadas del cliente de comunicación remota se enruten al objeto del servidor remoto.</param>
        <summary>Crea una copia superficial del objeto <see cref="T:System.MarshalByRefObject" /> actual.</summary>
        <returns>Copia superficial del objeto <see cref="T:System.MarshalByRefObject" /> actual.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.MarshalByRefObject.MemberwiseClone%28System.Boolean%29> método crea una copia superficial mediante la creación de un nuevo <xref:System.MarshalByRefObject> objeto y, a continuación, copiar los campos no estáticos del elemento actual <xref:System.MarshalByRefObject> objeto en el nuevo objeto. Si un campo es un tipo de valor, se realiza una copia bit a bit del campo. Si un campo es un tipo de referencia, la referencia se copia, pero el objeto que se hace referencia es no; por lo tanto, el objeto original y su clon hacen referencia al mismo objeto.  
  
 Por ejemplo, considere un <xref:System.MarshalByRefObject> objeto denominado X que hace referencia a objetos A y B. el objeto B, a su vez, hace referencia a objeto C. Una copia superficial de X crea nuevo objeto X2 que también hace referencia a objetos A y B. En contraste, una copia en profundidad de X crea un nuevo objeto X2 que hace referencia a los nuevos objetos A2 y B2, que son copias de A y B. B2, a su vez, hace referencia al nuevo objeto C2, que es una copia C. utilizar una clase que implementa el <xref:System.ICloneable> interfaz para realizar una profunda o superficial c copiar de un objeto.  
  
 La identidad de un <xref:System.MarshalByRefObject> objeto se define como el objeto de servidor remoto que es el destino de una llamada del cliente remoto. De forma predeterminada, el clon miembro a miembro de un <xref:System.MarshalByRefObject> objeto tiene la misma identidad que el objeto original, que no suele ser el comportamiento correcto para clones de objetos del lado servidor que se serializan en un límite de comunicación remota para el lado del cliente. Especifique `false`, que normalmente es adecuado, para eliminar la identidad de la clonación y provocar una nueva identidad que se asignará cuando se serializa el clon a través de un límite de comunicación remota, o `true` para hacer que el clon conservar la identidad del original <xref:System.MarshalByRefObject> objeto. El <xref:System.MarshalByRefObject.MemberwiseClone%28System.Boolean%29> método está pensado para usarse por los desarrolladores que implementan objetos del servidor remoto.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>