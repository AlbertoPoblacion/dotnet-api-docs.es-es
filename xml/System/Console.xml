<Type Name="Console" FullName="System.Console">
  <Metadata><Meta Name="ms.openlocfilehash" Value="1e0cfe8c8256881b084e78ae928c00c2f577f253" /><Meta Name="ms.sourcegitcommit" Value="8e213bb5e6801f6e29861ba72664978ad00e34fa" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="es-ES" /><Meta Name="ms.lasthandoff" Value="02/18/2019" /><Meta Name="ms.locfileid" Value="56376100" /></Metadata><TypeSignature Language="C#" Value="public static class Console" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract sealed Console extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Console" />
  <TypeSignature Language="VB.NET" Value="Public Class Console" />
  <TypeSignature Language="C++ CLI" Value="public ref class Console abstract sealed" />
  <TypeSignature Language="F#" Value="type Console = class" />
  <AssemblyInfo>
    <AssemblyName>System.Console</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Representa los flujos de entrada, salida y error estándar para las aplicaciones de consola. Esta clase no puede heredarse.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La consola es una ventana del sistema operativo donde los usuarios interactúan con el sistema operativo o con una aplicación de consola basada en texto mediante la especificación de entrada de texto mediante el teclado del equipo y leyendo el texto de salida del terminal del equipo. Por ejemplo, en el sistema operativo Windows, la consola se llama a la ventana de símbolo del sistema y acepta comandos de MS-DOS. El <xref:System.Console> proporciona compatibilidad básica para las aplicaciones que leen caracteres de y escriben caracteres en la consola.  
  
 Para obtener información sobre el desarrollo con el <xref:System.Console> de clases, vea las secciones siguientes:  
  
-   [Secuencias de E/S de consola](#Streams)  
  
-   [Búfer de pantalla y ventana de consola](#Buffer)  
  
-   [Compatibilidad con Unicode para la consola](#Unicode)  
  
-   [Operaciones comunes](#Operations)  
  
-   [Notas de la de .NET core](#Core)  
  
<a name="Streams"></a>   
## <a name="console-io-streams"></a>Secuencias de E/S de consola  
 Cuando se inicia una aplicación de consola, el sistema operativo asocia automáticamente tres secuencias de E/S a la consola: estándar de entrada de flujo, flujo de salida estándar y la secuencia de salida de error estándar. La aplicación puede leer la entrada del usuario del flujo de entrada estándar; escribir datos normales en el flujo de salida estándar; y escribir datos de error en el flujo de salida de error estándar. Estas secuencias se presentan a la aplicación como los valores de la <xref:System.Console.In%2A?displayProperty=nameWithType>, <xref:System.Console.Out%2A?displayProperty=nameWithType>, y <xref:System.Console.Error%2A?displayProperty=nameWithType> propiedades.  
  
 De forma predeterminada, el valor de la <xref:System.Console.In%2A> propiedad es un <xref:System.IO.TextReader?displayProperty=nameWithType> objeto que representa el teclado y los valores de la <xref:System.Console.Out%2A> y <xref:System.Console.Error%2A> propiedades son <xref:System.IO.TextWriter?displayProperty=nameWithType> objetos que representan una ventana de consola. Sin embargo, puede establecer estas propiedades en secuencias que no representan la ventana de consola o el teclado; Por ejemplo, puede establecer estas propiedades en secuencias que representan archivos. Para redirigir la entrada estándar, la salida estándar o la secuencia de error estándar, llame a la <xref:System.Console.SetIn%2A?displayProperty=nameWithType>, <xref:System.Console.SetOut%2A?displayProperty=nameWithType>, o <xref:System.Console.SetError%2A?displayProperty=nameWithType> método, respectivamente. Las operaciones de E/S que utilizan estas secuencias están sincronizadas, lo que significa que varios subprocesos pueden leer o escribir en los flujos. Esto significa que los métodos que son normalmente asincrónicos, como <xref:System.IO.TextReader.ReadLineAsync%2A?displayProperty=nameWithType>, ejecutan de forma sincrónica si el objeto representa una secuencia de la consola.  
  
> [!NOTE]
>  No use la <xref:System.Console> clase para mostrar el resultado en aplicaciones desatendidas, por ejemplo, las aplicaciones de servidor. Las llamadas a métodos como <xref:System.Console.Write%2A?displayProperty=nameWithType> y <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> no tienen ningún efecto en las aplicaciones GUI.  
  
 <xref:System.Console> los miembros de clase que funcionan normalmente cuando la secuencia subyacente se dirige a una consola podrían producir una excepción si se redirige la secuencia, por ejemplo, en un archivo. Programar la aplicación para detectar <xref:System.IO.IOException?displayProperty=nameWithType> excepciones si se redirige a un flujo estándar. También puede usar el <xref:System.Console.IsOutputRedirected%2A>, <xref:System.Console.IsInputRedirected%2A>, y <xref:System.Console.IsErrorRedirected%2A> propiedades para determinar si se redirige una secuencia estándar antes de realizar una operación que inicia un <xref:System.IO.IOException?displayProperty=nameWithType> excepción.  
  
 A veces resulta útil llamar explícitamente a los miembros de los objetos de secuencia representados por la <xref:System.Console.In%2A>, <xref:System.Console.Out%2A>, y <xref:System.Console.Error%2A> propiedades. Por ejemplo, de forma predeterminada, el <xref:System.Console.ReadLine%2A?displayProperty=nameWithType> método lee la entrada del flujo de entrada estándar. De forma similar, la <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> método escribe datos en el flujo de salida estándar y los datos seguidos de la cadena de terminación de línea predeterminado, que es un retorno de carro y avance de línea ("\r\n"). Sin embargo, la <xref:System.Console> clase no proporciona un método correspondiente para escribir datos en el flujo de salida de error estándar, o una propiedad para cambiar la cadena de terminación de línea de los datos escritos en esa secuencia.  
  
 Puede resolver este problema estableciendo la <xref:System.IO.TextWriter.NewLine%2A?displayProperty=nameWithType> propiedad de la <xref:System.Console.Out%2A> o <xref:System.Console.Error%2A> propiedad por otra cadena de terminación de línea. Por ejemplo, la instrucción de C# siguiente establece la cadena de terminación de línea para el flujo de salida de error estándar a dos retorno de carro y avance de las secuencias de línea:  
  
 `Console.Error.NewLine = "\r\n\r\n";`  
  
 A continuación, se puede llamar explícitamente la <xref:System.IO.TextWriter.WriteLine%2A> método para el objeto de flujo de salida de error, como se muestra en la siguiente instrucción de C#:  
  
 `Console.Error.WriteLine();`  
  
<a name="Buffer"></a>   
## <a name="screen-buffer-and-console-window"></a>Búfer de pantalla y ventana de consola  
 Dos características estrechamente relacionadas de la consola son el búfer de pantalla y la ventana de consola. Texto realmente se leen o escriben en secuencias que pertenecen a la consola, pero parece que se leen o escriben en un área que pertenecen a la consola denominado el búfer de pantalla. El búfer de pantalla es un atributo de la consola y se organiza como una cuadrícula rectangular de filas y columnas, donde cada intersección de la cuadrícula o celda de carácter, puede contener un carácter. Cada carácter tiene su propio color de primer plano y cada celda de carácter tiene su propio color de fondo.  
  
 El búfer de pantalla se ve a través de una región rectangular que se llama a la ventana de consola. La ventana de consola es otro atributo de la consola; no es la propia consola, que es una ventana del sistema operativo. La ventana de consola se organiza en filas y columnas, es menor o igual que el tamaño del búfer de pantalla y se puede mover para ver las diferentes áreas del búfer de pantalla subyacente. Si el búfer de pantalla es mayor que la ventana de consola, la consola muestra automáticamente barras de desplazamiento, por lo que se puede mover la ventana de consola en el área del búfer de pantalla.  
  
 Un cursor indica la posición del búfer de pantalla donde texto se leen o escriben actualmente. El cursor se puede ocultar o hacerse visible, y se puede cambiar su altura. Si el cursor está visible, la posición de la ventana de consola se mueve automáticamente para que el cursor está siempre en la vista.  
  
 El origen de las coordenadas de celda de carácter en el búfer de pantalla es la esquina superior izquierda y las posiciones del cursor y la ventana de consola se miden en relación con ese origen. Usar índices de base cero para indicar las posiciones; es decir, especifique la fila superior como la fila 0 y la columna más a la izquierda como columna 0. Es el valor máximo para los índices de fila y columna <xref:System.Int16.MaxValue?displayProperty=nameWithType>.  
  
<a name="Unicode"></a>   
## <a name="unicode-support-for-the-console"></a>Compatibilidad con Unicode para la consola  
 En general, la consola lee la entrada y escribe la salida mediante el uso de la página de códigos de consola actual, que define la configuración regional del sistema de forma predeterminada. Una página de códigos puede controlar sólo un subconjunto de caracteres Unicode disponibles, por lo que si intenta mostrar caracteres que no están asignados mediante una página de códigos determinada, la consola no pueden mostrar todos los caracteres o representarlos con precisión. El siguiente ejemplo ilustra este problema. Intenta mostrar los caracteres del alfabeto cirílico desde U + 0410 a 044F U + en la consola. Si ejecuta el ejemplo en un sistema que usa la página de códigos 437, cada carácter se sustituye por un signo de interrogación (?), como caracteres cirílicos no se asignan a los caracteres de la página de códigos 437.  
  
 [!code-csharp[System.Console.Class#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.console.class/cs/unicode1.cs#1)]
 [!code-vb[System.Console.Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.console.class/vb/unicode1.vb#1)]  
  
 Además de admitir las páginas de códigos, la <xref:System.Console> clase admite la codificación con UTF-8 el <xref:System.Text.UTF8Encoding> clase. A partir de .NET Framework 4.5, el <xref:System.Console> clase también admite la codificación con UTF-16 el <xref:System.Text.UnicodeEncoding> clase. Para mostrar caracteres Unicode en la consola. establece el <xref:System.Console.OutputEncoding%2A> propiedad como <xref:System.Text.UTF8Encoding> o <xref:System.Text.UnicodeEncoding>.  
  
 Compatibilidad con caracteres Unicode requiere que el codificador para que reconozca un carácter Unicode concreto y también requiere una fuente que contiene los glifos que se necesitan para representar ese carácter. Para mostrar correctamente los caracteres Unicode en la consola, la fuente de consola debe establecerse en una no trama o fuente TrueType como Lucida Console o de Consolas. El ejemplo siguiente muestra cómo se puede cambiar mediante programación la fuente de una fuente de mapa de bits Lucida Console.  
  
 [!code-csharp[System.Console.Class.Unsafe#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.console.class.unsafe/cs/setfont1.cs#3)]
 [!code-vb[System.Console.Class.Unsafe#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.console.class.unsafe/vb/setfont1.vb#3)]  
  
 Sin embargo, las fuentes TrueType pueden mostrar solo un subconjunto de los glifos. Por ejemplo, la fuente Lucida Console muestra sólo 643 de los aproximadamente 64.000 caracteres disponibles desde u+0021 a FB02 + U. Para ver una fuente concreta los caracteres que admite, abra el **fuentes** applet del Panel de Control, elija la **buscar un carácter** opción y elija la fuente cuyo conjunto de caracteres desea examinar en el  **Fuente** lista de los **mapa de caracteres** ventana.  
  
 Windows usa la vinculación de fuentes para mostrar glifos que no están disponibles en una fuente concreta. Para obtener información sobre la vinculación de fuentes para mostrar más juegos de caracteres, vea [Globalización paso a paso: Fuentes](https://go.microsoft.com/fwlink/?LinkId=229111). Fuentes vinculadas se definen en la subclave HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\FontLink\SystemLink del registro. Cada entrada asociada a esta subclave corresponde al nombre de una fuente base y su valor es una matriz de cadenas que define los archivos de fuentes y las fuentes que están vinculadas a la fuente base. Cada miembro de la matriz define una fuente vinculada y adopta la forma *nombre de archivo de fuente*,*nombre de fuente*. El ejemplo siguiente muestra cómo se puede definir mediante programación una fuente vinculada denominada SimSun se encuentra en un archivo de fuente denominado simsun.ttc que muestra caracteres Han simplificado.  
  
 [!code-csharp[System.Console.Class#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.console.class/cs/fontlink1.cs#2)]
 [!code-vb[System.Console.Class#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.console.class/vb/fontlink1.vb#2)]  
  
 Compatibilidad con Unicode para la consola tiene las siguientes limitaciones:  
  
-   No se admite la codificación UTF-32. El único admitido Unicode son de codificaciones UTF-8 y UTF-16, que están representados por la <xref:System.Text.UTF8Encoding> y <xref:System.Text.UnicodeEncoding> clases, respectivamente.  
  
-   No se admite la salida bidireccional.  
  
-   Visualización de caracteres fuera del plano multilingüe básico (es decir, de los pares suplentes) no es compatible, incluso si están definidos en un archivo de fuente vinculados.  
  
-   No se admite la visualización de caracteres de secuencias de comandos complejas.  
  
-   Secuencias de caracteres combinados (es decir, los caracteres que se componen de un carácter base y uno o más caracteres de combinación) se muestran como caracteres distintos. Para solucionar esta limitación, puede normalizar la cadena que se mostrará mediante una llamada a la <xref:System.String.Normalize%2A?displayProperty=nameWithType> método antes de enviar la salida a la consola. En el ejemplo siguiente, una cadena que contiene el carácter de la combinación de secuencia u+0061 + u+0308 se muestra en la consola como dos caracteres antes de la cadena de salida se normaliza y como un único carácter después de la <xref:System.String.Normalize%2A?displayProperty=nameWithType> se llama al método.  
  
     [!code-csharp[System.Console.Class#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.console.class/cs/normalize1.cs#5)]
     [!code-vb[System.Console.Class#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.console.class/vb/normalize1.vb#5)]  
  
     Tenga en cuenta que la normalización es una solución viable solo si la secuencia de caracteres Unicode estándar para el carácter se incluye un formulario previamente compuesto que corresponde a un determinado combining.  
  
-   Si una fuente proporciona un glifo de punto de código en el área de uso privado, se mostrará ese glifo. Sin embargo, dado que los caracteres en el área de uso privado son específicos de la aplicación, esto puede no ser el glifo esperado.  
  
 El ejemplo siguiente muestra un intervalo de caracteres Unicode en la consola. El ejemplo acepta tres parámetros de línea de comandos: el inicio del intervalo para mostrar el final del intervalo para mostrar y si se usa la codificación de la consola actual (`false`) o la codificación UTF-16 (`true`). Se supone que la consola está utilizando una fuente TrueType.  
  
 [!code-csharp[System.Console.Class#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.console.class/cs/example3.cs#4)]
 [!code-vb[System.Console.Class#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.console.class/vb/example3.vb#4)]  
  
<a name="Operations"></a>   
## <a name="common-operations"></a>Operaciones comunes  
 La <xref:System.Console> clase contiene los siguientes métodos para leer la entrada de la consola y escribir la salida de consola:  
  
-   Las sobrecargas de los <xref:System.Console.ReadKey%2A> método leer caracteres individuales.  
  
-   El <xref:System.Console.ReadLine%2A> método lee una línea de entrada completa.  
  
-   El <xref:System.Console.Write%2A> sobrecargas del método convertir una instancia de un tipo de valor, una matriz de caracteres o un conjunto de objetos en una cadena con formato o sin formato y, a continuación, escribir esa cadena en la consola.  
  
-   Establece un paralelo de <xref:System.Console.WriteLine%2A> sobrecargas de método de salida de la misma cadena como el <xref:System.Console.Write%2A> sobrecargas, pero también agrega una cadena de terminación de la línea.  
  
 La <xref:System.Console> clase también contiene métodos y propiedades para realizar las siguientes operaciones:  
  
-   Obtiene o establece el tamaño del búfer de pantalla. El <xref:System.Console.BufferHeight%2A> y <xref:System.Console.BufferWidth%2A> propiedades le permiten obtener o establecer el ancho y el alto del búfer, respectivamente y el <xref:System.Console.SetBufferSize%2A> método le permite establecer el tamaño del búfer en una única llamada al método.  
  
-   Obtiene o establece el tamaño de la ventana de consola. El <xref:System.Console.WindowHeight%2A> y <xref:System.Console.WindowWidth%2A> propiedades le permiten obtener o establecer el ancho y el alto de la ventana, respectivamente y el <xref:System.Console.SetWindowSize%2A> método le permite establecer el tamaño de ventana en una única llamada al método.  
  
-   Obtiene o establece el tamaño del cursor. El <xref:System.Console.CursorSize%2A> propiedad especifica el alto del cursor en una celda de carácter.  
  
-   Obtiene o establece la posición de la ventana de consola con respecto al búfer de pantalla. El <xref:System.Console.WindowTop%2A> y <xref:System.Console.WindowLeft%2A> propiedades le permiten obtener o establecer la fila superior y la columna situada más a del búfer de pantalla que aparece en la ventana de consola, y el <xref:System.Console.SetWindowPosition%2A> método le permite definir estos valores en una única llamada al método.  
  
-   Obtiene o establece la posición del cursor al obtener o establecer el <xref:System.Console.CursorTop%2A> y <xref:System.Console.CursorLeft%2A> propiedades o conjunto de la posición del cursor mediante una llamada a la <xref:System.Console.SetCursorPosition%2A> método.  
  
-   Mover o eliminar datos en el búfer de pantalla mediante una llamada a la <xref:System.Console.MoveBufferArea%2A> o <xref:System.Console.Clear%2A> método.  
  
-   Obtiene o establece los colores de primer y segundo plano mediante el uso de la <xref:System.Console.ForegroundColor%2A> y <xref:System.Console.BackgroundColor%2A> propiedades, o restablecer el background y foreground sus colores predeterminados mediante una llamada a la <xref:System.Console.ResetColor%2A> método.  
  
-   Reproducir el sonido de un bip a través del altavoz de la consola mediante una llamada a la <xref:System.Console.Beep%2A> método.  
  
<a name="Core"></a>   
## <a name="includenetcoreincludesnet-core-mdmd-notes"></a>[!INCLUDE[net_core](~/includes/net-core-md.md)] Notas de la  
 En .NET Framework en el escritorio, la <xref:System.Console> clase usa la codificación devuelta por `GetConsoleCP` y `GetConsoleOutputCP`, que normalmente es una página de códigos de codificación. Por ejemplo código en sistemas cuya referencia cultural es inglés (Estados Unidos), página de códigos 437 es la codificación que se usa de forma predeterminada. Sin embargo, [!INCLUDE[net_core](~/includes/net-core-md.md)] puede realizar solo un subconjunto limitado de estas codificaciones disponibles. En este caso, <xref:System.Text.Encoding.UTF8%2A?displayProperty=nameWithType> se utiliza como la codificación predeterminada para la consola.  
  
 Si la aplicación depende de codificaciones de páginas de código específico, puede seguir hacerlos disponibles haciendo lo siguiente *antes* llamar a cualquier <xref:System.Console> métodos:  
  
1.  Agregue una referencia al ensamblado System.Text.Encoding.CodePages.dll al proyecto.  
  
2.  Recuperar el <xref:System.Text.EncodingProvider> objeto desde el <xref:System.Text.CodePagesEncodingProvider.Instance%2A?displayProperty=nameWithType> propiedad.  
  
3.  Pase el <xref:System.Text.EncodingProvider> de objeto para el <xref:System.Text.Encoding.RegisterProvider%2A?displayProperty=nameWithType> método para hacer que las codificaciones adicionales admitidas por el proveedor de codificación disponible.  
  
 El <xref:System.Console> clase, a continuación, usarán automáticamente la codificación predeterminada del sistema en lugar de UTF8, siempre que haya registrado el proveedor de codificación antes de llamar a cualquier <xref:System.Console> métodos de salida.  
  
   
  
## Examples  
 El ejemplo siguiente muestra cómo leer y escribir datos en las secuencias de salida y entrada estándar. Tenga en cuenta que estos flujos pueden redirigirse utilizando el <xref:System.Console.SetIn%2A> y <xref:System.Console.SetOut%2A> métodos.  
  
 [!code-cpp[Classic Console Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Console Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Console Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Console Example/CS/source.cs#1)]
 [!code-vb[Classic Console Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Console Example/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <threadsafe>Este tipo es seguro para la ejecución de subprocesos.</threadsafe>
  </Docs>
  <Members>
    <Member MemberName="BackgroundColor">
      <MemberSignature Language="C#" Value="public static ConsoleColor BackgroundColor { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property valuetype System.ConsoleColor BackgroundColor" />
      <MemberSignature Language="DocId" Value="P:System.Console.BackgroundColor" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property BackgroundColor As ConsoleColor" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property ConsoleColor BackgroundColor { ConsoleColor get(); void set(ConsoleColor value); };" />
      <MemberSignature Language="F#" Value="member this.BackgroundColor : ConsoleColor with get, set" Usage="System.Console.BackgroundColor" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>set: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ConsoleColor</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece el color de fondo de la consola.</summary>
        <value>Valor que especifica el color de fondo de la consola; es decir, el color que aparece detrás de cada carácter. El valor predeterminado es negro.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un cambio en el <xref:System.Console.BackgroundColor%2A> propiedad afecta a la salida única que se escribe en las celdas de caracteres individuales después de cambia el color de fondo. Para cambiar el color de fondo de la ventana de consola como un todo, establezca el <xref:System.Console.BackgroundColor%2A> propiedad y llame a la <xref:System.Console.Clear%2A> método. Esto se muestra en el ejemplo siguiente.  
  
 [!code-csharp[System.Console.BackgroundColor#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.console.backgroundcolor/cs/backgroundcolor1.cs#1)]
 [!code-vb[System.Console.BackgroundColor#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.console.backgroundcolor/vb/backgroundcolor1.vb#1)]  
  
 Devuelve una operación get para una aplicación basada en Windows, en la que no exista una consola <xref:System.ConsoleColor.Black?displayProperty=nameWithType>.  
  
   
  
## Examples  
 En el ejemplo siguiente se guarda los valores de la <xref:System.ConsoleColor> enumeración en una matriz y almacena los valores actuales de la <xref:System.Console.BackgroundColor%2A> y <xref:System.Console.ForegroundColor%2A> propiedades a las variables. A continuación, cambia el color de primer plano para cada color en el <xref:System.ConsoleColor> enumeración, excepto en el color que coincida con el fondo actual, y cambia el color de fondo a cada color en el <xref:System.ConsoleColor> enumeración excepto en el color que coincide con el primer plano actual. (Si el color de primer plano es el mismo que el color de fondo, el texto no está visible.) Por último, llama a la <xref:System.Console.ResetColor%2A> método para restablecer los colores de consola original.  
  
 [!code-csharp[System.ConsoleColor#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.consolecolor/cs/foregroundcolor3.cs#1)]
 [!code-vb[System.ConsoleColor#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.consolecolor/vb/foregroundcolor3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">El color especificado en una operación de establecimiento no es un miembro válido de <see cref="T:System.ConsoleColor" />.</exception>
        <exception cref="T:System.Security.SecurityException">El usuario no tiene permiso para realizar esta acción.</exception>
        <exception cref="T:System.IO.IOException">Error de E/S.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">Para modificar las ventanas secundarias y ventanas seguras de nivel superior. Enumeración asociada: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="Beep">
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Reproduce el sonido de un bip a través del altavoz de la consola.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Beep">
      <MemberSignature Language="C#" Value="public static void Beep ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Beep() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.Beep" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Beep ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Beep();" />
      <MemberSignature Language="F#" Value="static member Beep : unit -&gt; unit" Usage="System.Console.Beep " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Reproduce el sonido de un bip a través del altavoz de la consola.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 De forma predeterminada, el bip con una frecuencia de 800 hercios durante un tiempo de 200 milisegundos.  
  
> [!NOTE]
>  El <xref:System.Console.Beep%2A> método no se admite en las ediciones de 64 bits de Windows Vista y Windows XP.  
  
 <xref:System.Console.Beep%2A> ajusta una llamada a la Windows [Beep función](https://msdn.microsoft.com/library/windows/desktop/ms679277.aspx). Si <xref:System.Console.Beep%2A> genera un sonido en las versiones de Windows antes de que la presencia de un chip de temporizador de intervalos programable 8254 depende de Windows 7. A partir de Windows 7, depende del dispositivo de sonido de forma predeterminada.  
  
   
  
## Examples  
 En el ejemplo siguiente se muestra el <xref:System.Console.Beep%2A> método. El ejemplo acepta un número comprendido entre 1 y 9 como un argumento de línea de comandos y ese número de veces que reproduce el sonido.  
  
 [!code-cpp[console.beep#1](~/samples/snippets/cpp/VS_Snippets_CLR/console.beep/CPP/beep.cpp#1)]
 [!code-csharp[console.beep#1](~/samples/snippets/csharp/VS_Snippets_CLR/console.beep/CS/beep.cs#1)]
 [!code-vb[console.beep#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/console.beep/VB/beep.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.HostProtectionException">Este método se ha ejecutado en un servidor, como SQL Server, que no permite el acceso a una interfaz de usuario.</exception>
      </Docs>
    </Member>
    <Member MemberName="Beep">
      <MemberSignature Language="C#" Value="public static void Beep (int frequency, int duration);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Beep(int32 frequency, int32 duration) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.Beep(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Beep (frequency As Integer, duration As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Beep(int frequency, int duration);" />
      <MemberSignature Language="F#" Value="static member Beep : int * int -&gt; unit" Usage="System.Console.Beep (frequency, duration)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="frequency" Type="System.Int32" />
        <Parameter Name="duration" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="frequency">Frecuencia del bip, que va de 37 a 32.767 hercios.</param>
        <param name="duration">Duración del bip, medida en milisegundos.</param>
        <summary>Reproduce el sonido de un bip con una frecuencia y duración especificadas a través del altavoz de la consola.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Console.Beep%2A> ajusta una llamada a la Windows [Beep función](https://msdn.microsoft.com/library/windows/desktop/ms679277.aspx). Si <xref:System.Console.Beep%2A> genera un sonido en las versiones de Windows antes de que la presencia de un chip de temporizador de intervalos programable 8254 depende de Windows 7. A partir de Windows 7, depende del dispositivo de sonido de forma predeterminada.  
  
> [!NOTE]
>  El <xref:System.Console.Beep%2A> método no se admite en las ediciones de 64 bits de Windows Vista y Windows XP.  
  
   
  
## Examples  
 Este ejemplo se muestra el <xref:System.Console.Beep%2A> método reproduciendo las primeras notas de una canción a través del altavoz de la consola.  
  
 [!code-cpp[console.beep2#1](~/samples/snippets/cpp/VS_Snippets_CLR/console.beep2/CPP/b2.cpp#1)]
 [!code-csharp[console.beep2#1](~/samples/snippets/csharp/VS_Snippets_CLR/console.beep2/CS/b2.cs#1)]
 [!code-vb[console.beep2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/console.beep2/VB/b2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="frequency" /> es menor que 37 o mayor que 32767 hercios.  
  
O bien 
 <paramref name="duration" /> es menor o igual que cero.</exception>
        <exception cref="T:System.Security.HostProtectionException">Este método se ha ejecutado en un servidor, como SQL Server, que no permite el acceso a la consola.</exception>
      </Docs>
    </Member>
    <Member MemberName="BufferHeight">
      <MemberSignature Language="C#" Value="public static int BufferHeight { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property int32 BufferHeight" />
      <MemberSignature Language="DocId" Value="P:System.Console.BufferHeight" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property BufferHeight As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property int BufferHeight { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.BufferHeight : int with get, set" Usage="System.Console.BufferHeight" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece el alto del área del búfer.</summary>
        <value>El alto actual, en filas, del área del búfer.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esta propiedad define el número de filas (o líneas) almacenados en el búfer que se tiene acceso a una ventana de modo de consola. En cambio, el <xref:System.Console.WindowHeight%2A> propiedad define el número de filas que realmente se muestran en la ventana de consola en un momento dado. Si el número de filas escritas realmente en el búfer supera el número de filas definido por el <xref:System.Console.WindowHeight%2A> propiedad, se puede desplazar verticalmente la ventana de modo que muestre un número contiguo de filas que son iguales a la <xref:System.Console.WindowHeight%2A> propiedad y se encuentran en cualquier lugar en el búfer.  
  
 Si una operación de establecimiento disminuye el valor de la <xref:System.Console.BufferHeight%2A> propiedad, se quitan las líneas superior. Por ejemplo, si se reduce el número de líneas de 300 a 250, se quitan las líneas 0 al 49 y existente líneas entre 50 y 299 se convierten en líneas de 249 a 0.  
  
   
  
## Examples  
 Este ejemplo se muestra el <xref:System.Console.BufferHeight%2A> y <xref:System.Console.BufferWidth%2A> propiedades. En el ejemplo se informa de las dimensiones de una ventana del sistema operativo establecido en un tamaño de búfer de 300 filas y 85 columnas.  
  
 [!code-cpp[console.bufferHW#1](~/samples/snippets/cpp/VS_Snippets_CLR/console.bufferHW/CPP/hw.cpp#1)]
 [!code-csharp[console.bufferHW#1](~/samples/snippets/csharp/VS_Snippets_CLR/console.bufferHW/CS/hw.cs#1)]
 [!code-vb[console.bufferHW#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/console.bufferHW/VB/hw.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">El valor de una operación set es mayor o igual que cero.  
  
O bien 
El valor de una operación set es mayor o igual que <see cref="F:System.Int16.MaxValue" />.  
  
O bien 
El valor de una operación Set es menor que <see cref="P:System.Console.WindowTop" /> + <see cref="P:System.Console.WindowHeight" />.</exception>
        <exception cref="T:System.Security.SecurityException">El usuario no tiene permiso para realizar esta acción.</exception>
        <exception cref="T:System.IO.IOException">Error de E/S.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">Para modificar las ventanas secundarias y ventanas seguras de nivel superior. Enumeración asociada: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
      </Docs>
    </Member>
    <Member MemberName="BufferWidth">
      <MemberSignature Language="C#" Value="public static int BufferWidth { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property int32 BufferWidth" />
      <MemberSignature Language="DocId" Value="P:System.Console.BufferWidth" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property BufferWidth As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property int BufferWidth { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.BufferWidth : int with get, set" Usage="System.Console.BufferWidth" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece el ancho del área del búfer.</summary>
        <value>El ancho actual, en columnas, del área del búfer.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si una operación de establecimiento disminuye el valor de la <xref:System.Console.BufferWidth%2A> propiedad, se quitan las columnas más a la derecha. Por ejemplo, si se reduce el número de columnas de 80 a 60, se quitan las columnas 60 y 79 de cada fila.  
  
   
  
## Examples  
 Este ejemplo se muestra el <xref:System.Console.BufferHeight%2A> y <xref:System.Console.BufferWidth%2A> propiedades. En el ejemplo se informa de las dimensiones de una ventana del sistema operativo establecido en un tamaño de búfer de 300 filas y 85 columnas.  
  
 [!code-cpp[console.bufferHW#1](~/samples/snippets/cpp/VS_Snippets_CLR/console.bufferHW/CPP/hw.cpp#1)]
 [!code-csharp[console.bufferHW#1](~/samples/snippets/csharp/VS_Snippets_CLR/console.bufferHW/CS/hw.cs#1)]
 [!code-vb[console.bufferHW#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/console.bufferHW/VB/hw.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">El valor de una operación set es mayor o igual que cero.  
  
O bien 
El valor de una operación set es mayor o igual que <see cref="F:System.Int16.MaxValue" />.  
  
O bien 
El valor de una operación Set es menor que <see cref="P:System.Console.WindowLeft" /> + <see cref="P:System.Console.WindowWidth" />.</exception>
        <exception cref="T:System.Security.SecurityException">El usuario no tiene permiso para realizar esta acción.</exception>
        <exception cref="T:System.IO.IOException">Error de E/S.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">Para modificar las ventanas secundarias y ventanas seguras de nivel superior. Enumeración asociada: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
      </Docs>
    </Member>
    <Member MemberName="CancelKeyPress">
      <MemberSignature Language="C#" Value="public static event ConsoleCancelEventHandler CancelKeyPress;" />
      <MemberSignature Language="ILAsm" Value=".event class System.ConsoleCancelEventHandler CancelKeyPress" />
      <MemberSignature Language="DocId" Value="E:System.Console.CancelKeyPress" />
      <MemberSignature Language="VB.NET" Value="Public Shared Custom Event CancelKeyPress As ConsoleCancelEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static event ConsoleCancelEventHandler ^ CancelKeyPress;" />
      <MemberSignature Language="F#" Value="member this.CancelKeyPress : ConsoleCancelEventHandler " Usage="member this.CancelKeyPress : System.ConsoleCancelEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>add: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>remove: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ConsoleCancelEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produce cuando la tecla modificadora <see cref="F:System.ConsoleModifiers.Control" /> (Ctrl) y la tecla de consola <see cref="F:System.ConsoleKey.C" /> (C) o la tecla Interrumpir se presionan simultáneamente (Ctrl+C o Ctrl+Inter).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este evento se usa junto con <xref:System.ConsoleCancelEventHandler?displayProperty=nameWithType> y <xref:System.ConsoleCancelEventArgs?displayProperty=nameWithType>. El <xref:System.Console.CancelKeyPress> evento permite interceptar la señal de Ctrl + C para el controlador de eventos pueda decidir si desea continuar la ejecución o finalizar una aplicación de consola. Para obtener más información sobre el manejo de eventos, consulte [controlar y provocar eventos](~/docs/standard/events/index.md).  
  
 Cuando el usuario presiona CTRL+c o CTRL+INTER, el <xref:System.Console.CancelKeyPress> desencadena el evento y la aplicación <xref:System.ConsoleCancelEventHandler> se ejecuta el controlador de eventos. El controlador de eventos se pasa un <xref:System.ConsoleCancelEventArgs> objeto que tiene dos propiedades útiles:  
  
-   <xref:System.ConsoleCancelEventArgs.SpecialKey%2A>, que le permite determinar si se invocó el controlador porque el usuario al presionar CTRL+c (el valor de propiedad es <xref:System.ConsoleSpecialKey.ControlC?displayProperty=nameWithType>) o CTRL+INTER (es el valor de propiedad <xref:System.ConsoleSpecialKey.ControlBreak?displayProperty=nameWithType>).  
  
-   <xref:System.ConsoleCancelEventArgs.Cancel%2A>, que le permite determinar cómo su aplicación debe responder al usuario al presionar CTRL+c o CTRL+INTER. De forma predeterminada, el <xref:System.ConsoleCancelEventArgs.Cancel%2A> propiedad es `false`, que hace que la ejecución para que finalice cuando se cierra el controlador de eventos del programa. Modificación de su propiedad a `true` especifica que la aplicación debería continuar ejecutándose.  
  
> [!TIP]
>  Si la aplicación tiene requisitos simples, puede usar el <xref:System.Console.TreatControlCAsInput%2A> propiedad en lugar de este evento. Al establecer esta propiedad en `false`, puede asegurarse de que la aplicación siempre se cierra si el usuario presiona CTRL+c. Si se establece en `true`, puede asegurarse de que al presionar CTRL+c no finalizará la aplicación.  
  
 El controlador de eventos para este evento se ejecuta en un subproceso ThreadPool.  
  
   
  
## Examples  
 En el ejemplo siguiente se muestra cómo el <xref:System.Console.CancelKeyPress> se usa el evento. Al presionar Ctrl + C, se interrumpe la operación de lectura y la `myHandler` se invoca el controlador de eventos. Al entrar en el controlador de eventos, el <xref:System.ConsoleCancelEventArgs.Cancel%2A?displayProperty=nameWithType> propiedad es `false`, lo que significa que el proceso actual se cerrará cuando finaliza el controlador de eventos. Sin embargo, el controlador de eventos establece el <xref:System.ConsoleCancelEventArgs.Cancel%2A?displayProperty=nameWithType> propiedad `true`, lo que significa que no finalizará el proceso y se reanudará la operación de lectura.  
  
 [!code-cpp[console.cancelkeypress#1](~/samples/snippets/cpp/VS_Snippets_CLR/console.cancelkeypress/cpp/ckp.cpp#1)]
 [!code-csharp[console.cancelkeypress#1](~/samples/snippets/csharp/VS_Snippets_CLR/console.cancelkeypress/cs/ckp.cs#1)]
 [!code-vb[console.cancelkeypress#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/console.cancelkeypress/vb/ckp.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">Para modificar las ventanas secundarias y ventanas seguras de nivel superior. Enumeración asociada: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
        <altmember cref="T:System.ConsoleCancelEventArgs" />
        <altmember cref="T:System.ConsoleCancelEventHandler" />
        <altmember cref="P:System.Console.TreatControlCAsInput" />
      </Docs>
    </Member>
    <Member MemberName="CapsLock">
      <MemberSignature Language="C#" Value="public static bool CapsLock { get; }" />
      <MemberSignature Language="ILAsm" Value=".property bool CapsLock" />
      <MemberSignature Language="DocId" Value="P:System.Console.CapsLock" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property CapsLock As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool CapsLock { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CapsLock : bool" Usage="System.Console.CapsLock" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene un valor que indica si se activa o desactiva la alternancia de teclado de BLOQ MAYÚS.</summary>
        <value><see langword="true" /> si se activa BLOQ MAYÚS; <see langword="false" /> si se desactiva BLOQ MAYÚS.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Clear">
      <MemberSignature Language="C#" Value="public static void Clear ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Clear() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.Clear" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Clear ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Clear();" />
      <MemberSignature Language="F#" Value="static member Clear : unit -&gt; unit" Usage="System.Console.Clear " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Borra la información que se muestra en el búfer de pantalla y en la correspondiente ventana de la consola.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Mediante el <xref:System.Console.Clear%2A> método equivale a llamar MS-DOS `cls` comando en la ventana de símbolo del sistema. Cuando el <xref:System.Console.Clear%2A> se llama al método, el cursor se desplaza automáticamente a la esquina superior izquierda de la ventana y el contenido del búfer de pantalla se establece en espacios en blanco mediante los colores de fondo de primer plano actual.  
  
> [!NOTE]
>  Al intentar llamar a la <xref:System.Console.Clear%2A> método cuando el resultado de la aplicación de consola se redirige a un archivo produce una <xref:System.IO.IOException>. Para evitar esto, siempre contienen una llamada a la <xref:System.Console.Clear%2A> método en un `try`...`catch` bloque.  
  
   
  
## Examples  
 En el ejemplo siguiente se usa el <xref:System.Console.Clear%2A> método para borrar la consola antes de ejecutar un bucle, pide al usuario seleccionar un color de primer y segundo plano y escriba una cadena para mostrar. Si el usuario elige no salir del programa, se restauran los colores de primer plano y fondo del originales de la consola y el <xref:System.Console.Clear%2A> se llama al método nuevo antes de volver a ejecutar el bucle.  
  
 [!code-csharp[System.Console.Clear#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.console.clear/cs/clear1.cs#1)]
 [!code-vb[System.Console.Clear#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.console.clear/vb/clear1.vb#1)]  
  
 En el ejemplo se basa en un `GetKeyPress` método para validar la selección del usuario de un color de primer plano y fondo.  
  
 Este ejemplo se muestra el <xref:System.Console.CursorLeft%2A> y <xref:System.Console.CursorTop%2A> propiedades y el <xref:System.Console.SetCursorPosition%2A> y <xref:System.Console.Clear%2A> métodos. En el ejemplo se coloca el cursor, que determina dónde se producirá la siguiente escritura, para dibujar un 5 caracteres por 5 rectángulo carácter mediante una combinación de "+", "&#124;", y "-" cadenas. Tenga en cuenta que se puede dibujar el rectángulo con menos pasos mediante una combinación de otras cadenas.  
  
 [!code-cpp[console.cursorLTS#1](~/samples/snippets/cpp/VS_Snippets_CLR/console.cursorLTS/CPP/lts.cpp#1)]
 [!code-csharp[console.cursorLTS#1](~/samples/snippets/csharp/VS_Snippets_CLR/console.cursorLTS/CS/lts.cs#1)]
 [!code-vb[console.cursorLTS#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/console.cursorLTS/VB/lts.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Error de E/S.</exception>
      </Docs>
    </Member>
    <Member MemberName="CursorLeft">
      <MemberSignature Language="C#" Value="public static int CursorLeft { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property int32 CursorLeft" />
      <MemberSignature Language="DocId" Value="P:System.Console.CursorLeft" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property CursorLeft As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property int CursorLeft { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.CursorLeft : int with get, set" Usage="System.Console.CursorLeft" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece la posición en columnas del cursor en el área del búfer.</summary>
        <value>La posición actual, en columnas, del cursor.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Este ejemplo se muestra el <xref:System.Console.CursorLeft%2A> y <xref:System.Console.CursorTop%2A> propiedades y el <xref:System.Console.SetCursorPosition%2A> y <xref:System.Console.Clear%2A> métodos. En el ejemplo se coloca el cursor, que determina dónde se producirá la siguiente escritura, para dibujar un 5 caracteres por 5 rectángulo carácter mediante una combinación de "+", "&#124;", y "-" cadenas. Tenga en cuenta que se puede dibujar el rectángulo con menos pasos mediante una combinación de otras cadenas.  
  
 [!code-cpp[console.cursorLTS#1](~/samples/snippets/cpp/VS_Snippets_CLR/console.cursorLTS/CPP/lts.cpp#1)]
 [!code-csharp[console.cursorLTS#1](~/samples/snippets/csharp/VS_Snippets_CLR/console.cursorLTS/CS/lts.cs#1)]
 [!code-vb[console.cursorLTS#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/console.cursorLTS/VB/lts.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">El valor de una operación Set es menor que cero.  
  
O bien 
El valor de una operación set es mayor o igual que <see cref="P:System.Console.BufferWidth" />.</exception>
        <exception cref="T:System.Security.SecurityException">El usuario no tiene permiso para realizar esta acción.</exception>
        <exception cref="T:System.IO.IOException">Error de E/S.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">Para modificar las ventanas secundarias y ventanas seguras de nivel superior. Enumeración asociada: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
      </Docs>
    </Member>
    <Member MemberName="CursorSize">
      <MemberSignature Language="C#" Value="public static int CursorSize { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property int32 CursorSize" />
      <MemberSignature Language="DocId" Value="P:System.Console.CursorSize" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property CursorSize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property int CursorSize { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.CursorSize : int with get, set" Usage="System.Console.CursorSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>set: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece el alto del cursor en una celda de carácter.</summary>
        <value>El tamaño del cursor expresado como porcentaje del alto de una celda de carácter. El valor de propiedad varía entre 1 y 100.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La apariencia del cursor varía, que abarcan desde una línea horizontal en la parte inferior de la celda cuando el valor de propiedad es 1, para rellenar por completo la celda cuando el valor de propiedad es 100.  
  
   
  
## Examples  
 Este ejemplo se muestra el <xref:System.Console.CursorSize%2A> propiedad. El ejemplo aumenta el tamaño del cursor cada vez que se presiona cualquier tecla de consola y luego restaura el cursor a su tamaño original antes de finalizar.  
  
 [!code-cpp[console.cursorsize#1](~/samples/snippets/cpp/VS_Snippets_CLR/console.cursorsize/CPP/csize.cpp#1)]
 [!code-csharp[console.cursorsize#1](~/samples/snippets/csharp/VS_Snippets_CLR/console.cursorsize/CS/csize.cs#1)]
 [!code-vb[console.cursorsize#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/console.cursorsize/VB/csize.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">El valor especificado en una operación Set es menor que 1 o mayor que 100.</exception>
        <exception cref="T:System.Security.SecurityException">El usuario no tiene permiso para realizar esta acción.</exception>
        <exception cref="T:System.IO.IOException">Error de E/S.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">Para modificar las ventanas secundarias y ventanas seguras de nivel superior. Enumeración asociada: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
      </Docs>
    </Member>
    <Member MemberName="CursorTop">
      <MemberSignature Language="C#" Value="public static int CursorTop { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property int32 CursorTop" />
      <MemberSignature Language="DocId" Value="P:System.Console.CursorTop" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property CursorTop As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property int CursorTop { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.CursorTop : int with get, set" Usage="System.Console.CursorTop" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece la posición en filas del cursor en el área del búfer.</summary>
        <value>La posición actual, en filas, del cursor.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Este ejemplo se muestra el <xref:System.Console.CursorLeft%2A> y <xref:System.Console.CursorTop%2A> propiedades y el <xref:System.Console.SetCursorPosition%2A> y <xref:System.Console.Clear%2A> métodos. En el ejemplo se coloca el cursor, que determina dónde se producirá la siguiente escritura, para dibujar un 5 caracteres por 5 rectángulo carácter mediante una combinación de "+", "&#124;", y "-" cadenas. Tenga en cuenta que se puede dibujar el rectángulo con menos pasos mediante una combinación de otras cadenas.  
  
 [!code-cpp[console.cursorLTS#1](~/samples/snippets/cpp/VS_Snippets_CLR/console.cursorLTS/CPP/lts.cpp#1)]
 [!code-csharp[console.cursorLTS#1](~/samples/snippets/csharp/VS_Snippets_CLR/console.cursorLTS/CS/lts.cs#1)]
 [!code-vb[console.cursorLTS#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/console.cursorLTS/VB/lts.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">El valor de una operación Set es menor que cero.  
  
O bien 
El valor de una operación set es mayor o igual que <see cref="P:System.Console.BufferHeight" />.</exception>
        <exception cref="T:System.Security.SecurityException">El usuario no tiene permiso para realizar esta acción.</exception>
        <exception cref="T:System.IO.IOException">Error de E/S.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">Para modificar las ventanas secundarias y ventanas seguras de nivel superior. Enumeración asociada: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
      </Docs>
    </Member>
    <Member MemberName="CursorVisible">
      <MemberSignature Language="C#" Value="public static bool CursorVisible { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property bool CursorVisible" />
      <MemberSignature Language="DocId" Value="P:System.Console.CursorVisible" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property CursorVisible As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool CursorVisible { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.CursorVisible : bool with get, set" Usage="System.Console.CursorVisible" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>set: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece un valor que indica si el cursor es visible.</summary>
        <value><see langword="true" /> si el cursor es visible; en caso contrario, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Este ejemplo se muestra el <xref:System.Console.CursorVisible%2A> propiedad. El ejemplo hace que el cursor es visible si la primera columna de entrada es un carácter '+' o invisible si la entrada es un '-' caracteres.  
  
 [!code-cpp[console.cursorvis#1](~/samples/snippets/cpp/VS_Snippets_CLR/console.cursorvis/CPP/vis.cpp#1)]
 [!code-csharp[console.cursorvis#1](~/samples/snippets/csharp/VS_Snippets_CLR/console.cursorvis/CS/vis.cs#1)]
 [!code-vb[console.cursorvis#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/console.cursorvis/VB/vis.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">El usuario no tiene permiso para realizar esta acción.</exception>
        <exception cref="T:System.IO.IOException">Error de E/S.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">Para modificar las ventanas secundarias y ventanas seguras de nivel superior. Enumeración asociada: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
      </Docs>
    </Member>
    <Member MemberName="Error">
      <MemberSignature Language="C#" Value="public static System.IO.TextWriter Error { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.IO.TextWriter Error" />
      <MemberSignature Language="DocId" Value="P:System.Console.Error" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property Error As TextWriter" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::IO::TextWriter ^ Error { System::IO::TextWriter ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Error : System.IO.TextWriter" Usage="System.Console.Error" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.TextWriter</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene el flujo de salida de error estándar.</summary>
        <value>Objeto <see cref="T:System.IO.TextWriter" /> que representa el flujo de salida de error estándar.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esta secuencia de error estándar se establece en la consola de forma predeterminada. Se puede establecer en otra secuencia con el <xref:System.Console.SetError%2A> método. Se puede volver a adquirir una vez que se redirige la secuencia de error estándar, mediante una llamada a la <xref:System.Console.OpenStandardError%2A> método.  
  
 En las aplicaciones de consola cuya salida informativo a menudo se redirige a un archivo, el error estándar flujo disponibles a través de la <xref:System.Console.Error%2A> propiedad puede usarse para mostrar información en la consola, incluso si se redirige la salida. El ejemplo siguiente muestra las tablas de producto de 10 números en un momento a partir de 1. Después de cada conjunto de 10 números, la <xref:System.Console.Error%2A> propiedad se utiliza para pedir al usuario si se debe mostrar el siguiente conjunto. Si se redirige la salida estándar a un archivo, el usuario todavía se solicita si la rutina debe generar el siguiente conjunto de productos.  
  
 [!code-csharp[System.Console.Error#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.console.error/cs/error1.cs#1)]
 [!code-vb[System.Console.Error#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.console.error/vb/error1.vb#1)]  
  
   
  
## Examples  
 El ejemplo siguiente es una utilidad de línea de comandos denominada ExpandTabs que reemplaza los caracteres de tabulación en un archivo de texto con cuatro espacios, el valor definido por el `tabSize` variable. Redirige la entrada estándar y transmite por secuencias a los archivos de salida, pero usa el <xref:System.Console.Error%2A> propiedad que se va a escribir la secuencia de error estándar en la consola. Puede iniciar desde la línea de comandos proporcionando el nombre del archivo que contiene caracteres de tabulación y el nombre del archivo de salida.  
  
 [!code-cpp[Console-EXPANDTABSEX#1](~/samples/snippets/cpp/VS_Snippets_CLR/Console-EXPANDTABSEX/CPP/expandtabsex.cpp#1)]
 [!code-csharp[Console-EXPANDTABSEX#1](~/samples/snippets/csharp/VS_Snippets_CLR/Console-EXPANDTABSEX/CS/expandtabsex.cs#1)]
 [!code-vb[Console-EXPANDTABSEX#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Console-EXPANDTABSEX/VB/expandtabsex.vb#1)]  
  
 El ejemplo siguiente es un visor de archivos de texto simple que muestra el contenido de uno o varios archivos de texto en la consola. Si no hay ningún argumento de línea de comandos, o si no existen los archivos que se pasan como argumentos de línea de comandos, el ejemplo llama a la <xref:System.Console.SetError%2A> llama al método para redirigir la información de error a un archivo, el <xref:System.Console.OpenStandardError%2A> método en el proceso de volver a adquirir el error estándar transmitir e indica que se escribió la información de error a un archivo.  
  
 [!code-csharp[System.Console.OpenStandardError#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.console.openstandarderror/cs/viewtextfile.cs#1)]
 [!code-vb[System.Console.OpenStandardError#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.console.openstandarderror/vb/viewtextfile.vb#1)]  
  
 Tenga en cuenta que el <xref:System.IO.StreamWriter.AutoFlush%2A?displayProperty=nameWithType> propiedad está establecida en `true` antes de volver a adquirir el flujo de error. Esto garantiza que salida se envía inmediatamente a la consola en lugar de almacenado en búfer.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Console.In" />
        <altmember cref="P:System.Console.Out" />
        <altmember cref="P:System.Console.IsErrorRedirected" />
        <altmember cref="M:System.Console.SetError(System.IO.TextWriter)" />
      </Docs>
    </Member>
    <Member MemberName="ForegroundColor">
      <MemberSignature Language="C#" Value="public static ConsoleColor ForegroundColor { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property valuetype System.ConsoleColor ForegroundColor" />
      <MemberSignature Language="DocId" Value="P:System.Console.ForegroundColor" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property ForegroundColor As ConsoleColor" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property ConsoleColor ForegroundColor { ConsoleColor get(); void set(ConsoleColor value); };" />
      <MemberSignature Language="F#" Value="member this.ForegroundColor : ConsoleColor with get, set" Usage="System.Console.ForegroundColor" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>set: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ConsoleColor</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece el color de primer plano de la consola.</summary>
        <value>Enumeración <see cref="T:System.ConsoleColor" /> que especifica el color de primer plano de la consola; es decir, el color de cada carácter que se muestra. El valor predeterminado es gris.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Devuelve una operación get para una aplicación basada en Windows, en la que no exista una consola <xref:System.ConsoleColor.Gray>.  
  
   
  
## Examples  
 El ejemplo siguiente se comprueba si es el color de fondo de la consola negro y, si es así, cambia el color de fondo a rojo y el color de primer plano en negro.  
  
 [!code-csharp[System.ConsoleColor#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.consolecolor/cs/Example2.cs#2)] 
 [!code-vb[System.ConsoleColor#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.consolecolor/vb/Example2.vb#2)]  
  
 En el ejemplo siguiente se guarda los valores de la <xref:System.ConsoleColor> enumeración en una matriz y almacena los valores actuales de la <xref:System.Console.BackgroundColor%2A> y <xref:System.Console.ForegroundColor%2A> propiedades a las variables. A continuación, cambia el color de primer plano para cada color en el <xref:System.ConsoleColor> enumeración, excepto en el color que coincida con el fondo actual, y cambia el color de fondo a cada color en el <xref:System.ConsoleColor> enumeración excepto en el color que coincide con el primer plano actual. (Si el color de primer plano es el mismo que el color de fondo, el texto no está visible.) Por último, llama a la <xref:System.Console.ResetColor%2A> método para restablecer los colores de consola original.  
  
 [!code-csharp[System.ConsoleColor#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.consolecolor/cs/foregroundcolor3.cs#1)]
 [!code-vb[System.ConsoleColor#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.consolecolor/vb/foregroundcolor3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">El color especificado en una operación de establecimiento no es un miembro válido de <see cref="T:System.ConsoleColor" />.</exception>
        <exception cref="T:System.Security.SecurityException">El usuario no tiene permiso para realizar esta acción.</exception>
        <exception cref="T:System.IO.IOException">Error de E/S.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">Para modificar las ventanas secundarias y ventanas seguras de nivel superior. Enumeración asociada: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
      </Docs>
    </Member>
    <Member MemberName="In">
      <MemberSignature Language="C#" Value="public static System.IO.TextReader In { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.IO.TextReader In" />
      <MemberSignature Language="DocId" Value="P:System.Console.In" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property In As TextReader" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::IO::TextReader ^ In { System::IO::TextReader ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.In : System.IO.TextReader" Usage="System.Console.In" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.TextReader</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene el flujo de entrada estándar.</summary>
        <value><see cref="T:System.IO.TextReader" /> que representa el flujo de entrada estándar.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esta propiedad se establece en el flujo de entrada estándar de forma predeterminada. Esta propiedad puede establecerse en otra secuencia con el <xref:System.Console.SetIn%2A> método.  
  
 Las operaciones de lectura en el flujo de entrada estándar se ejecutan de forma sincrónica. Es decir, bloqueará hasta que se ha completado la operación de lectura especificada. Esto es cierto incluso si un método asincrónico, como <xref:System.IO.TextReader.ReadLineAsync%2A>, se llama en el <xref:System.IO.TextReader> objeto devuelto por la <xref:System.Console.In%2A> propiedad.  
  
   
  
## Examples  
 El ejemplo siguiente muestra el uso de la `In` propiedad.  
  
 [!code-cpp[consolein#1](~/samples/snippets/cpp/VS_Snippets_CLR/consolein/CPP/consolein.cpp#1)]
 [!code-csharp[consolein#1](~/samples/snippets/csharp/VS_Snippets_CLR/consolein/CS/consolein.cs#1)]
 [!code-vb[consolein#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/consolein/VB/consolein.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Console.OpenStandardInput" />
        <altmember cref="P:System.Console.IsInputRedirected" />
        <altmember cref="P:System.Console.Error" />
        <altmember cref="P:System.Console.Out" />
        <altmember cref="M:System.Console.SetIn(System.IO.TextReader)" />
      </Docs>
    </Member>
    <Member MemberName="InputEncoding">
      <MemberSignature Language="C#" Value="public static System.Text.Encoding InputEncoding { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Text.Encoding InputEncoding" />
      <MemberSignature Language="DocId" Value="P:System.Console.InputEncoding" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property InputEncoding As Encoding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Text::Encoding ^ InputEncoding { System::Text::Encoding ^ get(); void set(System::Text::Encoding ^ value); };" />
      <MemberSignature Language="F#" Value="member this.InputEncoding : System.Text.Encoding with get, set" Usage="System.Console.InputEncoding" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>set: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece la codificación que usa la consola para leer la entrada.</summary>
        <value>Codificación usada para leer la entrada de la consola.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La consola utiliza la codificación para convertir la entrada de teclado en el carácter correspondiente de entrada. La codificación de entrada incorpora una página de códigos que se asigna 256 códigos de caracteres de teclado a caracteres individuales. Cada página de código incluye caracteres especiales distintos, que suelen estar personalizados para un idioma o grupo de idiomas.  
  
 A partir de la [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], una operación get de propiedad puede devolver un valor almacenado en caché en lugar de codificación de entrada actual en la consola. Esto puede ocurrir si el valor de la <xref:System.Console.InputEncoding%2A> se modifica la propiedad por otros medios distintos a una asignación a la <xref:System.Console.InputEncoding%2A> propiedad, como llamar a la Windows `SetConsoleCP` función o mediante el `chcp` comando desde un script de PowerShell.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El valor de la propiedad en una operación de conjunto es <see langword="null" />.</exception>
        <exception cref="T:System.IO.IOException">Error durante la ejecución de esta operación.</exception>
        <exception cref="T:System.Security.SecurityException">Tu aplicación no tiene permiso para realizar esta operación.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">para leer y escribir en las ventanas secundarias y ventanas de nivel superior. Enumeración asociada: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
        <altmember cref="T:System.Text.Encoding" />
      </Docs>
    </Member>
    <Member MemberName="IsErrorRedirected">
      <MemberSignature Language="C#" Value="public static bool IsErrorRedirected { get; }" />
      <MemberSignature Language="ILAsm" Value=".property bool IsErrorRedirected" />
      <MemberSignature Language="DocId" Value="P:System.Console.IsErrorRedirected" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property IsErrorRedirected As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool IsErrorRedirected { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsErrorRedirected : bool" Usage="System.Console.IsErrorRedirected" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene un valor que indica si el flujo de salida de errores se ha redirigido desde el flujo de errores estándar.</summary>
        <value><see langword="true" /> si se redirige la salida de error; si no, <see langword="false" />.</value>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Console.Error" />
        <altmember cref="M:System.Console.SetError(System.IO.TextWriter)" />
        <altmember cref="M:System.Console.OpenStandardError" />
      </Docs>
    </Member>
    <Member MemberName="IsInputRedirected">
      <MemberSignature Language="C#" Value="public static bool IsInputRedirected { get; }" />
      <MemberSignature Language="ILAsm" Value=".property bool IsInputRedirected" />
      <MemberSignature Language="DocId" Value="P:System.Console.IsInputRedirected" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property IsInputRedirected As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool IsInputRedirected { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsInputRedirected : bool" Usage="System.Console.IsInputRedirected" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene un valor que indica si la entrada se ha redirigido desde el flujo de entrada estándar.</summary>
        <value><see langword="true" /> si se redirige la entrada; si no, <see langword="false" />.</value>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Console.In" />
        <altmember cref="M:System.Console.SetIn(System.IO.TextReader)" />
        <altmember cref="M:System.Console.OpenStandardInput" />
      </Docs>
    </Member>
    <Member MemberName="IsOutputRedirected">
      <MemberSignature Language="C#" Value="public static bool IsOutputRedirected { get; }" />
      <MemberSignature Language="ILAsm" Value=".property bool IsOutputRedirected" />
      <MemberSignature Language="DocId" Value="P:System.Console.IsOutputRedirected" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property IsOutputRedirected As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool IsOutputRedirected { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsOutputRedirected : bool" Usage="System.Console.IsOutputRedirected" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene un valor que indica si la salida se ha redirigido desde el flujo de salida estándar.</summary>
        <value><see langword="true" /> si se redirige la salida; si no, <see langword="false" />.</value>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Console.Out" />
        <altmember cref="M:System.Console.SetOut(System.IO.TextWriter)" />
        <altmember cref="M:System.Console.OpenStandardError" />
      </Docs>
    </Member>
    <Member MemberName="KeyAvailable">
      <MemberSignature Language="C#" Value="public static bool KeyAvailable { get; }" />
      <MemberSignature Language="ILAsm" Value=".property bool KeyAvailable" />
      <MemberSignature Language="DocId" Value="P:System.Console.KeyAvailable" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property KeyAvailable As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool KeyAvailable { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.KeyAvailable : bool" Usage="System.Console.KeyAvailable" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene un valor que indica si hay disponible una acción de presionar una tecla en el flujo de entrada.</summary>
        <value><see langword="true" /> si hay disponible una acción de presionar una tecla; en caso contrario, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El valor de propiedad se devuelve inmediatamente; es decir, el <xref:System.Console.KeyAvailable%2A> propiedad no bloquea la entrada hasta que presione una tecla está disponible.  
  
 Use la <xref:System.Console.KeyAvailable%2A> propiedad junto con solo el <xref:System.Console.ReadKey%2A> método, no el <xref:System.Console.Read%2A> o <xref:System.Console.ReadLine%2A> métodos.  
  
   
  
## Examples  
 En el ejemplo siguiente se muestra cómo usar el <xref:System.Console.KeyAvailable%2A> propiedad para crear un bucle que se ejecuta hasta que se presiona una tecla.  
  
 [!code-cpp[console.keyavailable#1](~/samples/snippets/cpp/VS_Snippets_CLR/console.keyavailable/CPP/ka.cpp#1)]
 [!code-csharp[console.keyavailable#1](~/samples/snippets/csharp/VS_Snippets_CLR/console.keyavailable/CS/ka.cs#1)]
 [!code-vb[console.keyavailable#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/console.keyavailable/VB/ka.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Error de E/S.</exception>
        <exception cref="T:System.InvalidOperationException">La entrada estándar se redirige a un archivo en lugar de al teclado.</exception>
      </Docs>
    </Member>
    <Member MemberName="LargestWindowHeight">
      <MemberSignature Language="C#" Value="public static int LargestWindowHeight { get; }" />
      <MemberSignature Language="ILAsm" Value=".property int32 LargestWindowHeight" />
      <MemberSignature Language="DocId" Value="P:System.Console.LargestWindowHeight" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property LargestWindowHeight As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property int LargestWindowHeight { int get(); };" />
      <MemberSignature Language="F#" Value="member this.LargestWindowHeight : int" Usage="System.Console.LargestWindowHeight" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene el máximo número posible de filas para la ventana de la consola, basado en la fuente y la resolución de pantalla actuales.</summary>
        <value>El alto de la ventana de la consola más grande posible medido en filas.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="LargestWindowWidth">
      <MemberSignature Language="C#" Value="public static int LargestWindowWidth { get; }" />
      <MemberSignature Language="ILAsm" Value=".property int32 LargestWindowWidth" />
      <MemberSignature Language="DocId" Value="P:System.Console.LargestWindowWidth" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property LargestWindowWidth As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property int LargestWindowWidth { int get(); };" />
      <MemberSignature Language="F#" Value="member this.LargestWindowWidth : int" Usage="System.Console.LargestWindowWidth" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene el máximo número posible de columnas para la ventana de la consola, basado en la fuente y la resolución de pantalla actuales.</summary>
        <value>El ancho de la ventana de la consola más grande posible medido en columnas.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="MoveBufferArea">
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Copia un área de origen especificada del búfer de pantalla en un área de destino determinada.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="MoveBufferArea">
      <MemberSignature Language="C#" Value="public static void MoveBufferArea (int sourceLeft, int sourceTop, int sourceWidth, int sourceHeight, int targetLeft, int targetTop);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void MoveBufferArea(int32 sourceLeft, int32 sourceTop, int32 sourceWidth, int32 sourceHeight, int32 targetLeft, int32 targetTop) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.MoveBufferArea(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub MoveBufferArea (sourceLeft As Integer, sourceTop As Integer, sourceWidth As Integer, sourceHeight As Integer, targetLeft As Integer, targetTop As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void MoveBufferArea(int sourceLeft, int sourceTop, int sourceWidth, int sourceHeight, int targetLeft, int targetTop);" />
      <MemberSignature Language="F#" Value="static member MoveBufferArea : int * int * int * int * int * int -&gt; unit" Usage="System.Console.MoveBufferArea (sourceLeft, sourceTop, sourceWidth, sourceHeight, targetLeft, targetTop)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceLeft" Type="System.Int32" />
        <Parameter Name="sourceTop" Type="System.Int32" />
        <Parameter Name="sourceWidth" Type="System.Int32" />
        <Parameter Name="sourceHeight" Type="System.Int32" />
        <Parameter Name="targetLeft" Type="System.Int32" />
        <Parameter Name="targetTop" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="sourceLeft">Columna situada más a la izquierda del área de origen.</param>
        <param name="sourceTop">Fila superior del área de origen.</param>
        <param name="sourceWidth">Número de columnas en el área de origen.</param>
        <param name="sourceHeight">Número de filas en el área de origen.</param>
        <param name="targetLeft">Columna situada más a la izquierda del área de destino.</param>
        <param name="targetTop">Fila superior del área de destino.</param>
        <summary>Copia un área de origen especificada del búfer de pantalla en un área de destino determinada.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si los parámetros de origen y destino especifican una posición situada fuera de los límites del búfer de pantalla actual, se copiará solo la parte del área de origen que quepa en el área de destino. Es decir, el área de origen se recorta para ajustarse al búfer de pantalla actual.  
  
 El <xref:System.Console.MoveBufferArea%2A> método copia el área de origen en el área de destino. Si el área de destino no forman una intersección con el área de origen, el área de origen se rellena con espacios en blanco mediante los colores de primer plano y fondo actuales. En caso contrario, no se ha rellenado la parte cortada del área de origen.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Uno o varios parámetros son menores que cero.  
  
O bien 
 <paramref name="sourceLeft" /> o <paramref name="targetLeft" /> es mayor o igual que <see cref="P:System.Console.BufferWidth" />.  
  
O bien 
 <paramref name="sourceTop" /> o <paramref name="targetTop" /> es mayor o igual que <see cref="P:System.Console.BufferHeight" />.  
  
O bien 
 <paramref name="sourceTop" /> + <paramref name="sourceHeight" /> es mayor o igual que <see cref="P:System.Console.BufferHeight" />.  
  
O bien 
 <paramref name="sourceLeft" /> + <paramref name="sourceWidth" /> es mayor o igual que <see cref="P:System.Console.BufferWidth" />.</exception>
        <exception cref="T:System.Security.SecurityException">El usuario no tiene permiso para realizar esta acción.</exception>
        <exception cref="T:System.IO.IOException">Error de E/S.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">Para modificar las ventanas secundarias y ventanas seguras de nivel superior. Enumeración asociada: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
      </Docs>
    </Member>
    <Member MemberName="MoveBufferArea">
      <MemberSignature Language="C#" Value="public static void MoveBufferArea (int sourceLeft, int sourceTop, int sourceWidth, int sourceHeight, int targetLeft, int targetTop, char sourceChar, ConsoleColor sourceForeColor, ConsoleColor sourceBackColor);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void MoveBufferArea(int32 sourceLeft, int32 sourceTop, int32 sourceWidth, int32 sourceHeight, int32 targetLeft, int32 targetTop, char sourceChar, valuetype System.ConsoleColor sourceForeColor, valuetype System.ConsoleColor sourceBackColor) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.MoveBufferArea(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Char,System.ConsoleColor,System.ConsoleColor)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub MoveBufferArea (sourceLeft As Integer, sourceTop As Integer, sourceWidth As Integer, sourceHeight As Integer, targetLeft As Integer, targetTop As Integer, sourceChar As Char, sourceForeColor As ConsoleColor, sourceBackColor As ConsoleColor)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void MoveBufferArea(int sourceLeft, int sourceTop, int sourceWidth, int sourceHeight, int targetLeft, int targetTop, char sourceChar, ConsoleColor sourceForeColor, ConsoleColor sourceBackColor);" />
      <MemberSignature Language="F#" Value="static member MoveBufferArea : int * int * int * int * int * int * char * ConsoleColor * ConsoleColor -&gt; unit" Usage="System.Console.MoveBufferArea (sourceLeft, sourceTop, sourceWidth, sourceHeight, targetLeft, targetTop, sourceChar, sourceForeColor, sourceBackColor)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceLeft" Type="System.Int32" />
        <Parameter Name="sourceTop" Type="System.Int32" />
        <Parameter Name="sourceWidth" Type="System.Int32" />
        <Parameter Name="sourceHeight" Type="System.Int32" />
        <Parameter Name="targetLeft" Type="System.Int32" />
        <Parameter Name="targetTop" Type="System.Int32" />
        <Parameter Name="sourceChar" Type="System.Char" />
        <Parameter Name="sourceForeColor" Type="System.ConsoleColor" />
        <Parameter Name="sourceBackColor" Type="System.ConsoleColor" />
      </Parameters>
      <Docs>
        <param name="sourceLeft">Columna situada más a la izquierda del área de origen.</param>
        <param name="sourceTop">Fila superior del área de origen.</param>
        <param name="sourceWidth">Número de columnas en el área de origen.</param>
        <param name="sourceHeight">Número de filas en el área de origen.</param>
        <param name="targetLeft">Columna situada más a la izquierda del área de destino.</param>
        <param name="targetTop">Fila superior del área de destino.</param>
        <param name="sourceChar">Carácter que se usa para rellenar el área de origen.</param>
        <param name="sourceForeColor">Color de primer plano que se usa para rellenar el área de origen.</param>
        <param name="sourceBackColor">Color de fondo que se usa para rellenar el área de origen.</param>
        <summary>Copia un área de origen especificada del búfer de pantalla en un área de destino determinada.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si los parámetros de origen y destino especifican una posición situada más allá de los límites del búfer de pantalla actual, se copiará solo la parte del área de origen que quepa en el área de destino. Es decir, el área de origen se recorta para ajustarse al búfer de pantalla actual.  
  
 El <xref:System.Console.MoveBufferArea%2A> método copia el área de origen en el área de destino. Si el área de destino no forman una intersección con el área de origen, el área de origen se rellena con el carácter especificado por `sourceChar`, mediante los colores especificados por `sourceForeColor` y `sourceBackColor`. En caso contrario, no se ha rellenado la parte cortada del área de origen.  
  
 El <xref:System.Console.MoveBufferArea%2A> método no realiza ninguna operación si `sourceWidth` o `sourceHeight` es cero.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Uno o varios parámetros son menores que cero.  
  
O bien 
 <paramref name="sourceLeft" /> o <paramref name="targetLeft" /> es mayor o igual que <see cref="P:System.Console.BufferWidth" />.  
  
O bien 
 <paramref name="sourceTop" /> o <paramref name="targetTop" /> es mayor o igual que <see cref="P:System.Console.BufferHeight" />.  
  
O bien 
 <paramref name="sourceTop" /> + <paramref name="sourceHeight" /> es mayor o igual que <see cref="P:System.Console.BufferHeight" />.  
  
O bien 
 <paramref name="sourceLeft" /> + <paramref name="sourceWidth" /> es mayor o igual que <see cref="P:System.Console.BufferWidth" />.</exception>
        <exception cref="T:System.ArgumentException">Uno o ambos parámetros de color no son miembros de la enumeración <see cref="T:System.ConsoleColor" />.</exception>
        <exception cref="T:System.Security.SecurityException">El usuario no tiene permiso para realizar esta acción.</exception>
        <exception cref="T:System.IO.IOException">Error de E/S.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">Para modificar las ventanas secundarias y ventanas seguras de nivel superior. Enumeración asociada: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
      </Docs>
    </Member>
    <Member MemberName="NumberLock">
      <MemberSignature Language="C#" Value="public static bool NumberLock { get; }" />
      <MemberSignature Language="ILAsm" Value=".property bool NumberLock" />
      <MemberSignature Language="DocId" Value="P:System.Console.NumberLock" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property NumberLock As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool NumberLock { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.NumberLock : bool" Usage="System.Console.NumberLock" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene un valor que indica si está activada o desactivada la alternancia de teclado de BLOQ NUM.</summary>
        <value><see langword="true" /> si está activado BLOQ NUM; <see langword="false" /> si está desactivado BLOQ NUM.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="OpenStandardError">
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Adquiere el flujo de error estándar.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="OpenStandardError">
      <MemberSignature Language="C#" Value="public static System.IO.Stream OpenStandardError ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.Stream OpenStandardError() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.OpenStandardError" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OpenStandardError () As Stream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::Stream ^ OpenStandardError();" />
      <MemberSignature Language="F#" Value="static member OpenStandardError : unit -&gt; System.IO.Stream" Usage="System.Console.OpenStandardError " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Stream</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Adquiere el flujo de error estándar.</summary>
        <returns>El flujo de error estándar.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método se puede utilizar para volver a adquirir el flujo de error estándar después de ha cambiado el <xref:System.Console.SetError%2A> método.  
  
   
  
## Examples  
 El ejemplo siguiente es un visor de archivos de texto simple que muestra el contenido de uno o varios archivos de texto en la consola. Si no hay ningún argumento de línea de comandos, o si no existen los archivos que se pasan como argumentos de línea de comandos, el ejemplo llama a la <xref:System.Console.SetError%2A> llama al método para redirigir la información de error a un archivo, el <xref:System.Console.OpenStandardError%2A> método en el proceso de volver a adquirir el error estándar transmitir e indica que se escribió la información de error a un archivo.  
  
 [!code-csharp[System.Console.OpenStandardError#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.console.openstandarderror/cs/viewtextfile.cs#1)]
 [!code-vb[System.Console.OpenStandardError#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.console.openstandarderror/vb/viewtextfile.vb#1)]  
  
 Tenga en cuenta que el <xref:System.IO.StreamWriter.AutoFlush%2A?displayProperty=nameWithType> propiedad está establecida en `true` antes de volver a adquirir el flujo de error. Esto garantiza que salida se envía inmediatamente a la consola en lugar de almacenado en búfer.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Console.Error" />
        <altmember cref="P:System.Console.IsErrorRedirected" />
        <altmember cref="M:System.Console.SetError(System.IO.TextWriter)" />
      </Docs>
    </Member>
    <Member MemberName="OpenStandardError">
      <MemberSignature Language="C#" Value="public static System.IO.Stream OpenStandardError (int bufferSize);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.Stream OpenStandardError(int32 bufferSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.OpenStandardError(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OpenStandardError (bufferSize As Integer) As Stream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::Stream ^ OpenStandardError(int bufferSize);" />
      <MemberSignature Language="F#" Value="static member OpenStandardError : int -&gt; System.IO.Stream" Usage="System.Console.OpenStandardError bufferSize" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Stream</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bufferSize" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="bufferSize">Tamaño del búfer de flujo interno.</param>
        <summary>Adquiere el flujo de error estándar, que se establece en un tamaño de búfer especificado.</summary>
        <returns>El flujo de error estándar.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método se puede utilizar para volver a adquirir el flujo de error estándar después de ha cambiado el <xref:System.Console.SetError%2A> método.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="bufferSize" /> es menor o igual que cero.</exception>
        <altmember cref="P:System.Console.Error" />
        <altmember cref="P:System.Console.IsErrorRedirected" />
        <altmember cref="M:System.Console.SetError(System.IO.TextWriter)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="OpenStandardInput">
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Adquiere el flujo de entrada estándar.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="OpenStandardInput">
      <MemberSignature Language="C#" Value="public static System.IO.Stream OpenStandardInput ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.Stream OpenStandardInput() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.OpenStandardInput" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OpenStandardInput () As Stream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::Stream ^ OpenStandardInput();" />
      <MemberSignature Language="F#" Value="static member OpenStandardInput : unit -&gt; System.IO.Stream" Usage="System.Console.OpenStandardInput " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Stream</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Adquiere el flujo de entrada estándar.</summary>
        <returns>Flujo de entrada estándar.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método se puede utilizar para volver a adquirir el flujo de entrada estándar después de ha cambiado el <xref:System.Console.SetIn%2A> método.  
  
   
  
## Examples  
 El ejemplo siguiente muestra el uso de la `OpenStandardInput` propiedad.  
  
 [!code-cpp[System.Console.OpenStandartInput#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Console.OpenStandartInput/CPP/decode.cpp#1)]
 [!code-csharp[System.Console.OpenStandartInput#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Console.OpenStandartInput/CS/decode.cs#1)]
 [!code-vb[System.Console.OpenStandartInput#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Console.OpenStandartInput/VB/decode.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Console.In" />
        <altmember cref="P:System.Console.IsInputRedirected" />
        <altmember cref="M:System.Console.SetIn(System.IO.TextReader)" />
      </Docs>
    </Member>
    <Member MemberName="OpenStandardInput">
      <MemberSignature Language="C#" Value="public static System.IO.Stream OpenStandardInput (int bufferSize);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.Stream OpenStandardInput(int32 bufferSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.OpenStandardInput(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OpenStandardInput (bufferSize As Integer) As Stream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::Stream ^ OpenStandardInput(int bufferSize);" />
      <MemberSignature Language="F#" Value="static member OpenStandardInput : int -&gt; System.IO.Stream" Usage="System.Console.OpenStandardInput bufferSize" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Stream</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bufferSize" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="bufferSize">Tamaño del búfer de flujo interno.</param>
        <summary>Adquiere el flujo de entrada estándar, que se establece en un tamaño de búfer especificado.</summary>
        <returns>Flujo de entrada estándar.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método se puede utilizar para volver a adquirir el flujo de salida estándar después de ha cambiado el <xref:System.Console.SetIn%2A> método.  
  
   
  
## Examples  
 El ejemplo siguiente muestra el uso de la `OpenStandardInput` propiedad.  
  
 [!code-cpp[System.Console.OpenStandartInput#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Console.OpenStandartInput/CPP/decode.cpp#1)]
 [!code-csharp[System.Console.OpenStandartInput#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Console.OpenStandartInput/CS/decode.cs#1)]
 [!code-vb[System.Console.OpenStandartInput#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Console.OpenStandartInput/VB/decode.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="bufferSize" /> es menor o igual que cero.</exception>
        <altmember cref="P:System.Console.In" />
        <altmember cref="P:System.Console.IsInputRedirected" />
        <altmember cref="M:System.Console.SetIn(System.IO.TextReader)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="OpenStandardOutput">
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Adquiere el flujo de salida estándar.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="OpenStandardOutput">
      <MemberSignature Language="C#" Value="public static System.IO.Stream OpenStandardOutput ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.Stream OpenStandardOutput() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.OpenStandardOutput" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OpenStandardOutput () As Stream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::Stream ^ OpenStandardOutput();" />
      <MemberSignature Language="F#" Value="static member OpenStandardOutput : unit -&gt; System.IO.Stream" Usage="System.Console.OpenStandardOutput " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Stream</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Adquiere el flujo de salida estándar.</summary>
        <returns>Flujo de salida estándar.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método se puede utilizar para volver a adquirir el flujo de salida estándar después de ha cambiado el <xref:System.Console.SetOut%2A> método.  
  
   
  
## Examples  
 En el ejemplo siguiente se muestra el uso del método <xref:System.Console.OpenStandardOutput%2A>. Reemplaza cuatro caracteres de espacio consecutivos en una cadena con un carácter de tabulación. Para ejecutarlo, debe proporcionar dos argumentos de línea de comandos. El primero es el nombre de un archivo de texto existente al que se va a redirigir el flujo de entrada estándar. El segundo es el nombre de un archivo al que se va a redirigir el flujo de salida estándar. No es necesario que exista este archivo. Si existe, se sobrescribirá su contenido.  
  
 [!code-cpp[System.Console-INSERTTABS#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Console-INSERTTABS/CPP/inserttabs.cpp#1)]
 [!code-csharp[System.Console-INSERTTABS#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Console-INSERTTABS/CS/inserttabs.cs#1)]
 [!code-vb[System.Console-INSERTTABS#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Console-INSERTTABS/VB/inserttabs.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Console.Out" />
        <altmember cref="P:System.Console.IsOutputRedirected" />
        <altmember cref="M:System.Console.SetOut(System.IO.TextWriter)" />
      </Docs>
    </Member>
    <Member MemberName="OpenStandardOutput">
      <MemberSignature Language="C#" Value="public static System.IO.Stream OpenStandardOutput (int bufferSize);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.Stream OpenStandardOutput(int32 bufferSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.OpenStandardOutput(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OpenStandardOutput (bufferSize As Integer) As Stream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::Stream ^ OpenStandardOutput(int bufferSize);" />
      <MemberSignature Language="F#" Value="static member OpenStandardOutput : int -&gt; System.IO.Stream" Usage="System.Console.OpenStandardOutput bufferSize" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Stream</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bufferSize" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="bufferSize">Tamaño del búfer de flujo interno.</param>
        <summary>Adquiere el flujo de salida estándar, que se establece en un tamaño de búfer especificado.</summary>
        <returns>Flujo de salida estándar.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método se puede utilizar para volver a adquirir el flujo de salida estándar después de ha cambiado el <xref:System.Console.SetOut%2A> método.  
  
   
  
## Examples  
 En el ejemplo siguiente se muestra el uso del método <xref:System.Console.OpenStandardOutput%2A>. Reemplaza cuatro caracteres de espacio consecutivos en una cadena con un carácter de tabulación. Para ejecutarlo, debe proporcionar dos argumentos de línea de comandos. El primero es el nombre de un archivo de texto existente al que se va a redirigir el flujo de entrada estándar. El segundo es el nombre de un archivo al que se va a redirigir el flujo de salida estándar. No es necesario que exista este archivo. Si existe, se sobrescribirá su contenido.  
  
 [!code-cpp[System.Console-INSERTTABS#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Console-INSERTTABS/CPP/inserttabs.cpp#1)]
 [!code-csharp[System.Console-INSERTTABS#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Console-INSERTTABS/CS/inserttabs.cs#1)]
 [!code-vb[System.Console-INSERTTABS#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Console-INSERTTABS/VB/inserttabs.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="bufferSize" /> es menor o igual que cero.</exception>
        <altmember cref="P:System.Console.Out" />
        <altmember cref="P:System.Console.IsOutputRedirected" />
        <altmember cref="M:System.Console.SetOut(System.IO.TextWriter)" />
      </Docs>
    </Member>
    <Member MemberName="Out">
      <MemberSignature Language="C#" Value="public static System.IO.TextWriter Out { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.IO.TextWriter Out" />
      <MemberSignature Language="DocId" Value="P:System.Console.Out" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property Out As TextWriter" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::IO::TextWriter ^ Out { System::IO::TextWriter ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Out : System.IO.TextWriter" Usage="System.Console.Out" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.TextWriter</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene el flujo de salida estándar.</summary>
        <value><see cref="T:System.IO.TextWriter" /> que representa el flujo de salida estándar.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esta propiedad se establece en el flujo de salida estándar de forma predeterminada. Esta propiedad puede establecerse en otra secuencia con el <xref:System.Console.SetOut%2A> método.  
  
 Tenga en cuenta que las llamadas a `Console.Out.WriteLine` son equivalentes a las llamadas a los correspondientes métodos <xref:System.Console.WriteLine%2A> métodos.  
  
   
  
## Examples  
 En el ejemplo siguiente se usa el <xref:System.Console.Out%2A> propiedad para mostrar una matriz que contiene los nombres de archivos en el directorio actual de la aplicación en el dispositivo de salida estándar. A continuación, Establece la salida estándar a un archivo denominado Files.txt y enumera los elementos de matriz en el archivo. Por último, la salida se establece en el flujo de salida estándar y de nuevo muestra los elementos de matriz para el dispositivo de salida estándar.  
  
 [!code-csharp[System.Console.Out#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.console.out/cs/out1.cs#1)]
 [!code-vb[System.Console.Out#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.console.out/vb/out1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Console.Error" />
        <altmember cref="P:System.Console.In" />
        <altmember cref="M:System.Console.SetOut(System.IO.TextWriter)" />
      </Docs>
    </Member>
    <Member MemberName="OutputEncoding">
      <MemberSignature Language="C#" Value="public static System.Text.Encoding OutputEncoding { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Text.Encoding OutputEncoding" />
      <MemberSignature Language="DocId" Value="P:System.Console.OutputEncoding" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property OutputEncoding As Encoding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Text::Encoding ^ OutputEncoding { System::Text::Encoding ^ get(); void set(System::Text::Encoding ^ value); };" />
      <MemberSignature Language="F#" Value="member this.OutputEncoding : System.Text.Encoding with get, set" Usage="System.Console.OutputEncoding" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>set: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece la codificación que usa la consola para escribir la salida.</summary>
        <value>Codificación usada para escribir la salida de la consola.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La consola utiliza la codificación de salida para convertir los caracteres escritos por una aplicación en los caracteres correspondientes de presentación de consola. La página de códigos predeterminada que utiliza la consola viene determinada por la configuración regional del sistema.  
  
 A partir de la [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], una operación get de propiedad puede devolver un valor almacenado en caché en lugar de codificación de salida actual de la consola. Esto puede ocurrir si el valor de la <xref:System.Console.OutputEncoding%2A> se modifica la propiedad por otros medios distintos a una asignación a la <xref:System.Console.OutputEncoding%2A> propiedad, como llamar a la Windows `SetConsoleOutputCP` función.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El valor de la propiedad en una operación de conjunto es <see langword="null" />.</exception>
        <exception cref="T:System.IO.IOException">Error durante la ejecución de esta operación.</exception>
        <exception cref="T:System.Security.SecurityException">Tu aplicación no tiene permiso para realizar esta operación.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">para leer y escribir en las ventanas secundarias y ventanas de nivel superior.  Enumeración asociada: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
        <block subset="none" type="usage"><para>De las codificaciones Unicode, el <see cref="T:System.Console" /> clase admite la codificación con UTF-8 el <see cref="T:System.Text.UTF8Encoding" /> clase y, a partir de la [!INCLUDE[net_v45](~/includes/net-v45-md.md)], admite la codificación con UTF-16 el <see cref="T:System.Text.UnicodeEncoding" /> clase. Codificación UTF-32 con el <see cref="T:System.Text.UTF32Encoding" /> clase no se admite. Al intentar establecer la codificación de salida a UTF-32 produce una <see cref="T:System.IO.IOException" />.  
  
Tenga en cuenta que mostrar correctamente los caracteres Unicode en la consola requiere lo siguiente: 
-La consola debe usar una fuente TrueType, como Lucida Console o Consolas, para mostrar caracteres.  
  
-Una fuente usada por la consola debe definir el glifo concreto o glifos para mostrarse. La consola puede sacar partido de vinculación para mostrar glifos de fuentes vinculados si la fuente base no contiene una definición para ese glifo de fuentes.  
  
Para obtener más información sobre la compatibilidad con Unicode codificación mediante la consola, consulte la sección "Unicode admite para la consola de" en el <see cref="T:System.Console" /> clase.</para></block>
      </Docs>
    </Member>
    <Member MemberName="Read">
      <MemberSignature Language="C#" Value="public static int Read ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Read() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.Read" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Read () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Read();" />
      <MemberSignature Language="F#" Value="static member Read : unit -&gt; int" Usage="System.Console.Read " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Lee el siguiente carácter del flujo de entrada estándar.</summary>
        <returns>El carácter siguiente del flujo de entrada o menos uno (-1) si no hay actualmente más caracteres que leer.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Console.Read%2A> método bloquea su devolución al escribir caracteres de entrada; de lo finaliza al presionar el <xref:System.ConsoleKey.Enter> clave. Al presionar ENTRAR, anexa una secuencia de terminación de la línea depende de la plataforma a la entrada (por ejemplo, Windows agrega una secuencia de retorno de carro). Las llamadas posteriores a la <xref:System.Console.Read%2A> método recuperar un carácter de entrada a la vez. Después de recupera el último carácter, <xref:System.Console.Read%2A> bloquea su resultado nuevo y el ciclo se repite.  
  
> [!IMPORTANT]
>  El <xref:System.Console.ReadLine%2A> método, o la <xref:System.Console.KeyAvailable%2A> propiedad y <xref:System.Console.ReadKey%2A> método es preferible utilizar la <xref:System.Console.Read%2A> método.  
  
 Tenga en cuenta que el método no devuelve -1 a menos que realice una de las acciones siguientes:  
  
-   Presione simultáneamente la <xref:System.ConsoleModifiers.Control> tecla modificadora y <xref:System.ConsoleKey.Z> tecla de consola (Ctrl + Z), lo cual indica la condición de final de archivo.  
  
-   Presione una clave equivalente a la que señala la condición de final de archivo, como la tecla de función F6 en Windows.  
  
-   Redirigir el flujo de entrada a un origen, como un archivo de texto, que tiene un carácter de final de archivo real.  
  
   
  
## Examples  
 En el ejemplo siguiente se muestra el <xref:System.Console.Read%2A> método.  
  
 [!code-cpp[console.read#1](~/samples/snippets/cpp/VS_Snippets_CLR/console.read/CPP/read.cpp#1)]
 [!code-csharp[console.read#1](~/samples/snippets/csharp/VS_Snippets_CLR/console.read/CS/read.cs#1)]
 [!code-vb[console.read#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/console.read/VB/read.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Error de E/S.</exception>
        <altmember cref="M:System.Console.ReadLine" />
        <altmember cref="M:System.Console.Write(System.String,System.Object)" />
        <altmember cref="M:System.Console.WriteLine" />
      </Docs>
    </Member>
    <MemberGroup MemberName="ReadKey">
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Obtiene la siguiente tecla de carácter o de función presionada por el usuario.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReadKey">
      <MemberSignature Language="C#" Value="public static ConsoleKeyInfo ReadKey ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.ConsoleKeyInfo ReadKey() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.ReadKey" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReadKey () As ConsoleKeyInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static ConsoleKeyInfo ReadKey();" />
      <MemberSignature Language="F#" Value="static member ReadKey : unit -&gt; ConsoleKeyInfo" Usage="System.Console.ReadKey " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ConsoleKeyInfo</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Obtiene la siguiente tecla de carácter o de función presionada por el usuario. La tecla presionada se muestra en la ventana de la consola.</summary>
        <returns>Objeto que describe la constante <see cref="T:System.ConsoleKey" /> y el carácter Unicode, si existe, que corresponden a la tecla presionada de la consola. El objeto <see cref="T:System.ConsoleKeyInfo" /> también describe, en una combinación bit a bit de valores de <see cref="T:System.ConsoleModifiers" />, si alguna de las teclas modificadoras Mayús, Alt o Ctrl se presionaron al mismo tiempo que la tecla de la consola.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Console.ReadKey%2A> método espera, es decir, los bloques en la emisión de subproceso el <xref:System.Console.ReadKey%2A> método hasta que se presiona una tecla de carácter o de función. Puede presionar una tecla de carácter o de función en combinación con uno o más teclas modificadoras MAYÚS, Ctrl o Alt. Sin embargo, al presionar una tecla modificadora por sí solo no provocará la <xref:System.Console.ReadKey%2A> método devuelva.  
  
 Dependiendo de la aplicación, es posible que desee usar el <xref:System.Console.ReadKey%2A> método junto con el <xref:System.Console.KeyAvailable%2A> propiedad.  
  
 El <xref:System.Console.ReadKey%2A> método lee desde el teclado, incluso si la entrada estándar se redirige a un archivo con el <xref:System.Console.SetIn%2A> método.  
  
   
  
## Examples  
 Se utiliza uno de los más comunes de la <xref:System.Console.ReadKey> método consiste en detener la ejecución del programa hasta que el usuario presiona una tecla y la aplicación finaliza o muestra una ventana de información adicional. En el ejemplo siguiente se usa el <xref:System.Console.ReadKey> método espera para que el usuario presione la tecla ENTRAR antes de finalizar la aplicación.  
  
 [!code-csharp[System.Console.ReadKey#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Console.ReadKey/cs/ReadKey1.cs#1)]
 [!code-vb[System.Console.ReadKey#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Console.ReadKey/vb/ReadKey1.vb#1)]  
  
 Tenga en cuenta que esta sobrecarga de la <xref:System.Console.ReadKey%2A> método predeterminada devuelve las claves que se puede mostrar que el usuario presiona a la consola. Para suprimirlos, llame a la <xref:System.Console.ReadKey%2A> método con un `intercept` argumento de `true`.  
  
 En el ejemplo siguiente se usa el <xref:System.Console.ReadKey> método para mostrar información acerca de la clave que el usuario presionó. 
  
 [!code-cpp[console.readkey1#1](~/samples/snippets/cpp/VS_Snippets_CLR/console.readkey1/CPP/rk.cpp#1)]
 [!code-csharp[console.readkey1#1](~/samples/snippets/csharp/VS_Snippets_CLR/console.readkey1/CS/rk.cs#1)]
 [!code-vb[console.readkey1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/console.readkey1/VB/rk.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">La propiedad <see cref="P:System.Console.In" /> se ha redirigido desde alguna otra secuencia distinta de la consola.</exception>
        <altmember cref="T:System.ConsoleKey" />
        <altmember cref="P:System.Console.KeyAvailable" />
        <altmember cref="P:System.Console.TreatControlCAsInput" />
        <altmember cref="E:System.Console.CancelKeyPress" />
      </Docs>
    </Member>
    <Member MemberName="ReadKey">
      <MemberSignature Language="C#" Value="public static ConsoleKeyInfo ReadKey (bool intercept);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.ConsoleKeyInfo ReadKey(bool intercept) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.ReadKey(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReadKey (intercept As Boolean) As ConsoleKeyInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static ConsoleKeyInfo ReadKey(bool intercept);" />
      <MemberSignature Language="F#" Value="static member ReadKey : bool -&gt; ConsoleKeyInfo" Usage="System.Console.ReadKey intercept" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ConsoleKeyInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="intercept" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="intercept">Determina si la tecla presionada se muestra en la ventana de la consola. <see langword="true" /> para que no se muestre la tecla presionada; de lo contrario, <see langword="false" />.</param>
        <summary>Obtiene la siguiente tecla de carácter o de función presionada por el usuario. Opcionalmente, la tecla presionada se muestra en la ventana de la consola.</summary>
        <returns>Objeto que describe la constante <see cref="T:System.ConsoleKey" /> y el carácter Unicode, si existe, que corresponden a la tecla presionada de la consola. El objeto <see cref="T:System.ConsoleKeyInfo" /> también describe, en una combinación bit a bit de valores de <see cref="T:System.ConsoleModifiers" />, si alguna de las teclas modificadoras Mayús, Alt o Ctrl se presionaron al mismo tiempo que la tecla de la consola.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Console.ReadKey%2A> método espera, es decir, los bloques en la emisión de subproceso el <xref:System.Console.ReadKey%2A> método hasta que se presiona una tecla de carácter o de función. Puede presionar una tecla de carácter o de función en combinación con uno o más teclas modificadoras MAYÚS, Ctrl o Alt. Sin embargo, al presionar una tecla modificadora por sí solo no provocará la <xref:System.Console.ReadKey%2A> método devuelva.  
  
 Si el `intercept` parámetro es `true`, la tecla presionada se intercepta y no aparecen en la ventana de consola; en caso contrario, la tecla presionada se muestra.  
  
 Dependiendo de la aplicación, es posible que desee usar el <xref:System.Console.ReadKey%2A> método junto con el <xref:System.Console.KeyAvailable%2A> propiedad.  
  
 El <xref:System.Console.ReadKey%2A> método lee desde el teclado, incluso si la entrada estándar se redirige a un archivo con el <xref:System.Console.SetIn%2A> método.  
  
   
  
## Examples  
 Se utiliza uno de los más comunes de la <xref:System.Console.ReadKey%2A> método consiste en detener la ejecución del programa hasta que el usuario presiona una tecla y la aplicación finaliza o muestra una ventana de información adicional. En el ejemplo siguiente se usa el <xref:System.Console.ReadKey%28System.Boolean%29> método espera para que el usuario presione la tecla ENTRAR antes de finalizar la aplicación. Tenga en cuenta que, si el usuario presiona cualquier otra clave, no se muestra en la consola.  
  
 [!code-csharp[System.Console.ReadKey#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Console.ReadKey/cs/ReadKey2.cs#2)]
 [!code-vb[System.Console.ReadKey#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Console.ReadKey/vb/ReadKey2.vb#2)]  
  
 En el ejemplo siguiente se usa el <xref:System.Console.ReadKey%28System.Boolean%29> método para mostrar información sobre la tecla presionada por un usuario sin reflejar esa clave en la consola.  
  
 [!code-cpp[console.readkey2#1](~/samples/snippets/cpp/VS_Snippets_CLR/console.readkey2/CPP/rkbool.cpp#1)]
 [!code-csharp[console.readkey2#1](~/samples/snippets/csharp/VS_Snippets_CLR/console.readkey2/CS/rkbool.cs#1)]
 [!code-vb[console.readkey2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/console.readkey2/VB/rkbool.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">La propiedad <see cref="P:System.Console.In" /> se ha redirigido desde alguna otra secuencia distinta de la consola.</exception>
        <altmember cref="T:System.ConsoleKey" />
        <altmember cref="P:System.Console.KeyAvailable" />
        <altmember cref="P:System.Console.TreatControlCAsInput" />
        <altmember cref="E:System.Console.CancelKeyPress" />
      </Docs>
    </Member>
    <Member MemberName="ReadLine">
      <MemberSignature Language="C#" Value="public static string ReadLine ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string ReadLine() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.ReadLine" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReadLine () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ ReadLine();" />
      <MemberSignature Language="F#" Value="static member ReadLine : unit -&gt; string" Usage="System.Console.ReadLine " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Lee la siguiente línea de caracteres del flujo de entrada estándar.</summary>
        <returns>La siguiente línea de caracteres del flujo de entrada o <see langword="null" /> si no hay más líneas disponibles.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Console.ReadLine%2A> método lee una línea de la secuencia de entrada estándar. (Para la definición de una línea, consulte el párrafo después de la lista siguiente). Esto significa que:  
  
-   Si el dispositivo de entrada estándar es el teclado, el <xref:System.Console.ReadLine%2A> método se bloquea hasta que el usuario presiona el **ENTRAR** clave.  
  
     Se utiliza uno de los más comunes de la <xref:System.Console.ReadLine%2A> método es para pausar la ejecución del programa antes de borrar la consola y muestra información nueva a él, o para solicitar al usuario que presione la tecla ENTRAR antes de finalizar la aplicación. Esto se ilustra en el siguiente ejemplo:  
  
     [!code-cpp[System.Console.ReadLine#6](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Console.ReadLine/cpp/ReadLineSimple.cpp#6)]
     [!code-csharp[System.Console.ReadLine#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Console.ReadLine/cs/ReadLineSimple.cs#6)]
     [!code-vb[System.Console.ReadLine#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Console.ReadLine/vb/ReadLineSimple.vb#6)]  
  
-   Si la entrada estándar se redirige a un archivo, el <xref:System.Console.ReadLine%2A> método lee una línea de texto de un archivo. Por ejemplo, este es un archivo de texto denominado ReadLine1.txt:  
  
    ```  
  
    This is the first line.  
    This is the second line.  
    This is the third line.  
    This is the fourth line.  
  
    ```  
  
     En el ejemplo siguiente se usa el <xref:System.Console.ReadLine%2A> método para leer la entrada que se redirige desde un archivo. La operación de lectura finaliza cuando el método devuelve `null`, lo que indica que no hay ninguna línea permanecen para poder leerse.  
  
     [!code-csharp[System.Console.ReadLine#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Console.ReadLine/cs/ReadLine3.cs#3)]
     [!code-vb[System.Console.ReadLine#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Console.ReadLine/vb/ReadLine3.vb#3)]  
  
     Después de compilar el ejemplo a un ejecutable ReadLine1.exe con nombre, puede ejecutarlo desde la línea de comandos con la sintaxis  
  
    ```  
    ReadLine1 < ReadLine1.txt  
    ```  
  
     para leer el contenido del archivo y mostrarlos en la consola.  
  
 Una línea se define como una secuencia de caracteres seguida de un retorno de carro (hexadecimal 0x000d), un avance de línea (hexadecimal 0x000a) o el valor de la <xref:System.Environment.NewLine%2A?displayProperty=nameWithType> propiedad. La cadena devuelta no contiene los caracteres de terminación. De forma predeterminada, el método lee la entrada de un búfer de entrada de 256 caracteres. Dado que esto incluye la <xref:System.Environment.NewLine%2A?displayProperty=nameWithType> caracteres, el método puede leer las líneas que contienen hasta 254 caracteres. Para leer las líneas más largas, llame a la <xref:System.Console.OpenStandardInput%28System.Int32%29> método.  
  
 El <xref:System.Console.ReadLine%2A> método se ejecuta de forma sincrónica. Es decir, se bloquea hasta que se lee una línea o se presiona la combinación de teclado Ctrl + Z. El <xref:System.Console.In%2A> propiedad devuelve un <xref:System.IO.TextReader> objeto que representa el flujo de entrada estándar y que tiene ambos sincrónica <xref:System.IO.TextReader.ReadLine%2A?displayProperty=nameWithType> método y asincrónico <xref:System.IO.TextReader.ReadLineAsync%2A?displayProperty=nameWithType> método. Sin embargo, cuando se usa como flujo de entrada estándar de la consola, el <xref:System.IO.TextReader.ReadLineAsync%2A?displayProperty=nameWithType> ejecuta sincrónicamente en lugar de forma asincrónica y devuelve un `Task<String>` solo después de que se ha completado la operación de lectura.  
  
 Si este método produce una <xref:System.OutOfMemoryException> excepción, la posición del lector en subyacente <xref:System.IO.Stream> objeto avanza por el número de caracteres que el método fue capaz de leer, pero los caracteres ya leídos en el interno <xref:System.Console.ReadLine%2A> búfer son se descartan. Puesto que no se puede cambiar la posición del lector en la secuencia, los caracteres leídos ya son irrecuperables y puede tener acceso a solo reinicializando la <xref:System.IO.TextReader>. Si la posición inicial dentro de la secuencia es desconocida o la secuencia no admite búsquedas, subyacente <xref:System.IO.Stream> también es necesario reinicializar. Para evitar esta situación y generar código robusto, debe usar el <xref:System.Console.KeyAvailable%2A> propiedad y <xref:System.Console.ReadKey%2A> método y el almacén de los caracteres de lectura en un búfer asignado previamente.  
  
 Si se presiona el carácter CTRL+z cuando el método es leer la entrada desde la consola, el método devuelve `null`. Esto permite que el usuario para evitar que el teclado más entrada cuando el <xref:System.Console.ReadLine%2A> se llama al método en un bucle. El ejemplo siguiente muestra este escenario.  
  
 [!code-cpp[System.Console.ReadLine#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Console.ReadLine/cpp/readline2.cpp#1)]
 [!code-csharp[System.Console.ReadLine#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Console.ReadLine/cs/ReadLine2.cs#1)]
 [!code-vb[System.Console.ReadLine#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Console.ReadLine/vb/ReadLine2.vb#1)]  
  
   
  
## Examples  
 El ejemplo siguiente requiere dos argumentos de línea de comandos: el nombre de un archivo de texto existente y el nombre de un archivo para escribir la salida. Se abre el archivo de texto existente y redirige la entrada desde el teclado estándar para ese archivo. Además, redirige la salida estándar desde la consola en el archivo de salida. A continuación, usa el <xref:System.Console.ReadLine%2A?displayProperty=nameWithType> método para leer cada línea en el archivo, reemplaza cada secuencia de cuatro espacios por un carácter de tabulación y utiliza el <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> método para escribir el resultado en el archivo de salida.  
  
 [!code-cpp[System.Console-INSERTTABS#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Console-INSERTTABS/CPP/inserttabs.cpp#1)]
 [!code-csharp[System.Console-INSERTTABS#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Console-INSERTTABS/CS/inserttabs.cs#1)]
 [!code-vb[System.Console-INSERTTABS#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Console-INSERTTABS/VB/inserttabs.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Error de E/S.</exception>
        <exception cref="T:System.OutOfMemoryException">No hay memoria suficiente para asignar un búfer para la cadena devuelta.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">El número de caracteres de la siguiente línea de caracteres es mayor que <see cref="F:System.Int32.MaxValue" />.</exception>
        <altmember cref="M:System.Console.Read" />
        <altmember cref="M:System.Console.Write(System.String,System.Object)" />
        <altmember cref="M:System.Console.WriteLine" />
      </Docs>
    </Member>
    <Member MemberName="ResetColor">
      <MemberSignature Language="C#" Value="public static void ResetColor ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void ResetColor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.ResetColor" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub ResetColor ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void ResetColor();" />
      <MemberSignature Language="F#" Value="static member ResetColor : unit -&gt; unit" Usage="System.Console.ResetColor " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Establece los colores de primer plano y de fondo de la consola en sus valores predeterminados.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Los colores de primer y segundo plano se restauran en los colores que existían cuando se inició el proceso actual. Para obtener más información, consulte el <xref:System.Console.ForegroundColor%2A> y <xref:System.Console.BackgroundColor%2A> propiedades.  
  
   
  
## Examples  
 En el ejemplo siguiente se guarda los valores de la <xref:System.ConsoleColor> enumeración en una matriz y almacena los valores actuales de la <xref:System.Console.BackgroundColor%2A> y <xref:System.Console.ForegroundColor%2A> propiedades a las variables. A continuación, cambia el color de primer plano para cada color en el <xref:System.ConsoleColor> enumeración, excepto en el color que coincida con el fondo actual, y cambia el color de fondo a cada color en el <xref:System.ConsoleColor> enumeración excepto en el color que coincide con el primer plano actual. (Si el color de primer plano es el mismo que el color de fondo, el texto no está visible.) Por último, llama a la <xref:System.Console.ResetColor%2A> método para restablecer los colores de consola original.  
  
 [!code-csharp[System.ConsoleColor#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.consolecolor/cs/foregroundcolor3.cs#1)]
 [!code-vb[System.ConsoleColor#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.consolecolor/vb/foregroundcolor3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">El usuario no tiene permiso para realizar esta acción.</exception>
        <exception cref="T:System.IO.IOException">Error de E/S.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">Para modificar las ventanas secundarias y ventanas seguras de nivel superior. Enumeración asociada: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
      </Docs>
    </Member>
    <Member MemberName="SetBufferSize">
      <MemberSignature Language="C#" Value="public static void SetBufferSize (int width, int height);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetBufferSize(int32 width, int32 height) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.SetBufferSize(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetBufferSize (width As Integer, height As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetBufferSize(int width, int height);" />
      <MemberSignature Language="F#" Value="static member SetBufferSize : int * int -&gt; unit" Usage="System.Console.SetBufferSize (width, height)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="width" Type="System.Int32" />
        <Parameter Name="height" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="width">Ancho del área del búfer medido en columnas.</param>
        <param name="height">Alto del área del búfer medido en filas.</param>
        <summary>Establece el alto y el ancho del área del búfer de pantalla en los valores especificados.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 En el ejemplo siguiente se muestra el <xref:System.Console.WindowLeft%2A>, <xref:System.Console.WindowTop%2A>, <xref:System.Console.WindowWidth%2A>, <xref:System.Console.WindowHeight%2A>, <xref:System.Console.BufferWidth%2A>, <xref:System.Console.BufferHeight%2A>, y <xref:System.Console.CursorVisible%2A> propiedades; y la <xref:System.Console.SetWindowPosition%2A>, <xref:System.Console.SetBufferSize%2A>, y <xref:System.Console.ReadKey%2A> métodos. En el ejemplo se dibuja un patrón de cuadrícula en el búfer de pantalla según el ancho del búfer de pantalla. A continuación, en el ejemplo se mueve la ventana de consola en respuesta a las que la flecha arriba, se presionan teclas de consola de flecha abajo, flecha izquierda o flecha derecha. El patrón de cuadrícula ayuda a ver el movimiento de la ventana de consola con respecto al búfer de pantalla.  
  
 [!code-cpp[console.windowLT#1](~/samples/snippets/cpp/VS_Snippets_CLR/console.windowLT/CPP/wlt.cpp#1)]
 [!code-csharp[console.windowLT#1](~/samples/snippets/csharp/VS_Snippets_CLR/console.windowLT/CS/wlt.cs#1)]
 [!code-vb[console.windowLT#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/console.windowLT/VB/wlt.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="height" /> o <paramref name="width" /> es menor o igual que cero.  
  
O bien 
 <paramref name="height" /> o <paramref name="width" /> es mayor o igual que <see cref="F:System.Int16.MaxValue" />.  
  
O bien 
 <paramref name="width" /> es menor que <see cref="P:System.Console.WindowLeft" /> + <see cref="P:System.Console.WindowWidth" />.  
  
O bien 
 <paramref name="height" /> es menor que <see cref="P:System.Console.WindowTop" /> + <see cref="P:System.Console.WindowHeight" />.</exception>
        <exception cref="T:System.Security.SecurityException">El usuario no tiene permiso para realizar esta acción.</exception>
        <exception cref="T:System.IO.IOException">Error de E/S.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">Para modificar las ventanas secundarias y ventanas seguras de nivel superior. Enumeración asociada: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
      </Docs>
    </Member>
    <Member MemberName="SetCursorPosition">
      <MemberSignature Language="C#" Value="public static void SetCursorPosition (int left, int top);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetCursorPosition(int32 left, int32 top) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.SetCursorPosition(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetCursorPosition (left As Integer, top As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetCursorPosition(int left, int top);" />
      <MemberSignature Language="F#" Value="static member SetCursorPosition : int * int -&gt; unit" Usage="System.Console.SetCursorPosition (left, top)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Int32" />
        <Parameter Name="top" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="left">Posición en columnas del cursor. Las columnas se numeran de izquierda a derecha a partir de 0.</param>
        <param name="top">Posición en filas del cursor. Las filas se numeran de arriba abajo a partir de 0.</param>
        <summary>Establece la posición del cursor.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use el <xref:System.Console.SetCursorPosition%2A> método para especificar donde la siguiente operación de escritura en la ventana de consola se va a comenzar. Si la posición del cursor especificado está fuera del área que está actualmente visible en la ventana de consola, el origen de la ventana se cambia automáticamente para hacer visible el cursor.  
  
 El cursor se mueve automáticamente a la posición del carácter siguiente cada vez que se escribe un carácter en la ventana de consola. Si el cursor está en la posición de carácter derecha de la parte inferior de la ventana de consola, la siguiente operación de escritura provocará la ventana de consola para desplazarse por lo que el cursor permanece visible. Si desea escribir un carácter en la posición de carácter de la derecha inferior sin causar la ventana de consola para desplazarse, use el <xref:System.Console.MoveBufferArea%2A> método para mover un carácter en esa posición.  
  
   
  
## Examples  
 Este ejemplo se muestra el <xref:System.Console.CursorLeft%2A> y <xref:System.Console.CursorTop%2A> propiedades y el <xref:System.Console.SetCursorPosition%2A> y <xref:System.Console.Clear%2A> métodos. En el ejemplo se coloca el cursor, que determina dónde se producirá la siguiente escritura, para dibujar un 5 caracteres por 5 rectángulo carácter mediante una combinación de "+", "&#124;", y "-" cadenas. Tenga en cuenta que se puede dibujar el rectángulo con menos pasos mediante una combinación de otras cadenas.  
  
 [!code-cpp[console.cursorLTS#1](~/samples/snippets/cpp/VS_Snippets_CLR/console.cursorLTS/CPP/lts.cpp#1)]
 [!code-csharp[console.cursorLTS#1](~/samples/snippets/csharp/VS_Snippets_CLR/console.cursorLTS/CS/lts.cs#1)]
 [!code-vb[console.cursorLTS#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/console.cursorLTS/VB/lts.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="left" /> o <paramref name="top" /> es menor que cero.  
  
O bien 
 <paramref name="left" /> es mayor o igual que <see cref="P:System.Console.BufferWidth" />.  
  
O bien 
 <paramref name="top" /> es mayor o igual que <see cref="P:System.Console.BufferHeight" />.</exception>
        <exception cref="T:System.Security.SecurityException">El usuario no tiene permiso para realizar esta acción.</exception>
        <exception cref="T:System.IO.IOException">Error de E/S.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">Para modificar las ventanas secundarias y ventanas seguras de nivel superior. Enumeración asociada: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
      </Docs>
    </Member>
    <Member MemberName="SetError">
      <MemberSignature Language="C#" Value="public static void SetError (System.IO.TextWriter newError);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetError(class System.IO.TextWriter newError) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.SetError(System.IO.TextWriter)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetError (newError As TextWriter)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetError(System::IO::TextWriter ^ newError);" />
      <MemberSignature Language="F#" Value="static member SetError : System.IO.TextWriter -&gt; unit" Usage="System.Console.SetError newError" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="newError" Type="System.IO.TextWriter" />
      </Parameters>
      <Docs>
        <param name="newError">Flujo que constituye la nueva salida de error estándar.</param>
        <summary>Establece la propiedad <see cref="P:System.Console.Error" /> en el objeto <see cref="T:System.IO.TextWriter" /> especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 De forma predeterminada, el <xref:System.Console.Error%2A> propiedad está establecida en el flujo de salida de error estándar.  
  
 Un <xref:System.IO.StreamWriter> que encapsula un <xref:System.IO.FileStream> puede usarse para enviar mensajes de error a un archivo.  
  
   
  
## Examples  
 El ejemplo siguiente muestra cómo redirigir el flujo de error estándar a un archivo.  
  
 [!code-cpp[System.Console.SetError#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Console.SetError/cpp/seterror1.cpp#1)]
 [!code-csharp[System.Console.SetError#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Console.SetError/cs/SetError1.cs#1)]
 [!code-vb[System.Console.SetError#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Console.SetError/vb/SetError1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="newError" /> es <see langword="null" />.</exception>
        <exception cref="T:System.Security.SecurityException">El llamador no dispone del permiso requerido.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">para llamar a código no administrado. Enumeración asociada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <altmember cref="P:System.Console.IsErrorRedirected" />
        <altmember cref="P:System.Console.Error" />
      </Docs>
    </Member>
    <Member MemberName="SetIn">
      <MemberSignature Language="C#" Value="public static void SetIn (System.IO.TextReader newIn);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetIn(class System.IO.TextReader newIn) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.SetIn(System.IO.TextReader)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetIn (newIn As TextReader)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetIn(System::IO::TextReader ^ newIn);" />
      <MemberSignature Language="F#" Value="static member SetIn : System.IO.TextReader -&gt; unit" Usage="System.Console.SetIn newIn" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="newIn" Type="System.IO.TextReader" />
      </Parameters>
      <Docs>
        <param name="newIn">Flujo que constituye la nueva entrada estándar.</param>
        <summary>Establece la propiedad <see cref="P:System.Console.In" /> en el objeto <see cref="T:System.IO.TextReader" /> especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 De forma predeterminada, el <xref:System.Console.In%2A> propiedad está establecida en el flujo de entrada estándar.  
  
 Un <xref:System.IO.StreamReader> que encapsula un <xref:System.IO.FileStream> puede utilizarse para recibir entradas de un archivo.  
  
   
  
## Examples  
 En el ejemplo siguiente se muestra el uso del método <xref:System.Console.SetIn%2A>. Reemplaza cuatro caracteres de espacio consecutivos en una cadena con un carácter de tabulación. Para ejecutarlo, debe proporcionar dos argumentos de línea de comandos. El primero es el nombre de un archivo de texto existente al que se va a redirigir el flujo de entrada estándar. El segundo es el nombre de un archivo al que se va a redirigir el flujo de salida estándar. No es necesario que exista este archivo. Si existe, se sobrescribirá su contenido.  
  
 [!code-cpp[System.Console-INSERTTABS#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Console-INSERTTABS/CPP/inserttabs.cpp#1)]
 [!code-csharp[System.Console-INSERTTABS#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Console-INSERTTABS/CS/inserttabs.cs#1)]
 [!code-vb[System.Console-INSERTTABS#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Console-INSERTTABS/VB/inserttabs.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="newIn" /> es <see langword="null" />.</exception>
        <exception cref="T:System.Security.SecurityException">El llamador no dispone del permiso requerido.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">para llamar a código no administrado. Enumeración asociada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <altmember cref="T:System.IO.TextReader" />
        <altmember cref="P:System.Console.In" />
      </Docs>
    </Member>
    <Member MemberName="SetOut">
      <MemberSignature Language="C#" Value="public static void SetOut (System.IO.TextWriter newOut);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetOut(class System.IO.TextWriter newOut) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.SetOut(System.IO.TextWriter)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetOut (newOut As TextWriter)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetOut(System::IO::TextWriter ^ newOut);" />
      <MemberSignature Language="F#" Value="static member SetOut : System.IO.TextWriter -&gt; unit" Usage="System.Console.SetOut newOut" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="newOut" Type="System.IO.TextWriter" />
      </Parameters>
      <Docs>
        <param name="newOut">Flujo que constituye la nueva salida estándar.</param>
        <summary>Establece la propiedad <see cref="P:System.Console.Out" /> en el objeto <see cref="T:System.IO.TextWriter" /> especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 De forma predeterminada, el <xref:System.Console.Out%2A> propiedad está establecida en el flujo de salida estándar.  
  
 Un <xref:System.IO.StreamWriter> que encapsula un <xref:System.IO.FileStream> puede usarse para enviar la salida a un archivo. Por ejemplo:  
  
 [!code-cpp[System.Console.SetOut#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.console.setout/cpp/source.cpp#1)]
 [!code-csharp[System.Console.SetOut#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.console.setout/cs/source.cs#1)]
 [!code-vb[System.Console.SetOut#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.console.setout/vb/source.vb#1)]  
  
   
  
## Examples  
 En el ejemplo siguiente se muestra el uso del método <xref:System.Console.SetOut%2A>. Reemplaza cuatro caracteres de espacio consecutivos en una cadena con un carácter de tabulación. Para ejecutarlo, debe proporcionar dos argumentos de línea de comandos. El primero es el nombre de un archivo de texto existente al que se va a redirigir el flujo de entrada estándar. El segundo es el nombre de un archivo al que se va a redirigir el flujo de salida estándar. No es necesario que exista este archivo. Si existe, se sobrescribirá su contenido.  
  
 [!code-cpp[System.Console-INSERTTABS#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Console-INSERTTABS/CPP/inserttabs.cpp#1)]
 [!code-csharp[System.Console-INSERTTABS#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Console-INSERTTABS/CS/inserttabs.cs#1)]
 [!code-vb[System.Console-INSERTTABS#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Console-INSERTTABS/VB/inserttabs.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="newOut" /> es <see langword="null" />.</exception>
        <exception cref="T:System.Security.SecurityException">El llamador no dispone del permiso requerido.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">para llamar a código no administrado. Enumeración asociada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <altmember cref="T:System.IO.TextWriter" />
        <altmember cref="P:System.Console.Out" />
      </Docs>
    </Member>
    <Member MemberName="SetWindowPosition">
      <MemberSignature Language="C#" Value="public static void SetWindowPosition (int left, int top);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetWindowPosition(int32 left, int32 top) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.SetWindowPosition(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetWindowPosition (left As Integer, top As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetWindowPosition(int left, int top);" />
      <MemberSignature Language="F#" Value="static member SetWindowPosition : int * int -&gt; unit" Usage="System.Console.SetWindowPosition (left, top)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Int32" />
        <Parameter Name="top" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="left">Posición en columnas de la esquina superior izquierda de la ventana de la consola.</param>
        <param name="top">Posición en filas de la esquina superior izquierda de la ventana de la consola.</param>
        <summary>Establece la posición de la ventana de la consola con respecto al búfer de pantalla.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La ventana del sistema operativo muestra la ventana de consola y la ventana de consola muestra una parte del búfer de pantalla. El <xref:System.Console.SetWindowPosition%2A> método afecta a la posición de la ventana de consola con respecto al búfer de pantalla, pero no afecta a la posición de la ventana del sistema operativo en relación con el escritorio.  
  
 Las ventanas de consola y del sistema operativo por lo general no afectan entre sí. Sin embargo, si no se puede mostrar el búfer de pantalla en los límites actuales de la ventana de consola, el sistema operativo anexa automáticamente barras de desplazamiento a la ventana del sistema operativo. En ese caso, mover las barras de desplazamiento de la ventana de sistema operativo afecta a la posición de la ventana de consola y mover la ventana de consola con el <xref:System.Console.SetWindowPosition%2A> método afecta a la posición de las barras de desplazamiento de la ventana de sistema operativo.  
  
   
  
## Examples  
 En el ejemplo siguiente se muestra el <xref:System.Console.WindowLeft%2A>, <xref:System.Console.WindowTop%2A>, <xref:System.Console.WindowWidth%2A>, <xref:System.Console.WindowHeight%2A>, <xref:System.Console.BufferWidth%2A>, <xref:System.Console.BufferHeight%2A>, y <xref:System.Console.CursorVisible%2A> propiedades; y la <xref:System.Console.SetWindowPosition%2A>, <xref:System.Console.SetBufferSize%2A>, y <xref:System.Console.ReadKey%2A> métodos. En el ejemplo se dibuja un patrón de cuadrícula en el búfer de pantalla según el ancho del búfer de pantalla. A continuación, en el ejemplo se mueve la ventana de consola en respuesta a las que la flecha arriba, se presionan teclas de consola de flecha abajo, flecha izquierda o flecha derecha. El patrón de cuadrícula ayuda a ver el movimiento de la ventana de consola con respecto al búfer de pantalla.  
  
 [!code-cpp[console.windowLT#1](~/samples/snippets/cpp/VS_Snippets_CLR/console.windowLT/CPP/wlt.cpp#1)]
 [!code-csharp[console.windowLT#1](~/samples/snippets/csharp/VS_Snippets_CLR/console.windowLT/CS/wlt.cs#1)]
 [!code-vb[console.windowLT#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/console.windowLT/VB/wlt.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="left" /> o <paramref name="top" /> es menor que cero.  
  
O bien 
 <paramref name="left" /> + <see cref="P:System.Console.WindowWidth" /> es mayor que <see cref="P:System.Console.BufferWidth" />.  
  
O bien 
 <paramref name="top" /> + <see cref="P:System.Console.WindowHeight" /> es mayor que <see cref="P:System.Console.BufferHeight" />.</exception>
        <exception cref="T:System.Security.SecurityException">El usuario no tiene permiso para realizar esta acción.</exception>
        <exception cref="T:System.IO.IOException">Error de E/S.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">Para modificar las ventanas secundarias y ventanas seguras de nivel superior. Enumeración asociada: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
      </Docs>
    </Member>
    <Member MemberName="SetWindowSize">
      <MemberSignature Language="C#" Value="public static void SetWindowSize (int width, int height);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetWindowSize(int32 width, int32 height) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.SetWindowSize(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetWindowSize (width As Integer, height As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetWindowSize(int width, int height);" />
      <MemberSignature Language="F#" Value="static member SetWindowSize : int * int -&gt; unit" Usage="System.Console.SetWindowSize (width, height)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="width" Type="System.Int32" />
        <Parameter Name="height" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="width">Ancho de la ventana de la consola, medido en columnas.</param>
        <param name="height">Alto de la ventana de la consola, medido en filas.</param>
        <summary>Establece el alto y el ancho de la ventana de la consola en los valores especificados.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Este ejemplo se muestra el <xref:System.Console.SetWindowSize%2A> método y el <xref:System.Console.WindowWidth%2A> y <xref:System.Console.WindowHeight%2A> propiedades. Debe ejecutar el ejemplo para ver el efecto del cambio de tamaño de la ventana de consola completo.  
  
 En el ejemplo se informa de las dimensiones de una ventana de consola establecida en 85 columnas y 43 filas y luego espera que se presiona una clave. Cuando se presiona cualquier tecla, se reduce a la mitad las dimensiones de la ventana de consola, se notifican las nuevas dimensiones y se espera a que presione otra tecla. Por último, cuando se presiona cualquier tecla, se restaura la ventana de consola a sus dimensiones originales y finaliza en el ejemplo.  
  
 [!code-cpp[console.setwindowsize#1](~/samples/snippets/cpp/VS_Snippets_CLR/console.setwindowsize/CPP/sws.cpp#1)]
 [!code-csharp[console.setwindowsize#1](~/samples/snippets/csharp/VS_Snippets_CLR/console.setwindowsize/CS/sws.cs#1)]
 [!code-vb[console.setwindowsize#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/console.setwindowsize/VB/sws.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="width" /> o <paramref name="height" /> es menor o igual que cero.  
  
O bien 
 <paramref name="width" /> más <see cref="P:System.Console.WindowLeft" /> o <paramref name="height" /> más <see cref="P:System.Console.WindowTop" /> es mayor o igual que <see cref="F:System.Int16.MaxValue" />.  
  
O bien 
 <paramref name="width" /> o <paramref name="height" /> es mayor que el mayor ancho o la altura de ventana más grande posible para la resolución de pantalla y la fuente de consola actuales.</exception>
        <exception cref="T:System.Security.SecurityException">El usuario no tiene permiso para realizar esta acción.</exception>
        <exception cref="T:System.IO.IOException">Error de E/S.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">Para modificar las ventanas secundarias y ventanas seguras de nivel superior. Enumeración asociada: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
      </Docs>
    </Member>
    <Member MemberName="Title">
      <MemberSignature Language="C#" Value="public static string Title { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property string Title" />
      <MemberSignature Language="DocId" Value="P:System.Console.Title" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property Title As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::String ^ Title { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Title : string with get, set" Usage="System.Console.Title" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>set: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece el título que se va a mostrar en la barra de título de la consola.</summary>
        <value>Cadena que se va a mostrar en la barra de título de la consola. La cadena de título tiene una longitud máxima de 24.500 caracteres.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Este ejemplo se muestra el <xref:System.Console.Title%2A> propiedad. En el ejemplo se muestra el título de la ventana del sistema operativo actual, espera a que presione una tecla y muestra un título nuevo.  
  
 [!code-cpp[console.title#1](~/samples/snippets/cpp/VS_Snippets_CLR/console.title/CPP/mytitle.cpp#1)]
 [!code-csharp[console.title#1](~/samples/snippets/csharp/VS_Snippets_CLR/console.title/CS/mytitle.cs#1)]
 [!code-vb[console.title#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/console.title/VB/mytitle.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">En una operación get, el título recuperado tiene más de 24.500 caracteres.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">En una operación set, el título especificado tiene más de 24.500 caracteres.</exception>
        <exception cref="T:System.ArgumentNullException">En una operación set, el título especificado es <see langword="null" />.</exception>
        <exception cref="T:System.IO.IOException">Error de E/S.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">Para modificar las ventanas secundarias y ventanas seguras de nivel superior. Enumeración asociada: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
      </Docs>
    </Member>
    <Member MemberName="TreatControlCAsInput">
      <MemberSignature Language="C#" Value="public static bool TreatControlCAsInput { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property bool TreatControlCAsInput" />
      <MemberSignature Language="DocId" Value="P:System.Console.TreatControlCAsInput" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property TreatControlCAsInput As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool TreatControlCAsInput { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.TreatControlCAsInput : bool with get, set" Usage="System.Console.TreatControlCAsInput" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>set: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece un valor que indica si la combinación de la tecla modificadora <see cref="F:System.ConsoleModifiers.Control" /> y de la tecla de consola <see cref="F:System.ConsoleKey.C" /> (Ctrl+C) se trata como una entrada ordinaria o como una interrupción controlada por el sistema operativo.</summary>
        <value><see langword="true" /> si Ctrl+C se trata como una entrada ordinaria; de lo contrario, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si el valor de la <xref:System.Console.TreatControlCAsInput%2A> propiedad es `false` y se presiona Ctrl + C, las teclas presionadas no se almacenan en el búfer de entrada y el sistema operativo finaliza el proceso está ejecutando actualmente. Este es el valor predeterminado.  
  
> [!CAUTION]
>  Utilice esta propiedad con prudencia porque si se establece en `true` tiene un efecto considerable de este tipo. La mayoría de los usuarios esperan Ctrl + C para finalizar una aplicación de consola. Si deshabilita el efecto de Ctrl + C, debe recordar al usuario usar CTRL+INTER para finalizar la aplicación, que es una combinación de teclas menos conocida.  
  
   
  
## Examples  
 En el ejemplo siguiente se muestra el <xref:System.Console.TreatControlCAsInput%2A> propiedad.  
  
 [!code-cpp[console.readkey1#1](~/samples/snippets/cpp/VS_Snippets_CLR/console.readkey1/CPP/rk.cpp#1)]
 [!code-csharp[console.readkey1#1](~/samples/snippets/csharp/VS_Snippets_CLR/console.readkey1/CS/rk.cs#1)]
 [!code-vb[console.readkey1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/console.readkey1/VB/rk.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">No se puede obtener o establecer el modo de entrada del búfer de entrada de consola.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">Para modificar las ventanas secundarias y ventanas seguras de nivel superior. Enumeración asociada: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
        <altmember cref="F:System.ConsoleModifiers.Control" />
        <altmember cref="F:System.ConsoleKey.C" />
        <altmember cref="E:System.Console.CancelKeyPress" />
      </Docs>
    </Member>
    <Member MemberName="WindowHeight">
      <MemberSignature Language="C#" Value="public static int WindowHeight { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property int32 WindowHeight" />
      <MemberSignature Language="DocId" Value="P:System.Console.WindowHeight" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property WindowHeight As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property int WindowHeight { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.WindowHeight : int with get, set" Usage="System.Console.WindowHeight" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece el alto del área de la ventana de la consola.</summary>
        <value>Alto de la ventana de la consola, medido en filas.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se intentó establecer el valor de la <xref:System.Console.WindowHeight%2A> propiedad cuando se redirige la salida produce cualquiera un <xref:System.ArgumentOutOfRangeException> o un <xref:System.IO.IOException> excepción. Para evitar una excepción, puede establecer el valor de esta propiedad sólo si la <xref:System.Console.IsOutputRedirected%2A> propiedad devuelve `false`.  
  
   
  
## Examples  
 Este ejemplo se muestra el <xref:System.Console.SetWindowSize%2A> método y el <xref:System.Console.WindowWidth%2A> y <xref:System.Console.WindowHeight%2A> propiedades. Debe ejecutar el ejemplo para ver el efecto del cambio de tamaño de la ventana de consola completo.  
  
 En el ejemplo se informa de las dimensiones de una ventana de consola establecida en 85 columnas y 43 filas y luego espera a que presione una tecla. Cuando se presiona cualquier tecla, se reduce a la mitad las dimensiones de la ventana de consola, se notifican las nuevas dimensiones y se espera a que presione otra tecla. Por último, cuando se presiona cualquier tecla se restaura la ventana de consola a sus dimensiones originales y finaliza en el ejemplo.  
  
 [!code-cpp[console.setwindowsize#1](~/samples/snippets/cpp/VS_Snippets_CLR/console.setwindowsize/CPP/sws.cpp#1)]
 [!code-csharp[console.setwindowsize#1](~/samples/snippets/csharp/VS_Snippets_CLR/console.setwindowsize/CS/sws.cs#1)]
 [!code-vb[console.setwindowsize#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/console.setwindowsize/VB/sws.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">El valor de la propiedad <see cref="P:System.Console.WindowWidth" /> o el valor de la propiedad  <see cref="P:System.Console.WindowHeight" /> es menor o igual que 0.  
  
O bien 
El valor de la propiedad <see cref="P:System.Console.WindowHeight" /> más el valor de la propiedad  <see cref="P:System.Console.WindowTop" /> es mayor o igual que <see cref="F:System.Int16.MaxValue" />.  
  
O bien 
El valor de la propiedad <see cref="P:System.Console.WindowWidth" /> o el valor de la propiedad <see cref="P:System.Console.WindowHeight" /> es mayor que el mayor ancho o la mayor altura de ventana posible para la resolución de pantalla y la fuente de consola actuales.</exception>
        <exception cref="T:System.IO.IOException">Error al leer o escribir información.</exception>
      </Docs>
    </Member>
    <Member MemberName="WindowLeft">
      <MemberSignature Language="C#" Value="public static int WindowLeft { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property int32 WindowLeft" />
      <MemberSignature Language="DocId" Value="P:System.Console.WindowLeft" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property WindowLeft As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property int WindowLeft { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.WindowLeft : int with get, set" Usage="System.Console.WindowLeft" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece la posición más a la izquierda del área de la ventana de la consola con respecto al búfer de pantalla.</summary>
        <value>Posición más a la izquierda de la ventana de la consola, medida en columnas.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La consola representa una ventana rectangular en un área rectangular de búfer mayor. La ventana y el búfer se miden verticalmente por su número de filas y horizontalmente por su número de columnas. Las dimensiones del área del búfer se definen mediante la <xref:System.Console.BufferHeight%2A> y <xref:System.Console.BufferWidth%2A> propiedades. Las dimensiones del área de la consola se definen mediante la <xref:System.Console.WindowHeight%2A> y <xref:System.Console.WindowWidth%2A> propiedades. El <xref:System.Console.WindowLeft%2A> propiedad determina qué columna del área del búfer se muestra en la primera columna de la ventana de consola. El valor de la <xref:System.Console.WindowLeft%2A> propiedad puede oscilar entre 0 y <xref:System.Console.BufferWidth%2A>  -  <xref:System.Console.WindowWidth%2A>. Al intentar establecerla, en un valor fuera de la que intervalo produce una <xref:System.ArgumentOutOfRangeException>.  
  
 Cuando se abre primero una ventana de consola, el valor predeterminado de la <xref:System.Console.WindowLeft%2A> propiedad es cero, lo que indica que la primera columna se muestra en la consola corresponde a la primera columna (la columna en la posición cero) en el área del búfer. El ancho predeterminado de la ventana de consola y el área del búfer es 80 columnas. Esto significa que el <xref:System.Console.WindowLeft%2A> se puede modificar la propiedad solo si la ventana de consola se hace más estrecha o el área del búfer se realiza más amplio.  
  
 Tenga en cuenta que si el ancho del área del búfer supera el ancho de la ventana de consola, el valor de la <xref:System.Console.WindowLeft%2A> propiedad se ajusta automáticamente cuando el usuario usa la barra de desplazamiento horizontal para definir la relación de la ventana en el área del búfer.  
  
 Se intentó establecer el valor de la <xref:System.Console.WindowLeft%2A> propiedad cuando la salida es redirigido produce una <xref:System.IO.IOException> excepción. Para evitar la excepción, puede establecer el valor de esta propiedad sólo si la <xref:System.Console.IsOutputRedirected%2A> propiedad devuelve `false`.  
  
   
  
## Examples  
 El ejemplo siguiente abre una ventana de consola de la columna de 80 y define un área de búfer que es de 120 columnas de ancho. Muestra información sobre la ventana y tamaño de búfer y, a continuación, espera a que el usuario presione la tecla flecha izquierda o la tecla flecha derecha. En el caso anterior, se disminuye el valor de la <xref:System.Console.WindowLeft%2A> propiedad en uno si el resultado es un valor válido. En el último caso, aumenta el valor de la <xref:System.Console.WindowLeft%2A> propiedad por uno si el resultado sería válido. Tenga en cuenta que el ejemplo no tiene que controlar una <xref:System.ArgumentOutOfRangeException>, porque lo comprueba que el valor que se asignará a la <xref:System.Console.WindowLeft%2A> propiedad no es negativa y no provoca la suma de la <xref:System.Console.WindowLeft%2A> y <xref:System.Console.WindowWidth%2A> propiedades supere los <xref:System.Console.BufferWidth%2A> valor de propiedad.  
  
 [!code-cpp[System.Console.WindowLeft#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.console.windowleft/cpp/windowleft1.cpp#1)]
 [!code-csharp[System.Console.WindowLeft#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.console.windowleft/cs/windowleft1.cs#1)]
 [!code-vb[System.Console.WindowLeft#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.console.windowleft/vb/windowleft1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">En una operación set, el valor que se asigna es menor que cero.  
  
O bien 
Como resultado de la asignación, <see cref="P:System.Console.WindowLeft" /> más <see cref="P:System.Console.WindowWidth" /> superaría <see cref="P:System.Console.BufferWidth" />.</exception>
        <exception cref="T:System.IO.IOException">Error al leer o escribir información.</exception>
      </Docs>
    </Member>
    <Member MemberName="WindowTop">
      <MemberSignature Language="C#" Value="public static int WindowTop { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property int32 WindowTop" />
      <MemberSignature Language="DocId" Value="P:System.Console.WindowTop" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property WindowTop As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property int WindowTop { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.WindowTop : int with get, set" Usage="System.Console.WindowTop" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece la posición superior del área de la ventana de la consola con respecto al búfer de pantalla.</summary>
        <value>Posición superior de la ventana de la consola, medida en filas.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La consola representa una ventana rectangular en un área rectangular de búfer mayor. La ventana y el búfer se miden verticalmente por su número de filas y horizontalmente por su número de columnas. Las dimensiones del área del búfer se definen mediante la <xref:System.Console.BufferHeight%2A> y <xref:System.Console.BufferWidth%2A> propiedades. Las dimensiones del área de la consola se definen mediante la <xref:System.Console.WindowHeight%2A> y <xref:System.Console.WindowWidth%2A> propiedades. El <xref:System.Console.WindowTop%2A> propiedad determina qué fila del área del búfer se muestra en la primera columna de la ventana de consola. El valor de la <xref:System.Console.WindowTop%2A> propiedad puede oscilar entre 0 y <xref:System.Console.BufferHeight%2A>  -  <xref:System.Console.WindowHeight%2A>. Al intentar establecerla, en un valor fuera de la que intervalo produce una <xref:System.ArgumentOutOfRangeException>.  
  
 Se intentó establecer el valor de la <xref:System.Console.WindowTop%2A> propiedad cuando la salida es redirigido produce una <xref:System.IO.IOException> excepción. Para evitar la excepción, puede establecer el valor de esta propiedad sólo si la <xref:System.Console.IsOutputRedirected%2A> propiedad devuelve `false`.  
  
   
  
## Examples  
 En el ejemplo siguiente se muestra el <xref:System.Console.WindowLeft%2A>, <xref:System.Console.WindowTop%2A>, <xref:System.Console.WindowWidth%2A>, <xref:System.Console.WindowHeight%2A>, <xref:System.Console.BufferWidth%2A>, <xref:System.Console.BufferHeight%2A>, y <xref:System.Console.CursorVisible%2A> propiedades; y la <xref:System.Console.SetWindowPosition%2A>, <xref:System.Console.SetBufferSize%2A>, y <xref:System.Console.ReadKey%2A> métodos. En el ejemplo se dibuja un patrón de cuadrícula en el búfer de pantalla según el ancho del búfer de pantalla. A continuación, en el ejemplo se mueve la ventana de consola en respuesta a las que la flecha arriba, se presionan teclas de consola de flecha abajo, flecha izquierda o flecha derecha. El patrón de cuadrícula ayuda a ver el movimiento de la ventana de consola con respecto al búfer de pantalla.  
  
 [!code-cpp[console.windowLT#1](~/samples/snippets/cpp/VS_Snippets_CLR/console.windowLT/CPP/wlt.cpp#1)]
 [!code-csharp[console.windowLT#1](~/samples/snippets/csharp/VS_Snippets_CLR/console.windowLT/CS/wlt.cs#1)]
 [!code-vb[console.windowLT#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/console.windowLT/VB/wlt.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">En una operación set, el valor que se asigna es menor que cero.  
  
O bien 
Como resultado de la asignación, <see cref="P:System.Console.WindowTop" /> más <see cref="P:System.Console.WindowHeight" /> superaría <see cref="P:System.Console.BufferHeight" />.</exception>
        <exception cref="T:System.IO.IOException">Error al leer o escribir información.</exception>
      </Docs>
    </Member>
    <Member MemberName="WindowWidth">
      <MemberSignature Language="C#" Value="public static int WindowWidth { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property int32 WindowWidth" />
      <MemberSignature Language="DocId" Value="P:System.Console.WindowWidth" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property WindowWidth As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property int WindowWidth { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.WindowWidth : int with get, set" Usage="System.Console.WindowWidth" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece el ancho de la ventana de la consola.</summary>
        <value>Ancho de la ventana de la consola, medido en columnas.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se intentó establecer el valor de la <xref:System.Console.WindowWidth%2A> propiedad cuando se redirige la salida produce cualquiera un <xref:System.ArgumentOutOfRangeException> o un <xref:System.IO.IOException> excepción. Para evitar una excepción, puede establecer el valor de esta propiedad sólo si la <xref:System.Console.IsOutputRedirected%2A> propiedad devuelve `false`.  
  
   
  
## Examples  
 Este ejemplo se muestra el <xref:System.Console.SetWindowSize%2A> método y el <xref:System.Console.WindowWidth%2A> y <xref:System.Console.WindowHeight%2A> propiedades. Debe ejecutar el ejemplo para ver el efecto del cambio de tamaño de la ventana de consola completo.  
  
 En el ejemplo se informa de las dimensiones de una ventana de consola establecida en 85 columnas y 43 filas y luego espera a que presione una tecla. Cuando se presiona cualquier tecla, se reduce a la mitad las dimensiones de la ventana de consola, se notifican las nuevas dimensiones y se espera a que presione otra tecla. Por último, cuando se presiona cualquier tecla se restaura la ventana de consola a sus dimensiones originales y finaliza en el ejemplo.  
  
 [!code-cpp[console.setwindowsize#1](~/samples/snippets/cpp/VS_Snippets_CLR/console.setwindowsize/CPP/sws.cpp#1)]
 [!code-csharp[console.setwindowsize#1](~/samples/snippets/csharp/VS_Snippets_CLR/console.setwindowsize/CS/sws.cs#1)]
 [!code-vb[console.setwindowsize#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/console.setwindowsize/VB/sws.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">El valor de la propiedad <see cref="P:System.Console.WindowWidth" /> o el valor de la propiedad  <see cref="P:System.Console.WindowHeight" /> es menor o igual que 0.  
  
O bien 
El valor de la propiedad <see cref="P:System.Console.WindowHeight" /> más el valor de la propiedad  <see cref="P:System.Console.WindowTop" /> es mayor o igual que <see cref="F:System.Int16.MaxValue" />.  
  
O bien 
El valor de la propiedad <see cref="P:System.Console.WindowWidth" /> o el valor de la propiedad <see cref="P:System.Console.WindowHeight" /> es mayor que el mayor ancho o la mayor altura de ventana posible para la resolución de pantalla y la fuente de consola actuales.</exception>
        <exception cref="T:System.IO.IOException">Error al leer o escribir información.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Write">
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Escribe la representación de texto del valor o valores especificados en el flujo de salida estándar.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public static void Write (bool value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Write(bool value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.Write(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Write (value As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Write(bool value);" />
      <MemberSignature Language="F#" Value="static member Write : bool -&gt; unit" Usage="System.Console.Write value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="value">Valor que se va a escribir.</param>
        <summary>Escribe la representación de texto del valor booleano especificado en el flujo de salida estándar.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La representación de texto `value` se genera mediante una llamada a <xref:System.Boolean.ToString%2A?displayProperty=nameWithType>, lo que da como resultado <xref:System.Boolean.TrueString?displayProperty=nameWithType> o <xref:System.Boolean.FalseString?displayProperty=nameWithType>.  
  
   
  
## Examples  
 En el ejemplo siguiente se muestra el uso del método `Write`.  
  
 [!code-cpp[System.Console-REFORMAT#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Console-REFORMAT/CPP/reformat.cpp#1)]
 [!code-csharp[System.Console-REFORMAT#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Console-REFORMAT/CS/reformat.cs#1)]
 [!code-vb[System.Console-REFORMAT#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Console-REFORMAT/VB/reformat.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Error de E/S.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">Para modificar las ventanas secundarias y ventanas seguras de nivel superior. Enumeración asociada: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
        <altmember cref="M:System.Console.Read" />
        <altmember cref="M:System.Console.ReadLine" />
        <altmember cref="M:System.Console.WriteLine" />
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public static void Write (char value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Write(char value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.Write(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Write (value As Char)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Write(char value);" />
      <MemberSignature Language="F#" Value="static member Write : char -&gt; unit" Usage="System.Console.Write value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="value">Valor que se va a escribir.</param>
        <summary>Escribe el valor del carácter Unicode especificado en el flujo de salida estándar.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 En el ejemplo siguiente se muestra el uso del método `Write`.  
  
 [!code-cpp[System.Console-REFORMAT#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Console-REFORMAT/CPP/reformat.cpp#1)]
 [!code-csharp[System.Console-REFORMAT#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Console-REFORMAT/CS/reformat.cs#1)]
 [!code-vb[System.Console-REFORMAT#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Console-REFORMAT/VB/reformat.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Error de E/S.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">Para modificar las ventanas secundarias y ventanas seguras de nivel superior. Enumeración asociada: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
        <altmember cref="M:System.Console.Read" />
        <altmember cref="M:System.Console.ReadLine" />
        <altmember cref="M:System.Console.WriteLine" />
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public static void Write (char[] buffer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Write(char[] buffer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.Write(System.Char[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Write (buffer As Char())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Write(cli::array &lt;char&gt; ^ buffer);" />
      <MemberSignature Language="F#" Value="static member Write : char[] -&gt; unit" Usage="System.Console.Write buffer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Char[]" />
      </Parameters>
      <Docs>
        <param name="buffer">Matriz de caracteres Unicode.</param>
        <summary>Escribe la matriz especificada de caracteres Unicode en el flujo de salida estándar.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.IO.IOException">Error de E/S.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">Para modificar las ventanas secundarias y ventanas seguras de nivel superior. Enumeración asociada: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
        <altmember cref="M:System.Console.Read" />
        <altmember cref="M:System.Console.ReadLine" />
        <altmember cref="M:System.Console.WriteLine" />
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public static void Write (decimal value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Write(valuetype System.Decimal value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.Write(System.Decimal)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Write (value As Decimal)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Write(System::Decimal value);" />
      <MemberSignature Language="F#" Value="static member Write : decimal -&gt; unit" Usage="System.Console.Write value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Decimal" />
      </Parameters>
      <Docs>
        <param name="value">Valor que se va a escribir.</param>
        <summary>Escribe la representación de texto del valor <see cref="T:System.Decimal" /> especificado en el flujo de salida estándar.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La representación de texto `value` se genera mediante una llamada a <xref:System.Decimal.ToString%2A?displayProperty=nameWithType>.  
  
   
  
## Examples  
 En el ejemplo siguiente se muestra el uso del método `Write`.  
  
 [!code-cpp[System.Console-REFORMAT#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Console-REFORMAT/CPP/reformat.cpp#1)]
 [!code-csharp[System.Console-REFORMAT#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Console-REFORMAT/CS/reformat.cs#1)]
 [!code-vb[System.Console-REFORMAT#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Console-REFORMAT/VB/reformat.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Error de E/S.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">Para modificar las ventanas secundarias y ventanas seguras de nivel superior. Enumeración asociada: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
        <altmember cref="M:System.Console.Read" />
        <altmember cref="M:System.Console.ReadLine" />
        <altmember cref="M:System.Console.WriteLine" />
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public static void Write (double value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Write(float64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.Write(System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Write (value As Double)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Write(double value);" />
      <MemberSignature Language="F#" Value="static member Write : double -&gt; unit" Usage="System.Console.Write value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="value">Valor que se va a escribir.</param>
        <summary>Escribe la representación de texto del valor de punto flotante de precisión doble especificado en el flujo de salida estándar.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La representación de texto `value` se genera mediante una llamada a la <xref:System.Double.ToString%2A?displayProperty=nameWithType> método.  
  
   
  
## Examples  
 En el ejemplo siguiente se muestra el uso del método `Write`.  
  
 [!code-cpp[System.Console-REFORMAT#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Console-REFORMAT/CPP/reformat.cpp#1)]
 [!code-csharp[System.Console-REFORMAT#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Console-REFORMAT/CS/reformat.cs#1)]
 [!code-vb[System.Console-REFORMAT#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Console-REFORMAT/VB/reformat.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Error de E/S.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">Para modificar las ventanas secundarias y ventanas seguras de nivel superior. Enumeración asociada: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
        <altmember cref="M:System.Console.Read" />
        <altmember cref="M:System.Console.ReadLine" />
        <altmember cref="M:System.Console.WriteLine" />
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public static void Write (int value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Write(int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.Write(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Write (value As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Write(int value);" />
      <MemberSignature Language="F#" Value="static member Write : int -&gt; unit" Usage="System.Console.Write value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">Valor que se va a escribir.</param>
        <summary>Escribe la representación de texto del valor entero de 32 bits con signo especificado en el flujo de salida estándar.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La representación de texto `value` se genera mediante una llamada a la <xref:System.Int32.ToString%2A?displayProperty=nameWithType> método.  
  
   
  
## Examples  
 En el ejemplo siguiente se muestra el uso del método `Write`.  
  
 [!code-cpp[System.Console-REFORMAT#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Console-REFORMAT/CPP/reformat.cpp#1)]
 [!code-csharp[System.Console-REFORMAT#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Console-REFORMAT/CS/reformat.cs#1)]
 [!code-vb[System.Console-REFORMAT#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Console-REFORMAT/VB/reformat.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Error de E/S.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">Para modificar las ventanas secundarias y ventanas seguras de nivel superior. Enumeración asociada: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
        <altmember cref="M:System.Console.Read" />
        <altmember cref="M:System.Console.ReadLine" />
        <altmember cref="M:System.Console.WriteLine" />
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public static void Write (long value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Write(int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.Write(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Write (value As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Write(long value);" />
      <MemberSignature Language="F#" Value="static member Write : int64 -&gt; unit" Usage="System.Console.Write value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="value">Valor que se va a escribir.</param>
        <summary>Escribe la representación de texto del valor entero de 64 bits con signo especificado en el flujo de salida estándar.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La representación de texto `value` se genera mediante una llamada a la <xref:System.Int64.ToString%2A?displayProperty=nameWithType> método.  
  
   
  
## Examples  
 En el ejemplo siguiente se muestra el uso del método `Write`.  
  
 [!code-cpp[System.Console-REFORMAT#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Console-REFORMAT/CPP/reformat.cpp#1)]
 [!code-csharp[System.Console-REFORMAT#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Console-REFORMAT/CS/reformat.cs#1)]
 [!code-vb[System.Console-REFORMAT#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Console-REFORMAT/VB/reformat.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Error de E/S.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">Para modificar las ventanas secundarias y ventanas seguras de nivel superior. Enumeración asociada: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
        <altmember cref="M:System.Console.Read" />
        <altmember cref="M:System.Console.ReadLine" />
        <altmember cref="M:System.Console.WriteLine" />
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public static void Write (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Write(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.Write(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Write (value As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Write(System::Object ^ value);" />
      <MemberSignature Language="F#" Value="static member Write : obj -&gt; unit" Usage="System.Console.Write value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">Valor que se va a escribir o <see langword="null" />.</param>
        <summary>Escribe la representación de texto del objeto especificado en el flujo de salida estándar.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si `value` es `null`, se escribe nada y se produce ninguna excepción. En caso contrario, el `ToString` método `value` se llama para generar la representación de cadena, y la cadena resultante se escribe en el flujo de salida estándar.  
  
   
  
## Examples  
 En el ejemplo siguiente se muestra el uso del método `Write`.  
  
 [!code-cpp[System.Console-REFORMAT#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Console-REFORMAT/CPP/reformat.cpp#1)]
 [!code-csharp[System.Console-REFORMAT#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Console-REFORMAT/CS/reformat.cs#1)]
 [!code-vb[System.Console-REFORMAT#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Console-REFORMAT/VB/reformat.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Error de E/S.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">Para modificar las ventanas secundarias y ventanas seguras de nivel superior. Enumeración asociada: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
        <altmember cref="M:System.Console.Read" />
        <altmember cref="M:System.Console.ReadLine" />
        <altmember cref="M:System.Console.WriteLine" />
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public static void Write (float value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Write(float32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.Write(System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Write (value As Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Write(float value);" />
      <MemberSignature Language="F#" Value="static member Write : single -&gt; unit" Usage="System.Console.Write value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="value">Valor que se va a escribir.</param>
        <summary>Escribe la representación de texto del valor de punto flotante de precisión sencilla especificado en el flujo de salida estándar.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La representación de texto `value` se genera mediante una llamada a la <xref:System.Single.ToString%2A?displayProperty=nameWithType> método.  
  
   
  
## Examples  
 En el ejemplo siguiente se muestra el uso del método `Write`.  
  
 [!code-cpp[System.Console-REFORMAT#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Console-REFORMAT/CPP/reformat.cpp#1)]
 [!code-csharp[System.Console-REFORMAT#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Console-REFORMAT/CS/reformat.cs#1)]
 [!code-vb[System.Console-REFORMAT#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Console-REFORMAT/VB/reformat.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Error de E/S.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">Para modificar las ventanas secundarias y ventanas seguras de nivel superior. Enumeración asociada: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
        <altmember cref="M:System.Console.Read" />
        <altmember cref="M:System.Console.ReadLine" />
        <altmember cref="M:System.Console.WriteLine" />
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public static void Write (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Write(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.Write(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Write (value As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Write(System::String ^ value);" />
      <MemberSignature Language="F#" Value="static member Write : string -&gt; unit" Usage="System.Console.Write value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="value">Valor que se va a escribir.</param>
        <summary>Escribe el valor de cadena especificado en el flujo de salida estándar.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si el valor es `null`, se escribirá nada en el flujo de salida estándar.  
  
   
  
## Examples  
 En el ejemplo siguiente se muestra el uso del método `Write`.  
  
 [!code-cpp[System.Console-REFORMAT#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Console-REFORMAT/CPP/reformat.cpp#1)]
 [!code-csharp[System.Console-REFORMAT#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Console-REFORMAT/CS/reformat.cs#1)]
 [!code-vb[System.Console-REFORMAT#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Console-REFORMAT/VB/reformat.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Error de E/S.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">Para modificar las ventanas secundarias y ventanas seguras de nivel superior. Enumeración asociada: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
        <altmember cref="M:System.Console.Read" />
        <altmember cref="M:System.Console.ReadLine" />
        <altmember cref="M:System.Console.WriteLine" />
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public static void Write (uint value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Write(unsigned int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.Write(System.UInt32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Write (value As UInteger)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Write(System::UInt32 value);" />
      <MemberSignature Language="F#" Value="static member Write : uint32 -&gt; unit" Usage="System.Console.Write value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;netcore-3.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UInt32" />
      </Parameters>
      <Docs>
        <param name="value">Valor que se va a escribir.</param>
        <summary>Escribe la representación de texto del valor entero de 32 bits sin signo especificado en el flujo de salida estándar.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La representación de texto `value` se genera mediante una llamada a la <xref:System.UInt32.ToString%2A?displayProperty=nameWithType> método.  
  
   
  
## Examples  
 En el ejemplo siguiente se muestra el uso del método `Write`.  
  
 [!code-cpp[System.Console-REFORMAT#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Console-REFORMAT/CPP/reformat.cpp#1)]
 [!code-csharp[System.Console-REFORMAT#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Console-REFORMAT/CS/reformat.cs#1)]
 [!code-vb[System.Console-REFORMAT#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Console-REFORMAT/VB/reformat.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Error de E/S.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">Para modificar las ventanas secundarias y ventanas seguras de nivel superior. Enumeración asociada: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
        <altmember cref="M:System.Console.Read" />
        <altmember cref="M:System.Console.ReadLine" />
        <altmember cref="M:System.Console.WriteLine" />
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public static void Write (ulong value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Write(unsigned int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.Write(System.UInt64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Write (value As ULong)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Write(System::UInt64 value);" />
      <MemberSignature Language="F#" Value="static member Write : uint64 -&gt; unit" Usage="System.Console.Write value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;netcore-3.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UInt64" />
      </Parameters>
      <Docs>
        <param name="value">Valor que se va a escribir.</param>
        <summary>Escribe la representación de texto del valor entero de 64 bits sin signo especificado en el flujo de salida estándar.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La representación de texto `value` se genera mediante una llamada a la <xref:System.UInt64.ToString%2A?displayProperty=nameWithType> método.  
  
   
  
## Examples  
 En el ejemplo siguiente se muestra el uso del método `Write`.  
  
 [!code-cpp[System.Console-REFORMAT#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Console-REFORMAT/CPP/reformat.cpp#1)]
 [!code-csharp[System.Console-REFORMAT#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Console-REFORMAT/CS/reformat.cs#1)]
 [!code-vb[System.Console-REFORMAT#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Console-REFORMAT/VB/reformat.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Error de E/S.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">Para modificar las ventanas secundarias y ventanas seguras de nivel superior. Enumeración asociada: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
        <altmember cref="M:System.Console.Read" />
        <altmember cref="M:System.Console.ReadLine" />
        <altmember cref="M:System.Console.WriteLine" />
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public static void Write (string format, object arg0);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Write(string format, object arg0) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.Write(System.String,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Write (format As String, arg0 As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Write(System::String ^ format, System::Object ^ arg0);" />
      <MemberSignature Language="F#" Value="static member Write : string * obj -&gt; unit" Usage="System.Console.Write (format, arg0)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="arg0" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="format">Cadena de formato compuesto.</param>
        <param name="arg0">Objeto que se va a escribir con <paramref name="format" />.</param>
        <summary>Escribe la representación de texto del objeto especificado en el flujo de salida estándar usando la información de formato indicada.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método usa la [característica de formato compuesto](~/docs/standard/base-types/composite-formatting.md) de .NET Framework para convertir el valor de un objeto en su representación de texto e incrustar esa representación en una cadena. La cadena resultante se escribe en el flujo de salida.  
  
 El `format` parámetro consta de cero o más ejecuciones de texto mezclado con cero o más marcadores de posición indizados, denominados elementos de formato, que corresponden a un objeto en la lista de parámetros de este método. El proceso de formato reemplaza cada elemento de formato con la representación de texto del valor del objeto correspondiente.  
  
 La sintaxis de un elemento de formato es `{` *índice*[`,`*alineación*] [`:`*formatString*]`}`, que especifica un índice obligatorio, opcional longitud y la alineación del texto con formato y una cadena opcional de caracteres del especificador de formato que rigen cómo se da formato el valor del objeto correspondiente.  
  
 .NET Framework proporciona una amplia compatibilidad de formato, que se describe con más detalle en los siguientes temas de formato.  
  
-   Para obtener más información acerca de la característica de formato compuesto compatible con métodos como <xref:System.String.Format%2A>, <xref:System.Text.StringBuilder.AppendFormat%2A>y algunas sobrecargas de <xref:System.Console.WriteLine%2A>, consulte [formatos compuestos](~/docs/standard/base-types/composite-formatting.md).  
  
-   Para obtener más información sobre los especificadores de formato numérico, vea [cadenas de formato numérico estándar](~/docs/standard/base-types/standard-numeric-format-strings.md) y [cadenas con formato numérico personalizado](~/docs/standard/base-types/custom-numeric-format-strings.md).  
  
-   Para obtener más información acerca de fecha y hora en especificadores de formato, vea [Standard Date and Time Format Strings](~/docs/standard/base-types/standard-date-and-time-format-strings.md) y [Custom Date and Time Format Strings](~/docs/standard/base-types/custom-date-and-time-format-strings.md).  
  
-   Para obtener más información sobre los especificadores de formato de enumeración, vea [Enumeration Format Strings](~/docs/standard/base-types/enumeration-format-strings.md).  
  
-   Para obtener más información sobre el formato, vea [aplicar formato a tipos](~/docs/standard/base-types/formatting-types.md).  
  
   
  
## Examples  
 En el ejemplo siguiente se usa el método `WriteLine` para mostrar los especificadores de formato estándar para números, fechas y enumeraciones.  
  
 [!code-cpp[console.writelineFmt1#1](~/samples/snippets/cpp/VS_Snippets_CLR/console.writelineFmt1/cpp/wl.cpp#1)] 
 [!code-csharp[console.writelineFmt1#1](~/samples/snippets/csharp/VS_Snippets_CLR/console.writelineFmt1/cs/wl.cs#1)] 
 [!code-vb[console.writelineFmt1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/console.writelineFmt1/vb/wl.vb#1)]  
  
 En el ejemplo siguiente se muestra el uso del método <xref:System.Console.Write%2A>.  
  
 [!code-cpp[System.Console-REFORMAT#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Console-REFORMAT/CPP/reformat.cpp#1)]
 [!code-csharp[System.Console-REFORMAT#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Console-REFORMAT/CS/reformat.cs#1)]
 [!code-vb[System.Console-REFORMAT#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Console-REFORMAT/VB/reformat.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Error de E/S.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="format" /> es <see langword="null" />.</exception>
        <exception cref="T:System.FormatException">La especificación de formato de <paramref name="format" /> no es válida.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">Para modificar las ventanas secundarias y ventanas seguras de nivel superior. Enumeración asociada: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
        <altmember cref="M:System.Console.Read" />
        <altmember cref="M:System.Console.ReadLine" />
        <altmember cref="M:System.Console.WriteLine" />
        <related type="Article" href="~/docs/standard/base-types/formatting-types.md">Aplicar formato a tipos en .NET</related>
        <related type="Article" href="~/docs/standard/base-types/composite-formatting.md">Formatos compuestos</related>
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public static void Write (string format, params object[] arg);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Write(string format, object[] arg) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.Write(System.String,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Write (format As String, ParamArray arg As Object())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Write(System::String ^ format, ... cli::array &lt;System::Object ^&gt; ^ arg);" />
      <MemberSignature Language="F#" Value="static member Write : string * obj[] -&gt; unit" Usage="System.Console.Write (format, arg)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="arg" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="format">Cadena de formato compuesto.</param>
        <param name="arg">Matriz de objetos que se va a escribir con <paramref name="format" />.</param>
        <summary>Escribe la representación de texto de la matriz de objetos especificada en el flujo de salida estándar usando la información de formato especificada.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método usa la [característica de formato compuesto](~/docs/standard/base-types/composite-formatting.md) de .NET Framework para convertir el valor de un objeto en su representación de texto e incrustar esa representación en una cadena. La cadena resultante se escribe en el flujo de salida.  
  
 El `format` parámetro consta de cero o más ejecuciones de texto mezclado con cero o más marcadores de posición indizados, denominados elementos de formato, que corresponden a un objeto en la lista de parámetros de este método. El proceso de formato reemplaza cada elemento de formato con la representación de texto del valor del objeto correspondiente.  
  
 La sintaxis de un elemento de formato es `{` *índice*[`,`*alineación*] [`:`*formatString*]`}`, que especifica un índice obligatorio, opcional longitud y la alineación del texto con formato y una cadena opcional de caracteres del especificador de formato que rigen cómo se da formato el valor del objeto correspondiente.  
  
 .NET Framework proporciona una amplia compatibilidad de formato, que se describe con más detalle en los siguientes temas de formato.  
  
-   Para obtener más información acerca de la característica de formato compuesto compatible con métodos como <xref:System.String.Format%2A>, <xref:System.Text.StringBuilder.AppendFormat%2A>y algunas sobrecargas de <xref:System.Console.WriteLine%2A>, consulte [formatos compuestos](~/docs/standard/base-types/composite-formatting.md).  
  
-   Para obtener más información sobre los especificadores de formato numérico, vea [cadenas de formato numérico estándar](~/docs/standard/base-types/standard-numeric-format-strings.md) y [cadenas con formato numérico personalizado](~/docs/standard/base-types/custom-numeric-format-strings.md).  
  
-   Para obtener más información acerca de fecha y hora en especificadores de formato, vea [Standard Date and Time Format Strings](~/docs/standard/base-types/standard-date-and-time-format-strings.md) y [Custom Date and Time Format Strings](~/docs/standard/base-types/custom-date-and-time-format-strings.md).  
  
-   Para obtener más información sobre los especificadores de formato de enumeración, vea [Enumeration Format Strings](~/docs/standard/base-types/enumeration-format-strings.md).  
  
-   Para obtener más información sobre el formato, vea [aplicar formato a tipos](~/docs/standard/base-types/formatting-types.md).  
  
 El `arg` parámetro es una matriz de parámetros. Pueden pasar argumentos al método como una matriz o como lista de cinco o más elementos. Los ejemplos ilustran ambos formatos de llamada al método.  
  
   
  
## Examples  
 En el ejemplo siguiente se define un `Person` clase con un número de propiedades que proporcionan información sobre una persona. Su `GetDescription` método devuelve una matriz que contiene todos los valores de propiedad, excepto uno. El ejemplo utiliza la matriz devuelta por la `GetDescription` método para mostrar los valores del objeto Person.  
  
 [!code-csharp[System.Console.Write#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.console.write/cs/WriteParams1.cs#1)]
 [!code-vb[System.Console.Write#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.console.write/vb/WriteParams1.vb#1)]  
  
 Tenga en cuenta que el ejemplo llama a la <xref:System.Console.Write%28System.String%2CSystem.Object%5B%5D%29> método en lugar de <xref:System.Console.WriteLine%28System.String%2CSystem.Object%5B%5D%29> método porque intenta mostrar el valor de la `Person.Remarks` propiedad en la misma línea. Para ello, examina el valor de la <xref:System.Console.CursorLeft%2A> y <xref:System.Console.WindowWidth%2A> propiedades para determinar si hay suficiente espacio para el comentario para ajustarse.  Si no existe, muestra la línea. Si no escribe una línea, tres espacios se aplica una sangría y muestra el comentario.  
  
 El ejemplo siguiente es idéntico al primero, salvo que proporciona una lista de cinco elementos como el `arg` argumento en lugar de una matriz de parámetros.  
  
 [!code-csharp[System.Console.Write#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.console.write/cs/WriteParams2.cs#2)]
 [!code-vb[System.Console.Write#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.console.write/vb/WriteParams2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Error de E/S.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="format" /> o <paramref name="arg" /> es <see langword="null" />.</exception>
        <exception cref="T:System.FormatException">La especificación de formato de <paramref name="format" /> no es válida.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">Para modificar las ventanas secundarias y ventanas seguras de nivel superior. Enumeración asociada: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
        <block subset="none" type="usage"><para>Este método no se llama al código de C++. El compilador de C++ resuelve las llamadas a [System.Console.Write](xref:System.Console.Write*) que incluyen una cadena y una lista de cuatro o más parámetros de objeto como una llamada a <see cref="M:System.Console.Write(System.String,System.Object,System.Object,System.Object,System.Object)" />. Resuelve las llamadas a [System.Console.Write](xref:System.Console.Write*) que incluyen una cadena y una matriz de objetos como una llamada a <see cref="M:System.Console.Write(System.String,System.Object)" />.</para></block>
        <altmember cref="M:System.Console.Read" />
        <altmember cref="M:System.Console.ReadLine" />
        <altmember cref="M:System.Console.WriteLine" />
        <related type="Article" href="~/docs/standard/base-types/formatting-types.md">Aplicar formato a tipos en .NET</related>
        <related type="Article" href="~/docs/standard/base-types/composite-formatting.md">Formatos compuestos</related>
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public static void Write (char[] buffer, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Write(char[] buffer, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.Write(System.Char[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Write (buffer As Char(), index As Integer, count As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Write(cli::array &lt;char&gt; ^ buffer, int index, int count);" />
      <MemberSignature Language="F#" Value="static member Write : char[] * int * int -&gt; unit" Usage="System.Console.Write (buffer, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Char[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="buffer">Matriz de caracteres Unicode.</param>
        <param name="index">Posición inicial en <paramref name="buffer" />.</param>
        <param name="count">Número de caracteres que se van a escribir.</param>
        <summary>Escribe la submatriz de caracteres Unicode especificada en el flujo de salida estándar.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método escribe `count` caracteres a partir de la posición `index` de `buffer` al flujo de salida estándar.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> o <paramref name="count" /> es menor que cero.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="index" /> más <paramref name="count" /> especifica una posición que no está dentro de <paramref name="buffer" />.</exception>
        <exception cref="T:System.IO.IOException">Error de E/S.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">Para modificar las ventanas secundarias y ventanas seguras de nivel superior. Enumeración asociada: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
        <altmember cref="M:System.Console.Read" />
        <altmember cref="M:System.Console.ReadLine" />
        <altmember cref="M:System.Console.WriteLine" />
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public static void Write (string format, object arg0, object arg1);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Write(string format, object arg0, object arg1) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.Write(System.String,System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Write (format As String, arg0 As Object, arg1 As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Write(System::String ^ format, System::Object ^ arg0, System::Object ^ arg1);" />
      <MemberSignature Language="F#" Value="static member Write : string * obj * obj -&gt; unit" Usage="System.Console.Write (format, arg0, arg1)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="arg0" Type="System.Object" />
        <Parameter Name="arg1" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="format">Cadena de formato compuesto.</param>
        <param name="arg0">Primer objeto que se va a escribir con <paramref name="format" />.</param>
        <param name="arg1">Segundo objeto que se va a escribir con <paramref name="format" />.</param>
        <summary>Escribe la representación de texto de los objetos especificados en el flujo de salida estándar usando la información de formato indicada.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método usa la [característica de formato compuesto](~/docs/standard/base-types/composite-formatting.md) de .NET Framework para convertir el valor de un objeto en su representación de texto e incrustar esa representación en una cadena. La cadena resultante se escribe en el flujo de salida.  
  
 El `format` parámetro consta de cero o más ejecuciones de texto mezclado con cero o más marcadores de posición indizados, denominados elementos de formato, que corresponden a un objeto en la lista de parámetros de este método. El proceso de formato reemplaza cada elemento de formato con la representación de texto del valor del objeto correspondiente.  
  
 La sintaxis de un elemento de formato es `{` *índice*[`,`*alineación*] [`:`*formatString*]`}`, que especifica un índice obligatorio, opcional longitud y la alineación del texto con formato y una cadena opcional de caracteres del especificador de formato que rigen cómo se da formato el valor del objeto correspondiente.  
  
 .NET Framework proporciona una amplia compatibilidad de formato, que se describe con más detalle en los siguientes temas de formato.  
  
-   Para obtener más información acerca de la característica de formato compuesto compatible con métodos como <xref:System.String.Format%2A>, <xref:System.Text.StringBuilder.AppendFormat%2A>y algunas sobrecargas de <xref:System.Console.WriteLine%2A>, consulte [formatos compuestos](~/docs/standard/base-types/composite-formatting.md).  
  
-   Para obtener más información sobre los especificadores de formato numérico, vea [cadenas de formato numérico estándar](~/docs/standard/base-types/standard-numeric-format-strings.md) y [cadenas con formato numérico personalizado](~/docs/standard/base-types/custom-numeric-format-strings.md).  
  
-   Para obtener más información acerca de fecha y hora en especificadores de formato, vea [Standard Date and Time Format Strings](~/docs/standard/base-types/standard-date-and-time-format-strings.md) y [Custom Date and Time Format Strings](~/docs/standard/base-types/custom-date-and-time-format-strings.md).  
  
-   Para obtener más información sobre los especificadores de formato de enumeración, vea [Enumeration Format Strings](~/docs/standard/base-types/enumeration-format-strings.md).  
  
-   Para obtener más información sobre el formato, vea [aplicar formato a tipos](~/docs/standard/base-types/formatting-types.md).  
  
   
  
## Examples  
 En el ejemplo siguiente se usa el método `WriteLine` para mostrar los especificadores de formato estándar para números, fechas y enumeraciones.  
  
 [!code-cpp[console.writelineFmt1#1](~/samples/snippets/cpp/VS_Snippets_CLR/console.writelineFmt1/cpp/wl.cpp#1)] 
 [!code-csharp[console.writelineFmt1#1](~/samples/snippets/csharp/VS_Snippets_CLR/console.writelineFmt1/cs/wl.cs#1)]
 [!code-vb[console.writelineFmt1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/console.writelineFmt1/vb/wl.vb#1)]  
  
 En el ejemplo siguiente se muestra el uso del método `Write`.  
  
 [!code-cpp[System.Console-REFORMAT#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Console-REFORMAT/CPP/reformat.cpp#1)]
 [!code-csharp[System.Console-REFORMAT#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Console-REFORMAT/CS/reformat.cs#1)]
 [!code-vb[System.Console-REFORMAT#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Console-REFORMAT/VB/reformat.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Error de E/S.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="format" /> es <see langword="null" />.</exception>
        <exception cref="T:System.FormatException">La especificación de formato de <paramref name="format" /> no es válida.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">Para modificar las ventanas secundarias y ventanas seguras de nivel superior. Enumeración asociada: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
        <altmember cref="M:System.Console.Read" />
        <altmember cref="M:System.Console.ReadLine" />
        <altmember cref="M:System.Console.WriteLine" />
        <related type="Article" href="~/docs/standard/base-types/formatting-types.md">Aplicar formato a tipos en .NET</related>
        <related type="Article" href="~/docs/standard/base-types/composite-formatting.md">Formatos compuestos</related>
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public static void Write (string format, object arg0, object arg1, object arg2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Write(string format, object arg0, object arg1, object arg2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.Write(System.String,System.Object,System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Write (format As String, arg0 As Object, arg1 As Object, arg2 As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Write(System::String ^ format, System::Object ^ arg0, System::Object ^ arg1, System::Object ^ arg2);" />
      <MemberSignature Language="F#" Value="static member Write : string * obj * obj * obj -&gt; unit" Usage="System.Console.Write (format, arg0, arg1, arg2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="arg0" Type="System.Object" />
        <Parameter Name="arg1" Type="System.Object" />
        <Parameter Name="arg2" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="format">Cadena de formato compuesto.</param>
        <param name="arg0">Primer objeto que se va a escribir con <paramref name="format" />.</param>
        <param name="arg1">Segundo objeto que se va a escribir con <paramref name="format" />.</param>
        <param name="arg2">Tercer objeto que se va a escribir con <paramref name="format" />.</param>
        <summary>Escribe la representación de texto de los objetos especificados en el flujo de salida estándar usando la información de formato indicada.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método usa la [característica de formato compuesto](~/docs/standard/base-types/composite-formatting.md) de .NET Framework para convertir el valor de un objeto en su representación de texto e incrustar esa representación en una cadena. La cadena resultante se escribe en el flujo de salida.  
  
 El `format` parámetro consta de cero o más ejecuciones de texto mezclado con cero o más marcadores de posición indizados, denominados elementos de formato, que corresponden a un objeto en la lista de parámetros de este método. El proceso de formato reemplaza cada elemento de formato con la representación de texto del valor del objeto correspondiente.  
  
 La sintaxis de un elemento de formato es `{` *índice*[`,`*alineación*] [`:`*formatString*]`}`, que especifica un índice obligatorio, opcional longitud y la alineación del texto con formato y una cadena opcional de caracteres del especificador de formato que rigen cómo se da formato el valor del objeto correspondiente.  
  
 .NET Framework proporciona una amplia compatibilidad de formato, que se describe con más detalle en los siguientes temas de formato.  
  
-   Para obtener más información acerca de la característica de formato compuesto compatible con métodos como <xref:System.String.Format%2A>, <xref:System.Text.StringBuilder.AppendFormat%2A>y algunas sobrecargas de <xref:System.Console.WriteLine%2A>, consulte [formatos compuestos](~/docs/standard/base-types/composite-formatting.md).  
  
-   Para obtener más información sobre los especificadores de formato numérico, vea [cadenas de formato numérico estándar](~/docs/standard/base-types/standard-numeric-format-strings.md) y [cadenas con formato numérico personalizado](~/docs/standard/base-types/custom-numeric-format-strings.md).  
  
-   Para obtener más información acerca de fecha y hora en especificadores de formato, vea [Standard Date and Time Format Strings](~/docs/standard/base-types/standard-date-and-time-format-strings.md) y [Custom Date and Time Format Strings](~/docs/standard/base-types/custom-date-and-time-format-strings.md).  
  
-   Para obtener más información sobre los especificadores de formato de enumeración, vea [Enumeration Format Strings](~/docs/standard/base-types/enumeration-format-strings.md).  
  
-   Para obtener más información sobre el formato, vea [aplicar formato a tipos](~/docs/standard/base-types/formatting-types.md).  
  
   
  
## Examples  
 En el ejemplo siguiente se usa el método `WriteLine` para mostrar los especificadores de formato estándar para números, fechas y enumeraciones.  
  
 [!code-cpp[console.writelineFmt1#1](~/samples/snippets/cpp/VS_Snippets_CLR/console.writelineFmt1/cpp/wl.cpp#1)] 
 [!code-csharp[console.writelineFmt1#1](~/samples/snippets/csharp/VS_Snippets_CLR/console.writelineFmt1/cs/wl.cs#1)]
 [!code-vb[console.writelineFmt1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/console.writelineFmt1/vb/wl.vb#1)]  
  
 En el ejemplo siguiente se muestra el uso del método `Write`.  
  
 [!code-cpp[System.Console-REFORMAT#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Console-REFORMAT/CPP/reformat.cpp#1)]
 [!code-csharp[System.Console-REFORMAT#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Console-REFORMAT/CS/reformat.cs#1)]
 [!code-vb[System.Console-REFORMAT#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Console-REFORMAT/VB/reformat.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Error de E/S.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="format" /> es <see langword="null" />.</exception>
        <exception cref="T:System.FormatException">La especificación de formato de <paramref name="format" /> no es válida.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">Para modificar las ventanas secundarias y ventanas seguras de nivel superior. Enumeración asociada: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
        <altmember cref="M:System.Console.Read" />
        <altmember cref="M:System.Console.ReadLine" />
        <altmember cref="M:System.Console.WriteLine" />
        <related type="Article" href="~/docs/standard/base-types/formatting-types.md">Aplicar formato a tipos en .NET</related>
        <related type="Article" href="~/docs/standard/base-types/composite-formatting.md">Formatos compuestos</related>
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public static void Write (string format, object arg0, object arg1, object arg2, object arg3);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Write(string format, object arg0, object arg1, object arg2, object arg3) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.Write(System.String,System.Object,System.Object,System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Write (format As String, arg0 As Object, arg1 As Object, arg2 As Object, arg3 As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Write(System::String ^ format, System::Object ^ arg0, System::Object ^ arg1, System::Object ^ arg2, System::Object ^ arg3);" />
      <MemberSignature Language="F#" Value="static member Write : string * obj * obj * obj * obj -&gt; unit" Usage="System.Console.Write (format, arg0, arg1, arg2, arg3)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="arg0" Type="System.Object" />
        <Parameter Name="arg1" Type="System.Object" />
        <Parameter Name="arg2" Type="System.Object" />
        <Parameter Name="arg3" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="format">Cadena de formato compuesto.</param>
        <param name="arg0">Primer objeto que se va a escribir con <paramref name="format" />.</param>
        <param name="arg1">Segundo objeto que se va a escribir con <paramref name="format" />.</param>
        <param name="arg2">Tercer objeto que se va a escribir con <paramref name="format" />.</param>
        <param name="arg3">Cuarto objeto que se va a escribir con <paramref name="format" />.</param>
        <summary>Escribe la representación de texto de los objetos especificados y la lista de parámetros de longitud variable en el flujo de salida estándar usando la información de formato especificada.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Esta API no es conforme a CLS. La alternativa conforme a CLS es <xref:System.Console.Write%28System.String%2CSystem.Object%5B%5D%29?displayProperty=nameWithType>. Los compiladores de C# y Visual Basic resolver automáticamente una llamada a este método como una llamada a <xref:System.Console.Write%28System.String%2CSystem.Object%5B%5D%29?displayProperty=nameWithType>.  
  
 Este método usa la [característica de formato compuesto](~/docs/standard/base-types/composite-formatting.md) de .NET Framework para convertir el valor de un objeto en su representación de texto e incrustar esa representación en una cadena. La cadena resultante se escribe en el flujo de salida.  
  
 El `format` parámetro consta de cero o más ejecuciones de texto mezclado con cero o más marcadores de posición indizados, denominados elementos de formato, que corresponden a un objeto en la lista de parámetros de este método. El proceso de formato reemplaza cada elemento de formato con la representación de texto del valor del objeto correspondiente.  
  
 La sintaxis de un elemento de formato es `{` *índice*[`,`*alineación*] [`:`*formatString*]`}`, que especifica un índice obligatorio, opcional longitud y la alineación del texto con formato y una cadena opcional de caracteres del especificador de formato que rigen cómo se da formato el valor del objeto correspondiente.  
  
 .NET Framework proporciona una amplia compatibilidad de formato, que se describe con más detalle en los siguientes temas de formato.  
  
-   Para obtener más información acerca de la característica de formato compuesto compatible con métodos como <xref:System.String.Format%2A>, <xref:System.Text.StringBuilder.AppendFormat%2A>y algunas sobrecargas de <xref:System.Console.WriteLine%2A>, consulte [formatos compuestos](~/docs/standard/base-types/composite-formatting.md).  
  
-   Para obtener más información sobre los especificadores de formato numérico, vea [cadenas de formato numérico estándar](~/docs/standard/base-types/standard-numeric-format-strings.md) y [cadenas con formato numérico personalizado](~/docs/standard/base-types/custom-numeric-format-strings.md).  
  
-   Para obtener más información acerca de fecha y hora en especificadores de formato, vea [Standard Date and Time Format Strings](~/docs/standard/base-types/standard-date-and-time-format-strings.md) y [Custom Date and Time Format Strings](~/docs/standard/base-types/custom-date-and-time-format-strings.md).  
  
-   Para obtener más información sobre los especificadores de formato de enumeración, vea [Enumeration Format Strings](~/docs/standard/base-types/enumeration-format-strings.md).  
  
-   Para obtener más información sobre el formato, vea [aplicar formato a tipos](~/docs/standard/base-types/formatting-types.md).  
  
   
  
## Examples  
 El ejemplo siguiente muestra el uso de parámetros de variable con el <xref:System.Console.Write%28System.String%2CSystem.Object%2CSystem.Object%2CSystem.Object%2CSystem.Object%29> método. Se llama al método con una cadena de formato compuesto y cinco elementos de formato.  
  
 [!code-cpp[System.Console.Write#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.console.write/cpp/con_write.cpp#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Error de E/S.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="format" /> es <see langword="null" />.</exception>
        <exception cref="T:System.FormatException">La especificación de formato de <paramref name="format" /> no es válida.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">Para modificar las ventanas secundarias y ventanas seguras de nivel superior. Enumeración asociada: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
        <block subset="none" type="usage"><para>Este método está marcado con el <see langword="vararg" /> palabra clave, lo que significa que admite un número variable de parámetros. El método puede llamarse desde Visual C++, pero no se puede llamar desde el código de C# o Visual Basic. Los compiladores de C# y Visual Basic resolver llamadas a <see cref="M:System.Console.Write(System.String,System.Object,System.Object,System.Object,System.Object)" /> como llamadas a <see cref="M:System.Console.Write(System.String,System.Object[])" />.</para></block>
        <altmember cref="M:System.Console.Read" />
        <altmember cref="M:System.Console.ReadLine" />
        <altmember cref="M:System.Console.WriteLine" />
        <related type="Article" href="~/docs/standard/base-types/formatting-types.md">Aplicar formato a tipos en .NET</related>
        <related type="Article" href="~/docs/standard/base-types/composite-formatting.md">Formatos compuestos</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="WriteLine">
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Escribe los datos especificados, seguidos del terminador de línea actual, en el flujo de salida estándar.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El terminador de línea predeterminado es una cadena cuyo valor es un retorno de carro seguido de un avance de línea ("\r\n" en C#, o `vbCrLf` en Visual Basic). El terminador de línea se puede cambiar estableciendo la <xref:System.IO.TextWriter.NewLine%2A?displayProperty=nameWithType> propiedad de la <xref:System.Console.Out%2A> propiedad por otra cadena.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="WriteLine">
      <MemberSignature Language="C#" Value="public static void WriteLine ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteLine() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.WriteLine" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteLine ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteLine();" />
      <MemberSignature Language="F#" Value="static member WriteLine : unit -&gt; unit" Usage="System.Console.WriteLine " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Escribe el terminador de línea actual en el flujo de salida estándar.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El terminador de línea predeterminado es una cadena cuyo valor es un retorno de carro seguido de un avance de línea ("\r\n" en C#, o `vbCrLf` en Visual Basic). El terminador de línea se puede cambiar estableciendo la <xref:System.IO.TextWriter.NewLine%2A?displayProperty=nameWithType> propiedad de la <xref:System.Console.Out%2A> propiedad por otra cadena. En este ejemplo se ilustra.  
  
   
  
## Examples  
 En el ejemplo se cambia el terminador de línea de su valor predeterminado de "\r\n" o `vbCrLf` a "\r\n\r\n" o `vbCrLf`  +  `vbCrLf`. A continuación, llama el <xref:System.Console.WriteLine> y <xref:System.Console.WriteLine%28System.String%29> métodos para mostrar el resultado en la consola.  
  
 [!code-cpp[System.Console.WriteLine#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Console.WriteLine/CPP/newline1.cpp#2)]
 [!code-csharp[System.Console.WriteLine#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Console.WriteLine/CS/newline1.cs#2)]
 [!code-vb[System.Console.WriteLine#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Console.WriteLine/VB/newline1.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Error de E/S.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">Para modificar las ventanas secundarias y ventanas seguras de nivel superior. Enumeración asociada: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
        <altmember cref="M:System.Console.Read" />
        <altmember cref="M:System.Console.ReadLine" />
        <altmember cref="M:System.Console.Write(System.String,System.Object)" />
        <altmember cref="P:System.IO.TextWriter.NewLine" />
        <altmember cref="P:System.Console.Out" />
      </Docs>
    </Member>
    <Member MemberName="WriteLine">
      <MemberSignature Language="C#" Value="public static void WriteLine (bool value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteLine(bool value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.WriteLine(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteLine (value As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteLine(bool value);" />
      <MemberSignature Language="F#" Value="static member WriteLine : bool -&gt; unit" Usage="System.Console.WriteLine value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="value">Valor que se va a escribir.</param>
        <summary>Escribe la representación de texto del valor booleano especificado, seguida del terminador de línea actual, en el flujo de salida estándar.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La representación de texto `value` se genera mediante una llamada a la <xref:System.Boolean.ToString%2A?displayProperty=nameWithType> método.  
  
 Para obtener más información acerca del terminador de línea, consulte la sección Comentarios de la <xref:System.Console.WriteLine%2A> método que no toma ningún parámetro.  
  
   
  
## Examples  
 El ejemplo siguiente genera diez enteros aleatorios y usa el <xref:System.Console.WriteLine%28System.Boolean%29?displayProperty=nameWithType> método para indicar si son pares.  
  
 [!code-cpp[System.Console.WriteLine#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Console.WriteLine/CPP/writeline_boolean1.cpp#4)]
 [!code-csharp[System.Console.WriteLine#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Console.WriteLine/CS/writeline_boolean1.cs#4)]
 [!code-vb[System.Console.WriteLine#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Console.WriteLine/VB/writeline_boolean1.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Error de E/S.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">Para modificar las ventanas secundarias y ventanas seguras de nivel superior. Enumeración asociada: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
        <altmember cref="M:System.Console.Read" />
        <altmember cref="M:System.Console.ReadLine" />
        <altmember cref="M:System.Console.Write(System.String,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="WriteLine">
      <MemberSignature Language="C#" Value="public static void WriteLine (char value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteLine(char value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.WriteLine(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteLine (value As Char)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteLine(char value);" />
      <MemberSignature Language="F#" Value="static member WriteLine : char -&gt; unit" Usage="System.Console.WriteLine value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="value">Valor que se va a escribir.</param>
        <summary>Escribe el carácter Unicode especificado, seguido del terminador de línea actual, en el flujo de salida estándar.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para obtener más información acerca del terminador de línea, consulte la sección Comentarios de la <xref:System.Console.WriteLine%2A> método que no toma ningún parámetro.  
  
   
  
## Examples  
 El ejemplo siguiente es una calculadora de sugerencia que calcula una sugerencia 18% y usa el <xref:System.Console.WriteLine%2A> método para mostrar la cantidad de la carga original, la cantidad de la punta y la cantidad total. El ejemplo es una aplicación de consola que requiere que el usuario proporcionar la cantidad de la carga original como un parámetro de línea de comandos.  
  
 [!code-csharp[System.Console.WriteLine#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Console.WriteLine/CS/tipcalc.cs#1)]
 [!code-vb[System.Console.WriteLine#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Console.WriteLine/VB/tipcalc.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Error de E/S.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">Para modificar las ventanas secundarias y ventanas seguras de nivel superior. Enumeración asociada: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
        <altmember cref="M:System.Console.Read" />
        <altmember cref="M:System.Console.ReadLine" />
        <altmember cref="M:System.Console.Write(System.String,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="WriteLine">
      <MemberSignature Language="C#" Value="public static void WriteLine (char[] buffer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteLine(char[] buffer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.WriteLine(System.Char[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteLine (buffer As Char())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteLine(cli::array &lt;char&gt; ^ buffer);" />
      <MemberSignature Language="F#" Value="static member WriteLine : char[] -&gt; unit" Usage="System.Console.WriteLine buffer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Char[]" />
      </Parameters>
      <Docs>
        <param name="buffer">Matriz de caracteres Unicode.</param>
        <summary>Escribe la matriz de caracteres Unicode especificada, seguida del terminador de línea actual, en el flujo de salida estándar.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para obtener más información acerca del terminador de línea, consulte la sección Comentarios de la <xref:System.Console.WriteLine%2A> método que no toma ningún parámetro.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Error de E/S.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">Para modificar las ventanas secundarias y ventanas seguras de nivel superior. Enumeración asociada: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
        <altmember cref="M:System.Console.Read" />
        <altmember cref="M:System.Console.ReadLine" />
        <altmember cref="M:System.Console.Write(System.String,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="WriteLine">
      <MemberSignature Language="C#" Value="public static void WriteLine (decimal value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteLine(valuetype System.Decimal value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.WriteLine(System.Decimal)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteLine (value As Decimal)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteLine(System::Decimal value);" />
      <MemberSignature Language="F#" Value="static member WriteLine : decimal -&gt; unit" Usage="System.Console.WriteLine value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Decimal" />
      </Parameters>
      <Docs>
        <param name="value">Valor que se va a escribir.</param>
        <summary>Escribe la representación de texto del valor <see cref="T:System.Decimal" /> especificado, seguido del terminador de línea actual, en el flujo de salida estándar.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La representación de texto `value` se genera mediante una llamada a la <xref:System.Decimal.ToString%2A?displayProperty=nameWithType> método.  
  
 Para obtener más información acerca del terminador de línea, consulte la sección Comentarios de la <xref:System.Console.WriteLine%2A> método que no toma ningún parámetro.  
  
   
  
## Examples  
 El ejemplo siguiente es una calculadora de sugerencia que calcula una sugerencia 18% y usa el <xref:System.Console.WriteLine%2A> método para mostrar la cantidad de la carga original, la cantidad de la punta y la cantidad total. El ejemplo es una aplicación de consola que requiere que el usuario proporcionar la cantidad de la carga original como un parámetro de línea de comandos.  
  
 [!code-csharp[System.Console.WriteLine#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Console.WriteLine/CS/tipcalc.cs#1)]
 [!code-vb[System.Console.WriteLine#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Console.WriteLine/VB/tipcalc.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Error de E/S.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">Para modificar las ventanas secundarias y ventanas seguras de nivel superior. Enumeración asociada: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
        <altmember cref="M:System.Console.Read" />
        <altmember cref="M:System.Console.ReadLine" />
        <altmember cref="M:System.Console.Write(System.String,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="WriteLine">
      <MemberSignature Language="C#" Value="public static void WriteLine (double value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteLine(float64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.WriteLine(System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteLine (value As Double)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteLine(double value);" />
      <MemberSignature Language="F#" Value="static member WriteLine : double -&gt; unit" Usage="System.Console.WriteLine value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="value">Valor que se va a escribir.</param>
        <summary>Escribe la representación de texto del valor de punto flotante de precisión doble especificado, seguido del terminador de línea actual, en el flujo de salida estándar.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La representación de texto `value` se genera mediante una llamada a la <xref:System.Double.ToString%2A?displayProperty=nameWithType> método.  
  
 Para obtener más información acerca del terminador de línea, consulte la sección Comentarios de la <xref:System.Console.WriteLine%2A> método que no toma ningún parámetro.  
  
   
  
## Examples  
 El ejemplo siguiente es una calculadora de sugerencia que calcula una sugerencia 18% y usa el <xref:System.Console.WriteLine%2A> método para mostrar la cantidad de la carga original, la cantidad de la punta y la cantidad total. El ejemplo es una aplicación de consola que requiere que el usuario proporcionar la cantidad de la carga original como un parámetro de línea de comandos.  
  
 [!code-csharp[System.Console.WriteLine#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Console.WriteLine/CS/tipcalc.cs#1)]
 [!code-vb[System.Console.WriteLine#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Console.WriteLine/VB/tipcalc.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Error de E/S.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">Para modificar las ventanas secundarias y ventanas seguras de nivel superior. Enumeración asociada: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
        <altmember cref="M:System.Console.Read" />
        <altmember cref="M:System.Console.ReadLine" />
        <altmember cref="M:System.Console.Write(System.String,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="WriteLine">
      <MemberSignature Language="C#" Value="public static void WriteLine (int value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteLine(int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.WriteLine(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteLine (value As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteLine(int value);" />
      <MemberSignature Language="F#" Value="static member WriteLine : int -&gt; unit" Usage="System.Console.WriteLine value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">Valor que se va a escribir.</param>
        <summary>Escribe la representación de texto del valor entero de 32 bits con signo especificado, seguido del terminador de línea actual, en el flujo de salida estándar.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La representación de texto `value` se genera mediante una llamada a la <xref:System.Int32.ToString%2A?displayProperty=nameWithType> método.  
  
 Para obtener más información acerca del terminador de línea, consulte la sección Comentarios de la <xref:System.Console.WriteLine%2A> método que no toma ningún parámetro.  
  
   
  
## Examples  
 El ejemplo siguiente es una calculadora de sugerencia que calcula una sugerencia 18% y usa el <xref:System.Console.WriteLine%2A> método para mostrar la cantidad de la carga original, la cantidad de la punta y la cantidad total. El ejemplo es una aplicación de consola que requiere que el usuario proporcionar la cantidad de la carga original como un parámetro de línea de comandos.  
  
 [!code-csharp[System.Console.WriteLine#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Console.WriteLine/CS/tipcalc.cs#1)]
 [!code-vb[System.Console.WriteLine#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Console.WriteLine/VB/tipcalc.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Error de E/S.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">Para modificar las ventanas secundarias y ventanas seguras de nivel superior. Enumeración asociada: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
        <altmember cref="M:System.Console.Read" />
        <altmember cref="M:System.Console.ReadLine" />
        <altmember cref="M:System.Console.Write(System.String,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="WriteLine">
      <MemberSignature Language="C#" Value="public static void WriteLine (long value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteLine(int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.WriteLine(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteLine (value As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteLine(long value);" />
      <MemberSignature Language="F#" Value="static member WriteLine : int64 -&gt; unit" Usage="System.Console.WriteLine value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="value">Valor que se va a escribir.</param>
        <summary>Escribe la representación de texto del valor entero de 64 bits con signo especificado, seguido del terminador de línea actual, en el flujo de salida estándar.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La representación de texto `value` se genera mediante una llamada a la <xref:System.Int64.ToString%2A?displayProperty=nameWithType> método.  
  
 Para obtener más información acerca del terminador de línea, consulte la sección Comentarios de la <xref:System.Console.WriteLine%2A> método que no toma ningún parámetro.  
  
   
  
## Examples  
 El ejemplo siguiente es una calculadora de sugerencia que calcula una sugerencia 18% y usa el <xref:System.Console.WriteLine%2A> método para mostrar la cantidad de la carga original, la cantidad de la punta y la cantidad total. El ejemplo es una aplicación de consola que requiere que el usuario proporcionar la cantidad de la carga original como un parámetro de línea de comandos.  
  
 [!code-csharp[System.Console.WriteLine#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Console.WriteLine/CS/tipcalc.cs#1)]
 [!code-vb[System.Console.WriteLine#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Console.WriteLine/VB/tipcalc.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Error de E/S.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">Para modificar las ventanas secundarias y ventanas seguras de nivel superior. Enumeración asociada: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
        <altmember cref="M:System.Console.Read" />
        <altmember cref="M:System.Console.ReadLine" />
        <altmember cref="M:System.Console.Write(System.String,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="WriteLine">
      <MemberSignature Language="C#" Value="public static void WriteLine (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteLine(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.WriteLine(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteLine (value As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteLine(System::Object ^ value);" />
      <MemberSignature Language="F#" Value="static member WriteLine : obj -&gt; unit" Usage="System.Console.WriteLine value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">Valor que se va a escribir.</param>
        <summary>Escribe la representación de texto del objeto especificado, seguida del terminador de línea actual, en el flujo de salida estándar.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si `value` es `null`, sólo se escribe el terminador de línea. En caso contrario, el `ToString` método `value` se llama para generar la representación de cadena, y la cadena resultante se escribe en el flujo de salida estándar.  
  
 Para obtener más información acerca del terminador de línea, consulte la sección Comentarios de la <xref:System.Console.WriteLine%2A> método que no toma ningún parámetro.  
  
   
  
## Examples  
 En el ejemplo siguiente se usa el <xref:System.Console.WriteLine%28System.Object%29> método para mostrar cada valor en una matriz de objetos en la consola.  
  
 [!code-cpp[System.Console.WriteLine#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Console.WriteLine/CPP/writeline_obj1.cpp#3)]
 [!code-csharp[System.Console.WriteLine#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Console.WriteLine/CS/writeline_obj1.cs#3)]
 [!code-vb[System.Console.WriteLine#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Console.WriteLine/VB/writeline_obj1.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Error de E/S.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">Para modificar las ventanas secundarias y ventanas seguras de nivel superior. Enumeración asociada: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
        <altmember cref="M:System.Console.Read" />
        <altmember cref="M:System.Console.ReadLine" />
        <altmember cref="M:System.Console.Write(System.String,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="WriteLine">
      <MemberSignature Language="C#" Value="public static void WriteLine (float value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteLine(float32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.WriteLine(System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteLine (value As Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteLine(float value);" />
      <MemberSignature Language="F#" Value="static member WriteLine : single -&gt; unit" Usage="System.Console.WriteLine value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="value">Valor que se va a escribir.</param>
        <summary>Escribe la representación de texto del valor de punto flotante de precisión sencilla especificado, seguido del terminador de línea actual, en el flujo de salida estándar.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La representación de texto `value` se genera mediante una llamada a la <xref:System.Single.ToString%2A?displayProperty=nameWithType> método.  
  
 Para obtener más información acerca del terminador de línea, consulte la sección Comentarios de la <xref:System.Console.WriteLine%2A> método que no toma ningún parámetro.  
  
   
  
## Examples  
 El ejemplo siguiente es una calculadora de sugerencia que calcula una sugerencia 18% y usa el <xref:System.Console.WriteLine%2A> método para mostrar la cantidad de la carga original, la cantidad de la punta y la cantidad total. El ejemplo es una aplicación de consola que requiere que el usuario proporcionar la cantidad de la carga original como un parámetro de línea de comandos.  
  
 [!code-csharp[System.Console.WriteLine#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Console.WriteLine/CS/tipcalc.cs#1)]
 [!code-vb[System.Console.WriteLine#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Console.WriteLine/VB/tipcalc.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Error de E/S.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">Para modificar las ventanas secundarias y ventanas seguras de nivel superior. Enumeración asociada: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
        <altmember cref="M:System.Console.Read" />
        <altmember cref="M:System.Console.ReadLine" />
        <altmember cref="M:System.Console.Write(System.String,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="WriteLine">
      <MemberSignature Language="C#" Value="public static void WriteLine (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteLine(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.WriteLine(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteLine (value As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteLine(System::String ^ value);" />
      <MemberSignature Language="F#" Value="static member WriteLine : string -&gt; unit" Usage="System.Console.WriteLine value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="value">Valor que se va a escribir.</param>
        <summary>Escribe el valor de cadena especificado, seguido del terminador de línea actual, en el flujo de salida estándar.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si el valor es `null`, solo el terminador de línea se escribe en el flujo de salida estándar.  
  
 Para obtener más información acerca del terminador de línea, consulte la sección Comentarios de la <xref:System.Console.WriteLine> método.  
  
   
  
## Examples  
 En el ejemplo se cambia el terminador de línea de su valor predeterminado de "\r\n" o `vbCrLf` a "\r\n\r\n" o `vbCrLf`  +  `vbCrLf`. A continuación, llama el <xref:System.Console.WriteLine> y <xref:System.Console.WriteLine%28System.String%29> métodos para mostrar el resultado en la consola.  
  
 [!code-cpp[System.Console.WriteLine#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Console.WriteLine/CPP/newline1.cpp#2)]
 [!code-csharp[System.Console.WriteLine#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Console.WriteLine/CS/newline1.cs#2)]
 [!code-vb[System.Console.WriteLine#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Console.WriteLine/VB/newline1.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Error de E/S.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">Para modificar las ventanas secundarias y ventanas seguras de nivel superior. Enumeración asociada: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
        <altmember cref="M:System.Console.Read" />
        <altmember cref="M:System.Console.ReadLine" />
        <altmember cref="M:System.Console.Write(System.String,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="WriteLine">
      <MemberSignature Language="C#" Value="public static void WriteLine (uint value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteLine(unsigned int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.WriteLine(System.UInt32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteLine (value As UInteger)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteLine(System::UInt32 value);" />
      <MemberSignature Language="F#" Value="static member WriteLine : uint32 -&gt; unit" Usage="System.Console.WriteLine value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;netcore-3.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UInt32" />
      </Parameters>
      <Docs>
        <param name="value">Valor que se va a escribir.</param>
        <summary>Escribe la representación de texto del valor entero de 32 bits sin signo especificado, seguido del terminador de línea actual, en el flujo de salida estándar.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La representación de texto `value` se genera mediante una llamada a la <xref:System.UInt32.ToString%2A?displayProperty=nameWithType> método.  
  
 Para obtener más información acerca del terminador de línea, consulte la sección Comentarios de la <xref:System.Console.WriteLine%2A> método que no toma ningún parámetro.  
  
   
  
## Examples  
 El ejemplo siguiente es una calculadora de sugerencia que calcula una sugerencia 18% y usa el <xref:System.Console.WriteLine%2A> método para mostrar la cantidad de la carga original, la cantidad de la punta y la cantidad total. El ejemplo es una aplicación de consola que requiere que el usuario proporcionar la cantidad de la carga original como un parámetro de línea de comandos.  
  
 [!code-csharp[System.Console.WriteLine#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Console.WriteLine/CS/tipcalc.cs#1)]
 [!code-vb[System.Console.WriteLine#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Console.WriteLine/VB/tipcalc.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Error de E/S.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">Para modificar las ventanas secundarias y ventanas seguras de nivel superior. Enumeración asociada: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
        <altmember cref="M:System.Console.Read" />
        <altmember cref="M:System.Console.ReadLine" />
        <altmember cref="M:System.Console.Write(System.String,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="WriteLine">
      <MemberSignature Language="C#" Value="public static void WriteLine (ulong value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteLine(unsigned int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.WriteLine(System.UInt64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteLine (value As ULong)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteLine(System::UInt64 value);" />
      <MemberSignature Language="F#" Value="static member WriteLine : uint64 -&gt; unit" Usage="System.Console.WriteLine value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;netcore-3.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UInt64" />
      </Parameters>
      <Docs>
        <param name="value">Valor que se va a escribir.</param>
        <summary>Escribe la representación de texto del valor entero de 64 bits sin signo especificado, seguido del terminador de línea actual, en el flujo de salida estándar.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La representación de texto `value` se genera mediante una llamada a la <xref:System.UInt64.ToString%2A?displayProperty=nameWithType> método.  
  
 Para obtener más información acerca del terminador de línea, consulte la sección Comentarios de la <xref:System.Console.WriteLine%2A> método que no toma ningún parámetro.  
  
   
  
## Examples  
 El ejemplo siguiente es una calculadora de sugerencia que calcula una sugerencia 18% y usa el <xref:System.Console.WriteLine%2A> método para mostrar la cantidad de la carga original, la cantidad de la punta y la cantidad total. El ejemplo es una aplicación de consola que requiere que el usuario proporcionar la cantidad de la carga original como un parámetro de línea de comandos.  
  
 [!code-csharp[System.Console.WriteLine#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Console.WriteLine/CS/tipcalc.cs#1)]
 [!code-vb[System.Console.WriteLine#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Console.WriteLine/VB/tipcalc.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Error de E/S.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">Para modificar las ventanas secundarias y ventanas seguras de nivel superior. Enumeración asociada: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
        <altmember cref="M:System.Console.Read" />
        <altmember cref="M:System.Console.ReadLine" />
        <altmember cref="M:System.Console.Write(System.String,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="WriteLine">
      <MemberSignature Language="C#" Value="public static void WriteLine (string format, object arg0);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteLine(string format, object arg0) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.WriteLine(System.String,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteLine (format As String, arg0 As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteLine(System::String ^ format, System::Object ^ arg0);" />
      <MemberSignature Language="F#" Value="static member WriteLine : string * obj -&gt; unit" Usage="System.Console.WriteLine (format, arg0)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="arg0" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="format">Cadena de formato compuesto.</param>
        <param name="arg0">Objeto que se va a escribir con <paramref name="format" />.</param>
        <summary>Escribe la representación de texto del objeto especificado, seguida del terminador de línea actual, en el flujo de salida estándar usando la información de formato especificada.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método usa la [característica de formato compuesto](~/docs/standard/base-types/composite-formatting.md) de .NET Framework para convertir el valor de un objeto en su representación de texto e incrustar esa representación en una cadena. La cadena resultante se escribe en el flujo de salida.  
  
 El `format` parámetro consta de cero o más ejecuciones de texto mezclado con cero o más marcadores de posición indizados, denominados elementos de formato, que corresponden a un objeto en la lista de parámetros de este método. El proceso de formato reemplaza cada elemento de formato con la representación de texto del valor del objeto correspondiente.  
  
 La sintaxis de un elemento de formato es `{` *índice*[`,`*alineación*] [`:`*formatString*]`}`, que especifica un índice obligatorio, opcional longitud y la alineación del texto con formato y una cadena opcional de caracteres del especificador de formato que rigen cómo se da formato el valor del objeto correspondiente.  
  
 .NET Framework proporciona una amplia compatibilidad de formato, que se describe con más detalle en los siguientes temas de formato.  
  
-   Para obtener más información acerca de la característica de formato compuesto compatible con métodos como <xref:System.String.Format%2A>, <xref:System.Text.StringBuilder.AppendFormat%2A>y algunas sobrecargas de <xref:System.Console.WriteLine%2A>, consulte [formatos compuestos](~/docs/standard/base-types/composite-formatting.md).  
  
-   Para obtener más información sobre los especificadores de formato numérico, vea [cadenas de formato numérico estándar](~/docs/standard/base-types/standard-numeric-format-strings.md) y [cadenas con formato numérico personalizado](~/docs/standard/base-types/custom-numeric-format-strings.md).  
  
-   Para obtener más información acerca de fecha y hora en especificadores de formato, vea [Standard Date and Time Format Strings](~/docs/standard/base-types/standard-date-and-time-format-strings.md) y [Custom Date and Time Format Strings](~/docs/standard/base-types/custom-date-and-time-format-strings.md).  
  
-   Para obtener más información sobre los especificadores de formato de enumeración, vea [Enumeration Format Strings](~/docs/standard/base-types/enumeration-format-strings.md).  
  
-   Para obtener más información sobre el formato, vea [aplicar formato a tipos](~/docs/standard/base-types/formatting-types.md).  
  
 Para obtener más información acerca del terminador de línea, consulte la sección Comentarios de la <xref:System.Console.WriteLine%2A> método que no toma ningún parámetro.  
  
   
  
## Examples  
 El ejemplo siguiente se llama el <xref:System.Console.WriteLine%28System.String%2CSystem.Object%29> método para mostrar cinco generado aleatoriamente <xref:System.Boolean> valores.  
  
 [!code-csharp[System.Console.WriteLine#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Console.WriteLine/CS/WriteLine6.cs#6)]
 [!code-vb[System.Console.WriteLine#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Console.WriteLine/VB/WriteLine6.vb#6)]  
  
 El ejemplo siguiente se llama el <xref:System.Console.WriteLine%28System.String%2CSystem.Object%29> método para mostrar la fecha actual.   Tenga en cuenta que el formato de elemento en el `format` argumento usa "D" [cadena de formato de fecha y hora estándar](~/docs/standard/base-types/standard-date-and-time-format-strings.md) para mostrar la fecha en el formato de fecha larga de la referencia cultural actual.  
  
 [!code-csharp[System.Console.WriteLine#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Console.WriteLine/CS/WriteLine7.cs#7)]
 [!code-vb[System.Console.WriteLine#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Console.WriteLine/VB/WriteLine7.vb#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Error de E/S.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="format" /> es <see langword="null" />.</exception>
        <exception cref="T:System.FormatException">La especificación de formato de <paramref name="format" /> no es válida.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">Para modificar las ventanas secundarias y ventanas seguras de nivel superior. Enumeración asociada: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
        <altmember cref="M:System.Console.Read" />
        <altmember cref="M:System.Console.ReadLine" />
        <altmember cref="M:System.Console.Write(System.String,System.Object)" />
        <related type="Article" href="~/docs/standard/base-types/formatting-types.md">Aplicar formato a tipos en .NET</related>
        <related type="Article" href="~/docs/standard/base-types/composite-formatting.md">Formatos compuestos</related>
      </Docs>
    </Member>
    <Member MemberName="WriteLine">
      <MemberSignature Language="C#" Value="public static void WriteLine (string format, params object[] arg);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteLine(string format, object[] arg) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.WriteLine(System.String,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteLine (format As String, ParamArray arg As Object())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteLine(System::String ^ format, ... cli::array &lt;System::Object ^&gt; ^ arg);" />
      <MemberSignature Language="F#" Value="static member WriteLine : string * obj[] -&gt; unit" Usage="System.Console.WriteLine (format, arg)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="arg" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="format">Cadena de formato compuesto.</param>
        <param name="arg">Matriz de objetos que se va a escribir con <paramref name="format" />.</param>
        <summary>Escribe la representación de texto de la matriz de objetos especificada, seguida del terminador de línea actual, en el flujo de salida estándar usando la información de formato especificada.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método usa la [característica de formato compuesto](~/docs/standard/base-types/composite-formatting.md) de .NET Framework para convertir el valor de un objeto en su representación de texto e incrustar esa representación en una cadena. La cadena resultante se escribe en el flujo de salida.  
  
 El `format` parámetro consta de cero o más ejecuciones de texto mezclado con cero o más marcadores de posición indizados, denominados elementos de formato, que corresponden a un objeto en la lista de parámetros de este método. El proceso de formato reemplaza cada elemento de formato con la representación de texto del valor del objeto correspondiente.  
  
 La sintaxis de un elemento de formato es `{` *índice*[`,`*alineación*] [`:`*formatString*]`}`, que especifica un índice obligatorio, opcional longitud y la alineación del texto con formato y una cadena opcional de caracteres del especificador de formato que rigen cómo se da formato el valor del objeto correspondiente.  
  
 .NET Framework proporciona una amplia compatibilidad de formato, que se describe con más detalle en los siguientes temas de formato.  
  
-   Para obtener más información acerca de la característica de formato compuesto compatible con métodos como <xref:System.String.Format%2A>, <xref:System.Text.StringBuilder.AppendFormat%2A>y algunas sobrecargas de <xref:System.Console.WriteLine%2A>, consulte [formatos compuestos](~/docs/standard/base-types/composite-formatting.md).  
  
-   Para obtener más información sobre los especificadores de formato numérico, vea [cadenas de formato numérico estándar](~/docs/standard/base-types/standard-numeric-format-strings.md) y [cadenas con formato numérico personalizado](~/docs/standard/base-types/custom-numeric-format-strings.md).  
  
-   Para obtener más información acerca de fecha y hora en especificadores de formato, vea [Standard Date and Time Format Strings](~/docs/standard/base-types/standard-date-and-time-format-strings.md) y [Custom Date and Time Format Strings](~/docs/standard/base-types/custom-date-and-time-format-strings.md).  
  
-   Para obtener más información sobre los especificadores de formato de enumeración, vea [Enumeration Format Strings](~/docs/standard/base-types/enumeration-format-strings.md).  
  
-   Para obtener más información sobre el formato, vea [aplicar formato a tipos](~/docs/standard/base-types/formatting-types.md).  
  
 Para obtener más información acerca del terminador de línea, consulte la sección Comentarios de la <xref:System.Console.WriteLine%2A> método que no toma ningún parámetro.  
  
   
  
## Examples  
 En el ejemplo siguiente se muestran los especificadores de formato estándar para números, fechas y enumeraciones.  
  
 [!code-cpp[console.writelineFmt1#1](~/samples/snippets/cpp/VS_Snippets_CLR/console.writelineFmt1/cpp/wl.cpp#1)] 
 [!code-csharp[console.writelineFmt1#1](~/samples/snippets/csharp/VS_Snippets_CLR/console.writelineFmt1/cs/wl.cs#1)]
 [!code-vb[console.writelineFmt1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/console.writelineFmt1/vb/wl.vb#1)]  
  
 El ejemplo siguiente es una calculadora de sugerencia que calcula una sugerencia 18% y usa el <xref:System.Console.WriteLine%2A> método para mostrar la cantidad de la carga original, la cantidad de la punta y la cantidad total. El ejemplo es una aplicación de consola que requiere que el usuario proporcionar la cantidad de la carga original como un parámetro de línea de comandos.  
  
 [!code-csharp[System.Console.WriteLine#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Console.WriteLine/CS/tipcalc.cs#1)]
 [!code-vb[System.Console.WriteLine#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Console.WriteLine/VB/tipcalc.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Error de E/S.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="format" /> o <paramref name="arg" /> es <see langword="null" />.</exception>
        <exception cref="T:System.FormatException">La especificación de formato de <paramref name="format" /> no es válida.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">Para modificar las ventanas secundarias y ventanas seguras de nivel superior. Enumeración asociada: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
        <block subset="none" type="usage"><para>Este método no se llama al código de C++. El compilador de C++ resuelve las llamadas a [System.Console.WriteLine](xref:System.Console.WriteLine*) que incluyen una cadena y una lista de cuatro o más parámetros de objeto como una llamada a <see cref="M:System.Console.WriteLine(System.String,System.Object,System.Object,System.Object,System.Object)" />. Resuelve las llamadas a [System.Console.WriteLine](xref:System.Console.WriteLine*) que incluyen una cadena y una matriz de objetos como una llamada a <see cref="M:System.Console.WriteLine(System.String,System.Object)" />.</para></block>
        <altmember cref="M:System.Console.Read" />
        <altmember cref="M:System.Console.ReadLine" />
        <altmember cref="M:System.Console.Write(System.String,System.Object)" />
        <related type="Article" href="~/docs/standard/base-types/formatting-types.md">Aplicar formato a tipos en .NET</related>
        <related type="Article" href="~/docs/standard/base-types/composite-formatting.md">Formatos compuestos</related>
      </Docs>
    </Member>
    <Member MemberName="WriteLine">
      <MemberSignature Language="C#" Value="public static void WriteLine (char[] buffer, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteLine(char[] buffer, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.WriteLine(System.Char[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteLine (buffer As Char(), index As Integer, count As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteLine(cli::array &lt;char&gt; ^ buffer, int index, int count);" />
      <MemberSignature Language="F#" Value="static member WriteLine : char[] * int * int -&gt; unit" Usage="System.Console.WriteLine (buffer, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Char[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="buffer">Matriz de caracteres Unicode.</param>
        <param name="index">Posición inicial en <paramref name="buffer" />.</param>
        <param name="count">Número de caracteres que se van a escribir.</param>
        <summary>Escribe la submatriz de caracteres Unicode especificada, seguida del terminador de línea actual, en el flujo de salida estándar.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método escribe `count` caracteres a partir de la posición `index` de `buffer` al flujo de salida estándar.  
  
 Para obtener más información acerca del terminador de línea, consulte la sección Comentarios de la <xref:System.Console.WriteLine%2A> método que no toma ningún parámetro.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> o <paramref name="count" /> es menor que cero.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="index" /> más <paramref name="count" /> especifica una posición que no está dentro de <paramref name="buffer" />.</exception>
        <exception cref="T:System.IO.IOException">Error de E/S.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">Para modificar las ventanas secundarias y ventanas seguras de nivel superior. Enumeración asociada: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
        <altmember cref="M:System.Console.Read" />
        <altmember cref="M:System.Console.ReadLine" />
        <altmember cref="M:System.Console.Write(System.String,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="WriteLine">
      <MemberSignature Language="C#" Value="public static void WriteLine (string format, object arg0, object arg1);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteLine(string format, object arg0, object arg1) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.WriteLine(System.String,System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteLine (format As String, arg0 As Object, arg1 As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteLine(System::String ^ format, System::Object ^ arg0, System::Object ^ arg1);" />
      <MemberSignature Language="F#" Value="static member WriteLine : string * obj * obj -&gt; unit" Usage="System.Console.WriteLine (format, arg0, arg1)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="arg0" Type="System.Object" />
        <Parameter Name="arg1" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="format">Cadena de formato compuesto.</param>
        <param name="arg0">Primer objeto que se va a escribir con <paramref name="format" />.</param>
        <param name="arg1">Segundo objeto que se va a escribir con <paramref name="format" />.</param>
        <summary>Escribe la representación de texto de los objetos especificados, seguida del terminador de línea actual, en el flujo de salida estándar usando la información de formato especificada.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método usa la [característica de formato compuesto](~/docs/standard/base-types/composite-formatting.md) de .NET Framework para convertir el valor de un objeto en su representación de texto e incrustar esa representación en una cadena. La cadena resultante se escribe en el flujo de salida.  
  
 El `format` parámetro consta de cero o más ejecuciones de texto mezclado con cero o más marcadores de posición indizados, denominados elementos de formato, que corresponden a un objeto en la lista de parámetros de este método. El proceso de formato reemplaza cada elemento de formato con la representación de texto del valor del objeto correspondiente.  
  
 La sintaxis de un elemento de formato es `{` *índice*[`,`*alineación*] [`:`*formatString*]`}`, que especifica un índice obligatorio, opcional longitud y la alineación del texto con formato y una cadena opcional de caracteres del especificador de formato que rigen cómo se da formato el valor del objeto correspondiente.  
  
 .NET Framework proporciona una amplia compatibilidad de formato, que se describe con más detalle en los siguientes temas de formato.  
  
-   Para obtener más información acerca de la característica de formato compuesto compatible con métodos como <xref:System.String.Format%2A>, <xref:System.Text.StringBuilder.AppendFormat%2A>y algunas sobrecargas de <xref:System.Console.WriteLine%2A>, consulte [formatos compuestos](~/docs/standard/base-types/composite-formatting.md).  
  
-   Para obtener más información sobre los especificadores de formato numérico, vea [cadenas de formato numérico estándar](~/docs/standard/base-types/standard-numeric-format-strings.md) y [cadenas con formato numérico personalizado](~/docs/standard/base-types/custom-numeric-format-strings.md).  
  
-   Para obtener más información acerca de fecha y hora en especificadores de formato, vea [Standard Date and Time Format Strings](~/docs/standard/base-types/standard-date-and-time-format-strings.md) y [Custom Date and Time Format Strings](~/docs/standard/base-types/custom-date-and-time-format-strings.md).  
  
-   Para obtener más información sobre los especificadores de formato de enumeración, vea [Enumeration Format Strings](~/docs/standard/base-types/enumeration-format-strings.md).  
  
-   Para obtener más información sobre el formato, vea [aplicar formato a tipos](~/docs/standard/base-types/formatting-types.md).  
  
 Para obtener más información acerca del terminador de línea, consulte la sección Comentarios de la <xref:System.Console.WriteLine%2A> método que no toma ningún parámetro.  
  
   
  
## Examples  
 En el ejemplo siguiente se muestran los especificadores de formato estándar para números, fechas y enumeraciones.  
  
 [!code-cpp[console.writelineFmt1#1](~/samples/snippets/cpp/VS_Snippets_CLR/console.writelineFmt1/cpp/wl.cpp#1)] 
 [!code-csharp[console.writelineFmt1#1](~/samples/snippets/csharp/VS_Snippets_CLR/console.writelineFmt1/cs/wl.cs#1)]
 [!code-vb[console.writelineFmt1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/console.writelineFmt1/vb/wl.vb#1)]  
  
 El ejemplo siguiente es una calculadora de sugerencia que calcula una sugerencia 18% y usa el <xref:System.Console.WriteLine%2A> método para mostrar la cantidad de la carga original, la cantidad de la punta y la cantidad total. El ejemplo es una aplicación de consola que requiere que el usuario proporcionar la cantidad de la carga original como un parámetro de línea de comandos.  
  
 [!code-csharp[System.Console.WriteLine#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Console.WriteLine/CS/tipcalc.cs#1)]
 [!code-vb[System.Console.WriteLine#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Console.WriteLine/VB/tipcalc.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Error de E/S.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="format" /> es <see langword="null" />.</exception>
        <exception cref="T:System.FormatException">La especificación de formato de <paramref name="format" /> no es válida.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">Para modificar las ventanas secundarias y ventanas seguras de nivel superior. Enumeración asociada: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
        <altmember cref="M:System.Console.Read" />
        <altmember cref="M:System.Console.ReadLine" />
        <altmember cref="M:System.Console.Write(System.String,System.Object)" />
        <related type="Article" href="~/docs/standard/base-types/formatting-types.md">Aplicar formato a tipos en .NET</related>
        <related type="Article" href="~/docs/standard/base-types/composite-formatting.md">Formatos compuestos</related>
      </Docs>
    </Member>
    <Member MemberName="WriteLine">
      <MemberSignature Language="C#" Value="public static void WriteLine (string format, object arg0, object arg1, object arg2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteLine(string format, object arg0, object arg1, object arg2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.WriteLine(System.String,System.Object,System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteLine (format As String, arg0 As Object, arg1 As Object, arg2 As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteLine(System::String ^ format, System::Object ^ arg0, System::Object ^ arg1, System::Object ^ arg2);" />
      <MemberSignature Language="F#" Value="static member WriteLine : string * obj * obj * obj -&gt; unit" Usage="System.Console.WriteLine (format, arg0, arg1, arg2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="arg0" Type="System.Object" />
        <Parameter Name="arg1" Type="System.Object" />
        <Parameter Name="arg2" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="format">Cadena de formato compuesto.</param>
        <param name="arg0">Primer objeto que se va a escribir con <paramref name="format" />.</param>
        <param name="arg1">Segundo objeto que se va a escribir con <paramref name="format" />.</param>
        <param name="arg2">Tercer objeto que se va a escribir con <paramref name="format" />.</param>
        <summary>Escribe la representación de texto de los objetos especificados, seguida del terminador de línea actual, en el flujo de salida estándar usando la información de formato especificada.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método usa la [característica de formato compuesto](~/docs/standard/base-types/composite-formatting.md) de .NET Framework para convertir el valor de un objeto en su representación de texto e incrustar esa representación en una cadena. La cadena resultante se escribe en el flujo de salida.  
  
 El `format` parámetro consta de cero o más ejecuciones de texto mezclado con cero o más marcadores de posición indizados, denominados elementos de formato, que corresponden a un objeto en la lista de parámetros de este método. El proceso de formato reemplaza cada elemento de formato con la representación de texto del valor del objeto correspondiente.  
  
 La sintaxis de un elemento de formato es `{` *índice*[`,`*alineación*] [`:`*formatString*]`}`, que especifica un índice obligatorio, opcional longitud y la alineación del texto con formato y una cadena opcional de caracteres del especificador de formato que rigen cómo se da formato el valor del objeto correspondiente.  
  
 .NET Framework proporciona una amplia compatibilidad de formato, que se describe con más detalle en los siguientes temas de formato.  
  
-   Para obtener más información acerca de la característica de formato compuesto compatible con métodos como <xref:System.String.Format%2A>, <xref:System.Text.StringBuilder.AppendFormat%2A>y algunas sobrecargas de <xref:System.Console.WriteLine%2A>, consulte [formatos compuestos](~/docs/standard/base-types/composite-formatting.md).  
  
-   Para obtener más información sobre los especificadores de formato numérico, vea [cadenas de formato numérico estándar](~/docs/standard/base-types/standard-numeric-format-strings.md) y [cadenas con formato numérico personalizado](~/docs/standard/base-types/custom-numeric-format-strings.md).  
  
-   Para obtener más información acerca de fecha y hora en especificadores de formato, vea [Standard Date and Time Format Strings](~/docs/standard/base-types/standard-date-and-time-format-strings.md) y [Custom Date and Time Format Strings](~/docs/standard/base-types/custom-date-and-time-format-strings.md).  
  
-   Para obtener más información sobre los especificadores de formato de enumeración, vea [Enumeration Format Strings](~/docs/standard/base-types/enumeration-format-strings.md).  
  
-   Para obtener más información sobre el formato, vea [aplicar formato a tipos](~/docs/standard/base-types/formatting-types.md).  
  
 Para obtener más información acerca del terminador de línea, consulte la sección Comentarios de la <xref:System.Console.WriteLine%2A> método que no toma ningún parámetro.  
  
   
  
## Examples  
 En el ejemplo siguiente se muestran los especificadores de formato estándar para números, fechas y enumeraciones.  
  
 [!code-cpp[console.writelineFmt1#1](~/samples/snippets/cpp/VS_Snippets_CLR/console.writelineFmt1/cpp/wl.cpp#1)] 
 [!code-csharp[console.writelineFmt1#1](~/samples/snippets/csharp/VS_Snippets_CLR/console.writelineFmt1/cs/wl.cs#1)]
 [!code-vb[console.writelineFmt1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/console.writelineFmt1/vb/wl.vb#1)]  
  
 El ejemplo siguiente es una calculadora de sugerencia que calcula una sugerencia 18% y usa el <xref:System.Console.WriteLine%2A> método para mostrar la cantidad de la carga original, la cantidad de la punta y la cantidad total. El ejemplo es una aplicación de consola que requiere que el usuario proporcionar la cantidad de la carga original como un parámetro de línea de comandos.  
  
 [!code-csharp[System.Console.WriteLine#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Console.WriteLine/CS/tipcalc.cs#1)]
 [!code-vb[System.Console.WriteLine#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Console.WriteLine/VB/tipcalc.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Error de E/S.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="format" /> es <see langword="null" />.</exception>
        <exception cref="T:System.FormatException">La especificación de formato de <paramref name="format" /> no es válida.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">Para modificar las ventanas secundarias y ventanas seguras de nivel superior. Enumeración asociada: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
        <altmember cref="M:System.Console.Read" />
        <altmember cref="M:System.Console.ReadLine" />
        <altmember cref="M:System.Console.Write(System.String,System.Object)" />
        <related type="Article" href="~/docs/standard/base-types/formatting-types.md">Aplicar formato a tipos en .NET</related>
        <related type="Article" href="~/docs/standard/base-types/composite-formatting.md">Formatos compuestos</related>
      </Docs>
    </Member>
    <Member MemberName="WriteLine">
      <MemberSignature Language="C#" Value="public static void WriteLine (string format, object arg0, object arg1, object arg2, object arg3);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteLine(string format, object arg0, object arg1, object arg2, object arg3) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.WriteLine(System.String,System.Object,System.Object,System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteLine (format As String, arg0 As Object, arg1 As Object, arg2 As Object, arg3 As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteLine(System::String ^ format, System::Object ^ arg0, System::Object ^ arg1, System::Object ^ arg2, System::Object ^ arg3);" />
      <MemberSignature Language="F#" Value="static member WriteLine : string * obj * obj * obj * obj -&gt; unit" Usage="System.Console.WriteLine (format, arg0, arg1, arg2, arg3)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="arg0" Type="System.Object" />
        <Parameter Name="arg1" Type="System.Object" />
        <Parameter Name="arg2" Type="System.Object" />
        <Parameter Name="arg3" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="format">Cadena de formato compuesto.</param>
        <param name="arg0">Primer objeto que se va a escribir con <paramref name="format" />.</param>
        <param name="arg1">Segundo objeto que se va a escribir con <paramref name="format" />.</param>
        <param name="arg2">Tercer objeto que se va a escribir con <paramref name="format" />.</param>
        <param name="arg3">Cuarto objeto que se va a escribir con <paramref name="format" />.</param>
        <summary>Escribe la representación de texto de los objetos especificados y la lista de parámetros de longitud variable, seguidas del terminador de línea actual, en el flujo de salida estándar usando la información de formato especificada.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Esta API no es conforme a CLS. La alternativa conforme a CLS es <xref:System.Console.WriteLine%28System.String%2CSystem.Object%5B%5D%29?displayProperty=nameWithType>. Los compiladores de C# y Visual Basic resolver automáticamente una llamada a este método como una llamada a <xref:System.Console.WriteLine%28System.String%2CSystem.Object%5B%5D%29?displayProperty=nameWithType>.  
  
 Este método usa la [característica de formato compuesto](~/docs/standard/base-types/composite-formatting.md) de .NET Framework para convertir el valor de un objeto en su representación de texto e incrustar esa representación en una cadena. La cadena resultante se escribe en el flujo de salida.  
  
 El `format` parámetro consta de cero o más ejecuciones de texto mezclado con cero o más marcadores de posición indizados, denominados elementos de formato, que corresponden a un objeto en la lista de parámetros de este método. El proceso de formato reemplaza cada elemento de formato con la representación de texto del valor del objeto correspondiente.  
  
 La sintaxis de un elemento de formato es `{` *índice*[`,`*alineación*] [`:`*formatString*]`}`, que especifica un índice obligatorio, opcional longitud y la alineación del texto con formato y una cadena opcional de caracteres del especificador de formato que rigen cómo se da formato el valor del objeto correspondiente.  
  
 .NET Framework proporciona una amplia compatibilidad de formato, que se describe con más detalle en los siguientes temas de formato.  
  
-   Para obtener más información acerca de la característica de formato compuesto compatible con métodos como <xref:System.String.Format%2A>, <xref:System.Text.StringBuilder.AppendFormat%2A>y algunas sobrecargas de <xref:System.Console.WriteLine%2A>, consulte [formatos compuestos](~/docs/standard/base-types/composite-formatting.md).  
  
-   Para obtener más información sobre los especificadores de formato numérico, vea [cadenas de formato numérico estándar](~/docs/standard/base-types/standard-numeric-format-strings.md) y [cadenas con formato numérico personalizado](~/docs/standard/base-types/custom-numeric-format-strings.md).  
  
-   Para obtener más información acerca de fecha y hora en especificadores de formato, vea [Standard Date and Time Format Strings](~/docs/standard/base-types/standard-date-and-time-format-strings.md) y [Custom Date and Time Format Strings](~/docs/standard/base-types/custom-date-and-time-format-strings.md).  
  
-   Para obtener más información sobre los especificadores de formato de enumeración, vea [Enumeration Format Strings](~/docs/standard/base-types/enumeration-format-strings.md).  
  
-   Para obtener más información sobre el formato, vea [aplicar formato a tipos](~/docs/standard/base-types/formatting-types.md).  
  
 Para obtener más información acerca del terminador de línea, consulte la sección Comentarios de la <xref:System.Console.WriteLine%2A> método que no toma ningún parámetro.  
  
   
  
## Examples  
 El ejemplo siguiente muestra el uso de argumentos de variable con el <xref:System.Console.WriteLine%28System.String%2CSystem.Object%2CSystem.Object%2CSystem.Object%2CSystem.Object%29> método. Se llama al método con una cadena de formato compuesto y cinco elementos de formato.  
  
 [!code-cpp[System.Console.WriteLine#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Console.WriteLine/CPP/writeline_vararg.cpp#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Error de E/S.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="format" /> es <see langword="null" />.</exception>
        <exception cref="T:System.FormatException">La especificación de formato de <paramref name="format" /> no es válida.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">Para modificar las ventanas secundarias y ventanas seguras de nivel superior. Enumeración asociada: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
        <block subset="none" type="usage"><para>Este método está marcado con el <see langword="vararg" /> palabra clave, lo que significa que admite un número variable de parámetros. El método puede llamarse desde Visual C++, pero no se puede llamar desde el código de C# o Visual Basic. Los compiladores de C# y Visual Basic resolver llamadas a <see cref="M:System.Console.WriteLine(System.String,System.Object,System.Object,System.Object,System.Object)" /> como llamadas a <see cref="M:System.Console.WriteLine(System.String,System.Object[])" />.</para></block>
        <altmember cref="M:System.Console.Read" />
        <altmember cref="M:System.Console.ReadLine" />
        <altmember cref="M:System.Console.Write(System.String,System.Object)" />
        <related type="Article" href="~/docs/standard/base-types/formatting-types.md">Aplicar formato a tipos en .NET</related>
        <related type="Article" href="~/docs/standard/base-types/composite-formatting.md">Formatos compuestos</related>
      </Docs>
    </Member>
  </Members>
</Type>