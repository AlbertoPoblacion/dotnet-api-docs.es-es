<Type Name="Single" FullName="System.Single">
  <Metadata><Meta Name="ms.openlocfilehash" Value="51a91450fc3d21c7156ea132b7b40d17c834af7b" /><Meta Name="ms.sourcegitcommit" Value="c5fd6b431a16f0412349201a0e93a9eacddf4b35" /><Meta Name="ms.translationtype" Value="HT" /><Meta Name="ms.contentlocale" Value="es-ES" /><Meta Name="ms.lasthandoff" Value="12/14/2018" /><Meta Name="ms.locfileid" Value="53395882" /></Metadata><TypeSignature Language="C#" Value="public struct Single : IComparable, IComparable&lt;float&gt;, IConvertible, IEquatable&lt;float&gt;, IFormattable" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi serializable sealed beforefieldinit float32 extends System.ValueType implements class System.IComparable, class System.IComparable`1&lt;float32&gt;, class System.IConvertible, class System.IEquatable`1&lt;float32&gt;, class System.IFormattable" />
  <TypeSignature Language="DocId" Value="T:System.Single" />
  <TypeSignature Language="VB.NET" Value="Public Structure Single&#xA;Implements IComparable, IComparable(Of Single), IConvertible, IEquatable(Of Single), IFormattable" />
  <TypeSignature Language="C++ CLI" Value="public value class Single : IComparable, IComparable&lt;float&gt;, IConvertible, IEquatable&lt;float&gt;, IFormattable" />
  <TypeSignature Language="F#" Value="type single = struct&#xA;    interface IFormattable&#xA;    interface IConvertible" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.ValueType</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IComparable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IComparable&lt;System.Single&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IConvertible</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IEquatable&lt;System.Single&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IFormattable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Representa un número de punto flotante de precisión sencilla.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Single> tipo de valor representa un número de 32 bits de precisión sencilla con valores comprendidos entre 3, 402823E38 y negativo y positivo 3. 402823e38, así como cero positivo o negativo, <xref:System.Single.PositiveInfinity>, <xref:System.Single.NegativeInfinity>y no es un número (<xref:System.Single.NaN>). Está diseñado para representar los valores que son extremadamente grandes (por ejemplo, las distancias entre los planetas o galaxias) o muy pequeño (por ejemplo, la masa molecular de una sustancia en kilogramos) y que a menudo son precisos (como la distancia desde la tierra en otro sistema solar ). El <xref:System.Single> tipo satisface el IEC 60559: 1989 (IEEE 754) estándar para aritmética binaria de punto flotante.  
  
 Este tema consta de las siguientes secciones:  
  
-   [Precisión y la representación de punto flotante](#Precision)  
  
-   [Probar la igualdad](#Equality)  
  
-   [Las excepciones y los valores de punto flotante](#Exceptions)  
  
-   [Conversión de tipos y la estructura única](#Conversion)  
  
-   [Funcionalidad de punto flotante](#Functionality)  
  
 <xref:System.Single?displayProperty=nameWithType> Proporciona métodos para comparar instancias de este tipo, para convertir el valor de una instancia en su representación de cadena y convertir la representación de cadena de un número a una instancia de este tipo. Para obtener información acerca de cómo los códigos de especificación de formato controlan la representación de cadena de tipos de valor, vea [aplicar formato a tipos](~/docs/standard/base-types/formatting-types.md), [cadenas de formato numérico estándar](~/docs/standard/base-types/standard-numeric-format-strings.md), y [numérico personalizado Las cadenas de formato](~/docs/standard/base-types/custom-numeric-format-strings.md).  
  
<a name="Precision"></a>   
## <a name="floating-point-representation-and-precision"></a>Precisión y la representación de punto flotante  
 El <xref:System.Single> tipo de datos almacena los valores de punto flotante de precisión sencilla en un formato binario de 32 bits, tal como se muestra en la tabla siguiente:  
  
|Parte|Bits|  
|----------|----------|  
|Significado o mantisa|0-22|  
|Exponente|23-30|  
|Inicio de sesión (0 = positivo, 1 = negativo)|31|  
  
 Tal como fracciones decimales son no se puede representar con precisión los valores fraccionarios (por ejemplo, 1/3 o <xref:System.Math.PI?displayProperty=nameWithType>), fracciones binarias son no puede representar algunos valores fraccionarios. Por ejemplo, 2 y 10, que se representa con precisión,.2 como una fracción decimal, se representa mediante.0011111001001100 como una fracción binaria con el patrón de repetición "1100" hasta el infinito. En este caso, el valor de punto flotante proporciona una representación imprecisa del número que representa. Realizar operaciones matemáticas adicionales en el valor de punto flotante original a menudo aumenta su falta de precisión. Por ejemplo, si compara el resultado de multiplicar.3 por 10 y agregar.3 a.3 nueve veces, verá esta adición genera el resultado de la proporciona resultados menos preciso, dado que implica más de ocho operaciones de multiplicación. Tenga en cuenta que esta discrepancia es evidente sólo si se muestran las dos <xref:System.Single> valores mediante el uso de la "R" [cadena de formato numérico estándar](~/docs/standard/base-types/standard-numeric-format-strings.md), que, si es necesario, muestra todos los 9 dígitos de precisión admitida por el <xref:System.Single> tipo.  
  
 [!code-csharp[System.Single.Structure#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.single.structure/cs/representation1.cs#3)]
 [!code-vb[System.Single.Structure#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.single.structure/vb/representation1.vb#3)]  
  
 Dado que algunos números no se puede representar exactamente como valores binarios fraccionarios, números de punto flotante pueden solo los números reales aproximados.  
  
 Todos los números de punto flotante tienen un número limitado de dígitos significativos, que también determina la precisión con un valor de punto flotante se aproxima a un número real. Un <xref:System.Single> valor tiene hasta 7 dígitos decimales de precisión, aunque internamente se mantiene un máximo de 9 dígitos. Esto significa que algunas operaciones de punto flotante pueden carecer de la precisión para cambiar el valor de punto flotante. El ejemplo siguiente se define un valor de punto flotante de precisión sencilla grande y, a continuación, agrega el producto de <xref:System.Single.Epsilon?displayProperty=nameWithType> y mil billones a él. Sin embargo, el producto es demasiado pequeño para modificar el valor de punto flotante original. Sus dígitos menos significativos es milésimas, mientras que el dígito más significativo en el producto es 10<sup>-30</sup>.  
  
 [!code-csharp[System.Single.Structure#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.single.structure/cs/representation2.cs#4)]
 [!code-vb[System.Single.Structure#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.single.structure/vb/representation2.vb#4)]  
  
 La precisión limitada de un número de punto flotante tiene varias consecuencias:  
  
-   Dos números de punto flotante que parecen iguales para una precisión determinada podrían no son iguales porque sus dígitos menos significativos son diferentes. En el ejemplo siguiente, se suman una serie de números y el total se compara con su total esperado. Aunque los dos valores parecen ser la misma, una llamada a la `Equals` método indica que no son.  
  
     [!code-csharp[System.Single.Structure#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.single.structure/cs/precisionlist3.cs#6)]
     [!code-vb[System.Single.Structure#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.single.structure/vb/precisionlist3.vb#6)]  
  
     Si cambia los elementos de formato en el <xref:System.Console.WriteLine%28System.String%2CSystem.Object%2CSystem.Object%29?displayProperty=nameWithType> instrucción desde `{0}` y `{1}` a `{0:R}` y `{1:R}` para mostrar todos los dígitos significativos de los dos <xref:System.Single> valores, está claro que los dos valores son iguales porque de una pérdida de precisión durante las operaciones de adición. En este caso, el problema puede resolverse mediante una llamada a la <xref:System.Math.Round%28System.Double%2CSystem.Int32%29?displayProperty=nameWithType> método para redondear el <xref:System.Single> valores a la precisión deseado antes de realizar la comparación.  
  
-   Una operación matemática o de comparación que utiliza un número de punto flotante podría no producir el mismo resultado si se usa un número decimal, porque el número de punto flotante binario no podría ser igual al número decimal. El ejemplo anterior ilustra esto mostrando el resultado de multiplicar.3 por 10 y agregar.3 a.3 nueve veces.  
  
     Cuando es importante la precisión en las operaciones numéricas con los valores fraccionarios, utilice el <xref:System.Decimal> en lugar del tipo el <xref:System.Single> tipo. Cuando la precisión en las operaciones numéricas con valores enteros más allá del intervalo de la <xref:System.Int64> o <xref:System.UInt64> tipos es importante, use el <xref:System.Numerics.BigInteger> tipo.  
  
-   Es posible que un valor no ida y vuelta si está implicado un número de punto flotante. Se dice que un valor de ida y vuelta si una operación convierte a un número de punto flotante original a otro, una operación inversa transforma el formato convertido a un número de punto flotante y el número de punto flotante final es igual a la versión original número de punto flotante. Puede producir un error en la ida y vuelta porque uno o más dígitos menos significativos se pierden o cambian en una conversión. En el ejemplo siguiente, tres <xref:System.Single> valores se convierten en cadenas y se guardan en un archivo. Como se muestra en la salida, aunque los valores parecen ser idénticas, los valores restaurados no son iguales a los valores originales.  
  
     [!code-csharp[System.Single.Structure#17](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.single.structure/cs/precisionlist4a.cs#17)]
     [!code-vb[System.Single.Structure#17](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.single.structure/vb/PrecisionList4a.vb#17)]  
  
     En este caso, los valores pueden ser la ida y vuelta correctamente mediante el uso de la "G9" [cadena de formato numérico estándar](~/docs/standard/base-types/standard-numeric-format-strings.md) para conservar la precisión completa de <xref:System.Single> valores, como se muestra en el ejemplo siguiente.  
  
     [!code-csharp[System.Single.Structure#18](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.single.structure/cs/PrecisionList5a.cs#18)]
     [!code-vb[System.Single.Structure#18](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.single.structure/vb/PrecisionList5a.vb#18)]  
  
-   <xref:System.Single> los valores tienen la menor precisión que <xref:System.Double> valores. Un <xref:System.Single> valor que se convierte en un equivalente aparentemente <xref:System.Double> a menudo no es igual a la <xref:System.Double> valor debido a diferencias en la precisión. En el ejemplo siguiente, se asigna el resultado de operaciones de división idéntico a un <xref:System.Double> valor y un <xref:System.Single> valor. Después de la <xref:System.Single> valor se convierte en un <xref:System.Double>, se muestra una comparación de los dos valores que son iguales.  
  
     [!code-csharp[System.Double.Structure#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.structure/cs/precisionlist1.cs#5)]
     [!code-vb[System.Double.Structure#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.structure/vb/precisionlist1.vb#5)]  
  
     Para evitar este problema, utilice el <xref:System.Double> de tipos de datos en lugar de la <xref:System.Single> tipo de datos o use el <xref:System.Math.Round%2A> método para que ambos valores tienen la misma precisión.  
  
<a name="Equality"></a>   
## <a name="testing-for-equality"></a>Probar la igualdad  
 Para considerarse iguales, dos <xref:System.Single> valores deben representar valores idénticos. Sin embargo, debido a diferencias en precisión entre valores, o debido a una pérdida de precisión por uno o ambos valores, valores de punto flotante que se esperan que sean idénticos a menudo resultan para ser desigual debido a diferencias en sus dígitos menos significativos. Como resultado, las llamadas a la <xref:System.Single.Equals%2A> método para determinar si dos valores son iguales, o las llamadas a la <xref:System.Single.CompareTo%2A> método para determinar la relación entre dos <xref:System.Single> valores, a menudo producen resultados inesperados. Esto es evidente en el ejemplo siguiente, donde dos sea aparentemente <xref:System.Single> valores resultan para ser iguales, porque el primer valor tiene 7 dígitos de precisión, mientras que el segundo valor tiene 9.  
  
 [!code-csharp[System.Single.Structure#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.single.structure/cs/comparison1.cs#9)]
 [!code-vb[System.Single.Structure#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.single.structure/vb/comparison1.vb#9)]  
  
 Los valores calculados que siguen diferentes rutas de código y que a menudo se manipulan de maneras diferentes resultar desiguales. En el ejemplo siguiente, un <xref:System.Single> se multiplica el valor y, a continuación, se calcula la raíz cuadrada para restaurar el valor original. Un segundo <xref:System.Single> se multiplica por 3.51 y cuadrado antes de la raíz cuadrada del resultado se divide por 3.51 para restaurar el valor original. Aunque los dos valores parezcan idénticas, una llamada a la <xref:System.Single.Equals%28System.Single%29> método indica que no son iguales. Uso de la cadena de formato estándar "G9" para devolver una cadena de resultado que muestra todos los dígitos significativos de cada <xref:System.Single> valor se muestra que el segundo valor es.0000000000001 menor que el primero.  
  
 [!code-csharp[System.Single.Structure#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.single.structure/cs/comparison2.cs#10)]
 [!code-vb[System.Single.Structure#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.single.structure/vb/comparison2.vb#10)]  
  
 En casos donde es probable que afecta al resultado de una comparación de una pérdida de precisión, puede usar las técnicas siguientes en lugar de llamar el <xref:System.Single.Equals%2A> o <xref:System.Single.CompareTo%2A> método:  
  
-   Llame a la <xref:System.Math.Round%2A?displayProperty=nameWithType> método para asegurarse de que ambos valores tienen la misma precisión. El ejemplo siguiente modifica un ejemplo anterior para usar este enfoque para que dos valores fraccionarios son equivalentes.  
  
     [!code-csharp[System.Single.Structure#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.single.structure/cs/comparison3.cs#11)]
     [!code-vb[System.Single.Structure#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.single.structure/vb/comparison3.vb#11)]  
  
     Tenga en cuenta que el problema de precisión sigue siendo aplicable al redondeo de valores de punto medio. Para obtener más información, vea el método <xref:System.Math.Round%28System.Double%2CSystem.Int32%2CSystem.MidpointRounding%29?displayProperty=nameWithType>.  
  
-   Probar la igualdad aproximado en lugar de igualdad. Esta técnica requiere que se defina cualquier absoluta cantidad por la que los dos valores pueden diferir pero aún ser igual o definir una cantidad relativa por el que el valor más pequeño puede diferir el valor más grande.  
  
    > [!WARNING]
    >  <xref:System.Single.Epsilon?displayProperty=nameWithType> a veces se usa como una medida de la distancia entre dos absoluta <xref:System.Single> valores al probar la igualdad.  Sin embargo, <xref:System.Single.Epsilon?displayProperty=nameWithType> mide el menor valor posible que se puede sumar o restar, un <xref:System.Single> cuyo valor es cero. Para la mayoría de valores positivos y negativos <xref:System.Single> valores, el valor de <xref:System.Single.Epsilon?displayProperty=nameWithType> es demasiado pequeño para que lo detecte. Por lo tanto, excepto para los valores que son iguales a cero, no se recomienda su uso en las pruebas de igualdad.  
  
     En el ejemplo siguiente se usa el último enfoque para definir un `IsApproximatelyEqual` método para probar la diferencia relativa entre dos valores. También se contrastan el resultado de las llamadas a la `IsApproximatelyEqual` método y el <xref:System.Single.Equals%28System.Single%29> método.  
  
     [!code-csharp[System.Single.Structure#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.single.structure/cs/comparison4.cs#12)]
     [!code-vb[System.Single.Structure#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.single.structure/vb/comparison4.vb#12)]  
  
<a name="Exceptions"></a>   
## <a name="floating-point-values-and-exceptions"></a>Las excepciones y los valores de punto flotante  
 Operaciones con valores de punto flotante no producen excepciones, a diferencia de las operaciones con tipos enteros, que inician excepciones en los casos de operaciones ilegales, como la división por cero o desbordamiento.  En su lugar, en estas situaciones, el resultado de una operación de punto flotante es cero, infinito positivo, infinito negativo o no es un número (NaN):  
  
-   Si el resultado de una operación de punto flotante es demasiado pequeño para el formato de destino, el resultado es cero. Esto puede ocurrir cuando se multiplican dos números de punto flotante muy pequeños, como se muestra en el ejemplo siguiente.  
  
     [!code-csharp[System.Single.Structure#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.single.structure/cs/exceptional1.cs#1)]
     [!code-vb[System.Single.Structure#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.single.structure/vb/exceptional1.vb#1)]  
  
-   Si la magnitud del resultado de una operación de punto flotante supera el intervalo del formato de destino, el resultado de la operación es <xref:System.Single.PositiveInfinity> o <xref:System.Single.NegativeInfinity>, según corresponda para el signo del resultado. El resultado de una operación que desborda <xref:System.Single.MaxValue?displayProperty=nameWithType> es <xref:System.Single.PositiveInfinity>y el resultado de una operación que desborda <xref:System.Single.MinValue?displayProperty=nameWithType> es <xref:System.Single.NegativeInfinity>, tal y como se muestra en el ejemplo siguiente.  
  
     [!code-csharp[System.Single.Structure#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.single.structure/cs/exceptional2.cs#2)]
     [!code-vb[System.Single.Structure#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.single.structure/vb/exceptional2.vb#2)]  
  
     <xref:System.Single.PositiveInfinity> También se produce de una división por cero con un dividendo positivo, y <xref:System.Single.NegativeInfinity> da como resultado de una división por cero con un dividendo negativo.  
  
-   Si una operación de punto flotante no es válida, el resultado de la operación es <xref:System.Single.NaN>. Por ejemplo, <xref:System.Single.NaN> da como resultado de las siguientes operaciones:  
  
    -   División por cero con un dividendo de cero. Tenga en cuenta que los demás casos de división por cero resultados de cualquiera <xref:System.Single.PositiveInfinity> o <xref:System.Single.NegativeInfinity>.  
  
    -   Cualquier operación de punto flotante con una entrada no válida. Por ejemplo, intentando encontrar devuelve la raíz cuadrada de un valor negativo <xref:System.Single.NaN>.  
  
    -   Cualquier operación con un argumento cuyo valor es <xref:System.Single.NaN?displayProperty=nameWithType>.  
  
<a name="Conversion"></a>   
## <a name="type-conversions-and-the-single-structure"></a>Las conversiones de tipos y la estructura única  
 El <xref:System.Single> estructura no define ningún operador de conversión explícita o implícita; en su lugar, las conversiones se implementan el compilador.  
  
 En la tabla siguiente se enumera las conversiones posibles de un valor de los otros tipos numéricos primitivos a una <xref:System.Single> valor, indica si la conversión es ampliación o restricción y si también resultante <xref:System.Single> puede tener la menor precisión que el valor original.  
  
|Conversión de|Ampliación de restricción|Posible pérdida de precisión|  
|---------------------|-------------------------|--------------------------------|  
|<xref:System.Byte>|Widening|No|  
|<xref:System.Decimal>|Widening<br /><br /> Tenga en cuenta que C# requiere un operador de conversión.|Sí. <xref:System.Decimal> es compatible con 29 dígitos decimales de precisión; <xref:System.Single> es compatible con 9.|  
|<xref:System.Double>|Restricción; los valores fuera del intervalo se convierten en <xref:System.Double.NegativeInfinity?displayProperty=nameWithType> o <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>.|Sí. <xref:System.Double> admite 17 dígitos decimales de precisión; <xref:System.Single> es compatible con 9.|  
|<xref:System.Int16>|Widening|No|  
|<xref:System.Int32>|Widening|Sí. <xref:System.Int32> es compatible con 10 dígitos decimales de precisión; <xref:System.Single> es compatible con 9.|  
|<xref:System.Int64>|Widening|Sí. <xref:System.Int64> es compatible con 19 dígitos decimales de precisión; <xref:System.Single> es compatible con 9.|  
|<xref:System.SByte>|Widening|No|  
|<xref:System.UInt16>|Widening|No|  
|<xref:System.UInt32>|Widening|Sí. <xref:System.UInt32> es compatible con 10 dígitos decimales de precisión; <xref:System.Single> es compatible con 9.|  
|<xref:System.UInt64>|Widening|Sí. <xref:System.Int64> es compatible con 20 dígitos decimales de precisión; <xref:System.Single> es compatible con 9.|  
  
 El ejemplo siguiente convierte el valor mínimo o máximo de otros tipos numéricos primitivos a una <xref:System.Single> valor.  
  
 [!code-csharp[System.Single.Structure#20](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.single.structure/cs/convert1.cs#20)]
 [!code-vb[System.Single.Structure#20](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.single.structure/vb/convert1.vb#20)]  
  
 Además, el <xref:System.Double> valores <xref:System.Double.NaN?displayProperty=nameWithType>, <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>, y <xref:System.Double.NegativeInfinity?displayProperty=nameWithType> convertir a <xref:System.Single.NaN?displayProperty=nameWithType>, <xref:System.Single.PositiveInfinity?displayProperty=nameWithType>, y <xref:System.Single.NegativeInfinity?displayProperty=nameWithType>, respectivamente.  
  
 Tenga en cuenta que la conversión del valor de algunos tipos numéricos para un <xref:System.Single> valor puede conllevar una pérdida de precisión. Como se muestra en el ejemplo siguiente, una pérdida de precisión es posible al convertir <xref:System.Decimal>, <xref:System.Double>, <xref:System.Int32>, <xref:System.Int64>, <xref:System.UInt32>, y <xref:System.UInt64> valores <xref:System.Single> valores.  
  
 La conversión de un <xref:System.Single> valor a un <xref:System.Double> es una conversión de ampliación. La conversión puede producir una pérdida de precisión si el <xref:System.Double> tipo no tiene una representación precisa para el <xref:System.Single> valor.  
  
 La conversión de un <xref:System.Single> valor distinto en un valor de cualquier tipo numérico primitivo un <xref:System.Double> es una conversión de restricción y requiere un operador de conversión (en C#) o un método de conversión (en Visual Basic). Los valores que están fuera del intervalo del tipo de datos de destino, que se definen mediante el tipo de destino `MinValue` y `MaxValue` de las propiedades, se comportan como se muestra en la tabla siguiente.  
  
|Tipo de destino|Resultado|  
|-----------------|------------|  
|Cualquier tipo integral|Un <xref:System.OverflowException> excepción si la conversión se produce en un contexto comprobado.<br /><br /> Si la conversión se produce en un contexto no comprobado (el valor predeterminado en C#), la operación de conversión se realiza correctamente, pero el valor se desborda.|  
|<xref:System.Decimal>|Un <xref:System.OverflowException> excepción,|  
  
 Además, <xref:System.Single.NaN?displayProperty=nameWithType>, <xref:System.Single.PositiveInfinity?displayProperty=nameWithType>, y <xref:System.Single.NegativeInfinity?displayProperty=nameWithType> producir una <xref:System.OverflowException> para las conversiones de enteros en un contexto comprobado, pero estos desbordamiento valores cuando se convierten en enteros en un contexto no comprobado. Para las conversiones a <xref:System.Decimal>, siempre producen un <xref:System.OverflowException>. Para las conversiones a <xref:System.Double>, se convierten a <xref:System.Double.NaN?displayProperty=nameWithType>, <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>, y <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>, respectivamente.  
  
 Tenga en cuenta que puede producir una pérdida de precisión en la conversión de un <xref:System.Single> valor a otro tipo numérico. En el caso de conversión no integrales <xref:System.Single> valores, como se muestra el resultado del ejemplo, el componente de fracción se pierde cuando el <xref:System.Single> valor se redondea (como en Visual Basic) o se truncan (como en C#). Para las conversiones a <xref:System.Decimal> valores, el <xref:System.Single> valor no puede tener una representación precisa en el tipo de datos de destino.  
  
 El siguiente ejemplo convierte un número de <xref:System.Single> valores para otros tipos numéricos. Las conversiones se producen en un contexto comprobado en Visual Basic (valor predeterminado) y en C# (porque el [comprueban](~/docs/csharp/language-reference/keywords/checked.md) palabra clave). El resultado del ejemplo muestra el resultado para las conversiones en ambos un activado un contexto no comprobado. Puede realizar conversiones en un contexto no comprobado en Visual Basic a la compilación con el `/removeintchecks+` modificador del compilador y en C# marcando como comentario el `checked` instrucción.  
  
 [!code-csharp[System.Single.Structure#21](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.single.structure/cs/convert2.cs#21)]
 [!code-vb[System.Single.Structure#21](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.single.structure/vb/convert2.vb#21)]  
  
 Para obtener más información sobre la conversión de tipos numéricos, vea [conversión de tipos en .NET Framework](~/docs/standard/base-types/type-conversion.md) y [tablas de conversión de tipo](~/docs/standard/base-types/conversion-tables.md).  
  
<a name="Functionality"></a>   
## <a name="floating-point-functionality"></a>Funcionalidad de punto flotante  
 El <xref:System.Single> estructura y los tipos relacionados proporcionan métodos para llevar a cabo las siguientes categorías de operaciones:  
  
-   **Comparación de valores**. Puede llamar a la <xref:System.Single.Equals%2A> método para determinar si dos <xref:System.Single> valores son iguales, o el <xref:System.Single.CompareTo%2A> método para determinar la relación entre dos valores.  
  
     El <xref:System.Single> estructura también admite un conjunto completo de operadores de comparación. Por ejemplo, puede probar para igualdad o desigualdad o determinar si un valor es mayor o igual que otro valor. Si uno de los operandos es una <xref:System.Double>, <xref:System.Single> valor se convierte en un <xref:System.Double> antes de realizar la comparación. Si uno de los operandos es un tipo entero, se convierte en un <xref:System.Single> antes de realizar la comparación. Aunque estas son las conversiones de ampliación, puede conllevar una pérdida de precisión.  
  
    > [!WARNING]
    >  Debido a diferencias en precisión, dos <xref:System.Single> valores que se esperan que sea igual que resultó para ser desigual, lo que afecta al resultado de la comparación. Consulte la [probar la igualdad](#Equality) sección para obtener más información sobre cómo comparar dos <xref:System.Single> valores.  
  
     También puede llamar a la <xref:System.Single.IsNaN%2A>, <xref:System.Single.IsInfinity%2A>, <xref:System.Single.IsPositiveInfinity%2A>, y <xref:System.Single.IsNegativeInfinity%2A> métodos para comprobar estos valores especiales.  
  
-   **Operaciones matemáticas**. Las operaciones aritméticas comunes, como suma, resta, multiplicación y división se implementan mediante compiladores de lenguaje y las instrucciones de lenguaje intermedio común (CIL) en lugar de <xref:System.Single> métodos. Si el otro operando en una operación matemática es un <xref:System.Double>, <xref:System.Single> se convierte en un <xref:System.Double> antes de realizar la operación y el resultado de la operación es también un <xref:System.Double> valor. Si el otro operando es un tipo entero, se convierte en un <xref:System.Single> antes de realizar la operación y el resultado de la operación es también un <xref:System.Single> valor.  
  
     Puede realizar otras operaciones matemáticas mediante una llamada a `static` (`Shared` en Visual Basic) métodos en el <xref:System.Math?displayProperty=nameWithType> clase. Estos incluyen métodos adicionales usados para la aritmética de (como <xref:System.Math.Abs%2A?displayProperty=nameWithType>, <xref:System.Math.Sign%2A?displayProperty=nameWithType>, y <xref:System.Math.Sqrt%2A?displayProperty=nameWithType>), geometría (como <xref:System.Math.Cos%2A?displayProperty=nameWithType> y <xref:System.Math.Sin%2A?displayProperty=nameWithType>) y el cálculo (como <xref:System.Math.Log%2A?displayProperty=nameWithType>).  En todos los casos, el <xref:System.Single> valor se convierte en un <xref:System.Double>.  
  
     También puede manipular los bits individuales de un <xref:System.Single> valor. El <xref:System.BitConverter.GetBytes%28System.Single%29?displayProperty=nameWithType> método devuelve su patrón de bits en una matriz de bytes.  Al pasar esa matriz de bytes para la <xref:System.BitConverter.ToInt32%2A?displayProperty=nameWithType> método, también puede conservar el <xref:System.Single> valor de patrón de bits en un entero de 32 bits.  
  
-   **Redondeo**. Redondeo a menudo se usa como una técnica para reducir el impacto de las diferencias entre los valores causados por problemas de representación de punto flotante y precisión. Se puede redondear un <xref:System.Single> valor mediante una llamada a la <xref:System.Math.Round%2A?displayProperty=nameWithType> método. Sin embargo, tenga en cuenta que el <xref:System.Single> valor se convierte en un <xref:System.Double> antes de que se llama al método y la conversión puede conllevar una pérdida de precisión.  
  
-   **Formato**. Puede convertir un <xref:System.Single> valor a su representación de cadena mediante una llamada a la <xref:System.Single.ToString%2A> método o mediante el [formatos compuestos](~/docs/standard/base-types/composite-formatting.md) característica. Para obtener información acerca de cómo las cadenas de formato controlan la representación de cadena de valores de punto flotante, vea el [cadenas de formato numérico estándar](~/docs/standard/base-types/standard-numeric-format-strings.md) y [cadenas con formato numérico personalizado](~/docs/standard/base-types/custom-numeric-format-strings.md) temas.  
  
-   **Analizar cadenas**. Puede convertir la representación de cadena del valor de punto flotante a un <xref:System.Single> valor mediante una llamada a la <xref:System.Single.Parse%2A> o <xref:System.Single.TryParse%2A> método. Si se produce un error en la operación de análisis, el <xref:System.Single.Parse%2A> método produce una excepción, mientras que el <xref:System.Single.TryParse%2A> devuelve del método `false`.  
  
-   **Conversión de tipos**. El <xref:System.Single> estructura proporciona una implementación de interfaz explícita para la <xref:System.IConvertible> interfaz, que admite la conversión entre los dos tipos de datos estándar de .NET Framework. Los compiladores de lenguajes también admiten la conversión implícita de valores para todos los otros tipos numéricos estándares, excepto la conversión de <xref:System.Double> a <xref:System.Single> valores. Conversión de un valor de cualquier tipo numérico estándar no sea un <xref:System.Double> a un <xref:System.Single> es una conversión de ampliación y no requiere el uso de un método de conversión o el operador de conversión.  
  
     Sin embargo, la conversión de valores enteros de 32 bits y 64 bits puede conllevar una pérdida de precisión. En la tabla siguiente se enumera las diferencias en la precisión de 32 bits, 64 bits, y <xref:System.Double> tipos:  
  
    |Tipo|Precisión máxima (en dígitos decimales)|Precisión interna (de dígitos decimales)|  
    |----------|---------------------------------------------|----------------------------------------------|  
    |<xref:System.Double>|15|17|  
    |<xref:System.Int32> y <xref:System.UInt32>|10|10|  
    |<xref:System.Int64> y <xref:System.UInt64>|19|19|  
    |<xref:System.Single>|7|9|  
  
     El problema de precisión con más frecuencia afecta a <xref:System.Single> valores que se convierten en <xref:System.Double> valores. En el ejemplo siguiente, dos valores generados por operaciones de división idénticos no son iguales, porque uno de los valores es un valor de punto flotante de precisión sencilla que se convierte en un <xref:System.Double>.  
  
     [!code-csharp[System.Single.Structure#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.single.structure/cs/precisionlist1.cs#5)]
     [!code-vb[System.Single.Structure#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.single.structure/vb/precisionlist1.vb#5)]  
  
 ]]></format>
    </remarks>
    <threadsafe>Todos los miembros de este tipo son seguros para subprocesos. Los miembros que aparecen modificar el estado de instancia devuelven realmente una nueva instancia inicializada con el nuevo valor. Como con cualquier otro tipo, leer y escribir en una variable compartida que contiene una instancia de este tipo deben protegerse mediante un bloqueo para garantizar la seguridad para subprocesos.</threadsafe>
    <altmember cref="T:System.Decimal" />
    <altmember cref="T:System.Double" />
  </Docs>
  <Members>
    <MemberGroup MemberName="CompareTo">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Compara esta instancia con un objeto especificado o con otra instancia de <see cref="T:System.Single" /> y devuelve un entero que indica si el valor de esta instancia es menor, igual o mayor que el valor del objeto especificado o la otra instancia de <see cref="T:System.Single" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CompareTo">
      <MemberSignature Language="C#" Value="public int CompareTo (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 CompareTo(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.CompareTo(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function CompareTo (value As Object) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int CompareTo(System::Object ^ value);" />
      <MemberSignature Language="F#" Value="abstract member CompareTo : obj -&gt; int&#xA;override this.CompareTo : obj -&gt; int" Usage="single.CompareTo value" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IComparable.CompareTo(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">Objeto que se va a comparar o <see langword="null" />.</param>
        <summary>Compara esta instancia con un objeto especificado y devuelve un entero que indica si el valor de esta instancia es mayor, igual o menor que el valor del objeto especificado.</summary>
        <returns>Número con signo que indica los valores relativos de esta instancia y <paramref name="value" />.  
  
 <list type="table"><listheader><term> Valor devuelto 
 </term><description> Descripción 
 </description></listheader><item><term> Menor que cero 
 </term><description> Esta instancia es menor que <paramref name="value" />.  
  
O bien 
Esta instancia no es numérica (<see cref="F:System.Single.NaN" />) y <paramref name="value" /> es un número.  
  
 </description></item><item><term> Cero 
 </term><description> Esta instancia es igual a <paramref name="value" />.  
  
O bien 
Tanto esta instancia como este valor no son numéricos (<see cref="F:System.Single.NaN" />) <see cref="F:System.Single.PositiveInfinity" /> o <see cref="F:System.Single.NegativeInfinity" />.  
  
 </description></item><item><term> Mayor que cero 
 </term><description> Esta instancia es mayor que <paramref name="value" />.  
  
O bien 
Esta instancia es numérica y este <paramref name="value" /> no es numérico (<see cref="F:System.Single.NaN" />).  
  
O bien 
 El valor de <paramref name="value" /> es <see langword="null" />.  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El `value` parámetro debe ser `null` o una instancia de <xref:System.Single>; de lo contrario, se produce una excepción. Cualquier instancia de <xref:System.Single>, independientemente de su valor, se considera mayor `null`.  
  
 Los valores deben ser idénticos para que se consideran iguales. Especialmente cuando los valores de punto flotante dependen de varias operaciones matemáticas, es común para que puedan perder precisión y sus valores ser casi idéntico, salvo sus dígitos menos significativos. Por este motivo, el valor devuelto de la <xref:System.Single.CompareTo%2A> método puede parecer sorprendente en ocasiones. Por ejemplo, la multiplicación por un valor concreto seguido de división por el mismo valor debe generar el valor original, pero en el ejemplo siguiente, el valor calculado resulta para ser mayor que el valor original. Mostrar todos los dígitos significativos de los dos valores con la "R" [cadena de formato numérico estándar](~/docs/standard/base-types/standard-numeric-format-strings.md) indica que el valor calculado es diferente del valor original en sus dígitos menos significativos. Para obtener información sobre cómo administrar estas comparaciones, vea la sección Comentarios de la <xref:System.Single.Equals%28System.Single%29> método.  
  
 [!code-csharp[System.Single.CompareTo#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.single.compareto/cs/compareto3.cs#2)]
 [!code-vb[System.Single.CompareTo#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.single.compareto/vb/compareto3.vb#2)]  
  
 Este método se implementa para admitir la <xref:System.IComparable> interfaz. Tenga en cuenta que, aunque un <xref:System.Single.NaN> no se considera igual que otro <xref:System.Single.NaN> (incluso él mismo), el <xref:System.IComparable> interfaz requiere que `A.CompareTo(A)` devolver cero.  
  
## <a name="precision-in-comparisons"></a>Precisión en las comparaciones  
 La precisión de números de punto flotante más allá de la precisión documentada es específica de la implementación y la versión de .NET Framework. Por lo tanto, una comparación de dos números determinados puede cambiar entre las versiones de .NET Framework ya que podría cambiar la precisión de la representación interna de los números.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra el <xref:System.Single.CompareTo%2A> método.  
  
 [!code-cpp[System.Single#16](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Single/CPP/singlesample.cpp#16)]
 [!code-csharp[System.Single#16](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Single/CS/singlesample.cs#16)]
 [!code-vb[System.Single#16](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Single/VB/singlesample.vb#16)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="value" /> no es un <see cref="T:System.Single" />.</exception>
        <altmember cref="M:System.Single.Equals(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="CompareTo">
      <MemberSignature Language="C#" Value="public int CompareTo (float value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 CompareTo(float32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.CompareTo(System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Function CompareTo (value As Single) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int CompareTo(float value);" />
      <MemberSignature Language="F#" Value="abstract member CompareTo : single -&gt; int&#xA;override this.CompareTo : single -&gt; int" Usage="single.CompareTo value" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IComparable`1.CompareTo(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="value">Número de punto flotante de precisión sencilla que se va a comparar.</param>
        <summary>Compara esta instancia con un número de punto flotante de precisión sencilla especificado y devuelve un entero que indica si el valor de esta instancia es menor, igual o mayor que el valor del número de punto flotante de precisión sencilla especificado.</summary>
        <returns>Número con signo que indica los valores relativos de esta instancia y <paramref name="value" />.  
  
 <list type="table"><listheader><term> Valor devuelto 
 </term><description> Descripción 
 </description></listheader><item><term> Menor que cero 
 </term><description> Esta instancia es menor que <paramref name="value" />.  
  
O bien 
Esta instancia no es numérica (<see cref="F:System.Single.NaN" />) y <paramref name="value" /> es un número.  
  
 </description></item><item><term> Cero 
 </term><description> Esta instancia es igual a <paramref name="value" />.  
  
O bien 
Tanto esta instancia como este <paramref name="value" /> no son numéricos (<see cref="F:System.Single.NaN" />), <see cref="F:System.Single.PositiveInfinity" />, o <see cref="F:System.Single.NegativeInfinity" />.  
  
 </description></item><item><term> Mayor que cero 
 </term><description> Esta instancia es mayor que <paramref name="value" />.  
  
O bien 
Esta instancia es numérica y este <paramref name="value" /> no es numérico (<see cref="F:System.Single.NaN" />).  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Los valores deben ser idénticos para que se consideran iguales. Es habitual que los valores de punto flotante a perder precisión a convertirse en casi idénticos salvo por sus dígitos menos significativos, especialmente cuando los valores dependen de varias operaciones matemáticas. Por este motivo, el valor devuelto de la <xref:System.Single.CompareTo%2A> método a veces puede parecer sorprendente. Por ejemplo, la multiplicación por cualquier valor seguido de división por el mismo valor debe generar el valor original. Sin embargo, en el ejemplo siguiente, el valor calculado resulta para ser mayor que el valor original. Mostrar todos los dígitos significativos de los dos valores con la "R" [cadena de formato numérico estándar](~/docs/standard/base-types/standard-numeric-format-strings.md) indica que el valor calculado es diferente del valor original en sus dígitos menos significativos. Para obtener información sobre cómo administrar estas comparaciones, vea la sección Comentarios de la <xref:System.Single.Equals%28System.Single%29> método.  
  
 [!code-csharp[System.Single.CompareTo#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.single.compareto/cs/compareto2.cs#1)]
 [!code-vb[System.Single.CompareTo#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.single.compareto/vb/compareto2.vb#1)]  
  
 Este método implementa el <xref:System.IComparable%601?displayProperty=nameWithType> interfaz y realiza un poco mejor que el <xref:System.Single.CompareTo%2A?displayProperty=nameWithType> método porque no tiene que convertir el `value` parámetro a un objeto.  
  
 Tenga en cuenta que, aunque un objeto cuyo valor es <xref:System.Single.NaN> no se considera igual a otro objeto cuyo valor es <xref:System.Single.NaN> (incluso él mismo), el <xref:System.IComparable%601> interfaz requiere que `A.CompareTo(A)` devolver cero.  
  
## <a name="widening-conversions"></a>conversiones de ampliación  
 Dependiendo del lenguaje de programación, puede que sea posible al código un <xref:System.Single.CompareTo%2A> método donde el tipo de parámetro tiene menos bits (es más estrecho) que el tipo de instancia. Esto es posible porque algunos lenguajes de programación realizan una conversión de ampliación implícita que representa el parámetro como un tipo con tantos bits como la instancia.  
  
 Por ejemplo, suponga que el tipo de instancia es <xref:System.Single> y el tipo de parámetro es <xref:System.Int32>. El compilador de Microsoft C# genera instrucciones para representar el valor del parámetro como un <xref:System.Single> objeto, a continuación, genera un <xref:System.Single.CompareTo%28System.Single%29?displayProperty=nameWithType> método que compara los valores de la instancia y la representación ampliada del parámetro.  
  
 Consulte la documentación de su lenguaje de programación para determinar si el compilador realiza las conversiones de ampliación implícitas de tipos numéricos. Para obtener más información, consulte el [tablas de conversión de tipo](~/docs/standard/base-types/conversion-tables.md) tema.  
  
## <a name="precision-in-comparisons"></a>Precisión en las comparaciones  
 La precisión de números de punto flotante más allá de la precisión documentada es específica de la implementación y la versión de .NET Framework. Por lo tanto, una comparación de dos números determinados puede cambiar entre las versiones de .NET Framework ya que podría cambiar la precisión de la representación interna de los números.  
  
   
  
## Examples  
 El ejemplo de código siguiente muestra las versiones genéricas y de la <xref:System.Single.CompareTo%2A> método para varios tipos de valor y de referencia.  
  
 [!code-cpp[T.CompareTo#1](~/samples/snippets/cpp/VS_Snippets_CLR/T.CompareTo/CPP/cat.cpp#1)]
 [!code-csharp[T.CompareTo#1](~/samples/snippets/csharp/VS_Snippets_CLR/T.CompareTo/CS/cat.cs#1)]
 [!code-vb[T.CompareTo#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/T.CompareTo/VB/cat.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Single.Equals(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Epsilon">
      <MemberSignature Language="C#" Value="public const float Epsilon = 1.401298E-45;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal float32 Epsilon = float32(1.401298E-45)" />
      <MemberSignature Language="DocId" Value="F:System.Single.Epsilon" />
      <MemberSignature Language="VB.NET" Value="Public Const Epsilon As Single  = 1.401298E-45" />
      <MemberSignature Language="C++ CLI" Value="public: float Epsilon = 1.401298E-45;" />
      <MemberSignature Language="F#" Value="val mutable Epsilon : single" Usage="System.single.Epsilon" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <MemberValue>1.401298E-45</MemberValue>
      <Docs>
        <summary>Representa el menor valor <see cref="T:System.Single" /> positivo mayor que cero. Este campo es constante.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El valor de la <xref:System.Single.Epsilon> propiedad refleja el valor positivo más pequeño <xref:System.Single> valor que es importante en las operaciones numéricas o comparaciones cuando el valor de la <xref:System.Single> instancia es cero. Por ejemplo, el código siguiente muestra que cero y <xref:System.Single.Epsilon> se consideran valores distintos, mientras que cero y la mitad del valor de <xref:System.Single.Epsilon> se consideran iguales.  
  
 [!code-csharp[System.Single.Epsilon#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Single.Epsilon/cs/epsilon.cs#5)]
 [!code-vb[System.Single.Epsilon#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Single.Epsilon/vb/epsilon.vb#5)]  
  
 Más concretamente, el formato de punto flotante de precisión sencilla formado por un inicio de sesión, una mantisa de 23 bits o mantisa y un exponente de 8 bits. Como se muestra en el ejemplo siguiente, cero tiene un exponente de-126 y una mantisa de 0. <xref:System.Single.Epsilon> tiene un exponente de-126 y una mantisa de 1. Esto significa que <xref:System.Single.Epsilon?displayProperty=nameWithType> es el valor positivo más pequeño <xref:System.Single> valor que es mayor que cero y representa el menor valor posible y el incremento más pequeño posible para un <xref:System.Single> cuyo exponente es-126.  
  
 [!code-csharp[System.Single.Epsilon#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Single.Epsilon/cs/epsilon1.cs#6)]
 [!code-vb[System.Single.Epsilon#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Single.Epsilon/vb/epsilon1.vb#6)]  
  
 Sin embargo, el <xref:System.Single.Epsilon> propiedad no es una medida general de precisión de la <xref:System.Single> escriba; solo se aplica a <xref:System.Single> instancias que tienen un valor de cero.  
  
> [!NOTE]
>  El valor de la <xref:System.Single.Epsilon> propiedad no es equivalente al épsilon del equipo, que representa el límite superior del error relativo debido al redondeo en aritmética de punto flotante.  
  
 El valor de esta constante es 1.4e-45.  
  
 Es posible que dos números de punto flotante equivalentes aparentemente no son iguales debido a diferencias en sus dígitos menos significativos. Por ejemplo, la expresión de C# `(float)1/3 == (float)0.33333`, no son iguales porque la operación de división en el lado izquierdo tiene precisión máxima, mientras que la constante del lado derecho es precisa únicamente a los dígitos especificados. Si crea un algoritmo personalizado que determina si dos números de punto flotante pueden considerarse iguales, debe usar un valor mayor que el <xref:System.Single.Epsilon> constante para establecer el margen absoluto aceptable de diferencia de los dos valores se consideran iguales. (Normalmente, ese margen de diferencia es muchas veces mayor que <xref:System.Single.Epsilon>.)  
  
## <a name="platform-notes"></a>Notas de la plataforma  
 En sistemas ARM, el valor de la <xref:System.Single.Epsilon> constante es demasiado pequeño para ser detectado, por lo que es igual a cero. Puede definir un valor épsilon alternativo que es igual a 1.175494351E-38 en su lugar.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Equals">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Devuelve un valor que indica si dos instancias de <see cref="T:System.Single" /> representan el mismo valor.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (obj As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="override this.Equals : obj -&gt; bool" Usage="single.Equals obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">Objeto que se va a comparar con esta instancia.</param>
        <summary>Devuelve un valor que indica si esta instancia equivale a un objeto especificado.</summary>
        <returns>Es <see langword="true" /> si <paramref name="obj" /> es una instancia de <see cref="T:System.Single" /> y es igual al valor de esta instancia; en caso contrario, es <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Single.Equals%2A> método debe usarse con precaución, porque dos valores aparentemente equivalentes pueden ser distintos debido a la precisión de los dos valores diferente. En el ejemplo siguiente se notifica que el <xref:System.Single> .3333 de valor y el <xref:System.Single> devuelve dividiendo 1 al 3 no son iguales.  
  
 [!code-csharp[System.Single.Epsilon#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Single.Epsilon/cs/SingleEquals_25051.cs#3)]
 [!code-vb[System.Single.Epsilon#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Single.Epsilon/vb/SingleEquals_25051.vb#3)]  
  
 En lugar de comparación de igualdad, una técnica recomendada consiste en definir un margen aceptable de diferencia entre dos valores (como. 01% de uno de los valores). Si el valor absoluto de la diferencia entre los dos valores es menor o igual que el margen, la diferencia es probable que sea debido a diferencias en la precisión y, por lo tanto, los valores suelen ser iguales. En el ejemplo siguiente se usa esta técnica para comparar, 33333 y 1/3, los dos <xref:System.Single> valores que en el ejemplo de código anterior se consideran iguales.  
  
 [!code-csharp[System.Single.Epsilon#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Single.Epsilon/cs/SingleEquals_25051.cs#4)]
 [!code-vb[System.Single.Epsilon#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Single.Epsilon/vb/SingleEquals_25051.vb#4)]  
  
 En este caso, los valores son iguales.  
  
> [!NOTE]
>  Dado que <xref:System.Single.Epsilon> define la expresión de mínimo de un valor positivo cuyo intervalo está cerca de cero, debe ser mayor que el margen de diferencia <xref:System.Single.Epsilon>. Normalmente, es muchas veces mayor que <xref:System.Single.Epsilon>.  
  
 La precisión de números de punto flotante más allá de la precisión documentada es específica de la implementación y la versión de .NET Framework. Por lo tanto, una comparación de dos números determinados puede cambiar entre las versiones de .NET Framework ya que podría cambiar la precisión de la representación interna de los números.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra el <xref:System.Single.Equals%2A> método.  
  
 [!code-cpp[System.Single#17](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Single/CPP/singlesample.cpp#17)]
 [!code-csharp[System.Single#17](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Single/CS/singlesample.cs#17)]
 [!code-vb[System.Single#17](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Single/VB/singlesample.vb#17)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage"><para>Es posible que cuenta la resolución de sobrecarga del compilador una diferencia aparente en el comportamiento de los dos <see cref="M:System.Single.Equals(System.Object)" /> sobrecargas del método. Si una conversión implícita entre el <paramref name="obj" /> argumento y un <see cref="T:System.Single" /> está definido y el argumento no es del tipo una <see cref="T:System.Object" />, compiladores pueden realizar una conversión implícita y llame a la <see cref="M:System.Single.Equals(System.Single)" /> método. En caso contrario, llaman a la <see cref="M:System.Single.Equals(System.Object)" /> método, que siempre devuelve <see langword="false" /> si su <paramref name="obj" /> argumento no es un <see cref="T:System.Single" /> valor. El ejemplo siguiente ilustra la diferencia de comportamiento entre las sobrecargas del método de dos. En el caso de todos los tipos numéricos primitivos excepto <see cref="T:System.Double" /> en Visual Basic y excepto <see cref="T:System.Decimal" /> y <see cref="T:System.Double" /> en C#, se devuelve la primera comparación <see langword="true" /> porque el compilador realiza automáticamente una conversión de ampliación y las llamadas el <see cref="M:System.Single.Equals(System.Single)" /> método, mientras que la segunda comparación devuelve <see langword="false" /> porque el compilador llama a la <see cref="M:System.Single.Equals(System.Object)" /> método.  
  
[! código csharp[System.Single.Equals#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.single.equals/cs/equalsoverl.cs#2)] [! código vb[System.Single.Equals#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.single.equals/vb/equalsoverl.vb#2)]</para></block>
        <altmember cref="M:System.Single.CompareTo(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public bool Equals (float obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Equals(float32 obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.Equals(System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Function Equals (obj As Single) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Equals(float obj);" />
      <MemberSignature Language="F#" Value="override this.Equals : single -&gt; bool" Usage="single.Equals obj" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IEquatable`1.Equals(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="obj">Objeto que se va a comparar con esta instancia.</param>
        <summary>Devuelve un valor que indica si esta instancia y un objeto <see cref="T:System.Single" /> especificado representan el mismo valor.</summary>
        <returns><see langword="true" /> si <paramref name="obj" /> es igual a esta instancia; en caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método implementa el <xref:System.IEquatable%601?displayProperty=nameWithType> interfaz y realiza un poco mejor que <xref:System.Single.Equals%2A> porque no tiene que convertir el `obj` parámetro a un objeto.  
  
## <a name="widening-conversions"></a>conversiones de ampliación  
 Dependiendo del lenguaje de programación, puede que sea posible al código un <xref:System.Single.Equals%2A> método donde el tipo de parámetro tiene menos bits (es más estrecho) que el tipo de instancia. Esto es posible porque algunos lenguajes de programación realizan una conversión de ampliación implícita que representa el parámetro como un tipo con tantos bits como la instancia.  
  
 Por ejemplo, suponga que el tipo de instancia es <xref:System.Single> y el tipo de parámetro es <xref:System.Int32>. El compilador de Microsoft C# genera instrucciones para representar el valor del parámetro como un <xref:System.Single> de objetos y, a continuación, genera un <xref:System.Single.Equals%28System.Single%29?displayProperty=nameWithType> método que compara los valores de la instancia y la representación ampliada del parámetro.  
  
 Consulte la documentación de su lenguaje de programación para determinar si el compilador realiza las conversiones de ampliación implícitas de tipos numéricos. Para obtener más información, consulte el [tablas de conversión de tipo](~/docs/standard/base-types/conversion-tables.md) tema.  
  
## <a name="precision-in-comparisons"></a>Precisión en las comparaciones  
 El <xref:System.Single.Equals%2A> método debe usarse con precaución, porque dos valores aparentemente equivalentes pueden ser distintos debido a la precisión de los dos valores diferente. En el ejemplo siguiente se notifica que el <xref:System.Single> .3333 de valor y el <xref:System.Single> devuelve dividiendo 1 al 3 no son iguales.  
  
 [!code-csharp[System.Single.Epsilon#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Single.Epsilon/cs/SingleEquals_25051.cs#1)]
 [!code-vb[System.Single.Epsilon#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Single.Epsilon/vb/SingleEquals_25051.vb#1)]  
  
 Técnica de una comparación que evita los problemas asociados con la comparación de igualdad implica definir un margen aceptable de diferencia entre dos valores (como. 01% de uno de los valores). Si el valor absoluto de la diferencia entre los dos valores es menor o igual que el margen, la diferencia es probable que sea un resultado de las diferencias en precisión y, por lo tanto, los valores suelen ser iguales. En el ejemplo siguiente se usa esta técnica para comparar, 33333 y 1/3, que son los dos <xref:System.Single> valores que en el ejemplo de código anterior se consideran iguales.  
  
 [!code-csharp[System.Single.Epsilon#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Single.Epsilon/cs/SingleEquals_25051.cs#2)]
 [!code-vb[System.Single.Epsilon#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Single.Epsilon/vb/SingleEquals_25051.vb#2)]  
  
 En este caso, los valores son iguales.  
  
> [!NOTE]
>  Dado que <xref:System.Single.Epsilon> define la expresión de mínimo de un valor positivo cuyo intervalo está cerca de cero, debe ser mayor que el margen de diferencia <xref:System.Single.Epsilon>. Normalmente, es muchas veces mayor que <xref:System.Single.Epsilon>. Por este motivo, se recomienda que no utilicen <xref:System.Double.Epsilon> al comparar <xref:System.Double> valores para la igualdad.  
  
 Una segunda técnica que evita los problemas asociados con la comparación de igualdad implica comparar la diferencia entre dos números de punto flotante con algún valor absoluto. Si la diferencia es menor o igual a ese valor absoluto, los números son iguales. Si es mayor, los números no son iguales. Una manera de hacerlo es seleccionar arbitrariamente un valor absoluto. Sin embargo, esto es problemático, ya que un margen aceptable de diferencia depende de la magnitud de la <xref:System.Single> valores. Una segunda forma aprovecha una característica de diseño del formato de punto flotante: La diferencia entre los componentes de mantisa en las representaciones de entero de dos valores de punto flotante indica el número de posibles valores de punto flotante que separa los dos valores. Por ejemplo, la diferencia entre 0,0 y <xref:System.Single.Epsilon> es 1, porque <xref:System.Single.Epsilon> es el valor más pequeño que se puede representar al trabajar con un <xref:System.Single> cuyo valor es cero. En el ejemplo siguiente se usa esta técnica para comparar, 33333 y 1/3, que son los dos <xref:System.Double> valores que el anterior ejemplo de código con el <xref:System.Single.Equals%28System.Single%29> encuentra método japonesas. Tenga en cuenta que el ejemplo se usa el <xref:System.BitConverter.GetBytes%2A?displayProperty=nameWithType> y <xref:System.BitConverter.ToInt32%2A?displayProperty=nameWithType> métodos para convertir un valor de punto flotante de precisión sencilla en su representación de entero.  
  
 [!code-csharp[System.Single.Equals#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.single.equals/cs/equalsabs1.cs#1)]
 [!code-vb[System.Single.Equals#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.single.equals/vb/equalsabs1.vb#1)]  
  
 La precisión de números de punto flotante más allá de la precisión documentada es específica de la implementación y la versión de .NET Framework. Por lo tanto, una comparación de dos números podría producir resultados diferentes según la versión de .NET Framework, ya que podría cambiar la precisión de la representación interna de los números.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage"><para>Es posible que cuenta la resolución de sobrecarga del compilador una diferencia aparente en el comportamiento de los dos <see cref="M:System.Single.Equals(System.Object)" /> sobrecargas del método. Si una conversión implícita entre el <paramref name="obj" /> argumento y un <see cref="T:System.Single" /> está definido y el argumento no es del tipo una <see cref="T:System.Object" />, compiladores pueden realizar una conversión implícita y llame a la <see cref="M:System.Single.Equals(System.Single)" /> método. En caso contrario, llaman a la <see cref="M:System.Single.Equals(System.Object)" /> método, que siempre devuelve <see langword="false" /> si su <paramref name="obj" /> argumento no es un <see cref="T:System.Single" /> valor. El ejemplo siguiente ilustra la diferencia de comportamiento entre las sobrecargas del método de dos. En el caso de todos los tipos numéricos primitivos excepto <see cref="T:System.Double" /> en Visual Basic y excepto <see cref="T:System.Decimal" /> y <see cref="T:System.Double" /> en C#, se devuelve la primera comparación <see langword="true" /> porque el compilador realiza automáticamente una conversión de ampliación y las llamadas el <see cref="M:System.Single.Equals(System.Single)" /> método, mientras que la segunda comparación devuelve <see langword="false" /> porque el compilador llama a la <see cref="M:System.Single.Equals(System.Object)" /> método.  
  
[! código csharp[System.Single.Equals#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.single.equals/cs/equalsoverl.cs#2)] [! código vb[System.Single.Equals#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.single.equals/vb/equalsoverl.vb#2)]</para></block>
        <altmember cref="M:System.Single.Equals(System.Object)" />
        <altmember cref="Overload:System.Single.CompareTo" />
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="single.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Devuelve el código hash de esta instancia.</summary>
        <returns>Código hash de un entero de 32 bits con signo.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetTypeCode">
      <MemberSignature Language="C#" Value="public TypeCode GetTypeCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.TypeCode GetTypeCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.GetTypeCode" />
      <MemberSignature Language="VB.NET" Value="Public Function GetTypeCode () As TypeCode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual TypeCode GetTypeCode();" />
      <MemberSignature Language="F#" Value="abstract member GetTypeCode : unit -&gt; TypeCode&#xA;override this.GetTypeCode : unit -&gt; TypeCode" Usage="single.GetTypeCode " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.GetTypeCode</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.TypeCode</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Devuelve el <see cref="T:System.TypeCode" /> para el tipo de valor <see cref="T:System.Single" />.</summary>
        <returns>Constante enumerada, <see cref="F:System.TypeCode.Single" />.</returns>
        <remarks>To be added.</remarks>
        <altmember cref="T:System.TypeCode" />
      </Docs>
    </Member>
    <Member MemberName="IsFinite">
      <MemberSignature Language="C#" Value="public static bool IsFinite (float f);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsFinite(float32 f) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.IsFinite(System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsFinite (f As Single) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsFinite(float f);" />
      <MemberSignature Language="F#" Value="static member IsFinite : single -&gt; bool" Usage="System.single.IsFinite f" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="f" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="f">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsInfinity">
      <MemberSignature Language="C#" Value="public static bool IsInfinity (float f);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsInfinity(float32 f) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.IsInfinity(System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsInfinity (f As Single) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsInfinity(float f);" />
      <MemberSignature Language="F#" Value="static member IsInfinity : single -&gt; bool" Usage="System.single.IsInfinity f" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="f" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="f">Número de punto flotante de precisión sencilla.</param>
        <summary>Devuelve un valor que indica si el número especificado se evalúa como infinito negativo o positivo.</summary>
        <returns>Es <see langword="true" /> si <paramref name="f" /> se evalúa en <see cref="F:System.Single.PositiveInfinity" /> o <see cref="F:System.Single.NegativeInfinity" />; en caso contrario, es <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Las operaciones de punto flotante devuelven <xref:System.Single.PositiveInfinity> o <xref:System.Single.NegativeInfinity> para indicar una condición de desbordamiento.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra el <xref:System.Single.IsInfinity%2A> método.  
  
 [!code-cpp[System.Single#11](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Single/CPP/singlesample.cpp#11)]
 [!code-csharp[System.Single#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Single/CS/singlesample.cs#11)]
 [!code-vb[System.Single#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Single/VB/singlesample.vb#11)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Single.IsPositiveInfinity(System.Single)" />
        <altmember cref="M:System.Single.IsNegativeInfinity(System.Single)" />
        <altmember cref="F:System.Single.PositiveInfinity" />
        <altmember cref="F:System.Single.NegativeInfinity" />
      </Docs>
    </Member>
    <Member MemberName="IsNaN">
      <MemberSignature Language="C#" Value="public static bool IsNaN (float f);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsNaN(float32 f) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.IsNaN(System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsNaN (f As Single) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsNaN(float f);" />
      <MemberSignature Language="F#" Value="static member IsNaN : single -&gt; bool" Usage="System.single.IsNaN f" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="f" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="f">Número de punto flotante de precisión sencilla.</param>
        <summary>Devuelve un valor que indica si el valor especificado no es un número (<see cref="F:System.Single.NaN" />).</summary>
        <returns>Es <see langword="true" /> si <paramref name="f" /> se evalúa como un valor no numérico (<see cref="F:System.Single.NaN" />); en caso contrario, es <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Las operaciones de punto flotante devuelven <xref:System.Single.NaN> para indicar que el resultado de la operación es indefinido. Por ejemplo, dividir 0,0, 0,0 da como resultado <xref:System.Single.NaN>.  
  
> [!NOTE]
>  <xref:System.Single.IsNaN%2A> Devuelve `false` si un <xref:System.Single> valor sea <xref:System.Single.PositiveInfinity> o <xref:System.Single.NegativeInfinity>. Para comprobar estos valores, utilice el <xref:System.Single.IsInfinity%2A>, <xref:System.Single.IsPositiveInfinity%2A>, y <xref:System.Single.IsNegativeInfinity%2A> métodos.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra el <xref:System.Single.IsNaN%2A> método.  
  
 [!code-cpp[System.Single#8](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Single/CPP/singlesample.cpp#8)]
 [!code-csharp[System.Single#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Single/CS/singlesample.cs#8)]
 [!code-vb[System.Single#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Single/VB/singlesample.vb#8)]  
  
 ]]></format>
        </remarks>
        <altmember cref="F:System.Single.NaN" />
      </Docs>
    </Member>
    <Member MemberName="IsNegative">
      <MemberSignature Language="C#" Value="public static bool IsNegative (float f);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsNegative(float32 f) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.IsNegative(System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsNegative (f As Single) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsNegative(float f);" />
      <MemberSignature Language="F#" Value="static member IsNegative : single -&gt; bool" Usage="System.single.IsNegative f" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="f" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="f">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsNegativeInfinity">
      <MemberSignature Language="C#" Value="public static bool IsNegativeInfinity (float f);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsNegativeInfinity(float32 f) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.IsNegativeInfinity(System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsNegativeInfinity (f As Single) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsNegativeInfinity(float f);" />
      <MemberSignature Language="F#" Value="static member IsNegativeInfinity : single -&gt; bool" Usage="System.single.IsNegativeInfinity f" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="f" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="f">Número de punto flotante de precisión sencilla.</param>
        <summary>Devuelve un valor que indica si el número especificado se evalúa como infinito negativo.</summary>
        <returns>Es <see langword="true" /> si <paramref name="f" /> se evalúa en <see cref="F:System.Single.NegativeInfinity" />; en caso contrario, es <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Las operaciones de punto flotante devuelven <xref:System.Single.NegativeInfinity> para indicar una condición de desbordamiento.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra el <xref:System.Single.IsNegativeInfinity%2A> método.  
  
 [!code-cpp[System.Single#13](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Single/CPP/singlesample.cpp#13)]
 [!code-csharp[System.Single#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Single/CS/singlesample.cs#13)]
 [!code-vb[System.Single#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Single/VB/singlesample.vb#13)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Single.IsInfinity(System.Single)" />
        <altmember cref="M:System.Single.IsPositiveInfinity(System.Single)" />
        <altmember cref="F:System.Single.PositiveInfinity" />
        <altmember cref="F:System.Single.NegativeInfinity" />
      </Docs>
    </Member>
    <Member MemberName="IsNormal">
      <MemberSignature Language="C#" Value="public static bool IsNormal (float f);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsNormal(float32 f) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.IsNormal(System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsNormal (f As Single) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsNormal(float f);" />
      <MemberSignature Language="F#" Value="static member IsNormal : single -&gt; bool" Usage="System.single.IsNormal f" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="f" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="f">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsPositiveInfinity">
      <MemberSignature Language="C#" Value="public static bool IsPositiveInfinity (float f);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsPositiveInfinity(float32 f) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.IsPositiveInfinity(System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsPositiveInfinity (f As Single) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsPositiveInfinity(float f);" />
      <MemberSignature Language="F#" Value="static member IsPositiveInfinity : single -&gt; bool" Usage="System.single.IsPositiveInfinity f" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="f" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="f">Número de punto flotante de precisión sencilla.</param>
        <summary>Devuelve un valor que indica si el número especificado se evalúa como infinito positivo.</summary>
        <returns>Es <see langword="true" /> si <paramref name="f" /> se evalúa en <see cref="F:System.Single.PositiveInfinity" />; en caso contrario, es <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Las operaciones de punto flotante devuelven <xref:System.Single.PositiveInfinity> para indicar una condición de desbordamiento.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra el <xref:System.Single.IsPositiveInfinity%2A> método.  
  
 [!code-cpp[System.Single#12](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Single/CPP/singlesample.cpp#12)]
 [!code-csharp[System.Single#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Single/CS/singlesample.cs#12)]
 [!code-vb[System.Single#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Single/VB/singlesample.vb#12)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Single.IsInfinity(System.Single)" />
        <altmember cref="M:System.Single.IsNegativeInfinity(System.Single)" />
        <altmember cref="F:System.Single.PositiveInfinity" />
        <altmember cref="F:System.Single.NegativeInfinity" />
      </Docs>
    </Member>
    <Member MemberName="IsSubnormal">
      <MemberSignature Language="C#" Value="public static bool IsSubnormal (float f);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsSubnormal(float32 f) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.IsSubnormal(System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsSubnormal (f As Single) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsSubnormal(float f);" />
      <MemberSignature Language="F#" Value="static member IsSubnormal : single -&gt; bool" Usage="System.single.IsSubnormal f" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="f" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="f">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MaxValue">
      <MemberSignature Language="C#" Value="public const float MaxValue = 3.402823E+38;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal float32 MaxValue = float32(3.402823E+38)" />
      <MemberSignature Language="DocId" Value="F:System.Single.MaxValue" />
      <MemberSignature Language="VB.NET" Value="Public Const MaxValue As Single  = 3.402823E+38" />
      <MemberSignature Language="C++ CLI" Value="public: float MaxValue = 3.402823E+38;" />
      <MemberSignature Language="F#" Value="val mutable MaxValue : single" Usage="System.single.MaxValue" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <MemberValue>3.402823E+38</MemberValue>
      <Docs>
        <summary>Representa el mayor valor posible de <see cref="T:System.Single" />. Este campo es constante.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El valor de esta constante es positivo 3.40282347E + 38.  
  
 El resultado de una operación que excede <xref:System.Single.MaxValue?displayProperty=nameWithType> es <xref:System.Single.PositiveInfinity?displayProperty=nameWithType>. En el ejemplo siguiente, <xref:System.Single.PositiveInfinity?displayProperty=nameWithType> resultados de las operaciones de suma, multiplicación y exponenciación cuando el resultado supera <xref:System.Single.MaxValue?displayProperty=nameWithType>.  
  
 [!code-csharp[System.Single.MaxValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.single.maxvalue/cs/maxvalueex.cs#1)]
 [!code-vb[System.Single.MaxValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.single.maxvalue/vb/maxvalueex.vb#1)]  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra el <xref:System.Single.MaxValue> constante.  
  
 [!code-cpp[System.Single#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Single/CPP/singlesample.cpp#4)]
 [!code-csharp[System.Single#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Single/CS/singlesample.cs#4)]
 [!code-vb[System.Single#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Single/VB/singlesample.vb#4)]  
  
 ]]></format>
        </remarks>
        <altmember cref="F:System.Single.MinValue" />
      </Docs>
    </Member>
    <Member MemberName="MinValue">
      <MemberSignature Language="C#" Value="public const float MinValue = -3.402823E+38;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal float32 MinValue = float32(-3.402823E+38)" />
      <MemberSignature Language="DocId" Value="F:System.Single.MinValue" />
      <MemberSignature Language="VB.NET" Value="Public Const MinValue As Single  = -3.402823E+38" />
      <MemberSignature Language="C++ CLI" Value="public: float MinValue = -3.402823E+38;" />
      <MemberSignature Language="F#" Value="val mutable MinValue : single" Usage="System.single.MinValue" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <MemberValue>-3.402823E+38</MemberValue>
      <Docs>
        <summary>Representa el menor valor posible de <see cref="T:System.Single" />. Este campo es constante.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El valor de esta constante es 3. 402823e38 negativo.  
  
 El resultado de una operación que es menor que <xref:System.Single.MinValue?displayProperty=nameWithType> es <xref:System.Single.NegativeInfinity?displayProperty=nameWithType>. En el ejemplo siguiente, <xref:System.Single.NegativeInfinity?displayProperty=nameWithType> resultados de las operaciones de resta y multiplicación cuando el resultado es inferior a <xref:System.Single.MinValue?displayProperty=nameWithType>.  
  
 [!code-csharp[System.Single.MinValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.single.minvalue/cs/minvalueex.cs#1)]
 [!code-vb[System.Single.MinValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.single.minvalue/vb/minvalueex.vb#1)]  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra el <xref:System.Single.MinValue> constante.  
  
 [!code-cpp[System.Single#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Single/CPP/singlesample.cpp#5)]
 [!code-csharp[System.Single#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Single/CS/singlesample.cs#5)]
 [!code-vb[System.Single#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Single/VB/singlesample.vb#5)]  
  
 ]]></format>
        </remarks>
        <altmember cref="F:System.Single.MaxValue" />
      </Docs>
    </Member>
    <Member MemberName="NaN">
      <MemberSignature Language="C#" Value="public const float NaN = NaN;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal float32 NaN = float32(NaN)" />
      <MemberSignature Language="DocId" Value="F:System.Single.NaN" />
      <MemberSignature Language="VB.NET" Value="Public Const NaN As Single  = NaN" />
      <MemberSignature Language="C++ CLI" Value="public: float NaN = NaN;" />
      <MemberSignature Language="F#" Value="val mutable NaN : single" Usage="System.single.NaN" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <MemberValue>NaN</MemberValue>
      <Docs>
        <summary>Representa un valor no numérico (<see langword="NaN" />). Este campo es constante.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Devuelve un método u operador <xref:System.Single.NaN> cuando el resultado de una operación es indefinido. Por ejemplo, es el resultado de dividir cero por cero <xref:System.Single.NaN>, tal y como se muestra en el ejemplo siguiente. (Pero tenga en cuenta que al dividir un número distinto de cero por cero devuelve <xref:System.Single.PositiveInfinity> o <xref:System.Single.NegativeInfinity>, según el signo del divisor.)  
  
 [!code-csharp[System.Single.NaN#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.single.nan/cs/nan1.cs#1)]
 [!code-vb[System.Single.NaN#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.single.nan/vb/nan1.vb#1)]  
  
 Además, llamar un método con un <xref:System.Single.NaN> valor o una operación en un <xref:System.Single.NaN> valor devuelve <xref:System.Single.NaN>, tal y como se muestra en el ejemplo siguiente.  
  
 [!code-csharp[System.Single.NaN#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.single.nan/cs/nan1.cs#2)]
 [!code-vb[System.Single.NaN#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.single.nan/vb/nan1.vb#2)]  
  
 Use el <xref:System.Single.IsNaN%2A> método para determinar si un valor no es un número. En general, <xref:System.Single> operadores no se puede usar para comparar <xref:System.Single.NaN?displayProperty=nameWithType> Sí <xref:System.Single> valores, aunque los métodos de comparación (como <xref:System.Single.Equals%2A> y <xref:System.Single.CompareTo%2A>) puede. El ejemplo siguiente ilustra la diferencia de comportamiento entre <xref:System.Single> métodos y operadores de comparación.  
  
 [!code-csharp[System.Single.NaN#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.single.nan/cs/single.nan4.cs#4)]
 [!code-vb[System.Single.NaN#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.single.nan/vb/single.nan4.vb#4)]  
  
   
  
## Examples  
 En el ejemplo siguiente se muestra el <xref:System.Single.NaN> constante.  
  
 [!code-cpp[System.Single#7](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Single/CPP/singlesample.cpp#7)]
 [!code-csharp[System.Single#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Single/CS/singlesample.cs#7)]
 [!code-vb[System.Single#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Single/VB/singlesample.vb#7)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Single.IsNaN(System.Single)" />
      </Docs>
    </Member>
    <Member MemberName="NegativeInfinity">
      <MemberSignature Language="C#" Value="public const float NegativeInfinity = -Infinity;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal float32 NegativeInfinity = float32(-Infinity)" />
      <MemberSignature Language="DocId" Value="F:System.Single.NegativeInfinity" />
      <MemberSignature Language="VB.NET" Value="Public Const NegativeInfinity As Single  = -Infinity" />
      <MemberSignature Language="C++ CLI" Value="public: float NegativeInfinity = -Infinity;" />
      <MemberSignature Language="F#" Value="val mutable NegativeInfinity : single" Usage="System.single.NegativeInfinity" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <MemberValue>-Infinity</MemberValue>
      <Docs>
        <summary>Representa infinito negativo. Este campo es constante.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El valor de esta constante es el resultado de dividir un número negativo por cero.  
  
 Esta constante se devuelve cuando el resultado de una operación es menor que <xref:System.Single.MinValue>.  
  
 Use <xref:System.Single.IsNegativeInfinity%2A> para determinar si un valor se evalúa como infinito negativo.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra el <xref:System.Single.NegativeInfinity> constante.  
  
 [!code-cpp[System.Single#9](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Single/CPP/singlesample.cpp#9)]
 [!code-csharp[System.Single#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Single/CS/singlesample.cs#9)]
 [!code-vb[System.Single#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Single/VB/singlesample.vb#9)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Single.IsNegativeInfinity(System.Single)" />
        <altmember cref="M:System.Single.IsInfinity(System.Single)" />
        <altmember cref="F:System.Single.PositiveInfinity" />
      </Docs>
    </Member>
    <Member MemberName="op_Equality">
      <MemberSignature Language="C#" Value="public static bool operator == (float left, float right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Equality(float32 left, float32 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.op_Equality(System.Single,System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator == (left As Single, right As Single) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator ==(float left, float right);" />
      <MemberSignature Language="F#" Value="static member ( = ) : single * single -&gt; bool" Usage="left = right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Single" />
        <Parameter Name="right" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="left">Primer valor que se va a comparar.</param>
        <param name="right">Segundo valor que se va a comparar.</param>
        <summary>Devuelve un valor que indica si dos valores <see cref="T:System.Single" /> especificados son iguales.</summary>
        <returns><see langword="true" /> si <paramref name="left" /> y <paramref name="right" /> son iguales; en caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Single.op_Equality%2A> método define el operador de igualdad para <xref:System.Single> valores.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_GreaterThan">
      <MemberSignature Language="C#" Value="public static bool operator &gt; (float left, float right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_GreaterThan(float32 left, float32 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.op_GreaterThan(System.Single,System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &gt; (left As Single, right As Single) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &gt;(float left, float right);" />
      <MemberSignature Language="F#" Value="static member ( &gt; ) : single * single -&gt; bool" Usage="left &gt; right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Single" />
        <Parameter Name="right" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="left">Primer valor que se va a comparar.</param>
        <param name="right">Segundo valor que se va a comparar.</param>
        <summary>Devuelve un valor que indica si un valor <see cref="T:System.Single" /> especificado es mayor que otro valor <see cref="T:System.Single" /> especificado.</summary>
        <returns>Es <see langword="true" /> si <paramref name="left" /> es mayor que <paramref name="right" />; en caso contrario, es <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Single.op_GreaterThan%2A> método define la operación del mayor-operador para <xref:System.Single> valores.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_GreaterThanOrEqual">
      <MemberSignature Language="C#" Value="public static bool operator &gt;= (float left, float right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_GreaterThanOrEqual(float32 left, float32 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.op_GreaterThanOrEqual(System.Single,System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &gt;= (left As Single, right As Single) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &gt;=(float left, float right);" />
      <MemberSignature Language="F#" Value="static member ( &gt;= ) : single * single -&gt; bool" Usage="left &gt;= right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Single" />
        <Parameter Name="right" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="left">Primer valor que se va a comparar.</param>
        <param name="right">Segundo valor que se va a comparar.</param>
        <summary>Devuelve un valor que indica si un valor <see cref="T:System.Single" /> especificado es mayor o igual que otro valor <see cref="T:System.Single" /> especificado.</summary>
        <returns>Es <see langword="true" /> si <paramref name="left" /> es mayor o igual que <paramref name="right" />; en caso contrario, es <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Single.op_GreaterThanOrEqual%2A> método define el funcionamiento del operador mayor o igual de <xref:System.Single> valores.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Inequality">
      <MemberSignature Language="C#" Value="public static bool operator != (float left, float right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Inequality(float32 left, float32 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.op_Inequality(System.Single,System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator != (left As Single, right As Single) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator !=(float left, float right);" />
      <MemberSignature Language="F#" Value="static member op_Inequality : single * single -&gt; bool" Usage="System.single.op_Inequality (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Single" />
        <Parameter Name="right" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="left">Primer valor que se va a comparar.</param>
        <param name="right">Segundo valor que se va a comparar.</param>
        <summary>Devuelve un valor que indica si dos valores <see cref="T:System.Single" /> especificados no son iguales.</summary>
        <returns><see langword="true" /> si <paramref name="left" /> y <paramref name="right" /> no son iguales; en caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Single.op_Inequality%2A> método define el operador de desigualdad para <xref:System.Single> valores.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_LessThan">
      <MemberSignature Language="C#" Value="public static bool operator &lt; (float left, float right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_LessThan(float32 left, float32 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.op_LessThan(System.Single,System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &lt; (left As Single, right As Single) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &lt;(float left, float right);" />
      <MemberSignature Language="F#" Value="static member ( &lt; ) : single * single -&gt; bool" Usage="left &lt; right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Single" />
        <Parameter Name="right" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="left">Primer valor que se va a comparar.</param>
        <param name="right">Segundo valor que se va a comparar.</param>
        <summary>Devuelve un valor que indica si un valor <see cref="T:System.Single" /> especificado es menor que otro valor <see cref="T:System.Single" /> especificado.</summary>
        <returns>Es <see langword="true" /> si <paramref name="left" /> es menor que <paramref name="right" />; en caso contrario, es <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Single.op_LessThan%2A> método define la operación de menor-que el operador para <xref:System.Single> valores.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_LessThanOrEqual">
      <MemberSignature Language="C#" Value="public static bool operator &lt;= (float left, float right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_LessThanOrEqual(float32 left, float32 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.op_LessThanOrEqual(System.Single,System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &lt;= (left As Single, right As Single) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &lt;=(float left, float right);" />
      <MemberSignature Language="F#" Value="static member ( &lt;= ) : single * single -&gt; bool" Usage="left &lt;= right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Single" />
        <Parameter Name="right" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="left">Primer valor que se va a comparar.</param>
        <param name="right">Segundo valor que se va a comparar.</param>
        <summary>Devuelve un valor que indica si un valor <see cref="T:System.Single" /> especificado es menor o igual que otro valor <see cref="T:System.Single" /> especificado.</summary>
        <returns>Es <see langword="true" /> si <paramref name="left" /> es menor o igual que <paramref name="right" />; en caso contrario, es <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Single.op_LessThanOrEqual%2A> método define el funcionamiento del operador menor o igual de <xref:System.Single> valores.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Parse">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Convierte la representación en forma de cadena de un número en el número de punto flotante de precisión sencilla equivalente.</summary>
        <altmember cref="Overload:System.Single.TryParse" />
      </Docs>
    </MemberGroup>
    <Member MemberName="Parse">
      <MemberSignature Language="C#" Value="public static float Parse (string s);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 Parse(string s) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.Parse(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Parse (s As String) As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static float Parse(System::String ^ s);" />
      <MemberSignature Language="F#" Value="static member Parse : string -&gt; single" Usage="System.single.Parse s" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="s">Cadena que contiene un número que se va a convertir.</param>
        <summary>Convierte la representación en forma de cadena de un número en el número de punto flotante de precisión sencilla equivalente.</summary>
        <returns>Número de punto flotante de precisión sencilla equivalente al valor numérico o símbolo especificado en <paramref name="s" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El `s` parámetro puede contener la referencia cultural actual <xref:System.Globalization.NumberFormatInfo.PositiveInfinitySymbol%2A>, <xref:System.Globalization.NumberFormatInfo.NegativeInfinitySymbol%2A>, <xref:System.Globalization.NumberFormatInfo.NaNSymbol%2A>, o una cadena del formulario:  
  
 [*ws*] [*sesión*] [*dígitos enteros*[*,*]]*dígitos enteros*[*.* [*dígitos fraccionarios*]] [e [*sesión*]*dígitos exponenciales*] [*ws*]  
  
 Los elementos de los corchetes ([ y ]) son opcionales. En esta tabla se describe cada elemento.  
  
|Elemento|Descripción|  
|-------------|-----------------|  
|*ws*|Una serie de caracteres de espacio en blanco.|  
|*sign*|Símbolo de signo negativo o un símbolo de signo positivo. Caracteres de inicio de sesión válidos se determinan mediante la <xref:System.Globalization.NumberFormatInfo.NegativeSign%2A?displayProperty=nameWithType> y <xref:System.Globalization.NumberFormatInfo.PositiveSign%2A?displayProperty=nameWithType> propiedades de la referencia cultural actual. Se puede utilizar solo un signo inicial.|  
|*dígitos enteros*|Una serie de dígitos comprendidos del 0 al 9 que especifican la parte entera del número. Se ejecuta de *dígitos enteros* pueden particionarse mediante un símbolo de separador de grupos. Por ejemplo, en algunas referencias culturales una coma (,) separa los millares. El *dígitos enteros* puede ser el elemento ausente si la cadena contiene la *dígitos fraccionarios* elemento.|  
|*,*|Específicas de referencias culturales miles símbolo de separador.|  
|*.*|Un símbolo de separador de decimales de referencia cultural específica.|  
|*dígitos fraccionarios*|Una serie de dígitos comprendidos del 0 al 9 que especifican la parte fraccionaria del número.|  
|E|La "e" o el carácter "E", lo que indica que el valor se representa en una notación exponencial (científica).|  
|*dígitos exponenciales*|Una serie de dígitos comprendidos del 0 al 9 que especifican a un exponente.|  
  
 El `s` parámetro se interpreta mediante una combinación de la <xref:System.Globalization.NumberStyles.Float?displayProperty=nameWithType> y <xref:System.Globalization.NumberStyles.AllowThousands?displayProperty=nameWithType> marcas. Esto significa que ese espacio en blanco y miles se permiten separadores pero no símbolos de moneda. Para definir explícitamente los elementos (como símbolos de moneda, miles separadores y espacios en blanco) que pueden estar presentes en `s`, utilice el <xref:System.Single.Parse%28System.String%2CSystem.Globalization.NumberStyles%29> sobrecarga del método.  
  
 El `s` parámetro se analiza mediante el uso de la información de formato en un <xref:System.Globalization.NumberFormatInfo> objeto que se inicializa para la referencia cultural actual del sistema. Para obtener más información, vea <xref:System.Globalization.NumberFormatInfo.CurrentInfo%2A>. Para analizar una cadena mediante el uso de la información de formato de una referencia cultural concreta, use el <xref:System.Single.Parse%28System.String%2CSystem.IFormatProvider%29> o <xref:System.Single.Parse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%29> método.  
  
 Normalmente, si se pasa el <xref:System.Single.Parse%2A> método una cadena que se crea mediante una llamada a la <xref:System.Single.ToString%2A> método, el original <xref:System.Single> se devuelve el valor. Sin embargo, debido a una pérdida de precisión, los valores pueden no ser iguales.  
  
 Si se encuentra un separador en la `s` parámetro durante una operación de análisis y la divisa aplicable o número decimal y separadores de grupo son iguales, la operación de análisis supone que se trata de un separador decimal en lugar de un grupo separador. Para obtener más información acerca de los separadores, consulte <xref:System.Globalization.NumberFormatInfo.CurrencyDecimalSeparator%2A>, <xref:System.Globalization.NumberFormatInfo.NumberDecimalSeparator%2A>, <xref:System.Globalization.NumberFormatInfo.CurrencyGroupSeparator%2A>, y <xref:System.Globalization.NumberFormatInfo.NumberGroupSeparator%2A>.  
  
   
  
## Examples  
 En el ejemplo siguiente se usa el <xref:System.Single.Parse%28System.String%29> método para convertir una matriz de cadenas en equivalente <xref:System.Single> valores.  
  
 [!code-csharp[System.Single.Parse#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Single.Parse/CS/parse1.cs#2)]
 [!code-vb[System.Single.Parse#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Single.Parse/VB/parse1.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El valor de <paramref name="s" /> es <see langword="null" />.</exception>
        <exception cref="T:System.FormatException"><paramref name="s" /> no representa un número con un formato válido.</exception>
        <exception cref="T:System.OverflowException"><paramref name="s" /> representa un número menor que <see cref="F:System.Single.MinValue" /> o mayor que <see cref="F:System.Single.MaxValue" />.</exception>
        <altmember cref="M:System.Single.ToString" />
        <related type="Article" href="~/docs/standard/base-types/parsing-numeric.md">Analizar cadenas numéricas en .NET</related>
      </Docs>
    </Member>
    <Member MemberName="Parse">
      <MemberSignature Language="C#" Value="public static float Parse (string s, System.Globalization.NumberStyles style);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 Parse(string s, valuetype System.Globalization.NumberStyles style) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.Parse(System.String,System.Globalization.NumberStyles)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Parse (s As String, style As NumberStyles) As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static float Parse(System::String ^ s, System::Globalization::NumberStyles style);" />
      <MemberSignature Language="F#" Value="static member Parse : string * System.Globalization.NumberStyles -&gt; single" Usage="System.single.Parse (s, style)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="style" Type="System.Globalization.NumberStyles" />
      </Parameters>
      <Docs>
        <param name="s">Cadena que contiene un número que se va a convertir.</param>
        <param name="style">Combinación bit a bit de los valores de enumeración que indica los elementos de estilo que pueden estar presentes en <paramref name="s" />. Un valor que se especifica de forma habitual es <see cref="F:System.Globalization.NumberStyles.Float" /> combinado con <see cref="F:System.Globalization.NumberStyles.AllowThousands" />.</param>
        <summary>Convierte la representación en forma de cadena de un número con un estilo especificado en el número de punto flotante de precisión sencilla equivalente.</summary>
        <returns>Número de punto flotante de precisión sencilla equivalente al valor numérico o símbolo especificado en <paramref name="s" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El `style` parámetro define los elementos de estilo (como espacios en blanco, miles separadores y símbolos de moneda) que se permiten en el `s` parámetro para la operación de análisis se realice correctamente. Debe ser una combinación de marcas de bits de la <xref:System.Globalization.NumberStyles> enumeración. La siguiente <xref:System.Globalization.NumberStyles> miembros no son compatibles:  
  
-   <xref:System.Globalization.NumberStyles.AllowHexSpecifier>  
  
-   <xref:System.Globalization.NumberStyles.HexNumber>  
  
 El `s` parámetro puede contener la referencia cultural actual <xref:System.Globalization.NumberFormatInfo.PositiveInfinitySymbol%2A>, <xref:System.Globalization.NumberFormatInfo.NegativeInfinitySymbol%2A>, <xref:System.Globalization.NumberFormatInfo.NaNSymbol%2A>. Dependiendo del valor de `style`, también pueden adoptar la forma:  
  
 [*ws*] [*$*] [*sesión*] [*dígitos enteros*[*,*]] *dígitos enteros*[*.* [*dígitos fraccionarios*]] [E [*sesión*]*dígitos exponenciales*] [*ws*]  
  
 Los elementos de los corchetes ([ y ]) son opcionales. En esta tabla se describe cada elemento.  
  
 *ws*  
 Una serie de caracteres de espacio en blanco. Pueden aparecer espacios en blanco al principio de `s` si `style` incluye la <xref:System.Globalization.NumberStyles.AllowLeadingWhite?displayProperty=nameWithType> marca y puede aparecer al final de `s` si `style` incluye la <xref:System.Globalization.NumberStyles.AllowTrailingWhite?displayProperty=nameWithType> marca.  
  
 $  
 Un símbolo de moneda de la referencia cultural específica. Su posición en la cadena viene definida por el <xref:System.Globalization.NumberFormatInfo.CurrencyNegativePattern%2A?displayProperty=nameWithType> y <xref:System.Globalization.NumberFormatInfo.CurrencyPositivePattern%2A?displayProperty=nameWithType> propiedades de la referencia cultural actual. Símbolo de divisa de la referencia cultural actual puede aparecer en `s` si `style` incluye la <xref:System.Globalization.NumberStyles.AllowCurrencySymbol?displayProperty=nameWithType> marca.  
  
 *sign*  
 Símbolo de signo negativo (-) o de símbolos de un signo positivo (+). El inicio de sesión puede aparecer al principio de `s` si `style` incluye la <xref:System.Globalization.NumberStyles.AllowLeadingSign?displayProperty=nameWithType> marca y puede aparecer al final de `s` si `style` incluye la <xref:System.Globalization.NumberStyles.AllowTrailingSign?displayProperty=nameWithType> marca. Se pueden utilizar paréntesis en `s` para indicar un valor negativo si `style` incluye la <xref:System.Globalization.NumberStyles.AllowParentheses?displayProperty=nameWithType> marca.  
  
 *dígitos enteros*  
 Una serie de dígitos comprendidos del 0 al 9 que especifican la parte entera del número. El *dígitos enteros* puede ser el elemento ausente si la cadena contiene la *dígitos fraccionarios* elemento.  
  
 ,  
 Un separador de grupo específicas de referencias culturales. Símbolo de separador de grupos de la referencia cultural actual puede aparecer en `s` si `style` incluye la <xref:System.Globalization.NumberStyles.AllowThousands?displayProperty=nameWithType> marca  
  
 .  
 Un símbolo de separador de decimales de referencia cultural específica. Símbolo de separador decimal de la referencia cultural actual puede aparecer en `s` si `style` incluye la <xref:System.Globalization.NumberStyles.AllowDecimalPoint?displayProperty=nameWithType> marca.  
  
 *dígitos fraccionarios*  
 Una serie de dígitos comprendidos del 0 al 9 que especifican la parte fraccionaria del número. Pueden aparecer dígitos fraccionarios en `s` si `style` incluye la <xref:System.Globalization.NumberStyles.AllowDecimalPoint?displayProperty=nameWithType> marca.  
  
 E  
 La "e" o el carácter "E", lo que indica que el valor se representa en una notación exponencial (científica). El `value` parámetro puede representar un número en notación exponencial si `style` incluye la <xref:System.Globalization.NumberStyles.AllowExponent?displayProperty=nameWithType> marca.  
  
 *dígitos exponenciales*  
 Una serie de dígitos comprendidos del 0 al 9 que especifican a un exponente.  
  
> [!NOTE]
> Terminación NUL (u+0000) caracteres en `s` son ignoradas por la operación de análisis, independientemente del valor de la `style` argumento.

 Una cadena formada únicamente por dígitos (que corresponde a la <xref:System.Globalization.NumberStyles.None?displayProperty=nameWithType> estilo) siempre se analiza correctamente. Los restantes <xref:System.Globalization.NumberStyles?displayProperty=nameWithType> miembros controlan los elementos que pueden estar presentes, pero no tienen que estar presente en la cadena de entrada. La tabla siguiente se indica cómo individuales <xref:System.Globalization.NumberStyles> marcas afectan a los elementos que pueden estar presentes en `s`.  
  
|Valor NumberStyles|Elementos permitidos en `s` además de dígitos|  
|------------------------|-----------------------------------------------------|  
|<xref:System.Globalization.NumberStyles.None>|El *dígitos enteros* sólo elemento.|  
|<xref:System.Globalization.NumberStyles.AllowDecimalPoint>|El separador decimal (*.*) y *dígitos fraccionarios* elementos.|  
|<xref:System.Globalization.NumberStyles.AllowExponent>|La "e" o el carácter "E", lo que indica una notación exponencial. Este marcador por sí solo admite valores en el formulario *dígitos*E*dígitos*; adicionales se necesitan los marcadores para analizar correctamente cadenas con esos elementos como signos positivos o negativos y los símbolos de separador decimal.|  
|<xref:System.Globalization.NumberStyles.AllowLeadingWhite>|El *ws* elemento situado al principio de `s`.|  
|<xref:System.Globalization.NumberStyles.AllowTrailingWhite>|El *ws* elemento al final de `s`.|  
|<xref:System.Globalization.NumberStyles.AllowLeadingSign>|El *sesión* elemento situado al principio de `s`.|  
|<xref:System.Globalization.NumberStyles.AllowTrailingSign>|El *sesión* elemento al final de `s`.|  
|<xref:System.Globalization.NumberStyles.AllowParentheses>|El *sesión* elemento con la forma de paréntesis para delimitar el valor numérico.|  
|<xref:System.Globalization.NumberStyles.AllowThousands>|Miles elemento separador (,).|  
|<xref:System.Globalization.NumberStyles.AllowCurrencySymbol>|El elemento de moneda ($).|  
|<xref:System.Globalization.NumberStyles.Currency>|Todos los elementos. Sin embargo, `s` no puede representar un número hexadecimal o un número en notación exponencial.|  
|<xref:System.Globalization.NumberStyles.Float>|El *ws* elemento al principio o al final de `s`, *sesión* al principio de `s`y el símbolo de separador decimal (.). El `s` parámetro también puede utilizar la notación exponencial.|  
|<xref:System.Globalization.NumberStyles.Number>|El `ws`, `sign`, miles separador (,) y elementos de separador decimal (.).|  
|<xref:System.Globalization.NumberStyles.Any>|Todos los elementos. Sin embargo, `s` no se puede representar un número hexadecimal.|  
  
 Algunos ejemplos de `s` son "100", "-123,456,789", "123. 45e + 6", "+ 500", "5e2", "3.1416", "600.", "-. 123" y "-Infinity".  
  
 El `s` parámetro se analiza utilizando la información de formato en un <xref:System.Globalization.NumberFormatInfo> objeto que se inicializa para la referencia cultural actual del sistema. Para especificar la referencia cultural cuya información de formato se usa para la operación de análisis, llame a la <xref:System.Single.Parse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%29> de sobrecarga.  
  
 Normalmente, si se pasa el <xref:System.Single.Parse%2A> método una cadena que se crea mediante una llamada a la <xref:System.Single.ToString%2A> método, el original <xref:System.Single> se devuelve el valor. Sin embargo, debido a una pérdida de precisión, los valores pueden no ser iguales.  
  
 Si se encuentra un separador en la `s` parámetro durante una operación de análisis y la divisa aplicable o número decimal y separadores de grupo son iguales, la operación de análisis supone que se trata de un separador decimal en lugar de un grupo separador. Para obtener más información acerca de los separadores, consulte <xref:System.Globalization.NumberFormatInfo.CurrencyDecimalSeparator%2A>, <xref:System.Globalization.NumberFormatInfo.NumberDecimalSeparator%2A>, <xref:System.Globalization.NumberFormatInfo.CurrencyGroupSeparator%2A>, y <xref:System.Globalization.NumberFormatInfo.NumberGroupSeparator%2A>.  
  
   
  
## Examples  
 En el ejemplo siguiente se usa el <xref:System.Single.Parse%28System.String%2CSystem.Globalization.NumberStyles%29> método para analizar las representaciones de cadena de <xref:System.Single> valores. El ejemplo utiliza la información de formato para la referencia cultural en-US.  
  
 [!code-csharp[System.Single.Parse#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Single.Parse/CS/parse2.cs#3)]
 [!code-vb[System.Single.Parse#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Single.Parse/VB/parse2.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El valor de <paramref name="s" /> es <see langword="null" />.</exception>
        <exception cref="T:System.FormatException"><paramref name="s" /> no es un número con un formato válido.</exception>
        <exception cref="T:System.OverflowException"><paramref name="s" /> representa un número menor que <see cref="F:System.Single.MinValue" /> o mayor que <see cref="F:System.Single.MaxValue" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="style" /> no es un valor <see cref="T:System.Globalization.NumberStyles" />.  
  
O bien 
 <paramref name="style" /> incluye el valor <see cref="F:System.Globalization.NumberStyles.AllowHexSpecifier" /> </exception>
        <altmember cref="M:System.Single.ToString" />
        <altmember cref="Overload:System.Single.TryParse" />
        <related type="Article" href="~/docs/standard/base-types/parsing-numeric.md">Analizar cadenas numéricas en .NET</related>
      </Docs>
    </Member>
    <Member MemberName="Parse">
      <MemberSignature Language="C#" Value="public static float Parse (string s, IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 Parse(string s, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.Parse(System.String,System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Parse (s As String, provider As IFormatProvider) As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static float Parse(System::String ^ s, IFormatProvider ^ provider);" />
      <MemberSignature Language="F#" Value="static member Parse : string * IFormatProvider -&gt; single" Usage="System.single.Parse (s, provider)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="s">Cadena que contiene un número que se va a convertir.</param>
        <param name="provider">Objeto que proporciona información de formato específica de la referencia cultural acerca de <paramref name="s" />.</param>
        <summary>Convierte la representación en forma de cadena de un número con un formato específico de la referencia cultural especificado en el número de punto flotante de precisión sencilla equivalente.</summary>
        <returns>Número de punto flotante de precisión sencilla equivalente al valor numérico o símbolo especificado en <paramref name="s" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esta sobrecarga se utiliza normalmente para convertir el texto que se puede aplicar formato en una variedad de formas a un <xref:System.Single> valor. Por ejemplo, puede usarse para convertir el texto escrito por un usuario en un cuadro de texto HTML en un valor numérico.  
  
 El `s` parámetro se interpreta mediante una combinación de la <xref:System.Globalization.NumberStyles.Float?displayProperty=nameWithType> y <xref:System.Globalization.NumberStyles.AllowThousands?displayProperty=nameWithType> marcas. El `s` parámetro puede contener <xref:System.Globalization.NumberFormatInfo.PositiveInfinitySymbol%2A?displayProperty=nameWithType>, <xref:System.Globalization.NumberFormatInfo.NegativeInfinitySymbol%2A?displayProperty=nameWithType>, o <xref:System.Globalization.NumberFormatInfo.NaNSymbol%2A?displayProperty=nameWithType> para la referencia cultural especificada por `provider`, o puede contener una cadena del formulario:  
  
 [*ws*] [*sesión*]*dígitos enteros*[*.* [*dígitos fraccionarios*]] [E [*sesión*]*dígitos exponenciales*] [*ws*]  
  
 Elementos opcionales están entre corchetes ([y]). Los elementos que contienen el término "dígitos" constan de una serie de caracteres numéricos comprendidos entre 0 y 9.  
  
|Elemento|Descripción|  
|-------------|-----------------|  
|*ws*|Una serie de caracteres de espacio en blanco.|  
|*sign*|Símbolo de signo negativo (-) o de símbolos de un signo positivo (+).|  
|*dígitos enteros*|Una serie de dígitos comprendidos del 0 al 9 que especifican la parte entera del número. Se ejecuta de *dígitos enteros* pueden particionarse mediante un símbolo de separador de grupos. Por ejemplo, en algunas referencias culturales una coma (,) separa los millares. El *dígitos enteros* puede ser el elemento ausente si la cadena contiene la *dígitos fraccionarios* elemento.|  
|.|Un símbolo de separador de decimales de referencia cultural específica.|  
|*dígitos fraccionarios*|Una serie de dígitos comprendidos del 0 al 9 que especifican la parte fraccionaria del número.|  
|E|La "e" o el carácter "E", lo que indica que el valor se representa en una notación exponencial (científica).|  
|*dígitos exponenciales*|Una serie de dígitos comprendidos del 0 al 9 que especifican a un exponente.|  
  
 Para obtener más información acerca de formatos numéricos, vea el [aplicar formato a tipos](~/docs/standard/base-types/formatting-types.md) tema.  
  
 El `provider` parámetro es un <xref:System.IFormatProvider> implementación cuyo <xref:System.IFormatProvider.GetFormat%2A> método devuelve un <xref:System.Globalization.NumberFormatInfo> objeto que proporciona información de formato específica de la referencia cultural. Cuando el <xref:System.Single.Parse%28System.String%2CSystem.IFormatProvider%29> se invoca el método, llama a la `provider` del parámetro <xref:System.IFormatProvider.GetFormat%2A> método y le pasa un <xref:System.Type> objeto que representa el <xref:System.Globalization.NumberFormatInfo> tipo. El <xref:System.IFormatProvider.GetFormat%2A> método, a continuación, devuelve el <xref:System.Globalization.NumberFormatInfo> objeto que proporciona información sobre el formato de la `s` parámetro. Hay tres formas de usar el `provider` parámetro para proporcionar información de formato personalizado para la operación de análisis:  
  
-   Puede pasar un <xref:System.Globalization.CultureInfo> objeto que representa la referencia cultural que proporciona información de formato. Su <xref:System.Globalization.CultureInfo.GetFormat%2A> método devuelve el <xref:System.Globalization.NumberFormatInfo> objeto que proporciona información de formato numérico para esa referencia cultural.  
  
-   Puede pasar los datos reales <xref:System.Globalization.NumberFormatInfo> objeto que proporciona información de formato numérico. (Su implementación de <xref:System.Globalization.NumberFormatInfo.GetFormat%2A> simplemente devuelve a sí mismo.)  
  
-   Puede pasar un objeto personalizado que implementa <xref:System.IFormatProvider>. Su <xref:System.IFormatProvider.GetFormat%2A> crea una instancia de método y devuelve el <xref:System.Globalization.NumberFormatInfo> objeto que proporciona información de formato.  
  
 Si `provider` es `null` o <xref:System.Globalization.NumberFormatInfo> no se puede obtener la información de formato para la referencia cultural del sistema actual se utiliza.  
  
 Si se encuentra un separador en la `s` parámetro durante una operación de análisis y la divisa aplicable o número decimal y separadores de grupo son iguales, la operación de análisis supone que se trata de un separador decimal en lugar de un grupo separador. Para obtener más información acerca de los separadores, consulte <xref:System.Globalization.NumberFormatInfo.CurrencyDecimalSeparator%2A>, <xref:System.Globalization.NumberFormatInfo.NumberDecimalSeparator%2A>, <xref:System.Globalization.NumberFormatInfo.CurrencyGroupSeparator%2A>, y <xref:System.Globalization.NumberFormatInfo.NumberGroupSeparator%2A>.  
  
 Algunos ejemplos de `s` son "100", "-123,456,789", "123. 45e + 6", "+ 500", "5e2", "3.1416", "600.", "-. 123" y "-Infinity".  
  
   
  
## Examples  
 El ejemplo siguiente es el botón, haga clic en el controlador de eventos de un formulario Web. Utiliza la matriz devuelta por la <xref:System.Web.HttpRequest.UserLanguages%2A?displayProperty=nameWithType> propiedad para determinar la configuración regional del usuario. A continuación, crea una instancia de un <xref:System.Globalization.CultureInfo> objeto que corresponde a esa configuración regional. El <xref:System.Globalization.NumberFormatInfo> objeto al que pertenece a la que <xref:System.Globalization.CultureInfo> objeto, a continuación, se pasa a la <xref:System.Single.Parse%28System.String%2CSystem.IFormatProvider%29> entrada del método para convertir al usuario un <xref:System.Single> valor.  
  
 [!code-csharp[ParseMethod#1](~/samples/snippets/csharp/VS_Snippets_CLR/ParseMethod/cs/Default.aspx.cs#1)]
 [!code-vb[ParseMethod#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ParseMethod/vb/Default.aspx.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El valor de <paramref name="s" /> es <see langword="null" />.</exception>
        <exception cref="T:System.FormatException"><paramref name="s" /> no representa un número con un formato válido.</exception>
        <exception cref="T:System.OverflowException"><paramref name="s" /> representa un número menor que <see cref="F:System.Single.MinValue" /> o mayor que <see cref="F:System.Single.MaxValue" />.</exception>
        <altmember cref="M:System.Single.ToString" />
        <altmember cref="Overload:System.Single.TryParse" />
        <related type="Article" href="~/docs/standard/base-types/parsing-numeric.md">Analizar cadenas numéricas en .NET</related>
      </Docs>
    </Member>
    <Member MemberName="Parse">
      <MemberSignature Language="C#" Value="public static float Parse (ReadOnlySpan&lt;char&gt; s, System.Globalization.NumberStyles style = System.Globalization.NumberStyles.AllowDecimalPoint | System.Globalization.NumberStyles.AllowExponent | System.Globalization.NumberStyles.AllowLeadingSign | System.Globalization.NumberStyles.AllowLeadingWhite | System.Globalization.NumberStyles.AllowThousands | System.Globalization.NumberStyles.AllowTrailingWhite | System.Globalization.NumberStyles.Float | System.Globalization.NumberStyles.Integer, IFormatProvider provider = null);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 Parse(valuetype System.ReadOnlySpan`1&lt;char&gt; s, valuetype System.Globalization.NumberStyles style, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.Parse(System.ReadOnlySpan{System.Char},System.Globalization.NumberStyles,System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Parse (s As ReadOnlySpan(Of Char), Optional style As NumberStyles = System.Globalization.NumberStyles.AllowDecimalPoint | System.Globalization.NumberStyles.AllowExponent | System.Globalization.NumberStyles.AllowLeadingSign | System.Globalization.NumberStyles.AllowLeadingWhite | System.Globalization.NumberStyles.AllowThousands | System.Globalization.NumberStyles.AllowTrailingWhite | System.Globalization.NumberStyles.Float | System.Globalization.NumberStyles.Integer, Optional provider As IFormatProvider = null) As Single" />
      <MemberSignature Language="F#" Value="static member Parse : ReadOnlySpan&lt;char&gt; * System.Globalization.NumberStyles * IFormatProvider -&gt; single" Usage="System.single.Parse (s, style, provider)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.ReadOnlySpan&lt;System.Char&gt;" />
        <Parameter Name="style" Type="System.Globalization.NumberStyles" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="s">To be added.</param>
        <param name="style">To be added.</param>
        <param name="provider">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Parse">
      <MemberSignature Language="C#" Value="public static float Parse (string s, System.Globalization.NumberStyles style, IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 Parse(string s, valuetype System.Globalization.NumberStyles style, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.Parse(System.String,System.Globalization.NumberStyles,System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Parse (s As String, style As NumberStyles, provider As IFormatProvider) As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static float Parse(System::String ^ s, System::Globalization::NumberStyles style, IFormatProvider ^ provider);" />
      <MemberSignature Language="F#" Value="static member Parse : string * System.Globalization.NumberStyles * IFormatProvider -&gt; single" Usage="System.single.Parse (s, style, provider)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="style" Type="System.Globalization.NumberStyles" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="s">Cadena que contiene un número que se va a convertir.</param>
        <param name="style">Combinación bit a bit de los valores de enumeración que indica los elementos de estilo que pueden estar presentes en <paramref name="s" />. Un valor que se especifica de forma habitual es <see cref="F:System.Globalization.NumberStyles.Float" /> combinado con <see cref="F:System.Globalization.NumberStyles.AllowThousands" />.</param>
        <param name="provider">Objeto que proporciona información de formato específica de la referencia cultural acerca de <paramref name="s" />.</param>
        <summary>Convierte la representación en forma de cadena de un número con un estilo y un formato específico de la referencia cultural especificados en el número de punto flotante de precisión sencilla equivalente.</summary>
        <returns>Número de punto flotante de precisión sencilla equivalente al valor numérico o símbolo especificado en <paramref name="s" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El `style` parámetro define los elementos de estilo (como espacios en blanco, miles separadores y símbolos de moneda) que se permiten en el `s` parámetro para la operación de análisis se realice correctamente. Debe ser una combinación de marcas de bits de la <xref:System.Globalization.NumberStyles> enumeración. La siguiente <xref:System.Globalization.NumberStyles> miembros no son compatibles:  
  
-   <xref:System.Globalization.NumberStyles.AllowHexSpecifier>  
  
-   <xref:System.Globalization.NumberStyles.HexNumber>  
  
 El `s` parámetro puede contener <xref:System.Globalization.NumberFormatInfo.PositiveInfinitySymbol%2A?displayProperty=nameWithType>, <xref:System.Globalization.NumberFormatInfo.NegativeInfinitySymbol%2A?displayProperty=nameWithType>, o <xref:System.Globalization.NumberFormatInfo.NaNSymbol%2A?displayProperty=nameWithType> para la referencia cultural especificada por `provider`. Dependiendo del valor de `style`, también pueden adoptar la forma:  
  
 [*ws*] [*$*] [*sesión*] [*dígitos enteros*,]*dígitos enteros*[. [ *dígitos fraccionarios*]] [E [*sesión*]*dígitos exponenciales*] [*ws*]  
  
 Elementos que aparecen entre corchetes ([y]) son opcionales. En esta tabla se describe cada elemento.  
  
|Elemento|Descripción|  
|-------------|-----------------|  
|*ws*|Una serie de caracteres de espacio en blanco. Pueden aparecer espacios en blanco al principio de `s` si `style` incluye la <xref:System.Globalization.NumberStyles.AllowLeadingWhite?displayProperty=nameWithType> marca y puede aparecer al final de `s` si `style` incluye la <xref:System.Globalization.NumberStyles.AllowTrailingWhite?displayProperty=nameWithType> marca.|  
|$|Un símbolo de moneda de la referencia cultural específica. Su posición en la cadena viene definida por el <xref:System.Globalization.NumberFormatInfo.CurrencyNegativePattern%2A?displayProperty=nameWithType> y <xref:System.Globalization.NumberFormatInfo.CurrencyPositivePattern%2A?displayProperty=nameWithType> propiedades de la referencia cultural actual. Símbolo de divisa de la referencia cultural actual puede aparecer en `s` si `style` incluye la <xref:System.Globalization.NumberStyles.AllowCurrencySymbol?displayProperty=nameWithType> marca.|  
|*sign*|Símbolo de signo negativo (-) o de símbolos de un signo positivo (+). El inicio de sesión puede aparecer al principio de `s` si `style` incluye la <xref:System.Globalization.NumberStyles.AllowLeadingSign?displayProperty=nameWithType> marca y puede aparecer al final de `s` si `style` incluye la <xref:System.Globalization.NumberStyles.AllowTrailingSign?displayProperty=nameWithType> marca. Se pueden utilizar paréntesis en `s` para indicar un valor negativo si `style` incluye la <xref:System.Globalization.NumberStyles.AllowParentheses?displayProperty=nameWithType> marca.|  
|*dígitos enteros*|Una serie de dígitos comprendidos del 0 al 9 que especifican la parte entera del número. El *dígitos enteros* puede ser el elemento ausente si la cadena contiene la *dígitos fraccionarios* elemento.|  
|,|Un separador de grupo específicas de referencias culturales. Símbolo de separador de grupos de la referencia cultural actual puede aparecer en `s` si `style` incluye la <xref:System.Globalization.NumberStyles.AllowThousands?displayProperty=nameWithType> marca|  
|.|Un símbolo de separador de decimales de referencia cultural específica. Símbolo de separador decimal de la referencia cultural actual puede aparecer en `s` si `style` incluye la <xref:System.Globalization.NumberStyles.AllowDecimalPoint?displayProperty=nameWithType> marca.|  
|*dígitos fraccionarios*|Una serie de dígitos comprendidos del 0 al 9 que especifican la parte fraccionaria del número. Pueden aparecer dígitos fraccionarios en `s` si `style` incluye la <xref:System.Globalization.NumberStyles.AllowDecimalPoint?displayProperty=nameWithType> marca.|  
|E|La "e" o el carácter "E", lo que indica que el valor se representa en una notación exponencial (científica). El `s` parámetro puede representar un número en notación exponencial si `style` incluye la <xref:System.Globalization.NumberStyles.AllowExponent?displayProperty=nameWithType> marca.|  
|*dígitos exponenciales*|Una serie de dígitos comprendidos del 0 al 9 que especifican a un exponente.|  
  
> [!NOTE]
> Terminación NUL (u+0000) caracteres en `s` son ignoradas por la operación de análisis, independientemente del valor de la `style` argumento.

 Una cadena formada únicamente por dígitos (que corresponde a la <xref:System.Globalization.NumberStyles.None?displayProperty=nameWithType> estilo) siempre se analiza correctamente. Los restantes <xref:System.Globalization.NumberStyles?displayProperty=nameWithType> miembros controlan los elementos que pueden estar presentes, pero no tienen que estar presente en la cadena de entrada. La tabla siguiente se indica cómo individuales <xref:System.Globalization.NumberStyles> marcas afectan a los elementos que pueden estar presentes en `s`.  
  
|Valor NumberStyles|Elementos permitidos en `s` además de dígitos|  
|------------------------|-----------------------------------------------------|  
|<xref:System.Globalization.NumberStyles.None>|El *dígitos enteros* sólo elemento.|  
|<xref:System.Globalization.NumberStyles.AllowDecimalPoint>|El separador decimal (*.*) y *dígitos fraccionarios* elementos.|  
|<xref:System.Globalization.NumberStyles.AllowExponent>|La "e" o el carácter "E", lo que indica una notación exponencial. Este marcador por sí solo admite valores en el formulario *dígitos*E*dígitos*; adicionales se necesitan los marcadores para analizar correctamente cadenas con esos elementos como signos positivos o negativos y los símbolos de separador decimal.|  
|<xref:System.Globalization.NumberStyles.AllowLeadingWhite>|El *ws* elemento situado al principio de `s`.|  
|<xref:System.Globalization.NumberStyles.AllowTrailingWhite>|El *ws* elemento al final de `s`.|  
|<xref:System.Globalization.NumberStyles.AllowLeadingSign>|El *sesión* elemento situado al principio de `s`.|  
|<xref:System.Globalization.NumberStyles.AllowTrailingSign>|El *sesión* elemento al final de `s`.|  
|<xref:System.Globalization.NumberStyles.AllowParentheses>|El *sesión* elemento con la forma de paréntesis para delimitar el valor numérico.|  
|<xref:System.Globalization.NumberStyles.AllowThousands>|Miles elemento separador (,).|  
|<xref:System.Globalization.NumberStyles.AllowCurrencySymbol>|El elemento de moneda ($).|  
|<xref:System.Globalization.NumberStyles.Currency>|Todos los elementos. Sin embargo, `s` no puede representar un número hexadecimal o un número en notación exponencial.|  
|<xref:System.Globalization.NumberStyles.Float>|El *ws* elemento al principio o al final de `s`, *sesión* al principio de `s`y el símbolo de separador decimal (.). El `s` parámetro también puede utilizar la notación exponencial.|  
|<xref:System.Globalization.NumberStyles.Number>|El `ws`, `sign`, miles separador (,) y elementos de separador decimal (.).|  
|<xref:System.Globalization.NumberStyles.Any>|Todos los elementos. Sin embargo, `s` no se puede representar un número hexadecimal.|  
  
 El `provider` parámetro es un <xref:System.IFormatProvider> implementación. Su <xref:System.IFormatProvider.GetFormat%2A> método devuelve un <xref:System.Globalization.NumberFormatInfo> objeto que proporciona información específica de la referencia cultural sobre el formato de `value`. Por lo general, `provider` puede ser cualquiera de las siguientes acciones:  
  
-   Un <xref:System.Globalization.CultureInfo> objeto que representa la referencia cultural que proporciona información de formato numérico. Su <xref:System.Globalization.CultureInfo.GetFormat%2A> método devuelve el <xref:System.Globalization.NumberFormatInfo> objeto que proporciona información de formato numérico.  
  
-   Un <xref:System.Globalization.NumberFormatInfo> objeto que proporciona información de formato. (Su implementación de <xref:System.Globalization.NumberFormatInfo.GetFormat%2A> simplemente devuelve a sí mismo.)  
  
-   Un objeto personalizado que implementa <xref:System.IFormatProvider> y usa el <xref:System.Globalization.NumberFormatInfo.GetFormat%2A> método para crear instancias y devolver el <xref:System.Globalization.NumberFormatInfo> objeto que proporciona información de formato.  
  
 Si `provider` es `null`, el <xref:System.Globalization.NumberFormatInfo> objeto se usa la referencia cultural actual.  
  
 Si se encuentra un separador en la `s` parámetro durante una operación de análisis y la divisa aplicable o número decimal y separadores de grupo son iguales, la operación de análisis supone que se trata de un separador decimal en lugar de un grupo separador. Para obtener más información acerca de los separadores, consulte <xref:System.Globalization.NumberFormatInfo.CurrencyDecimalSeparator%2A>, <xref:System.Globalization.NumberFormatInfo.NumberDecimalSeparator%2A>, <xref:System.Globalization.NumberFormatInfo.CurrencyGroupSeparator%2A>, y <xref:System.Globalization.NumberFormatInfo.NumberGroupSeparator%2A>.  
  
   
  
## Examples  
 El siguiente ejemplo de código utiliza el <xref:System.Single.Parse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%29> método para analizar las representaciones de cadena de <xref:System.Single> valores. Cada cadena en una matriz se analiza mediante las convenciones de formato de en-US, nl-NL y una referencia cultural personalizada. La referencia cultural personalizada define su símbolo de separador de grupo como el carácter de subrayado ("_") y el tamaño de grupo como dos.  
  
 [!code-csharp[System.Single.Parse#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Single.Parse/CS/parse3.cs#4)]
 [!code-vb[System.Single.Parse#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Single.Parse/VB/parse3.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El valor de <paramref name="s" /> es <see langword="null" />.</exception>
        <exception cref="T:System.FormatException"><paramref name="s" /> no representa un valor numérico.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="style" /> no es un valor <see cref="T:System.Globalization.NumberStyles" />.  
  
O bien 
 <paramref name="style" /> es el valor <see cref="F:System.Globalization.NumberStyles.AllowHexSpecifier" />.</exception>
        <exception cref="T:System.OverflowException"><paramref name="s" /> representa un número menor que <see cref="F:System.Single.MinValue" /> o mayor que <see cref="F:System.Single.MaxValue" />.</exception>
        <altmember cref="M:System.Single.ToString" />
        <related type="Article" href="~/docs/standard/base-types/parsing-numeric.md">Analizar cadenas numéricas en .NET</related>
      </Docs>
    </Member>
    <Member MemberName="PositiveInfinity">
      <MemberSignature Language="C#" Value="public const float PositiveInfinity = Infinity;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal float32 PositiveInfinity = float32(Infinity)" />
      <MemberSignature Language="DocId" Value="F:System.Single.PositiveInfinity" />
      <MemberSignature Language="VB.NET" Value="Public Const PositiveInfinity As Single  = Infinity" />
      <MemberSignature Language="C++ CLI" Value="public: float PositiveInfinity = Infinity;" />
      <MemberSignature Language="F#" Value="val mutable PositiveInfinity : single" Usage="System.single.PositiveInfinity" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <MemberValue>Infinity</MemberValue>
      <Docs>
        <summary>Representa infinito positivo. Este campo es constante.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El valor de esta constante es el resultado de dividir un número positivo por cero.  
  
 Esta constante se devuelve cuando es mayor que el resultado de una operación <xref:System.Single.MaxValue>.  
  
 Use <xref:System.Single.IsPositiveInfinity%2A> para determinar si un valor se evalúa como infinito positivo.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra el <xref:System.Single.PositiveInfinity> constante.  
  
 [!code-cpp[System.Single#10](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Single/CPP/singlesample.cpp#10)]
 [!code-csharp[System.Single#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Single/CS/singlesample.cs#10)]
 [!code-vb[System.Single#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Single/VB/singlesample.vb#10)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Single.IsPositiveInfinity(System.Single)" />
        <altmember cref="M:System.Single.IsInfinity(System.Single)" />
        <altmember cref="F:System.Single.NegativeInfinity" />
      </Docs>
    </Member>
    <Member MemberName="System.IComparable.CompareTo">
      <MemberSignature Language="C#" Value="int IComparable.CompareTo (object value);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int32 System.IComparable.CompareTo(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.System#IComparable#CompareTo(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Function CompareTo (value As Object) As Integer Implements IComparable.CompareTo" />
      <MemberSignature Language="C++ CLI" Value=" virtual int System.IComparable.CompareTo(System::Object ^ value) = IComparable::CompareTo;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IComparable.CompareTo(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.GetTypeCode">
      <MemberSignature Language="C#" Value="TypeCode IConvertible.GetTypeCode ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance valuetype System.TypeCode System.IConvertible.GetTypeCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.System#IConvertible#GetTypeCode" />
      <MemberSignature Language="VB.NET" Value="Function GetTypeCode () As TypeCode Implements IConvertible.GetTypeCode" />
      <MemberSignature Language="C++ CLI" Value=" virtual TypeCode System.IConvertible.GetTypeCode() = IConvertible::GetTypeCode;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.GetTypeCode</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.TypeCode</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToBoolean">
      <MemberSignature Language="C#" Value="bool IConvertible.ToBoolean (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool System.IConvertible.ToBoolean(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.System#IConvertible#ToBoolean(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToBoolean (provider As IFormatProvider) As Boolean Implements IConvertible.ToBoolean" />
      <MemberSignature Language="C++ CLI" Value=" virtual bool System.IConvertible.ToBoolean(IFormatProvider ^ provider) = IConvertible::ToBoolean;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToBoolean(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Este parámetro se ignora.</param>
        <summary>Para obtener una descripción de este miembro, vea <see cref="M:System.IConvertible.ToBoolean(System.IFormatProvider)" />.</summary>
        <returns>Es <see langword="true" /> si el valor de la instancia actual no es cero; en caso contrario, es <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este miembro es una implementación explícita de un miembro de interfaz. Solo se puede utilizar cuando la instancia de <xref:System.Single> se convierte en una interfaz <xref:System.IConvertible>. La alternativa recomendada es llamar a la <xref:System.Convert.ToBoolean%28System.Single%29?displayProperty=nameWithType> método.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToByte">
      <MemberSignature Language="C#" Value="byte IConvertible.ToByte (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance unsigned int8 System.IConvertible.ToByte(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.System#IConvertible#ToByte(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToByte (provider As IFormatProvider) As Byte Implements IConvertible.ToByte" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Byte System.IConvertible.ToByte(IFormatProvider ^ provider) = IConvertible::ToByte;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToByte(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Este parámetro se ignora.</param>
        <summary>Para obtener una descripción de este miembro, vea <see cref="M:System.IConvertible.ToByte(System.IFormatProvider)" />.</summary>
        <returns>Valor de la instancia actual, convertido en <see cref="T:System.Byte" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este miembro es una implementación explícita de un miembro de interfaz. Solo se puede utilizar cuando la instancia de <xref:System.Single> se convierte en una interfaz <xref:System.IConvertible>. La alternativa recomendada es llamar a la <xref:System.Convert.ToByte%28System.Single%29?displayProperty=nameWithType> método.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToChar">
      <MemberSignature Language="C#" Value="char IConvertible.ToChar (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance char System.IConvertible.ToChar(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.System#IConvertible#ToChar(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToChar (provider As IFormatProvider) As Char Implements IConvertible.ToChar" />
      <MemberSignature Language="C++ CLI" Value=" virtual char System.IConvertible.ToChar(IFormatProvider ^ provider) = IConvertible::ToChar;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToChar(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Este parámetro se ignora.</param>
        <summary>No se admite esta conversión. Cualquier intento de usar este método produce una excepción <see cref="T:System.InvalidCastException" />.</summary>
        <returns>No se admite esta conversión. No se devuelve ningún valor.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidCastException">En todos los casos.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToDateTime">
      <MemberSignature Language="C#" Value="DateTime IConvertible.ToDateTime (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance valuetype System.DateTime System.IConvertible.ToDateTime(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.System#IConvertible#ToDateTime(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToDateTime (provider As IFormatProvider) As DateTime Implements IConvertible.ToDateTime" />
      <MemberSignature Language="C++ CLI" Value=" virtual DateTime System.IConvertible.ToDateTime(IFormatProvider ^ provider) = IConvertible::ToDateTime;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToDateTime(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Este parámetro se ignora.</param>
        <summary>No se admite esta conversión. Cualquier intento de usar este método produce una excepción <see cref="T:System.InvalidCastException" />.</summary>
        <returns>No se admite esta conversión. No se devuelve ningún valor.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidCastException">En todos los casos.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToDecimal">
      <MemberSignature Language="C#" Value="decimal IConvertible.ToDecimal (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance valuetype System.Decimal System.IConvertible.ToDecimal(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.System#IConvertible#ToDecimal(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToDecimal (provider As IFormatProvider) As Decimal Implements IConvertible.ToDecimal" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Decimal System.IConvertible.ToDecimal(IFormatProvider ^ provider) = IConvertible::ToDecimal;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToDecimal(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Este parámetro se ignora.</param>
        <summary>Para obtener una descripción de este miembro, vea <see cref="M:System.IConvertible.ToDecimal(System.IFormatProvider)" />.</summary>
        <returns>Valor de la instancia actual, convertido en <see cref="T:System.Decimal" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este miembro es una implementación explícita de un miembro de interfaz. Solo se puede utilizar cuando la instancia de <xref:System.Single> se convierte en una interfaz <xref:System.IConvertible>. La alternativa recomendada es llamar a la <xref:System.Convert.ToDecimal%28System.Single%29?displayProperty=nameWithType> método.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToDouble">
      <MemberSignature Language="C#" Value="double IConvertible.ToDouble (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance float64 System.IConvertible.ToDouble(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.System#IConvertible#ToDouble(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToDouble (provider As IFormatProvider) As Double Implements IConvertible.ToDouble" />
      <MemberSignature Language="C++ CLI" Value=" virtual double System.IConvertible.ToDouble(IFormatProvider ^ provider) = IConvertible::ToDouble;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToDouble(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Este parámetro se ignora.</param>
        <summary>Para una descripción de este miembro, vea <see cref="M:System.IConvertible.ToDouble(System.IFormatProvider)" />.</summary>
        <returns>Valor de la instancia actual, convertido en <see cref="T:System.Double" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este miembro es una implementación explícita de un miembro de interfaz. Solo se puede utilizar cuando la instancia de <xref:System.Single> se convierte en una interfaz <xref:System.IConvertible>. La alternativa recomendada es llamar a la <xref:System.Convert.ToDouble%28System.Single%29?displayProperty=nameWithType> método.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToInt16">
      <MemberSignature Language="C#" Value="short IConvertible.ToInt16 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int16 System.IConvertible.ToInt16(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.System#IConvertible#ToInt16(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToInt16 (provider As IFormatProvider) As Short Implements IConvertible.ToInt16" />
      <MemberSignature Language="C++ CLI" Value=" virtual short System.IConvertible.ToInt16(IFormatProvider ^ provider) = IConvertible::ToInt16;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToInt16(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Este parámetro se ignora.</param>
        <summary>Para obtener una descripción de este miembro, vea <see cref="M:System.IConvertible.ToInt16(System.IFormatProvider)" />.</summary>
        <returns>Valor de la instancia actual, convertido en <see cref="T:System.Int16" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este miembro es una implementación explícita de un miembro de interfaz. Solo se puede utilizar cuando la instancia de <xref:System.Single> se convierte en una interfaz <xref:System.IConvertible>. La alternativa recomendada es llamar a la <xref:System.Convert.ToInt16%28System.Single%29?displayProperty=nameWithType> método.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToInt32">
      <MemberSignature Language="C#" Value="int IConvertible.ToInt32 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int32 System.IConvertible.ToInt32(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.System#IConvertible#ToInt32(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToInt32 (provider As IFormatProvider) As Integer Implements IConvertible.ToInt32" />
      <MemberSignature Language="C++ CLI" Value=" virtual int System.IConvertible.ToInt32(IFormatProvider ^ provider) = IConvertible::ToInt32;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToInt32(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Este parámetro se ignora.</param>
        <summary>Para obtener una descripción de este miembro, vea <see cref="M:System.IConvertible.ToInt32(System.IFormatProvider)" />.</summary>
        <returns>Valor de la instancia actual, convertido en <see cref="T:System.Int32" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este miembro es una implementación explícita de un miembro de interfaz. Solo se puede utilizar cuando la instancia de <xref:System.Single> se convierte en una interfaz <xref:System.IConvertible>. La alternativa recomendada es llamar a la <xref:System.Convert.ToInt32%28System.Single%29?displayProperty=nameWithType> método.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToInt64">
      <MemberSignature Language="C#" Value="long IConvertible.ToInt64 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int64 System.IConvertible.ToInt64(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.System#IConvertible#ToInt64(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToInt64 (provider As IFormatProvider) As Long Implements IConvertible.ToInt64" />
      <MemberSignature Language="C++ CLI" Value=" virtual long System.IConvertible.ToInt64(IFormatProvider ^ provider) = IConvertible::ToInt64;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToInt64(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Este parámetro se ignora.</param>
        <summary>Para obtener una descripción de este miembro, vea <see cref="M:System.IConvertible.ToInt64(System.IFormatProvider)" />.</summary>
        <returns>Valor de la instancia actual, convertido en <see cref="T:System.Int64" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este miembro es una implementación explícita de un miembro de interfaz. Solo se puede utilizar cuando la instancia de <xref:System.Single> se convierte en una interfaz <xref:System.IConvertible>. La alternativa recomendada es llamar a la <xref:System.Convert.ToInt64%28System.Single%29?displayProperty=nameWithType> método.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToSByte">
      <MemberSignature Language="C#" Value="sbyte IConvertible.ToSByte (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int8 System.IConvertible.ToSByte(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.System#IConvertible#ToSByte(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToSByte (provider As IFormatProvider) As SByte Implements IConvertible.ToSByte" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::SByte System.IConvertible.ToSByte(IFormatProvider ^ provider) = IConvertible::ToSByte;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToSByte(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.SByte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Este parámetro se ignora.</param>
        <summary>Para una descripción de este miembro, vea <see cref="M:System.IConvertible.ToSByte(System.IFormatProvider)" />.</summary>
        <returns>Valor de la instancia actual, convertido en <see cref="T:System.SByte" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este miembro es una implementación explícita de un miembro de interfaz. Solo se puede utilizar cuando la instancia de <xref:System.Single> se convierte en una interfaz <xref:System.IConvertible>. La alternativa recomendada es llamar a la <xref:System.Convert.ToSByte%28System.Single%29?displayProperty=nameWithType> método.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToSingle">
      <MemberSignature Language="C#" Value="float IConvertible.ToSingle (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance float32 System.IConvertible.ToSingle(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.System#IConvertible#ToSingle(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToSingle (provider As IFormatProvider) As Single Implements IConvertible.ToSingle" />
      <MemberSignature Language="C++ CLI" Value=" virtual float System.IConvertible.ToSingle(IFormatProvider ^ provider) = IConvertible::ToSingle;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToSingle(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Este parámetro se ignora.</param>
        <summary>Para una descripción de este miembro, vea <see cref="M:System.IConvertible.ToSingle(System.IFormatProvider)" />.</summary>
        <returns>Valor de la instancia actual, sin ningún tipo de modificación.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este miembro es una implementación explícita de un miembro de interfaz. Solo se puede utilizar cuando la instancia de <xref:System.Single> se convierte en una interfaz <xref:System.IConvertible>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToType">
      <MemberSignature Language="C#" Value="object IConvertible.ToType (Type type, IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance object System.IConvertible.ToType(class System.Type type, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.System#IConvertible#ToType(System.Type,System.IFormatProvider)" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Object ^ System.IConvertible.ToType(Type ^ type, IFormatProvider ^ provider) = IConvertible::ToType;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToType(System.Type,System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="type">Tipo al que se va a convertir este valor <see cref="T:System.Single" />.</param>
        <param name="provider">Objeto que suministra información sobre el formato del valor devuelto.</param>
        <summary>Para una descripción de este miembro, vea <see cref="M:System.IConvertible.ToType(System.Type,System.IFormatProvider)" />.</summary>
        <returns>Valor de la instancia actual, convertido en <paramref name="type" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este miembro es una implementación explícita de un miembro de interfaz. Solo se puede utilizar cuando la instancia de <xref:System.Single> se convierte en una interfaz <xref:System.IConvertible>. La alternativa recomendada es llamar a la `static` (`Shared` en Visual Basic) <xref:System.Convert.ChangeType%2A?displayProperty=nameWithType> método.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToUInt16">
      <MemberSignature Language="C#" Value="ushort IConvertible.ToUInt16 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance unsigned int16 System.IConvertible.ToUInt16(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.System#IConvertible#ToUInt16(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToUInt16 (provider As IFormatProvider) As UShort Implements IConvertible.ToUInt16" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::UInt16 System.IConvertible.ToUInt16(IFormatProvider ^ provider) = IConvertible::ToUInt16;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToUInt16(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Este parámetro se ignora.</param>
        <summary>Para obtener una descripción de este miembro, vea <see cref="M:System.IConvertible.ToUInt16(System.IFormatProvider)" />.</summary>
        <returns>Valor de la instancia actual, convertido en <see cref="T:System.UInt16" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este miembro es una implementación explícita de un miembro de interfaz. Solo se puede utilizar cuando la instancia de <xref:System.Single> se convierte en una interfaz <xref:System.IConvertible>. La alternativa recomendada es llamar a la <xref:System.Convert.ToUInt16%28System.Single%29?displayProperty=nameWithType> método.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToUInt32">
      <MemberSignature Language="C#" Value="uint IConvertible.ToUInt32 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance unsigned int32 System.IConvertible.ToUInt32(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.System#IConvertible#ToUInt32(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToUInt32 (provider As IFormatProvider) As UInteger Implements IConvertible.ToUInt32" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::UInt32 System.IConvertible.ToUInt32(IFormatProvider ^ provider) = IConvertible::ToUInt32;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToUInt32(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Este parámetro se ignora.</param>
        <summary>Para obtener una descripción de este miembro, vea <see cref="M:System.IConvertible.ToUInt32(System.IFormatProvider)" />.</summary>
        <returns>Valor de la instancia actual, convertido en <see cref="T:System.UInt32" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este miembro es una implementación explícita de un miembro de interfaz. Solo se puede utilizar cuando la instancia de <xref:System.Single> se convierte en una interfaz <xref:System.IConvertible>. La alternativa recomendada es llamar a la <xref:System.Convert.ToUInt32%28System.Single%29?displayProperty=nameWithType> método.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToUInt64">
      <MemberSignature Language="C#" Value="ulong IConvertible.ToUInt64 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance unsigned int64 System.IConvertible.ToUInt64(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.System#IConvertible#ToUInt64(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToUInt64 (provider As IFormatProvider) As ULong Implements IConvertible.ToUInt64" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::UInt64 System.IConvertible.ToUInt64(IFormatProvider ^ provider) = IConvertible::ToUInt64;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToUInt64(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Este parámetro se ignora.</param>
        <summary>Para obtener una descripción de este miembro, vea <see cref="M:System.IConvertible.ToUInt64(System.IFormatProvider)" />.</summary>
        <returns>Valor de la instancia actual, convertido en <see cref="T:System.UInt64" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este miembro es una implementación explícita de un miembro de interfaz. Solo se puede utilizar cuando la instancia de <xref:System.Single> se convierte en una interfaz <xref:System.IConvertible>. La alternativa recomendada es llamar a la <xref:System.Convert.ToUInt64%28System.Single%29?displayProperty=nameWithType> método.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="ToString">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Convierte el valor numérico de esta instancia en la representación de cadena equivalente.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="single.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Convierte el valor numérico de esta instancia en la representación de cadena equivalente.</summary>
        <returns>Representación de cadena del valor de esta instancia.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Single.ToString> método formatos un <xref:System.Single> valor en el valor predeterminado ("G" o general), formato de la referencia cultural actual. Si desea especificar un formato diferente o la referencia cultural, use las otras sobrecargas de los <xref:System.Single.ToString%2A> método, como se indica a continuación:  
  
|Para usar el formato|Para la referencia cultural|Use la sobrecarga|  
|-------------------|-----------------|----------------------|  
|Formato predeterminado ("G")|Una referencia cultural específica|<xref:System.Single.ToString%28System.IFormatProvider%29>|  
|Un formato concreto|Referencia cultural de forma predeterminada (actual)|<xref:System.Single.ToString%28System.String%29>|  
|Un formato concreto|Una referencia cultural específica|<xref:System.Single.ToString%28System.String%2CSystem.IFormatProvider%29>|  
  
 El valor devuelto puede ser <xref:System.Globalization.NumberFormatInfo.PositiveInfinitySymbol%2A>, <xref:System.Globalization.NumberFormatInfo.NegativeInfinitySymbol%2A>, <xref:System.Globalization.NumberFormatInfo.NaNSymbol%2A>, o una cadena del formulario:  
  
 [sign]integral-digits[.[fractional-digits]][e[sign]exponential-digits]  
  
 Elementos opcionales están entre corchetes ([y]). Los elementos que contienen el término "dígitos" constan de una serie de caracteres numéricos comprendidos entre 0 y 9. En la tabla siguiente se enumera cada elemento:  
  
|Elemento|Descripción|  
|-------------|-----------------|  
|*sign*|Un signo negativo o un símbolo de signo positivo.|  
|*dígitos enteros*|Una serie de dígitos que especifican la parte entera del número. Dígitos enteros pueden estar ausentes si hay dígitos fraccionarios.|  
|'.'|Un símbolo de separador de decimales de referencia cultural específica.|  
|*dígitos fraccionarios*|Una serie de dígitos que especifican la parte fraccionaria del número.|  
|'e'|Un carácter en minúscula "e", que indica una notación exponencial (científica).|  
|*dígitos exponenciales*|Una serie de dígitos que especifican a un exponente.|  
  
 Algunos ejemplos del valor devuelto son "100", "-123,456,789", "123. 45e + 6", "500", "3.1416", "600", "-0.123" y "-Infinity".  
  
 .NET Framework proporciona una amplia compatibilidad de formato, que se describe con más detalle en los temas de formato siguientes:  
  
-   Para obtener más información sobre los especificadores de formato numérico, vea [cadenas de formato numérico estándar](~/docs/standard/base-types/standard-numeric-format-strings.md) y [cadenas con formato numérico personalizado](~/docs/standard/base-types/custom-numeric-format-strings.md).  
  
-   Para obtener más información sobre el formato, vea [aplicar formato a tipos](~/docs/standard/base-types/formatting-types.md).  
  
   
  
## Examples  
 En el ejemplo siguiente se usa el valor predeterminado <xref:System.Single.ToString%2A?displayProperty=nameWithType> método para mostrar las representaciones de cadena de un número de <xref:System.Single> valores.  
  
 [!code-csharp[System.Single.ToString#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Single.ToString/CS/ToString1.cs#1)]
 [!code-vb[System.Single.ToString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Single.ToString/VB/ToString1.vb#1)]  
  
 El ejemplo de código siguiente muestra el uso de la <xref:System.Single.Parse%28System.String%29> método junto con el <xref:System.Single.ToString> método.  
  
 [!code-cpp[System.Single#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Single/CPP/singlesample.cpp#3)]
 [!code-csharp[System.Single#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Single/CS/singlesample.cs#3)]
 [!code-vb[System.Single#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Single/VB/singlesample.vb#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Single.Parse(System.String)" />
        <altmember cref="T:System.String" />
        <related type="Article" href="~/docs/standard/base-types/formatting-types.md">Aplicar formato a tipos en .NET</related>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public string ToString (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string ToString(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.ToString(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToString (provider As IFormatProvider) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ ToString(IFormatProvider ^ provider);" />
      <MemberSignature Language="F#" Value="override this.ToString : IFormatProvider -&gt; string" Usage="single.ToString provider" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToString(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Objeto que proporciona información de formato específica de la referencia cultural.</param>
        <summary>Convierte el valor numérico de esta instancia en la representación de cadena equivalente usando la información de formato específica de la referencia cultural especificada.</summary>
        <returns>Representación en forma de cadena del valor de esta instancia, tal y como especifica <paramref name="provider" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Single.ToString%28System.IFormatProvider%29> método formatos un <xref:System.Single> valor en el valor predeterminado ("G" o general), formato de una referencia cultural especificada. Si desea especificar un formato diferente o la referencia cultural actual, use las otras sobrecargas de los <xref:System.Single.ToString%2A> método, como se indica a continuación:  
  
|Para usar el formato|Para la referencia cultural|Use la sobrecarga|  
|-------------------|-----------------|----------------------|  
|Formato predeterminado ("G")|Referencia cultural de forma predeterminada (actual)|<xref:System.Single.ToString>|  
|Un formato concreto|Referencia cultural de forma predeterminada (actual)|<xref:System.Single.ToString%28System.String%29>|  
|Un formato concreto|Una referencia cultural específica|<xref:System.Single.ToString%28System.String%2CSystem.IFormatProvider%29>|  
  
 El valor devuelto puede ser <xref:System.Globalization.NumberFormatInfo.PositiveInfinitySymbol%2A>, <xref:System.Globalization.NumberFormatInfo.NegativeInfinitySymbol%2A>, <xref:System.Globalization.NumberFormatInfo.NaNSymbol%2A>, o una cadena del formulario:  
  
 [sign]integral-digits[.[fractional-digits]][e[sign]exponential-digits]  
  
 Elementos opcionales están entre corchetes ([y]). Elementos que contienen el término "dígitos" constan de una serie de caracteres numéricos comprendidos entre 0 y 9. La tabla siguiente enumera cada elemento.  
  
|Elemento|Descripción|  
|-------------|-----------------|  
|sign|Un signo negativo o un símbolo de signo positivo.|  
|dígitos enteros|Una serie de dígitos que especifican la parte entera del número. Dígitos enteros pueden estar ausentes si hay dígitos fraccionarios.|  
|'.'|Un símbolo de separador de decimales de referencia cultural específica.|  
|dígitos fraccionarios|Una serie de dígitos que especifican la parte fraccionaria del número.|  
|'e'|Un carácter en minúscula "e", que indica una notación exponencial (científica).|  
|dígitos exponenciales|Una serie de dígitos que especifican a un exponente.|  
  
 Algunos ejemplos del valor devuelto son "100", "-123,456,789", "123. 45e + 6", "500", "3.1416", "600", "-0.123" y "-Infinity".  
  
 .NET Framework proporciona una amplia compatibilidad de formato, que se describe con más detalle en los temas de formato siguientes:  
  
-   Para obtener más información sobre los especificadores de formato numérico, vea [cadenas de formato numérico estándar](~/docs/standard/base-types/standard-numeric-format-strings.md) y [cadenas con formato numérico personalizado](~/docs/standard/base-types/custom-numeric-format-strings.md).  
  
-   Para obtener más información sobre el formato, vea [aplicar formato a tipos](~/docs/standard/base-types/formatting-types.md).  
  
 El `provider` parámetro es un <xref:System.IFormatProvider> implementación cuyo <xref:System.IFormatProvider.GetFormat%2A> método devuelve un <xref:System.Globalization.NumberFormatInfo> objeto. Por lo general, `provider` es un <xref:System.Globalization.CultureInfo> objeto o un <xref:System.Globalization.NumberFormatInfo> objeto. El `provider` parámetro proporciona información específica de la referencia cultural usada en el formato. Si `provider` es `null`, el valor devuelto se representa con el <xref:System.Globalization.NumberFormatInfo> datos para la referencia cultural actual.  
  
 Para convertir un <xref:System.Single> valor a su representación de cadena utilizando una referencia cultural especificada y una cadena de formato específico, llamada la <xref:System.Single.ToString%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType> método.  
  
   
  
## Examples  
 En el ejemplo siguiente se muestra la representación de cadena de dos <xref:System.Single> valores utilizando <xref:System.Globalization.CultureInfo> objetos que representan varias referencias culturales diferentes.  
  
 [!code-csharp[System.Single.ToString#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Single.ToString/CS/ToString1.cs#2)]
 [!code-vb[System.Single.ToString#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Single.ToString/VB/ToString1.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Single.Parse(System.String)" />
        <altmember cref="T:System.String" />
        <related type="Article" href="~/docs/standard/base-types/formatting-types.md">Aplicar formato a tipos en .NET</related>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public string ToString (string format);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ToString(string format) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.ToString(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToString (format As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ToString(System::String ^ format);" />
      <MemberSignature Language="F#" Value="override this.ToString : string -&gt; string" Usage="single.ToString format" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="format">Cadena de formato numérico.</param>
        <summary>Convierte el valor numérico de esta instancia en la representación de cadena equivalente usando el formato especificado.</summary>
        <returns>Representación en forma de cadena del valor de esta instancia, tal y como especifica <paramref name="format" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Single.ToString%28System.String%29> método formatos un <xref:System.Single> valor en un formato especificado mediante las convenciones de la referencia cultural actual. Si desea usar el valor predeterminado ("G" o general) dar formato o especificar una referencia cultural diferente, use las otras sobrecargas de los <xref:System.Single.ToString%2A> método, como se indica a continuación:  
  
|Para usar el formato|Para la referencia cultural|Use la sobrecarga|  
|-------------------|-----------------|----------------------|  
|Formato predeterminado ("G")|Referencia cultural de forma predeterminada (actual)|<xref:System.Single.ToString>|  
|Formato predeterminado ("G")|Una referencia cultural específica|<xref:System.Single.ToString%28System.IFormatProvider%29>|  
|Un formato concreto|Una referencia cultural específica|<xref:System.Single.ToString%28System.String%2CSystem.IFormatProvider%29>|  
  
 El valor devuelto puede ser <xref:System.Globalization.NumberFormatInfo.PositiveInfinitySymbol%2A>, <xref:System.Globalization.NumberFormatInfo.NegativeInfinitySymbol%2A>, <xref:System.Globalization.NumberFormatInfo.NaNSymbol%2A>, o la representación de cadena del valor de la instancia actual, según lo especificado por `format`.  
  
 El `format` parámetro puede ser cualquier especificador de formato numérico estándar válido salvo D y X, así como cualquier combinación de especificadores de formato numérico personalizado. Si el formato es `null` o una cadena vacía, el valor devuelto tiene el formato con el especificador de formato numérico general ("G").  
  
 .NET Framework proporciona una amplia compatibilidad de formato, que se describe con más detalle en los temas de formato siguientes:  
  
-   Para obtener más información sobre los especificadores de formato numérico, vea [cadenas de formato numérico estándar](~/docs/standard/base-types/standard-numeric-format-strings.md) y [cadenas con formato numérico personalizado](~/docs/standard/base-types/custom-numeric-format-strings.md).  
  
-   Para obtener más información sobre el formato, vea [aplicar formato a tipos](~/docs/standard/base-types/formatting-types.md).  
  
 De forma predeterminada, el valor devuelto solo contiene 7 dígitos de precisión, aunque internamente se mantiene un máximo de 9 dígitos. Si el valor de esta instancia tiene más de 7 dígitos <xref:System.Single.ToString%28System.String%29> devuelve <xref:System.Globalization.NumberFormatInfo.PositiveInfinitySymbol%2A> o <xref:System.Globalization.NumberFormatInfo.NegativeInfinitySymbol%2A> en lugar del número esperado. Si necesita más precisión, especifique `format` con la especificación de formato "G9", que siempre devuelve 9 dígitos de precisión o "R", que devuelve 7 dígitos si el número se puede representar con esa precisión o 9 dígitos si solo se puede representar el número con la máxima precisión.  
  
   
  
## Examples  
 En el ejemplo siguiente se define un valor numérico y le asigna un valor de moneda mediante el uso de la cadena de formato numérico estándar "C" y como un valor numérico con tres decimales mediante el uso de la cadena de formato numérico estándar "N". Se da formato a las cadenas de resultado mediante las convenciones de la referencia cultural en-US. Para obtener más información sobre las cadenas de formato numérico, vea [cadenas de formato numérico estándar](~/docs/standard/base-types/standard-numeric-format-strings.md) y [cadenas con formato numérico personalizado](~/docs/standard/base-types/custom-numeric-format-strings.md).  
  
 [!code-csharp[System.Single.ToString#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Single.ToString/CS/ToString7.cs#7)]
 [!code-vb[System.Single.ToString#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Single.ToString/VB/ToString7.vb#7)]  
  
 El ejemplo siguiente muestra varios <xref:System.Single> valores con cada uno de los especificadores de formato numérico estándar compatibles junto con dos cadenas de formato numérico personalizado. Una de esas cadenas de formato personalizado muestra cómo rellenar un <xref:System.Single> valor con ceros iniciales. Convertir los valores numéricos en cadenas, el ejemplo usa las convenciones de formato de la referencia cultural en-US.  
  
 [!code-csharp[System.Single.ToString#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Single.ToString/CS/ToString1.cs#3)]
 [!code-vb[System.Single.ToString#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Single.ToString/VB/ToString1.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException"><paramref name="format" /> no es válido.</exception>
        <altmember cref="M:System.Single.Parse(System.String)" />
        <altmember cref="T:System.String" />
        <related type="Article" href="~/docs/standard/base-types/formatting-types.md">Aplicar formato a tipos en .NET</related>
        <related type="Article" href="~/docs/standard/base-types/how-to-pad-a-number-with-leading-zeros.md">Cómo: Rellenar un número con ceros iniciales</related>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public string ToString (string format, IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string ToString(string format, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.ToString(System.String,System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToString (format As String, provider As IFormatProvider) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ ToString(System::String ^ format, IFormatProvider ^ provider);" />
      <MemberSignature Language="F#" Value="override this.ToString : string * IFormatProvider -&gt; string" Usage="single.ToString (format, provider)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IFormattable.ToString(System.String,System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="format">Cadena de formato numérico.</param>
        <param name="provider">Objeto que proporciona información de formato específica de la referencia cultural.</param>
        <summary>Convierte el valor numérico de esta instancia en su representación de cadena equivalente mediante el formato y la información de formato específica de la referencia cultural que se especificaran.</summary>
        <returns>Representación de cadena del valor de esta instancia, tal y como especifican <paramref name="format" /> y <paramref name="provider" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Single.ToString%28System.String%2CSystem.IFormatProvider%29> método formatos un <xref:System.Single> valor en un formato especificado de una referencia cultural especificada. Si desea utilizar la configuración de formato o la referencia cultural predeterminada, use las otras sobrecargas de los <xref:System.Single.ToString%2A> método, como se indica a continuación:  
  
|Para usar el formato|Para la referencia cultural|Use la sobrecarga|  
|-------------------|-----------------|----------------------|  
|Formato predeterminado ("G")|Referencia cultural de forma predeterminada (actual)|<xref:System.Single.ToString>|  
|Formato predeterminado ("G")|Una referencia cultural específica|<xref:System.Single.ToString%28System.IFormatProvider%29>|  
|Un formato concreto|Referencia cultural de forma predeterminada (actual)|<xref:System.Single.ToString%28System.String%29>|  
  
 El valor devuelto puede ser <xref:System.Globalization.NumberFormatInfo.PositiveInfinitySymbol%2A>, <xref:System.Globalization.NumberFormatInfo.NegativeInfinitySymbol%2A>, <xref:System.Globalization.NumberFormatInfo.NaNSymbol%2A>, o la representación de cadena del valor de la instancia actual, según lo especificado por `format`.  
  
 El `format` parámetro puede ser cualquier especificador de formato numérico estándar válido salvo D y X, así como cualquier combinación de especificadores de formato numérico personalizado. Si `format` es `null` o una cadena vacía, el valor devuelto para esta instancia está formateada con el especificador de formato numérico general ("G").  
  
 .NET Framework proporciona una amplia compatibilidad de formato, que se describe con más detalle en los temas de formato siguientes:  
  
-   Para obtener más información sobre los especificadores de formato numérico, vea [cadenas de formato numérico estándar](~/docs/standard/base-types/standard-numeric-format-strings.md) y [cadenas con formato numérico personalizado](~/docs/standard/base-types/custom-numeric-format-strings.md).  
  
-   Para obtener más información sobre el formato, vea [aplicar formato a tipos](~/docs/standard/base-types/formatting-types.md).  
  
 El `provider` parámetro es un <xref:System.IFormatProvider> implementación cuyo <xref:System.IFormatProvider.GetFormat%2A> método devuelve un <xref:System.Globalization.NumberFormatInfo> objeto. Por lo general, `provider` es un <xref:System.Globalization.CultureInfo> objeto o un <xref:System.Globalization.NumberFormatInfo> objeto. El `provider` parámetro proporciona información específica de la referencia cultural usada en el formato. Si `provider` es `null`, el valor devuelto se le da la <xref:System.Globalization.NumberFormatInfo> objeto para la referencia cultural actual.  
  
 De forma predeterminada, el valor devuelto solo contiene 7 dígitos de precisión, aunque internamente se mantiene un máximo de 9 dígitos. Si el valor de esta instancia tiene más de 7 dígitos <xref:System.Single.ToString%2A> devuelve <xref:System.Globalization.NumberFormatInfo.PositiveInfinitySymbol%2A> o <xref:System.Globalization.NumberFormatInfo.NegativeInfinitySymbol%2A> en lugar del número esperado. Si necesita más precisión, especifique `format` con la especificación de formato "G9", que siempre devuelve 9 dígitos de precisión o "R", que devuelve 7 dígitos si el número se puede representar con esa precisión o 9 dígitos si solo se puede representar el número con la máxima precisión.  
  
   
  
## Examples  
 El ejemplo siguiente se muestra un <xref:System.Single> valor con cada uno de los especificadores de formato numérico estándar compatibles para varias referencias culturales diferentes.  
  
 [!code-csharp[System.Single.ToString#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Single.ToString/CS/ToString1.cs#4)]
 [!code-vb[System.Single.ToString#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Single.ToString/VB/ToString1.vb#4)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Single.Parse(System.String)" />
        <altmember cref="T:System.String" />
        <related type="Article" href="~/docs/standard/base-types/formatting-types.md">Aplicar formato a tipos en .NET</related>
        <related type="Article" href="~/docs/standard/base-types/how-to-pad-a-number-with-leading-zeros.md">Cómo: Rellenar un número con ceros iniciales</related>
      </Docs>
    </Member>
    <Member MemberName="TryFormat">
      <MemberSignature Language="C#" Value="public bool TryFormat (Span&lt;char&gt; destination, out int charsWritten, ReadOnlySpan&lt;char&gt; format = null, IFormatProvider provider = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryFormat(valuetype System.Span`1&lt;char&gt; destination, [out] int32&amp; charsWritten, valuetype System.ReadOnlySpan`1&lt;char&gt; format, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.TryFormat(System.Span{System.Char},System.Int32@,System.ReadOnlySpan{System.Char},System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryFormat (destination As Span(Of Char), ByRef charsWritten As Integer, Optional format As ReadOnlySpan(Of Char) = null, Optional provider As IFormatProvider = null) As Boolean" />
      <MemberSignature Language="F#" Value="member this.TryFormat : Span&lt;char&gt; *  * ReadOnlySpan&lt;char&gt; * IFormatProvider -&gt; bool" Usage="single.TryFormat (destination, charsWritten, format, provider)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.Span&lt;System.Char&gt;" />
        <Parameter Name="charsWritten" Type="System.Int32" RefType="out" />
        <Parameter Name="format" Type="System.ReadOnlySpan&lt;System.Char&gt;" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="destination">To be added.</param>
        <param name="charsWritten">To be added.</param>
        <param name="format">To be added.</param>
        <param name="provider">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="TryParse">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Convierte la representación en forma de cadena de un número en el número de punto flotante de precisión sencilla equivalente. Un valor devuelto indica si la conversión se realizó correctamente o si se produjeron errores.</summary>
        <altmember cref="Overload:System.Single.Parse" />
      </Docs>
    </MemberGroup>
    <Member MemberName="TryParse">
      <MemberSignature Language="C#" Value="public static bool TryParse (ReadOnlySpan&lt;char&gt; s, out float result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryParse(valuetype System.ReadOnlySpan`1&lt;char&gt; s, [out] float32&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.TryParse(System.ReadOnlySpan{System.Char},System.Single@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryParse (s As ReadOnlySpan(Of Char), ByRef result As Single) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryParse(ReadOnlySpan&lt;char&gt; s, [Runtime::InteropServices::Out] float % result);" />
      <MemberSignature Language="F#" Value="static member TryParse : ReadOnlySpan&lt;char&gt; *  -&gt; bool" Usage="System.single.TryParse (s, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.ReadOnlySpan&lt;System.Char&gt;" />
        <Parameter Name="result" Type="System.Single" RefType="out" />
      </Parameters>
      <Docs>
        <param name="s">To be added.</param>
        <param name="result">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryParse">
      <MemberSignature Language="C#" Value="public static bool TryParse (string s, out float result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryParse(string s, [out] float32&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.TryParse(System.String,System.Single@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryParse (s As String, ByRef result As Single) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryParse(System::String ^ s, [Runtime::InteropServices::Out] float % result);" />
      <MemberSignature Language="F#" Value="static member TryParse : string *  -&gt; bool" Usage="System.single.TryParse (s, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="result" Type="System.Single" RefType="out" />
      </Parameters>
      <Docs>
        <param name="s">Cadena que representa un número que se va a convertir.</param>
        <param name="result">Cuando se devuelve este método, contiene el número de punto flotante de precisión sencilla equivalente al valor numérico o al símbolo contenido en <paramref name="s" /> si la conversión se realizó correctamente, o cero si no se realizó correctamente. La conversión no finaliza correctamente si el parámetro <paramref name="s" /> es <see langword="null" /> o <see cref="F:System.String.Empty" />, no es un número con formato válido o representa un número menor que <see cref="F:System.Single.MinValue" /> o mayor que <see cref="F:System.Single.MaxValue" />. Este parámetro se pasa sin inicializar; cualquier valor proporcionado originalmente en <paramref name="result" /> se sobrescribirá.</param>
        <summary>Convierte la representación en forma de cadena de un número en el número de punto flotante de precisión sencilla equivalente. Un valor devuelto indica si la conversión se realizó correctamente o si se produjeron errores.</summary>
        <returns><see langword="true" /> si <paramref name="s" /> se convirtió correctamente; en caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esta sobrecarga difiere el <xref:System.Single.Parse%28System.String%29?displayProperty=nameWithType> método devolviendo un valor booleano que indica si la operación de análisis se realizó correctamente en lugar de devolver el valor numérico analizado. Elimina la necesidad de usar el control de excepciones para probar una <xref:System.FormatException> en caso de que `s` no es válido y no puede analizarse correctamente.  
  
 El `s` parámetro puede contener <xref:System.Globalization.NumberFormatInfo.PositiveInfinitySymbol%2A>, <xref:System.Globalization.NumberFormatInfo.NegativeInfinitySymbol%2A>, <xref:System.Globalization.NumberFormatInfo.NaNSymbol%2A> (la comparación de cadenas distingue mayúsculas de minúsculas), o una cadena del formulario:  
  
 [ws][sign][integral-digits,]integral-digits[.[fractional-digits]][e[sign]exponential-digits][ws]  
  
 Los elementos entre corchetes son opcionales. En esta tabla se describe cada elemento.  
  
|Elemento|Descripción|  
|-------------|-----------------|  
|*ws*|Una serie de caracteres de espacio en blanco.|  
|*sign*|Un signo negativo o un símbolo de signo positivo.|  
|*dígitos enteros*|Una serie de caracteres numéricos comprendidos entre 0 y 9 que especifican la parte entera del número. Dígitos enteros pueden estar ausentes si hay dígitos fraccionarios.|  
|*,*|Un símbolo de separador de grupo específicas de referencias culturales.|  
|*.*|Un símbolo de separador de decimales de referencia cultural específica.|  
|*dígitos fraccionarios*|Una serie de caracteres numéricos comprendidos entre 0 y 9 que especifican la parte fraccionaria del número.|  
|*E*|Un letra mayúscula o minúscula carácter "e", que indica una notación exponencial (científica).|  
|*dígitos exponenciales*|Una serie de caracteres numéricos comprendidos entre 0 y 9 que especifican a un exponente.|  
  
 El `s` parámetro se interpreta mediante una combinación de la <xref:System.Globalization.NumberStyles.Float?displayProperty=nameWithType> y <xref:System.Globalization.NumberStyles.AllowThousands?displayProperty=nameWithType> marcas. Esto significa que ese espacio en blanco y miles se permiten separadores pero no símbolos de moneda. Para definir explícitamente los elementos (como símbolos de moneda, miles separadores y espacios en blanco) que pueden estar presentes en `s`, utilice el <xref:System.Single.TryParse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%2CSystem.Single%40%29> sobrecarga del método.  
  
 El `s` parámetro se analiza utilizando la información de formato en un <xref:System.Globalization.NumberFormatInfo> objeto que se inicializa para la referencia cultural actual del sistema. Para obtener más información, vea <xref:System.Globalization.NumberFormatInfo.CurrentInfo%2A?displayProperty=nameWithType>. Para analizar una cadena utilizando la información de algún otro formato especifica la referencia cultural, use el <xref:System.Single.TryParse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%2CSystem.Single%40%29> sobrecarga del método.  
  
 Normalmente, si se pasa el <xref:System.Single.TryParse%2A?displayProperty=nameWithType> método una cadena que se crea mediante una llamada a la <xref:System.Single.ToString%2A?displayProperty=nameWithType> método, el original <xref:System.Single> se devuelve el valor. Sin embargo, debido a una pérdida de precisión, los valores pueden no ser iguales.  
  
 Si se encuentra un separador en la `s` parámetro durante una operación de análisis y la divisa aplicable o número decimal y separadores de grupo son iguales, la operación de análisis supone que se trata de un separador decimal en lugar de un grupo separador. Para obtener más información acerca de los separadores, consulte <xref:System.Globalization.NumberFormatInfo.CurrencyDecimalSeparator%2A>, <xref:System.Globalization.NumberFormatInfo.NumberDecimalSeparator%2A>, <xref:System.Globalization.NumberFormatInfo.CurrencyGroupSeparator%2A>, y <xref:System.Globalization.NumberFormatInfo.NumberGroupSeparator%2A>.  
  
   
  
## Examples  
 En el ejemplo siguiente se usa el <xref:System.Single.TryParse%28System.String%2CSystem.Single%40%29> método para convertir las representaciones de cadena de valores numéricos para <xref:System.Single> valores. Se supone que en-US es la referencia cultural actual.  
  
 [!code-csharp[System.Single.TryParse#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.single.tryparse/cs/tryparse1.cs#1)]
 [!code-vb[System.Single.TryParse#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.single.tryparse/vb/tryparse1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Single.Parse(System.String)" />
        <altmember cref="M:System.Single.ToString" />
        <related type="Article" href="~/docs/standard/base-types/parsing-numeric.md">Analizar cadenas numéricas en .NET</related>
      </Docs>
    </Member>
    <Member MemberName="TryParse">
      <MemberSignature Language="C#" Value="public static bool TryParse (ReadOnlySpan&lt;char&gt; s, System.Globalization.NumberStyles style, IFormatProvider provider, out float result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryParse(valuetype System.ReadOnlySpan`1&lt;char&gt; s, valuetype System.Globalization.NumberStyles style, class System.IFormatProvider provider, [out] float32&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.TryParse(System.ReadOnlySpan{System.Char},System.Globalization.NumberStyles,System.IFormatProvider,System.Single@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryParse (s As ReadOnlySpan(Of Char), style As NumberStyles, provider As IFormatProvider, ByRef result As Single) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryParse(ReadOnlySpan&lt;char&gt; s, System::Globalization::NumberStyles style, IFormatProvider ^ provider, [Runtime::InteropServices::Out] float % result);" />
      <MemberSignature Language="F#" Value="static member TryParse : ReadOnlySpan&lt;char&gt; * System.Globalization.NumberStyles * IFormatProvider *  -&gt; bool" Usage="System.single.TryParse (s, style, provider, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.ReadOnlySpan&lt;System.Char&gt;" />
        <Parameter Name="style" Type="System.Globalization.NumberStyles" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
        <Parameter Name="result" Type="System.Single" RefType="out" />
      </Parameters>
      <Docs>
        <param name="s">To be added.</param>
        <param name="style">To be added.</param>
        <param name="provider">To be added.</param>
        <param name="result">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryParse">
      <MemberSignature Language="C#" Value="public static bool TryParse (string s, System.Globalization.NumberStyles style, IFormatProvider provider, out float result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryParse(string s, valuetype System.Globalization.NumberStyles style, class System.IFormatProvider provider, [out] float32&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.TryParse(System.String,System.Globalization.NumberStyles,System.IFormatProvider,System.Single@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryParse (s As String, style As NumberStyles, provider As IFormatProvider, ByRef result As Single) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryParse(System::String ^ s, System::Globalization::NumberStyles style, IFormatProvider ^ provider, [Runtime::InteropServices::Out] float % result);" />
      <MemberSignature Language="F#" Value="static member TryParse : string * System.Globalization.NumberStyles * IFormatProvider *  -&gt; bool" Usage="System.single.TryParse (s, style, provider, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="style" Type="System.Globalization.NumberStyles" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
        <Parameter Name="result" Type="System.Single" RefType="out" />
      </Parameters>
      <Docs>
        <param name="s">Cadena que representa un número que se va a convertir.</param>
        <param name="style">Combinación bit a bit de valores de enumeración que indica el formato permitido de <paramref name="s" />. Un valor que se especifica de forma habitual es <see cref="F:System.Globalization.NumberStyles.Float" /> combinado con <see cref="F:System.Globalization.NumberStyles.AllowThousands" />.</param>
        <param name="provider">Objeto que proporciona información de formato específica de la referencia cultural acerca de <paramref name="s" />.</param>
        <param name="result">Cuando se devuelve este método, contiene el número de punto flotante de precisión sencilla equivalente al valor numérico o al símbolo contenido en <paramref name="s" /> si la conversión se realizó correctamente, o cero si no se realizó correctamente. Se produce un error en la conversión si el parámetro <paramref name="s" /> es <see langword="null" /> o <see cref="F:System.String.Empty" />, no está en un formato compatible con <paramref name="style" />, representa un número menor que <see cref="F:System.Single.MinValue" /> o mayor que <see cref="F:System.Single.MaxValue" />, o bien si <paramref name="style" /> no es una combinación válida de constantes enumeradas de <see cref="T:System.Globalization.NumberStyles" />. Este parámetro se pasa sin inicializar; cualquier valor proporcionado originalmente en <paramref name="result" /> se sobrescribirá.</param>
        <summary>Convierte la representación en forma de cadena de un número con un estilo y un formato específico de la referencia cultural especificados en el número de punto flotante de precisión sencilla equivalente. Un valor devuelto indica si la conversión se realizó correctamente o si se produjeron errores.</summary>
        <returns><see langword="true" /> si <paramref name="s" /> se convirtió correctamente; en caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esta sobrecarga difiere el <xref:System.Single.Parse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%29> método devolviendo un valor booleano que indica si la operación de análisis se realizó correctamente en lugar de devolver el valor numérico analizado. Elimina la necesidad de usar el control de excepciones para probar una <xref:System.FormatException> en caso de que `s` no es válido y no puede analizarse correctamente.  
  
 El `style` parámetro define el formato permitido de la `s` parámetro para la operación de análisis se realice correctamente. Debe ser una combinación de marcas de bits de la <xref:System.Globalization.NumberStyles> enumeración. La siguiente <xref:System.Globalization.NumberStyles> miembros no son compatibles:  
  
-   <xref:System.Globalization.NumberStyles.AllowHexSpecifier?displayProperty=nameWithType>  
  
-   <xref:System.Globalization.NumberStyles.HexNumber?displayProperty=nameWithType>  
  
 El `s` parámetro puede contener <xref:System.Globalization.NumberFormatInfo.PositiveInfinitySymbol%2A>, <xref:System.Globalization.NumberFormatInfo.NegativeInfinitySymbol%2A>, <xref:System.Globalization.NumberFormatInfo.NaNSymbol%2A> para la referencia cultural indicada por `provider`. Además, dependiendo del valor de `style`, el `s` parámetro puede incluir los siguientes elementos:  
  
 [ws] [$] [inicio de sesión] [dígitos enteros,] dígitos enteros [. dígitos fraccionarios] [e [inicio de sesión] dígitos exponenciales] [ws]  
  
 Los elementos de los corchetes ([ y ]) son opcionales. En esta tabla se describe cada elemento.  
  
|Elemento|Descripción|  
|-------------|-----------------|  
|*ws*|Espacio en blanco opcional. Pueden aparecer espacios en blanco al principio de `s` si `style` incluye la <xref:System.Globalization.NumberStyles.AllowLeadingWhite?displayProperty=nameWithType> marca. Puede aparecer al final de `s` si `style` incluye la <xref:System.Globalization.NumberStyles.AllowTrailingWhite?displayProperty=nameWithType> marca.|  
|*$*|Un símbolo de moneda de la referencia cultural específica. Su posición en la cadena viene definida por el <xref:System.Globalization.NumberFormatInfo.CurrencyNegativePattern%2A?displayProperty=nameWithType> o <xref:System.Globalization.NumberFormatInfo.CurrencyPositivePattern%2A?displayProperty=nameWithType> propiedades de la <xref:System.Globalization.NumberFormatInfo> objeto devuelto por la <xref:System.IFormatProvider.GetFormat%2A?displayProperty=nameWithType> método de la `provider` parámetro. Puede aparecer el símbolo de moneda en `s` si `style` incluye la <xref:System.Globalization.NumberStyles.AllowCurrencySymbol?displayProperty=nameWithType> marca.|  
|*sign*|Un signo opcional. El inicio de sesión puede aparecer al principio de `s` si `style` incluye la <xref:System.Globalization.NumberStyles.AllowLeadingSign?displayProperty=nameWithType> marca y puede aparecer al final de `s` si `style` incluye la <xref:System.Globalization.NumberStyles.AllowTrailingSign?displayProperty=nameWithType> marca. Se pueden utilizar paréntesis en `s` para indicar un valor negativo si `style` incluye la <xref:System.Globalization.NumberStyles.AllowParentheses?displayProperty=nameWithType> marca.|  
|*dígitos enteros*|Una serie de dígitos comprendidos del 0 al 9 que especifican la parte entera del número. Dígitos enteros pueden estar ausentes si hay dígitos fraccionarios.|  
|*,*|Específicas de referencias culturales miles símbolo de separador. Miles de la referencia cultural actual separador símbolo puede aparecer en `s` si `style` incluye la <xref:System.Globalization.NumberStyles.AllowThousands?displayProperty=nameWithType> marca.|  
|*.*|Un símbolo de separador de decimales de referencia cultural específica. Símbolo de separador decimal de la referencia cultural actual puede aparecer en `s` si `style` incluye la <xref:System.Globalization.NumberStyles.AllowDecimalPoint?displayProperty=nameWithType> marca.|  
|*dígitos fraccionarios*|Una serie de dígitos comprendidos del 0 al 9 que especifican la parte fraccionaria del número. Pueden aparecer dígitos fraccionarios en `s` si `style` incluye la <xref:System.Globalization.NumberStyles.AllowDecimalPoint?displayProperty=nameWithType> marca.|  
|*e*|El carácter e o E, que indica que `s` puede representar un número mediante notación exponencial. El `s` parámetro puede representar un número en notación exponencial si el estilo incluye la <xref:System.Globalization.NumberStyles.AllowExponent?displayProperty=nameWithType> marca.|  
|*dígitos exponenciales*|Una serie de dígitos comprendidos del 0 al 9 que especifican a un exponente.|  
  
> [!NOTE]
> Terminación NUL (u+0000) caracteres en `s` son ignoradas por la operación de análisis, independientemente del valor de la `style` argumento.

 Una cadena formada únicamente por dígitos (que corresponde a la <xref:System.Globalization.NumberStyles.None?displayProperty=nameWithType> estilo) siempre se analiza correctamente. Los restantes <xref:System.Globalization.NumberStyles?displayProperty=nameWithType> miembros controlan los elementos que pueden ser, pero no tienen que estar presentes en la cadena de entrada. La tabla siguiente se indica cómo individuales <xref:System.Globalization.NumberStyles> marcas afectan a los elementos que pueden estar presentes en `s`.  
  
|Valor NumberStyles|Elementos permitidos en s además de dígitos|  
|------------------------|---------------------------------------------------|  
|<xref:System.Globalization.NumberStyles.None>|El *dígitos enteros* sólo elemento.|  
|<xref:System.Globalization.NumberStyles.AllowDecimalPoint>|El elemento de lenguaje *.* y *dígitos fraccionarios* elementos.|  
|<xref:System.Globalization.NumberStyles.AllowExponent>|El `s` parámetro también puede utilizar la notación exponencial. Este marcador por sí solo admite valores en el formulario *dígitos enteros*E*dígitos exponenciales*; adicionales se necesitan los marcadores para analizar correctamente cadenas en notación exponencial con esos elementos como signos positivos o negativos y los símbolos de separador decimal.|  
|<xref:System.Globalization.NumberStyles.AllowLeadingWhite>|El *ws* elemento situado al principio de `s`.|  
|<xref:System.Globalization.NumberStyles.AllowTrailingWhite>|El *ws* elemento al final de `s`.|  
|<xref:System.Globalization.NumberStyles.AllowLeadingSign>|El *sesión* elemento situado al principio de `s`.|  
|<xref:System.Globalization.NumberStyles.AllowTrailingSign>|El *sesión* elemento al final de `s`.|  
|<xref:System.Globalization.NumberStyles.AllowParentheses>|El *sesión* elemento con la forma de paréntesis para delimitar el valor numérico.|  
|<xref:System.Globalization.NumberStyles.AllowThousands>|El *,* elemento.|  
|<xref:System.Globalization.NumberStyles.AllowCurrencySymbol>|El *$* elemento.|  
|<xref:System.Globalization.NumberStyles.Currency>|Todos. El `s` parámetro no puede representar un número hexadecimal o un número en notación exponencial.|  
|<xref:System.Globalization.NumberStyles.Float>|El *ws* elemento al principio o al final de `s`, *sesión* al principio de `s`y el *.* símbolo. El `s` parámetro también puede utilizar la notación exponencial.|  
|<xref:System.Globalization.NumberStyles.Number>|El `ws`, `sign`, miles separador (*,),* y separador decimal (*.*) elementos.|  
|<xref:System.Globalization.NumberStyles.Any>|Todos los estilos, excepto `s` no se puede representar un número hexadecimal.|  
  
 El `provider` parámetro es un <xref:System.IFormatProvider> implementación cuyo <xref:System.IFormatProvider.GetFormat%2A> método devuelve un <xref:System.Globalization.NumberFormatInfo> objeto que proporciona información de formato específica de la referencia cultural. Cuando el <xref:System.Single.TryParse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%2CSystem.Single%40%29> se invoca el método, llama a la `provider` del parámetro <xref:System.IFormatProvider.GetFormat%2A> método y le pasa un <xref:System.Type> objeto que representa el <xref:System.Globalization.NumberFormatInfo> tipo. El <xref:System.IFormatProvider.GetFormat%2A> método, a continuación, devuelve el <xref:System.Globalization.NumberFormatInfo> objeto que proporciona información sobre el formato de la `s` parámetro. Hay tres formas de usar el `provider` parámetro para proporcionar información de formato personalizado para la operación de análisis:  
  
-   Puede pasar un <xref:System.Globalization.CultureInfo> objeto que representa la referencia cultural que proporciona información de formato. Su <xref:System.Globalization.CultureInfo.GetFormat%2A> método devuelve el <xref:System.Globalization.NumberFormatInfo> objeto que proporciona información de formato numérico para esa referencia cultural.  
  
-   Puede pasar los datos reales <xref:System.Globalization.NumberFormatInfo> objeto que proporciona información de formato numérico. (Su implementación de <xref:System.Globalization.NumberFormatInfo.GetFormat%2A> simplemente devuelve a sí mismo.)  
  
-   Puede pasar un objeto personalizado que implementa <xref:System.IFormatProvider>. Su <xref:System.IFormatProvider.GetFormat%2A> crea una instancia de método y devuelve el <xref:System.Globalization.NumberFormatInfo> objeto que proporciona información de formato.  
  
 Si `provider` es `null`, el formato de `s` se interpreta basándose en la <xref:System.Globalization.NumberFormatInfo> objeto de la referencia cultural actual.  
  
 Si se encuentra un separador en la `s` parámetro durante una operación de análisis y la divisa aplicable o número decimal y separadores de grupo son iguales, la operación de análisis supone que se trata de un separador decimal en lugar de un grupo separador. Para obtener más información acerca de los separadores, consulte <xref:System.Globalization.NumberFormatInfo.CurrencyDecimalSeparator%2A>, <xref:System.Globalization.NumberFormatInfo.NumberDecimalSeparator%2A>, <xref:System.Globalization.NumberFormatInfo.CurrencyGroupSeparator%2A>, y <xref:System.Globalization.NumberFormatInfo.NumberGroupSeparator%2A>.  
  
   
  
## Examples  
 En el ejemplo siguiente se muestra el uso de la <xref:System.Single.TryParse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%2CSystem.Single%40%29?displayProperty=nameWithType> método para analizar la representación de cadena de números que tienen un estilo determinado y se da formato usando las convenciones de una referencia cultural determinada.  
  
 [!code-csharp[System.Single.TryParse#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.single.tryparse/cs/tryparse1.cs#2)]
 [!code-vb[System.Single.TryParse#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.single.tryparse/vb/tryparse1.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="style" /> no es un valor <see cref="T:System.Globalization.NumberStyles" />.  
  
O bien 
 <paramref name="style" /> es el valor <see cref="F:System.Globalization.NumberStyles.AllowHexSpecifier" />.</exception>
        <altmember cref="M:System.Single.Parse(System.String)" />
        <altmember cref="M:System.Single.ToString" />
        <related type="Article" href="~/docs/standard/base-types/parsing-numeric.md">Analizar cadenas numéricas en .NET</related>
      </Docs>
    </Member>
  </Members>
</Type>