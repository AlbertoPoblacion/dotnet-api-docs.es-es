<Type Name="Math" FullName="System.Math">
  <TypeSignature Language="C#" Value="public static class Math" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract sealed beforefieldinit Math extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Math" />
  <TypeSignature Language="VB.NET" Value="Public Class Math" />
  <TypeSignature Language="C++ CLI" Value="public ref class Math abstract sealed" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime.Extensions</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary><span data-ttu-id="240c7-101">Proporciona constantes y métodos estáticos para operaciones trigonométricas, logarítmicas y otras funciones matemáticas comunes.</span><span class="sxs-lookup"><span data-stu-id="240c7-101">Provides constants and static methods for trigonometric, logarithmic, and other common mathematical functions.</span></span></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="240c7-102">El ejemplo siguiente utiliza varias funciones matemáticas y trigonométricas de la <xref:System.Math> clase para calcular los ángulos internos de un trapezoide.</span><span class="sxs-lookup"><span data-stu-id="240c7-102">The following example uses several mathematical and trigonometric functions from the <xref:System.Math> class to calculate the inner angles of a trapezoid.</span></span>  
  
 [!code-cpp[MathSample#1](~/samples/snippets/cpp/VS_Snippets_CLR/MathSample/CPP/mathsample.cpp#1)]
 [!code-csharp[MathSample#1](~/samples/snippets/csharp/VS_Snippets_CLR/MathSample/CS/mathsample.cs#1)]
 [!code-vb[MathSample#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/MathSample/VB/mathsample.vb#1)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <MemberGroup MemberName="Abs">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="240c7-103">Devuelve el valor absoluto de un número especificado.</span><span class="sxs-lookup"><span data-stu-id="240c7-103">Returns the absolute value of a specified number.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Abs">
      <MemberSignature Language="C#" Value="public static decimal Abs (decimal value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Decimal Abs(valuetype System.Decimal value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Abs(System.Decimal)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Abs (value As Decimal) As Decimal" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Decimal Abs(System::Decimal value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Decimal" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="240c7-104">Número mayor o igual que <see cref="F:System.Decimal.MinValue" />, pero menor o igual que <see cref="F:System.Decimal.MaxValue" />.</span><span class="sxs-lookup"><span data-stu-id="240c7-104">A number that is greater than or equal to <see cref="F:System.Decimal.MinValue" />, but less than or equal to <see cref="F:System.Decimal.MaxValue" />.</span></span></param>
        <summary><span data-ttu-id="240c7-105">Devuelve el valor absoluto de un número <see cref="T:System.Decimal" />.</span><span class="sxs-lookup"><span data-stu-id="240c7-105">Returns the absolute value of a <see cref="T:System.Decimal" /> number.</span></span></summary>
        <returns><span data-ttu-id="240c7-106">Número decimal, x, tal que 0 ≤ x ≤<see cref="F:System.Decimal.MaxValue" />.</span><span class="sxs-lookup"><span data-stu-id="240c7-106">A decimal number, x, such that 0 ≤ x ≤<see cref="F:System.Decimal.MaxValue" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="240c7-107">El valor absoluto de un <xref:System.Decimal> es su valor numérico sin signo.</span><span class="sxs-lookup"><span data-stu-id="240c7-107">The absolute value of a <xref:System.Decimal> is its numeric value without its sign.</span></span> <span data-ttu-id="240c7-108">Por ejemplo, el valor absoluto de 1.2 y -1,2 es 1.2.</span><span class="sxs-lookup"><span data-stu-id="240c7-108">For example, the absolute value of both 1.2 and -1.2 is 1.2.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="240c7-109">En el ejemplo siguiente se usa el <xref:System.Math.Abs%28System.Decimal%29> método para obtener el valor absoluto de un número de <xref:System.Decimal> valores.</span><span class="sxs-lookup"><span data-stu-id="240c7-109">The following example uses the <xref:System.Math.Abs%28System.Decimal%29> method to get the absolute value of a number of <xref:System.Decimal> values.</span></span>  
  
 [!code-csharp[System.Math.Abs#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Math.Abs/cs/Abs1.cs#1)]
 [!code-vb[System.Math.Abs#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Math.Abs/vb/Abs1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Abs">
      <MemberSignature Language="C#" Value="public static double Abs (double value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Abs(float64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Abs(System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Abs (value As Double) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double Abs(double value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="240c7-110">Número mayor o igual que <see cref="F:System.Double.MinValue" />, pero menor o igual que <see cref="F:System.Double.MaxValue" />.</span><span class="sxs-lookup"><span data-stu-id="240c7-110">A number that is greater than or equal to <see cref="F:System.Double.MinValue" />, but less than or equal to <see cref="F:System.Double.MaxValue" />.</span></span></param>
        <summary><span data-ttu-id="240c7-111">Devuelve el valor absoluto de un número de punto flotante de precisión doble.</span><span class="sxs-lookup"><span data-stu-id="240c7-111">Returns the absolute value of a double-precision floating-point number.</span></span></summary>
        <returns><span data-ttu-id="240c7-112">Número de punto flotante de precisión doble, x, tal que 0 ≤ x ≤<see cref="F:System.Double.MaxValue" />.</span><span class="sxs-lookup"><span data-stu-id="240c7-112">A double-precision floating-point number, x, such that 0 ≤ x ≤<see cref="F:System.Double.MaxValue" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="240c7-113">El valor absoluto de un <xref:System.Double> es su valor numérico sin signo.</span><span class="sxs-lookup"><span data-stu-id="240c7-113">The absolute value of a <xref:System.Double> is its numeric value without its sign.</span></span> <span data-ttu-id="240c7-114">Por ejemplo, el valor absoluto de 1.2e03 y - 1.2e03 es 1.2e03.</span><span class="sxs-lookup"><span data-stu-id="240c7-114">For example, the absolute value of both 1.2e03 and -1.2e03 is 1.2e03.</span></span>  
  
 <span data-ttu-id="240c7-115">Si `value` es igual a <xref:System.Double.NegativeInfinity> o <xref:System.Double.PositiveInfinity>, el valor devuelto es <xref:System.Double.PositiveInfinity>.</span><span class="sxs-lookup"><span data-stu-id="240c7-115">If `value` is equal to <xref:System.Double.NegativeInfinity> or <xref:System.Double.PositiveInfinity>, the return value is <xref:System.Double.PositiveInfinity>.</span></span> <span data-ttu-id="240c7-116">Si `value` es igual a <xref:System.Double.NaN>, el valor devuelto es <xref:System.Double.NaN>.</span><span class="sxs-lookup"><span data-stu-id="240c7-116">If `value` is equal to <xref:System.Double.NaN>, the return value is <xref:System.Double.NaN>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="240c7-117">En el ejemplo siguiente se usa el <xref:System.Math.Abs%28System.Double%29> método para obtener el valor absoluto de un número de <xref:System.Double> valores.</span><span class="sxs-lookup"><span data-stu-id="240c7-117">The following example uses the <xref:System.Math.Abs%28System.Double%29> method to get the absolute value of a number of <xref:System.Double> values.</span></span>  
  
 [!code-csharp[System.Math.Abs#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Math.Abs/cs/abs2.cs#2)]
 [!code-vb[System.Math.Abs#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Math.Abs/vb/abs2.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Abs">
      <MemberSignature Language="C#" Value="public static short Abs (short value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int16 Abs(int16 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Abs(System.Int16)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Abs (value As Short) As Short" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static short Abs(short value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int16" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="240c7-118">Número mayor que <see cref="F:System.Int16.MinValue" />, pero menor o igual que <see cref="F:System.Int16.MaxValue" />.</span><span class="sxs-lookup"><span data-stu-id="240c7-118">A number that is greater than <see cref="F:System.Int16.MinValue" />, but less than or equal to <see cref="F:System.Int16.MaxValue" />.</span></span></param>
        <summary><span data-ttu-id="240c7-119">Devuelve el valor absoluto de un entero de 16 bits con signo.</span><span class="sxs-lookup"><span data-stu-id="240c7-119">Returns the absolute value of a 16-bit signed integer.</span></span></summary>
        <returns><span data-ttu-id="240c7-120">Número entero de 16 bits con signo, x, tal que 0 ≤ x ≤<see cref="F:System.Int16.MaxValue" />.</span><span class="sxs-lookup"><span data-stu-id="240c7-120">A 16-bit signed integer, x, such that 0 ≤ x ≤<see cref="F:System.Int16.MaxValue" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="240c7-121">El valor absoluto de un <xref:System.Int16> es su valor numérico sin signo.</span><span class="sxs-lookup"><span data-stu-id="240c7-121">The absolute value of an <xref:System.Int16> is its numeric value without its sign.</span></span> <span data-ttu-id="240c7-122">Por ejemplo, el valor absoluto de 123 y-123 es 123.</span><span class="sxs-lookup"><span data-stu-id="240c7-122">For example, the absolute value of both 123 and -123 is 123.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="240c7-123">En el ejemplo siguiente se usa el <xref:System.Math.Abs%28System.Int16%29> método para obtener el valor absoluto de un número de <xref:System.Int16> valores.</span><span class="sxs-lookup"><span data-stu-id="240c7-123">The following example uses the <xref:System.Math.Abs%28System.Int16%29> method to get the absolute value of a number of <xref:System.Int16> values.</span></span>  
  
 [!code-csharp[System.Math.Abs#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Math.Abs/cs/abs3.cs#3)]
 [!code-vb[System.Math.Abs#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Math.Abs/vb/abs3.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException">
          <span data-ttu-id="240c7-124"><paramref name="value" /> es igual que <see cref="F:System.Int16.MinValue" />.</span><span class="sxs-lookup"><span data-stu-id="240c7-124"><paramref name="value" /> equals <see cref="F:System.Int16.MinValue" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Abs">
      <MemberSignature Language="C#" Value="public static int Abs (int value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Abs(int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Abs(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Abs (value As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Abs(int value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="240c7-125">Número mayor que <see cref="F:System.Int32.MinValue" />, pero menor o igual que <see cref="F:System.Int32.MaxValue" />.</span><span class="sxs-lookup"><span data-stu-id="240c7-125">A number that is greater than <see cref="F:System.Int32.MinValue" />, but less than or equal to <see cref="F:System.Int32.MaxValue" />.</span></span></param>
        <summary><span data-ttu-id="240c7-126">Devuelve el valor absoluto de un entero de 32 bits con signo.</span><span class="sxs-lookup"><span data-stu-id="240c7-126">Returns the absolute value of a 32-bit signed integer.</span></span></summary>
        <returns><span data-ttu-id="240c7-127">Número entero de 32 bits con signo, x, tal que 0 ≤ x ≤<see cref="F:System.Int32.MaxValue" />.</span><span class="sxs-lookup"><span data-stu-id="240c7-127">A 32-bit signed integer, x, such that 0 ≤ x ≤<see cref="F:System.Int32.MaxValue" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="240c7-128">El valor absoluto de un <xref:System.Int32> es su valor numérico sin signo.</span><span class="sxs-lookup"><span data-stu-id="240c7-128">The absolute value of an <xref:System.Int32> is its numeric value without its sign.</span></span> <span data-ttu-id="240c7-129">Por ejemplo, el valor absoluto de 123 y-123 es 123.</span><span class="sxs-lookup"><span data-stu-id="240c7-129">For example, the absolute value of both 123 and -123 is 123.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="240c7-130">En el ejemplo siguiente se usa el <xref:System.Math.Abs%28System.Int32%29> método para obtener el valor absoluto de un número de <xref:System.Int32> valores.</span><span class="sxs-lookup"><span data-stu-id="240c7-130">The following example uses the <xref:System.Math.Abs%28System.Int32%29> method to get the absolute value of a number of <xref:System.Int32> values.</span></span>  
  
 [!code-csharp[System.Math.Abs#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Math.Abs/cs/abs4.cs#4)]
 [!code-vb[System.Math.Abs#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Math.Abs/vb/abs4.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException">
          <span data-ttu-id="240c7-131"><paramref name="value" /> es igual que <see cref="F:System.Int32.MinValue" />.</span><span class="sxs-lookup"><span data-stu-id="240c7-131"><paramref name="value" /> equals <see cref="F:System.Int32.MinValue" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Abs">
      <MemberSignature Language="C#" Value="public static long Abs (long value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 Abs(int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Abs(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Abs (value As Long) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static long Abs(long value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="240c7-132">Número mayor que <see cref="F:System.Int64.MinValue" />, pero menor o igual que <see cref="F:System.Int64.MaxValue" />.</span><span class="sxs-lookup"><span data-stu-id="240c7-132">A number that is greater than <see cref="F:System.Int64.MinValue" />, but less than or equal to <see cref="F:System.Int64.MaxValue" />.</span></span></param>
        <summary><span data-ttu-id="240c7-133">Devuelve el valor absoluto de un entero de 64 bits con signo.</span><span class="sxs-lookup"><span data-stu-id="240c7-133">Returns the absolute value of a 64-bit signed integer.</span></span></summary>
        <returns><span data-ttu-id="240c7-134">Número entero de 64 bits con signo, x, tal que 0 ≤ x ≤<see cref="F:System.Int64.MaxValue" />.</span><span class="sxs-lookup"><span data-stu-id="240c7-134">A 64-bit signed integer, x, such that 0 ≤ x ≤<see cref="F:System.Int64.MaxValue" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="240c7-135">El valor absoluto de un <xref:System.Int64> es su valor numérico sin signo.</span><span class="sxs-lookup"><span data-stu-id="240c7-135">The absolute value of an <xref:System.Int64> is its numeric value without its sign.</span></span> <span data-ttu-id="240c7-136">Por ejemplo, el valor absoluto de 123 y-123 es 123.</span><span class="sxs-lookup"><span data-stu-id="240c7-136">For example, the absolute value of both 123 and -123 is 123.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="240c7-137">En el ejemplo siguiente se usa el <xref:System.Math.Abs%28System.Int64%29> método para obtener el valor absoluto de un número de <xref:System.Int64> valores.</span><span class="sxs-lookup"><span data-stu-id="240c7-137">The following example uses the <xref:System.Math.Abs%28System.Int64%29> method to get the absolute value of a number of <xref:System.Int64> values.</span></span>  
  
 [!code-csharp[System.Math.Abs#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Math.Abs/cs/abs5.cs#5)]
 [!code-vb[System.Math.Abs#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Math.Abs/vb/abs5.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException">
          <span data-ttu-id="240c7-138"><paramref name="value" /> es igual que <see cref="F:System.Int64.MinValue" />.</span><span class="sxs-lookup"><span data-stu-id="240c7-138"><paramref name="value" /> equals <see cref="F:System.Int64.MinValue" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Abs">
      <MemberSignature Language="C#" Value="public static sbyte Abs (sbyte value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int8 Abs(int8 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Abs(System.SByte)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Abs (value As SByte) As SByte" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::SByte Abs(System::SByte value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.SByte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.SByte" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="240c7-139">Número mayor que <see cref="F:System.SByte.MinValue" />, pero menor o igual que <see cref="F:System.SByte.MaxValue" />.</span><span class="sxs-lookup"><span data-stu-id="240c7-139">A number that is greater than <see cref="F:System.SByte.MinValue" />, but less than or equal to <see cref="F:System.SByte.MaxValue" />.</span></span></param>
        <summary><span data-ttu-id="240c7-140">Devuelve el valor absoluto de un entero de 8 bits con signo.</span><span class="sxs-lookup"><span data-stu-id="240c7-140">Returns the absolute value of an 8-bit signed integer.</span></span></summary>
        <returns><span data-ttu-id="240c7-141">Número entero de 8 bits con signo, x, tal que 0 ≤ x ≤<see cref="F:System.SByte.MaxValue" />.</span><span class="sxs-lookup"><span data-stu-id="240c7-141">An 8-bit signed integer, x, such that 0 ≤ x ≤<see cref="F:System.SByte.MaxValue" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="240c7-142">El valor absoluto de un byte con signo es su valor numérico sin signo.</span><span class="sxs-lookup"><span data-stu-id="240c7-142">The absolute value of a signed byte is its numeric value without its sign.</span></span> <span data-ttu-id="240c7-143">Por ejemplo, el valor absoluto de 12 y -12 es 12.</span><span class="sxs-lookup"><span data-stu-id="240c7-143">For example, the absolute value of both 12 and -12 is 12.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="240c7-144">En el ejemplo siguiente se usa el <xref:System.Math.Abs%28System.SByte%29> método para obtener el valor absoluto de un número de <xref:System.SByte> valores.</span><span class="sxs-lookup"><span data-stu-id="240c7-144">The following example uses the <xref:System.Math.Abs%28System.SByte%29> method to get the absolute value of a number of <xref:System.SByte> values.</span></span>  
  
 [!code-csharp[System.Math.Abs#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Math.Abs/cs/abs6.cs#6)]
 [!code-vb[System.Math.Abs#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Math.Abs/vb/abs6.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException">
          <span data-ttu-id="240c7-145"><paramref name="value" /> es igual que <see cref="F:System.SByte.MinValue" />.</span><span class="sxs-lookup"><span data-stu-id="240c7-145"><paramref name="value" /> equals <see cref="F:System.SByte.MinValue" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Abs">
      <MemberSignature Language="C#" Value="public static float Abs (float value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 Abs(float32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Abs(System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Abs (value As Single) As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static float Abs(float value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="240c7-146">Número mayor o igual que <see cref="F:System.Single.MinValue" />, pero menor o igual que <see cref="F:System.Single.MaxValue" />.</span><span class="sxs-lookup"><span data-stu-id="240c7-146">A number that is greater than or equal to <see cref="F:System.Single.MinValue" />, but less than or equal to <see cref="F:System.Single.MaxValue" />.</span></span></param>
        <summary><span data-ttu-id="240c7-147">Devuelve el valor absoluto de un número de punto flotante de precisión sencilla.</span><span class="sxs-lookup"><span data-stu-id="240c7-147">Returns the absolute value of a single-precision floating-point number.</span></span></summary>
        <returns><span data-ttu-id="240c7-148">Número de punto flotante de precisión sencilla, x, tal que 0 ≤ x ≤<see cref="F:System.Single.MaxValue" />.</span><span class="sxs-lookup"><span data-stu-id="240c7-148">A single-precision floating-point number, x, such that 0 ≤ x ≤<see cref="F:System.Single.MaxValue" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="240c7-149">El valor absoluto de un <xref:System.Single> es su valor numérico sin signo.</span><span class="sxs-lookup"><span data-stu-id="240c7-149">The absolute value of a <xref:System.Single> is its numeric value without its sign.</span></span> <span data-ttu-id="240c7-150">Por ejemplo, el valor absoluto de ambos 1.2e-03 y - 1.2e03 es 1.2e03.</span><span class="sxs-lookup"><span data-stu-id="240c7-150">For example, the absolute value of both 1.2e-03 and -1.2e03 is 1.2e03.</span></span>  
  
 <span data-ttu-id="240c7-151">Si `value` es igual a <xref:System.Single.NegativeInfinity> o <xref:System.Single.PositiveInfinity>, el valor devuelto es <xref:System.Single.PositiveInfinity>.</span><span class="sxs-lookup"><span data-stu-id="240c7-151">If `value` is equal to <xref:System.Single.NegativeInfinity> or <xref:System.Single.PositiveInfinity>, the return value is <xref:System.Single.PositiveInfinity>.</span></span> <span data-ttu-id="240c7-152">Si `value` es igual a <xref:System.Single.NaN>, el valor devuelto es <xref:System.Single.NaN>.</span><span class="sxs-lookup"><span data-stu-id="240c7-152">If `value` is equal to <xref:System.Single.NaN>, the return value is <xref:System.Single.NaN>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="240c7-153">En el ejemplo siguiente se usa el <xref:System.Math.Abs%28System.Single%29> método para obtener el valor absoluto de un número de <xref:System.Single> valores.</span><span class="sxs-lookup"><span data-stu-id="240c7-153">The following example uses the <xref:System.Math.Abs%28System.Single%29> method to get the absolute value of a number of <xref:System.Single> values.</span></span>  
  
 [!code-csharp[System.Math.Abs#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Math.Abs/cs/abs7.cs#7)]
 [!code-vb[System.Math.Abs#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Math.Abs/vb/abs7.vb#7)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Acos">
      <MemberSignature Language="C#" Value="public static double Acos (double d);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Acos(float64 d) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Acos(System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Acos (d As Double) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double Acos(double d);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="d"><span data-ttu-id="240c7-154">Número que representa un coseno, donde <c>d</c> debe ser mayor o igual que -1 y menor o igual que 1.</span><span class="sxs-lookup"><span data-stu-id="240c7-154">A number representing a cosine, where <c>d</c> must be greater than or equal to -1, but less than or equal to 1.</span></span></param>
        <summary><span data-ttu-id="240c7-155">Devuelve el ángulo cuyo coseno es el número especificado.</span><span class="sxs-lookup"><span data-stu-id="240c7-155">Returns the angle whose cosine is the specified number.</span></span></summary>
        <returns><span data-ttu-id="240c7-156">Ángulo, θ, medido en radianes, como 0 ≤θ≤π.</span><span class="sxs-lookup"><span data-stu-id="240c7-156">An angle, θ, measured in radians, such that 0 ≤θ≤π</span></span>  
  
 <span data-ttu-id="240c7-157">O bien</span><span class="sxs-lookup"><span data-stu-id="240c7-157">-or-</span></span>  
  
 <span data-ttu-id="240c7-158"><see cref="F:System.Double.NaN" /> si <paramref name="d" /> &lt; -1 o <paramref name="d" /> &gt; 1 o <paramref name="d" /> es igual que <see cref="F:System.Double.NaN" />.</span><span class="sxs-lookup"><span data-stu-id="240c7-158"><see cref="F:System.Double.NaN" /> if <paramref name="d" /> &lt; -1 or <paramref name="d" /> &gt; 1 or <paramref name="d" /> equals <see cref="F:System.Double.NaN" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="240c7-159">Multiplique el valor devuelto por 180 /<xref:System.Math.PI?displayProperty=nameWithType> para convertir de radianes a grados.</span><span class="sxs-lookup"><span data-stu-id="240c7-159">Multiply the return value by 180/<xref:System.Math.PI?displayProperty=nameWithType> to convert from radians to degrees.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="240c7-160">En el ejemplo siguiente se usa el <xref:System.Math.Acos%2A> método para ayudar en el cálculo de los ángulos internos de un trapezoide determinado.</span><span class="sxs-lookup"><span data-stu-id="240c7-160">The following example uses the <xref:System.Math.Acos%2A> method to assist in the computation of the inner angles of a given trapezoid.</span></span>  
  
 [!code-cpp[MathSample#1](~/samples/snippets/cpp/VS_Snippets_CLR/MathSample/CPP/mathsample.cpp#1)]
 [!code-csharp[MathSample#1](~/samples/snippets/csharp/VS_Snippets_CLR/MathSample/CS/mathsample.cs#1)]
 [!code-vb[MathSample#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/MathSample/VB/mathsample.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Asin">
      <MemberSignature Language="C#" Value="public static double Asin (double d);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Asin(float64 d) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Asin(System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Asin (d As Double) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double Asin(double d);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="d"><span data-ttu-id="240c7-161">Número que representa un seno, donde <c>d</c> debe ser mayor o igual que -1 y menor o igual que 1.</span><span class="sxs-lookup"><span data-stu-id="240c7-161">A number representing a sine, where <c>d</c> must be greater than or equal to -1, but less than or equal to 1.</span></span></param>
        <summary><span data-ttu-id="240c7-162">Devuelve el ángulo cuyo seno es el número especificado.</span><span class="sxs-lookup"><span data-stu-id="240c7-162">Returns the angle whose sine is the specified number.</span></span></summary>
        <returns><span data-ttu-id="240c7-163">Ángulo, θ, medido en radianes, como -π/2 ≤θ≤π/2.</span><span class="sxs-lookup"><span data-stu-id="240c7-163">An angle, θ, measured in radians, such that -π/2 ≤θ≤π/2</span></span>  
  
 <span data-ttu-id="240c7-164">O bien</span><span class="sxs-lookup"><span data-stu-id="240c7-164">-or-</span></span>  
  
 <span data-ttu-id="240c7-165"><see cref="F:System.Double.NaN" /> si <paramref name="d" /> &lt; -1 o <paramref name="d" /> &gt; 1 o <paramref name="d" /> es igual que <see cref="F:System.Double.NaN" />.</span><span class="sxs-lookup"><span data-stu-id="240c7-165"><see cref="F:System.Double.NaN" /> if <paramref name="d" /> &lt; -1 or <paramref name="d" /> &gt; 1 or <paramref name="d" /> equals <see cref="F:System.Double.NaN" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="240c7-166">Un valor devuelto positivo representa un ángulo ascendente desde el eje x; un valor devuelto negativo representa un ángulo de las agujas del reloj.</span><span class="sxs-lookup"><span data-stu-id="240c7-166">A positive return value represents a counterclockwise angle from the x-axis; a negative return value represents a clockwise angle.</span></span>  
  
 <span data-ttu-id="240c7-167">Multiplique el valor devuelto por 180 /<xref:System.Math.PI?displayProperty=nameWithType> para convertir de radianes a grados.</span><span class="sxs-lookup"><span data-stu-id="240c7-167">Multiply the return value by 180/<xref:System.Math.PI?displayProperty=nameWithType> to convert from radians to degrees.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="240c7-168">En el ejemplo siguiente se utiliza <xref:System.Math.Asin%2A> para ayudar en el cálculo de los ángulos internos de un trapezoide determinado.</span><span class="sxs-lookup"><span data-stu-id="240c7-168">The following example uses <xref:System.Math.Asin%2A> to assist in the computation of the inner angles of a given trapezoid.</span></span>  
  
 [!code-cpp[MathSample#1](~/samples/snippets/cpp/VS_Snippets_CLR/MathSample/CPP/mathsample.cpp#1)]
 [!code-csharp[MathSample#1](~/samples/snippets/csharp/VS_Snippets_CLR/MathSample/CS/mathsample.cs#1)]
 [!code-vb[MathSample#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/MathSample/VB/mathsample.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Atan">
      <MemberSignature Language="C#" Value="public static double Atan (double d);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Atan(float64 d) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Atan(System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Atan (d As Double) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double Atan(double d);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="d"><span data-ttu-id="240c7-169">Número que representa una tangente.</span><span class="sxs-lookup"><span data-stu-id="240c7-169">A number representing a tangent.</span></span></param>
        <summary><span data-ttu-id="240c7-170">Devuelve el ángulo cuya tangente corresponde al número especificado.</span><span class="sxs-lookup"><span data-stu-id="240c7-170">Returns the angle whose tangent is the specified number.</span></span></summary>
        <returns><span data-ttu-id="240c7-171">Ángulo, θ, medido en radianes, como -π/2 ≤θ≤π/2.</span><span class="sxs-lookup"><span data-stu-id="240c7-171">An angle, θ, measured in radians, such that -π/2 ≤θ≤π/2.</span></span>  
  
 <span data-ttu-id="240c7-172">O bien</span><span class="sxs-lookup"><span data-stu-id="240c7-172">-or-</span></span>  
  
 <span data-ttu-id="240c7-173"><see cref="F:System.Double.NaN" /> si <paramref name="d" /> es igual a <see cref="F:System.Double.NaN" />, -π/2 redondeado a precisión doble (-1,5707963267949) si <paramref name="d" /> es igual a <see cref="F:System.Double.NegativeInfinity" />, o π/2 redondeado a precisión doble (1,5707963267949) si <paramref name="d" /> es igual a <see cref="F:System.Double.PositiveInfinity" />.</span><span class="sxs-lookup"><span data-stu-id="240c7-173"><see cref="F:System.Double.NaN" /> if <paramref name="d" /> equals <see cref="F:System.Double.NaN" />, -π/2 rounded to double precision (-1.5707963267949) if <paramref name="d" /> equals <see cref="F:System.Double.NegativeInfinity" />, or π/2 rounded to double precision (1.5707963267949) if <paramref name="d" /> equals <see cref="F:System.Double.PositiveInfinity" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="240c7-174">Un valor devuelto positivo representa un ángulo ascendente desde el eje x; un valor devuelto negativo representa un ángulo de las agujas del reloj.</span><span class="sxs-lookup"><span data-stu-id="240c7-174">A positive return value represents a counterclockwise angle from the x-axis; a negative return value represents a clockwise angle.</span></span>  
  
 <span data-ttu-id="240c7-175">Multiplique el valor devuelto por 180 /<xref:System.Math.PI?displayProperty=nameWithType> para convertir de radianes a grados.</span><span class="sxs-lookup"><span data-stu-id="240c7-175">Multiply the return value by 180/<xref:System.Math.PI?displayProperty=nameWithType> to convert from radians to degrees.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="240c7-176">En el ejemplo siguiente se muestra cómo calcular el arco tangente de un valor y mostrarlo en la consola.</span><span class="sxs-lookup"><span data-stu-id="240c7-176">The following example demonstrates how to calculate the arctangent of a value and display it to the console.</span></span>  
  
 [!code-cpp[math.atanx#1](~/samples/snippets/cpp/VS_Snippets_CLR/math.atanx/CPP/atan.cpp#1)]
 [!code-csharp[math.atanx#1](~/samples/snippets/csharp/VS_Snippets_CLR/math.atanx/CS/atan.cs#1)]
 [!code-vb[math.atanx#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/math.atanx/VB/atan.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Atan2">
      <MemberSignature Language="C#" Value="public static double Atan2 (double y, double x);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Atan2(float64 y, float64 x) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Atan2(System.Double,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Atan2 (y As Double, x As Double) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double Atan2(double y, double x);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="y" Type="System.Double" />
        <Parameter Name="x" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="y"><span data-ttu-id="240c7-177">Coordenada Y de un punto.</span><span class="sxs-lookup"><span data-stu-id="240c7-177">The y coordinate of a point.</span></span></param>
        <param name="x"><span data-ttu-id="240c7-178">Coordenada X de un punto.</span><span class="sxs-lookup"><span data-stu-id="240c7-178">The x coordinate of a point.</span></span></param>
        <summary><span data-ttu-id="240c7-179">Devuelve el ángulo cuya tangente es el cociente de dos números especificados.</span><span class="sxs-lookup"><span data-stu-id="240c7-179">Returns the angle whose tangent is the quotient of two specified numbers.</span></span></summary>
        <returns><span data-ttu-id="240c7-180">Ángulo, θ, medido en radianes, como -π≤θ≤π, y tan(θ) = <paramref name="y" /> / <paramref name="x" />, donde (<paramref name="x" />, <paramref name="y" />) es un punto en el plano cartesiano.</span><span class="sxs-lookup"><span data-stu-id="240c7-180">An angle, θ, measured in radians, such that -π≤θ≤π, and tan(θ) = <paramref name="y" /> / <paramref name="x" />, where (<paramref name="x" />, <paramref name="y" />) is a point in the Cartesian plane.</span></span> <span data-ttu-id="240c7-181">Observe lo siguiente:</span><span class="sxs-lookup"><span data-stu-id="240c7-181">Observe the following:</span></span>  
  
-   <span data-ttu-id="240c7-182">Para (<paramref name="x" />, <paramref name="y" />) en el cuadrante 1, 0 &lt; θ &lt; π/2.</span><span class="sxs-lookup"><span data-stu-id="240c7-182">For (<paramref name="x" />, <paramref name="y" />) in quadrant 1, 0 &lt; θ &lt; π/2.</span></span>  
  
-   <span data-ttu-id="240c7-183">Para (<paramref name="x" />, <paramref name="y" />) en el cuadrante 2, π/2 &lt; θ≤π.</span><span class="sxs-lookup"><span data-stu-id="240c7-183">For (<paramref name="x" />, <paramref name="y" />) in quadrant 2, π/2 &lt; θ≤π.</span></span>  
  
-   <span data-ttu-id="240c7-184">Para (<paramref name="x" />, <paramref name="y" />) en el cuadrante 3, -π &lt; θ &lt; -π/2.</span><span class="sxs-lookup"><span data-stu-id="240c7-184">For (<paramref name="x" />, <paramref name="y" />) in quadrant 3, -π &lt; θ &lt; -π/2.</span></span>  
  
-   <span data-ttu-id="240c7-185">Para (<paramref name="x" />, <paramref name="y" />) en el cuadrante 4, -π/2 &lt; θ &lt; 0.</span><span class="sxs-lookup"><span data-stu-id="240c7-185">For (<paramref name="x" />, <paramref name="y" />) in quadrant 4, -π/2 &lt; θ &lt; 0.</span></span>  
  
 <span data-ttu-id="240c7-186">Para los puntos en los límites de los cuadrantes, el valor devuelto es el siguiente:</span><span class="sxs-lookup"><span data-stu-id="240c7-186">For points on the boundaries of the quadrants, the return value is the following:</span></span>  
  
-   <span data-ttu-id="240c7-187">Si y es 0 y x no es negativo, θ = 0.</span><span class="sxs-lookup"><span data-stu-id="240c7-187">If y is 0 and x is not negative, θ = 0.</span></span>  
  
-   <span data-ttu-id="240c7-188">Si y es 0 y x es negativo, θ = π.</span><span class="sxs-lookup"><span data-stu-id="240c7-188">If y is 0 and x is negative, θ = π.</span></span>  
  
-   <span data-ttu-id="240c7-189">Si y es positivo y x es 0, θ = π/2.</span><span class="sxs-lookup"><span data-stu-id="240c7-189">If y is positive and x is 0, θ = π/2.</span></span>  
  
-   <span data-ttu-id="240c7-190">Si y es negativo y el valor de x es 0, θ = -π/2.</span><span class="sxs-lookup"><span data-stu-id="240c7-190">If y is negative and x is 0, θ = -π/2.</span></span>  
  
-   <span data-ttu-id="240c7-191">Si y es 0 y x es 0, θ = 0.</span><span class="sxs-lookup"><span data-stu-id="240c7-191">If y is 0 and x is 0, θ = 0.</span></span>  
  
 <span data-ttu-id="240c7-192">Si <paramref name="x" /> o <paramref name="y" /> es <see cref="F:System.Double.NaN" /> o si <paramref name="x" /> y <paramref name="y" /> son <see cref="F:System.Double.PositiveInfinity" /> o <see cref="F:System.Double.NegativeInfinity" />, el método devuelve <see cref="F:System.Double.NaN" />.</span><span class="sxs-lookup"><span data-stu-id="240c7-192">If <paramref name="x" /> or <paramref name="y" /> is <see cref="F:System.Double.NaN" />, or if <paramref name="x" /> and <paramref name="y" /> are either <see cref="F:System.Double.PositiveInfinity" /> or <see cref="F:System.Double.NegativeInfinity" />, the method returns <see cref="F:System.Double.NaN" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="240c7-193">El valor devuelto es el ángulo en el plano cartesiano formado por el eje x y un vector a partir del origen (0,0) y termina en el punto, (x, y).</span><span class="sxs-lookup"><span data-stu-id="240c7-193">The return value is the angle in the Cartesian plane formed by the x-axis, and a vector starting from the origin, (0,0), and terminating at the point, (x,y).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="240c7-194">En el ejemplo siguiente se muestra cómo calcular el arco tangente de un ángulo y un vector.</span><span class="sxs-lookup"><span data-stu-id="240c7-194">The following example demonstrates how to calculate the arctangent of an angle and a vector.</span></span> <span data-ttu-id="240c7-195">El valor resultante se muestra en la consola.</span><span class="sxs-lookup"><span data-stu-id="240c7-195">The resulting value is displayed in the console.</span></span>  
  
 [!code-cpp[math.atanx#1](~/samples/snippets/cpp/VS_Snippets_CLR/math.atanx/CPP/atan.cpp#1)]
 [!code-csharp[math.atanx#1](~/samples/snippets/csharp/VS_Snippets_CLR/math.atanx/CS/atan.cs#1)]
 [!code-vb[math.atanx#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/math.atanx/VB/atan.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BigMul">
      <MemberSignature Language="C#" Value="public static long BigMul (int a, int b);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 BigMul(int32 a, int32 b) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.BigMul(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function BigMul (a As Integer, b As Integer) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static long BigMul(int a, int b);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="a" Type="System.Int32" />
        <Parameter Name="b" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="a"><span data-ttu-id="240c7-196">El primer número que se va a multiplicar.</span><span class="sxs-lookup"><span data-stu-id="240c7-196">The first number to multiply.</span></span></param>
        <param name="b"><span data-ttu-id="240c7-197">El segundo número que se va a multiplicar.</span><span class="sxs-lookup"><span data-stu-id="240c7-197">The second number to multiply.</span></span></param>
        <summary><span data-ttu-id="240c7-198">Calcula el producto completo de dos números de 32 bits.</span><span class="sxs-lookup"><span data-stu-id="240c7-198">Produces the full product of two 32-bit numbers.</span></span></summary>
        <returns><span data-ttu-id="240c7-199">Número que contiene el producto de los números especificados.</span><span class="sxs-lookup"><span data-stu-id="240c7-199">The number containing the product of the specified numbers.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="240c7-200">En el ejemplo siguiente se muestra el uso de la <xref:System.Math.BigMul%2A> método para calcular el producto de dos valores enteros.</span><span class="sxs-lookup"><span data-stu-id="240c7-200">The following example demonstrates the use of the <xref:System.Math.BigMul%2A> method to calculate the product of two integer values.</span></span>  
  
 [!code-cpp[math.bigmul#1](~/samples/snippets/cpp/VS_Snippets_CLR/math.bigmul/CPP/bigmul.cpp#1)]
 [!code-csharp[math.bigmul#1](~/samples/snippets/csharp/VS_Snippets_CLR/math.bigmul/CS/bigmul.cs#1)]
 [!code-vb[math.bigmul#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/math.bigmul/VB/bigmul.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Ceiling">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="240c7-201">Devuelve el menor valor integral mayor o igual que el número especificado.</span><span class="sxs-lookup"><span data-stu-id="240c7-201">Returns the smallest integral value greater than or equal to the specified number.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="240c7-202">El comportamiento de este método sigue el estándar IEEE 754, sección 4.</span><span class="sxs-lookup"><span data-stu-id="240c7-202">The behavior of this method follows IEEE Standard 754, section 4.</span></span> <span data-ttu-id="240c7-203">Este tipo de redondeo a veces se denomina redondeo hacia el infinito positivo.</span><span class="sxs-lookup"><span data-stu-id="240c7-203">This kind of rounding is sometimes called rounding toward positive infinity.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Ceiling">
      <MemberSignature Language="C#" Value="public static decimal Ceiling (decimal d);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Decimal Ceiling(valuetype System.Decimal d) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Ceiling(System.Decimal)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Ceiling (d As Decimal) As Decimal" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Decimal Ceiling(System::Decimal d);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d" Type="System.Decimal" />
      </Parameters>
      <Docs>
        <param name="d"><span data-ttu-id="240c7-204">Número decimal.</span><span class="sxs-lookup"><span data-stu-id="240c7-204">A decimal number.</span></span></param>
        <summary><span data-ttu-id="240c7-205">Devuelve el valor integral más pequeño que es mayor o igual que el número decimal especificado.</span><span class="sxs-lookup"><span data-stu-id="240c7-205">Returns the smallest integral value that is greater than or equal to the specified decimal number.</span></span></summary>
        <returns><span data-ttu-id="240c7-206">Valor entero más pequeño que es mayor o igual que <paramref name="d" />.</span><span class="sxs-lookup"><span data-stu-id="240c7-206">The smallest integral value that is greater than or equal to <paramref name="d" />.</span></span> <span data-ttu-id="240c7-207">Tenga en cuenta que este método devuelve un valor <see cref="T:System.Decimal" /> en lugar de un tipo entero.</span><span class="sxs-lookup"><span data-stu-id="240c7-207">Note that this method returns a <see cref="T:System.Decimal" /> instead of an integral type.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="240c7-208">El comportamiento de este método sigue el estándar IEEE 754, sección 4.</span><span class="sxs-lookup"><span data-stu-id="240c7-208">The behavior of this method follows IEEE Standard 754, section 4.</span></span> <span data-ttu-id="240c7-209">Este tipo de redondeo a veces se denomina redondeo hacia el infinito positivo.</span><span class="sxs-lookup"><span data-stu-id="240c7-209">This kind of rounding is sometimes called rounding toward positive infinity.</span></span> <span data-ttu-id="240c7-210">En otras palabras, si `d` es positivo, la presencia de las causas de cualquier componente de fracción `d` se redondea al entero más alto siguiente.</span><span class="sxs-lookup"><span data-stu-id="240c7-210">In other words, if `d` is positive, the presence of any fractional component causes `d` to be rounded to the next highest integer.</span></span> <span data-ttu-id="240c7-211">Si `d` es negativo, la operación de redondeo hace que cualquier componente fraccionario de `d` van a descartar.</span><span class="sxs-lookup"><span data-stu-id="240c7-211">If `d` is negative, the rounding operation causes any fractional component of `d` to be discarded.</span></span> <span data-ttu-id="240c7-212">La operación de este método difiere de la <xref:System.Math.Floor%28System.Decimal%29> método, que es compatible con redondeo a infinito negativo.</span><span class="sxs-lookup"><span data-stu-id="240c7-212">The operation of this method differs from the <xref:System.Math.Floor%28System.Decimal%29> method, which supports rounding toward negative infinity.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="240c7-213">En el ejemplo siguiente se muestra la <xref:System.Math.Ceiling%28System.Decimal%29?displayProperty=nameWithType> método y se contrasta con la <xref:System.Math.Floor%28System.Decimal%29> método.</span><span class="sxs-lookup"><span data-stu-id="240c7-213">The following example illustrates the <xref:System.Math.Ceiling%28System.Decimal%29?displayProperty=nameWithType> method and contrasts it with the <xref:System.Math.Floor%28System.Decimal%29> method.</span></span>  
  
 [!code-csharp[System.Math.Ceiling#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Math.Ceiling/cs/Ceiling1.cs#1)]
 [!code-vb[System.Math.Ceiling#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Math.Ceiling/vb/Ceiling1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Math.Round" />
        <altmember cref="M:System.Math.Floor(System.Decimal)" />
      </Docs>
    </Member>
    <Member MemberName="Ceiling">
      <MemberSignature Language="C#" Value="public static double Ceiling (double a);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Ceiling(float64 a) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Ceiling(System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Ceiling (a As Double) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double Ceiling(double a);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="a" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="a"><span data-ttu-id="240c7-214">Número de punto flotante de precisión doble.</span><span class="sxs-lookup"><span data-stu-id="240c7-214">A double-precision floating-point number.</span></span></param>
        <summary><span data-ttu-id="240c7-215">Devuelve el valor integral más pequeño que es mayor o igual que el número de punto flotante de precisión doble especificado.</span><span class="sxs-lookup"><span data-stu-id="240c7-215">Returns the smallest integral value that is greater than or equal to the specified double-precision floating-point number.</span></span></summary>
        <returns><span data-ttu-id="240c7-216">Valor entero más pequeño que es mayor o igual que <paramref name="a" />.</span><span class="sxs-lookup"><span data-stu-id="240c7-216">The smallest integral value that is greater than or equal to <paramref name="a" />.</span></span> <span data-ttu-id="240c7-217">Si <paramref name="a" /> es igual que <see cref="F:System.Double.NaN" />, <see cref="F:System.Double.NegativeInfinity" /> o <see cref="F:System.Double.PositiveInfinity" />, se devuelve ese valor.</span><span class="sxs-lookup"><span data-stu-id="240c7-217">If <paramref name="a" /> is equal to <see cref="F:System.Double.NaN" />, <see cref="F:System.Double.NegativeInfinity" />, or <see cref="F:System.Double.PositiveInfinity" />, that value is returned.</span></span> <span data-ttu-id="240c7-218">Tenga en cuenta que este método devuelve un valor <see cref="T:System.Double" /> en lugar de un tipo entero.</span><span class="sxs-lookup"><span data-stu-id="240c7-218">Note that this method returns a <see cref="T:System.Double" /> instead of an integral type.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="240c7-219">El comportamiento de este método sigue el estándar IEEE 754, sección 4.</span><span class="sxs-lookup"><span data-stu-id="240c7-219">The behavior of this method follows IEEE Standard 754, section 4.</span></span> <span data-ttu-id="240c7-220">Este tipo de redondeo a veces se denomina redondeo hacia el infinito positivo.</span><span class="sxs-lookup"><span data-stu-id="240c7-220">This kind of rounding is sometimes called rounding toward positive infinity.</span></span> <span data-ttu-id="240c7-221">En otras palabras, si `a` es positivo, la presencia de las causas de cualquier componente de fracción `a` se redondea al entero más alto siguiente.</span><span class="sxs-lookup"><span data-stu-id="240c7-221">In other words, if `a` is positive, the presence of any fractional component causes `a` to be rounded to the next highest integer.</span></span> <span data-ttu-id="240c7-222">Si `a` es negativo, la operación de redondeo hace que cualquier componente fraccionario de `a` van a descartar.</span><span class="sxs-lookup"><span data-stu-id="240c7-222">If `a` is negative, the rounding operation causes any fractional component of `a` to be discarded.</span></span> <span data-ttu-id="240c7-223">La operación de este método difiere de la <xref:System.Math.Floor%28System.Double%29> método, que es compatible con redondeo a infinito negativo.</span><span class="sxs-lookup"><span data-stu-id="240c7-223">The operation of this method differs from the <xref:System.Math.Floor%28System.Double%29> method, which supports rounding toward negative infinity.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="240c7-224">En el ejemplo siguiente se muestra la <xref:System.Math.Ceiling%28System.Double%29?displayProperty=nameWithType> método y se contrasta con la <xref:System.Math.Floor%28System.Double%29> método.</span><span class="sxs-lookup"><span data-stu-id="240c7-224">The following example illustrates the <xref:System.Math.Ceiling%28System.Double%29?displayProperty=nameWithType> method and contrasts it with the <xref:System.Math.Floor%28System.Double%29> method.</span></span>  
  
 [!code-csharp[System.Math.Ceiling#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Math.Ceiling/cs/Ceiling1.cs#2)]
 [!code-vb[System.Math.Ceiling#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Math.Ceiling/vb/Ceiling1.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Math.Round" />
        <altmember cref="M:System.Math.Floor(System.Double)" />
      </Docs>
    </Member>
    <Member MemberName="Clamp">
      <MemberSignature Language="C#" Value="public static byte Clamp (byte value, byte min, byte max);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int8 Clamp(unsigned int8 value, unsigned int8 min, unsigned int8 max) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Clamp(System.Byte,System.Byte,System.Byte)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Clamp (value As Byte, min As Byte, max As Byte) As Byte" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Byte Clamp(System::Byte value, System::Byte min, System::Byte max);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Byte" />
        <Parameter Name="min" Type="System.Byte" />
        <Parameter Name="max" Type="System.Byte" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <param name="min">To be added.</param>
        <param name="max">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Clamp">
      <MemberSignature Language="C#" Value="public static decimal Clamp (decimal value, decimal min, decimal max);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Decimal Clamp(valuetype System.Decimal value, valuetype System.Decimal min, valuetype System.Decimal max) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Clamp(System.Decimal,System.Decimal,System.Decimal)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Clamp (value As Decimal, min As Decimal, max As Decimal) As Decimal" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Decimal Clamp(System::Decimal value, System::Decimal min, System::Decimal max);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Decimal" />
        <Parameter Name="min" Type="System.Decimal" />
        <Parameter Name="max" Type="System.Decimal" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <param name="min">To be added.</param>
        <param name="max">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Clamp">
      <MemberSignature Language="C#" Value="public static double Clamp (double value, double min, double max);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Clamp(float64 value, float64 min, float64 max) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Clamp(System.Double,System.Double,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Clamp (value As Double, min As Double, max As Double) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double Clamp(double value, double min, double max);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Double" />
        <Parameter Name="min" Type="System.Double" />
        <Parameter Name="max" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <param name="min">To be added.</param>
        <param name="max">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Clamp">
      <MemberSignature Language="C#" Value="public static short Clamp (short value, short min, short max);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int16 Clamp(int16 value, int16 min, int16 max) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Clamp(System.Int16,System.Int16,System.Int16)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Clamp (value As Short, min As Short, max As Short) As Short" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static short Clamp(short value, short min, short max);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int16" />
        <Parameter Name="min" Type="System.Int16" />
        <Parameter Name="max" Type="System.Int16" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <param name="min">To be added.</param>
        <param name="max">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Clamp">
      <MemberSignature Language="C#" Value="public static int Clamp (int value, int min, int max);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Clamp(int32 value, int32 min, int32 max) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Clamp(System.Int32,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Clamp (value As Integer, min As Integer, max As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Clamp(int value, int min, int max);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int32" />
        <Parameter Name="min" Type="System.Int32" />
        <Parameter Name="max" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <param name="min">To be added.</param>
        <param name="max">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Clamp">
      <MemberSignature Language="C#" Value="public static long Clamp (long value, long min, long max);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 Clamp(int64 value, int64 min, int64 max) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Clamp(System.Int64,System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Clamp (value As Long, min As Long, max As Long) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static long Clamp(long value, long min, long max);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int64" />
        <Parameter Name="min" Type="System.Int64" />
        <Parameter Name="max" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <param name="min">To be added.</param>
        <param name="max">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Clamp">
      <MemberSignature Language="C#" Value="public static sbyte Clamp (sbyte value, sbyte min, sbyte max);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int8 Clamp(int8 value, int8 min, int8 max) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Clamp(System.SByte,System.SByte,System.SByte)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Clamp (value As SByte, min As SByte, max As SByte) As SByte" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::SByte Clamp(System::SByte value, System::SByte min, System::SByte max);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.SByte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.SByte" />
        <Parameter Name="min" Type="System.SByte" />
        <Parameter Name="max" Type="System.SByte" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <param name="min">To be added.</param>
        <param name="max">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Clamp">
      <MemberSignature Language="C#" Value="public static float Clamp (float value, float min, float max);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 Clamp(float32 value, float32 min, float32 max) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Clamp(System.Single,System.Single,System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Clamp (value As Single, min As Single, max As Single) As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static float Clamp(float value, float min, float max);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Single" />
        <Parameter Name="min" Type="System.Single" />
        <Parameter Name="max" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <param name="min">To be added.</param>
        <param name="max">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Clamp">
      <MemberSignature Language="C#" Value="public static ushort Clamp (ushort value, ushort min, ushort max);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int16 Clamp(unsigned int16 value, unsigned int16 min, unsigned int16 max) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Clamp(System.UInt16,System.UInt16,System.UInt16)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Clamp (value As UShort, min As UShort, max As UShort) As UShort" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::UInt16 Clamp(System::UInt16 value, System::UInt16 min, System::UInt16 max);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UInt16" />
        <Parameter Name="min" Type="System.UInt16" />
        <Parameter Name="max" Type="System.UInt16" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <param name="min">To be added.</param>
        <param name="max">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Clamp">
      <MemberSignature Language="C#" Value="public static uint Clamp (uint value, uint min, uint max);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int32 Clamp(unsigned int32 value, unsigned int32 min, unsigned int32 max) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Clamp(System.UInt32,System.UInt32,System.UInt32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Clamp (value As UInteger, min As UInteger, max As UInteger) As UInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::UInt32 Clamp(System::UInt32 value, System::UInt32 min, System::UInt32 max);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UInt32" />
        <Parameter Name="min" Type="System.UInt32" />
        <Parameter Name="max" Type="System.UInt32" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <param name="min">To be added.</param>
        <param name="max">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Clamp">
      <MemberSignature Language="C#" Value="public static ulong Clamp (ulong value, ulong min, ulong max);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int64 Clamp(unsigned int64 value, unsigned int64 min, unsigned int64 max) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Clamp(System.UInt64,System.UInt64,System.UInt64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Clamp (value As ULong, min As ULong, max As ULong) As ULong" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::UInt64 Clamp(System::UInt64 value, System::UInt64 min, System::UInt64 max);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UInt64" />
        <Parameter Name="min" Type="System.UInt64" />
        <Parameter Name="max" Type="System.UInt64" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <param name="min">To be added.</param>
        <param name="max">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Cos">
      <MemberSignature Language="C#" Value="public static double Cos (double d);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Cos(float64 d) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Cos(System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Cos (d As Double) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double Cos(double d);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="d"><span data-ttu-id="240c7-225">Ángulo, medido en radianes.</span><span class="sxs-lookup"><span data-stu-id="240c7-225">An angle, measured in radians.</span></span></param>
        <summary><span data-ttu-id="240c7-226">Devuelve el coseno del ángulo especificado.</span><span class="sxs-lookup"><span data-stu-id="240c7-226">Returns the cosine of the specified angle.</span></span></summary>
        <returns><span data-ttu-id="240c7-227">Coseno de <paramref name="d" />.</span><span class="sxs-lookup"><span data-stu-id="240c7-227">The cosine of <paramref name="d" />.</span></span> <span data-ttu-id="240c7-228">Si <paramref name="d" /> es igual a <see cref="F:System.Double.NaN" />, <see cref="F:System.Double.NegativeInfinity" /> o <see cref="F:System.Double.PositiveInfinity" />, este método devuelve <see cref="F:System.Double.NaN" />.</span><span class="sxs-lookup"><span data-stu-id="240c7-228">If <paramref name="d" /> is equal to <see cref="F:System.Double.NaN" />, <see cref="F:System.Double.NegativeInfinity" />, or <see cref="F:System.Double.PositiveInfinity" />, this method returns <see cref="F:System.Double.NaN" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="240c7-229">El ángulo, `d`, deben estar en radianes.</span><span class="sxs-lookup"><span data-stu-id="240c7-229">The angle, `d`, must be in radians.</span></span> <span data-ttu-id="240c7-230">Multiplicar por <xref:System.Math.PI?displayProperty=nameWithType>/180 para convertir los grados en radianes.</span><span class="sxs-lookup"><span data-stu-id="240c7-230">Multiply by <xref:System.Math.PI?displayProperty=nameWithType>/180 to convert degrees to radians.</span></span>  
  
 <span data-ttu-id="240c7-231">Los valores aceptables de `d` intervalo de aproximadamente -9223372036854775295 a aproximadamente 9223372036854775295.</span><span class="sxs-lookup"><span data-stu-id="240c7-231">Acceptable values of `d` range from approximately -9223372036854775295 to approximately 9223372036854775295.</span></span> <span data-ttu-id="240c7-232">Para valores fuera de este intervalo, el <xref:System.Math.Cos%2A> método `d` sin cambios en lugar de producir una excepción.</span><span class="sxs-lookup"><span data-stu-id="240c7-232">For values outside this range, the <xref:System.Math.Cos%2A> method returns `d` unchanged rather than throwing an exception.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="240c7-233">En el ejemplo siguiente se utiliza <xref:System.Math.Cos%2A> para evaluar determinadas identidades trigonométricas de ángulos seleccionados.</span><span class="sxs-lookup"><span data-stu-id="240c7-233">The following example uses <xref:System.Math.Cos%2A> to evaluate certain trigonometric identities for selected angles.</span></span>  
  
 [!code-cpp[System.Math.SinCos#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Math.SinCos/CPP/sincos.cpp#1)]
 [!code-csharp[System.Math.SinCos#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Math.SinCos/CS/sincos.cs#1)]
 [!code-vb[System.Math.SinCos#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Math.SinCos/VB/sincos.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Cosh">
      <MemberSignature Language="C#" Value="public static double Cosh (double value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Cosh(float64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Cosh(System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Cosh (value As Double) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double Cosh(double value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="240c7-234">Ángulo, medido en radianes.</span><span class="sxs-lookup"><span data-stu-id="240c7-234">An angle, measured in radians.</span></span></param>
        <summary><span data-ttu-id="240c7-235">Devuelve el coseno hiperbólico del ángulo especificado.</span><span class="sxs-lookup"><span data-stu-id="240c7-235">Returns the hyperbolic cosine of the specified angle.</span></span></summary>
        <returns><span data-ttu-id="240c7-236">Coseno hiperbólico de <paramref name="value" />.</span><span class="sxs-lookup"><span data-stu-id="240c7-236">The hyperbolic cosine of <paramref name="value" />.</span></span> <span data-ttu-id="240c7-237">Si <paramref name="value" /> es igual que <see cref="F:System.Double.NegativeInfinity" /> o <see cref="F:System.Double.PositiveInfinity" />, se devuelve <see cref="F:System.Double.PositiveInfinity" />.</span><span class="sxs-lookup"><span data-stu-id="240c7-237">If <paramref name="value" /> is equal to <see cref="F:System.Double.NegativeInfinity" /> or <see cref="F:System.Double.PositiveInfinity" />, <see cref="F:System.Double.PositiveInfinity" /> is returned.</span></span> <span data-ttu-id="240c7-238">Si <paramref name="value" /> es igual que <see cref="F:System.Double.NaN" />, se devuelve <see cref="F:System.Double.NaN" />.</span><span class="sxs-lookup"><span data-stu-id="240c7-238">If <paramref name="value" /> is equal to <see cref="F:System.Double.NaN" />, <see cref="F:System.Double.NaN" /> is returned.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="240c7-239">El ángulo, `value`, deben estar en radianes.</span><span class="sxs-lookup"><span data-stu-id="240c7-239">The angle, `value`, must be in radians.</span></span> <span data-ttu-id="240c7-240">Multiplicar por <xref:System.Math.PI?displayProperty=nameWithType>/180 para convertir los grados en radianes.</span><span class="sxs-lookup"><span data-stu-id="240c7-240">Multiply by <xref:System.Math.PI?displayProperty=nameWithType>/180 to convert degrees to radians.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="240c7-241">En el ejemplo siguiente se utiliza <xref:System.Math.Cosh%2A> para evaluar determinadas identidades hiperbólicas de valores seleccionados.</span><span class="sxs-lookup"><span data-stu-id="240c7-241">The following example uses <xref:System.Math.Cosh%2A> to evaluate certain hyperbolic identities for selected values.</span></span>  
  
 [!code-cpp[System.Math.SinhCosh#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Math.SinhCosh/CPP/sinhcosh.cpp#1)]
 [!code-csharp[System.Math.SinhCosh#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Math.SinhCosh/CS/sinhcosh.cs#1)]
 [!code-vb[System.Math.SinhCosh#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Math.SinhCosh/VB/sinhcosh.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="DivRem">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="240c7-242">Calcula el cociente de dos números y devuelve también el resto de la división como parámetro de salida.</span><span class="sxs-lookup"><span data-stu-id="240c7-242">Calculates the quotient of two numbers and also returns the remainder in an output parameter.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="DivRem">
      <MemberSignature Language="C#" Value="public static int DivRem (int a, int b, out int result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 DivRem(int32 a, int32 b, [out] int32&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.DivRem(System.Int32,System.Int32,System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function DivRem (a As Integer, b As Integer, ByRef result As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int DivRem(int a, int b, [Runtime::InteropServices::Out] int % result);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="a" Type="System.Int32" />
        <Parameter Name="b" Type="System.Int32" />
        <Parameter Name="result" Type="System.Int32&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="a"><span data-ttu-id="240c7-243">Dividendo.</span><span class="sxs-lookup"><span data-stu-id="240c7-243">The dividend.</span></span></param>
        <param name="b"><span data-ttu-id="240c7-244">Divisor.</span><span class="sxs-lookup"><span data-stu-id="240c7-244">The divisor.</span></span></param>
        <param name="result"><span data-ttu-id="240c7-245">Resto.</span><span class="sxs-lookup"><span data-stu-id="240c7-245">The remainder.</span></span></param>
        <summary><span data-ttu-id="240c7-246">Calcula el cociente de dos números enteros de 32 bits con signo y devuelve también el resto de la división como parámetro de salida.</span><span class="sxs-lookup"><span data-stu-id="240c7-246">Calculates the quotient of two 32-bit signed integers and also returns the remainder in an output parameter.</span></span></summary>
        <returns><span data-ttu-id="240c7-247">Cociente de los números especificados.</span><span class="sxs-lookup"><span data-stu-id="240c7-247">The quotient of the specified numbers.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="240c7-248">El resto se calcula mediante el uso de la operación de módulo.</span><span class="sxs-lookup"><span data-stu-id="240c7-248">The remainder is calculated by using the modulus operation.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="240c7-249">En el ejemplo siguiente se muestra el <xref:System.Math.DivRem%28System.Int32%2CSystem.Int32%2CSystem.Int32%40%29> método.</span><span class="sxs-lookup"><span data-stu-id="240c7-249">The following example demonstrates the <xref:System.Math.DivRem%28System.Int32%2CSystem.Int32%2CSystem.Int32%40%29> method.</span></span>  
  
 [!code-csharp[System.Math.DivRem#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.math.divrem/cs/divrem1.cs#1)]
 [!code-vb[System.Math.DivRem#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.math.divrem/vb/divrem1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.DivideByZeroException">
          <span data-ttu-id="240c7-250"><paramref name="b" /> es cero.</span><span class="sxs-lookup"><span data-stu-id="240c7-250"><paramref name="b" /> is zero.</span></span></exception>
        <altmember cref="M:System.Math.IEEERemainder(System.Double,System.Double)" />
      </Docs>
    </Member>
    <Member MemberName="DivRem">
      <MemberSignature Language="C#" Value="public static long DivRem (long a, long b, out long result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 DivRem(int64 a, int64 b, [out] int64&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.DivRem(System.Int64,System.Int64,System.Int64@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function DivRem (a As Long, b As Long, ByRef result As Long) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static long DivRem(long a, long b, [Runtime::InteropServices::Out] long % result);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="a" Type="System.Int64" />
        <Parameter Name="b" Type="System.Int64" />
        <Parameter Name="result" Type="System.Int64&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="a"><span data-ttu-id="240c7-251">Dividendo.</span><span class="sxs-lookup"><span data-stu-id="240c7-251">The dividend.</span></span></param>
        <param name="b"><span data-ttu-id="240c7-252">Divisor.</span><span class="sxs-lookup"><span data-stu-id="240c7-252">The divisor.</span></span></param>
        <param name="result"><span data-ttu-id="240c7-253">Resto.</span><span class="sxs-lookup"><span data-stu-id="240c7-253">The remainder.</span></span></param>
        <summary><span data-ttu-id="240c7-254">Calcula el cociente de dos números enteros de 64 bits con signo y devuelve también el resto de la división como parámetro de salida.</span><span class="sxs-lookup"><span data-stu-id="240c7-254">Calculates the quotient of two 64-bit signed integers and also returns the remainder in an output parameter.</span></span></summary>
        <returns><span data-ttu-id="240c7-255">Cociente de los números especificados.</span><span class="sxs-lookup"><span data-stu-id="240c7-255">The quotient of the specified numbers.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="240c7-256">El resto se calcula mediante el uso de la operación de módulo.</span><span class="sxs-lookup"><span data-stu-id="240c7-256">The remainder is calculated by using the modulus operation.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="240c7-257">En el ejemplo siguiente se muestra el <xref:System.Math.DivRem%28System.Int64%2CSystem.Int64%2CSystem.Int64%40%29> método.</span><span class="sxs-lookup"><span data-stu-id="240c7-257">The following example demonstrates the <xref:System.Math.DivRem%28System.Int64%2CSystem.Int64%2CSystem.Int64%40%29> method.</span></span>  
  
 [!code-csharp[System.Math.DivRem#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.math.divrem/cs/divrem2.cs#2)]
 [!code-vb[System.Math.DivRem#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.math.divrem/vb/divrem2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.DivideByZeroException">
          <span data-ttu-id="240c7-258"><paramref name="b" /> es cero.</span><span class="sxs-lookup"><span data-stu-id="240c7-258"><paramref name="b" /> is zero.</span></span></exception>
        <altmember cref="M:System.Math.IEEERemainder(System.Double,System.Double)" />
      </Docs>
    </Member>
    <Member MemberName="E">
      <MemberSignature Language="C#" Value="public const double E = 2.71828182845905;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal float64 E = (2.71828182845905)" />
      <MemberSignature Language="DocId" Value="F:System.Math.E" />
      <MemberSignature Language="VB.NET" Value="Public Const E As Double  = 2.71828182845905" />
      <MemberSignature Language="C++ CLI" Value="public: double E = 2.71828182845905;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <MemberValue>2.71828182845905</MemberValue>
      <Docs>
        <summary><span data-ttu-id="240c7-259">Representa la base logarítmica natural, especificada por la constante, <see langword="e" />.</span><span class="sxs-lookup"><span data-stu-id="240c7-259">Represents the natural logarithmic base, specified by the constant, <see langword="e" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="240c7-260">El valor de este campo es 2,7182818284590452354.</span><span class="sxs-lookup"><span data-stu-id="240c7-260">The value of this field is 2.7182818284590452354.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="240c7-261">En el ejemplo siguiente se comparan <xref:System.Math.E> con el valor calculado a partir de una serie de energía.</span><span class="sxs-lookup"><span data-stu-id="240c7-261">The following example compares <xref:System.Math.E> with the value calculated from a power series.</span></span>  
  
 [!code-cpp[System.Math.E#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Math.E/CPP/efield.cpp#1)]
 [!code-csharp[System.Math.E#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Math.E/CS/efield.cs#1)]
 [!code-vb[System.Math.E#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Math.E/VB/efield.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Exp">
      <MemberSignature Language="C#" Value="public static double Exp (double d);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Exp(float64 d) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Exp(System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Exp (d As Double) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double Exp(double d);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="d"><span data-ttu-id="240c7-262">Número que especifica una potencia.</span><span class="sxs-lookup"><span data-stu-id="240c7-262">A number specifying a power.</span></span></param>
        <summary><span data-ttu-id="240c7-263">Devuelve <see langword="e" /> elevado a la potencia especificada.</span><span class="sxs-lookup"><span data-stu-id="240c7-263">Returns <see langword="e" /> raised to the specified power.</span></span></summary>
        <returns><span data-ttu-id="240c7-264">Número <see langword="e" /> elevado a la potencia <paramref name="d" />.</span><span class="sxs-lookup"><span data-stu-id="240c7-264">The number <see langword="e" /> raised to the power <paramref name="d" />.</span></span> <span data-ttu-id="240c7-265">Si <paramref name="d" /> es igual que <see cref="F:System.Double.NaN" /> o <see cref="F:System.Double.PositiveInfinity" />, se devuelve ese valor.</span><span class="sxs-lookup"><span data-stu-id="240c7-265">If <paramref name="d" /> equals <see cref="F:System.Double.NaN" /> or <see cref="F:System.Double.PositiveInfinity" />, that value is returned.</span></span> <span data-ttu-id="240c7-266">Si <paramref name="d" /> es igual que <see cref="F:System.Double.NegativeInfinity" />, se devuelve 0.</span><span class="sxs-lookup"><span data-stu-id="240c7-266">If <paramref name="d" /> equals <see cref="F:System.Double.NegativeInfinity" />, 0 is returned.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="240c7-267">`e` es una constante matemática cuyo valor es aproximadamente 2,71828.</span><span class="sxs-lookup"><span data-stu-id="240c7-267">`e` is a mathematical constant whose value is approximately 2.71828.</span></span>  
  
 <span data-ttu-id="240c7-268">Use la <xref:System.Math.Pow%2A> método para calcular las potencias de otras bases de datos.</span><span class="sxs-lookup"><span data-stu-id="240c7-268">Use the <xref:System.Math.Pow%2A> method to calculate powers of other bases.</span></span>  
  
 <span data-ttu-id="240c7-269"><xref:System.Math.Exp%2A> es el inverso del <xref:System.Math.Log%2A>.</span><span class="sxs-lookup"><span data-stu-id="240c7-269"><xref:System.Math.Exp%2A> is the inverse of <xref:System.Math.Log%2A>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="240c7-270">En el ejemplo siguiente se utiliza <xref:System.Math.Exp%2A> para evaluar determinadas identidades exponenciales y logarítmicas de valores seleccionados.</span><span class="sxs-lookup"><span data-stu-id="240c7-270">The following example uses <xref:System.Math.Exp%2A> to evaluate certain exponential and logarithmic identities for selected values.</span></span>  
  
 [!code-cpp[System.Math.Exp#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Math.Exp/CPP/exp.cpp#1)]
 [!code-csharp[System.Math.Exp#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Math.Exp/CS/exp.cs#1)]
 [!code-vb[System.Math.Exp#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Math.Exp/VB/exp.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="F:System.Math.E" />
        <altmember cref="M:System.Math.Pow(System.Double,System.Double)" />
        <altmember cref="M:System.Math.Log(System.Double)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Floor">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="240c7-271">Devuelve el mayor valor integral menor o igual que el número especificado.</span><span class="sxs-lookup"><span data-stu-id="240c7-271">Returns the largest integral value less than or equal to the specified number.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="240c7-272">El comportamiento de este método sigue el estándar IEEE 754, sección 4.</span><span class="sxs-lookup"><span data-stu-id="240c7-272">The behavior of this method follows IEEE Standard 754, section 4.</span></span> <span data-ttu-id="240c7-273">Este tipo de redondeo a veces se denomina redondeo a infinito negativo.</span><span class="sxs-lookup"><span data-stu-id="240c7-273">This kind of rounding is sometimes called rounding toward negative infinity.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Floor">
      <MemberSignature Language="C#" Value="public static decimal Floor (decimal d);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Decimal Floor(valuetype System.Decimal d) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Floor(System.Decimal)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Floor (d As Decimal) As Decimal" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Decimal Floor(System::Decimal d);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d" Type="System.Decimal" />
      </Parameters>
      <Docs>
        <param name="d"><span data-ttu-id="240c7-274">Número decimal.</span><span class="sxs-lookup"><span data-stu-id="240c7-274">A decimal number.</span></span></param>
        <summary><span data-ttu-id="240c7-275">Devuelve el mayor valor integral menor o igual que el número decimal especificado.</span><span class="sxs-lookup"><span data-stu-id="240c7-275">Returns the largest integral value less than or equal to the specified decimal number.</span></span></summary>
        <returns><span data-ttu-id="240c7-276">El mayor valor integral que es menor o igual que <paramref name="d" />.</span><span class="sxs-lookup"><span data-stu-id="240c7-276">The largest integral value less than or equal to <paramref name="d" />.</span></span>  <span data-ttu-id="240c7-277">Tenga en cuenta que el método devuelve un valor entero de tipo <see cref="T:System.Decimal" />.</span><span class="sxs-lookup"><span data-stu-id="240c7-277">Note that the method returns an integral value of type <see cref="T:System.Decimal" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="240c7-278">El comportamiento de este método sigue el estándar IEEE 754, sección 4.</span><span class="sxs-lookup"><span data-stu-id="240c7-278">The behavior of this method follows IEEE Standard 754, section 4.</span></span> <span data-ttu-id="240c7-279">Este tipo de redondeo a veces se denomina redondeo a infinito negativo.</span><span class="sxs-lookup"><span data-stu-id="240c7-279">This kind of rounding is sometimes called rounding toward negative infinity.</span></span> <span data-ttu-id="240c7-280">En otras palabras, si `d` es positivo, se trunca cualquier componente fraccionario.</span><span class="sxs-lookup"><span data-stu-id="240c7-280">In other words, if `d` is positive, any fractional component is truncated.</span></span> <span data-ttu-id="240c7-281">Si `d` es negativo, la presencia de cualquier componente fraccionario hace que se redondea al entero más pequeño.</span><span class="sxs-lookup"><span data-stu-id="240c7-281">If `d` is negative, the presence of any fractional component causes it to be rounded to the smaller integer.</span></span> <span data-ttu-id="240c7-282">La operación de este método difiere de la <xref:System.Math.Ceiling%2A> método, que es compatible con redondeo a infinito positivo.</span><span class="sxs-lookup"><span data-stu-id="240c7-282">The operation of this method differs from the <xref:System.Math.Ceiling%2A> method, which supports rounding toward positive infinity.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="240c7-283">En el ejemplo siguiente se muestra la <xref:System.Math.Floor%28System.Decimal%29?displayProperty=nameWithType> método y se contrasta con la <xref:System.Math.Ceiling%28System.Decimal%29> método.</span><span class="sxs-lookup"><span data-stu-id="240c7-283">The following example illustrates the <xref:System.Math.Floor%28System.Decimal%29?displayProperty=nameWithType> method and contrasts it with the <xref:System.Math.Ceiling%28System.Decimal%29> method.</span></span>  
  
 [!code-csharp[System.Math.Ceiling#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Math.Ceiling/cs/Ceiling1.cs#1)]
 [!code-vb[System.Math.Ceiling#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Math.Ceiling/vb/Ceiling1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Math.Round" />
        <altmember cref="M:System.Math.Ceiling(System.Decimal)" />
        <altmember cref="M:System.Decimal.Floor(System.Decimal)" />
      </Docs>
    </Member>
    <Member MemberName="Floor">
      <MemberSignature Language="C#" Value="public static double Floor (double d);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Floor(float64 d) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Floor(System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Floor (d As Double) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double Floor(double d);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="d"><span data-ttu-id="240c7-284">Número de punto flotante de precisión doble.</span><span class="sxs-lookup"><span data-stu-id="240c7-284">A double-precision floating-point number.</span></span></param>
        <summary><span data-ttu-id="240c7-285">Devuelve el mayor valor integral menor o igual que el número de punto flotante de precisión doble especificado.</span><span class="sxs-lookup"><span data-stu-id="240c7-285">Returns the largest integral value less than or equal to the specified double-precision floating-point number.</span></span></summary>
        <returns><span data-ttu-id="240c7-286">El mayor valor integral que es menor o igual que <paramref name="d" />.</span><span class="sxs-lookup"><span data-stu-id="240c7-286">The largest integral value less than or equal to <paramref name="d" />.</span></span> <span data-ttu-id="240c7-287">Si <paramref name="d" /> es igual que <see cref="F:System.Double.NaN" />, <see cref="F:System.Double.NegativeInfinity" /> o <see cref="F:System.Double.PositiveInfinity" />, se devuelve ese valor.</span><span class="sxs-lookup"><span data-stu-id="240c7-287">If <paramref name="d" /> is equal to <see cref="F:System.Double.NaN" />, <see cref="F:System.Double.NegativeInfinity" />, or <see cref="F:System.Double.PositiveInfinity" />, that value is returned.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="240c7-288">El comportamiento de este método sigue el estándar IEEE 754, sección 4.</span><span class="sxs-lookup"><span data-stu-id="240c7-288">The behavior of this method follows IEEE Standard 754, section 4.</span></span> <span data-ttu-id="240c7-289">Este tipo de redondeo a veces se denomina redondeo a infinito negativo.</span><span class="sxs-lookup"><span data-stu-id="240c7-289">This kind of rounding is sometimes called rounding toward negative infinity.</span></span> <span data-ttu-id="240c7-290">En otras palabras, si `d` es positivo, se trunca cualquier componente fraccionario.</span><span class="sxs-lookup"><span data-stu-id="240c7-290">In other words, if `d` is positive, any fractional component is truncated.</span></span> <span data-ttu-id="240c7-291">Si `d` es negativo, la presencia de cualquier componente fraccionario hace que se redondea al entero más pequeño.</span><span class="sxs-lookup"><span data-stu-id="240c7-291">If `d` is negative, the presence of any fractional component causes it to be rounded to the smaller integer.</span></span> <span data-ttu-id="240c7-292">La operación de este método difiere de la <xref:System.Math.Ceiling%2A> método, que es compatible con redondeo a infinito positivo.</span><span class="sxs-lookup"><span data-stu-id="240c7-292">The operation of this method differs from the <xref:System.Math.Ceiling%2A> method, which supports rounding toward positive infinity.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="240c7-293">En el ejemplo siguiente se muestra la <xref:System.Math.Floor%28System.Double%29?displayProperty=nameWithType> método y se contrasta con la <xref:System.Math.Ceiling%28System.Double%29> método.</span><span class="sxs-lookup"><span data-stu-id="240c7-293">The following example illustrates the <xref:System.Math.Floor%28System.Double%29?displayProperty=nameWithType> method and contrasts it with the <xref:System.Math.Ceiling%28System.Double%29> method.</span></span>  
  
 [!code-csharp[System.Math.Ceiling#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Math.Ceiling/cs/Ceiling1.cs#2)]
 [!code-vb[System.Math.Ceiling#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Math.Ceiling/vb/Ceiling1.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Math.Round" />
        <altmember cref="M:System.Math.Ceiling(System.Double)" />
      </Docs>
    </Member>
    <Member MemberName="IEEERemainder">
      <MemberSignature Language="C#" Value="public static double IEEERemainder (double x, double y);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 IEEERemainder(float64 x, float64 y) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.IEEERemainder(System.Double,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IEEERemainder (x As Double, y As Double) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double IEEERemainder(double x, double y);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Double" />
        <Parameter Name="y" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="x"><span data-ttu-id="240c7-294">Dividendo.</span><span class="sxs-lookup"><span data-stu-id="240c7-294">A dividend.</span></span></param>
        <param name="y"><span data-ttu-id="240c7-295">Divisor.</span><span class="sxs-lookup"><span data-stu-id="240c7-295">A divisor.</span></span></param>
        <summary><span data-ttu-id="240c7-296">Devuelve el resto de la división de dos números especificados.</span><span class="sxs-lookup"><span data-stu-id="240c7-296">Returns the remainder resulting from the division of a specified number by another specified number.</span></span></summary>
        <returns><span data-ttu-id="240c7-297">Número igual a <paramref name="x" /> - (<paramref name="y" /> Q), donde Q es el cociente de <paramref name="x" /> / <paramref name="y" /> redondeado a su entero más próximo (si <paramref name="x" /> / <paramref name="y" /> se encuentra entre dos enteros, se devuelve el entero par).</span><span class="sxs-lookup"><span data-stu-id="240c7-297">A number equal to <paramref name="x" /> - (<paramref name="y" /> Q), where Q is the quotient of <paramref name="x" /> / <paramref name="y" /> rounded to the nearest integer (if <paramref name="x" /> / <paramref name="y" /> falls halfway between two integers, the even integer is returned).</span></span>  
  
 <span data-ttu-id="240c7-298">Si <paramref name="x" /> - (<paramref name="y" /> Q) es cero, se devuelve el valor +0 si <paramref name="x" /> es positivo o -0 si <paramref name="x" /> es negativo.</span><span class="sxs-lookup"><span data-stu-id="240c7-298">If <paramref name="x" /> - (<paramref name="y" /> Q) is zero, the value +0 is returned if <paramref name="x" /> is positive, or -0 if <paramref name="x" /> is negative.</span></span>  
  
 <span data-ttu-id="240c7-299">Si <paramref name="y" /> = 0, se devuelve <see cref="F:System.Double.NaN" />.</span><span class="sxs-lookup"><span data-stu-id="240c7-299">If <paramref name="y" /> = 0, <see cref="F:System.Double.NaN" /> is returned.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="240c7-300">Esta operación cumple con la operación de resto definida en la sección 5.1 de ANSI/IEEE Std 754-1985; Estándar IEEE para aritmética binaria de punto flotante; Institute of Electrical and Electronics Engineers, Inc; 1985.</span><span class="sxs-lookup"><span data-stu-id="240c7-300">This operation complies with the remainder operation defined in Section 5.1 of ANSI/IEEE Std 754-1985; IEEE Standard for Binary Floating-Point Arithmetic; Institute of Electrical and Electronics Engineers, Inc; 1985.</span></span>  
  
 <span data-ttu-id="240c7-301">El <xref:System.Math.IEEERemainder%2A> método no es el mismo que el operador de módulo.</span><span class="sxs-lookup"><span data-stu-id="240c7-301">The <xref:System.Math.IEEERemainder%2A> method is not the same as the modulus operator.</span></span> <span data-ttu-id="240c7-302">Aunque ambos devuelven el resto después de la división, las fórmulas que usan son diferentes.</span><span class="sxs-lookup"><span data-stu-id="240c7-302">Although both return the remainder after division, the formulas they use are different.</span></span> <span data-ttu-id="240c7-303">La fórmula para el <xref:System.Math.IEEERemainder%2A> método es:</span><span class="sxs-lookup"><span data-stu-id="240c7-303">The formula for the <xref:System.Math.IEEERemainder%2A> method is:</span></span>  
  
```  
IEEERemainder = dividend - (divisor * Math.Round(dividend / divisor))  
```  
  
 <span data-ttu-id="240c7-304">En cambio, la fórmula para el operador de módulo es:</span><span class="sxs-lookup"><span data-stu-id="240c7-304">In contrast, the formula for the modulus operator is:</span></span>  
  
```  
Modulus = (Math.Abs(dividend) - (Math.Abs(divisor) *   
          (Math.Floor(Math.Abs(dividend) / Math.Abs(divisor))))) *   
          Math.Sign(dividend)  
```  
  
   
  
## Examples  
 <span data-ttu-id="240c7-305">En el ejemplo siguiente se compara el resto devuelto por la <xref:System.Math.IEEERemainder%2A> método con el resto devuelto por el operador de división de módulo.</span><span class="sxs-lookup"><span data-stu-id="240c7-305">The following example contrasts the remainder returned by the <xref:System.Math.IEEERemainder%2A> method with the remainder returned by the modulus division operator.</span></span>  
  
 [!code-csharp[System.Math.IEEERemainder#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.math.ieeeremainder/cs/ieeeremainder1.cs#1)]
 [!code-vb[System.Math.IEEERemainder#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.math.ieeeremainder/vb/ieeeremainder1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Log">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="240c7-306">Devuelve el logaritmo de un número especificado.</span><span class="sxs-lookup"><span data-stu-id="240c7-306">Returns the logarithm of a specified number.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Log">
      <MemberSignature Language="C#" Value="public static double Log (double d);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Log(float64 d) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Log(System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Log (d As Double) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double Log(double d);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="d"><span data-ttu-id="240c7-307">Número cuyo logaritmo se va a calcular.</span><span class="sxs-lookup"><span data-stu-id="240c7-307">The number whose logarithm is to be found.</span></span></param>
        <summary><span data-ttu-id="240c7-308">Devuelve el logaritmo natural (en base <see langword="e" />) de un número especificado.</span><span class="sxs-lookup"><span data-stu-id="240c7-308">Returns the natural (base <see langword="e" />) logarithm of a specified number.</span></span></summary>
        <returns><span data-ttu-id="240c7-309">Uno de los valores de la tabla siguiente.</span><span class="sxs-lookup"><span data-stu-id="240c7-309">One of the values in the following table.</span></span>  
  
 <span data-ttu-id="240c7-310"><list type="table"><listheader><term>Parámetro <paramref name="d" /></span><span class="sxs-lookup"><span data-stu-id="240c7-310"><list type="table"><listheader><term><paramref name="d" /> parameter</span></span>  
  
 <span data-ttu-id="240c7-311"></term><description> Valor devuelto</span><span class="sxs-lookup"><span data-stu-id="240c7-311"></term><description> Return value</span></span>  
  
 <span data-ttu-id="240c7-312"></description></listheader><item><term> Positivo</span><span class="sxs-lookup"><span data-stu-id="240c7-312"></description></listheader><item><term> Positive</span></span>  
  
 <span data-ttu-id="240c7-313"></term><description> Logaritmo natural de <paramref name="d" />; es decir, ln <paramref name="d" /> o log e <paramref name="d" /></description></item><item><term> Cero</span><span class="sxs-lookup"><span data-stu-id="240c7-313"></term><description> The natural logarithm of <paramref name="d" />; that is, ln <paramref name="d" />, or log e <paramref name="d" /></description></item><item><term> Zero</span></span>  
  
 <span data-ttu-id="240c7-314"></term><description><see cref="F:System.Double.NegativeInfinity" /></description></item><item><term> Negativo</span><span class="sxs-lookup"><span data-stu-id="240c7-314"></term><description><see cref="F:System.Double.NegativeInfinity" /></description></item><item><term> Negative</span></span>  
  
 <span data-ttu-id="240c7-315"></term><description><see cref="F:System.Double.NaN" /></description></item><item><term> Igual a <see cref="F:System.Double.NaN" /></term><description><see cref="F:System.Double.NaN" /></description></item><item><term> Igual a <see cref="F:System.Double.PositiveInfinity" /></term><description><see cref="F:System.Double.PositiveInfinity" /></description></item></list></span><span class="sxs-lookup"><span data-stu-id="240c7-315"></term><description><see cref="F:System.Double.NaN" /></description></item><item><term> Equal to <see cref="F:System.Double.NaN" /></term><description><see cref="F:System.Double.NaN" /></description></item><item><term> Equal to <see cref="F:System.Double.PositiveInfinity" /></term><description><see cref="F:System.Double.PositiveInfinity" /></description></item></list></span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="240c7-316">Parámetro `d` se especifica como un número en base 10.</span><span class="sxs-lookup"><span data-stu-id="240c7-316">Parameter `d` is specified as a base 10 number.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="240c7-317">En el ejemplo siguiente se muestra el <xref:System.Math.Log%2A> método.</span><span class="sxs-lookup"><span data-stu-id="240c7-317">The following example illustrates the <xref:System.Math.Log%2A> method.</span></span>  
  
 [!code-csharp[System.Math.Log_Overloads#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Math.Log_Overloads/CS/log1.cs#2)]
 [!code-vb[System.Math.Log_Overloads#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Math.Log_Overloads/VB/log1.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="F:System.Math.E" />
        <altmember cref="M:System.Math.Exp(System.Double)" />
      </Docs>
    </Member>
    <Member MemberName="Log">
      <MemberSignature Language="C#" Value="public static double Log (double a, double newBase);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Log(float64 a, float64 newBase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Log(System.Double,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Log (a As Double, newBase As Double) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double Log(double a, double newBase);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="a" Type="System.Double" />
        <Parameter Name="newBase" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="a"><span data-ttu-id="240c7-318">Número cuyo logaritmo se va a calcular.</span><span class="sxs-lookup"><span data-stu-id="240c7-318">The number whose logarithm is to be found.</span></span></param>
        <param name="newBase"><span data-ttu-id="240c7-319">Base del logaritmo.</span><span class="sxs-lookup"><span data-stu-id="240c7-319">The base of the logarithm.</span></span></param>
        <summary><span data-ttu-id="240c7-320">Devuelve el logaritmo de un número especificado en una base determinada.</span><span class="sxs-lookup"><span data-stu-id="240c7-320">Returns the logarithm of a specified number in a specified base.</span></span></summary>
        <returns><span data-ttu-id="240c7-321">Uno de los valores de la tabla siguiente.</span><span class="sxs-lookup"><span data-stu-id="240c7-321">One of the values in the following table.</span></span> <span data-ttu-id="240c7-322">(+Infinito denota <see cref="F:System.Double.PositiveInfinity" />, -Infinito denota <see cref="F:System.Double.NegativeInfinity" /> y NaN denota <see cref="F:System.Double.NaN" />)</span><span class="sxs-lookup"><span data-stu-id="240c7-322">(+Infinity denotes <see cref="F:System.Double.PositiveInfinity" />, -Infinity denotes <see cref="F:System.Double.NegativeInfinity" />, and NaN denotes <see cref="F:System.Double.NaN" />.)</span></span>  
  
 <span data-ttu-id="240c7-323"><list type="table"><listheader><term><paramref name="a" /></term><description><paramref name="newBase" /></description><description> Valor devuelto</span><span class="sxs-lookup"><span data-stu-id="240c7-323"><list type="table"><listheader><term><paramref name="a" /></term><description><paramref name="newBase" /></description><description> Return value</span></span>  
  
 <span data-ttu-id="240c7-324"></description></listheader><item><term><paramref name="a" />&gt; 0</span><span class="sxs-lookup"><span data-stu-id="240c7-324"></description></listheader><item><term><paramref name="a" />&gt; 0</span></span>  
  
 <span data-ttu-id="240c7-325"></term><description> (0 &lt;<paramref name="newBase" />&lt; 1) -o bien-(<paramref name="newBase" />&gt; 1)</span><span class="sxs-lookup"><span data-stu-id="240c7-325"></term><description> (0 &lt;<paramref name="newBase" />&lt; 1) -or-(<paramref name="newBase" />&gt; 1)</span></span>  
  
 <span data-ttu-id="240c7-326"></description><description> lognewBase(a)</span><span class="sxs-lookup"><span data-stu-id="240c7-326"></description><description> lognewBase(a)</span></span>  
  
 <span data-ttu-id="240c7-327"></description></item><item><term><paramref name="a" />&lt; 0</span><span class="sxs-lookup"><span data-stu-id="240c7-327"></description></item><item><term><paramref name="a" />&lt; 0</span></span>  
  
 <span data-ttu-id="240c7-328"></term><description> (cualquier valor)</span><span class="sxs-lookup"><span data-stu-id="240c7-328"></term><description> (any value)</span></span>  
  
 <span data-ttu-id="240c7-329"></description><description> NaN</span><span class="sxs-lookup"><span data-stu-id="240c7-329"></description><description> NaN</span></span>  
  
 <span data-ttu-id="240c7-330"></description></item><item><term> (cualquier valor)</span><span class="sxs-lookup"><span data-stu-id="240c7-330"></description></item><item><term> (any value)</span></span>  
  
 <span data-ttu-id="240c7-331"></term><description><paramref name="newBase" />&lt; 0</span><span class="sxs-lookup"><span data-stu-id="240c7-331"></term><description><paramref name="newBase" />&lt; 0</span></span>  
  
 <span data-ttu-id="240c7-332"></description><description> NaN</span><span class="sxs-lookup"><span data-stu-id="240c7-332"></description><description> NaN</span></span>  
  
 <span data-ttu-id="240c7-333"></description></item><item><term><paramref name="a" /> != 1</span><span class="sxs-lookup"><span data-stu-id="240c7-333"></description></item><item><term><paramref name="a" /> != 1</span></span>  
  
 <span data-ttu-id="240c7-334"></term><description><paramref name="newBase" /> = 0</span><span class="sxs-lookup"><span data-stu-id="240c7-334"></term><description><paramref name="newBase" /> = 0</span></span>  
  
 <span data-ttu-id="240c7-335"></description><description> NaN</span><span class="sxs-lookup"><span data-stu-id="240c7-335"></description><description> NaN</span></span>  
  
 <span data-ttu-id="240c7-336"></description></item><item><term><paramref name="a" /> != 1</span><span class="sxs-lookup"><span data-stu-id="240c7-336"></description></item><item><term><paramref name="a" /> != 1</span></span>  
  
 <span data-ttu-id="240c7-337"></term><description><paramref name="newBase" /> = +Infinito</span><span class="sxs-lookup"><span data-stu-id="240c7-337"></term><description><paramref name="newBase" /> = +Infinity</span></span>  
  
 <span data-ttu-id="240c7-338"></description><description> NaN</span><span class="sxs-lookup"><span data-stu-id="240c7-338"></description><description> NaN</span></span>  
  
 <span data-ttu-id="240c7-339"></description></item><item><term><paramref name="a" /> = NaN</span><span class="sxs-lookup"><span data-stu-id="240c7-339"></description></item><item><term><paramref name="a" /> = NaN</span></span>  
  
 <span data-ttu-id="240c7-340"></term><description> (cualquier valor)</span><span class="sxs-lookup"><span data-stu-id="240c7-340"></term><description> (any value)</span></span>  
  
 <span data-ttu-id="240c7-341"></description><description> NaN</span><span class="sxs-lookup"><span data-stu-id="240c7-341"></description><description> NaN</span></span>  
  
 <span data-ttu-id="240c7-342"></description></item><item><term> (cualquier valor)</span><span class="sxs-lookup"><span data-stu-id="240c7-342"></description></item><item><term> (any value)</span></span>  
  
 <span data-ttu-id="240c7-343"></term><description><paramref name="newBase" /> = NaN</span><span class="sxs-lookup"><span data-stu-id="240c7-343"></term><description><paramref name="newBase" /> = NaN</span></span>  
  
 <span data-ttu-id="240c7-344"></description><description> NaN</span><span class="sxs-lookup"><span data-stu-id="240c7-344"></description><description> NaN</span></span>  
  
 <span data-ttu-id="240c7-345"></description></item><item><term> (cualquier valor)</span><span class="sxs-lookup"><span data-stu-id="240c7-345"></description></item><item><term> (any value)</span></span>  
  
 <span data-ttu-id="240c7-346"></term><description><paramref name="newBase" /> = 1</span><span class="sxs-lookup"><span data-stu-id="240c7-346"></term><description><paramref name="newBase" /> = 1</span></span>  
  
 <span data-ttu-id="240c7-347"></description><description> NaN</span><span class="sxs-lookup"><span data-stu-id="240c7-347"></description><description> NaN</span></span>  
  
 <span data-ttu-id="240c7-348"></description></item><item><term><paramref name="a" /> = 0</span><span class="sxs-lookup"><span data-stu-id="240c7-348"></description></item><item><term><paramref name="a" /> = 0</span></span>  
  
 <span data-ttu-id="240c7-349"></term><description> 0 &lt;<paramref name="newBase" />&lt; 1</span><span class="sxs-lookup"><span data-stu-id="240c7-349"></term><description> 0 &lt;<paramref name="newBase" />&lt; 1</span></span>  
  
 <span data-ttu-id="240c7-350"></description><description> +Infinito</span><span class="sxs-lookup"><span data-stu-id="240c7-350"></description><description> +Infinity</span></span>  
  
 <span data-ttu-id="240c7-351"></description></item><item><term><paramref name="a" /> = 0</span><span class="sxs-lookup"><span data-stu-id="240c7-351"></description></item><item><term><paramref name="a" /> = 0</span></span>  
  
 <span data-ttu-id="240c7-352"></term><description><paramref name="newBase" />&gt; 1</span><span class="sxs-lookup"><span data-stu-id="240c7-352"></term><description><paramref name="newBase" />&gt; 1</span></span>  
  
 <span data-ttu-id="240c7-353"></description><description> -Infinito</span><span class="sxs-lookup"><span data-stu-id="240c7-353"></description><description> -Infinity</span></span>  
  
 <span data-ttu-id="240c7-354"></description></item><item><term><paramref name="a" /> = +Infinito</span><span class="sxs-lookup"><span data-stu-id="240c7-354"></description></item><item><term><paramref name="a" /> =  +Infinity</span></span>  
  
 <span data-ttu-id="240c7-355"></term><description> 0 &lt;<paramref name="newBase" />&lt; 1</span><span class="sxs-lookup"><span data-stu-id="240c7-355"></term><description> 0 &lt;<paramref name="newBase" />&lt; 1</span></span>  
  
 <span data-ttu-id="240c7-356"></description><description> -Infinito</span><span class="sxs-lookup"><span data-stu-id="240c7-356"></description><description> -Infinity</span></span>  
  
 <span data-ttu-id="240c7-357"></description></item><item><term><paramref name="a" /> = +Infinito</span><span class="sxs-lookup"><span data-stu-id="240c7-357"></description></item><item><term><paramref name="a" /> =  +Infinity</span></span>  
  
 <span data-ttu-id="240c7-358"></term><description><paramref name="newBase" />&gt; 1</span><span class="sxs-lookup"><span data-stu-id="240c7-358"></term><description><paramref name="newBase" />&gt; 1</span></span>  
  
 <span data-ttu-id="240c7-359"></description><description> +Infinito</span><span class="sxs-lookup"><span data-stu-id="240c7-359"></description><description> +Infinity</span></span>  
  
 <span data-ttu-id="240c7-360"></description></item><item><term><paramref name="a" /> = 1</span><span class="sxs-lookup"><span data-stu-id="240c7-360"></description></item><item><term><paramref name="a" /> = 1</span></span>  
  
 <span data-ttu-id="240c7-361"></term><description><paramref name="newBase" /> = 0</span><span class="sxs-lookup"><span data-stu-id="240c7-361"></term><description><paramref name="newBase" /> = 0</span></span>  
  
 <span data-ttu-id="240c7-362"></description><description> 0</span><span class="sxs-lookup"><span data-stu-id="240c7-362"></description><description> 0</span></span>  
  
 <span data-ttu-id="240c7-363"></description></item><item><term><paramref name="a" /> = 1</span><span class="sxs-lookup"><span data-stu-id="240c7-363"></description></item><item><term><paramref name="a" /> = 1</span></span>  
  
 <span data-ttu-id="240c7-364"></term><description><paramref name="newBase" /> = +Infinito</span><span class="sxs-lookup"><span data-stu-id="240c7-364"></term><description><paramref name="newBase" /> = +Infinity</span></span>  
  
 <span data-ttu-id="240c7-365"></description><description> 0</span><span class="sxs-lookup"><span data-stu-id="240c7-365"></description><description> 0</span></span>  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="240c7-366">En el ejemplo siguiente se utiliza <xref:System.Math.Log%2A> para evaluar determinadas identidades logarítmicas de valores seleccionados.</span><span class="sxs-lookup"><span data-stu-id="240c7-366">The following example uses <xref:System.Math.Log%2A> to evaluate certain logarithmic identities for selected values.</span></span>  
  
 [!code-cpp[System.Math.Log_Overloads#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Math.Log_Overloads/CPP/loggen.cpp#1)]
 [!code-csharp[System.Math.Log_Overloads#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Math.Log_Overloads/CS/loggen.cs#1)]
 [!code-vb[System.Math.Log_Overloads#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Math.Log_Overloads/VB/loggen.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Log10">
      <MemberSignature Language="C#" Value="public static double Log10 (double d);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Log10(float64 d) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Log10(System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Log10 (d As Double) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double Log10(double d);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="d"><span data-ttu-id="240c7-367">Número cuyo logaritmo hay que calcular.</span><span class="sxs-lookup"><span data-stu-id="240c7-367">A number whose logarithm is to be found.</span></span></param>
        <summary><span data-ttu-id="240c7-368">Devuelve el logaritmo en base 10 de un número especificado.</span><span class="sxs-lookup"><span data-stu-id="240c7-368">Returns the base 10 logarithm of a specified number.</span></span></summary>
        <returns><span data-ttu-id="240c7-369">Uno de los valores de la tabla siguiente.</span><span class="sxs-lookup"><span data-stu-id="240c7-369">One of the values in the following table.</span></span>  
  
 <span data-ttu-id="240c7-370"><list type="table"><listheader><term>Parámetro <paramref name="d" /></span><span class="sxs-lookup"><span data-stu-id="240c7-370"><list type="table"><listheader><term><paramref name="d" /> parameter</span></span>  
  
 <span data-ttu-id="240c7-371"></term><description> Valor devuelto</span><span class="sxs-lookup"><span data-stu-id="240c7-371"></term><description> Return value</span></span>  
  
 <span data-ttu-id="240c7-372"></description></listheader><item><term> Positivo</span><span class="sxs-lookup"><span data-stu-id="240c7-372"></description></listheader><item><term> Positive</span></span>  
  
 <span data-ttu-id="240c7-373"></term><description> Logaritmo en base 10 de <paramref name="d" />; es decir, log 10<paramref name="d" />.</span><span class="sxs-lookup"><span data-stu-id="240c7-373"></term><description> The base 10 log of <paramref name="d" />; that is, log 10<paramref name="d" />.</span></span>  
  
 <span data-ttu-id="240c7-374"></description></item><item><term> Cero</span><span class="sxs-lookup"><span data-stu-id="240c7-374"></description></item><item><term> Zero</span></span>  
  
 <span data-ttu-id="240c7-375"></term><description><see cref="F:System.Double.NegativeInfinity" /></description></item><item><term> Negativo</span><span class="sxs-lookup"><span data-stu-id="240c7-375"></term><description><see cref="F:System.Double.NegativeInfinity" /></description></item><item><term> Negative</span></span>  
  
 <span data-ttu-id="240c7-376"></term><description><see cref="F:System.Double.NaN" /></description></item><item><term> Igual a <see cref="F:System.Double.NaN" /></term><description><see cref="F:System.Double.NaN" /></description></item><item><term> Igual a <see cref="F:System.Double.PositiveInfinity" /></term><description><see cref="F:System.Double.PositiveInfinity" /></description></item></list></span><span class="sxs-lookup"><span data-stu-id="240c7-376"></term><description><see cref="F:System.Double.NaN" /></description></item><item><term> Equal to <see cref="F:System.Double.NaN" /></term><description><see cref="F:System.Double.NaN" /></description></item><item><term> Equal to <see cref="F:System.Double.PositiveInfinity" /></term><description><see cref="F:System.Double.PositiveInfinity" /></description></item></list></span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="240c7-377">Parámetro `d` se especifica como un número en base 10.</span><span class="sxs-lookup"><span data-stu-id="240c7-377">Parameter `d` is specified as a base 10 number.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="240c7-378">En el ejemplo siguiente se usa el <xref:System.Math.Log10%2A> método para devolver el logaritmo en base 10 de los valores seleccionados.</span><span class="sxs-lookup"><span data-stu-id="240c7-378">The following example uses the <xref:System.Math.Log10%2A> method to return the base 10 logarithm for selected values.</span></span>  
  
 [!code-csharp[System.Math.Log10#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Math.Log10/CS/log10.cs#1)]
 [!code-vb[System.Math.Log10#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Math.Log10/VB/log10.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Max">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="240c7-379">Devuelve el mayor de dos números especificados.</span><span class="sxs-lookup"><span data-stu-id="240c7-379">Returns the larger of two specified numbers.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Max">
      <MemberSignature Language="C#" Value="public static byte Max (byte val1, byte val2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int8 Max(unsigned int8 val1, unsigned int8 val2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Max(System.Byte,System.Byte)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Max (val1 As Byte, val2 As Byte) As Byte" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Byte Max(System::Byte val1, System::Byte val2);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Byte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="val1" Type="System.Byte" />
        <Parameter Name="val2" Type="System.Byte" />
      </Parameters>
      <Docs>
        <param name="val1"><span data-ttu-id="240c7-380">Primer entero de 8 bits sin signo de los dos que se van a comparar.</span><span class="sxs-lookup"><span data-stu-id="240c7-380">The first of two 8-bit unsigned integers to compare.</span></span></param>
        <param name="val2"><span data-ttu-id="240c7-381">Segundo entero de 8 bits sin signo de los dos que se van a comparar.</span><span class="sxs-lookup"><span data-stu-id="240c7-381">The second of two 8-bit unsigned integers to compare.</span></span></param>
        <summary><span data-ttu-id="240c7-382">Devuelve el mayor de dos enteros de 8 bits sin signo.</span><span class="sxs-lookup"><span data-stu-id="240c7-382">Returns the larger of two 8-bit unsigned integers.</span></span></summary>
        <returns><span data-ttu-id="240c7-383">Parámetro <paramref name="val1" /> o <paramref name="val2" />, el que sea mayor.</span><span class="sxs-lookup"><span data-stu-id="240c7-383">Parameter <paramref name="val1" /> or <paramref name="val2" />, whichever is larger.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="240c7-384">En el ejemplo siguiente se muestra cómo utilizar el <xref:System.Math.Max%2A> método para devolver y mostrar la mayor de dos variables.</span><span class="sxs-lookup"><span data-stu-id="240c7-384">The following example demonstrates how to use the <xref:System.Math.Max%2A> method to return and display the greater of two variables.</span></span>  
  
 [!code-cpp[Math.Max#1](~/samples/snippets/cpp/VS_Snippets_CLR/math.max/CPP/max.cpp#1)]
 [!code-csharp[Math.Max#1](~/samples/snippets/csharp/VS_Snippets_CLR/math.max/CS/max.cs#1)]
 [!code-vb[Math.Max#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/math.max/VB/max.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Max">
      <MemberSignature Language="C#" Value="public static decimal Max (decimal val1, decimal val2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Decimal Max(valuetype System.Decimal val1, valuetype System.Decimal val2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Max(System.Decimal,System.Decimal)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Max (val1 As Decimal, val2 As Decimal) As Decimal" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Decimal Max(System::Decimal val1, System::Decimal val2);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="val1" Type="System.Decimal" />
        <Parameter Name="val2" Type="System.Decimal" />
      </Parameters>
      <Docs>
        <param name="val1"><span data-ttu-id="240c7-385">Primer número de dos números decimales que se van a comparar.</span><span class="sxs-lookup"><span data-stu-id="240c7-385">The first of two decimal numbers to compare.</span></span></param>
        <param name="val2"><span data-ttu-id="240c7-386">Segundo número de dos decimales que se van a comparar.</span><span class="sxs-lookup"><span data-stu-id="240c7-386">The second of two decimal numbers to compare.</span></span></param>
        <summary><span data-ttu-id="240c7-387">Devuelve el mayor de dos números decimales.</span><span class="sxs-lookup"><span data-stu-id="240c7-387">Returns the larger of two decimal numbers.</span></span></summary>
        <returns><span data-ttu-id="240c7-388">Parámetro <paramref name="val1" /> o <paramref name="val2" />, el que sea mayor.</span><span class="sxs-lookup"><span data-stu-id="240c7-388">Parameter <paramref name="val1" /> or <paramref name="val2" />, whichever is larger.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="240c7-389">En el ejemplo siguiente se muestra cómo utilizar el <xref:System.Math.Max%2A> método para devolver y mostrar la mayor de dos variables.</span><span class="sxs-lookup"><span data-stu-id="240c7-389">The following example demonstrates how to use the <xref:System.Math.Max%2A> method to return and display the greater of two variables.</span></span>  
  
 [!code-cpp[Math.Max#1](~/samples/snippets/cpp/VS_Snippets_CLR/math.max/CPP/max.cpp#1)]
 [!code-csharp[Math.Max#1](~/samples/snippets/csharp/VS_Snippets_CLR/math.max/CS/max.cs#1)]
 [!code-vb[Math.Max#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/math.max/VB/max.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Max">
      <MemberSignature Language="C#" Value="public static double Max (double val1, double val2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Max(float64 val1, float64 val2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Max(System.Double,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Max (val1 As Double, val2 As Double) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double Max(double val1, double val2);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="val1" Type="System.Double" />
        <Parameter Name="val2" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="val1"><span data-ttu-id="240c7-390">Primer número de punto flotante de precisión doble de los dos que se van a comparar.</span><span class="sxs-lookup"><span data-stu-id="240c7-390">The first of two double-precision floating-point numbers to compare.</span></span></param>
        <param name="val2"><span data-ttu-id="240c7-391">Segundo número de punto flotante de precisión doble de los dos que se van a comparar.</span><span class="sxs-lookup"><span data-stu-id="240c7-391">The second of two double-precision floating-point numbers to compare.</span></span></param>
        <summary><span data-ttu-id="240c7-392">Devuelve el mayor de dos números de punto flotante de precisión doble.</span><span class="sxs-lookup"><span data-stu-id="240c7-392">Returns the larger of two double-precision floating-point numbers.</span></span></summary>
        <returns><span data-ttu-id="240c7-393">Parámetro <paramref name="val1" /> o <paramref name="val2" />, el que sea mayor.</span><span class="sxs-lookup"><span data-stu-id="240c7-393">Parameter <paramref name="val1" /> or <paramref name="val2" />, whichever is larger.</span></span> <span data-ttu-id="240c7-394">Si <paramref name="val1" />, <paramref name="val2" /> o ambos ( <paramref name="val1" /> y <paramref name="val2" />) son iguales que <see cref="F:System.Double.NaN" />, se devuelve <see cref="F:System.Double.NaN" />.</span><span class="sxs-lookup"><span data-stu-id="240c7-394">If <paramref name="val1" />, <paramref name="val2" />, or both <paramref name="val1" /> and <paramref name="val2" /> are equal to <see cref="F:System.Double.NaN" />, <see cref="F:System.Double.NaN" /> is returned.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="240c7-395">En el ejemplo siguiente se muestra cómo utilizar el <xref:System.Math.Max%2A> método para devolver y mostrar la mayor de dos variables.</span><span class="sxs-lookup"><span data-stu-id="240c7-395">The following example demonstrates how to use the <xref:System.Math.Max%2A> method to return and display the greater of two variables.</span></span>  
  
 [!code-cpp[Math.Max#1](~/samples/snippets/cpp/VS_Snippets_CLR/math.max/CPP/max.cpp#1)]
 [!code-csharp[Math.Max#1](~/samples/snippets/csharp/VS_Snippets_CLR/math.max/CS/max.cs#1)]
 [!code-vb[Math.Max#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/math.max/VB/max.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Max">
      <MemberSignature Language="C#" Value="public static short Max (short val1, short val2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int16 Max(int16 val1, int16 val2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Max(System.Int16,System.Int16)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Max (val1 As Short, val2 As Short) As Short" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static short Max(short val1, short val2);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="val1" Type="System.Int16" />
        <Parameter Name="val2" Type="System.Int16" />
      </Parameters>
      <Docs>
        <param name="val1"><span data-ttu-id="240c7-396">Primero de los dos enteros de 16 bits con signo que se van a comparar.</span><span class="sxs-lookup"><span data-stu-id="240c7-396">The first of two 16-bit signed integers to compare.</span></span></param>
        <param name="val2"><span data-ttu-id="240c7-397">Segundo de los dos enteros de 16 bits con signo que se van a comparar.</span><span class="sxs-lookup"><span data-stu-id="240c7-397">The second of two 16-bit signed integers to compare.</span></span></param>
        <summary><span data-ttu-id="240c7-398">Devuelve el mayor de dos enteros de 16 bits con signo.</span><span class="sxs-lookup"><span data-stu-id="240c7-398">Returns the larger of two 16-bit signed integers.</span></span></summary>
        <returns><span data-ttu-id="240c7-399">Parámetro <paramref name="val1" /> o <paramref name="val2" />, el que sea mayor.</span><span class="sxs-lookup"><span data-stu-id="240c7-399">Parameter <paramref name="val1" /> or <paramref name="val2" />, whichever is larger.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="240c7-400">En el ejemplo siguiente se muestra cómo utilizar el <xref:System.Math.Max%2A> método para devolver y mostrar la mayor de dos variables.</span><span class="sxs-lookup"><span data-stu-id="240c7-400">The following example demonstrates how to use the <xref:System.Math.Max%2A> method to return and display the greater of two variables.</span></span>  
  
 [!code-cpp[Math.Max#1](~/samples/snippets/cpp/VS_Snippets_CLR/math.max/CPP/max.cpp#1)]
 [!code-csharp[Math.Max#1](~/samples/snippets/csharp/VS_Snippets_CLR/math.max/CS/max.cs#1)]
 [!code-vb[Math.Max#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/math.max/VB/max.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Max">
      <MemberSignature Language="C#" Value="public static int Max (int val1, int val2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Max(int32 val1, int32 val2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Max(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Max (val1 As Integer, val2 As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Max(int val1, int val2);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="val1" Type="System.Int32" />
        <Parameter Name="val2" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="val1"><span data-ttu-id="240c7-401">Primero de los dos enteros de 32 bits con signo que se van a comparar.</span><span class="sxs-lookup"><span data-stu-id="240c7-401">The first of two 32-bit signed integers to compare.</span></span></param>
        <param name="val2"><span data-ttu-id="240c7-402">Segundo de los dos enteros de 32 bits con signo que se van a comparar.</span><span class="sxs-lookup"><span data-stu-id="240c7-402">The second of two 32-bit signed integers to compare.</span></span></param>
        <summary><span data-ttu-id="240c7-403">Devuelve el mayor de dos enteros de 32 bits con signo.</span><span class="sxs-lookup"><span data-stu-id="240c7-403">Returns the larger of two 32-bit signed integers.</span></span></summary>
        <returns><span data-ttu-id="240c7-404">Parámetro <paramref name="val1" /> o <paramref name="val2" />, el que sea mayor.</span><span class="sxs-lookup"><span data-stu-id="240c7-404">Parameter <paramref name="val1" /> or <paramref name="val2" />, whichever is larger.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="240c7-405">En el ejemplo siguiente se muestra cómo utilizar el <xref:System.Math.Max%2A> método para devolver y mostrar la mayor de dos variables.</span><span class="sxs-lookup"><span data-stu-id="240c7-405">The following example demonstrates how to use the <xref:System.Math.Max%2A> method to return and display the greater of two variables.</span></span>  
  
 [!code-cpp[Math.Max#1](~/samples/snippets/cpp/VS_Snippets_CLR/math.max/CPP/max.cpp#1)]
 [!code-csharp[Math.Max#1](~/samples/snippets/csharp/VS_Snippets_CLR/math.max/CS/max.cs#1)]
 [!code-vb[Math.Max#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/math.max/VB/max.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Max">
      <MemberSignature Language="C#" Value="public static long Max (long val1, long val2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 Max(int64 val1, int64 val2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Max(System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Max (val1 As Long, val2 As Long) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static long Max(long val1, long val2);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="val1" Type="System.Int64" />
        <Parameter Name="val2" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="val1"><span data-ttu-id="240c7-406">Primero de los dos enteros de 64 bits con signo que se van a comparar.</span><span class="sxs-lookup"><span data-stu-id="240c7-406">The first of two 64-bit signed integers to compare.</span></span></param>
        <param name="val2"><span data-ttu-id="240c7-407">Segundo de los dos enteros de 64 bits con signo que se van a comparar.</span><span class="sxs-lookup"><span data-stu-id="240c7-407">The second of two 64-bit signed integers to compare.</span></span></param>
        <summary><span data-ttu-id="240c7-408">Devuelve el mayor de dos enteros de 64 bits con signo.</span><span class="sxs-lookup"><span data-stu-id="240c7-408">Returns the larger of two 64-bit signed integers.</span></span></summary>
        <returns><span data-ttu-id="240c7-409">Parámetro <paramref name="val1" /> o <paramref name="val2" />, el que sea mayor.</span><span class="sxs-lookup"><span data-stu-id="240c7-409">Parameter <paramref name="val1" /> or <paramref name="val2" />, whichever is larger.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="240c7-410">En el ejemplo siguiente se muestra cómo utilizar el <xref:System.Math.Max%2A> método para devolver y mostrar la mayor de dos variables.</span><span class="sxs-lookup"><span data-stu-id="240c7-410">The following example demonstrates how to use the <xref:System.Math.Max%2A> method to return and display the greater of two variables.</span></span>  
  
 [!code-cpp[Math.Max#1](~/samples/snippets/cpp/VS_Snippets_CLR/math.max/CPP/max.cpp#1)]
 [!code-csharp[Math.Max#1](~/samples/snippets/csharp/VS_Snippets_CLR/math.max/CS/max.cs#1)]
 [!code-vb[Math.Max#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/math.max/VB/max.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Max">
      <MemberSignature Language="C#" Value="public static sbyte Max (sbyte val1, sbyte val2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int8 Max(int8 val1, int8 val2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Max(System.SByte,System.SByte)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Max (val1 As SByte, val2 As SByte) As SByte" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::SByte Max(System::SByte val1, System::SByte val2);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.SByte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="val1" Type="System.SByte" />
        <Parameter Name="val2" Type="System.SByte" />
      </Parameters>
      <Docs>
        <param name="val1"><span data-ttu-id="240c7-411">Primero de los dos enteros de 8 bits con signo que se van a comparar.</span><span class="sxs-lookup"><span data-stu-id="240c7-411">The first of two 8-bit signed integers to compare.</span></span></param>
        <param name="val2"><span data-ttu-id="240c7-412">Segundo de los dos enteros de 8 bits con signo que se van a comparar.</span><span class="sxs-lookup"><span data-stu-id="240c7-412">The second of two 8-bit signed integers to compare.</span></span></param>
        <summary><span data-ttu-id="240c7-413">Devuelve el mayor de dos enteros de 8 bits con signo.</span><span class="sxs-lookup"><span data-stu-id="240c7-413">Returns the larger of two 8-bit signed integers.</span></span></summary>
        <returns><span data-ttu-id="240c7-414">Parámetro <paramref name="val1" /> o <paramref name="val2" />, el que sea mayor.</span><span class="sxs-lookup"><span data-stu-id="240c7-414">Parameter <paramref name="val1" /> or <paramref name="val2" />, whichever is larger.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="240c7-415">En el ejemplo siguiente se muestra cómo utilizar el <xref:System.Math.Max%2A> método para devolver y mostrar la mayor de dos variables.</span><span class="sxs-lookup"><span data-stu-id="240c7-415">The following example demonstrates how to use the <xref:System.Math.Max%2A> method to return and display the greater of two variables.</span></span>  
  
 [!code-cpp[Math.Max#1](~/samples/snippets/cpp/VS_Snippets_CLR/math.max/CPP/max.cpp#1)]
 [!code-csharp[Math.Max#1](~/samples/snippets/csharp/VS_Snippets_CLR/math.max/CS/max.cs#1)]
 [!code-vb[Math.Max#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/math.max/VB/max.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Max">
      <MemberSignature Language="C#" Value="public static float Max (float val1, float val2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 Max(float32 val1, float32 val2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Max(System.Single,System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Max (val1 As Single, val2 As Single) As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static float Max(float val1, float val2);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="val1" Type="System.Single" />
        <Parameter Name="val2" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="val1"><span data-ttu-id="240c7-416">Primer número de punto flotante de precisión sencilla de los dos que se van a comparar.</span><span class="sxs-lookup"><span data-stu-id="240c7-416">The first of two single-precision floating-point numbers to compare.</span></span></param>
        <param name="val2"><span data-ttu-id="240c7-417">Segundo número de punto flotante de precisión sencilla de los dos que se van a comparar.</span><span class="sxs-lookup"><span data-stu-id="240c7-417">The second of two single-precision floating-point numbers to compare.</span></span></param>
        <summary><span data-ttu-id="240c7-418">Devuelve el mayor de dos números de punto flotante de precisión sencilla.</span><span class="sxs-lookup"><span data-stu-id="240c7-418">Returns the larger of two single-precision floating-point numbers.</span></span></summary>
        <returns><span data-ttu-id="240c7-419">Parámetro <paramref name="val1" /> o <paramref name="val2" />, el que sea mayor.</span><span class="sxs-lookup"><span data-stu-id="240c7-419">Parameter <paramref name="val1" /> or <paramref name="val2" />, whichever is larger.</span></span> <span data-ttu-id="240c7-420">Si <paramref name="val1" /> o <paramref name="val2" />, o ambos (<paramref name="val1" /> y <paramref name="val2" />) son iguales a <see cref="F:System.Single.NaN" />, <see cref="F:System.Single.NaN" /> se devuelve.</span><span class="sxs-lookup"><span data-stu-id="240c7-420">If <paramref name="val1" />, or <paramref name="val2" />, or both <paramref name="val1" /> and <paramref name="val2" /> are equal to <see cref="F:System.Single.NaN" />, <see cref="F:System.Single.NaN" /> is returned.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="240c7-421">En el ejemplo siguiente se muestra cómo utilizar el <xref:System.Math.Max%2A> método para devolver y mostrar la mayor de dos variables.</span><span class="sxs-lookup"><span data-stu-id="240c7-421">The following example demonstrates how to use the <xref:System.Math.Max%2A> method to return and display the greater of two variables.</span></span>  
  
 [!code-cpp[Math.Max#1](~/samples/snippets/cpp/VS_Snippets_CLR/math.max/CPP/max.cpp#1)]
 [!code-csharp[Math.Max#1](~/samples/snippets/csharp/VS_Snippets_CLR/math.max/CS/max.cs#1)]
 [!code-vb[Math.Max#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/math.max/VB/max.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Max">
      <MemberSignature Language="C#" Value="public static ushort Max (ushort val1, ushort val2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int16 Max(unsigned int16 val1, unsigned int16 val2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Max(System.UInt16,System.UInt16)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Max (val1 As UShort, val2 As UShort) As UShort" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::UInt16 Max(System::UInt16 val1, System::UInt16 val2);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="val1" Type="System.UInt16" />
        <Parameter Name="val2" Type="System.UInt16" />
      </Parameters>
      <Docs>
        <param name="val1"><span data-ttu-id="240c7-422">Primer entero de 16 bits sin signo de los dos que se van a comparar.</span><span class="sxs-lookup"><span data-stu-id="240c7-422">The first of two 16-bit unsigned integers to compare.</span></span></param>
        <param name="val2"><span data-ttu-id="240c7-423">Segundo entero de 16 bits sin signo de los dos que se van a comparar.</span><span class="sxs-lookup"><span data-stu-id="240c7-423">The second of two 16-bit unsigned integers to compare.</span></span></param>
        <summary><span data-ttu-id="240c7-424">Devuelve el mayor de dos enteros de 16 bits sin signo.</span><span class="sxs-lookup"><span data-stu-id="240c7-424">Returns the larger of two 16-bit unsigned integers.</span></span></summary>
        <returns><span data-ttu-id="240c7-425">Parámetro <paramref name="val1" /> o <paramref name="val2" />, el que sea mayor.</span><span class="sxs-lookup"><span data-stu-id="240c7-425">Parameter <paramref name="val1" /> or <paramref name="val2" />, whichever is larger.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="240c7-426">En el ejemplo siguiente se muestra cómo utilizar el <xref:System.Math.Max%2A> método para devolver y mostrar la mayor de dos variables.</span><span class="sxs-lookup"><span data-stu-id="240c7-426">The following example demonstrates how to use the <xref:System.Math.Max%2A> method to return and display the greater of two variables.</span></span>  
  
 [!code-cpp[Math.Max#1](~/samples/snippets/cpp/VS_Snippets_CLR/math.max/CPP/max.cpp#1)]
 [!code-csharp[Math.Max#1](~/samples/snippets/csharp/VS_Snippets_CLR/math.max/CS/max.cs#1)]
 [!code-vb[Math.Max#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/math.max/VB/max.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Max">
      <MemberSignature Language="C#" Value="public static uint Max (uint val1, uint val2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int32 Max(unsigned int32 val1, unsigned int32 val2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Max(System.UInt32,System.UInt32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Max (val1 As UInteger, val2 As UInteger) As UInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::UInt32 Max(System::UInt32 val1, System::UInt32 val2);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="val1" Type="System.UInt32" />
        <Parameter Name="val2" Type="System.UInt32" />
      </Parameters>
      <Docs>
        <param name="val1"><span data-ttu-id="240c7-427">Primer entero de 32 bits sin signo de los dos que se van a comparar.</span><span class="sxs-lookup"><span data-stu-id="240c7-427">The first of two 32-bit unsigned integers to compare.</span></span></param>
        <param name="val2"><span data-ttu-id="240c7-428">Segundo entero de 32 bits sin signo de los dos que se van a comparar.</span><span class="sxs-lookup"><span data-stu-id="240c7-428">The second of two 32-bit unsigned integers to compare.</span></span></param>
        <summary><span data-ttu-id="240c7-429">Devuelve el mayor de dos enteros de 32 bits sin signo.</span><span class="sxs-lookup"><span data-stu-id="240c7-429">Returns the larger of two 32-bit unsigned integers.</span></span></summary>
        <returns><span data-ttu-id="240c7-430">Parámetro <paramref name="val1" /> o <paramref name="val2" />, el que sea mayor.</span><span class="sxs-lookup"><span data-stu-id="240c7-430">Parameter <paramref name="val1" /> or <paramref name="val2" />, whichever is larger.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="240c7-431">En el ejemplo siguiente se muestra cómo utilizar el <xref:System.Math.Max%2A> método para devolver y mostrar la mayor de dos variables.</span><span class="sxs-lookup"><span data-stu-id="240c7-431">The following example demonstrates how to use the <xref:System.Math.Max%2A> method to return and display the greater of two variables.</span></span>  
  
 [!code-cpp[Math.Max#1](~/samples/snippets/cpp/VS_Snippets_CLR/math.max/CPP/max.cpp#1)]
 [!code-csharp[Math.Max#1](~/samples/snippets/csharp/VS_Snippets_CLR/math.max/CS/max.cs#1)]
 [!code-vb[Math.Max#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/math.max/VB/max.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Max">
      <MemberSignature Language="C#" Value="public static ulong Max (ulong val1, ulong val2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int64 Max(unsigned int64 val1, unsigned int64 val2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Max(System.UInt64,System.UInt64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Max (val1 As ULong, val2 As ULong) As ULong" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::UInt64 Max(System::UInt64 val1, System::UInt64 val2);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="val1" Type="System.UInt64" />
        <Parameter Name="val2" Type="System.UInt64" />
      </Parameters>
      <Docs>
        <param name="val1"><span data-ttu-id="240c7-432">Primer entero de 64 bits sin signo de los dos que se van a comparar.</span><span class="sxs-lookup"><span data-stu-id="240c7-432">The first of two 64-bit unsigned integers to compare.</span></span></param>
        <param name="val2"><span data-ttu-id="240c7-433">Segundo entero de 64 bits sin signo de los dos que se van a comparar.</span><span class="sxs-lookup"><span data-stu-id="240c7-433">The second of two 64-bit unsigned integers to compare.</span></span></param>
        <summary><span data-ttu-id="240c7-434">Devuelve el mayor de dos enteros de 64 bits sin signo.</span><span class="sxs-lookup"><span data-stu-id="240c7-434">Returns the larger of two 64-bit unsigned integers.</span></span></summary>
        <returns><span data-ttu-id="240c7-435">Parámetro <paramref name="val1" /> o <paramref name="val2" />, el que sea mayor.</span><span class="sxs-lookup"><span data-stu-id="240c7-435">Parameter <paramref name="val1" /> or <paramref name="val2" />, whichever is larger.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="240c7-436">En el ejemplo siguiente se muestra cómo utilizar el <xref:System.Math.Max%2A> método para devolver y mostrar la mayor de dos variables.</span><span class="sxs-lookup"><span data-stu-id="240c7-436">The following example demonstrates how to use the <xref:System.Math.Max%2A> method to return and display the greater of two variables.</span></span>  
  
 [!code-cpp[Math.Max#1](~/samples/snippets/cpp/VS_Snippets_CLR/math.max/CPP/max.cpp#1)]
 [!code-csharp[Math.Max#1](~/samples/snippets/csharp/VS_Snippets_CLR/math.max/CS/max.cs#1)]
 [!code-vb[Math.Max#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/math.max/VB/max.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Min">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="240c7-437">Devuelve el menor de dos números.</span><span class="sxs-lookup"><span data-stu-id="240c7-437">Returns the smaller of two numbers.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Min">
      <MemberSignature Language="C#" Value="public static byte Min (byte val1, byte val2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int8 Min(unsigned int8 val1, unsigned int8 val2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Min(System.Byte,System.Byte)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Min (val1 As Byte, val2 As Byte) As Byte" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Byte Min(System::Byte val1, System::Byte val2);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Byte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="val1" Type="System.Byte" />
        <Parameter Name="val2" Type="System.Byte" />
      </Parameters>
      <Docs>
        <param name="val1"><span data-ttu-id="240c7-438">Primer entero de 8 bits sin signo de los dos que se van a comparar.</span><span class="sxs-lookup"><span data-stu-id="240c7-438">The first of two 8-bit unsigned integers to compare.</span></span></param>
        <param name="val2"><span data-ttu-id="240c7-439">Segundo entero de 8 bits sin signo de los dos que se van a comparar.</span><span class="sxs-lookup"><span data-stu-id="240c7-439">The second of two 8-bit unsigned integers to compare.</span></span></param>
        <summary><span data-ttu-id="240c7-440">Devuelve el menor de dos enteros de 8 bits sin signo.</span><span class="sxs-lookup"><span data-stu-id="240c7-440">Returns the smaller of two 8-bit unsigned integers.</span></span></summary>
        <returns><span data-ttu-id="240c7-441">Parámetro <paramref name="val1" /> o <paramref name="val2" />, el que sea menor.</span><span class="sxs-lookup"><span data-stu-id="240c7-441">Parameter <paramref name="val1" /> or <paramref name="val2" />, whichever is smaller.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="240c7-442">En el ejemplo siguiente se muestra cómo utilizar el <xref:System.Math.Min%2A> método para devolver y mostrar la menor de dos variables.</span><span class="sxs-lookup"><span data-stu-id="240c7-442">The following example demonstrates how to use the <xref:System.Math.Min%2A> method to return and display the smaller of two variables.</span></span>  
  
 [!code-cpp[Math.Min#1](~/samples/snippets/cpp/VS_Snippets_CLR/math.min/CPP/min.cpp#1)]
 [!code-csharp[Math.Min#1](~/samples/snippets/csharp/VS_Snippets_CLR/math.min/CS/min.cs#1)]
 [!code-vb[Math.Min#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/math.min/VB/min.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Min">
      <MemberSignature Language="C#" Value="public static decimal Min (decimal val1, decimal val2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Decimal Min(valuetype System.Decimal val1, valuetype System.Decimal val2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Min(System.Decimal,System.Decimal)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Min (val1 As Decimal, val2 As Decimal) As Decimal" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Decimal Min(System::Decimal val1, System::Decimal val2);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="val1" Type="System.Decimal" />
        <Parameter Name="val2" Type="System.Decimal" />
      </Parameters>
      <Docs>
        <param name="val1"><span data-ttu-id="240c7-443">Primer número de dos números decimales que se van a comparar.</span><span class="sxs-lookup"><span data-stu-id="240c7-443">The first of two decimal numbers to compare.</span></span></param>
        <param name="val2"><span data-ttu-id="240c7-444">Segundo número de dos decimales que se van a comparar.</span><span class="sxs-lookup"><span data-stu-id="240c7-444">The second of two decimal numbers to compare.</span></span></param>
        <summary><span data-ttu-id="240c7-445">Devuelve el menor de dos números decimales.</span><span class="sxs-lookup"><span data-stu-id="240c7-445">Returns the smaller of two decimal numbers.</span></span></summary>
        <returns><span data-ttu-id="240c7-446">Parámetro <paramref name="val1" /> o <paramref name="val2" />, el que sea menor.</span><span class="sxs-lookup"><span data-stu-id="240c7-446">Parameter <paramref name="val1" /> or <paramref name="val2" />, whichever is smaller.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="240c7-447">En el ejemplo siguiente se muestra cómo utilizar el <xref:System.Math.Min%2A> método para devolver y mostrar la menor de dos variables.</span><span class="sxs-lookup"><span data-stu-id="240c7-447">The following example demonstrates how to use the <xref:System.Math.Min%2A> method to return and display the smaller of two variables.</span></span>  
  
 [!code-cpp[Math.Min#1](~/samples/snippets/cpp/VS_Snippets_CLR/math.min/CPP/min.cpp#1)]
 [!code-csharp[Math.Min#1](~/samples/snippets/csharp/VS_Snippets_CLR/math.min/CS/min.cs#1)]
 [!code-vb[Math.Min#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/math.min/VB/min.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Min">
      <MemberSignature Language="C#" Value="public static double Min (double val1, double val2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Min(float64 val1, float64 val2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Min(System.Double,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Min (val1 As Double, val2 As Double) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double Min(double val1, double val2);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="val1" Type="System.Double" />
        <Parameter Name="val2" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="val1"><span data-ttu-id="240c7-448">Primer número de punto flotante de precisión doble de los dos que se van a comparar.</span><span class="sxs-lookup"><span data-stu-id="240c7-448">The first of two double-precision floating-point numbers to compare.</span></span></param>
        <param name="val2"><span data-ttu-id="240c7-449">Segundo número de punto flotante de precisión doble de los dos que se van a comparar.</span><span class="sxs-lookup"><span data-stu-id="240c7-449">The second of two double-precision floating-point numbers to compare.</span></span></param>
        <summary><span data-ttu-id="240c7-450">Devuelve el menor de dos números de punto flotante de precisión doble.</span><span class="sxs-lookup"><span data-stu-id="240c7-450">Returns the smaller of two double-precision floating-point numbers.</span></span></summary>
        <returns><span data-ttu-id="240c7-451">Parámetro <paramref name="val1" /> o <paramref name="val2" />, el que sea menor.</span><span class="sxs-lookup"><span data-stu-id="240c7-451">Parameter <paramref name="val1" /> or <paramref name="val2" />, whichever is smaller.</span></span> <span data-ttu-id="240c7-452">Si <paramref name="val1" />, <paramref name="val2" /> o ambos ( <paramref name="val1" /> y <paramref name="val2" />) son iguales que <see cref="F:System.Double.NaN" />, se devuelve <see cref="F:System.Double.NaN" />.</span><span class="sxs-lookup"><span data-stu-id="240c7-452">If <paramref name="val1" />, <paramref name="val2" />, or both <paramref name="val1" /> and <paramref name="val2" /> are equal to <see cref="F:System.Double.NaN" />, <see cref="F:System.Double.NaN" /> is returned.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="240c7-453">En el ejemplo siguiente se muestra cómo utilizar el <xref:System.Math.Min%2A> método para devolver y mostrar la menor de dos variables.</span><span class="sxs-lookup"><span data-stu-id="240c7-453">The following example demonstrates how to use the <xref:System.Math.Min%2A> method to return and display the smaller of two variables.</span></span>  
  
 [!code-cpp[Math.Min#1](~/samples/snippets/cpp/VS_Snippets_CLR/math.min/CPP/min.cpp#1)]
 [!code-csharp[Math.Min#1](~/samples/snippets/csharp/VS_Snippets_CLR/math.min/CS/min.cs#1)]
 [!code-vb[Math.Min#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/math.min/VB/min.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Min">
      <MemberSignature Language="C#" Value="public static short Min (short val1, short val2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int16 Min(int16 val1, int16 val2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Min(System.Int16,System.Int16)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Min (val1 As Short, val2 As Short) As Short" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static short Min(short val1, short val2);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="val1" Type="System.Int16" />
        <Parameter Name="val2" Type="System.Int16" />
      </Parameters>
      <Docs>
        <param name="val1"><span data-ttu-id="240c7-454">Primero de los dos enteros de 16 bits con signo que se van a comparar.</span><span class="sxs-lookup"><span data-stu-id="240c7-454">The first of two 16-bit signed integers to compare.</span></span></param>
        <param name="val2"><span data-ttu-id="240c7-455">Segundo de los dos enteros de 16 bits con signo que se van a comparar.</span><span class="sxs-lookup"><span data-stu-id="240c7-455">The second of two 16-bit signed integers to compare.</span></span></param>
        <summary><span data-ttu-id="240c7-456">Devuelve el menor de dos enteros de 16 bits con signo.</span><span class="sxs-lookup"><span data-stu-id="240c7-456">Returns the smaller of two 16-bit signed integers.</span></span></summary>
        <returns><span data-ttu-id="240c7-457">Parámetro <paramref name="val1" /> o <paramref name="val2" />, el que sea menor.</span><span class="sxs-lookup"><span data-stu-id="240c7-457">Parameter <paramref name="val1" /> or <paramref name="val2" />, whichever is smaller.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="240c7-458">En el ejemplo siguiente se muestra cómo utilizar el <xref:System.Math.Min%2A> método para devolver y mostrar la menor de dos variables.</span><span class="sxs-lookup"><span data-stu-id="240c7-458">The following example demonstrates how to use the <xref:System.Math.Min%2A> method to return and display the smaller of two variables.</span></span>  
  
 [!code-cpp[Math.Min#1](~/samples/snippets/cpp/VS_Snippets_CLR/math.min/CPP/min.cpp#1)]
 [!code-csharp[Math.Min#1](~/samples/snippets/csharp/VS_Snippets_CLR/math.min/CS/min.cs#1)]
 [!code-vb[Math.Min#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/math.min/VB/min.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Min">
      <MemberSignature Language="C#" Value="public static int Min (int val1, int val2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Min(int32 val1, int32 val2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Min(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Min (val1 As Integer, val2 As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Min(int val1, int val2);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="val1" Type="System.Int32" />
        <Parameter Name="val2" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="val1"><span data-ttu-id="240c7-459">Primero de los dos enteros de 32 bits con signo que se van a comparar.</span><span class="sxs-lookup"><span data-stu-id="240c7-459">The first of two 32-bit signed integers to compare.</span></span></param>
        <param name="val2"><span data-ttu-id="240c7-460">Segundo de los dos enteros de 32 bits con signo que se van a comparar.</span><span class="sxs-lookup"><span data-stu-id="240c7-460">The second of two 32-bit signed integers to compare.</span></span></param>
        <summary><span data-ttu-id="240c7-461">Devuelve el menor de dos enteros de 32 bits con signo.</span><span class="sxs-lookup"><span data-stu-id="240c7-461">Returns the smaller of two 32-bit signed integers.</span></span></summary>
        <returns><span data-ttu-id="240c7-462">Parámetro <paramref name="val1" /> o <paramref name="val2" />, el que sea menor.</span><span class="sxs-lookup"><span data-stu-id="240c7-462">Parameter <paramref name="val1" /> or <paramref name="val2" />, whichever is smaller.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="240c7-463">En el ejemplo siguiente se muestra cómo utilizar el <xref:System.Math.Min%2A> método para devolver y mostrar la menor de dos variables.</span><span class="sxs-lookup"><span data-stu-id="240c7-463">The following example demonstrates how to use the <xref:System.Math.Min%2A> method to return and display the smaller of two variables.</span></span>  
  
 [!code-cpp[Math.Min#1](~/samples/snippets/cpp/VS_Snippets_CLR/math.min/CPP/min.cpp#1)]
 [!code-csharp[Math.Min#1](~/samples/snippets/csharp/VS_Snippets_CLR/math.min/CS/min.cs#1)]
 [!code-vb[Math.Min#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/math.min/VB/min.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Min">
      <MemberSignature Language="C#" Value="public static long Min (long val1, long val2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 Min(int64 val1, int64 val2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Min(System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Min (val1 As Long, val2 As Long) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static long Min(long val1, long val2);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="val1" Type="System.Int64" />
        <Parameter Name="val2" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="val1"><span data-ttu-id="240c7-464">Primero de los dos enteros de 64 bits con signo que se van a comparar.</span><span class="sxs-lookup"><span data-stu-id="240c7-464">The first of two 64-bit signed integers to compare.</span></span></param>
        <param name="val2"><span data-ttu-id="240c7-465">Segundo de los dos enteros de 64 bits con signo que se van a comparar.</span><span class="sxs-lookup"><span data-stu-id="240c7-465">The second of two 64-bit signed integers to compare.</span></span></param>
        <summary><span data-ttu-id="240c7-466">Devuelve el menor de dos enteros de 64 bits con signo.</span><span class="sxs-lookup"><span data-stu-id="240c7-466">Returns the smaller of two 64-bit signed integers.</span></span></summary>
        <returns><span data-ttu-id="240c7-467">Parámetro <paramref name="val1" /> o <paramref name="val2" />, el que sea menor.</span><span class="sxs-lookup"><span data-stu-id="240c7-467">Parameter <paramref name="val1" /> or <paramref name="val2" />, whichever is smaller.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="240c7-468">En el ejemplo siguiente se muestra cómo utilizar el <xref:System.Math.Min%2A> método para devolver y mostrar la menor de dos variables.</span><span class="sxs-lookup"><span data-stu-id="240c7-468">The following example demonstrates how to use the <xref:System.Math.Min%2A> method to return and display the smaller of two variables.</span></span>  
  
 [!code-cpp[Math.Min#1](~/samples/snippets/cpp/VS_Snippets_CLR/math.min/CPP/min.cpp#1)]
 [!code-csharp[Math.Min#1](~/samples/snippets/csharp/VS_Snippets_CLR/math.min/CS/min.cs#1)]
 [!code-vb[Math.Min#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/math.min/VB/min.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Min">
      <MemberSignature Language="C#" Value="public static sbyte Min (sbyte val1, sbyte val2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int8 Min(int8 val1, int8 val2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Min(System.SByte,System.SByte)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Min (val1 As SByte, val2 As SByte) As SByte" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::SByte Min(System::SByte val1, System::SByte val2);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.SByte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="val1" Type="System.SByte" />
        <Parameter Name="val2" Type="System.SByte" />
      </Parameters>
      <Docs>
        <param name="val1"><span data-ttu-id="240c7-469">Primero de los dos enteros de 8 bits con signo que se van a comparar.</span><span class="sxs-lookup"><span data-stu-id="240c7-469">The first of two 8-bit signed integers to compare.</span></span></param>
        <param name="val2"><span data-ttu-id="240c7-470">Segundo de los dos enteros de 8 bits con signo que se van a comparar.</span><span class="sxs-lookup"><span data-stu-id="240c7-470">The second of two 8-bit signed integers to compare.</span></span></param>
        <summary><span data-ttu-id="240c7-471">Devuelve el menor de dos enteros de 8 bits con signo.</span><span class="sxs-lookup"><span data-stu-id="240c7-471">Returns the smaller of two 8-bit signed integers.</span></span></summary>
        <returns><span data-ttu-id="240c7-472">Parámetro <paramref name="val1" /> o <paramref name="val2" />, el que sea menor.</span><span class="sxs-lookup"><span data-stu-id="240c7-472">Parameter <paramref name="val1" /> or <paramref name="val2" />, whichever is smaller.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="240c7-473">En el ejemplo siguiente se muestra cómo utilizar el <xref:System.Math.Min%2A> método para devolver y mostrar la menor de dos variables.</span><span class="sxs-lookup"><span data-stu-id="240c7-473">The following example demonstrates how to use the <xref:System.Math.Min%2A> method to return and display the smaller of two variables.</span></span>  
  
 [!code-cpp[Math.Min#1](~/samples/snippets/cpp/VS_Snippets_CLR/math.min/CPP/min.cpp#1)]
 [!code-csharp[Math.Min#1](~/samples/snippets/csharp/VS_Snippets_CLR/math.min/CS/min.cs#1)]
 [!code-vb[Math.Min#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/math.min/VB/min.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Min">
      <MemberSignature Language="C#" Value="public static float Min (float val1, float val2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 Min(float32 val1, float32 val2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Min(System.Single,System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Min (val1 As Single, val2 As Single) As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static float Min(float val1, float val2);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="val1" Type="System.Single" />
        <Parameter Name="val2" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="val1"><span data-ttu-id="240c7-474">Primer número de punto flotante de precisión sencilla de los dos que se van a comparar.</span><span class="sxs-lookup"><span data-stu-id="240c7-474">The first of two single-precision floating-point numbers to compare.</span></span></param>
        <param name="val2"><span data-ttu-id="240c7-475">Segundo número de punto flotante de precisión sencilla de los dos que se van a comparar.</span><span class="sxs-lookup"><span data-stu-id="240c7-475">The second of two single-precision floating-point numbers to compare.</span></span></param>
        <summary><span data-ttu-id="240c7-476">Devuelve el menor de dos números de punto flotante de precisión sencilla.</span><span class="sxs-lookup"><span data-stu-id="240c7-476">Returns the smaller of two single-precision floating-point numbers.</span></span></summary>
        <returns><span data-ttu-id="240c7-477">Parámetro <paramref name="val1" /> o <paramref name="val2" />, el que sea menor.</span><span class="sxs-lookup"><span data-stu-id="240c7-477">Parameter <paramref name="val1" /> or <paramref name="val2" />, whichever is smaller.</span></span> <span data-ttu-id="240c7-478">Si <paramref name="val1" />, <paramref name="val2" /> o ambos ( <paramref name="val1" /> y <paramref name="val2" />) son iguales que <see cref="F:System.Single.NaN" />, se devuelve <see cref="F:System.Single.NaN" />.</span><span class="sxs-lookup"><span data-stu-id="240c7-478">If <paramref name="val1" />, <paramref name="val2" />, or both <paramref name="val1" /> and <paramref name="val2" /> are equal to <see cref="F:System.Single.NaN" />, <see cref="F:System.Single.NaN" /> is returned.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="240c7-479">En el ejemplo siguiente se muestra cómo utilizar el <xref:System.Math.Min%2A> método para devolver y mostrar la menor de dos variables.</span><span class="sxs-lookup"><span data-stu-id="240c7-479">The following example demonstrates how to use the <xref:System.Math.Min%2A> method to return and display the smaller of two variables.</span></span>  
  
 [!code-cpp[Math.Min#1](~/samples/snippets/cpp/VS_Snippets_CLR/math.min/CPP/min.cpp#1)]
 [!code-csharp[Math.Min#1](~/samples/snippets/csharp/VS_Snippets_CLR/math.min/CS/min.cs#1)]
 [!code-vb[Math.Min#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/math.min/VB/min.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Min">
      <MemberSignature Language="C#" Value="public static ushort Min (ushort val1, ushort val2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int16 Min(unsigned int16 val1, unsigned int16 val2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Min(System.UInt16,System.UInt16)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Min (val1 As UShort, val2 As UShort) As UShort" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::UInt16 Min(System::UInt16 val1, System::UInt16 val2);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="val1" Type="System.UInt16" />
        <Parameter Name="val2" Type="System.UInt16" />
      </Parameters>
      <Docs>
        <param name="val1"><span data-ttu-id="240c7-480">Primer entero de 16 bits sin signo de los dos que se van a comparar.</span><span class="sxs-lookup"><span data-stu-id="240c7-480">The first of two 16-bit unsigned integers to compare.</span></span></param>
        <param name="val2"><span data-ttu-id="240c7-481">Segundo entero de 16 bits sin signo de los dos que se van a comparar.</span><span class="sxs-lookup"><span data-stu-id="240c7-481">The second of two 16-bit unsigned integers to compare.</span></span></param>
        <summary><span data-ttu-id="240c7-482">Devuelve el menor de dos enteros de 16 bits sin signo.</span><span class="sxs-lookup"><span data-stu-id="240c7-482">Returns the smaller of two 16-bit unsigned integers.</span></span></summary>
        <returns><span data-ttu-id="240c7-483">Parámetro <paramref name="val1" /> o <paramref name="val2" />, el que sea menor.</span><span class="sxs-lookup"><span data-stu-id="240c7-483">Parameter <paramref name="val1" /> or <paramref name="val2" />, whichever is smaller.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="240c7-484">En el ejemplo siguiente se muestra cómo utilizar el <xref:System.Math.Min%2A> método para devolver y mostrar la menor de dos variables.</span><span class="sxs-lookup"><span data-stu-id="240c7-484">The following example demonstrates how to use the <xref:System.Math.Min%2A> method to return and display the smaller of two variables.</span></span>  
  
 [!code-cpp[Math.Min#1](~/samples/snippets/cpp/VS_Snippets_CLR/math.min/CPP/min.cpp#1)]
 [!code-csharp[Math.Min#1](~/samples/snippets/csharp/VS_Snippets_CLR/math.min/CS/min.cs#1)]
 [!code-vb[Math.Min#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/math.min/VB/min.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Min">
      <MemberSignature Language="C#" Value="public static uint Min (uint val1, uint val2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int32 Min(unsigned int32 val1, unsigned int32 val2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Min(System.UInt32,System.UInt32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Min (val1 As UInteger, val2 As UInteger) As UInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::UInt32 Min(System::UInt32 val1, System::UInt32 val2);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="val1" Type="System.UInt32" />
        <Parameter Name="val2" Type="System.UInt32" />
      </Parameters>
      <Docs>
        <param name="val1"><span data-ttu-id="240c7-485">Primer entero de 32 bits sin signo de los dos que se van a comparar.</span><span class="sxs-lookup"><span data-stu-id="240c7-485">The first of two 32-bit unsigned integers to compare.</span></span></param>
        <param name="val2"><span data-ttu-id="240c7-486">Segundo entero de 32 bits sin signo de los dos que se van a comparar.</span><span class="sxs-lookup"><span data-stu-id="240c7-486">The second of two 32-bit unsigned integers to compare.</span></span></param>
        <summary><span data-ttu-id="240c7-487">Devuelve el menor de dos enteros de 32 bits sin signo.</span><span class="sxs-lookup"><span data-stu-id="240c7-487">Returns the smaller of two 32-bit unsigned integers.</span></span></summary>
        <returns><span data-ttu-id="240c7-488">Parámetro <paramref name="val1" /> o <paramref name="val2" />, el que sea menor.</span><span class="sxs-lookup"><span data-stu-id="240c7-488">Parameter <paramref name="val1" /> or <paramref name="val2" />, whichever is smaller.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="240c7-489">En el ejemplo siguiente se muestra cómo utilizar el <xref:System.Math.Min%2A> método para devolver y mostrar la menor de dos variables.</span><span class="sxs-lookup"><span data-stu-id="240c7-489">The following example demonstrates how to use the <xref:System.Math.Min%2A> method to return and display the smaller of two variables.</span></span>  
  
 [!code-cpp[Math.Min#1](~/samples/snippets/cpp/VS_Snippets_CLR/math.min/CPP/min.cpp#1)]
 [!code-csharp[Math.Min#1](~/samples/snippets/csharp/VS_Snippets_CLR/math.min/CS/min.cs#1)]
 [!code-vb[Math.Min#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/math.min/VB/min.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Min">
      <MemberSignature Language="C#" Value="public static ulong Min (ulong val1, ulong val2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int64 Min(unsigned int64 val1, unsigned int64 val2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Min(System.UInt64,System.UInt64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Min (val1 As ULong, val2 As ULong) As ULong" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::UInt64 Min(System::UInt64 val1, System::UInt64 val2);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="val1" Type="System.UInt64" />
        <Parameter Name="val2" Type="System.UInt64" />
      </Parameters>
      <Docs>
        <param name="val1"><span data-ttu-id="240c7-490">Primer entero de 64 bits sin signo de los dos que se van a comparar.</span><span class="sxs-lookup"><span data-stu-id="240c7-490">The first of two 64-bit unsigned integers to compare.</span></span></param>
        <param name="val2"><span data-ttu-id="240c7-491">Segundo entero de 64 bits sin signo de los dos que se van a comparar.</span><span class="sxs-lookup"><span data-stu-id="240c7-491">The second of two 64-bit unsigned integers to compare.</span></span></param>
        <summary><span data-ttu-id="240c7-492">Devuelve el menor de dos enteros de 64 bits sin signo.</span><span class="sxs-lookup"><span data-stu-id="240c7-492">Returns the smaller of two 64-bit unsigned integers.</span></span></summary>
        <returns><span data-ttu-id="240c7-493">Parámetro <paramref name="val1" /> o <paramref name="val2" />, el que sea menor.</span><span class="sxs-lookup"><span data-stu-id="240c7-493">Parameter <paramref name="val1" /> or <paramref name="val2" />, whichever is smaller.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="240c7-494">En el ejemplo siguiente se muestra cómo utilizar el <xref:System.Math.Min%2A> método para devolver y mostrar la menor de dos variables.</span><span class="sxs-lookup"><span data-stu-id="240c7-494">The following example demonstrates how to use the <xref:System.Math.Min%2A> method to return and display the smaller of two variables.</span></span>  
  
 [!code-cpp[Math.Min#1](~/samples/snippets/cpp/VS_Snippets_CLR/math.min/CPP/min.cpp#1)]
 [!code-csharp[Math.Min#1](~/samples/snippets/csharp/VS_Snippets_CLR/math.min/CS/min.cs#1)]
 [!code-vb[Math.Min#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/math.min/VB/min.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PI">
      <MemberSignature Language="C#" Value="public const double PI = 3.14159265358979;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal float64 PI = (3.14159265358979)" />
      <MemberSignature Language="DocId" Value="F:System.Math.PI" />
      <MemberSignature Language="VB.NET" Value="Public Const PI As Double  = 3.14159265358979" />
      <MemberSignature Language="C++ CLI" Value="public: double PI = 3.14159265358979;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <MemberValue>3.14159265358979</MemberValue>
      <Docs>
        <summary><span data-ttu-id="240c7-495">Representa la proporción de la circunferencia de un círculo en relación con su diámetro, especificado por la constante π.</span><span class="sxs-lookup"><span data-stu-id="240c7-495">Represents the ratio of the circumference of a circle to its diameter, specified by the constant, π.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="240c7-496">El valor de este campo es 3,14159265358979323846.</span><span class="sxs-lookup"><span data-stu-id="240c7-496">The value of this field is 3.14159265358979323846.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="240c7-497">En el ejemplo siguiente se utiliza <xref:System.Math.PI> para ayudar en el cálculo de los ángulos internos de un trapezoide determinado.</span><span class="sxs-lookup"><span data-stu-id="240c7-497">The following example uses <xref:System.Math.PI> to assist in the computation of the inner angles of a given trapezoid.</span></span>  
  
 [!code-cpp[MathSample#1](~/samples/snippets/cpp/VS_Snippets_CLR/MathSample/CPP/mathsample.cpp#1)]
 [!code-csharp[MathSample#1](~/samples/snippets/csharp/VS_Snippets_CLR/MathSample/CS/mathsample.cs#1)]
 [!code-vb[MathSample#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/MathSample/VB/mathsample.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Pow">
      <MemberSignature Language="C#" Value="public static double Pow (double x, double y);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Pow(float64 x, float64 y) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Pow(System.Double,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Pow (x As Double, y As Double) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double Pow(double x, double y);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Double" />
        <Parameter Name="y" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="x"><span data-ttu-id="240c7-498">Número de punto flotante de precisión doble que se desea elevar a una potencia.</span><span class="sxs-lookup"><span data-stu-id="240c7-498">A double-precision floating-point number to be raised to a power.</span></span></param>
        <param name="y"><span data-ttu-id="240c7-499">Número de punto flotante de precisión doble que especifica una potencia.</span><span class="sxs-lookup"><span data-stu-id="240c7-499">A double-precision floating-point number that specifies a power.</span></span></param>
        <summary><span data-ttu-id="240c7-500">Devuelve un número especificado elevado a la potencia especificada.</span><span class="sxs-lookup"><span data-stu-id="240c7-500">Returns a specified number raised to the specified power.</span></span></summary>
        <returns><span data-ttu-id="240c7-501">Número <paramref name="x" /> elevado a la potencia <paramref name="y" />.</span><span class="sxs-lookup"><span data-stu-id="240c7-501">The number <paramref name="x" /> raised to the power <paramref name="y" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="240c7-502">En la tabla siguiente indica el valor devuelto cuando se especifican varios valores o intervalos de valores para la `x` y `y` parámetros.</span><span class="sxs-lookup"><span data-stu-id="240c7-502">The following table indicates the return value when various values or ranges of values are specified for the `x` and `y` parameters.</span></span> <span data-ttu-id="240c7-503">Para obtener más información, vea <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>, <xref:System.Double.NegativeInfinity?displayProperty=nameWithType> y <xref:System.Double.NaN?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="240c7-503">For more information, see <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>, <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>, and <xref:System.Double.NaN?displayProperty=nameWithType>.</span></span>  
  
|<span data-ttu-id="240c7-504">Parámetros</span><span class="sxs-lookup"><span data-stu-id="240c7-504">Parameters</span></span>|<span data-ttu-id="240c7-505">Valor devuelto</span><span class="sxs-lookup"><span data-stu-id="240c7-505">Return value</span></span>|  
|----------------|------------------|  
|<span data-ttu-id="240c7-506">`x` o `y`  =  `NaN`.</span><span class="sxs-lookup"><span data-stu-id="240c7-506">`x` or `y` = `NaN`.</span></span>|`NaN`|  
|<span data-ttu-id="240c7-507">`x` = Cualquier valor excepto `NaN`; `y` = 0.</span><span class="sxs-lookup"><span data-stu-id="240c7-507">`x` = Any value except `NaN`; `y` = 0.</span></span>|<span data-ttu-id="240c7-508">1</span><span class="sxs-lookup"><span data-stu-id="240c7-508">1</span></span>|  
|<span data-ttu-id="240c7-509">`x` = `NegativeInfinity`; `y` < 0.</span><span class="sxs-lookup"><span data-stu-id="240c7-509">`x` = `NegativeInfinity`; `y` < 0.</span></span>|<span data-ttu-id="240c7-510">0</span><span class="sxs-lookup"><span data-stu-id="240c7-510">0</span></span>|  
|<span data-ttu-id="240c7-511">`x` = `NegativeInfinity`; `y` es un entero impar positivo.</span><span class="sxs-lookup"><span data-stu-id="240c7-511">`x` = `NegativeInfinity`; `y` is a positive odd integer.</span></span>|`NegativeInfinity`|  
|<span data-ttu-id="240c7-512">`x` = `NegativeInfinity`; `y` es positivo, pero no es un entero impar.</span><span class="sxs-lookup"><span data-stu-id="240c7-512">`x` = `NegativeInfinity`; `y` is positive but not an odd integer.</span></span>|`PositiveInfinity`|  
|<span data-ttu-id="240c7-513">`x` < 0, pero no `NegativeInfinity`; `y` no es un entero, `NegativeInfinity`, o `PositiveInfinity`.</span><span class="sxs-lookup"><span data-stu-id="240c7-513">`x` < 0 but not `NegativeInfinity`; `y` is not an integer, `NegativeInfinity`, or `PositiveInfinity`.</span></span>|`NaN`|  
|<span data-ttu-id="240c7-514">`x` = -1; `y`  =  `NegativeInfinity` o `PositiveInfinity`.</span><span class="sxs-lookup"><span data-stu-id="240c7-514">`x` = -1; `y` = `NegativeInfinity` or `PositiveInfinity`.</span></span>|`NaN`|  
|<span data-ttu-id="240c7-515">-1 < `x` < 1; `y` = `NegativeInfinity`.</span><span class="sxs-lookup"><span data-stu-id="240c7-515">-1 < `x` < 1; `y` = `NegativeInfinity`.</span></span>|`PositiveInfinity`|  
|<span data-ttu-id="240c7-516">-1 < `x` < 1; `y` = `PositiveInfinity`.</span><span class="sxs-lookup"><span data-stu-id="240c7-516">-1 < `x` < 1; `y` = `PositiveInfinity`.</span></span>|<span data-ttu-id="240c7-517">0</span><span class="sxs-lookup"><span data-stu-id="240c7-517">0</span></span>|  
|<span data-ttu-id="240c7-518">`x` < -1 o `x` > 1; `y` = `NegativeInfinity`.</span><span class="sxs-lookup"><span data-stu-id="240c7-518">`x` < -1 or `x` > 1; `y` = `NegativeInfinity`.</span></span>|<span data-ttu-id="240c7-519">0</span><span class="sxs-lookup"><span data-stu-id="240c7-519">0</span></span>|  
|<span data-ttu-id="240c7-520">`x` < -1 o `x` > 1; `y` = `PositiveInfinity`.</span><span class="sxs-lookup"><span data-stu-id="240c7-520">`x` < -1 or `x` > 1; `y` = `PositiveInfinity`.</span></span>|`PositiveInfinity`|  
|<span data-ttu-id="240c7-521">`x` = 0; `y` < 0.</span><span class="sxs-lookup"><span data-stu-id="240c7-521">`x` = 0; `y` < 0.</span></span>|`PositiveInfinity`|  
|<span data-ttu-id="240c7-522">`x` = 0; `y` > 0.</span><span class="sxs-lookup"><span data-stu-id="240c7-522">`x` = 0; `y` > 0.</span></span>|<span data-ttu-id="240c7-523">0</span><span class="sxs-lookup"><span data-stu-id="240c7-523">0</span></span>|  
|<span data-ttu-id="240c7-524">`x` = 1; `y` es cualquier valor excepto `NaN`.</span><span class="sxs-lookup"><span data-stu-id="240c7-524">`x` = 1; `y` is any value except `NaN`.</span></span>|<span data-ttu-id="240c7-525">1</span><span class="sxs-lookup"><span data-stu-id="240c7-525">1</span></span>|  
|<span data-ttu-id="240c7-526">`x` = `PositiveInfinity`; `y` < 0.</span><span class="sxs-lookup"><span data-stu-id="240c7-526">`x` = `PositiveInfinity`; `y` < 0.</span></span>|<span data-ttu-id="240c7-527">0</span><span class="sxs-lookup"><span data-stu-id="240c7-527">0</span></span>|  
|<span data-ttu-id="240c7-528">`x` = `PositiveInfinity`; `y` > 0.</span><span class="sxs-lookup"><span data-stu-id="240c7-528">`x` = `PositiveInfinity`; `y` > 0.</span></span>|`PositiveInfinity`|  
  
   
  
## Examples  
 <span data-ttu-id="240c7-529">En el ejemplo siguiente se usa el <xref:System.Math.Pow%2A> método para calcular el valor que es el resultado de elevar a 2 a una potencia comprendido entre 0 y 32.</span><span class="sxs-lookup"><span data-stu-id="240c7-529">The following example uses the <xref:System.Math.Pow%2A> method to calculate the value that results from raising 2 to a power ranging from 0 to 32.</span></span>  
  
 [!code-csharp[System.Math.Pow#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.math.pow/cs/pow1.cs#1)]
 [!code-vb[System.Math.Pow#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.math.pow/vb/pow1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Math.Sqrt(System.Double)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Round">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="240c7-530">Redondea un valor al entero más próximo o al número especificado de dígitos fraccionarios.</span><span class="sxs-lookup"><span data-stu-id="240c7-530">Rounds a value to the nearest integer or to the specified number of fractional digits.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="240c7-531">En esta sección:</span><span class="sxs-lookup"><span data-stu-id="240c7-531">In this section:</span></span>  
  
 <span data-ttu-id="240c7-532">[Sintaxis del método sobrecargado](#Syntax) </span><span class="sxs-lookup"><span data-stu-id="240c7-532">[Overloaded method syntax](#Syntax) </span></span>  
 <span data-ttu-id="240c7-533">[Parámetros](#Params) </span><span class="sxs-lookup"><span data-stu-id="240c7-533">[Parameters](#Params) </span></span>  
 <span data-ttu-id="240c7-534">[Valor devuelto](#Returns) </span><span class="sxs-lookup"><span data-stu-id="240c7-534">[Return value](#Returns) </span></span>  
 <span data-ttu-id="240c7-535">[Excepciones](#Exceptions) </span><span class="sxs-lookup"><span data-stu-id="240c7-535">[Exceptions](#Exceptions) </span></span>  
 <span data-ttu-id="240c7-536">[¿Qué método se debe llamar?](#Tasks) </span><span class="sxs-lookup"><span data-stu-id="240c7-536">[Which method do I call?](#Tasks) </span></span>  
 <span data-ttu-id="240c7-537">[Valores de punto medio y convenciones de redondeo](#Midpoint) </span><span class="sxs-lookup"><span data-stu-id="240c7-537">[Midpoint values and rounding conventions](#Midpoint) </span></span>  
 <span data-ttu-id="240c7-538">[Redondeo y la precisión](#Precision) </span><span class="sxs-lookup"><span data-stu-id="240c7-538">[Rounding and precision](#Precision) </span></span>  
 <span data-ttu-id="240c7-539">[Valores de punto flotante de precisión sencilla y redondeo](#Single) </span><span class="sxs-lookup"><span data-stu-id="240c7-539">[Rounding and single-precision floating-point values](#Single) </span></span>  
 <span data-ttu-id="240c7-540">Ejemplos:</span><span class="sxs-lookup"><span data-stu-id="240c7-540">Examples:</span></span>   
 [<span data-ttu-id="240c7-541">Math.Round(Decimal)</span><span class="sxs-lookup"><span data-stu-id="240c7-541">Math.Round(Decimal)</span></span>](#Round1_Example)  
 [<span data-ttu-id="240c7-542">Math.Round(Double)</span><span class="sxs-lookup"><span data-stu-id="240c7-542">Math.Round(Double)</span></span>](#Round2_Example)  
 [<span data-ttu-id="240c7-543">Math.Round(Decimal, Int32)</span><span class="sxs-lookup"><span data-stu-id="240c7-543">Math.Round(Decimal, Int32)</span></span>](#Round3_Example)  
 [<span data-ttu-id="240c7-544">Math.Round(Decimal, MidpointRounding)</span><span class="sxs-lookup"><span data-stu-id="240c7-544">Math.Round(Decimal, MidpointRounding)</span></span>](#Round4_Example)  
 [<span data-ttu-id="240c7-545">Math.Round(Double, Int32)</span><span class="sxs-lookup"><span data-stu-id="240c7-545">Math.Round(Double, Int32)</span></span>](#Round5_Example)  
 [<span data-ttu-id="240c7-546">Math.Round(Double, MidpointRounding)</span><span class="sxs-lookup"><span data-stu-id="240c7-546">Math.Round(Double, MidpointRounding)</span></span>](#Round6_Example)  
 [<span data-ttu-id="240c7-547">Math.Round(Decimal, Int32, MidpointRounding)</span><span class="sxs-lookup"><span data-stu-id="240c7-547">Math.Round(Decimal, Int32, MidpointRounding)</span></span>](#Round7_Example)  
 [<span data-ttu-id="240c7-548">Math.Round(Double, Int32, MidpointRounding)</span><span class="sxs-lookup"><span data-stu-id="240c7-548">Math.Round(Double, Int32, MidpointRounding)</span></span>](#Round8_Example)  
[<span data-ttu-id="240c7-549">Información de versión</span><span class="sxs-lookup"><span data-stu-id="240c7-549">Version information</span></span>](#Round_Versions)  
  
<a name="Syntax"></a>   
## <a name="overloaded-method-syntax"></a><span data-ttu-id="240c7-550">Sintaxis del método sobrecargado</span><span class="sxs-lookup"><span data-stu-id="240c7-550">Overloaded method syntax</span></span>  
 <span data-ttu-id="240c7-551">¿Para obtener instrucciones adicionales sobre cómo elegir una sobrecarga, consulte [qué método se debe llamar?](#Tasks)</span><span class="sxs-lookup"><span data-stu-id="240c7-551">For additional guidance on choosing an overload, see [Which method do I call?](#Tasks)</span></span>  
  
 <span data-ttu-id="240c7-552">`Decimal Math.Round(Decimal` `d` `)`</span><span class="sxs-lookup"><span data-stu-id="240c7-552">`Decimal Math.Round(Decimal` `d` `)`</span></span>  
 <span data-ttu-id="240c7-553">Redondea un valor decimal al entero más próximo y redondea los valores de punto medio al número par más cercano ([ejemplo](#Round1_Example)).</span><span class="sxs-lookup"><span data-stu-id="240c7-553">Rounds a decimal value to the nearest integer, and rounds midpoint values to the nearest even number ([example](#Round1_Example)).</span></span>  
  
 <span data-ttu-id="240c7-554">`Double Math.Round(Double` `a` `)`</span><span class="sxs-lookup"><span data-stu-id="240c7-554">`Double Math.Round(Double` `a` `)`</span></span>  
 <span data-ttu-id="240c7-555">Redondea un valor de punto flotante de precisión doble al entero más próximo y redondea los valores de punto medio al número par más cercano ([ejemplo](#Round2_Example)).</span><span class="sxs-lookup"><span data-stu-id="240c7-555">Rounds a double-precision floating-point value to the nearest integer, and rounds midpoint values to the nearest even number ([example](#Round2_Example)).</span></span>  
  
 <span data-ttu-id="240c7-556">`Decimal Math.Round(Decimal` `d` `, Int32`  `decimals` `)`</span><span class="sxs-lookup"><span data-stu-id="240c7-556">`Decimal Math.Round(Decimal` `d` `, Int32`  `decimals` `)`</span></span>  
 <span data-ttu-id="240c7-557">Redondea un valor decimal al número especificado de dígitos fraccionarios y redondea los valores de punto medio al número par más cercano ([ejemplo](#Round3_Example)).</span><span class="sxs-lookup"><span data-stu-id="240c7-557">Rounds a decimal value to a specified number of fractional digits, and rounds midpoint values to the nearest even number ([example](#Round3_Example)).</span></span>  
  
 <span data-ttu-id="240c7-558">`Double Math.Round(Double` `value` `, Int32`  `digits` `)`</span><span class="sxs-lookup"><span data-stu-id="240c7-558">`Double Math.Round(Double` `value` `, Int32`  `digits` `)`</span></span>  
 <span data-ttu-id="240c7-559">Redondea un valor de punto flotante de precisión doble al número especificado de dígitos fraccionarios y redondea los valores de punto medio al número par más cercano ([ejemplo](#Round4_Example)).</span><span class="sxs-lookup"><span data-stu-id="240c7-559">Rounds a double-precision floating-point value to a specified number of fractional digits, and rounds midpoint values to the nearest even number ([example](#Round4_Example)).</span></span>  
  
 <span data-ttu-id="240c7-560">`Decimal Math.Round(Decimal` `d` `, MidpointRounding`  `mode` `)`</span><span class="sxs-lookup"><span data-stu-id="240c7-560">`Decimal Math.Round(Decimal` `d` `, MidpointRounding`  `mode` `)`</span></span>  
 <span data-ttu-id="240c7-561">Redondea un valor decimal al entero más próximo y utiliza la convención de redondeo especificada para los valores de punto medio ([ejemplo](#Round5_Example)).</span><span class="sxs-lookup"><span data-stu-id="240c7-561">Rounds a decimal value to the nearest integer, and uses the specified rounding convention for midpoint values ([example](#Round5_Example)).</span></span>  
  
 <span data-ttu-id="240c7-562">`Double Math.Round(Double` `value` `, MidpointRounding`  `mode` `)`</span><span class="sxs-lookup"><span data-stu-id="240c7-562">`Double Math.Round(Double` `value` `, MidpointRounding`  `mode` `)`</span></span>  
 <span data-ttu-id="240c7-563">Redondea un valor de punto flotante de precisión doble al entero más próximo y utiliza la convención de redondeo especificada para los valores de punto medio ([ejemplo](#Round6_Example)).</span><span class="sxs-lookup"><span data-stu-id="240c7-563">Rounds a double-precision floating-point value to the nearest integer, and uses the specified rounding convention for midpoint values ([example](#Round6_Example)).</span></span>  
  
 <span data-ttu-id="240c7-564">`Decimal Math.Round(Decimal` `d` `, Int32`  `decimals` `, MidpointRounding`  `mode` `)`</span><span class="sxs-lookup"><span data-stu-id="240c7-564">`Decimal Math.Round(Decimal` `d` `, Int32`  `decimals` `, MidpointRounding`  `mode` `)`</span></span>  
 <span data-ttu-id="240c7-565">Redondea un valor decimal al número especificado de dígitos fraccionarios y utiliza la convención de redondeo especificada para los valores de punto medio ([ejemplo](#Round7_Example)).</span><span class="sxs-lookup"><span data-stu-id="240c7-565">Rounds a decimal value to a specified number of fractional digits, and uses the specified rounding convention for midpoint values ([example](#Round7_Example)).</span></span>  
  
 <span data-ttu-id="240c7-566">`Double Math.Round(Double` `value` `, Int32`  `digits` `, MidpointRounding`  `mode` `)`</span><span class="sxs-lookup"><span data-stu-id="240c7-566">`Double Math.Round(Double` `value` `, Int32`  `digits` `, MidpointRounding`  `mode` `)`</span></span>  
 <span data-ttu-id="240c7-567">Redondea un valor de punto flotante de precisión doble al número especificado de dígitos fraccionarios y utiliza la convención de redondeo especificada para los valores de punto medio ([ejemplo](#Round8_Example)).</span><span class="sxs-lookup"><span data-stu-id="240c7-567">Rounds a double-precision floating-point value to a specified number of fractional digits, and uses the specified rounding convention for midpoint values ([example](#Round8_Example)).</span></span>  
  
<a name="Params"></a>   
## <a name="parameters"></a><span data-ttu-id="240c7-568">Parámetros</span><span class="sxs-lookup"><span data-stu-id="240c7-568">Parameters</span></span>  
 <span data-ttu-id="240c7-569">Se trata de una lista completa de parámetros para el <xref:System.Math.Round%2A> método.</span><span class="sxs-lookup"><span data-stu-id="240c7-569">This is a complete list of parameters for the <xref:System.Math.Round%2A> method.</span></span> <span data-ttu-id="240c7-570">Para los parámetros utilizados por cada sobrecarga, vea la sintaxis de sobrecarga anterior.</span><span class="sxs-lookup"><span data-stu-id="240c7-570">For the parameters used by each overload, see the overload syntax above.</span></span>  
  
|<span data-ttu-id="240c7-571">Parámetro</span><span class="sxs-lookup"><span data-stu-id="240c7-571">Parameter</span></span>|<span data-ttu-id="240c7-572">Tipo</span><span class="sxs-lookup"><span data-stu-id="240c7-572">Type</span></span>|<span data-ttu-id="240c7-573">Descripción</span><span class="sxs-lookup"><span data-stu-id="240c7-573">Description</span></span>|  
|---------------|----------|-----------------|  
|`d`|<xref:System.Decimal>|<span data-ttu-id="240c7-574">Un número que se desea redondear.</span><span class="sxs-lookup"><span data-stu-id="240c7-574">A number to be rounded.</span></span>|  
|`a`<br /><br /> <span data-ttu-id="240c7-575">O bien</span><span class="sxs-lookup"><span data-stu-id="240c7-575">-or-</span></span><br /><br /> `value`|<xref:System.Double>|<span data-ttu-id="240c7-576">Número de punto flotante de precisión doble que se va a redondear.</span><span class="sxs-lookup"><span data-stu-id="240c7-576">A double-precision floating-point number to be rounded.</span></span>|  
|`decimals`<br /><br /> <span data-ttu-id="240c7-577">O bien</span><span class="sxs-lookup"><span data-stu-id="240c7-577">-or-</span></span><br /><br /> `digits`|<xref:System.Int32>|<span data-ttu-id="240c7-578">Número de dígitos fraccionarios del valor devuelto.</span><span class="sxs-lookup"><span data-stu-id="240c7-578">The number of fractional digits in the return value.</span></span> <span data-ttu-id="240c7-579">Para <xref:System.Decimal> valores, puede oscilar entre 0 y 28.</span><span class="sxs-lookup"><span data-stu-id="240c7-579">For <xref:System.Decimal> values, it can range from 0 to 28.</span></span> <span data-ttu-id="240c7-580">Para <xref:System.Double> valores, puede oscilar entre 0 y 15.</span><span class="sxs-lookup"><span data-stu-id="240c7-580">For <xref:System.Double> values, it can range from 0 to 15.</span></span> <span data-ttu-id="240c7-581">Tenga en cuenta que 15 es el número máximo de dígitos enteros y fraccionarios admitidos por el <xref:System.Double> tipo.</span><span class="sxs-lookup"><span data-stu-id="240c7-581">Note that 15 is the maximum number of integral and fractional digits supported by the <xref:System.Double> type.</span></span><br /><br /> <span data-ttu-id="240c7-582">Valor predeterminado: 0, lo que se redondea a un entero</span><span class="sxs-lookup"><span data-stu-id="240c7-582">Default value: 0, which rounds to an integer</span></span>|  
|`mode`|<xref:System.MidpointRounding>|<span data-ttu-id="240c7-583">Una marca que especifica la convención que se usará para redondear los valores de punto medio.</span><span class="sxs-lookup"><span data-stu-id="240c7-583">A flag that specifies the convention to use for rounding midpoint values.</span></span> <span data-ttu-id="240c7-584">Vea [valores de punto medio y convenciones de redondeo](#Midpoint).</span><span class="sxs-lookup"><span data-stu-id="240c7-584">See [Midpoint values and rounding conventions](#Midpoint).</span></span><br /><br /> <span data-ttu-id="240c7-585">Valor predeterminado: <xref:System.MidpointRounding.ToEven?displayProperty=nameWithType></span><span class="sxs-lookup"><span data-stu-id="240c7-585">Default value: <xref:System.MidpointRounding.ToEven?displayProperty=nameWithType></span></span>|  
  
<a name="Returns"></a>   
## <a name="return-value"></a><span data-ttu-id="240c7-586">Valor devuelto</span><span class="sxs-lookup"><span data-stu-id="240c7-586">Return value</span></span>  
 <span data-ttu-id="240c7-587">Tipo: <xref:System.Decimal> o <xref:System.Double>, según el tipo del valor que se va a redondear.</span><span class="sxs-lookup"><span data-stu-id="240c7-587">Type: <xref:System.Decimal> or <xref:System.Double>, depending on the type of the value to be rounded.</span></span>   
<span data-ttu-id="240c7-588">Un valor numérico del mismo tipo como `d`, `a`, o `value`, pero redondeado a un entero o al número especificado de dígitos decimales.</span><span class="sxs-lookup"><span data-stu-id="240c7-588">A numeric value of the same type as `d`, `a`, or `value`, but rounded either to an integer or to the specified number of decimal digits.</span></span> <span data-ttu-id="240c7-589">Vea [valores de punto medio y convenciones de redondeo](#Midpoint) para obtener información acerca de redondear los números con valores de punto medio.</span><span class="sxs-lookup"><span data-stu-id="240c7-589">See [Midpoint values and rounding conventions](#Midpoint) for information about rounding numbers with midpoint values.</span></span>  
  
> [!WARNING]
>  <span data-ttu-id="240c7-590">Cuando se redondea los valores de punto medio, el algoritmo de redondeo realiza una prueba de igualdad.</span><span class="sxs-lookup"><span data-stu-id="240c7-590">When rounding midpoint values, the rounding algorithm performs an equality test.</span></span> <span data-ttu-id="240c7-591">Debido a problemas de representación binaria y la precisión en el formato de punto flotante, el valor devuelto por el método puede ser inesperado.</span><span class="sxs-lookup"><span data-stu-id="240c7-591">Because of problems of binary representation and precision in the floating-point format, the value returned by the method can be unexpected.</span></span> <span data-ttu-id="240c7-592">Para obtener más información, consulte [redondeo y la precisión](#Precision).</span><span class="sxs-lookup"><span data-stu-id="240c7-592">For more information, see [Rounding and precision](#Precision).</span></span>  
  
 <span data-ttu-id="240c7-593">Si una sobrecarga con un <xref:System.Double> parámetro se denomina con <xref:System.Double.NaN?displayProperty=nameWithType>, el método devuelve <xref:System.Double.NaN?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="240c7-593">If an overload with a <xref:System.Double> parameter is called with <xref:System.Double.NaN?displayProperty=nameWithType>, the method returns <xref:System.Double.NaN?displayProperty=nameWithType>.</span></span> <span data-ttu-id="240c7-594">Si se llama con <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> o <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>, el método devuelve <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> o <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>, respectivamente.</span><span class="sxs-lookup"><span data-stu-id="240c7-594">If it is called with <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> or <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>, the method returns <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> or <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>, respectively.</span></span>  
  
<a name="Exceptions"></a>   
## <a name="exceptions"></a><span data-ttu-id="240c7-595">Excepciones</span><span class="sxs-lookup"><span data-stu-id="240c7-595">Exceptions</span></span>  
  
|<span data-ttu-id="240c7-596">Excepción</span><span class="sxs-lookup"><span data-stu-id="240c7-596">Exception</span></span>|<span data-ttu-id="240c7-597">Condición</span><span class="sxs-lookup"><span data-stu-id="240c7-597">Condition</span></span>|<span data-ttu-id="240c7-598">Producida por</span><span class="sxs-lookup"><span data-stu-id="240c7-598">Thrown by</span></span>|  
|---------------|---------------|---------------|  
|<xref:System.OverflowException>|<span data-ttu-id="240c7-599">El resultado está fuera del intervalo de la <xref:System.Decimal> tipo.</span><span class="sxs-lookup"><span data-stu-id="240c7-599">The result is outside the range of the <xref:System.Decimal> type.</span></span>|<xref:System.Math.Round%28System.Decimal%29><br /><br /> <xref:System.Math.Round%28System.Decimal%2CSystem.Int32%29><br /><br /> <xref:System.Math.Round%28System.Decimal%2CSystem.MidpointRounding%29><br /><br /> <xref:System.Math.Round%28System.Decimal%2CSystem.Int32%2CSystem.MidpointRounding%29>|  
|<xref:System.ArgumentOutOfRangeException>|<span data-ttu-id="240c7-600">`decimals` es menor que 0 o mayor que 28.</span><span class="sxs-lookup"><span data-stu-id="240c7-600">`decimals` is less than 0 or greater than 28.</span></span><br /><br /> <span data-ttu-id="240c7-601">O bien</span><span class="sxs-lookup"><span data-stu-id="240c7-601">-or-</span></span><br /><br /> <span data-ttu-id="240c7-602">`digits` es menor que 0 o mayor que 15.</span><span class="sxs-lookup"><span data-stu-id="240c7-602">`digits` is less than 0 or greater than 15.</span></span>|<xref:System.Math.Round%28System.Decimal%2CSystem.Int32%29><br /><br /> <xref:System.Math.Round%28System.Double%2CSystem.Int32%29><br /><br /> <xref:System.Math.Round%28System.Decimal%2CSystem.Int32%2CSystem.MidpointRounding%29><br /><br /> <xref:System.Math.Round%28System.Double%2CSystem.Int32%2CSystem.MidpointRounding%29>|  
|<xref:System.ArgumentException>|<span data-ttu-id="240c7-603">`mode` no es un valor válido de <xref:System.MidpointRounding>.</span><span class="sxs-lookup"><span data-stu-id="240c7-603">`mode` is not a valid value of <xref:System.MidpointRounding>.</span></span>|<xref:System.Math.Round%28System.Decimal%2CSystem.MidpointRounding%29><br /><br /> <xref:System.Math.Round%28System.Double%2CSystem.MidpointRounding%29><br /><br /> <xref:System.Math.Round%28System.Decimal%2CSystem.Int32%2CSystem.MidpointRounding%29><br /><br /> <xref:System.Math.Round%28System.Double%2CSystem.Int32%2CSystem.MidpointRounding%29>|  
  
<a name="Tasks"></a>   
## <a name="which-method-do-i-call"></a><span data-ttu-id="240c7-604">¿Qué método se debe llamar?</span><span class="sxs-lookup"><span data-stu-id="240c7-604">Which method do I call?</span></span>  
  
|<span data-ttu-id="240c7-605">En</span><span class="sxs-lookup"><span data-stu-id="240c7-605">To</span></span>|<span data-ttu-id="240c7-606">Call</span><span class="sxs-lookup"><span data-stu-id="240c7-606">Call</span></span>|  
|--------|----------|  
|<span data-ttu-id="240c7-607">Redondear un número en un entero utilizando el redondeo al más cercano convención.</span><span class="sxs-lookup"><span data-stu-id="240c7-607">Round a number to an integer by using the rounding to nearest convention.</span></span>|<xref:System.Math.Round%28System.Decimal%29><br /><br /> <span data-ttu-id="240c7-608">O bien</span><span class="sxs-lookup"><span data-stu-id="240c7-608">-or-</span></span><br /><br /> <xref:System.Math.Round%28System.Double%29>|  
|<span data-ttu-id="240c7-609">Redondear un número en un entero utilizando un redondeo convención.</span><span class="sxs-lookup"><span data-stu-id="240c7-609">Round a number to an integer by using a specified rounding convention.</span></span>|<xref:System.Math.Round%28System.Decimal%2CSystem.MidpointRounding%29><br /><br /> <span data-ttu-id="240c7-610">O bien</span><span class="sxs-lookup"><span data-stu-id="240c7-610">-or-</span></span><br /><br /> <xref:System.Math.Round%28System.Double%2CSystem.MidpointRounding%29>|  
|<span data-ttu-id="240c7-611">Redondear un número a un número especificado de dígitos fraccionarios utilizando el redondeo al más cercano convención.</span><span class="sxs-lookup"><span data-stu-id="240c7-611">Round a number to a specified number of fractional digits by using the rounding to nearest convention.</span></span>|<xref:System.Math.Round%28System.Decimal%2CSystem.Int32%29><br /><br /> <span data-ttu-id="240c7-612">O bien</span><span class="sxs-lookup"><span data-stu-id="240c7-612">-or-</span></span><br /><br /> <xref:System.Math.Round%28System.Double%2CSystem.Int32%29>|  
|<span data-ttu-id="240c7-613">Redondear un número al número especificado de dígitos fraccionarios utilizando un redondeo convención.</span><span class="sxs-lookup"><span data-stu-id="240c7-613">Round a number to a specified number of fractional digits by using a specified rounding convention.</span></span>|<xref:System.Math.Round%28System.Decimal%2CSystem.Int32%2CSystem.MidpointRounding%29><br /><br /> <span data-ttu-id="240c7-614">O bien</span><span class="sxs-lookup"><span data-stu-id="240c7-614">-or-</span></span><br /><br /> <xref:System.Math.Round%28System.Double%2CSystem.Int32%2CSystem.MidpointRounding%29>|  
|<span data-ttu-id="240c7-615">Redondear un <xref:System.Single> valor a un número especificado de dígitos fraccionarios mediante una convención de redondeo especificado y minimiza las pérdidas de precisión.</span><span class="sxs-lookup"><span data-stu-id="240c7-615">Round a <xref:System.Single> value to a specified number of fractional digits by using a specified rounding convention and minimizing the loss of precision.</span></span>|<span data-ttu-id="240c7-616">Convertir el <xref:System.Single> a una <xref:System.Decimal> y llame a <xref:System.Math.Round%28System.Decimal%2CSystem.Int32%2CSystem.MidpointRounding%29>.</span><span class="sxs-lookup"><span data-stu-id="240c7-616">Convert the <xref:System.Single> to a <xref:System.Decimal> and call <xref:System.Math.Round%28System.Decimal%2CSystem.Int32%2CSystem.MidpointRounding%29>.</span></span>|  
|<span data-ttu-id="240c7-617">Redondear un número a un número especificado de dígitos fraccionarios y minimizar los problemas de precisión en los valores de punto medio de redondeo.</span><span class="sxs-lookup"><span data-stu-id="240c7-617">Round a number to a specified number of fractional digits while minimizing problems of precision in rounding midpoint values.</span></span>|<span data-ttu-id="240c7-618">Llamar a un método de redondeo que implementa una comparación "mayor que o aproximadamente igual a".</span><span class="sxs-lookup"><span data-stu-id="240c7-618">Call a rounding method that implements a "greater than or approximately equal to" comparison.</span></span> <span data-ttu-id="240c7-619">Vea [redondeo y la precisión](#Precision).</span><span class="sxs-lookup"><span data-stu-id="240c7-619">See [Rounding and precision](#Precision).</span></span>|  
|<span data-ttu-id="240c7-620">Redondear un valor fraccionario en un entero que es mayor que el valor de fracciones.</span><span class="sxs-lookup"><span data-stu-id="240c7-620">Round a fractional value to an integer that is greater than the fractional value.</span></span> <span data-ttu-id="240c7-621">Por ejemplo, redondear 3.1 a 4.</span><span class="sxs-lookup"><span data-stu-id="240c7-621">For example, round 3.1 to 4.</span></span>|<xref:System.Math.Ceiling%2A>|  
|<span data-ttu-id="240c7-622">Redondear un valor fraccionario en un entero que es menor que el valor de fracciones.</span><span class="sxs-lookup"><span data-stu-id="240c7-622">Round a fractional value to an integer that is less than the fractional value.</span></span> <span data-ttu-id="240c7-623">Por ejemplo, redondear 3.9 a 3.</span><span class="sxs-lookup"><span data-stu-id="240c7-623">For example, round 3.9 to 3.</span></span>|<xref:System.Math.Floor%2A>|  
  
<a name="Midpoint"></a>   
## <a name="midpoint-values-and-rounding-conventions"></a><span data-ttu-id="240c7-624">Valores de punto medio y convenciones de redondeo</span><span class="sxs-lookup"><span data-stu-id="240c7-624">Midpoint values and rounding conventions</span></span>  
 <span data-ttu-id="240c7-625">Redondeo implica convertir un valor numérico con una precisión especificada para el valor más próximo con menos precisión.</span><span class="sxs-lookup"><span data-stu-id="240c7-625">Rounding involves converting a numeric value with a specified precision to the nearest value with less precision.</span></span> <span data-ttu-id="240c7-626">Por ejemplo, puede usar el <xref:System.Math.Round%28System.Double%29> método para redondear un valor de 3.4 a 3.0 y el <xref:System.Math.Round%28System.Double%2CSystem.Int32%29> método para redondear un valor de 3,579 a 3,58.</span><span class="sxs-lookup"><span data-stu-id="240c7-626">For example, you can use the <xref:System.Math.Round%28System.Double%29> method to round a value of 3.4 to 3.0, and the <xref:System.Math.Round%28System.Double%2CSystem.Int32%29> method to round a value of 3.579 to 3.58.</span></span>  
  
 <span data-ttu-id="240c7-627">Un valor de punto medio, el valor después de los dígitos menos significativos en el resultado es precisamente mitad de camino entre dos números.</span><span class="sxs-lookup"><span data-stu-id="240c7-627">In a midpoint value, the value after the least significant digit in the result is precisely half way between two numbers.</span></span> <span data-ttu-id="240c7-628">Por ejemplo, 3.47500 es un valor de punto medio si no redondea a dos posiciones decimales y 7.500 es un valor de punto medio si no se redondea a un entero.</span><span class="sxs-lookup"><span data-stu-id="240c7-628">For example, 3.47500 is a midpoint value if it is to be rounded two decimal places, and 7.500 is a midpoint value if it is to be rounded to an integer.</span></span> <span data-ttu-id="240c7-629">En estos casos, el valor más cercano no se puede identificar fácilmente sin una convención de redondeo.</span><span class="sxs-lookup"><span data-stu-id="240c7-629">In these cases, the nearest value can't be easily identified without a rounding convention.</span></span>  
  
 <span data-ttu-id="240c7-630">El <xref:System.Math.Round%2A> método es compatible con dos convenciones de redondeo para controlar los valores de punto medio:</span><span class="sxs-lookup"><span data-stu-id="240c7-630">The <xref:System.Math.Round%2A> method supports two rounding conventions for handling midpoint values:</span></span>  
  
 <span data-ttu-id="240c7-631">**Redondeo para evitar el cero**</span><span class="sxs-lookup"><span data-stu-id="240c7-631">**Rounding away from zero**</span></span>  
 <span data-ttu-id="240c7-632">Los valores de punto medio se redondean al siguiente número de dirección contraria a cero.</span><span class="sxs-lookup"><span data-stu-id="240c7-632">Midpoint values are rounded to the next number away from zero.</span></span> <span data-ttu-id="240c7-633">Por ejemplo, se redondea 3,75 a 3.8, 3.85 se redondeará a 3.9,-3.75 se redondea a-3.8, y-3.85 se redondea a-3.9.</span><span class="sxs-lookup"><span data-stu-id="240c7-633">For example, 3.75 rounds to 3.8, 3.85 rounds to 3.9, -3.75 rounds to -3.8, and -3.85 rounds to -3.9.</span></span> <span data-ttu-id="240c7-634">Esta forma de redondeo es representada por la <xref:System.MidpointRounding.AwayFromZero?displayProperty=nameWithType> miembro de enumeración.</span><span class="sxs-lookup"><span data-stu-id="240c7-634">This form of rounding is represented by the <xref:System.MidpointRounding.AwayFromZero?displayProperty=nameWithType> enumeration member.</span></span>  
  
 <span data-ttu-id="240c7-635">Redondeo para evitar el cero es la forma más ampliamente conocida de redondeo.</span><span class="sxs-lookup"><span data-stu-id="240c7-635">Rounding away from zero is the most widely known form of rounding.</span></span>  
  
 <span data-ttu-id="240c7-636">**Redondeo al más próximo o redondeo bancario**</span><span class="sxs-lookup"><span data-stu-id="240c7-636">**Rounding to nearest, or banker's rounding**</span></span>  
 <span data-ttu-id="240c7-637">Los valores de punto medio se redondean al número par más cercano.</span><span class="sxs-lookup"><span data-stu-id="240c7-637">Midpoint values are rounded to the nearest even number.</span></span> <span data-ttu-id="240c7-638">Por ejemplo, redondear 3.8 3,75 y 3.85 y-3.75 y-3.85 de ida y vuelta a-3.8.</span><span class="sxs-lookup"><span data-stu-id="240c7-638">For example, both 3.75 and 3.85 round to 3.8, and both -3.75 and -3.85 round to -3.8.</span></span> <span data-ttu-id="240c7-639">Esta forma de redondeo es representada por la <xref:System.MidpointRounding.ToEven?displayProperty=nameWithType> miembro de enumeración.</span><span class="sxs-lookup"><span data-stu-id="240c7-639">This form of rounding is represented by the <xref:System.MidpointRounding.ToEven?displayProperty=nameWithType> enumeration member.</span></span>  
  
 <span data-ttu-id="240c7-640">Redondeo al más cercano es la forma estándar de redondeo utilizado en las operaciones financieras y estadísticas.</span><span class="sxs-lookup"><span data-stu-id="240c7-640">Rounding to nearest is the standard form of rounding used in financial and statistical operations.</span></span> <span data-ttu-id="240c7-641">Se ajusta al estándar IEEE 754, sección 4.</span><span class="sxs-lookup"><span data-stu-id="240c7-641">It conforms to IEEE Standard 754, section 4.</span></span> <span data-ttu-id="240c7-642">Cuando se utiliza en varias operaciones de redondeo, reduce el error de redondeo que se debe a los valores de punto medio en una dirección única de redondear de forma consistente.</span><span class="sxs-lookup"><span data-stu-id="240c7-642">When used in multiple rounding operations, it reduces the rounding error that is caused by consistently rounding midpoint values in a single direction.</span></span> <span data-ttu-id="240c7-643">En algunos casos, este error de redondeo puede ser significativo.</span><span class="sxs-lookup"><span data-stu-id="240c7-643">In some cases, this rounding error can be significant.</span></span>  
  
 <span data-ttu-id="240c7-644">En el ejemplo siguiente se muestra la diferencia que puede derivarse de redondear de forma consistente los valores de punto medio en una dirección única.</span><span class="sxs-lookup"><span data-stu-id="240c7-644">The following example illustrates the bias that can result from consistently rounding midpoint values in a single direction.</span></span> <span data-ttu-id="240c7-645">En el ejemplo se calcula la verdadera Media de una matriz de <xref:System.Decimal> valores y, a continuación, calcula la media cuando los valores de la matriz se redondean usando las convenciones de dos.</span><span class="sxs-lookup"><span data-stu-id="240c7-645">The example computes the true mean of an array of <xref:System.Decimal> values, and then computes the mean when the values in the array are rounded by using the two conventions.</span></span> <span data-ttu-id="240c7-646">En este ejemplo, la verdadera Media y la media resultante cuando se redondea al entero más próximo son los mismos.</span><span class="sxs-lookup"><span data-stu-id="240c7-646">In this example, the true mean and the mean that results when rounding to nearest are the same.</span></span> <span data-ttu-id="240c7-647">Sin embargo, el promedio que se produce cuando el redondeo para evitar el cero difiere.05 (o 3,6%) de la verdadera Media.</span><span class="sxs-lookup"><span data-stu-id="240c7-647">However, the mean that results when rounding away from zero differs by .05 (or by 3.6%) from the true mean.</span></span>  
  
 [!code-csharp[System.Math.Round.Overload#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.math.round.overload/cs/mean1.cs#2)]
 [!code-vb[System.Math.Round.Overload#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.math.round.overload/vb/mean1.vb#2)]  
  
 <span data-ttu-id="240c7-648">De forma predeterminada, la <xref:System.Math.Round%2A> método utiliza el redondeo al más cercano convención.</span><span class="sxs-lookup"><span data-stu-id="240c7-648">By default, the <xref:System.Math.Round%2A> method uses the rounding to nearest convention.</span></span> <span data-ttu-id="240c7-649">En la tabla siguiente se enumera las sobrecargas de los <xref:System.Math.Round%2A> método y la convención de redondeo que se usa cada uno.</span><span class="sxs-lookup"><span data-stu-id="240c7-649">The following table lists the overloads of the <xref:System.Math.Round%2A> method and the rounding convention that each uses.</span></span>  
  
|<span data-ttu-id="240c7-650">Sobrecarga</span><span class="sxs-lookup"><span data-stu-id="240c7-650">Overload</span></span>|<span data-ttu-id="240c7-651">Convención de redondeo</span><span class="sxs-lookup"><span data-stu-id="240c7-651">Rounding convention</span></span>|  
|--------------|-------------------------|  
|<xref:System.Math.Round%28System.Decimal%29>|<xref:System.MidpointRounding.ToEven>|  
|<xref:System.Math.Round%28System.Double%29>|<xref:System.MidpointRounding.ToEven>|  
|<xref:System.Math.Round%28System.Decimal%2CSystem.Int32%29>|<xref:System.MidpointRounding.ToEven>|  
|<xref:System.Math.Round%28System.Double%2CSystem.Int32%29>|<xref:System.MidpointRounding.ToEven>|  
|<xref:System.Math.Round%28System.Decimal%2CSystem.MidpointRounding%29>|<span data-ttu-id="240c7-652">Determinado por `mode` parámetro.</span><span class="sxs-lookup"><span data-stu-id="240c7-652">Determined by `mode` parameter.</span></span>|  
|<xref:System.Math.Round%28System.Double%2CSystem.MidpointRounding%29>|<span data-ttu-id="240c7-653">Determinado por `mode` parámetro</span><span class="sxs-lookup"><span data-stu-id="240c7-653">Determined by `mode` parameter</span></span>|  
|<xref:System.Math.Round%28System.Decimal%2CSystem.Int32%2CSystem.MidpointRounding%29>|<span data-ttu-id="240c7-654">Determinado por `mode` parámetro</span><span class="sxs-lookup"><span data-stu-id="240c7-654">Determined by `mode` parameter</span></span>|  
|<xref:System.Math.Round%28System.Double%2CSystem.Int32%2CSystem.MidpointRounding%29>|<span data-ttu-id="240c7-655">Determinado por `mode` parámetro</span><span class="sxs-lookup"><span data-stu-id="240c7-655">Determined by `mode` parameter</span></span>|  
  
<a name="Precision"></a>   
## <a name="rounding-and-precision"></a><span data-ttu-id="240c7-656">Redondeo y la precisión</span><span class="sxs-lookup"><span data-stu-id="240c7-656">Rounding and precision</span></span>  
 <span data-ttu-id="240c7-657">Para determinar si una operación de redondeo implica un valor de punto medio, el <xref:System.Math.Round%2A> método multiplica el valor original se redondea por 10<sup>n</sup>, donde *n* es el número deseado de fracciones dígitos en el valor devuelto y, a continuación, determina si la parte fraccionaria restante del valor es mayor o igual que.5.</span><span class="sxs-lookup"><span data-stu-id="240c7-657">In order to determine whether a rounding operation involves a midpoint value, the <xref:System.Math.Round%2A> method multiplies the original value to be rounded by 10<sup>n</sup>, where *n* is the desired number of fractional digits in the return value, and then determines whether the remaining fractional portion of the value is greater than or equal to .5.</span></span> <span data-ttu-id="240c7-658">Se trata de una ligera variación en una prueba de igualdad y como hemos explicado en la sección "Probar la igualdad" de la <xref:System.Double> tema de referencia, debido a problemas de formato de punto flotante con binario es problemático comprueba la igualdad con valores de punto flotante representación y precisión.</span><span class="sxs-lookup"><span data-stu-id="240c7-658">This is a slight variation on a test for equality, and as discussed in the "Testing for Equality" section of the <xref:System.Double> reference topic, tests for equality with floating-point values are problematic because of the floating-point format's issues with binary representation and precision.</span></span> <span data-ttu-id="240c7-659">Esto significa que cualquier parte fraccionaria de un número que es un poco menos de.5 (debido a una pérdida de precisión) no se redondeará hacia arriba.</span><span class="sxs-lookup"><span data-stu-id="240c7-659">This means that any fractional portion of a number that is slightly less than .5 (because of a loss of precision) will not be rounded upward.</span></span>  
  
 <span data-ttu-id="240c7-660">En el siguiente ejemplo se ilustra el problema.</span><span class="sxs-lookup"><span data-stu-id="240c7-660">The following example illustrates the problem.</span></span> <span data-ttu-id="240c7-661">Repetidamente agrega.1 a 11.0 y redondea el resultado al entero más próximo.</span><span class="sxs-lookup"><span data-stu-id="240c7-661">It repeatedly adds .1 to 11.0 and rounds the result to the nearest integer.</span></span> <span data-ttu-id="240c7-662">Independientemente de la convención de redondeo, se deben redondear 11,5 a 12.</span><span class="sxs-lookup"><span data-stu-id="240c7-662">Regardless of the rounding convention, 11.5 should round to 12.</span></span> <span data-ttu-id="240c7-663">Sin embargo, como la salida se muestra en el ejemplo, no la tiene.</span><span class="sxs-lookup"><span data-stu-id="240c7-663">However, as the output from the example shows, it does not.</span></span> <span data-ttu-id="240c7-664">En el ejemplo se utiliza la "R" [cadena de formato numérico estándar](~/docs/standard/base-types/standard-numeric-format-strings.md) para mostrar el de punto flotante del valor precisión completa y se muestra que el valor se redondea ha perdido la precisión durante repetidas adiciones y su valor es realmente 11.499999999999998.</span><span class="sxs-lookup"><span data-stu-id="240c7-664">The example uses the "R" [standard numeric format string](~/docs/standard/base-types/standard-numeric-format-strings.md) to display the floating point value's full precision, and shows that the value to be rounded has lost precision during repeated additions, and its value is actually 11.499999999999998.</span></span> <span data-ttu-id="240c7-665">Dado que.499999999999998 es menor que.5, el valor no se redondea al entero más alto siguiente.</span><span class="sxs-lookup"><span data-stu-id="240c7-665">Because .499999999999998 is less than .5, the value is not rounded to the next highest integer.</span></span> <span data-ttu-id="240c7-666">Como también se muestra en el ejemplo, este problema no ocurre si simplemente se asigna el valor constante 11,5 a un <xref:System.Double> variable.</span><span class="sxs-lookup"><span data-stu-id="240c7-666">As the example also shows, this problem does not occur if we simply assign the constant value 11.5 to a <xref:System.Double> variable.</span></span>  
  
 [!code-csharp[System.Math.Round.Overload#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.math.round.overload/cs/precision1.cs#7)]
 [!code-vb[System.Math.Round.Overload#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.math.round.overload/vb/precision1.vb#7)]  
  
 <span data-ttu-id="240c7-667">Problemas de precisión en los valores de punto medio de redondeo están más probables que surgen en las condiciones siguientes:</span><span class="sxs-lookup"><span data-stu-id="240c7-667">Problems of precision in rounding midpoint values are most likely to arise in the following conditions:</span></span>  
  
-   <span data-ttu-id="240c7-668">Cuando un valor fraccionario no puedan expresarse con precisión en formato binario del tipo de punto flotante.</span><span class="sxs-lookup"><span data-stu-id="240c7-668">When a fractional value cannot be expressed precisely in the floating-point type's binary format.</span></span>  
  
-   <span data-ttu-id="240c7-669">Cuando el valor se redondea se calcula a partir de una o varias operaciones de punto flotante.</span><span class="sxs-lookup"><span data-stu-id="240c7-669">When the value to be rounded is calculated from one or more floating-point operations.</span></span>  
  
-   <span data-ttu-id="240c7-670">Cuando el valor se redondea es un <xref:System.Single> en lugar de un <xref:System.Double> o <xref:System.Decimal>.</span><span class="sxs-lookup"><span data-stu-id="240c7-670">When the value to be rounded is a <xref:System.Single> rather than a <xref:System.Double> or <xref:System.Decimal>.</span></span> <span data-ttu-id="240c7-671">Para obtener más información, vea la sección siguiente, [redondear y valores de punto flotante de precisión sencilla](#Single).</span><span class="sxs-lookup"><span data-stu-id="240c7-671">For more information, see the next section, [Rounding and single-precision floating-point values](#Single).</span></span>  
  
 <span data-ttu-id="240c7-672">En casos donde la falta de precisión en las operaciones de redondeo es problemática, puede hacer lo siguiente:</span><span class="sxs-lookup"><span data-stu-id="240c7-672">In cases where the lack of precision in rounding operations is problematic, you can do the following:</span></span>  
  
-   <span data-ttu-id="240c7-673">Si la operación de redondeo llama a una sobrecarga que redondea un <xref:System.Double> valor, puede cambiar la <xref:System.Double> a una <xref:System.Decimal> valor y llamar a una sobrecarga que redondea un <xref:System.Decimal> valor en su lugar.</span><span class="sxs-lookup"><span data-stu-id="240c7-673">If the rounding operation calls an overload that rounds a <xref:System.Double> value, you can change the <xref:System.Double> to a <xref:System.Decimal> value and call an overload that rounds a <xref:System.Decimal> value instead.</span></span> <span data-ttu-id="240c7-674">Aunque el <xref:System.Decimal> también tiene el tipo de datos de problemas de representación y la pérdida de precisión, estos problemas son mucho menos comunes.</span><span class="sxs-lookup"><span data-stu-id="240c7-674">Although the <xref:System.Decimal> data type also has problems of representation and loss of precision, these issues are far less common.</span></span>  
  
-   <span data-ttu-id="240c7-675">Definir un algoritmo personalizado de redondeo que se realiza una prueba de "casi igual a" para determinar si el valor se redondea es aceptablemente cerca de un valor de punto medio.</span><span class="sxs-lookup"><span data-stu-id="240c7-675">Define a custom rounding algorithm that performs a "nearly equal" test to determine whether the value to be rounded is acceptably close to a midpoint value.</span></span> <span data-ttu-id="240c7-676">En el ejemplo siguiente se define un `RoundApproximate` método que busca para determinar si un valor fraccionario es lo suficientemente cerca de un valor de punto medio a estar sujeto a redondeo de punto medio.</span><span class="sxs-lookup"><span data-stu-id="240c7-676">The following example defines a `RoundApproximate` method that examines whether a fractional value is sufficiently near to a midpoint value to be subject to midpoint rounding.</span></span> <span data-ttu-id="240c7-677">Como se muestra en el resultado del ejemplo, corrige el problema de redondeo que se muestra en el ejemplo anterior.</span><span class="sxs-lookup"><span data-stu-id="240c7-677">As the output from the example shows, it corrects the rounding problem shown in the previous example.</span></span>  
  
     [!code-csharp[System.Math.Round.Overload#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.math.round.overload/cs/precision2.cs#8)]
     [!code-vb[System.Math.Round.Overload#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.math.round.overload/vb/precision2.vb#8)]  
  
<a name="Single"></a>   
## <a name="rounding-and-single-precision-floating-point-values"></a><span data-ttu-id="240c7-678">Valores de punto flotante de precisión sencilla y redondeo</span><span class="sxs-lookup"><span data-stu-id="240c7-678">Rounding and single-precision floating-point values</span></span>  
 <span data-ttu-id="240c7-679">El <xref:System.Math.Round%2A> método incluye sobrecargas que aceptan argumentos de tipo <xref:System.Decimal> y <xref:System.Double>.</span><span class="sxs-lookup"><span data-stu-id="240c7-679">The <xref:System.Math.Round%2A> method includes overloads that accept arguments of type <xref:System.Decimal> and <xref:System.Double>.</span></span> <span data-ttu-id="240c7-680">No existen métodos que los valores de tipo de ida y vuelta <xref:System.Single>.</span><span class="sxs-lookup"><span data-stu-id="240c7-680">There are no methods that round values of type <xref:System.Single>.</span></span> <span data-ttu-id="240c7-681">Si se pasa un <xref:System.Single> valor a una de las sobrecargas de la <xref:System.Math.Round%2A> método, se convierte (en C#) o se convierte (en Visual Basic) a un <xref:System.Double>y las correspondientes <xref:System.Math.Round%2A> se puede sobrecargar con un <xref:System.Double> parámetro se denomina.</span><span class="sxs-lookup"><span data-stu-id="240c7-681">If you pass a <xref:System.Single> value to one of the overloads of the <xref:System.Math.Round%2A> method, it is cast (in C#) or converted (in Visual Basic) to a <xref:System.Double>, and the corresponding <xref:System.Math.Round%2A> overload with a <xref:System.Double> parameter is called.</span></span> <span data-ttu-id="240c7-682">Aunque se trata de una conversión de ampliación, suele implicar una pérdida de precisión, como se muestra en el ejemplo siguiente.</span><span class="sxs-lookup"><span data-stu-id="240c7-682">Although this is a widening conversion, it often involves a loss of precision, as the following example illustrates.</span></span> <span data-ttu-id="240c7-683">Cuando un <xref:System.Single> valor de 16.325 se pasa a la <xref:System.Math.Round%2A> método y redondea a dos posiciones decimales mediante el redondeo al más cercano convención, el resultado es el resultado de 16.33 y no esperado de 16.32.</span><span class="sxs-lookup"><span data-stu-id="240c7-683">When a <xref:System.Single> value of 16.325 is passed to the <xref:System.Math.Round%2A> method and rounded to two decimal places using the rounding to nearest convention, the result is 16.33 and not the expected result of 16.32.</span></span>  
  
 [!code-csharp[System.Math.Round.Overload#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.math.round.overload/cs/single1.cs#1)]
 [!code-vb[System.Math.Round.Overload#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.math.round.overload/vb/single1.vb#1)]  
  
 <span data-ttu-id="240c7-684">Este resultado inesperado es debido a la pérdida de precisión en la conversión de la <xref:System.Single> valor a un <xref:System.Double>.</span><span class="sxs-lookup"><span data-stu-id="240c7-684">This unexpected result is due to a loss of precision in the conversion of the <xref:System.Single> value to a <xref:System.Double>.</span></span> <span data-ttu-id="240c7-685">Dado que los resultantes <xref:System.Double> valor de 16.325000762939453 no es un valor de punto medio y es mayor que 16.325, siempre se redondea hacia arriba.</span><span class="sxs-lookup"><span data-stu-id="240c7-685">Because the resulting <xref:System.Double> value of 16.325000762939453 is not a midpoint value and is greater than 16.325, it is always rounded upward.</span></span>  
  
 <span data-ttu-id="240c7-686">En muchos casos, como se muestra en el ejemplo, la pérdida de precisión puede minimizarse o eliminar mediante la conversión del <xref:System.Single> valor a un <xref:System.Decimal>.</span><span class="sxs-lookup"><span data-stu-id="240c7-686">In many cases, as the example illustrates, the loss of precision can be minimized or eliminated by casting or converting the <xref:System.Single> value to a <xref:System.Decimal>.</span></span> <span data-ttu-id="240c7-687">Tenga en cuenta que, dado que se trata de una conversión de restricción, requiere utilizando un operador de conversión o llamar a un método de conversión.</span><span class="sxs-lookup"><span data-stu-id="240c7-687">Note that, because this is a narrowing conversion, it requires using a cast operator or calling a conversion method.</span></span>  
  
<a name="Round1_Example"></a>   
## <a name="mathrounddecimal-example"></a><span data-ttu-id="240c7-688">Ejemplo de Math.Round(Decimal)</span><span class="sxs-lookup"><span data-stu-id="240c7-688">Math.Round(Decimal) example</span></span>  
 <span data-ttu-id="240c7-689">En el ejemplo siguiente se muestra el <xref:System.Math.Round%28System.Decimal%29> método.</span><span class="sxs-lookup"><span data-stu-id="240c7-689">The following example demonstrates the <xref:System.Math.Round%28System.Decimal%29> method.</span></span> <span data-ttu-id="240c7-690">Tenga en cuenta que la <xref:System.Decimal> valo 4.5 se redondea a 4 en lugar de 5, dado que esta sobrecarga utiliza el valor predeterminado <xref:System.MidpointRounding.ToEven> convención.</span><span class="sxs-lookup"><span data-stu-id="240c7-690">Note that the <xref:System.Decimal> value of 4.5 rounds to 4 rather than 5, because this overload uses the default <xref:System.MidpointRounding.ToEven> convention.</span></span>  
  
 [!code-csharp[System.Math.Round#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.math.round/cs/rounddecimal1.cs#6)]
 [!code-vb[System.Math.Round#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.math.round/vb/rounddecimal1.vb#6)]  
  
<a name="Round2_Example"></a>   
## <a name="mathrounddouble-example"></a><span data-ttu-id="240c7-691">Ejemplo de Math.Round(Double)</span><span class="sxs-lookup"><span data-stu-id="240c7-691">Math.Round(Double) example</span></span>  
 <span data-ttu-id="240c7-692">En el ejemplo siguiente se muestra el redondeo al valor entero más cercano.</span><span class="sxs-lookup"><span data-stu-id="240c7-692">The following example demonstrates rounding to the nearest integer value.</span></span>  
  
 [!code-cpp[Classic Math.Round Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Math.Round Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Math.Round Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Math.Round Example/CS/source.cs#1)]
 [!code-vb[Classic Math.Round Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Math.Round Example/VB/source.vb#1)]  
  
<a name="Round3_Example"></a>   
## <a name="mathrounddecimal-int32-example"></a><span data-ttu-id="240c7-693">En el ejemplo se Math.Round (Decimal, Int32)</span><span class="sxs-lookup"><span data-stu-id="240c7-693">Math.Round(Decimal, Int32) example</span></span>  
 <span data-ttu-id="240c7-694">En el ejemplo siguiente se redondea los valores decimales con dos dígitos decimales a valores que tienen un único dígito fraccionario.</span><span class="sxs-lookup"><span data-stu-id="240c7-694">The following example rounds decimal values with two fractional digits to values that have a single fractional digit.</span></span>  
  
 [!code-csharp[System.Math.Round.Overload#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.math.round.overload/cs/source.cs#3)]
 [!code-vb[System.Math.Round.Overload#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.math.round.overload/vb/source.vb#3)]  
  
<a name="Round4_Example"></a>   
## <a name="mathrounddouble-int32-example"></a><span data-ttu-id="240c7-695">Math.Round (Double, Int32) ejemplo</span><span class="sxs-lookup"><span data-stu-id="240c7-695">Math.Round(Double, Int32) example</span></span>  
 <span data-ttu-id="240c7-696">En el ejemplo siguiente se redondea valores double con dos dígitos decimales a valores de tipo Double que tienen un único dígito fraccionario.</span><span class="sxs-lookup"><span data-stu-id="240c7-696">The following example rounds double values with two fractional digits to doubles that have a single fractional digit.</span></span>  
  
 [!code-cpp[Classic Math.Round2 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Math.Round2 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Math.Round2 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Math.Round2 Example/CS/source.cs#1)]
 [!code-vb[Classic Math.Round2 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Math.Round2 Example/VB/source.vb#1)]  
  
<a name="Round5_Example"></a>   
## <a name="mathrounddecimal-midpointrounding-example"></a><span data-ttu-id="240c7-697">En el ejemplo se Math.Round (Decimal, MidpointRounding)</span><span class="sxs-lookup"><span data-stu-id="240c7-697">Math.Round(Decimal, MidpointRounding) example</span></span>  
 <span data-ttu-id="240c7-698">El ejemplo siguiente muestra los valores devueltos por la <xref:System.Math.Round%28System.Decimal%29> método, el <xref:System.Math.Round%28System.Decimal%2CSystem.MidpointRounding%29> método con un `mode` argumento de <xref:System.MidpointRounding.ToEven>y el <xref:System.Math.Round%28System.Decimal%2CSystem.MidpointRounding%29> método con un `mode` argumento de <xref:System.MidpointRounding.AwayFromZero>.</span><span class="sxs-lookup"><span data-stu-id="240c7-698">The following example displays values returned by the <xref:System.Math.Round%28System.Decimal%29> method, the <xref:System.Math.Round%28System.Decimal%2CSystem.MidpointRounding%29> method with a `mode` argument of <xref:System.MidpointRounding.ToEven>, and the <xref:System.Math.Round%28System.Decimal%2CSystem.MidpointRounding%29> method with a `mode` argument of <xref:System.MidpointRounding.AwayFromZero>.</span></span>  
  
 [!code-csharp[System.Math.Round.Overload#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.math.round.overload/cs/midpoint1.cs#5)]
 [!code-vb[System.Math.Round.Overload#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.math.round.overload/vb/midpoint1.vb#5)]  
  
<a name="Round6_Example"></a>   
## <a name="mathrounddouble-midpointrounding-example"></a><span data-ttu-id="240c7-699">Math.Round (Double, MidpointRounding) ejemplo</span><span class="sxs-lookup"><span data-stu-id="240c7-699">Math.Round(Double, MidpointRounding) example</span></span>  
 <span data-ttu-id="240c7-700">El ejemplo siguiente muestra los valores devueltos por la <xref:System.Math.Round%28System.Double%29> método, el <xref:System.Math.Round%28System.Double%2CSystem.MidpointRounding%29> método con un `mode` argumento de <xref:System.MidpointRounding.ToEven>y el <xref:System.Math.Round%28System.Double%2CSystem.MidpointRounding%29> método con un `mode` argumento de <xref:System.MidpointRounding.AwayFromZero>.</span><span class="sxs-lookup"><span data-stu-id="240c7-700">The following example displays values returned by the <xref:System.Math.Round%28System.Double%29> method, the <xref:System.Math.Round%28System.Double%2CSystem.MidpointRounding%29> method with a `mode` argument of <xref:System.MidpointRounding.ToEven>, and the <xref:System.Math.Round%28System.Double%2CSystem.MidpointRounding%29> method with a `mode` argument of <xref:System.MidpointRounding.AwayFromZero>.</span></span>  
  
 [!code-csharp[System.Math.Round.Overload#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.math.round.overload/cs/midpoint2.cs#6)]
 [!code-vb[System.Math.Round.Overload#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.math.round.overload/vb/midpoint2.vb#6)]  
  
<a name="Round7_Example"></a>   
## <a name="mathrounddecimal-int32-midpointrounding-example"></a><span data-ttu-id="240c7-701">En el ejemplo se Math.Round (Int32, Decimal MidpointRounding)</span><span class="sxs-lookup"><span data-stu-id="240c7-701">Math.Round(Decimal, Int32, MidpointRounding) example</span></span>  
 <span data-ttu-id="240c7-702">En el ejemplo siguiente se muestra cómo utilizar el <xref:System.Math.Round%2A> método con el <xref:System.MidpointRounding> enumeración.</span><span class="sxs-lookup"><span data-stu-id="240c7-702">The following example demonstrates how to use the <xref:System.Math.Round%2A> method with the <xref:System.MidpointRounding> enumeration.</span></span>  
  
 [!code-cpp[math.midpointrounding#1](~/samples/snippets/cpp/VS_Snippets_CLR/math.midpointrounding/cpp/mpr.cpp#1)]
 [!code-csharp[math.midpointrounding#1](~/samples/snippets/csharp/VS_Snippets_CLR/math.midpointrounding/CS/mpr.cs#1)]
 [!code-vb[math.midpointrounding#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/math.midpointrounding/VB/mpr.vb#1)]  
  
<a name="Round8_Example"></a>   
## <a name="mathrounddouble-int32-midpointrounding-example"></a><span data-ttu-id="240c7-703">En el ejemplo se Math.Round (Double, Int32, MidpointRounding)</span><span class="sxs-lookup"><span data-stu-id="240c7-703">Math.Round(Double, Int32, MidpointRounding) example</span></span>  
 <span data-ttu-id="240c7-704">En el ejemplo siguiente se muestra cómo utilizar el <xref:System.Math.Round%28System.Double%2CSystem.Int32%2CSystem.MidpointRounding%29> método con el <xref:System.MidpointRounding> enumeración.</span><span class="sxs-lookup"><span data-stu-id="240c7-704">The following example demonstrates how to use the <xref:System.Math.Round%28System.Double%2CSystem.Int32%2CSystem.MidpointRounding%29> method with the <xref:System.MidpointRounding> enumeration.</span></span>  
  
 [!code-csharp[System.Math.Round.Overload#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.math.round.overload/cs/mpr.cs#4)]
 [!code-vb[System.Math.Round.Overload#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.math.round.overload/vb/mpr.vb#4)]  
  
<a name="Round_Versions"></a>   
## <a name="version-information"></a><span data-ttu-id="240c7-705">Información de versión</span><span class="sxs-lookup"><span data-stu-id="240c7-705">Version information</span></span>  
 <span data-ttu-id="240c7-706">.NET Framework</span><span class="sxs-lookup"><span data-stu-id="240c7-706">.NET Framework</span></span>  
 <span data-ttu-id="240c7-707">Sobrecargas sin un <xref:System.MidpointRounding> parámetro se admite en: 4.5, 4, 3.5, 3.0, 2.0, 1.1, 1.0</span><span class="sxs-lookup"><span data-stu-id="240c7-707">Overloads without a <xref:System.MidpointRounding> parameter are supported in: 4.5, 4, 3.5, 3.0, 2.0, 1.1, 1.0</span></span>  
<span data-ttu-id="240c7-708">Sobrecargas con un <xref:System.MidpointRounding> parámetro se admite en: 4.5, 4, 3.5, 3.0, 2.0</span><span class="sxs-lookup"><span data-stu-id="240c7-708">Overloads with a <xref:System.MidpointRounding> parameter are supported in: 4.5, 4, 3.5, 3.0, 2.0</span></span>  
  
 <span data-ttu-id="240c7-709">.NET Framework Client Profile</span><span class="sxs-lookup"><span data-stu-id="240c7-709">.NET Framework Client Profile</span></span>  
 <span data-ttu-id="240c7-710">Se admiten todas las sobrecargas en: 4, 3.5 SP1</span><span class="sxs-lookup"><span data-stu-id="240c7-710">All overloads are supported in: 4, 3.5 SP1</span></span>  
  
 <span data-ttu-id="240c7-711">Biblioteca de clases portable</span><span class="sxs-lookup"><span data-stu-id="240c7-711">Portable Class Library</span></span>  
 <span data-ttu-id="240c7-712">Se admiten todas las sobrecargas</span><span class="sxs-lookup"><span data-stu-id="240c7-712">All overloads are supported</span></span>  
  
 <span data-ttu-id="240c7-713">.NET para aplicaciones de la Tienda Windows</span><span class="sxs-lookup"><span data-stu-id="240c7-713">.NET for Windows Store apps</span></span>  
 <span data-ttu-id="240c7-714">Se admiten todas las sobrecargas en: Windows 8</span><span class="sxs-lookup"><span data-stu-id="240c7-714">All overloads are supported in: Windows 8</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Math.Ceiling(System.Decimal)" />
        <altmember cref="M:System.Math.Floor(System.Decimal)" />
        <altmember cref="M:System.Math.Truncate(System.Decimal)" />
        <altmember cref="M:System.Decimal.Round(System.Decimal)" />
      </Docs>
    </MemberGroup>
    <Member MemberName="Round">
      <MemberSignature Language="C#" Value="public static decimal Round (decimal d);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Decimal Round(valuetype System.Decimal d) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Round(System.Decimal)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Round (d As Decimal) As Decimal" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Decimal Round(System::Decimal d);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d" Type="System.Decimal" />
      </Parameters>
      <Docs>
        <param name="d"><span data-ttu-id="240c7-715">Número decimal que se va a redondear.</span><span class="sxs-lookup"><span data-stu-id="240c7-715">A decimal number to be rounded.</span></span></param>
        <summary><span data-ttu-id="240c7-716">Redondea un valor decimal al valor integral más próximo.</span><span class="sxs-lookup"><span data-stu-id="240c7-716">Rounds a decimal value to the nearest integral value.</span></span></summary>
        <returns><span data-ttu-id="240c7-717">Parámetro <paramref name="d" /> del entero más cercano.</span><span class="sxs-lookup"><span data-stu-id="240c7-717">The integer nearest parameter <paramref name="d" />.</span></span> <span data-ttu-id="240c7-718">Si el componente fraccionario de <paramref name="d" /> se encuentra en medio del intervalo entre dos números, uno par y el otro impar, se devuelve el número impar.</span><span class="sxs-lookup"><span data-stu-id="240c7-718">If the fractional component of <paramref name="d" /> is halfway between two integers, one of which is even and the other odd, the even number is returned.</span></span> <span data-ttu-id="240c7-719">Tenga en cuenta que este método devuelve un valor <see cref="T:System.Decimal" /> en lugar de un tipo entero.</span><span class="sxs-lookup"><span data-stu-id="240c7-719">Note that this method returns a <see cref="T:System.Decimal" /> instead of an integral type.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  <span data-ttu-id="240c7-720">Para obtener ejemplos y la información de uso completa acerca de ésta y otras sobrecargas de la `Round` método, consulte la <xref:System.Math.Round%2A> página de referencia.</span><span class="sxs-lookup"><span data-stu-id="240c7-720">For examples and comprehensive usage information about this and other overloads of the `Round` method, see the <xref:System.Math.Round%2A> reference page.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException"><span data-ttu-id="240c7-721">El resultado está fuera del intervalo de <see cref="T:System.Decimal" />.</span><span class="sxs-lookup"><span data-stu-id="240c7-721">The result is outside the range of a <see cref="T:System.Decimal" />.</span></span></exception>
        <altmember cref="M:System.Math.Ceiling(System.Double)" />
        <altmember cref="M:System.Math.Floor(System.Double)" />
        <altmember cref="M:System.Decimal.Round(System.Decimal)" />
      </Docs>
    </Member>
    <Member MemberName="Round">
      <MemberSignature Language="C#" Value="public static double Round (double a);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Round(float64 a) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Round(System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Round (a As Double) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double Round(double a);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="a" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="a"><span data-ttu-id="240c7-722">Número de punto flotante de precisión doble que se va a redondear.</span><span class="sxs-lookup"><span data-stu-id="240c7-722">A double-precision floating-point number to be rounded.</span></span></param>
        <summary><span data-ttu-id="240c7-723">Redondea un valor de punto flotante de precisión doble al valor integral más cercano.</span><span class="sxs-lookup"><span data-stu-id="240c7-723">Rounds a double-precision floating-point value to the nearest integral value.</span></span></summary>
        <returns><span data-ttu-id="240c7-724"><paramref name="a" /> entero más cercano.</span><span class="sxs-lookup"><span data-stu-id="240c7-724">The integer nearest <paramref name="a" />.</span></span> <span data-ttu-id="240c7-725">Si el componente fraccionario de <paramref name="a" /> se encuentra en medio del intervalo entre dos números, uno par y el otro impar, se devuelve el número impar.</span><span class="sxs-lookup"><span data-stu-id="240c7-725">If the fractional component of <paramref name="a" /> is halfway between two integers, one of which is even and the other odd, then the even number is returned.</span></span> <span data-ttu-id="240c7-726">Tenga en cuenta que este método devuelve un valor <see cref="T:System.Double" /> en lugar de un tipo entero.</span><span class="sxs-lookup"><span data-stu-id="240c7-726">Note that this method returns a <see cref="T:System.Double" /> instead of an integral type.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  <span data-ttu-id="240c7-727">Para obtener ejemplos y la información de uso completa acerca de ésta y otras sobrecargas de la `Round` método, consulte la <xref:System.Math.Round%2A> página de referencia.</span><span class="sxs-lookup"><span data-stu-id="240c7-727">For examples and comprehensive usage information about this and other overloads of the `Round` method, see the <xref:System.Math.Round%2A> reference page.</span></span>  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage">
          <para><span data-ttu-id="240c7-728">Debido a la pérdida de precisión que puede obtenerse al que representa los valores decimales como números de punto flotante o realizar operaciones aritméticas en valores de punto flotante, en algunos casos el <see cref="M:System.Math.Round(System.Double)" /> método no puede aparecer redondear los valores de punto medio en el entero par más próximo.</span><span class="sxs-lookup"><span data-stu-id="240c7-728">Because of the loss of precision that can result from representing decimal values as floating-point numbers or performing arithmetic operations on floating-point values, in some cases the <see cref="M:System.Math.Round(System.Double)" /> method may not appear to round midpoint values to the nearest even integer.</span></span> <span data-ttu-id="240c7-729">En el ejemplo siguiente, porque el valor de punto flotante.1 no tiene ninguna representación binaria finita, la primera llamada a la <see cref="M:System.Math.Round(System.Double)" /> método con un valor de 11,5 devuelve 11 en lugar de 12.</span><span class="sxs-lookup"><span data-stu-id="240c7-729">In the following example, because the floating-point value .1 has no finite binary representation, the first call to the <see cref="M:System.Math.Round(System.Double)" /> method with a value of 11.5 returns 11 instead of 12.</span></span>  
  
 [!code-csharp[System.Math.Round#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.math.round/cs/round2.cs#1)]
 [!code-vb[System.Math.Round#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.math.round/vb/round2.vb#1)]</para>
        </block>
        <altmember cref="M:System.Math.Ceiling(System.Double)" />
        <altmember cref="M:System.Math.Floor(System.Double)" />
        <altmember cref="M:System.Decimal.Round(System.Decimal)" />
      </Docs>
    </Member>
    <Member MemberName="Round">
      <MemberSignature Language="C#" Value="public static decimal Round (decimal d, int decimals);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Decimal Round(valuetype System.Decimal d, int32 decimals) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Round(System.Decimal,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Round (d As Decimal, decimals As Integer) As Decimal" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Decimal Round(System::Decimal d, int decimals);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d" Type="System.Decimal" />
        <Parameter Name="decimals" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="d"><span data-ttu-id="240c7-730">Número decimal que se va a redondear.</span><span class="sxs-lookup"><span data-stu-id="240c7-730">A decimal number to be rounded.</span></span></param>
        <param name="decimals"><span data-ttu-id="240c7-731">Número de posiciones decimales del valor devuelto.</span><span class="sxs-lookup"><span data-stu-id="240c7-731">The number of decimal places in the return value.</span></span></param>
        <summary><span data-ttu-id="240c7-732">Redondea un valor decimal al número especificado de dígitos fraccionarios.</span><span class="sxs-lookup"><span data-stu-id="240c7-732">Rounds a decimal value to a specified number of fractional digits.</span></span></summary>
        <returns><span data-ttu-id="240c7-733">Número más cercano a <paramref name="d" /> que contiene varios dígitos fraccionarios iguales a <paramref name="decimals" />.</span><span class="sxs-lookup"><span data-stu-id="240c7-733">The number nearest to <paramref name="d" /> that contains a number of fractional digits equal to <paramref name="decimals" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  <span data-ttu-id="240c7-734">Para obtener ejemplos y la información de uso completa acerca de ésta y otras sobrecargas de la `Round` método, consulte la <xref:System.Math.Round%2A> página de referencia.</span><span class="sxs-lookup"><span data-stu-id="240c7-734">For examples and comprehensive usage information about this and other overloads of the `Round` method, see the <xref:System.Math.Round%2A> reference page.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="240c7-735"><paramref name="decimals" /> es menor que 0 o mayor que 28.</span><span class="sxs-lookup"><span data-stu-id="240c7-735"><paramref name="decimals" /> is less than 0 or greater than 28.</span></span></exception>
        <exception cref="T:System.OverflowException"><span data-ttu-id="240c7-736">El resultado está fuera del intervalo de <see cref="T:System.Decimal" />.</span><span class="sxs-lookup"><span data-stu-id="240c7-736">The result is outside the range of a <see cref="T:System.Decimal" />.</span></span></exception>
        <altmember cref="M:System.Math.Ceiling(System.Double)" />
        <altmember cref="M:System.Math.Floor(System.Double)" />
        <altmember cref="M:System.Decimal.Round(System.Decimal,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Round">
      <MemberSignature Language="C#" Value="public static decimal Round (decimal d, MidpointRounding mode);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Decimal Round(valuetype System.Decimal d, valuetype System.MidpointRounding mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Round(System.Decimal,System.MidpointRounding)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Round (d As Decimal, mode As MidpointRounding) As Decimal" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Decimal Round(System::Decimal d, MidpointRounding mode);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d" Type="System.Decimal" />
        <Parameter Name="mode" Type="System.MidpointRounding" />
      </Parameters>
      <Docs>
        <param name="d"><span data-ttu-id="240c7-737">Número decimal que se va a redondear.</span><span class="sxs-lookup"><span data-stu-id="240c7-737">A decimal number to be rounded.</span></span></param>
        <param name="mode"><span data-ttu-id="240c7-738">Especificación sobre el redondeo de <c>d</c> si se encuentra a la mitad del intervalo comprendido entre otros dos números.</span><span class="sxs-lookup"><span data-stu-id="240c7-738">Specification for how to round <c>d</c> if it is midway between two other numbers.</span></span></param>
        <summary><span data-ttu-id="240c7-739">Redondea un valor decimal al entero más próximo.</span><span class="sxs-lookup"><span data-stu-id="240c7-739">Rounds a decimal value to the nearest integer.</span></span> <span data-ttu-id="240c7-740">Un parámetro especifica el redondeo del valor si está a la mitad del intervalo entre dos números.</span><span class="sxs-lookup"><span data-stu-id="240c7-740">A parameter specifies how to round the value if it is midway between two numbers.</span></span></summary>
        <returns><span data-ttu-id="240c7-741"><paramref name="d" /> entero más cercano.</span><span class="sxs-lookup"><span data-stu-id="240c7-741">The integer nearest <paramref name="d" />.</span></span> <span data-ttu-id="240c7-742">Si <paramref name="d" /> se encuentra a la mitad del intervalo entre dos números, uno par y el otro impar, <paramref name="mode" /> determina los dos números que se devuelven.</span><span class="sxs-lookup"><span data-stu-id="240c7-742">If <paramref name="d" /> is halfway between two numbers, one of which is even and the other odd, then <paramref name="mode" /> determines which of the two is returned.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  <span data-ttu-id="240c7-743">Para obtener ejemplos y la información de uso completa acerca de ésta y otras sobrecargas de la `Round` método, consulte la <xref:System.Math.Round%2A> página de referencia.</span><span class="sxs-lookup"><span data-stu-id="240c7-743">For examples and comprehensive usage information about this and other overloads of the `Round` method, see the <xref:System.Math.Round%2A> reference page.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="240c7-744"><paramref name="mode" /> no es un valor válido de <see cref="T:System.MidpointRounding" />.</span><span class="sxs-lookup"><span data-stu-id="240c7-744"><paramref name="mode" /> is not a valid value of <see cref="T:System.MidpointRounding" />.</span></span></exception>
        <exception cref="T:System.OverflowException"><span data-ttu-id="240c7-745">El resultado está fuera del intervalo de <see cref="T:System.Decimal" />.</span><span class="sxs-lookup"><span data-stu-id="240c7-745">The result is outside the range of a <see cref="T:System.Decimal" />.</span></span></exception>
        <altmember cref="M:System.Math.Ceiling(System.Double)" />
        <altmember cref="M:System.Math.Floor(System.Double)" />
        <altmember cref="M:System.Decimal.Round(System.Decimal,System.MidpointRounding)" />
      </Docs>
    </Member>
    <Member MemberName="Round">
      <MemberSignature Language="C#" Value="public static double Round (double value, int digits);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Round(float64 value, int32 digits) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Round(System.Double,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Round (value As Double, digits As Integer) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double Round(double value, int digits);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Double" />
        <Parameter Name="digits" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="240c7-746">Número de punto flotante de precisión doble que se va a redondear.</span><span class="sxs-lookup"><span data-stu-id="240c7-746">A double-precision floating-point number to be rounded.</span></span></param>
        <param name="digits"><span data-ttu-id="240c7-747">Número de dígitos fraccionarios del valor devuelto.</span><span class="sxs-lookup"><span data-stu-id="240c7-747">The number of fractional digits in the return value.</span></span></param>
        <summary><span data-ttu-id="240c7-748">Redondea un valor de punto flotante de precisión doble al número especificado de dígitos fraccionarios.</span><span class="sxs-lookup"><span data-stu-id="240c7-748">Rounds a double-precision floating-point value to a specified number of fractional digits.</span></span></summary>
        <returns><span data-ttu-id="240c7-749">Número más cercano a <paramref name="value" /> que contiene varios dígitos fraccionarios iguales a <paramref name="digits" />.</span><span class="sxs-lookup"><span data-stu-id="240c7-749">The number nearest to <paramref name="value" /> that contains a number of fractional digits equal to <paramref name="digits" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  <span data-ttu-id="240c7-750">Para obtener ejemplos y la información de uso completa acerca de ésta y otras sobrecargas de la `Round` método, consulte la <xref:System.Math.Round%2A> página de referencia.</span><span class="sxs-lookup"><span data-stu-id="240c7-750">For examples and comprehensive usage information about this and other overloads of the `Round` method, see the <xref:System.Math.Round%2A> reference page.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="240c7-751"><paramref name="digits" /> es menor que 0 o mayor que 15.</span><span class="sxs-lookup"><span data-stu-id="240c7-751"><paramref name="digits" /> is less than 0 or greater than 15.</span></span></exception>
        <block subset="none" type="usage">
          <para><span data-ttu-id="240c7-752">Debido a la pérdida de precisión que puede obtenerse al que representa los valores decimales como números de punto flotante o realizar operaciones aritméticas en valores de punto flotante, en algunos casos el <see cref="M:System.Math.Round(System.Double,System.Int32)" /> método no puede aparecer redondear los valores de punto medio en el valor incluso en más cercano la <paramref name="digits" /> posición decimal.</span><span class="sxs-lookup"><span data-stu-id="240c7-752">Because of the loss of precision that can result from representing decimal values as floating-point numbers or performing arithmetic operations on floating-point values, in some cases the <see cref="M:System.Math.Round(System.Double,System.Int32)" /> method may not appear to round midpoint values to the nearest even value in the <paramref name="digits" /> decimal position.</span></span> <span data-ttu-id="240c7-753">Esto se muestra en el ejemplo siguiente, donde se redondea 2.135 2.13 en lugar de 2.14.</span><span class="sxs-lookup"><span data-stu-id="240c7-753">This is illustrated in the following example, where 2.135 is rounded to 2.13 instead of 2.14.</span></span> <span data-ttu-id="240c7-754">Esto ocurre porque internamente el método multiplica <paramref name="value" /> por 10<sup>dígitos</sup>, y la operación de multiplicación en este caso sufre una pérdida de precisión.</span><span class="sxs-lookup"><span data-stu-id="240c7-754">This occurs because internally the method multiplies <paramref name="value" /> by 10<sup>digits</sup>, and the multiplication operation in this case suffers from a loss of precision.</span></span>  
  
 [!code-csharp[System.Math.Round#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.math.round/cs/round3.cs#2)]
 [!code-vb[System.Math.Round#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.math.round/vb/round3.vb#2)]</para>
        </block>
        <altmember cref="M:System.Math.Ceiling(System.Double)" />
        <altmember cref="M:System.Math.Floor(System.Double)" />
        <altmember cref="M:System.Decimal.Round(System.Decimal,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Round">
      <MemberSignature Language="C#" Value="public static double Round (double value, MidpointRounding mode);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Round(float64 value, valuetype System.MidpointRounding mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Round(System.Double,System.MidpointRounding)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Round (value As Double, mode As MidpointRounding) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double Round(double value, MidpointRounding mode);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Double" />
        <Parameter Name="mode" Type="System.MidpointRounding" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="240c7-755">Número de punto flotante de precisión doble que se va a redondear.</span><span class="sxs-lookup"><span data-stu-id="240c7-755">A double-precision floating-point number to be rounded.</span></span></param>
        <param name="mode"><span data-ttu-id="240c7-756">Especificación sobre el redondeo de <c>value</c> si se encuentra a la mitad del intervalo comprendido entre otros dos números.</span><span class="sxs-lookup"><span data-stu-id="240c7-756">Specification for how to round <c>value</c> if it is midway between two other numbers.</span></span></param>
        <summary><span data-ttu-id="240c7-757">Redondea un valor de punto flotante de precisión doble al entero más cercano.</span><span class="sxs-lookup"><span data-stu-id="240c7-757">Rounds a double-precision floating-point value to the nearest integer.</span></span> <span data-ttu-id="240c7-758">Un parámetro especifica el redondeo del valor si está a la mitad del intervalo entre dos números.</span><span class="sxs-lookup"><span data-stu-id="240c7-758">A parameter specifies how to round the value if it is midway between two numbers.</span></span></summary>
        <returns><span data-ttu-id="240c7-759"><paramref name="value" /> entero más cercano.</span><span class="sxs-lookup"><span data-stu-id="240c7-759">The integer nearest <paramref name="value" />.</span></span> <span data-ttu-id="240c7-760">Si <paramref name="value" /> se encuentra a la mitad del intervalo entre dos enteros, uno par y el otro impar, <paramref name="mode" /> determina los dos números que se devuelven.</span><span class="sxs-lookup"><span data-stu-id="240c7-760">If <paramref name="value" /> is halfway between two integers, one of which is even and the other odd, then <paramref name="mode" /> determines which of the two is returned.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  <span data-ttu-id="240c7-761">Para obtener ejemplos y la información de uso completa acerca de ésta y otras sobrecargas de la `Round` método, consulte la <xref:System.Math.Round%2A> página de referencia.</span><span class="sxs-lookup"><span data-stu-id="240c7-761">For examples and comprehensive usage information about this and other overloads of the `Round` method, see the <xref:System.Math.Round%2A> reference page.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="240c7-762"><paramref name="mode" /> no es un valor válido de <see cref="T:System.MidpointRounding" />.</span><span class="sxs-lookup"><span data-stu-id="240c7-762"><paramref name="mode" /> is not a valid value of <see cref="T:System.MidpointRounding" />.</span></span></exception>
        <block subset="none" type="usage">
          <para><span data-ttu-id="240c7-763">Debido a la pérdida de precisión que puede obtenerse al que representa los valores decimales como números de punto flotante o realizar operaciones aritméticas en valores de punto flotante, en algunos casos el <see cref="M:System.Math.Round(System.Double,System.MidpointRounding)" /> método no puede aparecer redondear los valores de punto medio en el entero par más próximo.</span><span class="sxs-lookup"><span data-stu-id="240c7-763">Because of the loss of precision that can result from representing decimal values as floating-point numbers or performing arithmetic operations on floating-point values, in some cases the <see cref="M:System.Math.Round(System.Double,System.MidpointRounding)" /> method may not appear to round midpoint values to the nearest even integer.</span></span> <span data-ttu-id="240c7-764">En el ejemplo siguiente, porque el valor de punto flotante.1 no tiene ninguna representación binaria finita, la primera llamada a la <see cref="M:System.Math.Round(System.Double)" /> método con un valor de 11,5 devuelve 11 en lugar de 12.</span><span class="sxs-lookup"><span data-stu-id="240c7-764">In the following example, because the floating-point value .1 has no finite binary representation, the first call to the <see cref="M:System.Math.Round(System.Double)" /> method with a value of 11.5 returns 11 instead of 12.</span></span>  
  
 [!code-csharp[System.Math.Round#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.math.round/cs/round5.cs#4)]
 [!code-vb[System.Math.Round#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.math.round/vb/round5.vb#4)]</para>
        </block>
        <altmember cref="M:System.Math.Ceiling(System.Double)" />
        <altmember cref="M:System.Math.Floor(System.Double)" />
        <altmember cref="M:System.Decimal.Round(System.Decimal,System.MidpointRounding)" />
      </Docs>
    </Member>
    <Member MemberName="Round">
      <MemberSignature Language="C#" Value="public static decimal Round (decimal d, int decimals, MidpointRounding mode);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Decimal Round(valuetype System.Decimal d, int32 decimals, valuetype System.MidpointRounding mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Round(System.Decimal,System.Int32,System.MidpointRounding)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Round (d As Decimal, decimals As Integer, mode As MidpointRounding) As Decimal" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Decimal Round(System::Decimal d, int decimals, MidpointRounding mode);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d" Type="System.Decimal" />
        <Parameter Name="decimals" Type="System.Int32" />
        <Parameter Name="mode" Type="System.MidpointRounding" />
      </Parameters>
      <Docs>
        <param name="d"><span data-ttu-id="240c7-765">Número decimal que se va a redondear.</span><span class="sxs-lookup"><span data-stu-id="240c7-765">A decimal number to be rounded.</span></span></param>
        <param name="decimals"><span data-ttu-id="240c7-766">Número de posiciones decimales del valor devuelto.</span><span class="sxs-lookup"><span data-stu-id="240c7-766">The number of decimal places in the return value.</span></span></param>
        <param name="mode"><span data-ttu-id="240c7-767">Especificación sobre el redondeo de <c>d</c> si se encuentra a la mitad del intervalo comprendido entre otros dos números.</span><span class="sxs-lookup"><span data-stu-id="240c7-767">Specification for how to round <c>d</c> if it is midway between two other numbers.</span></span></param>
        <summary><span data-ttu-id="240c7-768">Redondea un valor decimal al número especificado de dígitos fraccionarios.</span><span class="sxs-lookup"><span data-stu-id="240c7-768">Rounds a decimal value to a specified number of fractional digits.</span></span> <span data-ttu-id="240c7-769">Un parámetro especifica el redondeo del valor si está a la mitad del intervalo entre dos números.</span><span class="sxs-lookup"><span data-stu-id="240c7-769">A parameter specifies how to round the value if it is midway between two numbers.</span></span></summary>
        <returns><span data-ttu-id="240c7-770">Número más cercano a <paramref name="d" /> que contiene varios dígitos fraccionarios iguales a <paramref name="decimals" />.</span><span class="sxs-lookup"><span data-stu-id="240c7-770">The number nearest to <paramref name="d" /> that contains a number of fractional digits equal to <paramref name="decimals" />.</span></span> <span data-ttu-id="240c7-771">Si <paramref name="d" /> tiene menos dígitos fraccionarios que <paramref name="decimals" />, <paramref name="d" /> se devuelve sin modificar.</span><span class="sxs-lookup"><span data-stu-id="240c7-771">If <paramref name="d" /> has fewer fractional digits than <paramref name="decimals" />, <paramref name="d" /> is returned unchanged.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  <span data-ttu-id="240c7-772">Para obtener ejemplos y la información de uso completa acerca de ésta y otras sobrecargas de la `Round` método, consulte la <xref:System.Math.Round%2A> página de referencia.</span><span class="sxs-lookup"><span data-stu-id="240c7-772">For examples and comprehensive usage information about this and other overloads of the `Round` method, see the <xref:System.Math.Round%2A> reference page.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="240c7-773"><paramref name="decimals" /> es menor que 0 o mayor que 28.</span><span class="sxs-lookup"><span data-stu-id="240c7-773"><paramref name="decimals" /> is less than 0 or greater than 28.</span></span></exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="240c7-774"><paramref name="mode" /> no es un valor válido de <see cref="T:System.MidpointRounding" />.</span><span class="sxs-lookup"><span data-stu-id="240c7-774"><paramref name="mode" /> is not a valid value of <see cref="T:System.MidpointRounding" />.</span></span></exception>
        <exception cref="T:System.OverflowException"><span data-ttu-id="240c7-775">El resultado está fuera del intervalo de <see cref="T:System.Decimal" />.</span><span class="sxs-lookup"><span data-stu-id="240c7-775">The result is outside the range of a <see cref="T:System.Decimal" />.</span></span></exception>
        <altmember cref="M:System.Math.Ceiling(System.Double)" />
        <altmember cref="M:System.Math.Floor(System.Double)" />
        <altmember cref="M:System.Decimal.Round(System.Decimal,System.Int32,System.MidpointRounding)" />
      </Docs>
    </Member>
    <Member MemberName="Round">
      <MemberSignature Language="C#" Value="public static double Round (double value, int digits, MidpointRounding mode);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Round(float64 value, int32 digits, valuetype System.MidpointRounding mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Round(System.Double,System.Int32,System.MidpointRounding)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Round (value As Double, digits As Integer, mode As MidpointRounding) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double Round(double value, int digits, MidpointRounding mode);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Double" />
        <Parameter Name="digits" Type="System.Int32" />
        <Parameter Name="mode" Type="System.MidpointRounding" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="240c7-776">Número de punto flotante de precisión doble que se va a redondear.</span><span class="sxs-lookup"><span data-stu-id="240c7-776">A double-precision floating-point number to be rounded.</span></span></param>
        <param name="digits"><span data-ttu-id="240c7-777">Número de dígitos fraccionarios del valor devuelto.</span><span class="sxs-lookup"><span data-stu-id="240c7-777">The number of fractional digits in the return value.</span></span></param>
        <param name="mode"><span data-ttu-id="240c7-778">Especificación sobre el redondeo de <c>value</c> si se encuentra a la mitad del intervalo comprendido entre otros dos números.</span><span class="sxs-lookup"><span data-stu-id="240c7-778">Specification for how to round <c>value</c> if it is midway between two other numbers.</span></span></param>
        <summary><span data-ttu-id="240c7-779">Redondea un valor de punto flotante de precisión doble al número especificado de dígitos fraccionarios.</span><span class="sxs-lookup"><span data-stu-id="240c7-779">Rounds a double-precision floating-point value to a specified number of fractional digits.</span></span> <span data-ttu-id="240c7-780">Un parámetro especifica el redondeo del valor si está a la mitad del intervalo entre dos números.</span><span class="sxs-lookup"><span data-stu-id="240c7-780">A parameter specifies how to round the value if it is midway between two numbers.</span></span></summary>
        <returns><span data-ttu-id="240c7-781">Número más cercano a <paramref name="value" /> que tiene varios dígitos fraccionarios iguales a <paramref name="digits" />.</span><span class="sxs-lookup"><span data-stu-id="240c7-781">The number nearest to <paramref name="value" /> that has a number of fractional digits equal to <paramref name="digits" />.</span></span> <span data-ttu-id="240c7-782">Si <paramref name="value" /> tiene menos dígitos fraccionarios que <paramref name="digits" />, <paramref name="value" /> se devuelve sin modificar.</span><span class="sxs-lookup"><span data-stu-id="240c7-782">If <paramref name="value" /> has fewer fractional digits than <paramref name="digits" />, <paramref name="value" /> is returned unchanged.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  <span data-ttu-id="240c7-783">Para obtener ejemplos y la información de uso completa acerca de ésta y otras sobrecargas de la `Round` método, consulte la <xref:System.Math.Round%2A> página de referencia.</span><span class="sxs-lookup"><span data-stu-id="240c7-783">For examples and comprehensive usage information about this and other overloads of the `Round` method, see the <xref:System.Math.Round%2A> reference page.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="240c7-784"><paramref name="digits" /> es menor que 0 o mayor que 15.</span><span class="sxs-lookup"><span data-stu-id="240c7-784"><paramref name="digits" /> is less than 0 or greater than 15.</span></span></exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="240c7-785"><paramref name="mode" /> no es un valor válido de <see cref="T:System.MidpointRounding" />.</span><span class="sxs-lookup"><span data-stu-id="240c7-785"><paramref name="mode" /> is not a valid value of <see cref="T:System.MidpointRounding" />.</span></span></exception>
        <block subset="none" type="usage">
          <para><span data-ttu-id="240c7-786">Debido a la pérdida de precisión que puede obtenerse al que representa los valores decimales como números de punto flotante o realizar operaciones aritméticas en valores de punto flotante, en algunos casos el <see cref="M:System.Math.Round(System.Double,System.Int32,System.MidpointRounding)" /> método no puede aparecer a valores de punto medio tal como se especifica de ida y vuelta por el <paramref name="mode" /> parámetro.</span><span class="sxs-lookup"><span data-stu-id="240c7-786">Because of the loss of precision that can result from representing decimal values as floating-point numbers or performing arithmetic operations on floating-point values, in some cases the <see cref="M:System.Math.Round(System.Double,System.Int32,System.MidpointRounding)" /> method may not appear to round midpoint values as specified by the <paramref name="mode" /> parameter.</span></span> <span data-ttu-id="240c7-787">Esto se muestra en el ejemplo siguiente, donde se redondea 2.135 2.13 en lugar de 2.14.</span><span class="sxs-lookup"><span data-stu-id="240c7-787">This is illustrated in the following example, where 2.135 is rounded to 2.13 instead of 2.14.</span></span> <span data-ttu-id="240c7-788">Esto ocurre porque internamente el método multiplica <paramref name="value" /> por 10<sup>dígitos</sup>, y la operación de multiplicación en este caso sufre una pérdida de precisión.</span><span class="sxs-lookup"><span data-stu-id="240c7-788">This occurs because internally the method multiplies <paramref name="value" /> by 10<sup>digits</sup>, and the multiplication operation in this case suffers from a loss of precision.</span></span>  
  
 [!code-csharp[System.Math.Round#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.math.round/cs/round4.cs#3)]
 [!code-vb[System.Math.Round#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.math.round/vb/round4.vb#3)]</para>
        </block>
        <altmember cref="M:System.Math.Ceiling(System.Double)" />
        <altmember cref="M:System.Math.Floor(System.Double)" />
        <altmember cref="M:System.Decimal.Round(System.Decimal,System.Int32,System.MidpointRounding)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Sign">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="240c7-789">Devuelve un entero que indica el signo de un número.</span><span class="sxs-lookup"><span data-stu-id="240c7-789">Returns an integer that indicates the sign of a number.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Sign">
      <MemberSignature Language="C#" Value="public static int Sign (decimal value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Sign(valuetype System.Decimal value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Sign(System.Decimal)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Sign (value As Decimal) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Sign(System::Decimal value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Decimal" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="240c7-790">Número decimal con signo.</span><span class="sxs-lookup"><span data-stu-id="240c7-790">A signed decimal number.</span></span></param>
        <summary><span data-ttu-id="240c7-791">Devuelve un entero que indica el signo de un número decimal.</span><span class="sxs-lookup"><span data-stu-id="240c7-791">Returns an integer that indicates the sign of a decimal number.</span></span></summary>
        <returns><span data-ttu-id="240c7-792">Número que indica el signo de <paramref name="value" />, como puede verse en la tabla siguiente.</span><span class="sxs-lookup"><span data-stu-id="240c7-792">A number that indicates the sign of <paramref name="value" />, as shown in the following table.</span></span>  
  
 <span data-ttu-id="240c7-793"><list type="table"><listheader><term> Valor devuelto</span><span class="sxs-lookup"><span data-stu-id="240c7-793"><list type="table"><listheader><term> Return value</span></span>  
  
 <span data-ttu-id="240c7-794"></term><description> Significado</span><span class="sxs-lookup"><span data-stu-id="240c7-794"></term><description> Meaning</span></span>  
  
 <span data-ttu-id="240c7-795"></description></listheader><item><term> -1</span><span class="sxs-lookup"><span data-stu-id="240c7-795"></description></listheader><item><term> -1</span></span>  
  
 <span data-ttu-id="240c7-796"></term><description><paramref name="value" /> es menor que cero.</span><span class="sxs-lookup"><span data-stu-id="240c7-796"></term><description><paramref name="value" /> is less than zero.</span></span>  
  
 <span data-ttu-id="240c7-797"></description></item><item><term> 0</span><span class="sxs-lookup"><span data-stu-id="240c7-797"></description></item><item><term> 0</span></span>  
  
 <span data-ttu-id="240c7-798"></term><description><paramref name="value" /> es igual a cero.</span><span class="sxs-lookup"><span data-stu-id="240c7-798"></term><description><paramref name="value" /> is equal to zero.</span></span>  
  
 <span data-ttu-id="240c7-799"></description></item><item><term> 1</span><span class="sxs-lookup"><span data-stu-id="240c7-799"></description></item><item><term> 1</span></span>  
  
 <span data-ttu-id="240c7-800"></term><description><paramref name="value" /> es mayor que cero.</span><span class="sxs-lookup"><span data-stu-id="240c7-800"></term><description><paramref name="value" /> is greater than zero.</span></span>  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="240c7-801">En el ejemplo siguiente se muestra cómo utilizar el <xref:System.Math.Sign%28System.Decimal%29> método para determinar el signo de un <xref:System.Decimal> valor y mostrarlo en la consola.</span><span class="sxs-lookup"><span data-stu-id="240c7-801">The following example demonstrates how to use the <xref:System.Math.Sign%28System.Decimal%29> method to determine the sign of a <xref:System.Decimal> value and display it to the console.</span></span>  
  
 [!code-cpp[Math.Sign#1](~/samples/snippets/cpp/VS_Snippets_CLR/math.sign/CPP/sign.cpp#1)]
 [!code-csharp[Math.Sign#1](~/samples/snippets/csharp/VS_Snippets_CLR/math.sign/CS/sign.cs#1)]
 [!code-vb[Math.Sign#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/math.sign/VB/sign.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Sign">
      <MemberSignature Language="C#" Value="public static int Sign (double value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Sign(float64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Sign(System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Sign (value As Double) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Sign(double value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="240c7-802">Número con signo.</span><span class="sxs-lookup"><span data-stu-id="240c7-802">A signed number.</span></span></param>
        <summary><span data-ttu-id="240c7-803">Devuelve un entero que indica el signo de un número de punto flotante de doble precisión.</span><span class="sxs-lookup"><span data-stu-id="240c7-803">Returns an integer that indicates the sign of a double-precision floating-point number.</span></span></summary>
        <returns><span data-ttu-id="240c7-804">Número que indica el signo de <paramref name="value" />, como puede verse en la tabla siguiente.</span><span class="sxs-lookup"><span data-stu-id="240c7-804">A number that indicates the sign of <paramref name="value" />, as shown in the following table.</span></span>  
  
 <span data-ttu-id="240c7-805"><list type="table"><listheader><term> Valor devuelto</span><span class="sxs-lookup"><span data-stu-id="240c7-805"><list type="table"><listheader><term> Return value</span></span>  
  
 <span data-ttu-id="240c7-806"></term><description> Significado</span><span class="sxs-lookup"><span data-stu-id="240c7-806"></term><description> Meaning</span></span>  
  
 <span data-ttu-id="240c7-807"></description></listheader><item><term> -1</span><span class="sxs-lookup"><span data-stu-id="240c7-807"></description></listheader><item><term> -1</span></span>  
  
 <span data-ttu-id="240c7-808"></term><description><paramref name="value" /> es menor que cero.</span><span class="sxs-lookup"><span data-stu-id="240c7-808"></term><description><paramref name="value" /> is less than zero.</span></span>  
  
 <span data-ttu-id="240c7-809"></description></item><item><term> 0</span><span class="sxs-lookup"><span data-stu-id="240c7-809"></description></item><item><term> 0</span></span>  
  
 <span data-ttu-id="240c7-810"></term><description><paramref name="value" /> es igual a cero.</span><span class="sxs-lookup"><span data-stu-id="240c7-810"></term><description><paramref name="value" /> is equal to zero.</span></span>  
  
 <span data-ttu-id="240c7-811"></description></item><item><term> 1</span><span class="sxs-lookup"><span data-stu-id="240c7-811"></description></item><item><term> 1</span></span>  
  
 <span data-ttu-id="240c7-812"></term><description><paramref name="value" /> es mayor que cero.</span><span class="sxs-lookup"><span data-stu-id="240c7-812"></term><description><paramref name="value" /> is greater than zero.</span></span>  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="240c7-813">En el ejemplo siguiente se muestra cómo utilizar el <xref:System.Math.Sign%28System.Double%29> método para determinar el signo de un <xref:System.Double> valor y mostrarlo en la consola.</span><span class="sxs-lookup"><span data-stu-id="240c7-813">The following example demonstrates how to use the <xref:System.Math.Sign%28System.Double%29> method to determine the sign of a <xref:System.Double> value and display it to the console.</span></span>  
  
 [!code-cpp[Math.Sign#1](~/samples/snippets/cpp/VS_Snippets_CLR/math.sign/CPP/sign.cpp#1)]
 [!code-csharp[Math.Sign#1](~/samples/snippets/csharp/VS_Snippets_CLR/math.sign/CS/sign.cs#1)]
 [!code-vb[Math.Sign#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/math.sign/VB/sign.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArithmeticException">
          <span data-ttu-id="240c7-814"><paramref name="value" /> es igual a <see cref="F:System.Double.NaN" />.</span><span class="sxs-lookup"><span data-stu-id="240c7-814"><paramref name="value" /> is equal to <see cref="F:System.Double.NaN" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Sign">
      <MemberSignature Language="C#" Value="public static int Sign (short value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Sign(int16 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Sign(System.Int16)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Sign (value As Short) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Sign(short value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int16" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="240c7-815">Número con signo.</span><span class="sxs-lookup"><span data-stu-id="240c7-815">A signed number.</span></span></param>
        <summary><span data-ttu-id="240c7-816">Devuelve un entero que indica el signo de un entero de 16 bits con signo.</span><span class="sxs-lookup"><span data-stu-id="240c7-816">Returns an integer that indicates the sign of a 16-bit signed integer.</span></span></summary>
        <returns><span data-ttu-id="240c7-817">Número que indica el signo de <paramref name="value" />, como puede verse en la tabla siguiente.</span><span class="sxs-lookup"><span data-stu-id="240c7-817">A number that indicates the sign of <paramref name="value" />, as shown in the following table.</span></span>  
  
 <span data-ttu-id="240c7-818"><list type="table"><listheader><term> Valor devuelto</span><span class="sxs-lookup"><span data-stu-id="240c7-818"><list type="table"><listheader><term> Return value</span></span>  
  
 <span data-ttu-id="240c7-819"></term><description> Significado</span><span class="sxs-lookup"><span data-stu-id="240c7-819"></term><description> Meaning</span></span>  
  
 <span data-ttu-id="240c7-820"></description></listheader><item><term> -1</span><span class="sxs-lookup"><span data-stu-id="240c7-820"></description></listheader><item><term> -1</span></span>  
  
 <span data-ttu-id="240c7-821"></term><description><paramref name="value" /> es menor que cero.</span><span class="sxs-lookup"><span data-stu-id="240c7-821"></term><description><paramref name="value" /> is less than zero.</span></span>  
  
 <span data-ttu-id="240c7-822"></description></item><item><term> 0</span><span class="sxs-lookup"><span data-stu-id="240c7-822"></description></item><item><term> 0</span></span>  
  
 <span data-ttu-id="240c7-823"></term><description><paramref name="value" /> es igual a cero.</span><span class="sxs-lookup"><span data-stu-id="240c7-823"></term><description><paramref name="value" /> is equal to zero.</span></span>  
  
 <span data-ttu-id="240c7-824"></description></item><item><term> 1</span><span class="sxs-lookup"><span data-stu-id="240c7-824"></description></item><item><term> 1</span></span>  
  
 <span data-ttu-id="240c7-825"></term><description><paramref name="value" /> es mayor que cero.</span><span class="sxs-lookup"><span data-stu-id="240c7-825"></term><description><paramref name="value" /> is greater than zero.</span></span>  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="240c7-826">En el ejemplo siguiente se muestra cómo utilizar el <xref:System.Math.Sign%28System.Int16%29> método para determinar el signo de un <xref:System.Int16> valor y mostrarlo en la consola.</span><span class="sxs-lookup"><span data-stu-id="240c7-826">The following example demonstrates how to use the <xref:System.Math.Sign%28System.Int16%29> method to determine the sign of an <xref:System.Int16> value and display it to the console.</span></span>  
  
 [!code-cpp[Math.Sign#1](~/samples/snippets/cpp/VS_Snippets_CLR/math.sign/CPP/sign.cpp#1)]
 [!code-csharp[Math.Sign#1](~/samples/snippets/csharp/VS_Snippets_CLR/math.sign/CS/sign.cs#1)]
 [!code-vb[Math.Sign#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/math.sign/VB/sign.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Sign">
      <MemberSignature Language="C#" Value="public static int Sign (int value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Sign(int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Sign(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Sign (value As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Sign(int value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="240c7-827">Número con signo.</span><span class="sxs-lookup"><span data-stu-id="240c7-827">A signed number.</span></span></param>
        <summary><span data-ttu-id="240c7-828">Devuelve un entero que indica el signo de un entero de 32 bits con signo.</span><span class="sxs-lookup"><span data-stu-id="240c7-828">Returns an integer that indicates the sign of a 32-bit signed integer.</span></span></summary>
        <returns><span data-ttu-id="240c7-829">Número que indica el signo de <paramref name="value" />, como puede verse en la tabla siguiente.</span><span class="sxs-lookup"><span data-stu-id="240c7-829">A number that indicates the sign of <paramref name="value" />, as shown in the following table.</span></span>  
  
 <span data-ttu-id="240c7-830"><list type="table"><listheader><term> Valor devuelto</span><span class="sxs-lookup"><span data-stu-id="240c7-830"><list type="table"><listheader><term> Return value</span></span>  
  
 <span data-ttu-id="240c7-831"></term><description> Significado</span><span class="sxs-lookup"><span data-stu-id="240c7-831"></term><description> Meaning</span></span>  
  
 <span data-ttu-id="240c7-832"></description></listheader><item><term> -1</span><span class="sxs-lookup"><span data-stu-id="240c7-832"></description></listheader><item><term> -1</span></span>  
  
 <span data-ttu-id="240c7-833"></term><description><paramref name="value" /> es menor que cero.</span><span class="sxs-lookup"><span data-stu-id="240c7-833"></term><description><paramref name="value" /> is less than zero.</span></span>  
  
 <span data-ttu-id="240c7-834"></description></item><item><term> 0</span><span class="sxs-lookup"><span data-stu-id="240c7-834"></description></item><item><term> 0</span></span>  
  
 <span data-ttu-id="240c7-835"></term><description><paramref name="value" /> es igual a cero.</span><span class="sxs-lookup"><span data-stu-id="240c7-835"></term><description><paramref name="value" /> is equal to zero.</span></span>  
  
 <span data-ttu-id="240c7-836"></description></item><item><term> 1</span><span class="sxs-lookup"><span data-stu-id="240c7-836"></description></item><item><term> 1</span></span>  
  
 <span data-ttu-id="240c7-837"></term><description><paramref name="value" /> es mayor que cero.</span><span class="sxs-lookup"><span data-stu-id="240c7-837"></term><description><paramref name="value" /> is greater than zero.</span></span>  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="240c7-838">En el ejemplo siguiente se muestra cómo utilizar el <xref:System.Math.Sign%28System.Int32%29> método para determinar el signo de un <xref:System.Int32> valor y mostrarlo en la consola.</span><span class="sxs-lookup"><span data-stu-id="240c7-838">The following example demonstrates how to use the <xref:System.Math.Sign%28System.Int32%29> method to determine the sign of an <xref:System.Int32> value and display it to the console.</span></span>  
  
 [!code-cpp[Math.Sign#1](~/samples/snippets/cpp/VS_Snippets_CLR/math.sign/CPP/sign.cpp#1)]
 [!code-csharp[Math.Sign#1](~/samples/snippets/csharp/VS_Snippets_CLR/math.sign/CS/sign.cs#1)]
 [!code-vb[Math.Sign#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/math.sign/VB/sign.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Sign">
      <MemberSignature Language="C#" Value="public static int Sign (long value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Sign(int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Sign(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Sign (value As Long) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Sign(long value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="240c7-839">Número con signo.</span><span class="sxs-lookup"><span data-stu-id="240c7-839">A signed number.</span></span></param>
        <summary><span data-ttu-id="240c7-840">Devuelve un entero que indica el signo de un entero de 64 bits con signo.</span><span class="sxs-lookup"><span data-stu-id="240c7-840">Returns an integer that indicates the sign of a 64-bit signed integer.</span></span></summary>
        <returns><span data-ttu-id="240c7-841">Número que indica el signo de <paramref name="value" />, como puede verse en la tabla siguiente.</span><span class="sxs-lookup"><span data-stu-id="240c7-841">A number that indicates the sign of <paramref name="value" />, as shown in the following table.</span></span>  
  
 <span data-ttu-id="240c7-842"><list type="table"><listheader><term> Valor devuelto</span><span class="sxs-lookup"><span data-stu-id="240c7-842"><list type="table"><listheader><term> Return value</span></span>  
  
 <span data-ttu-id="240c7-843"></term><description> Significado</span><span class="sxs-lookup"><span data-stu-id="240c7-843"></term><description> Meaning</span></span>  
  
 <span data-ttu-id="240c7-844"></description></listheader><item><term> -1</span><span class="sxs-lookup"><span data-stu-id="240c7-844"></description></listheader><item><term> -1</span></span>  
  
 <span data-ttu-id="240c7-845"></term><description><paramref name="value" /> es menor que cero.</span><span class="sxs-lookup"><span data-stu-id="240c7-845"></term><description><paramref name="value" /> is less than zero.</span></span>  
  
 <span data-ttu-id="240c7-846"></description></item><item><term> 0</span><span class="sxs-lookup"><span data-stu-id="240c7-846"></description></item><item><term> 0</span></span>  
  
 <span data-ttu-id="240c7-847"></term><description><paramref name="value" /> es igual a cero.</span><span class="sxs-lookup"><span data-stu-id="240c7-847"></term><description><paramref name="value" /> is equal to zero.</span></span>  
  
 <span data-ttu-id="240c7-848"></description></item><item><term> 1</span><span class="sxs-lookup"><span data-stu-id="240c7-848"></description></item><item><term> 1</span></span>  
  
 <span data-ttu-id="240c7-849"></term><description><paramref name="value" /> es mayor que cero.</span><span class="sxs-lookup"><span data-stu-id="240c7-849"></term><description><paramref name="value" /> is greater than zero.</span></span>  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="240c7-850">En el ejemplo siguiente se muestra cómo utilizar el <xref:System.Math.Sign%28System.Int64%29> método para determinar el signo de un <xref:System.Int64> valor y mostrarlo en la consola.</span><span class="sxs-lookup"><span data-stu-id="240c7-850">The following example demonstrates how to use the <xref:System.Math.Sign%28System.Int64%29> method to determine the sign of an <xref:System.Int64> value and display it to the console.</span></span>  
  
 [!code-cpp[Math.Sign#1](~/samples/snippets/cpp/VS_Snippets_CLR/math.sign/CPP/sign.cpp#1)]
 [!code-csharp[Math.Sign#1](~/samples/snippets/csharp/VS_Snippets_CLR/math.sign/CS/sign.cs#1)]
 [!code-vb[Math.Sign#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/math.sign/VB/sign.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Sign">
      <MemberSignature Language="C#" Value="public static int Sign (sbyte value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Sign(int8 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Sign(System.SByte)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Sign (value As SByte) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Sign(System::SByte value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.SByte" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="240c7-851">Número con signo.</span><span class="sxs-lookup"><span data-stu-id="240c7-851">A signed number.</span></span></param>
        <summary><span data-ttu-id="240c7-852">Devuelve un entero que indica el signo de un entero de 8 bits con signo.</span><span class="sxs-lookup"><span data-stu-id="240c7-852">Returns an integer that indicates the sign of an 8-bit signed integer.</span></span></summary>
        <returns><span data-ttu-id="240c7-853">Número que indica el signo de <paramref name="value" />, como puede verse en la tabla siguiente.</span><span class="sxs-lookup"><span data-stu-id="240c7-853">A number that indicates the sign of <paramref name="value" />, as shown in the following table.</span></span>  
  
 <span data-ttu-id="240c7-854"><list type="table"><listheader><term> Valor devuelto</span><span class="sxs-lookup"><span data-stu-id="240c7-854"><list type="table"><listheader><term> Return value</span></span>  
  
 <span data-ttu-id="240c7-855"></term><description> Significado</span><span class="sxs-lookup"><span data-stu-id="240c7-855"></term><description> Meaning</span></span>  
  
 <span data-ttu-id="240c7-856"></description></listheader><item><term> -1</span><span class="sxs-lookup"><span data-stu-id="240c7-856"></description></listheader><item><term> -1</span></span>  
  
 <span data-ttu-id="240c7-857"></term><description><paramref name="value" /> es menor que cero.</span><span class="sxs-lookup"><span data-stu-id="240c7-857"></term><description><paramref name="value" /> is less than zero.</span></span>  
  
 <span data-ttu-id="240c7-858"></description></item><item><term> 0</span><span class="sxs-lookup"><span data-stu-id="240c7-858"></description></item><item><term> 0</span></span>  
  
 <span data-ttu-id="240c7-859"></term><description><paramref name="value" /> es igual a cero.</span><span class="sxs-lookup"><span data-stu-id="240c7-859"></term><description><paramref name="value" /> is equal to zero.</span></span>  
  
 <span data-ttu-id="240c7-860"></description></item><item><term> 1</span><span class="sxs-lookup"><span data-stu-id="240c7-860"></description></item><item><term> 1</span></span>  
  
 <span data-ttu-id="240c7-861"></term><description><paramref name="value" /> es mayor que cero.</span><span class="sxs-lookup"><span data-stu-id="240c7-861"></term><description><paramref name="value" /> is greater than zero.</span></span>  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="240c7-862">En el ejemplo siguiente se muestra cómo utilizar el <xref:System.Math.Sign%28System.SByte%29> método para determinar el signo de un <xref:System.SByte> valor y mostrarlo en la consola.</span><span class="sxs-lookup"><span data-stu-id="240c7-862">The following example demonstrates how to use the <xref:System.Math.Sign%28System.SByte%29> method to determine the sign of an <xref:System.SByte> value and display it to the console.</span></span>  
  
 [!code-cpp[Math.Sign#1](~/samples/snippets/cpp/VS_Snippets_CLR/math.sign/CPP/sign.cpp#1)]
 [!code-csharp[Math.Sign#1](~/samples/snippets/csharp/VS_Snippets_CLR/math.sign/CS/sign.cs#1)]
 [!code-vb[Math.Sign#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/math.sign/VB/sign.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Sign">
      <MemberSignature Language="C#" Value="public static int Sign (float value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Sign(float32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Sign(System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Sign (value As Single) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Sign(float value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="240c7-863">Número con signo.</span><span class="sxs-lookup"><span data-stu-id="240c7-863">A signed number.</span></span></param>
        <summary><span data-ttu-id="240c7-864">Devuelve un entero que indica el signo de un número de punto flotante de precisión sencilla.</span><span class="sxs-lookup"><span data-stu-id="240c7-864">Returns an integer that indicates the sign of a single-precision floating-point number.</span></span></summary>
        <returns><span data-ttu-id="240c7-865">Número que indica el signo de <paramref name="value" />, como puede verse en la tabla siguiente.</span><span class="sxs-lookup"><span data-stu-id="240c7-865">A number that indicates the sign of <paramref name="value" />, as shown in the following table.</span></span>  
  
 <span data-ttu-id="240c7-866"><list type="table"><listheader><term> Valor devuelto</span><span class="sxs-lookup"><span data-stu-id="240c7-866"><list type="table"><listheader><term> Return value</span></span>  
  
 <span data-ttu-id="240c7-867"></term><description> Significado</span><span class="sxs-lookup"><span data-stu-id="240c7-867"></term><description> Meaning</span></span>  
  
 <span data-ttu-id="240c7-868"></description></listheader><item><term> -1</span><span class="sxs-lookup"><span data-stu-id="240c7-868"></description></listheader><item><term> -1</span></span>  
  
 <span data-ttu-id="240c7-869"></term><description><paramref name="value" /> es menor que cero.</span><span class="sxs-lookup"><span data-stu-id="240c7-869"></term><description><paramref name="value" /> is less than zero.</span></span>  
  
 <span data-ttu-id="240c7-870"></description></item><item><term> 0</span><span class="sxs-lookup"><span data-stu-id="240c7-870"></description></item><item><term> 0</span></span>  
  
 <span data-ttu-id="240c7-871"></term><description><paramref name="value" /> es igual a cero.</span><span class="sxs-lookup"><span data-stu-id="240c7-871"></term><description><paramref name="value" /> is equal to zero.</span></span>  
  
 <span data-ttu-id="240c7-872"></description></item><item><term> 1</span><span class="sxs-lookup"><span data-stu-id="240c7-872"></description></item><item><term> 1</span></span>  
  
 <span data-ttu-id="240c7-873"></term><description><paramref name="value" /> es mayor que cero.</span><span class="sxs-lookup"><span data-stu-id="240c7-873"></term><description><paramref name="value" /> is greater than zero.</span></span>  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="240c7-874">En el ejemplo siguiente se muestra cómo utilizar el <xref:System.Math.Sign%28System.Single%29> método para determinar el signo de un <xref:System.Single> valor y mostrarlo en la consola.</span><span class="sxs-lookup"><span data-stu-id="240c7-874">The following example demonstrates how to use the <xref:System.Math.Sign%28System.Single%29> method to determine the sign of a <xref:System.Single> value and display it to the console.</span></span>  
  
 [!code-cpp[Math.Sign#1](~/samples/snippets/cpp/VS_Snippets_CLR/math.sign/CPP/sign.cpp#1)]
 [!code-csharp[Math.Sign#1](~/samples/snippets/csharp/VS_Snippets_CLR/math.sign/CS/sign.cs#1)]
 [!code-vb[Math.Sign#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/math.sign/VB/sign.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArithmeticException">
          <span data-ttu-id="240c7-875"><paramref name="value" /> es igual a <see cref="F:System.Single.NaN" />.</span><span class="sxs-lookup"><span data-stu-id="240c7-875"><paramref name="value" /> is equal to <see cref="F:System.Single.NaN" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Sin">
      <MemberSignature Language="C#" Value="public static double Sin (double a);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Sin(float64 a) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Sin(System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Sin (a As Double) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double Sin(double a);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="a" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="a"><span data-ttu-id="240c7-876">Ángulo, medido en radianes.</span><span class="sxs-lookup"><span data-stu-id="240c7-876">An angle, measured in radians.</span></span></param>
        <summary><span data-ttu-id="240c7-877">Devuelve el seno del ángulo especificado.</span><span class="sxs-lookup"><span data-stu-id="240c7-877">Returns the sine of the specified angle.</span></span></summary>
        <returns><span data-ttu-id="240c7-878">Seno de <paramref name="a" />.</span><span class="sxs-lookup"><span data-stu-id="240c7-878">The sine of <paramref name="a" />.</span></span> <span data-ttu-id="240c7-879">Si <paramref name="a" /> es igual a <see cref="F:System.Double.NaN" />, <see cref="F:System.Double.NegativeInfinity" /> o <see cref="F:System.Double.PositiveInfinity" />, este método devuelve <see cref="F:System.Double.NaN" />.</span><span class="sxs-lookup"><span data-stu-id="240c7-879">If <paramref name="a" /> is equal to <see cref="F:System.Double.NaN" />, <see cref="F:System.Double.NegativeInfinity" />, or <see cref="F:System.Double.PositiveInfinity" />, this method returns <see cref="F:System.Double.NaN" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="240c7-880">El ángulo, `a`, deben estar en radianes.</span><span class="sxs-lookup"><span data-stu-id="240c7-880">The angle, `a`, must be in radians.</span></span> <span data-ttu-id="240c7-881">Multiplicar por <xref:System.Math.PI?displayProperty=nameWithType>/180 para convertir los grados en radianes.</span><span class="sxs-lookup"><span data-stu-id="240c7-881">Multiply by <xref:System.Math.PI?displayProperty=nameWithType>/180 to convert degrees to radians.</span></span>  
  
 <span data-ttu-id="240c7-882">Los valores aceptables de `a` intervalo de aproximadamente -9223372036854775295 a aproximadamente 9223372036854775295.</span><span class="sxs-lookup"><span data-stu-id="240c7-882">Acceptable values of `a` range from approximately -9223372036854775295 to approximately 9223372036854775295.</span></span> <span data-ttu-id="240c7-883">Para valores fuera de este intervalo, el <xref:System.Math.Sin%2A> método `a` sin cambios en lugar de producir una excepción.</span><span class="sxs-lookup"><span data-stu-id="240c7-883">For values outside of this range, the <xref:System.Math.Sin%2A> method returns `a` unchanged rather than throwing an exception.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="240c7-884">En el ejemplo siguiente se utiliza <xref:System.Math.Sin%2A> para evaluar determinadas identidades trigonométricas de ángulos seleccionados.</span><span class="sxs-lookup"><span data-stu-id="240c7-884">The following example uses <xref:System.Math.Sin%2A> to evaluate certain trigonometric identities for selected angles.</span></span>  
  
 [!code-cpp[System.Math.SinCos#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Math.SinCos/CPP/sincos.cpp#1)]
 [!code-csharp[System.Math.SinCos#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Math.SinCos/CS/sincos.cs#1)]
 [!code-vb[System.Math.SinCos#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Math.SinCos/VB/sincos.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Sinh">
      <MemberSignature Language="C#" Value="public static double Sinh (double value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Sinh(float64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Sinh(System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Sinh (value As Double) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double Sinh(double value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="240c7-885">Ángulo, medido en radianes.</span><span class="sxs-lookup"><span data-stu-id="240c7-885">An angle, measured in radians.</span></span></param>
        <summary><span data-ttu-id="240c7-886">Devuelve el seno hiperbólico del ángulo especificado.</span><span class="sxs-lookup"><span data-stu-id="240c7-886">Returns the hyperbolic sine of the specified angle.</span></span></summary>
        <returns><span data-ttu-id="240c7-887">Seno hiperbólico de <paramref name="value" />.</span><span class="sxs-lookup"><span data-stu-id="240c7-887">The hyperbolic sine of <paramref name="value" />.</span></span> <span data-ttu-id="240c7-888">Si <paramref name="value" /> es igual a <see cref="F:System.Double.NegativeInfinity" />, <see cref="F:System.Double.PositiveInfinity" /> o <see cref="F:System.Double.NaN" />, este método devuelve <see cref="T:System.Double" /> igual a <paramref name="value" />.</span><span class="sxs-lookup"><span data-stu-id="240c7-888">If <paramref name="value" /> is equal to <see cref="F:System.Double.NegativeInfinity" />, <see cref="F:System.Double.PositiveInfinity" />, or <see cref="F:System.Double.NaN" />, this method returns a <see cref="T:System.Double" /> equal to <paramref name="value" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="240c7-889">El ángulo, `value`, deben estar en radianes.</span><span class="sxs-lookup"><span data-stu-id="240c7-889">The angle, `value`, must be in radians.</span></span> <span data-ttu-id="240c7-890">Multiplicar por <xref:System.Math.PI?displayProperty=nameWithType>/180 para convertir los grados en radianes.</span><span class="sxs-lookup"><span data-stu-id="240c7-890">Multiply by <xref:System.Math.PI?displayProperty=nameWithType>/180 to convert degrees to radians.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="240c7-891">En el ejemplo siguiente se utiliza <xref:System.Math.Sinh%2A> para evaluar determinadas identidades hiperbólicas de valores seleccionados.</span><span class="sxs-lookup"><span data-stu-id="240c7-891">The following example uses <xref:System.Math.Sinh%2A> to evaluate certain hyperbolic identities for selected values.</span></span>  
  
 [!code-cpp[System.Math.SinhCosh#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Math.SinhCosh/CPP/sinhcosh.cpp#1)]
 [!code-csharp[System.Math.SinhCosh#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Math.SinhCosh/CS/sinhcosh.cs#1)]
 [!code-vb[System.Math.SinhCosh#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Math.SinhCosh/VB/sinhcosh.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Sqrt">
      <MemberSignature Language="C#" Value="public static double Sqrt (double d);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Sqrt(float64 d) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Sqrt(System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Sqrt (d As Double) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double Sqrt(double d);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="d"><span data-ttu-id="240c7-892">Número cuya raíz cuadrada se va a calcular.</span><span class="sxs-lookup"><span data-stu-id="240c7-892">The number whose square root is to be found.</span></span></param>
        <summary><span data-ttu-id="240c7-893">Devuelve la raíz cuadrada de un número especificado.</span><span class="sxs-lookup"><span data-stu-id="240c7-893">Returns the square root of a specified number.</span></span></summary>
        <returns><span data-ttu-id="240c7-894">Uno de los valores de la tabla siguiente.</span><span class="sxs-lookup"><span data-stu-id="240c7-894">One of the values in the following table.</span></span>  
  
 <span data-ttu-id="240c7-895"><list type="table"><listheader><term>Parámetro <paramref name="d" /></span><span class="sxs-lookup"><span data-stu-id="240c7-895"><list type="table"><listheader><term><paramref name="d" /> parameter</span></span>  
  
 <span data-ttu-id="240c7-896"></term><description> Valor devuelto</span><span class="sxs-lookup"><span data-stu-id="240c7-896"></term><description> Return value</span></span>  
  
 <span data-ttu-id="240c7-897"></description></listheader><item><term> Cero o positivo</span><span class="sxs-lookup"><span data-stu-id="240c7-897"></description></listheader><item><term> Zero or positive</span></span>  
  
 <span data-ttu-id="240c7-898"></term><description> Raíz cuadrada positiva de <paramref name="d" />.</span><span class="sxs-lookup"><span data-stu-id="240c7-898"></term><description> The positive square root of <paramref name="d" />.</span></span>  
  
 <span data-ttu-id="240c7-899"></description></item><item><term> Negativo</span><span class="sxs-lookup"><span data-stu-id="240c7-899"></description></item><item><term> Negative</span></span>  
  
 <span data-ttu-id="240c7-900"></term><description><see cref="F:System.Double.NaN" /></description></item><item><term> Igual a <see cref="F:System.Double.NaN" /></term><description><see cref="F:System.Double.NaN" /></description></item><item><term> Igual a <see cref="F:System.Double.PositiveInfinity" /></term><description><see cref="F:System.Double.PositiveInfinity" /></description></item></list></span><span class="sxs-lookup"><span data-stu-id="240c7-900"></term><description><see cref="F:System.Double.NaN" /></description></item><item><term> Equals <see cref="F:System.Double.NaN" /></term><description><see cref="F:System.Double.NaN" /></description></item><item><term> Equals <see cref="F:System.Double.PositiveInfinity" /></term><description><see cref="F:System.Double.PositiveInfinity" /></description></item></list></span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="240c7-901">La raíz cuadrada del área de un cuadrado representa la longitud de cualquier lado del cuadrado.</span><span class="sxs-lookup"><span data-stu-id="240c7-901">The square root of the area of a square represents the length of any side of the square.</span></span> <span data-ttu-id="240c7-902">En el ejemplo siguiente se muestra el área de algunas ciudades en los Estados Unidos y da como resultado una impresión del tamaño de cada ciudad si se han representado por un cuadrado.</span><span class="sxs-lookup"><span data-stu-id="240c7-902">The following example displays the area of some cities in the United States and gives an impression of each city's size if it were represented by a square.</span></span>  
  
 [!code-csharp[System.Math.Sqrt#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.math.sqrt/cs/sqrt1.cs#1)]
 [!code-vb[System.Math.Sqrt#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.math.sqrt/vb/sqrt1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Math.Pow(System.Double,System.Double)" />
      </Docs>
    </Member>
    <Member MemberName="Tan">
      <MemberSignature Language="C#" Value="public static double Tan (double a);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Tan(float64 a) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Tan(System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Tan (a As Double) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double Tan(double a);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="a" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="a"><span data-ttu-id="240c7-903">Ángulo, medido en radianes.</span><span class="sxs-lookup"><span data-stu-id="240c7-903">An angle, measured in radians.</span></span></param>
        <summary><span data-ttu-id="240c7-904">Devuelve la tangente del ángulo especificado.</span><span class="sxs-lookup"><span data-stu-id="240c7-904">Returns the tangent of the specified angle.</span></span></summary>
        <returns><span data-ttu-id="240c7-905">Tangente de <paramref name="a" />.</span><span class="sxs-lookup"><span data-stu-id="240c7-905">The tangent of <paramref name="a" />.</span></span> <span data-ttu-id="240c7-906">Si <paramref name="a" /> es igual a <see cref="F:System.Double.NaN" />, <see cref="F:System.Double.NegativeInfinity" /> o <see cref="F:System.Double.PositiveInfinity" />, este método devuelve <see cref="F:System.Double.NaN" />.</span><span class="sxs-lookup"><span data-stu-id="240c7-906">If <paramref name="a" /> is equal to <see cref="F:System.Double.NaN" />, <see cref="F:System.Double.NegativeInfinity" />, or <see cref="F:System.Double.PositiveInfinity" />, this method returns <see cref="F:System.Double.NaN" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="240c7-907">El ángulo, `a`, deben estar en radianes.</span><span class="sxs-lookup"><span data-stu-id="240c7-907">The angle, `a`, must be in radians.</span></span> <span data-ttu-id="240c7-908">Multiplicar por <xref:System.Math.PI?displayProperty=nameWithType>/180 para convertir los grados en radianes.</span><span class="sxs-lookup"><span data-stu-id="240c7-908">Multiply by <xref:System.Math.PI?displayProperty=nameWithType>/180 to convert degrees to radians.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="240c7-909">En el ejemplo siguiente se muestra cómo calcular la tangente de un ángulo y mostrarlo en la consola.</span><span class="sxs-lookup"><span data-stu-id="240c7-909">The following example demonstrates how to calculate the tangent of an angle and display it to the console.</span></span>  
  
 [!code-cpp[math.atanx#1](~/samples/snippets/cpp/VS_Snippets_CLR/math.atanx/CPP/atan.cpp#1)]
 [!code-csharp[math.atanx#1](~/samples/snippets/csharp/VS_Snippets_CLR/math.atanx/CS/atan.cs#1)]
 [!code-vb[math.atanx#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/math.atanx/VB/atan.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Tanh">
      <MemberSignature Language="C#" Value="public static double Tanh (double value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Tanh(float64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Tanh(System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Tanh (value As Double) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double Tanh(double value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="240c7-910">Ángulo, medido en radianes.</span><span class="sxs-lookup"><span data-stu-id="240c7-910">An angle, measured in radians.</span></span></param>
        <summary><span data-ttu-id="240c7-911">Devuelve la tangente hiperbólica del ángulo especificado.</span><span class="sxs-lookup"><span data-stu-id="240c7-911">Returns the hyperbolic tangent of the specified angle.</span></span></summary>
        <returns><span data-ttu-id="240c7-912">Tangente hiperbólica de <paramref name="value" />.</span><span class="sxs-lookup"><span data-stu-id="240c7-912">The hyperbolic tangent of <paramref name="value" />.</span></span> <span data-ttu-id="240c7-913">Si <paramref name="value" /> es igual a <see cref="F:System.Double.NegativeInfinity" />, este método devuelve -1.</span><span class="sxs-lookup"><span data-stu-id="240c7-913">If <paramref name="value" /> is equal to <see cref="F:System.Double.NegativeInfinity" />, this method returns -1.</span></span> <span data-ttu-id="240c7-914">Si el valor es igual a <see cref="F:System.Double.PositiveInfinity" />, este método devuelve 1.</span><span class="sxs-lookup"><span data-stu-id="240c7-914">If value is equal to <see cref="F:System.Double.PositiveInfinity" />, this method returns 1.</span></span> <span data-ttu-id="240c7-915">Si <paramref name="value" /> es igual a <see cref="F:System.Double.NaN" />, este método devuelve <see cref="F:System.Double.NaN" />.</span><span class="sxs-lookup"><span data-stu-id="240c7-915">If <paramref name="value" /> is equal to <see cref="F:System.Double.NaN" />, this method returns <see cref="F:System.Double.NaN" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="240c7-916">El ángulo, `value`, deben estar en radianes.</span><span class="sxs-lookup"><span data-stu-id="240c7-916">The angle, `value`, must be in radians.</span></span> <span data-ttu-id="240c7-917">Multiplicar por <xref:System.Math.PI?displayProperty=nameWithType>/180 para convertir los grados en radianes.</span><span class="sxs-lookup"><span data-stu-id="240c7-917">Multiply by <xref:System.Math.PI?displayProperty=nameWithType>/180 to convert degrees to radians.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="240c7-918">En el ejemplo siguiente se utiliza <xref:System.Math.Tanh%2A> para evaluar determinadas identidades de tangente hiperbólica de valores seleccionados.</span><span class="sxs-lookup"><span data-stu-id="240c7-918">The following example uses <xref:System.Math.Tanh%2A> to evaluate certain hyperbolic tangent identities for selected values.</span></span>  
  
 [!code-cpp[System.Math.Tanh#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Math.Tanh/CPP/tanh.cpp#1)]
 [!code-csharp[System.Math.Tanh#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Math.Tanh/CS/tanh.cs#1)]
 [!code-vb[System.Math.Tanh#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Math.Tanh/VB/tanh.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Truncate">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="240c7-919">Calcula la parte entera de un número.</span><span class="sxs-lookup"><span data-stu-id="240c7-919">Calculates the integral part of a number.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="240c7-920">El número se redondea al entero más próximo a cero.</span><span class="sxs-lookup"><span data-stu-id="240c7-920">The number is rounded to the nearest integer towards zero.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Truncate">
      <MemberSignature Language="C#" Value="public static decimal Truncate (decimal d);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Decimal Truncate(valuetype System.Decimal d) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Truncate(System.Decimal)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Truncate (d As Decimal) As Decimal" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Decimal Truncate(System::Decimal d);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d" Type="System.Decimal" />
      </Parameters>
      <Docs>
        <param name="d"><span data-ttu-id="240c7-921">Número que se va a truncar.</span><span class="sxs-lookup"><span data-stu-id="240c7-921">A number to truncate.</span></span></param>
        <summary><span data-ttu-id="240c7-922">Calcula la parte entera de un número decimal especificado.</span><span class="sxs-lookup"><span data-stu-id="240c7-922">Calculates the integral part of a specified decimal number.</span></span></summary>
        <returns><span data-ttu-id="240c7-923">Parte entera de <paramref name="d" />, es decir, el número que queda después de descartar los dígitos fraccionarios.</span><span class="sxs-lookup"><span data-stu-id="240c7-923">The integral part of <paramref name="d" />; that is, the number that remains after any fractional digits have been discarded.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="240c7-924"><xref:System.Math.Truncate%2A> redondea `d` al entero más próximo a cero.</span><span class="sxs-lookup"><span data-stu-id="240c7-924"><xref:System.Math.Truncate%2A> rounds `d` to the nearest integer towards zero.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="240c7-925">El ejemplo siguiente se llama el <xref:System.Math.Truncate%28System.Decimal%29> método truncar positivo y negativo <xref:System.Decimal> valor.</span><span class="sxs-lookup"><span data-stu-id="240c7-925">The following example calls the <xref:System.Math.Truncate%28System.Decimal%29> method to truncate both a positive and a negative <xref:System.Decimal> value.</span></span>  
  
 [!code-csharp[System.Math.Truncate#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Math.Truncate/cs/Truncate1.cs#2)]
 [!code-vb[System.Math.Truncate#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Math.Truncate/vb/Truncate1.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Math.Round" />
        <altmember cref="M:System.Math.Ceiling(System.Decimal)" />
        <altmember cref="M:System.Math.Floor(System.Decimal)" />
      </Docs>
    </Member>
    <Member MemberName="Truncate">
      <MemberSignature Language="C#" Value="public static double Truncate (double d);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Truncate(float64 d) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Truncate(System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Truncate (d As Double) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double Truncate(double d);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="d"><span data-ttu-id="240c7-926">Número que se va a truncar.</span><span class="sxs-lookup"><span data-stu-id="240c7-926">A number to truncate.</span></span></param>
        <summary><span data-ttu-id="240c7-927">Calcula la parte entera de un número de punto flotante de precisión doble especificado.</span><span class="sxs-lookup"><span data-stu-id="240c7-927">Calculates the integral part of a specified double-precision floating-point number.</span></span></summary>
        <returns><span data-ttu-id="240c7-928">La parte entera de <paramref name="d" />, es decir, el número que permanece una vez descartado cualquier dígito fraccionario o uno de los valores enumerados en la siguiente tabla.</span><span class="sxs-lookup"><span data-stu-id="240c7-928">The integral part of <paramref name="d" />; that is, the number that remains after any fractional digits have been discarded, or one of the values listed in the following table.</span></span>  
  
 <span data-ttu-id="240c7-929"><list type="table"><listheader><term><paramref name="d" /></term><description> Valor devuelto</span><span class="sxs-lookup"><span data-stu-id="240c7-929"><list type="table"><listheader><term><paramref name="d" /></term><description> Return value</span></span>  
  
 </description></listheader><item><term><see cref="F:System.Double.NaN" /></term><description><see cref="F:System.Double.NaN" /></description></item><item><term><see cref="F:System.Double.NegativeInfinity" /></term><description><see cref="F:System.Double.NegativeInfinity" /></description></item><item><term><see cref="F:System.Double.PositiveInfinity" /></term><description><see cref="F:System.Double.PositiveInfinity" /></description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="240c7-930"><xref:System.Math.Truncate%2A> redondea `d` al entero más próximo a cero.</span><span class="sxs-lookup"><span data-stu-id="240c7-930"><xref:System.Math.Truncate%2A> rounds `d` to the nearest integer towards zero.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="240c7-931">El ejemplo siguiente se llama el <xref:System.Math.Truncate%28System.Double%29> método truncar positivo y negativo <xref:System.Double> valor.</span><span class="sxs-lookup"><span data-stu-id="240c7-931">The following example calls the <xref:System.Math.Truncate%28System.Double%29> method to truncate both a positive and a negative <xref:System.Double> value.</span></span>  
  
 [!code-csharp[System.Math.Truncate#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Math.Truncate/cs/Truncate1.cs#1)]
 [!code-vb[System.Math.Truncate#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Math.Truncate/vb/Truncate1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Math.Round" />
        <altmember cref="M:System.Math.Ceiling(System.Double)" />
        <altmember cref="M:System.Math.Floor(System.Double)" />
      </Docs>
    </Member>
  </Members>
</Type>