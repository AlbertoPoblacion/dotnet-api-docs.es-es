<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="Math.xml" source-language="en-US" target-language="es-ES">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-81070f4" tool-company="Microsoft" />
      <xliffext:skl_file_name xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">1e344e59-9d8e-481b-978a-09f2e01be86c970ae0c5f91215de9486dadb6303edc951885e7b.skl</xliffext:skl_file_name>
      <xliffext:version xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">1.2</xliffext:version>
      <xliffext:ms.openlocfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">970ae0c5f91215de9486dadb6303edc951885e7b</xliffext:ms.openlocfilehash>
      <xliffext:ms.sourcegitcommit xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">f9e3295b6cc303a611a73a84c4b27f9da792ad0d</xliffext:ms.sourcegitcommit>
      <xliffext:ms.lasthandoff xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">04/26/2018</xliffext:ms.lasthandoff>
      <xliffext:moniker_ids xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">netcore-1.0,netcore-1.1,netcore-2.0,netcore-2.1,netframework-4.5.1,netframework-4.5.2,netframework-4.5,netframework-4.6.1,netframework-4.6.2,netframework-4.6,netframework-4.7.1,netframework-4.7.2,netframework-4.7,netstandard-1.0,netstandard-1.1,netstandard-1.2,netstandard-1.3,netstandard-1.4,netstandard-1.5,netstandard-1.6,netstandard-2.0,xamarinandroid-7.1,xamarinios-10.8,xamarinmac-3.0</xliffext:moniker_ids>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve" uid="T:System.Math">
          <source>Provides constants and static methods for trigonometric, logarithmic, and other common mathematical functions.</source>
          <target state="translated">Proporciona constantes y métodos estáticos para operaciones trigonométricas, logarítmicas y otras funciones matemáticas comunes.</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Math">
          <source>The following example uses several mathematical and trigonometric functions from the <ph id="ph1">&lt;xref:System.Math&gt;</ph> class to calculate the inner angles of a trapezoid.</source>
          <target state="translated">El ejemplo siguiente utiliza varias funciones matemáticas y trigonométricas de la <ph id="ph1">&lt;xref:System.Math&gt;</ph> clase para calcular los ángulos internos de un trapezoide.</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve" uid="T:System.Math">
          <source>Returns the absolute value of a specified number.</source>
          <target state="translated">Devuelve el valor absoluto de un número especificado.</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve" uid="M:System.Math.Abs(System.Decimal)">
          <source>A number that is greater than or equal to <ph id="ph1">&lt;see cref="F:System.Decimal.MinValue" /&gt;</ph>, but less than or equal to <ph id="ph2">&lt;see cref="F:System.Decimal.MaxValue" /&gt;</ph>.</source>
          <target state="translated">Número mayor o igual que <ph id="ph1">&lt;see cref="F:System.Decimal.MinValue" /&gt;</ph>, pero menor o igual que <ph id="ph2">&lt;see cref="F:System.Decimal.MaxValue" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve" uid="M:System.Math.Abs(System.Decimal)">
          <source>Returns the absolute value of a <ph id="ph1">&lt;see cref="T:System.Decimal" /&gt;</ph> number.</source>
          <target state="translated">Devuelve el valor absoluto de un número <ph id="ph1">&lt;see cref="T:System.Decimal" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve" uid="M:System.Math.Abs(System.Decimal)">
          <source>A decimal number, x, such that 0 ≤ x ≤<ph id="ph1">&lt;see cref="F:System.Decimal.MaxValue" /&gt;</ph>.</source>
          <target state="translated">Número decimal, x, tal que 0 ≤ x ≤<ph id="ph1">&lt;see cref="F:System.Decimal.MaxValue" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Math.Abs(System.Decimal)">
          <source>The absolute value of a <ph id="ph1">&lt;xref:System.Decimal&gt;</ph> is its numeric value without its sign.</source>
          <target state="translated">El valor absoluto de un <ph id="ph1">&lt;xref:System.Decimal&gt;</ph> es su valor numérico sin signo.</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Math.Abs(System.Decimal)">
          <source>For example, the absolute value of both 1.2 and -1.2 is 1.2.</source>
          <target state="translated">Por ejemplo, el valor absoluto de 1.2 y -1,2 es 1.2.</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Math.Abs(System.Decimal)">
          <source>The following example uses the <ph id="ph1">&lt;xref:System.Math.Abs%28System.Decimal%29&gt;</ph> method to get the absolute value of a number of <ph id="ph2">&lt;xref:System.Decimal&gt;</ph> values.</source>
          <target state="translated">En el ejemplo siguiente se usa el <ph id="ph1">&lt;xref:System.Math.Abs%28System.Decimal%29&gt;</ph> método para obtener el valor absoluto de un número de <ph id="ph2">&lt;xref:System.Decimal&gt;</ph> valores.</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve" uid="M:System.Math.Abs(System.Double)">
          <source>A number that is greater than or equal to <ph id="ph1">&lt;see cref="F:System.Double.MinValue" /&gt;</ph>, but less than or equal to <ph id="ph2">&lt;see cref="F:System.Double.MaxValue" /&gt;</ph>.</source>
          <target state="translated">Número mayor o igual que <ph id="ph1">&lt;see cref="F:System.Double.MinValue" /&gt;</ph>, pero menor o igual que <ph id="ph2">&lt;see cref="F:System.Double.MaxValue" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve" uid="M:System.Math.Abs(System.Double)">
          <source>Returns the absolute value of a double-precision floating-point number.</source>
          <target state="translated">Devuelve el valor absoluto de un número de punto flotante de precisión doble.</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve" uid="M:System.Math.Abs(System.Double)">
          <source>A double-precision floating-point number, x, such that 0 ≤ x ≤<ph id="ph1">&lt;see cref="F:System.Double.MaxValue" /&gt;</ph>.</source>
          <target state="translated">Número de punto flotante de precisión doble, x, tal que 0 ≤ x ≤<ph id="ph1">&lt;see cref="F:System.Double.MaxValue" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Math.Abs(System.Double)">
          <source>The absolute value of a <ph id="ph1">&lt;xref:System.Double&gt;</ph> is its numeric value without its sign.</source>
          <target state="translated">El valor absoluto de un <ph id="ph1">&lt;xref:System.Double&gt;</ph> es su valor numérico sin signo.</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Math.Abs(System.Double)">
          <source>For example, the absolute value of both 1.2e03 and -1.2e03 is 1.2e03.</source>
          <target state="translated">Por ejemplo, el valor absoluto de 1.2e03 y - 1.2e03 es 1.2e03.</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Math.Abs(System.Double)">
          <source>If <ph id="ph1">`value`</ph> is equal to <ph id="ph2">&lt;xref:System.Double.NegativeInfinity&gt;</ph> or <ph id="ph3">&lt;xref:System.Double.PositiveInfinity&gt;</ph>, the return value is <ph id="ph4">&lt;xref:System.Double.PositiveInfinity&gt;</ph>.</source>
          <target state="translated">Si <ph id="ph1">`value`</ph> es igual a <ph id="ph2">&lt;xref:System.Double.NegativeInfinity&gt;</ph> o <ph id="ph3">&lt;xref:System.Double.PositiveInfinity&gt;</ph>, el valor devuelto es <ph id="ph4">&lt;xref:System.Double.PositiveInfinity&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Math.Abs(System.Double)">
          <source>If <ph id="ph1">`value`</ph> is equal to <ph id="ph2">&lt;xref:System.Double.NaN&gt;</ph>, the return value is <ph id="ph3">&lt;xref:System.Double.NaN&gt;</ph>.</source>
          <target state="translated">Si <ph id="ph1">`value`</ph> es igual a <ph id="ph2">&lt;xref:System.Double.NaN&gt;</ph>, el valor devuelto es <ph id="ph3">&lt;xref:System.Double.NaN&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Math.Abs(System.Double)">
          <source>The following example uses the <ph id="ph1">&lt;xref:System.Math.Abs%28System.Double%29&gt;</ph> method to get the absolute value of a number of <ph id="ph2">&lt;xref:System.Double&gt;</ph> values.</source>
          <target state="translated">En el ejemplo siguiente se usa el <ph id="ph1">&lt;xref:System.Math.Abs%28System.Double%29&gt;</ph> método para obtener el valor absoluto de un número de <ph id="ph2">&lt;xref:System.Double&gt;</ph> valores.</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve" uid="M:System.Math.Abs(System.Int16)">
          <source>A number that is greater than <ph id="ph1">&lt;see cref="F:System.Int16.MinValue" /&gt;</ph>, but less than or equal to <ph id="ph2">&lt;see cref="F:System.Int16.MaxValue" /&gt;</ph>.</source>
          <target state="translated">Número mayor que <ph id="ph1">&lt;see cref="F:System.Int16.MinValue" /&gt;</ph>, pero menor o igual que <ph id="ph2">&lt;see cref="F:System.Int16.MaxValue" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve" uid="M:System.Math.Abs(System.Int16)">
          <source>Returns the absolute value of a 16-bit signed integer.</source>
          <target state="translated">Devuelve el valor absoluto de un entero de 16 bits con signo.</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve" uid="M:System.Math.Abs(System.Int16)">
          <source>A 16-bit signed integer, x, such that 0 ≤ x ≤<ph id="ph1">&lt;see cref="F:System.Int16.MaxValue" /&gt;</ph>.</source>
          <target state="translated">Número entero de 16 bits con signo, x, tal que 0 ≤ x ≤<ph id="ph1">&lt;see cref="F:System.Int16.MaxValue" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Math.Abs(System.Int16)">
          <source>The absolute value of an <ph id="ph1">&lt;xref:System.Int16&gt;</ph> is its numeric value without its sign.</source>
          <target state="translated">El valor absoluto de un <ph id="ph1">&lt;xref:System.Int16&gt;</ph> es su valor numérico sin signo.</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Math.Abs(System.Int16)">
          <source>For example, the absolute value of both 123 and -123 is 123.</source>
          <target state="translated">Por ejemplo, el valor absoluto de 123 y-123 es 123.</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Math.Abs(System.Int16)">
          <source>The following example uses the <ph id="ph1">&lt;xref:System.Math.Abs%28System.Int16%29&gt;</ph> method to get the absolute value of a number of <ph id="ph2">&lt;xref:System.Int16&gt;</ph> values.</source>
          <target state="translated">En el ejemplo siguiente se usa el <ph id="ph1">&lt;xref:System.Math.Abs%28System.Int16%29&gt;</ph> método para obtener el valor absoluto de un número de <ph id="ph2">&lt;xref:System.Int16&gt;</ph> valores.</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve" uid="M:System.Math.Abs(System.Int16)">
          <source><ph id="ph1">&lt;paramref name="value" /&gt;</ph> equals <ph id="ph2">&lt;see cref="F:System.Int16.MinValue" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="value" /&gt;</ph> es igual que <ph id="ph2">&lt;see cref="F:System.Int16.MinValue" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve" uid="M:System.Math.Abs(System.Int32)">
          <source>A number that is greater than <ph id="ph1">&lt;see cref="F:System.Int32.MinValue" /&gt;</ph>, but less than or equal to <ph id="ph2">&lt;see cref="F:System.Int32.MaxValue" /&gt;</ph>.</source>
          <target state="translated">Número mayor que <ph id="ph1">&lt;see cref="F:System.Int32.MinValue" /&gt;</ph>, pero menor o igual que <ph id="ph2">&lt;see cref="F:System.Int32.MaxValue" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve" uid="M:System.Math.Abs(System.Int32)">
          <source>Returns the absolute value of a 32-bit signed integer.</source>
          <target state="translated">Devuelve el valor absoluto de un entero de 32 bits con signo.</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve" uid="M:System.Math.Abs(System.Int32)">
          <source>A 32-bit signed integer, x, such that 0 ≤ x ≤<ph id="ph1">&lt;see cref="F:System.Int32.MaxValue" /&gt;</ph>.</source>
          <target state="translated">Número entero de 32 bits con signo, x, tal que 0 ≤ x ≤<ph id="ph1">&lt;see cref="F:System.Int32.MaxValue" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Math.Abs(System.Int32)">
          <source>The absolute value of an <ph id="ph1">&lt;xref:System.Int32&gt;</ph> is its numeric value without its sign.</source>
          <target state="translated">El valor absoluto de un <ph id="ph1">&lt;xref:System.Int32&gt;</ph> es su valor numérico sin signo.</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Math.Abs(System.Int32)">
          <source>For example, the absolute value of both 123 and -123 is 123.</source>
          <target state="translated">Por ejemplo, el valor absoluto de 123 y-123 es 123.</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Math.Abs(System.Int32)">
          <source>The following example uses the <ph id="ph1">&lt;xref:System.Math.Abs%28System.Int32%29&gt;</ph> method to get the absolute value of a number of <ph id="ph2">&lt;xref:System.Int32&gt;</ph> values.</source>
          <target state="translated">En el ejemplo siguiente se usa el <ph id="ph1">&lt;xref:System.Math.Abs%28System.Int32%29&gt;</ph> método para obtener el valor absoluto de un número de <ph id="ph2">&lt;xref:System.Int32&gt;</ph> valores.</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve" uid="M:System.Math.Abs(System.Int32)">
          <source><ph id="ph1">&lt;paramref name="value" /&gt;</ph> equals <ph id="ph2">&lt;see cref="F:System.Int32.MinValue" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="value" /&gt;</ph> es igual que <ph id="ph2">&lt;see cref="F:System.Int32.MinValue" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve" uid="M:System.Math.Abs(System.Int64)">
          <source>A number that is greater than <ph id="ph1">&lt;see cref="F:System.Int64.MinValue" /&gt;</ph>, but less than or equal to <ph id="ph2">&lt;see cref="F:System.Int64.MaxValue" /&gt;</ph>.</source>
          <target state="translated">Número mayor que <ph id="ph1">&lt;see cref="F:System.Int64.MinValue" /&gt;</ph>, pero menor o igual que <ph id="ph2">&lt;see cref="F:System.Int64.MaxValue" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve" uid="M:System.Math.Abs(System.Int64)">
          <source>Returns the absolute value of a 64-bit signed integer.</source>
          <target state="translated">Devuelve el valor absoluto de un entero de 64 bits con signo.</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve" uid="M:System.Math.Abs(System.Int64)">
          <source>A 64-bit signed integer, x, such that 0 ≤ x ≤<ph id="ph1">&lt;see cref="F:System.Int64.MaxValue" /&gt;</ph>.</source>
          <target state="translated">Número entero de 64 bits con signo, x, tal que 0 ≤ x ≤<ph id="ph1">&lt;see cref="F:System.Int64.MaxValue" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Math.Abs(System.Int64)">
          <source>The absolute value of an <ph id="ph1">&lt;xref:System.Int64&gt;</ph> is its numeric value without its sign.</source>
          <target state="translated">El valor absoluto de un <ph id="ph1">&lt;xref:System.Int64&gt;</ph> es su valor numérico sin signo.</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Math.Abs(System.Int64)">
          <source>For example, the absolute value of both 123 and -123 is 123.</source>
          <target state="translated">Por ejemplo, el valor absoluto de 123 y-123 es 123.</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Math.Abs(System.Int64)">
          <source>The following example uses the <ph id="ph1">&lt;xref:System.Math.Abs%28System.Int64%29&gt;</ph> method to get the absolute value of a number of <ph id="ph2">&lt;xref:System.Int64&gt;</ph> values.</source>
          <target state="translated">En el ejemplo siguiente se usa el <ph id="ph1">&lt;xref:System.Math.Abs%28System.Int64%29&gt;</ph> método para obtener el valor absoluto de un número de <ph id="ph2">&lt;xref:System.Int64&gt;</ph> valores.</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve" uid="M:System.Math.Abs(System.Int64)">
          <source><ph id="ph1">&lt;paramref name="value" /&gt;</ph> equals <ph id="ph2">&lt;see cref="F:System.Int64.MinValue" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="value" /&gt;</ph> es igual que <ph id="ph2">&lt;see cref="F:System.Int64.MinValue" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve" uid="M:System.Math.Abs(System.SByte)">
          <source>A number that is greater than <ph id="ph1">&lt;see cref="F:System.SByte.MinValue" /&gt;</ph>, but less than or equal to <ph id="ph2">&lt;see cref="F:System.SByte.MaxValue" /&gt;</ph>.</source>
          <target state="translated">Número mayor que <ph id="ph1">&lt;see cref="F:System.SByte.MinValue" /&gt;</ph>, pero menor o igual que <ph id="ph2">&lt;see cref="F:System.SByte.MaxValue" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve" uid="M:System.Math.Abs(System.SByte)">
          <source>Returns the absolute value of an 8-bit signed integer.</source>
          <target state="translated">Devuelve el valor absoluto de un entero de 8 bits con signo.</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve" uid="M:System.Math.Abs(System.SByte)">
          <source>An 8-bit signed integer, x, such that 0 ≤ x ≤<ph id="ph1">&lt;see cref="F:System.SByte.MaxValue" /&gt;</ph>.</source>
          <target state="translated">Número entero de 8 bits con signo, x, tal que 0 ≤ x ≤<ph id="ph1">&lt;see cref="F:System.SByte.MaxValue" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Math.Abs(System.SByte)">
          <source>The absolute value of a signed byte is its numeric value without its sign.</source>
          <target state="translated">El valor absoluto de un byte con signo es su valor numérico sin signo.</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Math.Abs(System.SByte)">
          <source>For example, the absolute value of both 12 and -12 is 12.</source>
          <target state="translated">Por ejemplo, el valor absoluto de 12 y -12 es 12.</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Math.Abs(System.SByte)">
          <source>The following example uses the <ph id="ph1">&lt;xref:System.Math.Abs%28System.SByte%29&gt;</ph> method to get the absolute value of a number of <ph id="ph2">&lt;xref:System.SByte&gt;</ph> values.</source>
          <target state="translated">En el ejemplo siguiente se usa el <ph id="ph1">&lt;xref:System.Math.Abs%28System.SByte%29&gt;</ph> método para obtener el valor absoluto de un número de <ph id="ph2">&lt;xref:System.SByte&gt;</ph> valores.</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve" uid="M:System.Math.Abs(System.SByte)">
          <source><ph id="ph1">&lt;paramref name="value" /&gt;</ph> equals <ph id="ph2">&lt;see cref="F:System.SByte.MinValue" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="value" /&gt;</ph> es igual que <ph id="ph2">&lt;see cref="F:System.SByte.MinValue" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve" uid="M:System.Math.Abs(System.Single)">
          <source>A number that is greater than or equal to <ph id="ph1">&lt;see cref="F:System.Single.MinValue" /&gt;</ph>, but less than or equal to <ph id="ph2">&lt;see cref="F:System.Single.MaxValue" /&gt;</ph>.</source>
          <target state="translated">Número mayor o igual que <ph id="ph1">&lt;see cref="F:System.Single.MinValue" /&gt;</ph>, pero menor o igual que <ph id="ph2">&lt;see cref="F:System.Single.MaxValue" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve" uid="M:System.Math.Abs(System.Single)">
          <source>Returns the absolute value of a single-precision floating-point number.</source>
          <target state="translated">Devuelve el valor absoluto de un número de punto flotante de precisión sencilla.</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve" uid="M:System.Math.Abs(System.Single)">
          <source>A single-precision floating-point number, x, such that 0 ≤ x ≤<ph id="ph1">&lt;see cref="F:System.Single.MaxValue" /&gt;</ph>.</source>
          <target state="translated">Número de punto flotante de precisión sencilla, x, tal que 0 ≤ x ≤<ph id="ph1">&lt;see cref="F:System.Single.MaxValue" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Math.Abs(System.Single)">
          <source>The absolute value of a <ph id="ph1">&lt;xref:System.Single&gt;</ph> is its numeric value without its sign.</source>
          <target state="translated">El valor absoluto de un <ph id="ph1">&lt;xref:System.Single&gt;</ph> es su valor numérico sin signo.</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Math.Abs(System.Single)">
          <source>For example, the absolute value of both 1.2e-03 and -1.2e03 is 1.2e03.</source>
          <target state="translated">Por ejemplo, el valor absoluto de ambos 1.2e-03 y - 1.2e03 es 1.2e03.</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Math.Abs(System.Single)">
          <source>If <ph id="ph1">`value`</ph> is equal to <ph id="ph2">&lt;xref:System.Single.NegativeInfinity&gt;</ph> or <ph id="ph3">&lt;xref:System.Single.PositiveInfinity&gt;</ph>, the return value is <ph id="ph4">&lt;xref:System.Single.PositiveInfinity&gt;</ph>.</source>
          <target state="translated">Si <ph id="ph1">`value`</ph> es igual a <ph id="ph2">&lt;xref:System.Single.NegativeInfinity&gt;</ph> o <ph id="ph3">&lt;xref:System.Single.PositiveInfinity&gt;</ph>, el valor devuelto es <ph id="ph4">&lt;xref:System.Single.PositiveInfinity&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Math.Abs(System.Single)">
          <source>If <ph id="ph1">`value`</ph> is equal to <ph id="ph2">&lt;xref:System.Single.NaN&gt;</ph>, the return value is <ph id="ph3">&lt;xref:System.Single.NaN&gt;</ph>.</source>
          <target state="translated">Si <ph id="ph1">`value`</ph> es igual a <ph id="ph2">&lt;xref:System.Single.NaN&gt;</ph>, el valor devuelto es <ph id="ph3">&lt;xref:System.Single.NaN&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Math.Abs(System.Single)">
          <source>The following example uses the <ph id="ph1">&lt;xref:System.Math.Abs%28System.Single%29&gt;</ph> method to get the absolute value of a number of <ph id="ph2">&lt;xref:System.Single&gt;</ph> values.</source>
          <target state="translated">En el ejemplo siguiente se usa el <ph id="ph1">&lt;xref:System.Math.Abs%28System.Single%29&gt;</ph> método para obtener el valor absoluto de un número de <ph id="ph2">&lt;xref:System.Single&gt;</ph> valores.</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve" uid="M:System.Math.Acos(System.Double)">
          <source>A number representing a cosine, where <bpt id="p1">&lt;c&gt;</bpt>d<ept id="p1">&lt;/c&gt;</ept> must be greater than or equal to -1, but less than or equal to 1.</source>
          <target state="translated">Número que representa un coseno, donde <bpt id="p1">&lt;c&gt;</bpt>d<ept id="p1">&lt;/c&gt;</ept> debe ser mayor o igual que -1 y menor o igual que 1.</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve" uid="M:System.Math.Acos(System.Double)">
          <source>Returns the angle whose cosine is the specified number.</source>
          <target state="translated">Devuelve el ángulo cuyo coseno es el número especificado.</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve" uid="M:System.Math.Acos(System.Double)">
          <source>An angle, θ, measured in radians, such that 0 ≤θ≤π</source>
          <target state="translated">Ángulo, θ, medido en radianes, como 0 ≤θ≤π.</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve" uid="M:System.Math.Acos(System.Double)">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve" uid="M:System.Math.Acos(System.Double)">
          <source><ph id="ph1">&lt;see cref="F:System.Double.NaN" /&gt;</ph> if <ph id="ph2">&lt;paramref name="d" /&gt;</ph> <ph id="ph3">&amp;lt;</ph> -1 or <ph id="ph4">&lt;paramref name="d" /&gt;</ph> <ph id="ph5">&amp;gt;</ph> 1 or <ph id="ph6">&lt;paramref name="d" /&gt;</ph> equals <ph id="ph7">&lt;see cref="F:System.Double.NaN" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="F:System.Double.NaN" /&gt;</ph> si <ph id="ph2">&lt;paramref name="d" /&gt;</ph> <ph id="ph3">&amp;lt;</ph> -1 o <ph id="ph4">&lt;paramref name="d" /&gt;</ph> <ph id="ph5">&amp;gt;</ph> 1 o <ph id="ph6">&lt;paramref name="d" /&gt;</ph> es igual que <ph id="ph7">&lt;see cref="F:System.Double.NaN" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Math.Acos(System.Double)">
          <source>Multiply the return value by 180/<ph id="ph1">&lt;xref:System.Math.PI?displayProperty=nameWithType&gt;</ph> to convert from radians to degrees.</source>
          <target state="translated">Multiplique el valor devuelto por 180 /<ph id="ph1">&lt;xref:System.Math.PI?displayProperty=nameWithType&gt;</ph> para convertir de radianes a grados.</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Math.Acos(System.Double)">
          <source>The following example uses the <ph id="ph1">&lt;xref:System.Math.Acos%2A&gt;</ph> method to assist in the computation of the inner angles of a given trapezoid.</source>
          <target state="translated">En el ejemplo siguiente se usa el <ph id="ph1">&lt;xref:System.Math.Acos%2A&gt;</ph> método para ayudar en el cálculo de los ángulos internos de un trapezoide determinado.</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve" uid="M:System.Math.Asin(System.Double)">
          <source>A number representing a sine, where <bpt id="p1">&lt;c&gt;</bpt>d<ept id="p1">&lt;/c&gt;</ept> must be greater than or equal to -1, but less than or equal to 1.</source>
          <target state="translated">Número que representa un seno, donde <bpt id="p1">&lt;c&gt;</bpt>d<ept id="p1">&lt;/c&gt;</ept> debe ser mayor o igual que -1 y menor o igual que 1.</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve" uid="M:System.Math.Asin(System.Double)">
          <source>Returns the angle whose sine is the specified number.</source>
          <target state="translated">Devuelve el ángulo cuyo seno es el número especificado.</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve" uid="M:System.Math.Asin(System.Double)">
          <source>An angle, θ, measured in radians, such that -π/2 ≤θ≤π/2</source>
          <target state="translated">Ángulo, θ, medido en radianes, como -π/2 ≤θ≤π/2.</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve" uid="M:System.Math.Asin(System.Double)">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve" uid="M:System.Math.Asin(System.Double)">
          <source><ph id="ph1">&lt;see cref="F:System.Double.NaN" /&gt;</ph> if <ph id="ph2">&lt;paramref name="d" /&gt;</ph> <ph id="ph3">&amp;lt;</ph> -1 or <ph id="ph4">&lt;paramref name="d" /&gt;</ph> <ph id="ph5">&amp;gt;</ph> 1 or <ph id="ph6">&lt;paramref name="d" /&gt;</ph> equals <ph id="ph7">&lt;see cref="F:System.Double.NaN" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="F:System.Double.NaN" /&gt;</ph> si <ph id="ph2">&lt;paramref name="d" /&gt;</ph> <ph id="ph3">&amp;lt;</ph> -1 o <ph id="ph4">&lt;paramref name="d" /&gt;</ph> <ph id="ph5">&amp;gt;</ph> 1 o <ph id="ph6">&lt;paramref name="d" /&gt;</ph> es igual que <ph id="ph7">&lt;see cref="F:System.Double.NaN" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Math.Asin(System.Double)">
          <source>A positive return value represents a counterclockwise angle from the x-axis; a negative return value represents a clockwise angle.</source>
          <target state="translated">Un valor devuelto positivo representa un ángulo ascendente desde el eje x; un valor devuelto negativo representa un ángulo de las agujas del reloj.</target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Math.Asin(System.Double)">
          <source>Multiply the return value by 180/<ph id="ph1">&lt;xref:System.Math.PI?displayProperty=nameWithType&gt;</ph> to convert from radians to degrees.</source>
          <target state="translated">Multiplique el valor devuelto por 180 /<ph id="ph1">&lt;xref:System.Math.PI?displayProperty=nameWithType&gt;</ph> para convertir de radianes a grados.</target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Math.Asin(System.Double)">
          <source>The following example uses <ph id="ph1">&lt;xref:System.Math.Asin%2A&gt;</ph> to assist in the computation of the inner angles of a given trapezoid.</source>
          <target state="translated">En el ejemplo siguiente se utiliza <ph id="ph1">&lt;xref:System.Math.Asin%2A&gt;</ph> para ayudar en el cálculo de los ángulos internos de un trapezoide determinado.</target>       </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve" uid="M:System.Math.Atan(System.Double)">
          <source>A number representing a tangent.</source>
          <target state="translated">Número que representa una tangente.</target>       </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve" uid="M:System.Math.Atan(System.Double)">
          <source>Returns the angle whose tangent is the specified number.</source>
          <target state="translated">Devuelve el ángulo cuya tangente corresponde al número especificado.</target>       </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve" uid="M:System.Math.Atan(System.Double)">
          <source>An angle, θ, measured in radians, such that -π/2 ≤θ≤π/2.</source>
          <target state="translated">Ángulo, θ, medido en radianes, como -π/2 ≤θ≤π/2.</target>       </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve" uid="M:System.Math.Atan(System.Double)">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve" uid="M:System.Math.Atan(System.Double)">
          <source><ph id="ph1">&lt;see cref="F:System.Double.NaN" /&gt;</ph> if <ph id="ph2">&lt;paramref name="d" /&gt;</ph> equals <ph id="ph3">&lt;see cref="F:System.Double.NaN" /&gt;</ph>, -π/2 rounded to double precision (-1.5707963267949) if <ph id="ph4">&lt;paramref name="d" /&gt;</ph> equals <ph id="ph5">&lt;see cref="F:System.Double.NegativeInfinity" /&gt;</ph>, or π/2 rounded to double precision (1.5707963267949) if <ph id="ph6">&lt;paramref name="d" /&gt;</ph> equals <ph id="ph7">&lt;see cref="F:System.Double.PositiveInfinity" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="F:System.Double.NaN" /&gt;</ph> si <ph id="ph2">&lt;paramref name="d" /&gt;</ph> es igual a <ph id="ph3">&lt;see cref="F:System.Double.NaN" /&gt;</ph>, -π/2 redondeado a precisión doble (-1,5707963267949) si <ph id="ph4">&lt;paramref name="d" /&gt;</ph> es igual a <ph id="ph5">&lt;see cref="F:System.Double.NegativeInfinity" /&gt;</ph>, o π/2 redondeado a precisión doble (1,5707963267949) si <ph id="ph6">&lt;paramref name="d" /&gt;</ph> es igual a <ph id="ph7">&lt;see cref="F:System.Double.PositiveInfinity" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Math.Atan(System.Double)">
          <source>A positive return value represents a counterclockwise angle from the x-axis; a negative return value represents a clockwise angle.</source>
          <target state="translated">Un valor devuelto positivo representa un ángulo ascendente desde el eje x; un valor devuelto negativo representa un ángulo de las agujas del reloj.</target>       </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Math.Atan(System.Double)">
          <source>Multiply the return value by 180/<ph id="ph1">&lt;xref:System.Math.PI?displayProperty=nameWithType&gt;</ph> to convert from radians to degrees.</source>
          <target state="translated">Multiplique el valor devuelto por 180 /<ph id="ph1">&lt;xref:System.Math.PI?displayProperty=nameWithType&gt;</ph> para convertir de radianes a grados.</target>       </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Math.Atan(System.Double)">
          <source>The following example demonstrates how to calculate the arctangent of a value and display it to the console.</source>
          <target state="translated">En el ejemplo siguiente se muestra cómo calcular el arco tangente de un valor y mostrarlo en la consola.</target>       </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve" uid="M:System.Math.Atan2(System.Double,System.Double)">
          <source>The y coordinate of a point.</source>
          <target state="translated">Coordenada Y de un punto.</target>       </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve" uid="M:System.Math.Atan2(System.Double,System.Double)">
          <source>The x coordinate of a point.</source>
          <target state="translated">Coordenada X de un punto.</target>       </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve" uid="M:System.Math.Atan2(System.Double,System.Double)">
          <source>Returns the angle whose tangent is the quotient of two specified numbers.</source>
          <target state="translated">Devuelve el ángulo cuya tangente es el cociente de dos números especificados.</target>       </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve" uid="M:System.Math.Atan2(System.Double,System.Double)">
          <source>An angle, θ, measured in radians, such that -π≤θ≤π, and tan(θ) = <ph id="ph1">&lt;paramref name="y" /&gt;</ph><ph id="ph2"> / </ph><ph id="ph3">&lt;paramref name="x" /&gt;</ph>, where (<ph id="ph4">&lt;paramref name="x" /&gt;</ph>, <ph id="ph5">&lt;paramref name="y" /&gt;</ph>) is a point in the Cartesian plane.</source>
          <target state="translated">Ángulo, θ, medido en radianes, como -π≤θ≤π, y tan(θ) = <ph id="ph1">&lt;paramref name="y" /&gt;</ph><ph id="ph2"> / </ph><ph id="ph3">&lt;paramref name="x" /&gt;</ph>, donde (<ph id="ph4">&lt;paramref name="x" /&gt;</ph>, <ph id="ph5">&lt;paramref name="y" /&gt;</ph>) es un punto en el plano cartesiano.</target>       </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve" uid="M:System.Math.Atan2(System.Double,System.Double)">
          <source>Observe the following:</source>
          <target state="translated">Observe lo siguiente:</target>       </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve" uid="M:System.Math.Atan2(System.Double,System.Double)">
          <source>For (<ph id="ph1">&lt;paramref name="x" /&gt;</ph>, <ph id="ph2">&lt;paramref name="y" /&gt;</ph>) in quadrant 1, 0 <ph id="ph3">&amp;lt;</ph> θ <ph id="ph4">&amp;lt;</ph> π/2.</source>
          <target state="translated">Para (<ph id="ph1">&lt;paramref name="x" /&gt;</ph>, <ph id="ph2">&lt;paramref name="y" /&gt;</ph>) en el cuadrante 1, 0 <ph id="ph3">&amp;lt;</ph> θ <ph id="ph4">&amp;lt;</ph> π/2.</target>       </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve" uid="M:System.Math.Atan2(System.Double,System.Double)">
          <source>For (<ph id="ph1">&lt;paramref name="x" /&gt;</ph>, <ph id="ph2">&lt;paramref name="y" /&gt;</ph>) in quadrant 2, π/2 <ph id="ph3">&amp;lt;</ph> θ≤π.</source>
          <target state="translated">Para (<ph id="ph1">&lt;paramref name="x" /&gt;</ph>, <ph id="ph2">&lt;paramref name="y" /&gt;</ph>) en el cuadrante 2, π/2 <ph id="ph3">&amp;lt;</ph> θ≤π.</target>       </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve" uid="M:System.Math.Atan2(System.Double,System.Double)">
          <source>For (<ph id="ph1">&lt;paramref name="x" /&gt;</ph>, <ph id="ph2">&lt;paramref name="y" /&gt;</ph>) in quadrant 3, -π <ph id="ph3">&amp;lt;</ph> θ <ph id="ph4">&amp;lt;</ph> -π/2.</source>
          <target state="translated">Para (<ph id="ph1">&lt;paramref name="x" /&gt;</ph>, <ph id="ph2">&lt;paramref name="y" /&gt;</ph>) en el cuadrante 3, -π <ph id="ph3">&amp;lt;</ph> θ <ph id="ph4">&amp;lt;</ph> -π/2.</target>       </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve" uid="M:System.Math.Atan2(System.Double,System.Double)">
          <source>For (<ph id="ph1">&lt;paramref name="x" /&gt;</ph>, <ph id="ph2">&lt;paramref name="y" /&gt;</ph>) in quadrant 4, -π/2 <ph id="ph3">&amp;lt;</ph> θ <ph id="ph4">&amp;lt;</ph> 0.</source>
          <target state="translated">Para (<ph id="ph1">&lt;paramref name="x" /&gt;</ph>, <ph id="ph2">&lt;paramref name="y" /&gt;</ph>) en el cuadrante 4, -π/2 <ph id="ph3">&amp;lt;</ph> θ <ph id="ph4">&amp;lt;</ph> 0.</target>       </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve" uid="M:System.Math.Atan2(System.Double,System.Double)">
          <source>For points on the boundaries of the quadrants, the return value is the following:</source>
          <target state="translated">Para los puntos en los límites de los cuadrantes, el valor devuelto es el siguiente:</target>       </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve" uid="M:System.Math.Atan2(System.Double,System.Double)">
          <source>If y is 0 and x is not negative, θ = 0.</source>
          <target state="translated">Si y es 0 y x no es negativo, θ = 0.</target>       </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve" uid="M:System.Math.Atan2(System.Double,System.Double)">
          <source>If y is 0 and x is negative, θ = π.</source>
          <target state="translated">Si y es 0 y x es negativo, θ = π.</target>       </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve" uid="M:System.Math.Atan2(System.Double,System.Double)">
          <source>If y is positive and x is 0, θ = π/2.</source>
          <target state="translated">Si y es positivo y x es 0, θ = π/2.</target>       </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve" uid="M:System.Math.Atan2(System.Double,System.Double)">
          <source>If y is negative and x is 0, θ = -π/2.</source>
          <target state="translated">Si y es negativo y el valor de x es 0, θ = -π/2.</target>       </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve" uid="M:System.Math.Atan2(System.Double,System.Double)">
          <source>If y is 0 and x is 0, θ = 0.</source>
          <target state="translated">Si y es 0 y x es 0, θ = 0.</target>       </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve" uid="M:System.Math.Atan2(System.Double,System.Double)">
          <source>If <ph id="ph1">&lt;paramref name="x" /&gt;</ph> or <ph id="ph2">&lt;paramref name="y" /&gt;</ph> is <ph id="ph3">&lt;see cref="F:System.Double.NaN" /&gt;</ph>, or if <ph id="ph4">&lt;paramref name="x" /&gt;</ph> and <ph id="ph5">&lt;paramref name="y" /&gt;</ph> are either <ph id="ph6">&lt;see cref="F:System.Double.PositiveInfinity" /&gt;</ph> or <ph id="ph7">&lt;see cref="F:System.Double.NegativeInfinity" /&gt;</ph>, the method returns <ph id="ph8">&lt;see cref="F:System.Double.NaN" /&gt;</ph>.</source>
          <target state="translated">Si <ph id="ph1">&lt;paramref name="x" /&gt;</ph> o <ph id="ph2">&lt;paramref name="y" /&gt;</ph> es <ph id="ph3">&lt;see cref="F:System.Double.NaN" /&gt;</ph> o si <ph id="ph4">&lt;paramref name="x" /&gt;</ph> y <ph id="ph5">&lt;paramref name="y" /&gt;</ph> son <ph id="ph6">&lt;see cref="F:System.Double.PositiveInfinity" /&gt;</ph> o <ph id="ph7">&lt;see cref="F:System.Double.NegativeInfinity" /&gt;</ph>, el método devuelve <ph id="ph8">&lt;see cref="F:System.Double.NaN" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Math.Atan2(System.Double,System.Double)">
          <source>The return value is the angle in the Cartesian plane formed by the x-axis, and a vector starting from the origin, (0,0), and terminating at the point, (x,y).</source>
          <target state="translated">El valor devuelto es el ángulo en el plano cartesiano formado por el eje x y un vector a partir del origen (0,0) y termina en el punto, (x, y).</target>       </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Math.Atan2(System.Double,System.Double)">
          <source>The following example demonstrates how to calculate the arctangent of an angle and a vector.</source>
          <target state="translated">En el ejemplo siguiente se muestra cómo calcular el arco tangente de un ángulo y un vector.</target>       </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Math.Atan2(System.Double,System.Double)">
          <source>The resulting value is displayed in the console.</source>
          <target state="translated">El valor resultante se muestra en la consola.</target>       </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve" uid="M:System.Math.BigMul(System.Int32,System.Int32)">
          <source>The first number to multiply.</source>
          <target state="translated">El primer número que se va a multiplicar.</target>       </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve" uid="M:System.Math.BigMul(System.Int32,System.Int32)">
          <source>The second number to multiply.</source>
          <target state="translated">El segundo número que se va a multiplicar.</target>       </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve" uid="M:System.Math.BigMul(System.Int32,System.Int32)">
          <source>Produces the full product of two 32-bit numbers.</source>
          <target state="translated">Calcula el producto completo de dos números de 32 bits.</target>       </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve" uid="M:System.Math.BigMul(System.Int32,System.Int32)">
          <source>The number containing the product of the specified numbers.</source>
          <target state="translated">Número que contiene el producto de los números especificados.</target>       </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Math.BigMul(System.Int32,System.Int32)">
          <source>The following example demonstrates the use of the <ph id="ph1">&lt;xref:System.Math.BigMul%2A&gt;</ph> method to calculate the product of two integer values.</source>
          <target state="translated">En el ejemplo siguiente se muestra el uso de la <ph id="ph1">&lt;xref:System.Math.BigMul%2A&gt;</ph> método para calcular el producto de dos valores enteros.</target>       </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve" uid="T:System.Math">
          <source>Returns the smallest integral value greater than or equal to the specified number.</source>
          <target state="translated">Devuelve el menor valor integral mayor o igual que el número especificado.</target>       </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Math">
          <source>The behavior of this method follows IEEE Standard 754, section 4.</source>
          <target state="translated">El comportamiento de este método sigue el estándar IEEE 754, sección 4.</target>       </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Math">
          <source>This kind of rounding is sometimes called rounding toward positive infinity.</source>
          <target state="translated">Este tipo de redondeo a veces se denomina redondeo hacia el infinito positivo.</target>       </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve" uid="M:System.Math.Ceiling(System.Decimal)">
          <source>A decimal number.</source>
          <target state="translated">Número decimal.</target>       </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve" uid="M:System.Math.Ceiling(System.Decimal)">
          <source>Returns the smallest integral value that is greater than or equal to the specified decimal number.</source>
          <target state="translated">Devuelve el valor integral más pequeño que es mayor o igual que el número decimal especificado.</target>       </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve" uid="M:System.Math.Ceiling(System.Decimal)">
          <source>The smallest integral value that is greater than or equal to <ph id="ph1">&lt;paramref name="d" /&gt;</ph>.</source>
          <target state="translated">Valor entero más pequeño que es mayor o igual que <ph id="ph1">&lt;paramref name="d" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve" uid="M:System.Math.Ceiling(System.Decimal)">
          <source>Note that this method returns a <ph id="ph1">&lt;see cref="T:System.Decimal" /&gt;</ph> instead of an integral type.</source>
          <target state="translated">Tenga en cuenta que este método devuelve un valor <ph id="ph1">&lt;see cref="T:System.Decimal" /&gt;</ph> en lugar de un tipo entero.</target>       </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Math.Ceiling(System.Decimal)">
          <source>The behavior of this method follows IEEE Standard 754, section 4.</source>
          <target state="translated">El comportamiento de este método sigue el estándar IEEE 754, sección 4.</target>       </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Math.Ceiling(System.Decimal)">
          <source>This kind of rounding is sometimes called rounding toward positive infinity.</source>
          <target state="translated">Este tipo de redondeo a veces se denomina redondeo hacia el infinito positivo.</target>       </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Math.Ceiling(System.Decimal)">
          <source>In other words, if <ph id="ph1">`d`</ph> is positive, the presence of any fractional component causes <ph id="ph2">`d`</ph> to be rounded to the next highest integer.</source>
          <target state="translated">En otras palabras, si <ph id="ph1">`d`</ph> es positivo, la presencia de las causas de cualquier componente de fracción <ph id="ph2">`d`</ph> se redondea al entero más alto siguiente.</target>       </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Math.Ceiling(System.Decimal)">
          <source>If <ph id="ph1">`d`</ph> is negative, the rounding operation causes any fractional component of <ph id="ph2">`d`</ph> to be discarded.</source>
          <target state="translated">Si <ph id="ph1">`d`</ph> es negativo, la operación de redondeo hace que cualquier componente fraccionario de <ph id="ph2">`d`</ph> van a descartar.</target>       </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Math.Ceiling(System.Decimal)">
          <source>The operation of this method differs from the <ph id="ph1">&lt;xref:System.Math.Floor%28System.Decimal%29&gt;</ph> method, which supports rounding toward negative infinity.</source>
          <target state="translated">La operación de este método difiere de la <ph id="ph1">&lt;xref:System.Math.Floor%28System.Decimal%29&gt;</ph> método, que es compatible con redondeo a infinito negativo.</target>       </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Math.Ceiling(System.Decimal)">
          <source>The following example illustrates the <ph id="ph1">&lt;xref:System.Math.Ceiling%28System.Decimal%29?displayProperty=nameWithType&gt;</ph> method and contrasts it with the <ph id="ph2">&lt;xref:System.Math.Floor%28System.Decimal%29&gt;</ph> method.</source>
          <target state="translated">En el ejemplo siguiente se muestra la <ph id="ph1">&lt;xref:System.Math.Ceiling%28System.Decimal%29?displayProperty=nameWithType&gt;</ph> método y se contrasta con la <ph id="ph2">&lt;xref:System.Math.Floor%28System.Decimal%29&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve" uid="M:System.Math.Ceiling(System.Double)">
          <source>A double-precision floating-point number.</source>
          <target state="translated">Número de punto flotante de precisión doble.</target>       </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve" uid="M:System.Math.Ceiling(System.Double)">
          <source>Returns the smallest integral value that is greater than or equal to the specified double-precision floating-point number.</source>
          <target state="translated">Devuelve el valor integral más pequeño que es mayor o igual que el número de punto flotante de precisión doble especificado.</target>       </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve" uid="M:System.Math.Ceiling(System.Double)">
          <source>The smallest integral value that is greater than or equal to <ph id="ph1">&lt;paramref name="a" /&gt;</ph>.</source>
          <target state="translated">Valor entero más pequeño que es mayor o igual que <ph id="ph1">&lt;paramref name="a" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve" uid="M:System.Math.Ceiling(System.Double)">
          <source>If <ph id="ph1">&lt;paramref name="a" /&gt;</ph> is equal to <ph id="ph2">&lt;see cref="F:System.Double.NaN" /&gt;</ph>, <ph id="ph3">&lt;see cref="F:System.Double.NegativeInfinity" /&gt;</ph>, or <ph id="ph4">&lt;see cref="F:System.Double.PositiveInfinity" /&gt;</ph>, that value is returned.</source>
          <target state="translated">Si <ph id="ph1">&lt;paramref name="a" /&gt;</ph> es igual que <ph id="ph2">&lt;see cref="F:System.Double.NaN" /&gt;</ph>, <ph id="ph3">&lt;see cref="F:System.Double.NegativeInfinity" /&gt;</ph> o <ph id="ph4">&lt;see cref="F:System.Double.PositiveInfinity" /&gt;</ph>, se devuelve ese valor.</target>       </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve" uid="M:System.Math.Ceiling(System.Double)">
          <source>Note that this method returns a <ph id="ph1">&lt;see cref="T:System.Double" /&gt;</ph> instead of an integral type.</source>
          <target state="translated">Tenga en cuenta que este método devuelve un valor <ph id="ph1">&lt;see cref="T:System.Double" /&gt;</ph> en lugar de un tipo entero.</target>       </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Math.Ceiling(System.Double)">
          <source>The behavior of this method follows IEEE Standard 754, section 4.</source>
          <target state="translated">El comportamiento de este método sigue el estándar IEEE 754, sección 4.</target>       </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Math.Ceiling(System.Double)">
          <source>This kind of rounding is sometimes called rounding toward positive infinity.</source>
          <target state="translated">Este tipo de redondeo a veces se denomina redondeo hacia el infinito positivo.</target>       </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Math.Ceiling(System.Double)">
          <source>In other words, if <ph id="ph1">`a`</ph> is positive, the presence of any fractional component causes <ph id="ph2">`a`</ph> to be rounded to the next highest integer.</source>
          <target state="translated">En otras palabras, si <ph id="ph1">`a`</ph> es positivo, la presencia de las causas de cualquier componente de fracción <ph id="ph2">`a`</ph> se redondea al entero más alto siguiente.</target>       </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Math.Ceiling(System.Double)">
          <source>If <ph id="ph1">`a`</ph> is negative, the rounding operation causes any fractional component of <ph id="ph2">`a`</ph> to be discarded.</source>
          <target state="translated">Si <ph id="ph1">`a`</ph> es negativo, la operación de redondeo hace que cualquier componente fraccionario de <ph id="ph2">`a`</ph> van a descartar.</target>       </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Math.Ceiling(System.Double)">
          <source>The operation of this method differs from the <ph id="ph1">&lt;xref:System.Math.Floor%28System.Double%29&gt;</ph> method, which supports rounding toward negative infinity.</source>
          <target state="translated">La operación de este método difiere de la <ph id="ph1">&lt;xref:System.Math.Floor%28System.Double%29&gt;</ph> método, que es compatible con redondeo a infinito negativo.</target>       </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Math.Ceiling(System.Double)">
          <source>The following example illustrates the <ph id="ph1">&lt;xref:System.Math.Ceiling%28System.Double%29?displayProperty=nameWithType&gt;</ph> method and contrasts it with the <ph id="ph2">&lt;xref:System.Math.Floor%28System.Double%29&gt;</ph> method.</source>
          <target state="translated">En el ejemplo siguiente se muestra la <ph id="ph1">&lt;xref:System.Math.Ceiling%28System.Double%29?displayProperty=nameWithType&gt;</ph> método y se contrasta con la <ph id="ph2">&lt;xref:System.Math.Floor%28System.Double%29&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve" uid="M:System.Math.Cos(System.Double)">
          <source>An angle, measured in radians.</source>
          <target state="translated">Ángulo, medido en radianes.</target>       </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve" uid="M:System.Math.Cos(System.Double)">
          <source>Returns the cosine of the specified angle.</source>
          <target state="translated">Devuelve el coseno del ángulo especificado.</target>       </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve" uid="M:System.Math.Cos(System.Double)">
          <source>The cosine of <ph id="ph1">&lt;paramref name="d" /&gt;</ph>.</source>
          <target state="translated">Coseno de <ph id="ph1">&lt;paramref name="d" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve" uid="M:System.Math.Cos(System.Double)">
          <source>If <ph id="ph1">&lt;paramref name="d" /&gt;</ph> is equal to <ph id="ph2">&lt;see cref="F:System.Double.NaN" /&gt;</ph>, <ph id="ph3">&lt;see cref="F:System.Double.NegativeInfinity" /&gt;</ph>, or <ph id="ph4">&lt;see cref="F:System.Double.PositiveInfinity" /&gt;</ph>, this method returns <ph id="ph5">&lt;see cref="F:System.Double.NaN" /&gt;</ph>.</source>
          <target state="translated">Si <ph id="ph1">&lt;paramref name="d" /&gt;</ph> es igual a <ph id="ph2">&lt;see cref="F:System.Double.NaN" /&gt;</ph>, <ph id="ph3">&lt;see cref="F:System.Double.NegativeInfinity" /&gt;</ph> o <ph id="ph4">&lt;see cref="F:System.Double.PositiveInfinity" /&gt;</ph>, este método devuelve <ph id="ph5">&lt;see cref="F:System.Double.NaN" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Math.Cos(System.Double)">
          <source>The angle, <ph id="ph1">`d`</ph>, must be in radians.</source>
          <target state="translated">El ángulo, <ph id="ph1">`d`</ph>, deben estar en radianes.</target>       </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Math.Cos(System.Double)">
          <source>Multiply by <ph id="ph1">&lt;xref:System.Math.PI?displayProperty=nameWithType&gt;</ph>/180 to convert degrees to radians.</source>
          <target state="translated">Multiplicar por <ph id="ph1">&lt;xref:System.Math.PI?displayProperty=nameWithType&gt;</ph>/180 para convertir los grados en radianes.</target>       </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Math.Cos(System.Double)">
          <source>Acceptable values of <ph id="ph1">`d`</ph> range from approximately -9223372036854775295 to approximately 9223372036854775295.</source>
          <target state="translated">Los valores aceptables de <ph id="ph1">`d`</ph> intervalo de aproximadamente -9223372036854775295 a aproximadamente 9223372036854775295.</target>       </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Math.Cos(System.Double)">
          <source>For values outside this range, the <ph id="ph1">&lt;xref:System.Math.Cos%2A&gt;</ph> method returns <ph id="ph2">`d`</ph> unchanged rather than throwing an exception.</source>
          <target state="translated">Para valores fuera de este intervalo, el <ph id="ph1">&lt;xref:System.Math.Cos%2A&gt;</ph> método <ph id="ph2">`d`</ph> sin cambios en lugar de producir una excepción.</target>       </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Math.Cos(System.Double)">
          <source>The following example uses <ph id="ph1">&lt;xref:System.Math.Cos%2A&gt;</ph> to evaluate certain trigonometric identities for selected angles.</source>
          <target state="translated">En el ejemplo siguiente se utiliza <ph id="ph1">&lt;xref:System.Math.Cos%2A&gt;</ph> para evaluar determinadas identidades trigonométricas de ángulos seleccionados.</target>       </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve" uid="M:System.Math.Cosh(System.Double)">
          <source>An angle, measured in radians.</source>
          <target state="translated">Ángulo, medido en radianes.</target>       </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve" uid="M:System.Math.Cosh(System.Double)">
          <source>Returns the hyperbolic cosine of the specified angle.</source>
          <target state="translated">Devuelve el coseno hiperbólico del ángulo especificado.</target>       </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve" uid="M:System.Math.Cosh(System.Double)">
          <source>The hyperbolic cosine of <ph id="ph1">&lt;paramref name="value" /&gt;</ph>.</source>
          <target state="translated">Coseno hiperbólico de <ph id="ph1">&lt;paramref name="value" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve" uid="M:System.Math.Cosh(System.Double)">
          <source>If <ph id="ph1">&lt;paramref name="value" /&gt;</ph> is equal to <ph id="ph2">&lt;see cref="F:System.Double.NegativeInfinity" /&gt;</ph> or <ph id="ph3">&lt;see cref="F:System.Double.PositiveInfinity" /&gt;</ph>, <ph id="ph4">&lt;see cref="F:System.Double.PositiveInfinity" /&gt;</ph> is returned.</source>
          <target state="translated">Si <ph id="ph1">&lt;paramref name="value" /&gt;</ph> es igual que <ph id="ph2">&lt;see cref="F:System.Double.NegativeInfinity" /&gt;</ph> o <ph id="ph3">&lt;see cref="F:System.Double.PositiveInfinity" /&gt;</ph>, se devuelve <ph id="ph4">&lt;see cref="F:System.Double.PositiveInfinity" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve" uid="M:System.Math.Cosh(System.Double)">
          <source>If <ph id="ph1">&lt;paramref name="value" /&gt;</ph> is equal to <ph id="ph2">&lt;see cref="F:System.Double.NaN" /&gt;</ph>, <ph id="ph3">&lt;see cref="F:System.Double.NaN" /&gt;</ph> is returned.</source>
          <target state="translated">Si <ph id="ph1">&lt;paramref name="value" /&gt;</ph> es igual que <ph id="ph2">&lt;see cref="F:System.Double.NaN" /&gt;</ph>, se devuelve <ph id="ph3">&lt;see cref="F:System.Double.NaN" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Math.Cosh(System.Double)">
          <source>The angle, <ph id="ph1">`value`</ph>, must be in radians.</source>
          <target state="translated">El ángulo, <ph id="ph1">`value`</ph>, deben estar en radianes.</target>       </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Math.Cosh(System.Double)">
          <source>Multiply by <ph id="ph1">&lt;xref:System.Math.PI?displayProperty=nameWithType&gt;</ph>/180 to convert degrees to radians.</source>
          <target state="translated">Multiplicar por <ph id="ph1">&lt;xref:System.Math.PI?displayProperty=nameWithType&gt;</ph>/180 para convertir los grados en radianes.</target>       </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Math.Cosh(System.Double)">
          <source>The following example uses <ph id="ph1">&lt;xref:System.Math.Cosh%2A&gt;</ph> to evaluate certain hyperbolic identities for selected values.</source>
          <target state="translated">En el ejemplo siguiente se utiliza <ph id="ph1">&lt;xref:System.Math.Cosh%2A&gt;</ph> para evaluar determinadas identidades hiperbólicas de valores seleccionados.</target>       </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve" uid="T:System.Math">
          <source>Calculates the quotient of two numbers and also returns the remainder in an output parameter.</source>
          <target state="translated">Calcula el cociente de dos números y devuelve también el resto de la división como parámetro de salida.</target>       </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve" uid="M:System.Math.DivRem(System.Int32,System.Int32,System.Int32@)">
          <source>The dividend.</source>
          <target state="translated">Dividendo.</target>       </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve" uid="M:System.Math.DivRem(System.Int32,System.Int32,System.Int32@)">
          <source>The divisor.</source>
          <target state="translated">Divisor.</target>       </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve" uid="M:System.Math.DivRem(System.Int32,System.Int32,System.Int32@)">
          <source>The remainder.</source>
          <target state="translated">Resto.</target>       </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve" uid="M:System.Math.DivRem(System.Int32,System.Int32,System.Int32@)">
          <source>Calculates the quotient of two 32-bit signed integers and also returns the remainder in an output parameter.</source>
          <target state="translated">Calcula el cociente de dos números enteros de 32 bits con signo y devuelve también el resto de la división como parámetro de salida.</target>       </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve" uid="M:System.Math.DivRem(System.Int32,System.Int32,System.Int32@)">
          <source>The quotient of the specified numbers.</source>
          <target state="translated">Cociente de los números especificados.</target>       </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Math.DivRem(System.Int32,System.Int32,System.Int32@)">
          <source>The remainder is calculated by using the modulus operation.</source>
          <target state="translated">El resto se calcula mediante el uso de la operación de módulo.</target>       </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Math.DivRem(System.Int32,System.Int32,System.Int32@)">
          <source>The following example demonstrates the <ph id="ph1">&lt;xref:System.Math.DivRem%28System.Int32%2CSystem.Int32%2CSystem.Int32%40%29&gt;</ph> method.</source>
          <target state="translated">En el ejemplo siguiente se muestra el <ph id="ph1">&lt;xref:System.Math.DivRem%28System.Int32%2CSystem.Int32%2CSystem.Int32%40%29&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve" uid="M:System.Math.DivRem(System.Int32,System.Int32,System.Int32@)">
          <source><ph id="ph1">&lt;paramref name="b" /&gt;</ph> is zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="b" /&gt;</ph> es cero.</target>       </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve" uid="M:System.Math.DivRem(System.Int64,System.Int64,System.Int64@)">
          <source>The dividend.</source>
          <target state="translated">Dividendo.</target>       </trans-unit>
        <trans-unit id="252" translate="yes" xml:space="preserve" uid="M:System.Math.DivRem(System.Int64,System.Int64,System.Int64@)">
          <source>The divisor.</source>
          <target state="translated">Divisor.</target>       </trans-unit>
        <trans-unit id="253" translate="yes" xml:space="preserve" uid="M:System.Math.DivRem(System.Int64,System.Int64,System.Int64@)">
          <source>The remainder.</source>
          <target state="translated">Resto.</target>       </trans-unit>
        <trans-unit id="254" translate="yes" xml:space="preserve" uid="M:System.Math.DivRem(System.Int64,System.Int64,System.Int64@)">
          <source>Calculates the quotient of two 64-bit signed integers and also returns the remainder in an output parameter.</source>
          <target state="translated">Calcula el cociente de dos números enteros de 64 bits con signo y devuelve también el resto de la división como parámetro de salida.</target>       </trans-unit>
        <trans-unit id="255" translate="yes" xml:space="preserve" uid="M:System.Math.DivRem(System.Int64,System.Int64,System.Int64@)">
          <source>The quotient of the specified numbers.</source>
          <target state="translated">Cociente de los números especificados.</target>       </trans-unit>
        <trans-unit id="256" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Math.DivRem(System.Int64,System.Int64,System.Int64@)">
          <source>The remainder is calculated by using the modulus operation.</source>
          <target state="translated">El resto se calcula mediante el uso de la operación de módulo.</target>       </trans-unit>
        <trans-unit id="257" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Math.DivRem(System.Int64,System.Int64,System.Int64@)">
          <source>The following example demonstrates the <ph id="ph1">&lt;xref:System.Math.DivRem%28System.Int64%2CSystem.Int64%2CSystem.Int64%40%29&gt;</ph> method.</source>
          <target state="translated">En el ejemplo siguiente se muestra el <ph id="ph1">&lt;xref:System.Math.DivRem%28System.Int64%2CSystem.Int64%2CSystem.Int64%40%29&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="258" translate="yes" xml:space="preserve" uid="M:System.Math.DivRem(System.Int64,System.Int64,System.Int64@)">
          <source><ph id="ph1">&lt;paramref name="b" /&gt;</ph> is zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="b" /&gt;</ph> es cero.</target>       </trans-unit>
        <trans-unit id="259" translate="yes" xml:space="preserve" uid="F:System.Math.E">
          <source>Represents the natural logarithmic base, specified by the constant, <ph id="ph1">&lt;see langword="e" /&gt;</ph>.</source>
          <target state="translated">Representa la base logarítmica natural, especificada por la constante, <ph id="ph1">&lt;see langword="e" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="260" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Math.E">
          <source>The value of this field is 2.7182818284590452354.</source>
          <target state="translated">El valor de este campo es 2,7182818284590452354.</target>       </trans-unit>
        <trans-unit id="261" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Math.E">
          <source>The following example compares <ph id="ph1">&lt;xref:System.Math.E&gt;</ph> with the value calculated from a power series.</source>
          <target state="translated">En el ejemplo siguiente se comparan <ph id="ph1">&lt;xref:System.Math.E&gt;</ph> con el valor calculado a partir de una serie de energía.</target>       </trans-unit>
        <trans-unit id="262" translate="yes" xml:space="preserve" uid="M:System.Math.Exp(System.Double)">
          <source>A number specifying a power.</source>
          <target state="translated">Número que especifica una potencia.</target>       </trans-unit>
        <trans-unit id="263" translate="yes" xml:space="preserve" uid="M:System.Math.Exp(System.Double)">
          <source>Returns <ph id="ph1">&lt;see langword="e" /&gt;</ph> raised to the specified power.</source>
          <target state="translated">Devuelve <ph id="ph1">&lt;see langword="e" /&gt;</ph> elevado a la potencia especificada.</target>       </trans-unit>
        <trans-unit id="264" translate="yes" xml:space="preserve" uid="M:System.Math.Exp(System.Double)">
          <source>The number <ph id="ph1">&lt;see langword="e" /&gt;</ph> raised to the power <ph id="ph2">&lt;paramref name="d" /&gt;</ph>.</source>
          <target state="translated">Número <ph id="ph1">&lt;see langword="e" /&gt;</ph> elevado a la potencia <ph id="ph2">&lt;paramref name="d" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="265" translate="yes" xml:space="preserve" uid="M:System.Math.Exp(System.Double)">
          <source>If <ph id="ph1">&lt;paramref name="d" /&gt;</ph> equals <ph id="ph2">&lt;see cref="F:System.Double.NaN" /&gt;</ph> or <ph id="ph3">&lt;see cref="F:System.Double.PositiveInfinity" /&gt;</ph>, that value is returned.</source>
          <target state="translated">Si <ph id="ph1">&lt;paramref name="d" /&gt;</ph> es igual que <ph id="ph2">&lt;see cref="F:System.Double.NaN" /&gt;</ph> o <ph id="ph3">&lt;see cref="F:System.Double.PositiveInfinity" /&gt;</ph>, se devuelve ese valor.</target>       </trans-unit>
        <trans-unit id="266" translate="yes" xml:space="preserve" uid="M:System.Math.Exp(System.Double)">
          <source>If <ph id="ph1">&lt;paramref name="d" /&gt;</ph> equals <ph id="ph2">&lt;see cref="F:System.Double.NegativeInfinity" /&gt;</ph>, 0 is returned.</source>
          <target state="translated">Si <ph id="ph1">&lt;paramref name="d" /&gt;</ph> es igual que <ph id="ph2">&lt;see cref="F:System.Double.NegativeInfinity" /&gt;</ph>, se devuelve 0.</target>       </trans-unit>
        <trans-unit id="267" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Math.Exp(System.Double)">
          <source><ph id="ph1">`e`</ph> is a mathematical constant whose value is approximately 2.71828.</source>
          <target state="translated"><ph id="ph1">`e`</ph> es una constante matemática cuyo valor es aproximadamente 2,71828.</target>       </trans-unit>
        <trans-unit id="268" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Math.Exp(System.Double)">
          <source>Use the <ph id="ph1">&lt;xref:System.Math.Pow%2A&gt;</ph> method to calculate powers of other bases.</source>
          <target state="translated">Use la <ph id="ph1">&lt;xref:System.Math.Pow%2A&gt;</ph> método para calcular las potencias de otras bases de datos.</target>       </trans-unit>
        <trans-unit id="269" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Math.Exp(System.Double)">
          <source><ph id="ph1">&lt;xref:System.Math.Exp%2A&gt;</ph> is the inverse of <ph id="ph2">&lt;xref:System.Math.Log%2A&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Math.Exp%2A&gt;</ph> es el inverso del <ph id="ph2">&lt;xref:System.Math.Log%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="270" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Math.Exp(System.Double)">
          <source>The following example uses <ph id="ph1">&lt;xref:System.Math.Exp%2A&gt;</ph> to evaluate certain exponential and logarithmic identities for selected values.</source>
          <target state="translated">En el ejemplo siguiente se utiliza <ph id="ph1">&lt;xref:System.Math.Exp%2A&gt;</ph> para evaluar determinadas identidades exponenciales y logarítmicas de valores seleccionados.</target>       </trans-unit>
        <trans-unit id="271" translate="yes" xml:space="preserve" uid="T:System.Math">
          <source>Returns the largest integral value less than or equal to the specified number.</source>
          <target state="translated">Devuelve el mayor valor integral menor o igual que el número especificado.</target>       </trans-unit>
        <trans-unit id="272" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Math">
          <source>The behavior of this method follows IEEE Standard 754, section 4.</source>
          <target state="translated">El comportamiento de este método sigue el estándar IEEE 754, sección 4.</target>       </trans-unit>
        <trans-unit id="273" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Math">
          <source>This kind of rounding is sometimes called rounding toward negative infinity.</source>
          <target state="translated">Este tipo de redondeo a veces se denomina redondeo a infinito negativo.</target>       </trans-unit>
        <trans-unit id="274" translate="yes" xml:space="preserve" uid="M:System.Math.Floor(System.Decimal)">
          <source>A decimal number.</source>
          <target state="translated">Número decimal.</target>       </trans-unit>
        <trans-unit id="275" translate="yes" xml:space="preserve" uid="M:System.Math.Floor(System.Decimal)">
          <source>Returns the largest integral value less than or equal to the specified decimal number.</source>
          <target state="translated">Devuelve el mayor valor integral menor o igual que el número decimal especificado.</target>       </trans-unit>
        <trans-unit id="276" translate="yes" xml:space="preserve" uid="M:System.Math.Floor(System.Decimal)">
          <source>The largest integral value less than or equal to <ph id="ph1">&lt;paramref name="d" /&gt;</ph>.</source>
          <target state="translated">El mayor valor integral que es menor o igual que <ph id="ph1">&lt;paramref name="d" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="277" translate="yes" xml:space="preserve" uid="M:System.Math.Floor(System.Decimal)">
          <source>Note that the method returns an integral value of type <ph id="ph1">&lt;see cref="T:System.Decimal" /&gt;</ph>.</source>
          <target state="translated">Tenga en cuenta que el método devuelve un valor entero de tipo <ph id="ph1">&lt;see cref="T:System.Decimal" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="278" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Math.Floor(System.Decimal)">
          <source>The behavior of this method follows IEEE Standard 754, section 4.</source>
          <target state="translated">El comportamiento de este método sigue el estándar IEEE 754, sección 4.</target>       </trans-unit>
        <trans-unit id="279" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Math.Floor(System.Decimal)">
          <source>This kind of rounding is sometimes called rounding toward negative infinity.</source>
          <target state="translated">Este tipo de redondeo a veces se denomina redondeo a infinito negativo.</target>       </trans-unit>
        <trans-unit id="280" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Math.Floor(System.Decimal)">
          <source>In other words, if <ph id="ph1">`d`</ph> is positive, any fractional component is truncated.</source>
          <target state="translated">En otras palabras, si <ph id="ph1">`d`</ph> es positivo, se trunca cualquier componente fraccionario.</target>       </trans-unit>
        <trans-unit id="281" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Math.Floor(System.Decimal)">
          <source>If <ph id="ph1">`d`</ph> is negative, the presence of any fractional component causes it to be rounded to the smaller integer.</source>
          <target state="translated">Si <ph id="ph1">`d`</ph> es negativo, la presencia de cualquier componente fraccionario hace que se redondea al entero más pequeño.</target>       </trans-unit>
        <trans-unit id="282" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Math.Floor(System.Decimal)">
          <source>The operation of this method differs from the <ph id="ph1">&lt;xref:System.Math.Ceiling%2A&gt;</ph> method, which supports rounding toward positive infinity.</source>
          <target state="translated">La operación de este método difiere de la <ph id="ph1">&lt;xref:System.Math.Ceiling%2A&gt;</ph> método, que es compatible con redondeo a infinito positivo.</target>       </trans-unit>
        <trans-unit id="283" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Math.Floor(System.Decimal)">
          <source>The following example illustrates the <ph id="ph1">&lt;xref:System.Math.Floor%28System.Decimal%29?displayProperty=nameWithType&gt;</ph> method and contrasts it with the <ph id="ph2">&lt;xref:System.Math.Ceiling%28System.Decimal%29&gt;</ph> method.</source>
          <target state="translated">En el ejemplo siguiente se muestra la <ph id="ph1">&lt;xref:System.Math.Floor%28System.Decimal%29?displayProperty=nameWithType&gt;</ph> método y se contrasta con la <ph id="ph2">&lt;xref:System.Math.Ceiling%28System.Decimal%29&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="284" translate="yes" xml:space="preserve" uid="M:System.Math.Floor(System.Double)">
          <source>A double-precision floating-point number.</source>
          <target state="translated">Número de punto flotante de precisión doble.</target>       </trans-unit>
        <trans-unit id="285" translate="yes" xml:space="preserve" uid="M:System.Math.Floor(System.Double)">
          <source>Returns the largest integral value less than or equal to the specified double-precision floating-point number.</source>
          <target state="translated">Devuelve el mayor valor integral menor o igual que el número de punto flotante de precisión doble especificado.</target>       </trans-unit>
        <trans-unit id="286" translate="yes" xml:space="preserve" uid="M:System.Math.Floor(System.Double)">
          <source>The largest integral value less than or equal to <ph id="ph1">&lt;paramref name="d" /&gt;</ph>.</source>
          <target state="translated">El mayor valor integral que es menor o igual que <ph id="ph1">&lt;paramref name="d" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="287" translate="yes" xml:space="preserve" uid="M:System.Math.Floor(System.Double)">
          <source>If <ph id="ph1">&lt;paramref name="d" /&gt;</ph> is equal to <ph id="ph2">&lt;see cref="F:System.Double.NaN" /&gt;</ph>, <ph id="ph3">&lt;see cref="F:System.Double.NegativeInfinity" /&gt;</ph>, or <ph id="ph4">&lt;see cref="F:System.Double.PositiveInfinity" /&gt;</ph>, that value is returned.</source>
          <target state="translated">Si <ph id="ph1">&lt;paramref name="d" /&gt;</ph> es igual que <ph id="ph2">&lt;see cref="F:System.Double.NaN" /&gt;</ph>, <ph id="ph3">&lt;see cref="F:System.Double.NegativeInfinity" /&gt;</ph> o <ph id="ph4">&lt;see cref="F:System.Double.PositiveInfinity" /&gt;</ph>, se devuelve ese valor.</target>       </trans-unit>
        <trans-unit id="288" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Math.Floor(System.Double)">
          <source>The behavior of this method follows IEEE Standard 754, section 4.</source>
          <target state="translated">El comportamiento de este método sigue el estándar IEEE 754, sección 4.</target>       </trans-unit>
        <trans-unit id="289" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Math.Floor(System.Double)">
          <source>This kind of rounding is sometimes called rounding toward negative infinity.</source>
          <target state="translated">Este tipo de redondeo a veces se denomina redondeo a infinito negativo.</target>       </trans-unit>
        <trans-unit id="290" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Math.Floor(System.Double)">
          <source>In other words, if <ph id="ph1">`d`</ph> is positive, any fractional component is truncated.</source>
          <target state="translated">En otras palabras, si <ph id="ph1">`d`</ph> es positivo, se trunca cualquier componente fraccionario.</target>       </trans-unit>
        <trans-unit id="291" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Math.Floor(System.Double)">
          <source>If <ph id="ph1">`d`</ph> is negative, the presence of any fractional component causes it to be rounded to the smaller integer.</source>
          <target state="translated">Si <ph id="ph1">`d`</ph> es negativo, la presencia de cualquier componente fraccionario hace que se redondea al entero más pequeño.</target>       </trans-unit>
        <trans-unit id="292" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Math.Floor(System.Double)">
          <source>The operation of this method differs from the <ph id="ph1">&lt;xref:System.Math.Ceiling%2A&gt;</ph> method, which supports rounding toward positive infinity.</source>
          <target state="translated">La operación de este método difiere de la <ph id="ph1">&lt;xref:System.Math.Ceiling%2A&gt;</ph> método, que es compatible con redondeo a infinito positivo.</target>       </trans-unit>
        <trans-unit id="293" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Math.Floor(System.Double)">
          <source>The following example illustrates the <ph id="ph1">&lt;xref:System.Math.Floor%28System.Double%29?displayProperty=nameWithType&gt;</ph> method and contrasts it with the <ph id="ph2">&lt;xref:System.Math.Ceiling%28System.Double%29&gt;</ph> method.</source>
          <target state="translated">En el ejemplo siguiente se muestra la <ph id="ph1">&lt;xref:System.Math.Floor%28System.Double%29?displayProperty=nameWithType&gt;</ph> método y se contrasta con la <ph id="ph2">&lt;xref:System.Math.Ceiling%28System.Double%29&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="294" translate="yes" xml:space="preserve" uid="M:System.Math.IEEERemainder(System.Double,System.Double)">
          <source>A dividend.</source>
          <target state="translated">Dividendo.</target>       </trans-unit>
        <trans-unit id="295" translate="yes" xml:space="preserve" uid="M:System.Math.IEEERemainder(System.Double,System.Double)">
          <source>A divisor.</source>
          <target state="translated">Divisor.</target>       </trans-unit>
        <trans-unit id="296" translate="yes" xml:space="preserve" uid="M:System.Math.IEEERemainder(System.Double,System.Double)">
          <source>Returns the remainder resulting from the division of a specified number by another specified number.</source>
          <target state="translated">Devuelve el resto de la división de dos números especificados.</target>       </trans-unit>
        <trans-unit id="297" translate="yes" xml:space="preserve" uid="M:System.Math.IEEERemainder(System.Double,System.Double)">
          <source>A number equal to <ph id="ph1">&lt;paramref name="x" /&gt;</ph> - (<ph id="ph2">&lt;paramref name="y" /&gt;</ph> Q), where Q is the quotient of <ph id="ph3">&lt;paramref name="x" /&gt;</ph><ph id="ph4"> / </ph><ph id="ph5">&lt;paramref name="y" /&gt;</ph> rounded to the nearest integer (if <ph id="ph6">&lt;paramref name="x" /&gt;</ph><ph id="ph7"> / </ph><ph id="ph8">&lt;paramref name="y" /&gt;</ph> falls halfway between two integers, the even integer is returned).</source>
          <target state="translated">Número igual a <ph id="ph1">&lt;paramref name="x" /&gt;</ph> - (<ph id="ph2">&lt;paramref name="y" /&gt;</ph> Q), donde Q es el cociente de <ph id="ph3">&lt;paramref name="x" /&gt;</ph><ph id="ph4"> / </ph><ph id="ph5">&lt;paramref name="y" /&gt;</ph> redondeado a su entero más próximo (si <ph id="ph6">&lt;paramref name="x" /&gt;</ph><ph id="ph7"> / </ph><ph id="ph8">&lt;paramref name="y" /&gt;</ph> se encuentra entre dos enteros, se devuelve el entero par).</target>       </trans-unit>
        <trans-unit id="298" translate="yes" xml:space="preserve" uid="M:System.Math.IEEERemainder(System.Double,System.Double)">
          <source>If <ph id="ph1">&lt;paramref name="x" /&gt;</ph> - (<ph id="ph2">&lt;paramref name="y" /&gt;</ph> Q) is zero, the value +0 is returned if <ph id="ph3">&lt;paramref name="x" /&gt;</ph> is positive, or -0 if <ph id="ph4">&lt;paramref name="x" /&gt;</ph> is negative.</source>
          <target state="translated">Si <ph id="ph1">&lt;paramref name="x" /&gt;</ph> - (<ph id="ph2">&lt;paramref name="y" /&gt;</ph> Q) es cero, se devuelve el valor +0 si <ph id="ph3">&lt;paramref name="x" /&gt;</ph> es positivo o -0 si <ph id="ph4">&lt;paramref name="x" /&gt;</ph> es negativo.</target>       </trans-unit>
        <trans-unit id="299" translate="yes" xml:space="preserve" uid="M:System.Math.IEEERemainder(System.Double,System.Double)">
          <source>If <ph id="ph1">&lt;paramref name="y" /&gt;</ph> = 0, <ph id="ph2">&lt;see cref="F:System.Double.NaN" /&gt;</ph> is returned.</source>
          <target state="translated">Si <ph id="ph1">&lt;paramref name="y" /&gt;</ph> = 0, se devuelve <ph id="ph2">&lt;see cref="F:System.Double.NaN" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="300" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Math.IEEERemainder(System.Double,System.Double)">
          <source>This operation complies with the remainder operation defined in Section 5.1 of ANSI/IEEE Std 754-1985; IEEE Standard for Binary Floating-Point Arithmetic; Institute of Electrical and Electronics Engineers, Inc; 1985.</source>
          <target state="translated">Esta operación cumple con la operación de resto definida en la sección 5.1 de ANSI/IEEE Std 754-1985; Estándar IEEE para aritmética binaria de punto flotante; Institute of Electrical and Electronics Engineers, Inc; 1985.</target>       </trans-unit>
        <trans-unit id="301" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Math.IEEERemainder(System.Double,System.Double)">
          <source>The <ph id="ph1">&lt;xref:System.Math.IEEERemainder%2A&gt;</ph> method is not the same as the modulus operator.</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.Math.IEEERemainder%2A&gt;</ph> método no es el mismo que el operador de módulo.</target>       </trans-unit>
        <trans-unit id="302" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Math.IEEERemainder(System.Double,System.Double)">
          <source>Although both return the remainder after division, the formulas they use are different.</source>
          <target state="translated">Aunque ambos devuelven el resto después de la división, las fórmulas que usan son diferentes.</target>       </trans-unit>
        <trans-unit id="303" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Math.IEEERemainder(System.Double,System.Double)">
          <source>The formula for the <ph id="ph1">&lt;xref:System.Math.IEEERemainder%2A&gt;</ph> method is:</source>
          <target state="translated">La fórmula para el <ph id="ph1">&lt;xref:System.Math.IEEERemainder%2A&gt;</ph> método es:</target>       </trans-unit>
        <trans-unit id="304" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Math.IEEERemainder(System.Double,System.Double)">
          <source>In contrast, the formula for the modulus operator is:</source>
          <target state="translated">En cambio, la fórmula para el operador de módulo es:</target>       </trans-unit>
        <trans-unit id="305" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Math.IEEERemainder(System.Double,System.Double)">
          <source>The following example contrasts the remainder returned by the <ph id="ph1">&lt;xref:System.Math.IEEERemainder%2A&gt;</ph> method with the remainder returned by the modulus division operator.</source>
          <target state="translated">En el ejemplo siguiente se compara el resto devuelto por la <ph id="ph1">&lt;xref:System.Math.IEEERemainder%2A&gt;</ph> método con el resto devuelto por el operador de división de módulo.</target>       </trans-unit>
        <trans-unit id="306" translate="yes" xml:space="preserve" uid="T:System.Math">
          <source>Returns the logarithm of a specified number.</source>
          <target state="translated">Devuelve el logaritmo de un número especificado.</target>       </trans-unit>
        <trans-unit id="307" translate="yes" xml:space="preserve" uid="M:System.Math.Log(System.Double)">
          <source>The number whose logarithm is to be found.</source>
          <target state="translated">Número cuyo logaritmo se va a calcular.</target>       </trans-unit>
        <trans-unit id="308" translate="yes" xml:space="preserve" uid="M:System.Math.Log(System.Double)">
          <source>Returns the natural (base <ph id="ph1">&lt;see langword="e" /&gt;</ph>) logarithm of a specified number.</source>
          <target state="translated">Devuelve el logaritmo natural (en base <ph id="ph1">&lt;see langword="e" /&gt;</ph>) de un número especificado.</target>       </trans-unit>
        <trans-unit id="309" translate="yes" xml:space="preserve" uid="M:System.Math.Log(System.Double)">
          <source>One of the values in the following table.</source>
          <target state="translated">Uno de los valores de la tabla siguiente.</target>       </trans-unit>
        <trans-unit id="310" translate="yes" xml:space="preserve" uid="M:System.Math.Log(System.Double)">
          <source><ph id="ph1">&lt;list type="table"&gt;</ph><ph id="ph2">&lt;listheader&gt;</ph><ph id="ph3">&lt;term&gt;</ph><ph id="ph4">&lt;paramref name="d" /&gt;</ph> parameter</source>
          <target state="translated"><ph id="ph1">&lt;list type="table"&gt;</ph><ph id="ph2">&lt;listheader&gt;</ph><ph id="ph3">&lt;term&gt;</ph>Parámetro <ph id="ph4">&lt;paramref name="d" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="311" translate="yes" xml:space="preserve" uid="M:System.Math.Log(System.Double)">
          <source><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph> Return value</source>
          <target state="translated"><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph> Valor devuelto</target>       </trans-unit>
        <trans-unit id="312" translate="yes" xml:space="preserve" uid="M:System.Math.Log(System.Double)">
          <source><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/listheader&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> Positive</source>
          <target state="translated"><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/listheader&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> Positivo</target>       </trans-unit>
        <trans-unit id="313" translate="yes" xml:space="preserve" uid="M:System.Math.Log(System.Double)">
          <source><ph id="ph1">&lt;/term&gt;</ph><bpt id="p1">&lt;description&gt;</bpt> The natural logarithm of <ph id="ph2">&lt;paramref name="d" /&gt;</ph>; that is, ln <ph id="ph3">&lt;paramref name="d" /&gt;</ph>, or log e <ph id="ph4">&lt;paramref name="d" /&gt;</ph><ept id="p1">&lt;/description&gt;</ept><ph id="ph5">&lt;/item&gt;</ph><ph id="ph6">&lt;item&gt;</ph><ph id="ph7">&lt;term&gt;</ph> Zero</source>
          <target state="translated"><ph id="ph1">&lt;/term&gt;</ph><bpt id="p1">&lt;description&gt;</bpt> Logaritmo natural de <ph id="ph2">&lt;paramref name="d" /&gt;</ph>; es decir, ln <ph id="ph3">&lt;paramref name="d" /&gt;</ph> o log e <ph id="ph4">&lt;paramref name="d" /&gt;</ph><ept id="p1">&lt;/description&gt;</ept><ph id="ph5">&lt;/item&gt;</ph><ph id="ph6">&lt;item&gt;</ph><ph id="ph7">&lt;term&gt;</ph> Cero</target>       </trans-unit>
        <trans-unit id="314" translate="yes" xml:space="preserve" uid="M:System.Math.Log(System.Double)">
          <source><ph id="ph1">&lt;/term&gt;</ph><bpt id="p1">&lt;description&gt;</bpt><ph id="ph2">&lt;see cref="F:System.Double.NegativeInfinity" /&gt;</ph><ept id="p1">&lt;/description&gt;</ept><ph id="ph3">&lt;/item&gt;</ph><ph id="ph4">&lt;item&gt;</ph><ph id="ph5">&lt;term&gt;</ph> Negative</source>
          <target state="translated"><ph id="ph1">&lt;/term&gt;</ph><bpt id="p1">&lt;description&gt;</bpt><ph id="ph2">&lt;see cref="F:System.Double.NegativeInfinity" /&gt;</ph><ept id="p1">&lt;/description&gt;</ept><ph id="ph3">&lt;/item&gt;</ph><ph id="ph4">&lt;item&gt;</ph><ph id="ph5">&lt;term&gt;</ph> Negativo</target>       </trans-unit>
        <trans-unit id="315" translate="yes" xml:space="preserve" uid="M:System.Math.Log(System.Double)">
          <source><ph id="ph1">&lt;/term&gt;</ph><bpt id="p1">&lt;description&gt;</bpt><ph id="ph2">&lt;see cref="F:System.Double.NaN" /&gt;</ph><ept id="p1">&lt;/description&gt;</ept><ph id="ph3">&lt;/item&gt;</ph><bpt id="p2">&lt;item&gt;</bpt><bpt id="p3">&lt;term&gt;</bpt> Equal to <ph id="ph4">&lt;see cref="F:System.Double.NaN" /&gt;</ph><ept id="p3">&lt;/term&gt;</ept><bpt id="p4">&lt;description&gt;</bpt><ph id="ph5">&lt;see cref="F:System.Double.NaN" /&gt;</ph><ept id="p4">&lt;/description&gt;</ept><ept id="p2">&lt;/item&gt;</ept><bpt id="p5">&lt;item&gt;</bpt><bpt id="p6">&lt;term&gt;</bpt> Equal to <ph id="ph6">&lt;see cref="F:System.Double.PositiveInfinity" /&gt;</ph><ept id="p6">&lt;/term&gt;</ept><bpt id="p7">&lt;description&gt;</bpt><ph id="ph7">&lt;see cref="F:System.Double.PositiveInfinity" /&gt;</ph><ept id="p7">&lt;/description&gt;</ept><ept id="p5">&lt;/item&gt;</ept><ph id="ph8">&lt;/list&gt;</ph></source>
          <target state="translated"><ph id="ph1">&lt;/term&gt;</ph><bpt id="p1">&lt;description&gt;</bpt><ph id="ph2">&lt;see cref="F:System.Double.NaN" /&gt;</ph><ept id="p1">&lt;/description&gt;</ept><ph id="ph3">&lt;/item&gt;</ph><bpt id="p2">&lt;item&gt;</bpt><bpt id="p3">&lt;term&gt;</bpt> Igual a <ph id="ph4">&lt;see cref="F:System.Double.NaN" /&gt;</ph><ept id="p3">&lt;/term&gt;</ept><bpt id="p4">&lt;description&gt;</bpt><ph id="ph5">&lt;see cref="F:System.Double.NaN" /&gt;</ph><ept id="p4">&lt;/description&gt;</ept><ept id="p2">&lt;/item&gt;</ept><bpt id="p5">&lt;item&gt;</bpt><bpt id="p6">&lt;term&gt;</bpt> Igual a <ph id="ph6">&lt;see cref="F:System.Double.PositiveInfinity" /&gt;</ph><ept id="p6">&lt;/term&gt;</ept><bpt id="p7">&lt;description&gt;</bpt><ph id="ph7">&lt;see cref="F:System.Double.PositiveInfinity" /&gt;</ph><ept id="p7">&lt;/description&gt;</ept><ept id="p5">&lt;/item&gt;</ept><ph id="ph8">&lt;/list&gt;</ph></target>       </trans-unit>
        <trans-unit id="316" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Math.Log(System.Double)">
          <source>Parameter <ph id="ph1">`d`</ph> is specified as a base 10 number.</source>
          <target state="translated">Parámetro <ph id="ph1">`d`</ph> se especifica como un número en base 10.</target>       </trans-unit>
        <trans-unit id="317" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Math.Log(System.Double)">
          <source>The following example illustrates the <ph id="ph1">&lt;xref:System.Math.Log%2A&gt;</ph> method.</source>
          <target state="translated">En el ejemplo siguiente se muestra el <ph id="ph1">&lt;xref:System.Math.Log%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="318" translate="yes" xml:space="preserve" uid="M:System.Math.Log(System.Double,System.Double)">
          <source>The number whose logarithm is to be found.</source>
          <target state="translated">Número cuyo logaritmo se va a calcular.</target>       </trans-unit>
        <trans-unit id="319" translate="yes" xml:space="preserve" uid="M:System.Math.Log(System.Double,System.Double)">
          <source>The base of the logarithm.</source>
          <target state="translated">Base del logaritmo.</target>       </trans-unit>
        <trans-unit id="320" translate="yes" xml:space="preserve" uid="M:System.Math.Log(System.Double,System.Double)">
          <source>Returns the logarithm of a specified number in a specified base.</source>
          <target state="translated">Devuelve el logaritmo de un número especificado en una base determinada.</target>       </trans-unit>
        <trans-unit id="321" translate="yes" xml:space="preserve" uid="M:System.Math.Log(System.Double,System.Double)">
          <source>One of the values in the following table.</source>
          <target state="translated">Uno de los valores de la tabla siguiente.</target>       </trans-unit>
        <trans-unit id="322" translate="yes" xml:space="preserve" uid="M:System.Math.Log(System.Double,System.Double)">
          <source>(+Infinity denotes <ph id="ph1">&lt;see cref="F:System.Double.PositiveInfinity" /&gt;</ph>, -Infinity denotes <ph id="ph2">&lt;see cref="F:System.Double.NegativeInfinity" /&gt;</ph>, and NaN denotes <ph id="ph3">&lt;see cref="F:System.Double.NaN" /&gt;</ph>.)</source>
          <target state="translated">(+Infinito denota <ph id="ph1">&lt;see cref="F:System.Double.PositiveInfinity" /&gt;</ph>, -Infinito denota <ph id="ph2">&lt;see cref="F:System.Double.NegativeInfinity" /&gt;</ph> y NaN denota <ph id="ph3">&lt;see cref="F:System.Double.NaN" /&gt;</ph>)</target>       </trans-unit>
        <trans-unit id="323" translate="yes" xml:space="preserve" uid="M:System.Math.Log(System.Double,System.Double)">
          <source><ph id="ph1">&lt;list type="table"&gt;</ph><ph id="ph2">&lt;listheader&gt;</ph><bpt id="p1">&lt;term&gt;</bpt><ph id="ph3">&lt;paramref name="a" /&gt;</ph><ept id="p1">&lt;/term&gt;</ept><bpt id="p2">&lt;description&gt;</bpt><ph id="ph4">&lt;paramref name="newBase" /&gt;</ph><ept id="p2">&lt;/description&gt;</ept><ph id="ph5">&lt;description&gt;</ph> Return value</source>
          <target state="translated"><ph id="ph1">&lt;list type="table"&gt;</ph><ph id="ph2">&lt;listheader&gt;</ph><bpt id="p1">&lt;term&gt;</bpt><ph id="ph3">&lt;paramref name="a" /&gt;</ph><ept id="p1">&lt;/term&gt;</ept><bpt id="p2">&lt;description&gt;</bpt><ph id="ph4">&lt;paramref name="newBase" /&gt;</ph><ept id="p2">&lt;/description&gt;</ept><ph id="ph5">&lt;description&gt;</ph> Valor devuelto</target>       </trans-unit>
        <trans-unit id="324" translate="yes" xml:space="preserve" uid="M:System.Math.Log(System.Double,System.Double)">
          <source><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/listheader&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph><ph id="ph5">&lt;paramref name="a" /&gt;</ph><ph id="ph6">&amp;gt;</ph> 0</source>
          <target state="translated"><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/listheader&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph><ph id="ph5">&lt;paramref name="a" /&gt;</ph><ph id="ph6">&amp;gt;</ph> 0</target>       </trans-unit>
        <trans-unit id="325" translate="yes" xml:space="preserve" uid="M:System.Math.Log(System.Double,System.Double)">
          <source><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph> (0 <ph id="ph3">&amp;lt;</ph><ph id="ph4">&lt;paramref name="newBase" /&gt;</ph><ph id="ph5">&amp;lt;</ph> 1) -or-(<ph id="ph6">&lt;paramref name="newBase" /&gt;</ph><ph id="ph7">&amp;gt;</ph> 1)</source>
          <target state="translated"><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph> (0 <ph id="ph3">&amp;lt;</ph><ph id="ph4">&lt;paramref name="newBase" /&gt;</ph><ph id="ph5">&amp;lt;</ph> 1) -o bien-(<ph id="ph6">&lt;paramref name="newBase" /&gt;</ph><ph id="ph7">&amp;gt;</ph> 1)</target>       </trans-unit>
        <trans-unit id="326" translate="yes" xml:space="preserve" uid="M:System.Math.Log(System.Double,System.Double)">
          <source><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;description&gt;</ph> lognewBase(a)</source>
          <target state="translated"><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;description&gt;</ph> lognewBase(a)</target>       </trans-unit>
        <trans-unit id="327" translate="yes" xml:space="preserve" uid="M:System.Math.Log(System.Double,System.Double)">
          <source><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/item&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph><ph id="ph5">&lt;paramref name="a" /&gt;</ph><ph id="ph6">&amp;lt;</ph> 0</source>
          <target state="translated"><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/item&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph><ph id="ph5">&lt;paramref name="a" /&gt;</ph><ph id="ph6">&amp;lt;</ph> 0</target>       </trans-unit>
        <trans-unit id="328" translate="yes" xml:space="preserve" uid="M:System.Math.Log(System.Double,System.Double)">
          <source><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph> (any value)</source>
          <target state="translated"><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph> (cualquier valor)</target>       </trans-unit>
        <trans-unit id="329" translate="yes" xml:space="preserve" uid="M:System.Math.Log(System.Double,System.Double)">
          <source><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;description&gt;</ph> NaN</source>
          <target state="translated"><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;description&gt;</ph> NaN</target>       </trans-unit>
        <trans-unit id="330" translate="yes" xml:space="preserve" uid="M:System.Math.Log(System.Double,System.Double)">
          <source><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/item&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> (any value)</source>
          <target state="translated"><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/item&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> (cualquier valor)</target>       </trans-unit>
        <trans-unit id="331" translate="yes" xml:space="preserve" uid="M:System.Math.Log(System.Double,System.Double)">
          <source><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph><ph id="ph3">&lt;paramref name="newBase" /&gt;</ph><ph id="ph4">&amp;lt;</ph> 0</source>
          <target state="translated"><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph><ph id="ph3">&lt;paramref name="newBase" /&gt;</ph><ph id="ph4">&amp;lt;</ph> 0</target>       </trans-unit>
        <trans-unit id="332" translate="yes" xml:space="preserve" uid="M:System.Math.Log(System.Double,System.Double)">
          <source><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;description&gt;</ph> NaN</source>
          <target state="translated"><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;description&gt;</ph> NaN</target>       </trans-unit>
        <trans-unit id="333" translate="yes" xml:space="preserve" uid="M:System.Math.Log(System.Double,System.Double)">
          <source><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/item&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph><ph id="ph5">&lt;paramref name="a" /&gt;</ph> != 1</source>
          <target state="translated"><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/item&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph><ph id="ph5">&lt;paramref name="a" /&gt;</ph> != 1</target>       </trans-unit>
        <trans-unit id="334" translate="yes" xml:space="preserve" uid="M:System.Math.Log(System.Double,System.Double)">
          <source><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph><ph id="ph3">&lt;paramref name="newBase" /&gt;</ph> = 0</source>
          <target state="translated"><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph><ph id="ph3">&lt;paramref name="newBase" /&gt;</ph> = 0</target>       </trans-unit>
        <trans-unit id="335" translate="yes" xml:space="preserve" uid="M:System.Math.Log(System.Double,System.Double)">
          <source><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;description&gt;</ph> NaN</source>
          <target state="translated"><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;description&gt;</ph> NaN</target>       </trans-unit>
        <trans-unit id="336" translate="yes" xml:space="preserve" uid="M:System.Math.Log(System.Double,System.Double)">
          <source><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/item&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph><ph id="ph5">&lt;paramref name="a" /&gt;</ph> != 1</source>
          <target state="translated"><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/item&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph><ph id="ph5">&lt;paramref name="a" /&gt;</ph> != 1</target>       </trans-unit>
        <trans-unit id="337" translate="yes" xml:space="preserve" uid="M:System.Math.Log(System.Double,System.Double)">
          <source><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph><ph id="ph3">&lt;paramref name="newBase" /&gt;</ph> = +Infinity</source>
          <target state="translated"><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph><ph id="ph3">&lt;paramref name="newBase" /&gt;</ph> = +Infinito</target>       </trans-unit>
        <trans-unit id="338" translate="yes" xml:space="preserve" uid="M:System.Math.Log(System.Double,System.Double)">
          <source><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;description&gt;</ph> NaN</source>
          <target state="translated"><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;description&gt;</ph> NaN</target>       </trans-unit>
        <trans-unit id="339" translate="yes" xml:space="preserve" uid="M:System.Math.Log(System.Double,System.Double)">
          <source><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/item&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph><ph id="ph5">&lt;paramref name="a" /&gt;</ph> = NaN</source>
          <target state="translated"><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/item&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph><ph id="ph5">&lt;paramref name="a" /&gt;</ph> = NaN</target>       </trans-unit>
        <trans-unit id="340" translate="yes" xml:space="preserve" uid="M:System.Math.Log(System.Double,System.Double)">
          <source><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph> (any value)</source>
          <target state="translated"><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph> (cualquier valor)</target>       </trans-unit>
        <trans-unit id="341" translate="yes" xml:space="preserve" uid="M:System.Math.Log(System.Double,System.Double)">
          <source><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;description&gt;</ph> NaN</source>
          <target state="translated"><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;description&gt;</ph> NaN</target>       </trans-unit>
        <trans-unit id="342" translate="yes" xml:space="preserve" uid="M:System.Math.Log(System.Double,System.Double)">
          <source><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/item&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> (any value)</source>
          <target state="translated"><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/item&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> (cualquier valor)</target>       </trans-unit>
        <trans-unit id="343" translate="yes" xml:space="preserve" uid="M:System.Math.Log(System.Double,System.Double)">
          <source><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph><ph id="ph3">&lt;paramref name="newBase" /&gt;</ph> = NaN</source>
          <target state="translated"><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph><ph id="ph3">&lt;paramref name="newBase" /&gt;</ph> = NaN</target>       </trans-unit>
        <trans-unit id="344" translate="yes" xml:space="preserve" uid="M:System.Math.Log(System.Double,System.Double)">
          <source><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;description&gt;</ph> NaN</source>
          <target state="translated"><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;description&gt;</ph> NaN</target>       </trans-unit>
        <trans-unit id="345" translate="yes" xml:space="preserve" uid="M:System.Math.Log(System.Double,System.Double)">
          <source><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/item&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> (any value)</source>
          <target state="translated"><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/item&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> (cualquier valor)</target>       </trans-unit>
        <trans-unit id="346" translate="yes" xml:space="preserve" uid="M:System.Math.Log(System.Double,System.Double)">
          <source><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph><ph id="ph3">&lt;paramref name="newBase" /&gt;</ph> = 1</source>
          <target state="translated"><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph><ph id="ph3">&lt;paramref name="newBase" /&gt;</ph> = 1</target>       </trans-unit>
        <trans-unit id="347" translate="yes" xml:space="preserve" uid="M:System.Math.Log(System.Double,System.Double)">
          <source><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;description&gt;</ph> NaN</source>
          <target state="translated"><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;description&gt;</ph> NaN</target>       </trans-unit>
        <trans-unit id="348" translate="yes" xml:space="preserve" uid="M:System.Math.Log(System.Double,System.Double)">
          <source><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/item&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph><ph id="ph5">&lt;paramref name="a" /&gt;</ph> = 0</source>
          <target state="translated"><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/item&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph><ph id="ph5">&lt;paramref name="a" /&gt;</ph> = 0</target>       </trans-unit>
        <trans-unit id="349" translate="yes" xml:space="preserve" uid="M:System.Math.Log(System.Double,System.Double)">
          <source><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph> 0 <ph id="ph3">&amp;lt;</ph><ph id="ph4">&lt;paramref name="newBase" /&gt;</ph><ph id="ph5">&amp;lt;</ph> 1</source>
          <target state="translated"><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph> 0 <ph id="ph3">&amp;lt;</ph><ph id="ph4">&lt;paramref name="newBase" /&gt;</ph><ph id="ph5">&amp;lt;</ph> 1</target>       </trans-unit>
        <trans-unit id="350" translate="yes" xml:space="preserve" uid="M:System.Math.Log(System.Double,System.Double)">
          <source><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;description&gt;</ph> +Infinity</source>
          <target state="translated"><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;description&gt;</ph> +Infinito</target>       </trans-unit>
        <trans-unit id="351" translate="yes" xml:space="preserve" uid="M:System.Math.Log(System.Double,System.Double)">
          <source><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/item&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph><ph id="ph5">&lt;paramref name="a" /&gt;</ph> = 0</source>
          <target state="translated"><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/item&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph><ph id="ph5">&lt;paramref name="a" /&gt;</ph> = 0</target>       </trans-unit>
        <trans-unit id="352" translate="yes" xml:space="preserve" uid="M:System.Math.Log(System.Double,System.Double)">
          <source><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph><ph id="ph3">&lt;paramref name="newBase" /&gt;</ph><ph id="ph4">&amp;gt;</ph> 1</source>
          <target state="translated"><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph><ph id="ph3">&lt;paramref name="newBase" /&gt;</ph><ph id="ph4">&amp;gt;</ph> 1</target>       </trans-unit>
        <trans-unit id="353" translate="yes" xml:space="preserve" uid="M:System.Math.Log(System.Double,System.Double)">
          <source><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;description&gt;</ph> -Infinity</source>
          <target state="translated"><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;description&gt;</ph> -Infinito</target>       </trans-unit>
        <trans-unit id="354" translate="yes" xml:space="preserve" uid="M:System.Math.Log(System.Double,System.Double)">
          <source><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/item&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph><ph id="ph5">&lt;paramref name="a" /&gt;</ph> =  +Infinity</source>
          <target state="translated"><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/item&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph><ph id="ph5">&lt;paramref name="a" /&gt;</ph> = +Infinito</target>       </trans-unit>
        <trans-unit id="355" translate="yes" xml:space="preserve" uid="M:System.Math.Log(System.Double,System.Double)">
          <source><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph> 0 <ph id="ph3">&amp;lt;</ph><ph id="ph4">&lt;paramref name="newBase" /&gt;</ph><ph id="ph5">&amp;lt;</ph> 1</source>
          <target state="translated"><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph> 0 <ph id="ph3">&amp;lt;</ph><ph id="ph4">&lt;paramref name="newBase" /&gt;</ph><ph id="ph5">&amp;lt;</ph> 1</target>       </trans-unit>
        <trans-unit id="356" translate="yes" xml:space="preserve" uid="M:System.Math.Log(System.Double,System.Double)">
          <source><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;description&gt;</ph> -Infinity</source>
          <target state="translated"><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;description&gt;</ph> -Infinito</target>       </trans-unit>
        <trans-unit id="357" translate="yes" xml:space="preserve" uid="M:System.Math.Log(System.Double,System.Double)">
          <source><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/item&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph><ph id="ph5">&lt;paramref name="a" /&gt;</ph> =  +Infinity</source>
          <target state="translated"><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/item&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph><ph id="ph5">&lt;paramref name="a" /&gt;</ph> = +Infinito</target>       </trans-unit>
        <trans-unit id="358" translate="yes" xml:space="preserve" uid="M:System.Math.Log(System.Double,System.Double)">
          <source><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph><ph id="ph3">&lt;paramref name="newBase" /&gt;</ph><ph id="ph4">&amp;gt;</ph> 1</source>
          <target state="translated"><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph><ph id="ph3">&lt;paramref name="newBase" /&gt;</ph><ph id="ph4">&amp;gt;</ph> 1</target>       </trans-unit>
        <trans-unit id="359" translate="yes" xml:space="preserve" uid="M:System.Math.Log(System.Double,System.Double)">
          <source><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;description&gt;</ph> +Infinity</source>
          <target state="translated"><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;description&gt;</ph> +Infinito</target>       </trans-unit>
        <trans-unit id="360" translate="yes" xml:space="preserve" uid="M:System.Math.Log(System.Double,System.Double)">
          <source><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/item&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph><ph id="ph5">&lt;paramref name="a" /&gt;</ph> = 1</source>
          <target state="translated"><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/item&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph><ph id="ph5">&lt;paramref name="a" /&gt;</ph> = 1</target>       </trans-unit>
        <trans-unit id="361" translate="yes" xml:space="preserve" uid="M:System.Math.Log(System.Double,System.Double)">
          <source><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph><ph id="ph3">&lt;paramref name="newBase" /&gt;</ph> = 0</source>
          <target state="translated"><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph><ph id="ph3">&lt;paramref name="newBase" /&gt;</ph> = 0</target>       </trans-unit>
        <trans-unit id="362" translate="yes" xml:space="preserve" uid="M:System.Math.Log(System.Double,System.Double)">
          <source><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;description&gt;</ph> 0</source>
          <target state="translated"><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;description&gt;</ph> 0</target>       </trans-unit>
        <trans-unit id="363" translate="yes" xml:space="preserve" uid="M:System.Math.Log(System.Double,System.Double)">
          <source><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/item&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph><ph id="ph5">&lt;paramref name="a" /&gt;</ph> = 1</source>
          <target state="translated"><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/item&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph><ph id="ph5">&lt;paramref name="a" /&gt;</ph> = 1</target>       </trans-unit>
        <trans-unit id="364" translate="yes" xml:space="preserve" uid="M:System.Math.Log(System.Double,System.Double)">
          <source><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph><ph id="ph3">&lt;paramref name="newBase" /&gt;</ph> = +Infinity</source>
          <target state="translated"><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph><ph id="ph3">&lt;paramref name="newBase" /&gt;</ph> = +Infinito</target>       </trans-unit>
        <trans-unit id="365" translate="yes" xml:space="preserve" uid="M:System.Math.Log(System.Double,System.Double)">
          <source><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;description&gt;</ph> 0</source>
          <target state="translated"><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;description&gt;</ph> 0</target>       </trans-unit>
        <trans-unit id="366" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Math.Log(System.Double,System.Double)">
          <source>The following example uses <ph id="ph1">&lt;xref:System.Math.Log%2A&gt;</ph> to evaluate certain logarithmic identities for selected values.</source>
          <target state="translated">En el ejemplo siguiente se utiliza <ph id="ph1">&lt;xref:System.Math.Log%2A&gt;</ph> para evaluar determinadas identidades logarítmicas de valores seleccionados.</target>       </trans-unit>
        <trans-unit id="367" translate="yes" xml:space="preserve" uid="M:System.Math.Log10(System.Double)">
          <source>A number whose logarithm is to be found.</source>
          <target state="translated">Número cuyo logaritmo hay que calcular.</target>       </trans-unit>
        <trans-unit id="368" translate="yes" xml:space="preserve" uid="M:System.Math.Log10(System.Double)">
          <source>Returns the base 10 logarithm of a specified number.</source>
          <target state="translated">Devuelve el logaritmo en base 10 de un número especificado.</target>       </trans-unit>
        <trans-unit id="369" translate="yes" xml:space="preserve" uid="M:System.Math.Log10(System.Double)">
          <source>One of the values in the following table.</source>
          <target state="translated">Uno de los valores de la tabla siguiente.</target>       </trans-unit>
        <trans-unit id="370" translate="yes" xml:space="preserve" uid="M:System.Math.Log10(System.Double)">
          <source><ph id="ph1">&lt;list type="table"&gt;</ph><ph id="ph2">&lt;listheader&gt;</ph><ph id="ph3">&lt;term&gt;</ph><ph id="ph4">&lt;paramref name="d" /&gt;</ph> parameter</source>
          <target state="translated"><ph id="ph1">&lt;list type="table"&gt;</ph><ph id="ph2">&lt;listheader&gt;</ph><ph id="ph3">&lt;term&gt;</ph>Parámetro <ph id="ph4">&lt;paramref name="d" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="371" translate="yes" xml:space="preserve" uid="M:System.Math.Log10(System.Double)">
          <source><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph> Return value</source>
          <target state="translated"><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph> Valor devuelto</target>       </trans-unit>
        <trans-unit id="372" translate="yes" xml:space="preserve" uid="M:System.Math.Log10(System.Double)">
          <source><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/listheader&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> Positive</source>
          <target state="translated"><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/listheader&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> Positivo</target>       </trans-unit>
        <trans-unit id="373" translate="yes" xml:space="preserve" uid="M:System.Math.Log10(System.Double)">
          <source><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph> The base 10 log of <ph id="ph3">&lt;paramref name="d" /&gt;</ph>; that is, log 10<ph id="ph4">&lt;paramref name="d" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph> Logaritmo en base 10 de <ph id="ph3">&lt;paramref name="d" /&gt;</ph>; es decir, log 10<ph id="ph4">&lt;paramref name="d" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="374" translate="yes" xml:space="preserve" uid="M:System.Math.Log10(System.Double)">
          <source><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/item&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> Zero</source>
          <target state="translated"><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/item&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> Cero</target>       </trans-unit>
        <trans-unit id="375" translate="yes" xml:space="preserve" uid="M:System.Math.Log10(System.Double)">
          <source><ph id="ph1">&lt;/term&gt;</ph><bpt id="p1">&lt;description&gt;</bpt><ph id="ph2">&lt;see cref="F:System.Double.NegativeInfinity" /&gt;</ph><ept id="p1">&lt;/description&gt;</ept><ph id="ph3">&lt;/item&gt;</ph><ph id="ph4">&lt;item&gt;</ph><ph id="ph5">&lt;term&gt;</ph> Negative</source>
          <target state="translated"><ph id="ph1">&lt;/term&gt;</ph><bpt id="p1">&lt;description&gt;</bpt><ph id="ph2">&lt;see cref="F:System.Double.NegativeInfinity" /&gt;</ph><ept id="p1">&lt;/description&gt;</ept><ph id="ph3">&lt;/item&gt;</ph><ph id="ph4">&lt;item&gt;</ph><ph id="ph5">&lt;term&gt;</ph> Negativo</target>       </trans-unit>
        <trans-unit id="376" translate="yes" xml:space="preserve" uid="M:System.Math.Log10(System.Double)">
          <source><ph id="ph1">&lt;/term&gt;</ph><bpt id="p1">&lt;description&gt;</bpt><ph id="ph2">&lt;see cref="F:System.Double.NaN" /&gt;</ph><ept id="p1">&lt;/description&gt;</ept><ph id="ph3">&lt;/item&gt;</ph><bpt id="p2">&lt;item&gt;</bpt><bpt id="p3">&lt;term&gt;</bpt> Equal to <ph id="ph4">&lt;see cref="F:System.Double.NaN" /&gt;</ph><ept id="p3">&lt;/term&gt;</ept><bpt id="p4">&lt;description&gt;</bpt><ph id="ph5">&lt;see cref="F:System.Double.NaN" /&gt;</ph><ept id="p4">&lt;/description&gt;</ept><ept id="p2">&lt;/item&gt;</ept><bpt id="p5">&lt;item&gt;</bpt><bpt id="p6">&lt;term&gt;</bpt> Equal to <ph id="ph6">&lt;see cref="F:System.Double.PositiveInfinity" /&gt;</ph><ept id="p6">&lt;/term&gt;</ept><bpt id="p7">&lt;description&gt;</bpt><ph id="ph7">&lt;see cref="F:System.Double.PositiveInfinity" /&gt;</ph><ept id="p7">&lt;/description&gt;</ept><ept id="p5">&lt;/item&gt;</ept><ph id="ph8">&lt;/list&gt;</ph></source>
          <target state="translated"><ph id="ph1">&lt;/term&gt;</ph><bpt id="p1">&lt;description&gt;</bpt><ph id="ph2">&lt;see cref="F:System.Double.NaN" /&gt;</ph><ept id="p1">&lt;/description&gt;</ept><ph id="ph3">&lt;/item&gt;</ph><bpt id="p2">&lt;item&gt;</bpt><bpt id="p3">&lt;term&gt;</bpt> Igual a <ph id="ph4">&lt;see cref="F:System.Double.NaN" /&gt;</ph><ept id="p3">&lt;/term&gt;</ept><bpt id="p4">&lt;description&gt;</bpt><ph id="ph5">&lt;see cref="F:System.Double.NaN" /&gt;</ph><ept id="p4">&lt;/description&gt;</ept><ept id="p2">&lt;/item&gt;</ept><bpt id="p5">&lt;item&gt;</bpt><bpt id="p6">&lt;term&gt;</bpt> Igual a <ph id="ph6">&lt;see cref="F:System.Double.PositiveInfinity" /&gt;</ph><ept id="p6">&lt;/term&gt;</ept><bpt id="p7">&lt;description&gt;</bpt><ph id="ph7">&lt;see cref="F:System.Double.PositiveInfinity" /&gt;</ph><ept id="p7">&lt;/description&gt;</ept><ept id="p5">&lt;/item&gt;</ept><ph id="ph8">&lt;/list&gt;</ph></target>       </trans-unit>
        <trans-unit id="377" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Math.Log10(System.Double)">
          <source>Parameter <ph id="ph1">`d`</ph> is specified as a base 10 number.</source>
          <target state="translated">Parámetro <ph id="ph1">`d`</ph> se especifica como un número en base 10.</target>       </trans-unit>
        <trans-unit id="378" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Math.Log10(System.Double)">
          <source>The following example uses the <ph id="ph1">&lt;xref:System.Math.Log10%2A&gt;</ph> method to return the base 10 logarithm for selected values.</source>
          <target state="translated">En el ejemplo siguiente se usa el <ph id="ph1">&lt;xref:System.Math.Log10%2A&gt;</ph> método para devolver el logaritmo en base 10 de los valores seleccionados.</target>       </trans-unit>
        <trans-unit id="379" translate="yes" xml:space="preserve" uid="T:System.Math">
          <source>Returns the larger of two specified numbers.</source>
          <target state="translated">Devuelve el mayor de dos números especificados.</target>       </trans-unit>
        <trans-unit id="380" translate="yes" xml:space="preserve" uid="M:System.Math.Max(System.Byte,System.Byte)">
          <source>The first of two 8-bit unsigned integers to compare.</source>
          <target state="translated">Primer entero de 8 bits sin signo de los dos que se van a comparar.</target>       </trans-unit>
        <trans-unit id="381" translate="yes" xml:space="preserve" uid="M:System.Math.Max(System.Byte,System.Byte)">
          <source>The second of two 8-bit unsigned integers to compare.</source>
          <target state="translated">Segundo entero de 8 bits sin signo de los dos que se van a comparar.</target>       </trans-unit>
        <trans-unit id="382" translate="yes" xml:space="preserve" uid="M:System.Math.Max(System.Byte,System.Byte)">
          <source>Returns the larger of two 8-bit unsigned integers.</source>
          <target state="translated">Devuelve el mayor de dos enteros de 8 bits sin signo.</target>       </trans-unit>
        <trans-unit id="383" translate="yes" xml:space="preserve" uid="M:System.Math.Max(System.Byte,System.Byte)">
          <source>Parameter <ph id="ph1">&lt;paramref name="val1" /&gt;</ph> or <ph id="ph2">&lt;paramref name="val2" /&gt;</ph>, whichever is larger.</source>
          <target state="translated">Parámetro <ph id="ph1">&lt;paramref name="val1" /&gt;</ph> o <ph id="ph2">&lt;paramref name="val2" /&gt;</ph>, el que sea mayor.</target>       </trans-unit>
        <trans-unit id="384" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Math.Max(System.Byte,System.Byte)">
          <source>The following example demonstrates how to use the <ph id="ph1">&lt;xref:System.Math.Max%2A&gt;</ph> method to return and display the greater of two variables.</source>
          <target state="translated">En el ejemplo siguiente se muestra cómo utilizar el <ph id="ph1">&lt;xref:System.Math.Max%2A&gt;</ph> método para devolver y mostrar la mayor de dos variables.</target>       </trans-unit>
        <trans-unit id="385" translate="yes" xml:space="preserve" uid="M:System.Math.Max(System.Decimal,System.Decimal)">
          <source>The first of two decimal numbers to compare.</source>
          <target state="translated">Primer número de dos números decimales que se van a comparar.</target>       </trans-unit>
        <trans-unit id="386" translate="yes" xml:space="preserve" uid="M:System.Math.Max(System.Decimal,System.Decimal)">
          <source>The second of two decimal numbers to compare.</source>
          <target state="translated">Segundo número de dos decimales que se van a comparar.</target>       </trans-unit>
        <trans-unit id="387" translate="yes" xml:space="preserve" uid="M:System.Math.Max(System.Decimal,System.Decimal)">
          <source>Returns the larger of two decimal numbers.</source>
          <target state="translated">Devuelve el mayor de dos números decimales.</target>       </trans-unit>
        <trans-unit id="388" translate="yes" xml:space="preserve" uid="M:System.Math.Max(System.Decimal,System.Decimal)">
          <source>Parameter <ph id="ph1">&lt;paramref name="val1" /&gt;</ph> or <ph id="ph2">&lt;paramref name="val2" /&gt;</ph>, whichever is larger.</source>
          <target state="translated">Parámetro <ph id="ph1">&lt;paramref name="val1" /&gt;</ph> o <ph id="ph2">&lt;paramref name="val2" /&gt;</ph>, el que sea mayor.</target>       </trans-unit>
        <trans-unit id="389" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Math.Max(System.Decimal,System.Decimal)">
          <source>The following example demonstrates how to use the <ph id="ph1">&lt;xref:System.Math.Max%2A&gt;</ph> method to return and display the greater of two variables.</source>
          <target state="translated">En el ejemplo siguiente se muestra cómo utilizar el <ph id="ph1">&lt;xref:System.Math.Max%2A&gt;</ph> método para devolver y mostrar la mayor de dos variables.</target>       </trans-unit>
        <trans-unit id="390" translate="yes" xml:space="preserve" uid="M:System.Math.Max(System.Double,System.Double)">
          <source>The first of two double-precision floating-point numbers to compare.</source>
          <target state="translated">Primer número de punto flotante de precisión doble de los dos que se van a comparar.</target>       </trans-unit>
        <trans-unit id="391" translate="yes" xml:space="preserve" uid="M:System.Math.Max(System.Double,System.Double)">
          <source>The second of two double-precision floating-point numbers to compare.</source>
          <target state="translated">Segundo número de punto flotante de precisión doble de los dos que se van a comparar.</target>       </trans-unit>
        <trans-unit id="392" translate="yes" xml:space="preserve" uid="M:System.Math.Max(System.Double,System.Double)">
          <source>Returns the larger of two double-precision floating-point numbers.</source>
          <target state="translated">Devuelve el mayor de dos números de punto flotante de precisión doble.</target>       </trans-unit>
        <trans-unit id="393" translate="yes" xml:space="preserve" uid="M:System.Math.Max(System.Double,System.Double)">
          <source>Parameter <ph id="ph1">&lt;paramref name="val1" /&gt;</ph> or <ph id="ph2">&lt;paramref name="val2" /&gt;</ph>, whichever is larger.</source>
          <target state="translated">Parámetro <ph id="ph1">&lt;paramref name="val1" /&gt;</ph> o <ph id="ph2">&lt;paramref name="val2" /&gt;</ph>, el que sea mayor.</target>       </trans-unit>
        <trans-unit id="394" translate="yes" xml:space="preserve" uid="M:System.Math.Max(System.Double,System.Double)">
          <source>If <ph id="ph1">&lt;paramref name="val1" /&gt;</ph>, <ph id="ph2">&lt;paramref name="val2" /&gt;</ph>, or both <ph id="ph3">&lt;paramref name="val1" /&gt;</ph> and <ph id="ph4">&lt;paramref name="val2" /&gt;</ph> are equal to <ph id="ph5">&lt;see cref="F:System.Double.NaN" /&gt;</ph>, <ph id="ph6">&lt;see cref="F:System.Double.NaN" /&gt;</ph> is returned.</source>
          <target state="translated">Si <ph id="ph1">&lt;paramref name="val1" /&gt;</ph>, <ph id="ph2">&lt;paramref name="val2" /&gt;</ph> o ambos ( <ph id="ph3">&lt;paramref name="val1" /&gt;</ph> y <ph id="ph4">&lt;paramref name="val2" /&gt;</ph>) son iguales que <ph id="ph5">&lt;see cref="F:System.Double.NaN" /&gt;</ph>, se devuelve <ph id="ph6">&lt;see cref="F:System.Double.NaN" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="395" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Math.Max(System.Double,System.Double)">
          <source>The following example demonstrates how to use the <ph id="ph1">&lt;xref:System.Math.Max%2A&gt;</ph> method to return and display the greater of two variables.</source>
          <target state="translated">En el ejemplo siguiente se muestra cómo utilizar el <ph id="ph1">&lt;xref:System.Math.Max%2A&gt;</ph> método para devolver y mostrar la mayor de dos variables.</target>       </trans-unit>
        <trans-unit id="396" translate="yes" xml:space="preserve" uid="M:System.Math.Max(System.Int16,System.Int16)">
          <source>The first of two 16-bit signed integers to compare.</source>
          <target state="translated">Primero de los dos enteros de 16 bits con signo que se van a comparar.</target>       </trans-unit>
        <trans-unit id="397" translate="yes" xml:space="preserve" uid="M:System.Math.Max(System.Int16,System.Int16)">
          <source>The second of two 16-bit signed integers to compare.</source>
          <target state="translated">Segundo de los dos enteros de 16 bits con signo que se van a comparar.</target>       </trans-unit>
        <trans-unit id="398" translate="yes" xml:space="preserve" uid="M:System.Math.Max(System.Int16,System.Int16)">
          <source>Returns the larger of two 16-bit signed integers.</source>
          <target state="translated">Devuelve el mayor de dos enteros de 16 bits con signo.</target>       </trans-unit>
        <trans-unit id="399" translate="yes" xml:space="preserve" uid="M:System.Math.Max(System.Int16,System.Int16)">
          <source>Parameter <ph id="ph1">&lt;paramref name="val1" /&gt;</ph> or <ph id="ph2">&lt;paramref name="val2" /&gt;</ph>, whichever is larger.</source>
          <target state="translated">Parámetro <ph id="ph1">&lt;paramref name="val1" /&gt;</ph> o <ph id="ph2">&lt;paramref name="val2" /&gt;</ph>, el que sea mayor.</target>       </trans-unit>
        <trans-unit id="400" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Math.Max(System.Int16,System.Int16)">
          <source>The following example demonstrates how to use the <ph id="ph1">&lt;xref:System.Math.Max%2A&gt;</ph> method to return and display the greater of two variables.</source>
          <target state="translated">En el ejemplo siguiente se muestra cómo utilizar el <ph id="ph1">&lt;xref:System.Math.Max%2A&gt;</ph> método para devolver y mostrar la mayor de dos variables.</target>       </trans-unit>
        <trans-unit id="401" translate="yes" xml:space="preserve" uid="M:System.Math.Max(System.Int32,System.Int32)">
          <source>The first of two 32-bit signed integers to compare.</source>
          <target state="translated">Primero de los dos enteros de 32 bits con signo que se van a comparar.</target>       </trans-unit>
        <trans-unit id="402" translate="yes" xml:space="preserve" uid="M:System.Math.Max(System.Int32,System.Int32)">
          <source>The second of two 32-bit signed integers to compare.</source>
          <target state="translated">Segundo de los dos enteros de 32 bits con signo que se van a comparar.</target>       </trans-unit>
        <trans-unit id="403" translate="yes" xml:space="preserve" uid="M:System.Math.Max(System.Int32,System.Int32)">
          <source>Returns the larger of two 32-bit signed integers.</source>
          <target state="translated">Devuelve el mayor de dos enteros de 32 bits con signo.</target>       </trans-unit>
        <trans-unit id="404" translate="yes" xml:space="preserve" uid="M:System.Math.Max(System.Int32,System.Int32)">
          <source>Parameter <ph id="ph1">&lt;paramref name="val1" /&gt;</ph> or <ph id="ph2">&lt;paramref name="val2" /&gt;</ph>, whichever is larger.</source>
          <target state="translated">Parámetro <ph id="ph1">&lt;paramref name="val1" /&gt;</ph> o <ph id="ph2">&lt;paramref name="val2" /&gt;</ph>, el que sea mayor.</target>       </trans-unit>
        <trans-unit id="405" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Math.Max(System.Int32,System.Int32)">
          <source>The following example demonstrates how to use the <ph id="ph1">&lt;xref:System.Math.Max%2A&gt;</ph> method to return and display the greater of two variables.</source>
          <target state="translated">En el ejemplo siguiente se muestra cómo utilizar el <ph id="ph1">&lt;xref:System.Math.Max%2A&gt;</ph> método para devolver y mostrar la mayor de dos variables.</target>       </trans-unit>
        <trans-unit id="406" translate="yes" xml:space="preserve" uid="M:System.Math.Max(System.Int64,System.Int64)">
          <source>The first of two 64-bit signed integers to compare.</source>
          <target state="translated">Primero de los dos enteros de 64 bits con signo que se van a comparar.</target>       </trans-unit>
        <trans-unit id="407" translate="yes" xml:space="preserve" uid="M:System.Math.Max(System.Int64,System.Int64)">
          <source>The second of two 64-bit signed integers to compare.</source>
          <target state="translated">Segundo de los dos enteros de 64 bits con signo que se van a comparar.</target>       </trans-unit>
        <trans-unit id="408" translate="yes" xml:space="preserve" uid="M:System.Math.Max(System.Int64,System.Int64)">
          <source>Returns the larger of two 64-bit signed integers.</source>
          <target state="translated">Devuelve el mayor de dos enteros de 64 bits con signo.</target>       </trans-unit>
        <trans-unit id="409" translate="yes" xml:space="preserve" uid="M:System.Math.Max(System.Int64,System.Int64)">
          <source>Parameter <ph id="ph1">&lt;paramref name="val1" /&gt;</ph> or <ph id="ph2">&lt;paramref name="val2" /&gt;</ph>, whichever is larger.</source>
          <target state="translated">Parámetro <ph id="ph1">&lt;paramref name="val1" /&gt;</ph> o <ph id="ph2">&lt;paramref name="val2" /&gt;</ph>, el que sea mayor.</target>       </trans-unit>
        <trans-unit id="410" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Math.Max(System.Int64,System.Int64)">
          <source>The following example demonstrates how to use the <ph id="ph1">&lt;xref:System.Math.Max%2A&gt;</ph> method to return and display the greater of two variables.</source>
          <target state="translated">En el ejemplo siguiente se muestra cómo utilizar el <ph id="ph1">&lt;xref:System.Math.Max%2A&gt;</ph> método para devolver y mostrar la mayor de dos variables.</target>       </trans-unit>
        <trans-unit id="411" translate="yes" xml:space="preserve" uid="M:System.Math.Max(System.SByte,System.SByte)">
          <source>The first of two 8-bit signed integers to compare.</source>
          <target state="translated">Primero de los dos enteros de 8 bits con signo que se van a comparar.</target>       </trans-unit>
        <trans-unit id="412" translate="yes" xml:space="preserve" uid="M:System.Math.Max(System.SByte,System.SByte)">
          <source>The second of two 8-bit signed integers to compare.</source>
          <target state="translated">Segundo de los dos enteros de 8 bits con signo que se van a comparar.</target>       </trans-unit>
        <trans-unit id="413" translate="yes" xml:space="preserve" uid="M:System.Math.Max(System.SByte,System.SByte)">
          <source>Returns the larger of two 8-bit signed integers.</source>
          <target state="translated">Devuelve el mayor de dos enteros de 8 bits con signo.</target>       </trans-unit>
        <trans-unit id="414" translate="yes" xml:space="preserve" uid="M:System.Math.Max(System.SByte,System.SByte)">
          <source>Parameter <ph id="ph1">&lt;paramref name="val1" /&gt;</ph> or <ph id="ph2">&lt;paramref name="val2" /&gt;</ph>, whichever is larger.</source>
          <target state="translated">Parámetro <ph id="ph1">&lt;paramref name="val1" /&gt;</ph> o <ph id="ph2">&lt;paramref name="val2" /&gt;</ph>, el que sea mayor.</target>       </trans-unit>
        <trans-unit id="415" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Math.Max(System.SByte,System.SByte)">
          <source>The following example demonstrates how to use the <ph id="ph1">&lt;xref:System.Math.Max%2A&gt;</ph> method to return and display the greater of two variables.</source>
          <target state="translated">En el ejemplo siguiente se muestra cómo utilizar el <ph id="ph1">&lt;xref:System.Math.Max%2A&gt;</ph> método para devolver y mostrar la mayor de dos variables.</target>       </trans-unit>
        <trans-unit id="416" translate="yes" xml:space="preserve" uid="M:System.Math.Max(System.Single,System.Single)">
          <source>The first of two single-precision floating-point numbers to compare.</source>
          <target state="translated">Primer número de punto flotante de precisión sencilla de los dos que se van a comparar.</target>       </trans-unit>
        <trans-unit id="417" translate="yes" xml:space="preserve" uid="M:System.Math.Max(System.Single,System.Single)">
          <source>The second of two single-precision floating-point numbers to compare.</source>
          <target state="translated">Segundo número de punto flotante de precisión sencilla de los dos que se van a comparar.</target>       </trans-unit>
        <trans-unit id="418" translate="yes" xml:space="preserve" uid="M:System.Math.Max(System.Single,System.Single)">
          <source>Returns the larger of two single-precision floating-point numbers.</source>
          <target state="translated">Devuelve el mayor de dos números de punto flotante de precisión sencilla.</target>       </trans-unit>
        <trans-unit id="419" translate="yes" xml:space="preserve" uid="M:System.Math.Max(System.Single,System.Single)">
          <source>Parameter <ph id="ph1">&lt;paramref name="val1" /&gt;</ph> or <ph id="ph2">&lt;paramref name="val2" /&gt;</ph>, whichever is larger.</source>
          <target state="translated">Parámetro <ph id="ph1">&lt;paramref name="val1" /&gt;</ph> o <ph id="ph2">&lt;paramref name="val2" /&gt;</ph>, el que sea mayor.</target>       </trans-unit>
        <trans-unit id="420" translate="yes" xml:space="preserve" uid="M:System.Math.Max(System.Single,System.Single)">
          <source>If <ph id="ph1">&lt;paramref name="val1" /&gt;</ph>, or <ph id="ph2">&lt;paramref name="val2" /&gt;</ph>, or both <ph id="ph3">&lt;paramref name="val1" /&gt;</ph> and <ph id="ph4">&lt;paramref name="val2" /&gt;</ph> are equal to <ph id="ph5">&lt;see cref="F:System.Single.NaN" /&gt;</ph>, <ph id="ph6">&lt;see cref="F:System.Single.NaN" /&gt;</ph> is returned.</source>
          <target state="translated">Si <ph id="ph1">&lt;paramref name="val1" /&gt;</ph> o <ph id="ph2">&lt;paramref name="val2" /&gt;</ph>, o ambos (<ph id="ph3">&lt;paramref name="val1" /&gt;</ph> y <ph id="ph4">&lt;paramref name="val2" /&gt;</ph>) son iguales a <ph id="ph5">&lt;see cref="F:System.Single.NaN" /&gt;</ph>, <ph id="ph6">&lt;see cref="F:System.Single.NaN" /&gt;</ph> se devuelve.</target>       </trans-unit>
        <trans-unit id="421" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Math.Max(System.Single,System.Single)">
          <source>The following example demonstrates how to use the <ph id="ph1">&lt;xref:System.Math.Max%2A&gt;</ph> method to return and display the greater of two variables.</source>
          <target state="translated">En el ejemplo siguiente se muestra cómo utilizar el <ph id="ph1">&lt;xref:System.Math.Max%2A&gt;</ph> método para devolver y mostrar la mayor de dos variables.</target>       </trans-unit>
        <trans-unit id="422" translate="yes" xml:space="preserve" uid="M:System.Math.Max(System.UInt16,System.UInt16)">
          <source>The first of two 16-bit unsigned integers to compare.</source>
          <target state="translated">Primer entero de 16 bits sin signo de los dos que se van a comparar.</target>       </trans-unit>
        <trans-unit id="423" translate="yes" xml:space="preserve" uid="M:System.Math.Max(System.UInt16,System.UInt16)">
          <source>The second of two 16-bit unsigned integers to compare.</source>
          <target state="translated">Segundo entero de 16 bits sin signo de los dos que se van a comparar.</target>       </trans-unit>
        <trans-unit id="424" translate="yes" xml:space="preserve" uid="M:System.Math.Max(System.UInt16,System.UInt16)">
          <source>Returns the larger of two 16-bit unsigned integers.</source>
          <target state="translated">Devuelve el mayor de dos enteros de 16 bits sin signo.</target>       </trans-unit>
        <trans-unit id="425" translate="yes" xml:space="preserve" uid="M:System.Math.Max(System.UInt16,System.UInt16)">
          <source>Parameter <ph id="ph1">&lt;paramref name="val1" /&gt;</ph> or <ph id="ph2">&lt;paramref name="val2" /&gt;</ph>, whichever is larger.</source>
          <target state="translated">Parámetro <ph id="ph1">&lt;paramref name="val1" /&gt;</ph> o <ph id="ph2">&lt;paramref name="val2" /&gt;</ph>, el que sea mayor.</target>       </trans-unit>
        <trans-unit id="426" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Math.Max(System.UInt16,System.UInt16)">
          <source>The following example demonstrates how to use the <ph id="ph1">&lt;xref:System.Math.Max%2A&gt;</ph> method to return and display the greater of two variables.</source>
          <target state="translated">En el ejemplo siguiente se muestra cómo utilizar el <ph id="ph1">&lt;xref:System.Math.Max%2A&gt;</ph> método para devolver y mostrar la mayor de dos variables.</target>       </trans-unit>
        <trans-unit id="427" translate="yes" xml:space="preserve" uid="M:System.Math.Max(System.UInt32,System.UInt32)">
          <source>The first of two 32-bit unsigned integers to compare.</source>
          <target state="translated">Primer entero de 32 bits sin signo de los dos que se van a comparar.</target>       </trans-unit>
        <trans-unit id="428" translate="yes" xml:space="preserve" uid="M:System.Math.Max(System.UInt32,System.UInt32)">
          <source>The second of two 32-bit unsigned integers to compare.</source>
          <target state="translated">Segundo entero de 32 bits sin signo de los dos que se van a comparar.</target>       </trans-unit>
        <trans-unit id="429" translate="yes" xml:space="preserve" uid="M:System.Math.Max(System.UInt32,System.UInt32)">
          <source>Returns the larger of two 32-bit unsigned integers.</source>
          <target state="translated">Devuelve el mayor de dos enteros de 32 bits sin signo.</target>       </trans-unit>
        <trans-unit id="430" translate="yes" xml:space="preserve" uid="M:System.Math.Max(System.UInt32,System.UInt32)">
          <source>Parameter <ph id="ph1">&lt;paramref name="val1" /&gt;</ph> or <ph id="ph2">&lt;paramref name="val2" /&gt;</ph>, whichever is larger.</source>
          <target state="translated">Parámetro <ph id="ph1">&lt;paramref name="val1" /&gt;</ph> o <ph id="ph2">&lt;paramref name="val2" /&gt;</ph>, el que sea mayor.</target>       </trans-unit>
        <trans-unit id="431" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Math.Max(System.UInt32,System.UInt32)">
          <source>The following example demonstrates how to use the <ph id="ph1">&lt;xref:System.Math.Max%2A&gt;</ph> method to return and display the greater of two variables.</source>
          <target state="translated">En el ejemplo siguiente se muestra cómo utilizar el <ph id="ph1">&lt;xref:System.Math.Max%2A&gt;</ph> método para devolver y mostrar la mayor de dos variables.</target>       </trans-unit>
        <trans-unit id="432" translate="yes" xml:space="preserve" uid="M:System.Math.Max(System.UInt64,System.UInt64)">
          <source>The first of two 64-bit unsigned integers to compare.</source>
          <target state="translated">Primer entero de 64 bits sin signo de los dos que se van a comparar.</target>       </trans-unit>
        <trans-unit id="433" translate="yes" xml:space="preserve" uid="M:System.Math.Max(System.UInt64,System.UInt64)">
          <source>The second of two 64-bit unsigned integers to compare.</source>
          <target state="translated">Segundo entero de 64 bits sin signo de los dos que se van a comparar.</target>       </trans-unit>
        <trans-unit id="434" translate="yes" xml:space="preserve" uid="M:System.Math.Max(System.UInt64,System.UInt64)">
          <source>Returns the larger of two 64-bit unsigned integers.</source>
          <target state="translated">Devuelve el mayor de dos enteros de 64 bits sin signo.</target>       </trans-unit>
        <trans-unit id="435" translate="yes" xml:space="preserve" uid="M:System.Math.Max(System.UInt64,System.UInt64)">
          <source>Parameter <ph id="ph1">&lt;paramref name="val1" /&gt;</ph> or <ph id="ph2">&lt;paramref name="val2" /&gt;</ph>, whichever is larger.</source>
          <target state="translated">Parámetro <ph id="ph1">&lt;paramref name="val1" /&gt;</ph> o <ph id="ph2">&lt;paramref name="val2" /&gt;</ph>, el que sea mayor.</target>       </trans-unit>
        <trans-unit id="436" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Math.Max(System.UInt64,System.UInt64)">
          <source>The following example demonstrates how to use the <ph id="ph1">&lt;xref:System.Math.Max%2A&gt;</ph> method to return and display the greater of two variables.</source>
          <target state="translated">En el ejemplo siguiente se muestra cómo utilizar el <ph id="ph1">&lt;xref:System.Math.Max%2A&gt;</ph> método para devolver y mostrar la mayor de dos variables.</target>       </trans-unit>
        <trans-unit id="437" translate="yes" xml:space="preserve" uid="T:System.Math">
          <source>Returns the smaller of two numbers.</source>
          <target state="translated">Devuelve el menor de dos números.</target>       </trans-unit>
        <trans-unit id="438" translate="yes" xml:space="preserve" uid="M:System.Math.Min(System.Byte,System.Byte)">
          <source>The first of two 8-bit unsigned integers to compare.</source>
          <target state="translated">Primer entero de 8 bits sin signo de los dos que se van a comparar.</target>       </trans-unit>
        <trans-unit id="439" translate="yes" xml:space="preserve" uid="M:System.Math.Min(System.Byte,System.Byte)">
          <source>The second of two 8-bit unsigned integers to compare.</source>
          <target state="translated">Segundo entero de 8 bits sin signo de los dos que se van a comparar.</target>       </trans-unit>
        <trans-unit id="440" translate="yes" xml:space="preserve" uid="M:System.Math.Min(System.Byte,System.Byte)">
          <source>Returns the smaller of two 8-bit unsigned integers.</source>
          <target state="translated">Devuelve el menor de dos enteros de 8 bits sin signo.</target>       </trans-unit>
        <trans-unit id="441" translate="yes" xml:space="preserve" uid="M:System.Math.Min(System.Byte,System.Byte)">
          <source>Parameter <ph id="ph1">&lt;paramref name="val1" /&gt;</ph> or <ph id="ph2">&lt;paramref name="val2" /&gt;</ph>, whichever is smaller.</source>
          <target state="translated">Parámetro <ph id="ph1">&lt;paramref name="val1" /&gt;</ph> o <ph id="ph2">&lt;paramref name="val2" /&gt;</ph>, el que sea menor.</target>       </trans-unit>
        <trans-unit id="442" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Math.Min(System.Byte,System.Byte)">
          <source>The following example demonstrates how to use the <ph id="ph1">&lt;xref:System.Math.Min%2A&gt;</ph> method to return and display the smaller of two variables.</source>
          <target state="translated">En el ejemplo siguiente se muestra cómo utilizar el <ph id="ph1">&lt;xref:System.Math.Min%2A&gt;</ph> método para devolver y mostrar la menor de dos variables.</target>       </trans-unit>
        <trans-unit id="443" translate="yes" xml:space="preserve" uid="M:System.Math.Min(System.Decimal,System.Decimal)">
          <source>The first of two decimal numbers to compare.</source>
          <target state="translated">Primer número de dos números decimales que se van a comparar.</target>       </trans-unit>
        <trans-unit id="444" translate="yes" xml:space="preserve" uid="M:System.Math.Min(System.Decimal,System.Decimal)">
          <source>The second of two decimal numbers to compare.</source>
          <target state="translated">Segundo número de dos decimales que se van a comparar.</target>       </trans-unit>
        <trans-unit id="445" translate="yes" xml:space="preserve" uid="M:System.Math.Min(System.Decimal,System.Decimal)">
          <source>Returns the smaller of two decimal numbers.</source>
          <target state="translated">Devuelve el menor de dos números decimales.</target>       </trans-unit>
        <trans-unit id="446" translate="yes" xml:space="preserve" uid="M:System.Math.Min(System.Decimal,System.Decimal)">
          <source>Parameter <ph id="ph1">&lt;paramref name="val1" /&gt;</ph> or <ph id="ph2">&lt;paramref name="val2" /&gt;</ph>, whichever is smaller.</source>
          <target state="translated">Parámetro <ph id="ph1">&lt;paramref name="val1" /&gt;</ph> o <ph id="ph2">&lt;paramref name="val2" /&gt;</ph>, el que sea menor.</target>       </trans-unit>
        <trans-unit id="447" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Math.Min(System.Decimal,System.Decimal)">
          <source>The following example demonstrates how to use the <ph id="ph1">&lt;xref:System.Math.Min%2A&gt;</ph> method to return and display the smaller of two variables.</source>
          <target state="translated">En el ejemplo siguiente se muestra cómo utilizar el <ph id="ph1">&lt;xref:System.Math.Min%2A&gt;</ph> método para devolver y mostrar la menor de dos variables.</target>       </trans-unit>
        <trans-unit id="448" translate="yes" xml:space="preserve" uid="M:System.Math.Min(System.Double,System.Double)">
          <source>The first of two double-precision floating-point numbers to compare.</source>
          <target state="translated">Primer número de punto flotante de precisión doble de los dos que se van a comparar.</target>       </trans-unit>
        <trans-unit id="449" translate="yes" xml:space="preserve" uid="M:System.Math.Min(System.Double,System.Double)">
          <source>The second of two double-precision floating-point numbers to compare.</source>
          <target state="translated">Segundo número de punto flotante de precisión doble de los dos que se van a comparar.</target>       </trans-unit>
        <trans-unit id="450" translate="yes" xml:space="preserve" uid="M:System.Math.Min(System.Double,System.Double)">
          <source>Returns the smaller of two double-precision floating-point numbers.</source>
          <target state="translated">Devuelve el menor de dos números de punto flotante de precisión doble.</target>       </trans-unit>
        <trans-unit id="451" translate="yes" xml:space="preserve" uid="M:System.Math.Min(System.Double,System.Double)">
          <source>Parameter <ph id="ph1">&lt;paramref name="val1" /&gt;</ph> or <ph id="ph2">&lt;paramref name="val2" /&gt;</ph>, whichever is smaller.</source>
          <target state="translated">Parámetro <ph id="ph1">&lt;paramref name="val1" /&gt;</ph> o <ph id="ph2">&lt;paramref name="val2" /&gt;</ph>, el que sea menor.</target>       </trans-unit>
        <trans-unit id="452" translate="yes" xml:space="preserve" uid="M:System.Math.Min(System.Double,System.Double)">
          <source>If <ph id="ph1">&lt;paramref name="val1" /&gt;</ph>, <ph id="ph2">&lt;paramref name="val2" /&gt;</ph>, or both <ph id="ph3">&lt;paramref name="val1" /&gt;</ph> and <ph id="ph4">&lt;paramref name="val2" /&gt;</ph> are equal to <ph id="ph5">&lt;see cref="F:System.Double.NaN" /&gt;</ph>, <ph id="ph6">&lt;see cref="F:System.Double.NaN" /&gt;</ph> is returned.</source>
          <target state="translated">Si <ph id="ph1">&lt;paramref name="val1" /&gt;</ph>, <ph id="ph2">&lt;paramref name="val2" /&gt;</ph> o ambos ( <ph id="ph3">&lt;paramref name="val1" /&gt;</ph> y <ph id="ph4">&lt;paramref name="val2" /&gt;</ph>) son iguales que <ph id="ph5">&lt;see cref="F:System.Double.NaN" /&gt;</ph>, se devuelve <ph id="ph6">&lt;see cref="F:System.Double.NaN" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="453" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Math.Min(System.Double,System.Double)">
          <source>The following example demonstrates how to use the <ph id="ph1">&lt;xref:System.Math.Min%2A&gt;</ph> method to return and display the smaller of two variables.</source>
          <target state="translated">En el ejemplo siguiente se muestra cómo utilizar el <ph id="ph1">&lt;xref:System.Math.Min%2A&gt;</ph> método para devolver y mostrar la menor de dos variables.</target>       </trans-unit>
        <trans-unit id="454" translate="yes" xml:space="preserve" uid="M:System.Math.Min(System.Int16,System.Int16)">
          <source>The first of two 16-bit signed integers to compare.</source>
          <target state="translated">Primero de los dos enteros de 16 bits con signo que se van a comparar.</target>       </trans-unit>
        <trans-unit id="455" translate="yes" xml:space="preserve" uid="M:System.Math.Min(System.Int16,System.Int16)">
          <source>The second of two 16-bit signed integers to compare.</source>
          <target state="translated">Segundo de los dos enteros de 16 bits con signo que se van a comparar.</target>       </trans-unit>
        <trans-unit id="456" translate="yes" xml:space="preserve" uid="M:System.Math.Min(System.Int16,System.Int16)">
          <source>Returns the smaller of two 16-bit signed integers.</source>
          <target state="translated">Devuelve el menor de dos enteros de 16 bits con signo.</target>       </trans-unit>
        <trans-unit id="457" translate="yes" xml:space="preserve" uid="M:System.Math.Min(System.Int16,System.Int16)">
          <source>Parameter <ph id="ph1">&lt;paramref name="val1" /&gt;</ph> or <ph id="ph2">&lt;paramref name="val2" /&gt;</ph>, whichever is smaller.</source>
          <target state="translated">Parámetro <ph id="ph1">&lt;paramref name="val1" /&gt;</ph> o <ph id="ph2">&lt;paramref name="val2" /&gt;</ph>, el que sea menor.</target>       </trans-unit>
        <trans-unit id="458" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Math.Min(System.Int16,System.Int16)">
          <source>The following example demonstrates how to use the <ph id="ph1">&lt;xref:System.Math.Min%2A&gt;</ph> method to return and display the smaller of two variables.</source>
          <target state="translated">En el ejemplo siguiente se muestra cómo utilizar el <ph id="ph1">&lt;xref:System.Math.Min%2A&gt;</ph> método para devolver y mostrar la menor de dos variables.</target>       </trans-unit>
        <trans-unit id="459" translate="yes" xml:space="preserve" uid="M:System.Math.Min(System.Int32,System.Int32)">
          <source>The first of two 32-bit signed integers to compare.</source>
          <target state="translated">Primero de los dos enteros de 32 bits con signo que se van a comparar.</target>       </trans-unit>
        <trans-unit id="460" translate="yes" xml:space="preserve" uid="M:System.Math.Min(System.Int32,System.Int32)">
          <source>The second of two 32-bit signed integers to compare.</source>
          <target state="translated">Segundo de los dos enteros de 32 bits con signo que se van a comparar.</target>       </trans-unit>
        <trans-unit id="461" translate="yes" xml:space="preserve" uid="M:System.Math.Min(System.Int32,System.Int32)">
          <source>Returns the smaller of two 32-bit signed integers.</source>
          <target state="translated">Devuelve el menor de dos enteros de 32 bits con signo.</target>       </trans-unit>
        <trans-unit id="462" translate="yes" xml:space="preserve" uid="M:System.Math.Min(System.Int32,System.Int32)">
          <source>Parameter <ph id="ph1">&lt;paramref name="val1" /&gt;</ph> or <ph id="ph2">&lt;paramref name="val2" /&gt;</ph>, whichever is smaller.</source>
          <target state="translated">Parámetro <ph id="ph1">&lt;paramref name="val1" /&gt;</ph> o <ph id="ph2">&lt;paramref name="val2" /&gt;</ph>, el que sea menor.</target>       </trans-unit>
        <trans-unit id="463" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Math.Min(System.Int32,System.Int32)">
          <source>The following example demonstrates how to use the <ph id="ph1">&lt;xref:System.Math.Min%2A&gt;</ph> method to return and display the smaller of two variables.</source>
          <target state="translated">En el ejemplo siguiente se muestra cómo utilizar el <ph id="ph1">&lt;xref:System.Math.Min%2A&gt;</ph> método para devolver y mostrar la menor de dos variables.</target>       </trans-unit>
        <trans-unit id="464" translate="yes" xml:space="preserve" uid="M:System.Math.Min(System.Int64,System.Int64)">
          <source>The first of two 64-bit signed integers to compare.</source>
          <target state="translated">Primero de los dos enteros de 64 bits con signo que se van a comparar.</target>       </trans-unit>
        <trans-unit id="465" translate="yes" xml:space="preserve" uid="M:System.Math.Min(System.Int64,System.Int64)">
          <source>The second of two 64-bit signed integers to compare.</source>
          <target state="translated">Segundo de los dos enteros de 64 bits con signo que se van a comparar.</target>       </trans-unit>
        <trans-unit id="466" translate="yes" xml:space="preserve" uid="M:System.Math.Min(System.Int64,System.Int64)">
          <source>Returns the smaller of two 64-bit signed integers.</source>
          <target state="translated">Devuelve el menor de dos enteros de 64 bits con signo.</target>       </trans-unit>
        <trans-unit id="467" translate="yes" xml:space="preserve" uid="M:System.Math.Min(System.Int64,System.Int64)">
          <source>Parameter <ph id="ph1">&lt;paramref name="val1" /&gt;</ph> or <ph id="ph2">&lt;paramref name="val2" /&gt;</ph>, whichever is smaller.</source>
          <target state="translated">Parámetro <ph id="ph1">&lt;paramref name="val1" /&gt;</ph> o <ph id="ph2">&lt;paramref name="val2" /&gt;</ph>, el que sea menor.</target>       </trans-unit>
        <trans-unit id="468" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Math.Min(System.Int64,System.Int64)">
          <source>The following example demonstrates how to use the <ph id="ph1">&lt;xref:System.Math.Min%2A&gt;</ph> method to return and display the smaller of two variables.</source>
          <target state="translated">En el ejemplo siguiente se muestra cómo utilizar el <ph id="ph1">&lt;xref:System.Math.Min%2A&gt;</ph> método para devolver y mostrar la menor de dos variables.</target>       </trans-unit>
        <trans-unit id="469" translate="yes" xml:space="preserve" uid="M:System.Math.Min(System.SByte,System.SByte)">
          <source>The first of two 8-bit signed integers to compare.</source>
          <target state="translated">Primero de los dos enteros de 8 bits con signo que se van a comparar.</target>       </trans-unit>
        <trans-unit id="470" translate="yes" xml:space="preserve" uid="M:System.Math.Min(System.SByte,System.SByte)">
          <source>The second of two 8-bit signed integers to compare.</source>
          <target state="translated">Segundo de los dos enteros de 8 bits con signo que se van a comparar.</target>       </trans-unit>
        <trans-unit id="471" translate="yes" xml:space="preserve" uid="M:System.Math.Min(System.SByte,System.SByte)">
          <source>Returns the smaller of two 8-bit signed integers.</source>
          <target state="translated">Devuelve el menor de dos enteros de 8 bits con signo.</target>       </trans-unit>
        <trans-unit id="472" translate="yes" xml:space="preserve" uid="M:System.Math.Min(System.SByte,System.SByte)">
          <source>Parameter <ph id="ph1">&lt;paramref name="val1" /&gt;</ph> or <ph id="ph2">&lt;paramref name="val2" /&gt;</ph>, whichever is smaller.</source>
          <target state="translated">Parámetro <ph id="ph1">&lt;paramref name="val1" /&gt;</ph> o <ph id="ph2">&lt;paramref name="val2" /&gt;</ph>, el que sea menor.</target>       </trans-unit>
        <trans-unit id="473" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Math.Min(System.SByte,System.SByte)">
          <source>The following example demonstrates how to use the <ph id="ph1">&lt;xref:System.Math.Min%2A&gt;</ph> method to return and display the smaller of two variables.</source>
          <target state="translated">En el ejemplo siguiente se muestra cómo utilizar el <ph id="ph1">&lt;xref:System.Math.Min%2A&gt;</ph> método para devolver y mostrar la menor de dos variables.</target>       </trans-unit>
        <trans-unit id="474" translate="yes" xml:space="preserve" uid="M:System.Math.Min(System.Single,System.Single)">
          <source>The first of two single-precision floating-point numbers to compare.</source>
          <target state="translated">Primer número de punto flotante de precisión sencilla de los dos que se van a comparar.</target>       </trans-unit>
        <trans-unit id="475" translate="yes" xml:space="preserve" uid="M:System.Math.Min(System.Single,System.Single)">
          <source>The second of two single-precision floating-point numbers to compare.</source>
          <target state="translated">Segundo número de punto flotante de precisión sencilla de los dos que se van a comparar.</target>       </trans-unit>
        <trans-unit id="476" translate="yes" xml:space="preserve" uid="M:System.Math.Min(System.Single,System.Single)">
          <source>Returns the smaller of two single-precision floating-point numbers.</source>
          <target state="translated">Devuelve el menor de dos números de punto flotante de precisión sencilla.</target>       </trans-unit>
        <trans-unit id="477" translate="yes" xml:space="preserve" uid="M:System.Math.Min(System.Single,System.Single)">
          <source>Parameter <ph id="ph1">&lt;paramref name="val1" /&gt;</ph> or <ph id="ph2">&lt;paramref name="val2" /&gt;</ph>, whichever is smaller.</source>
          <target state="translated">Parámetro <ph id="ph1">&lt;paramref name="val1" /&gt;</ph> o <ph id="ph2">&lt;paramref name="val2" /&gt;</ph>, el que sea menor.</target>       </trans-unit>
        <trans-unit id="478" translate="yes" xml:space="preserve" uid="M:System.Math.Min(System.Single,System.Single)">
          <source>If <ph id="ph1">&lt;paramref name="val1" /&gt;</ph>, <ph id="ph2">&lt;paramref name="val2" /&gt;</ph>, or both <ph id="ph3">&lt;paramref name="val1" /&gt;</ph> and <ph id="ph4">&lt;paramref name="val2" /&gt;</ph> are equal to <ph id="ph5">&lt;see cref="F:System.Single.NaN" /&gt;</ph>, <ph id="ph6">&lt;see cref="F:System.Single.NaN" /&gt;</ph> is returned.</source>
          <target state="translated">Si <ph id="ph1">&lt;paramref name="val1" /&gt;</ph>, <ph id="ph2">&lt;paramref name="val2" /&gt;</ph> o ambos ( <ph id="ph3">&lt;paramref name="val1" /&gt;</ph> y <ph id="ph4">&lt;paramref name="val2" /&gt;</ph>) son iguales que <ph id="ph5">&lt;see cref="F:System.Single.NaN" /&gt;</ph>, se devuelve <ph id="ph6">&lt;see cref="F:System.Single.NaN" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="479" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Math.Min(System.Single,System.Single)">
          <source>The following example demonstrates how to use the <ph id="ph1">&lt;xref:System.Math.Min%2A&gt;</ph> method to return and display the smaller of two variables.</source>
          <target state="translated">En el ejemplo siguiente se muestra cómo utilizar el <ph id="ph1">&lt;xref:System.Math.Min%2A&gt;</ph> método para devolver y mostrar la menor de dos variables.</target>       </trans-unit>
        <trans-unit id="480" translate="yes" xml:space="preserve" uid="M:System.Math.Min(System.UInt16,System.UInt16)">
          <source>The first of two 16-bit unsigned integers to compare.</source>
          <target state="translated">Primer entero de 16 bits sin signo de los dos que se van a comparar.</target>       </trans-unit>
        <trans-unit id="481" translate="yes" xml:space="preserve" uid="M:System.Math.Min(System.UInt16,System.UInt16)">
          <source>The second of two 16-bit unsigned integers to compare.</source>
          <target state="translated">Segundo entero de 16 bits sin signo de los dos que se van a comparar.</target>       </trans-unit>
        <trans-unit id="482" translate="yes" xml:space="preserve" uid="M:System.Math.Min(System.UInt16,System.UInt16)">
          <source>Returns the smaller of two 16-bit unsigned integers.</source>
          <target state="translated">Devuelve el menor de dos enteros de 16 bits sin signo.</target>       </trans-unit>
        <trans-unit id="483" translate="yes" xml:space="preserve" uid="M:System.Math.Min(System.UInt16,System.UInt16)">
          <source>Parameter <ph id="ph1">&lt;paramref name="val1" /&gt;</ph> or <ph id="ph2">&lt;paramref name="val2" /&gt;</ph>, whichever is smaller.</source>
          <target state="translated">Parámetro <ph id="ph1">&lt;paramref name="val1" /&gt;</ph> o <ph id="ph2">&lt;paramref name="val2" /&gt;</ph>, el que sea menor.</target>       </trans-unit>
        <trans-unit id="484" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Math.Min(System.UInt16,System.UInt16)">
          <source>The following example demonstrates how to use the <ph id="ph1">&lt;xref:System.Math.Min%2A&gt;</ph> method to return and display the smaller of two variables.</source>
          <target state="translated">En el ejemplo siguiente se muestra cómo utilizar el <ph id="ph1">&lt;xref:System.Math.Min%2A&gt;</ph> método para devolver y mostrar la menor de dos variables.</target>       </trans-unit>
        <trans-unit id="485" translate="yes" xml:space="preserve" uid="M:System.Math.Min(System.UInt32,System.UInt32)">
          <source>The first of two 32-bit unsigned integers to compare.</source>
          <target state="translated">Primer entero de 32 bits sin signo de los dos que se van a comparar.</target>       </trans-unit>
        <trans-unit id="486" translate="yes" xml:space="preserve" uid="M:System.Math.Min(System.UInt32,System.UInt32)">
          <source>The second of two 32-bit unsigned integers to compare.</source>
          <target state="translated">Segundo entero de 32 bits sin signo de los dos que se van a comparar.</target>       </trans-unit>
        <trans-unit id="487" translate="yes" xml:space="preserve" uid="M:System.Math.Min(System.UInt32,System.UInt32)">
          <source>Returns the smaller of two 32-bit unsigned integers.</source>
          <target state="translated">Devuelve el menor de dos enteros de 32 bits sin signo.</target>       </trans-unit>
        <trans-unit id="488" translate="yes" xml:space="preserve" uid="M:System.Math.Min(System.UInt32,System.UInt32)">
          <source>Parameter <ph id="ph1">&lt;paramref name="val1" /&gt;</ph> or <ph id="ph2">&lt;paramref name="val2" /&gt;</ph>, whichever is smaller.</source>
          <target state="translated">Parámetro <ph id="ph1">&lt;paramref name="val1" /&gt;</ph> o <ph id="ph2">&lt;paramref name="val2" /&gt;</ph>, el que sea menor.</target>       </trans-unit>
        <trans-unit id="489" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Math.Min(System.UInt32,System.UInt32)">
          <source>The following example demonstrates how to use the <ph id="ph1">&lt;xref:System.Math.Min%2A&gt;</ph> method to return and display the smaller of two variables.</source>
          <target state="translated">En el ejemplo siguiente se muestra cómo utilizar el <ph id="ph1">&lt;xref:System.Math.Min%2A&gt;</ph> método para devolver y mostrar la menor de dos variables.</target>       </trans-unit>
        <trans-unit id="490" translate="yes" xml:space="preserve" uid="M:System.Math.Min(System.UInt64,System.UInt64)">
          <source>The first of two 64-bit unsigned integers to compare.</source>
          <target state="translated">Primer entero de 64 bits sin signo de los dos que se van a comparar.</target>       </trans-unit>
        <trans-unit id="491" translate="yes" xml:space="preserve" uid="M:System.Math.Min(System.UInt64,System.UInt64)">
          <source>The second of two 64-bit unsigned integers to compare.</source>
          <target state="translated">Segundo entero de 64 bits sin signo de los dos que se van a comparar.</target>       </trans-unit>
        <trans-unit id="492" translate="yes" xml:space="preserve" uid="M:System.Math.Min(System.UInt64,System.UInt64)">
          <source>Returns the smaller of two 64-bit unsigned integers.</source>
          <target state="translated">Devuelve el menor de dos enteros de 64 bits sin signo.</target>       </trans-unit>
        <trans-unit id="493" translate="yes" xml:space="preserve" uid="M:System.Math.Min(System.UInt64,System.UInt64)">
          <source>Parameter <ph id="ph1">&lt;paramref name="val1" /&gt;</ph> or <ph id="ph2">&lt;paramref name="val2" /&gt;</ph>, whichever is smaller.</source>
          <target state="translated">Parámetro <ph id="ph1">&lt;paramref name="val1" /&gt;</ph> o <ph id="ph2">&lt;paramref name="val2" /&gt;</ph>, el que sea menor.</target>       </trans-unit>
        <trans-unit id="494" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Math.Min(System.UInt64,System.UInt64)">
          <source>The following example demonstrates how to use the <ph id="ph1">&lt;xref:System.Math.Min%2A&gt;</ph> method to return and display the smaller of two variables.</source>
          <target state="translated">En el ejemplo siguiente se muestra cómo utilizar el <ph id="ph1">&lt;xref:System.Math.Min%2A&gt;</ph> método para devolver y mostrar la menor de dos variables.</target>       </trans-unit>
        <trans-unit id="495" translate="yes" xml:space="preserve" uid="F:System.Math.PI">
          <source>Represents the ratio of the circumference of a circle to its diameter, specified by the constant, π.</source>
          <target state="translated">Representa la proporción de la circunferencia de un círculo en relación con su diámetro, especificado por la constante π.</target>       </trans-unit>
        <trans-unit id="496" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Math.PI">
          <source>The value of this field is 3.14159265358979323846.</source>
          <target state="translated">El valor de este campo es 3,14159265358979323846.</target>       </trans-unit>
        <trans-unit id="497" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Math.PI">
          <source>The following example uses <ph id="ph1">&lt;xref:System.Math.PI&gt;</ph> to assist in the computation of the inner angles of a given trapezoid.</source>
          <target state="translated">En el ejemplo siguiente se utiliza <ph id="ph1">&lt;xref:System.Math.PI&gt;</ph> para ayudar en el cálculo de los ángulos internos de un trapezoide determinado.</target>       </trans-unit>
        <trans-unit id="498" translate="yes" xml:space="preserve" uid="M:System.Math.Pow(System.Double,System.Double)">
          <source>A double-precision floating-point number to be raised to a power.</source>
          <target state="translated">Número de punto flotante de precisión doble que se desea elevar a una potencia.</target>       </trans-unit>
        <trans-unit id="499" translate="yes" xml:space="preserve" uid="M:System.Math.Pow(System.Double,System.Double)">
          <source>A double-precision floating-point number that specifies a power.</source>
          <target state="translated">Número de punto flotante de precisión doble que especifica una potencia.</target>       </trans-unit>
        <trans-unit id="500" translate="yes" xml:space="preserve" uid="M:System.Math.Pow(System.Double,System.Double)">
          <source>Returns a specified number raised to the specified power.</source>
          <target state="translated">Devuelve un número especificado elevado a la potencia especificada.</target>       </trans-unit>
        <trans-unit id="501" translate="yes" xml:space="preserve" uid="M:System.Math.Pow(System.Double,System.Double)">
          <source>The number <ph id="ph1">&lt;paramref name="x" /&gt;</ph> raised to the power <ph id="ph2">&lt;paramref name="y" /&gt;</ph>.</source>
          <target state="translated">Número <ph id="ph1">&lt;paramref name="x" /&gt;</ph> elevado a la potencia <ph id="ph2">&lt;paramref name="y" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="502" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Math.Pow(System.Double,System.Double)">
          <source>The following table indicates the return value when various values or ranges of values are specified for the <ph id="ph1">`x`</ph> and <ph id="ph2">`y`</ph> parameters.</source>
          <target state="translated">En la tabla siguiente indica el valor devuelto cuando se especifican varios valores o intervalos de valores para la <ph id="ph1">`x`</ph> y <ph id="ph2">`y`</ph> parámetros.</target>       </trans-unit>
        <trans-unit id="503" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Math.Pow(System.Double,System.Double)">
          <source>For more information, see <ph id="ph1">&lt;xref:System.Double.PositiveInfinity?displayProperty=nameWithType&gt;</ph>, <ph id="ph2">&lt;xref:System.Double.NegativeInfinity?displayProperty=nameWithType&gt;</ph>, and <ph id="ph3">&lt;xref:System.Double.NaN?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Para obtener más información, vea <ph id="ph1">&lt;xref:System.Double.PositiveInfinity?displayProperty=nameWithType&gt;</ph>, <ph id="ph2">&lt;xref:System.Double.NegativeInfinity?displayProperty=nameWithType&gt;</ph> y <ph id="ph3">&lt;xref:System.Double.NaN?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="504" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Math.Pow(System.Double,System.Double)">
          <source>Parameters</source>
          <target state="translated">Parámetros</target>       </trans-unit>
        <trans-unit id="505" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Math.Pow(System.Double,System.Double)">
          <source>Return value</source>
          <target state="translated">Valor devuelto</target>       </trans-unit>
        <trans-unit id="506" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Math.Pow(System.Double,System.Double)">
          <source><ph id="ph1">`x`</ph> or <ph id="ph2">`y`</ph><ph id="ph3"> = </ph><ph id="ph4">`NaN`</ph>.</source>
          <target state="translated"><ph id="ph1">`x`</ph> o <ph id="ph2">`y`</ph> <ph id="ph3"> = </ph> <ph id="ph4">`NaN`</ph>.</target>       </trans-unit>
        <trans-unit id="507" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Math.Pow(System.Double,System.Double)">
          <source><ph id="ph1">`x`</ph> = Any value except <ph id="ph2">`NaN`</ph>; <ph id="ph3">`y`</ph> = 0.</source>
          <target state="translated"><ph id="ph1">`x`</ph> = Cualquier valor excepto <ph id="ph2">`NaN`</ph>; <ph id="ph3">`y`</ph> = 0.</target>       </trans-unit>
        <trans-unit id="508" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Math.Pow(System.Double,System.Double)">
          <source>1</source>
          <target state="translated">1</target>       </trans-unit>
        <trans-unit id="509" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Math.Pow(System.Double,System.Double)">
          <source><ph id="ph1">`x`</ph><ph id="ph2"> = </ph><ph id="ph3">`NegativeInfinity`</ph>; <ph id="ph4">`y`</ph> &lt; 0.</source>
          <target state="translated"><ph id="ph1">`x`</ph><ph id="ph2"> = </ph><ph id="ph3">`NegativeInfinity`</ph>; <ph id="ph4">`y`</ph> &lt; 0.</target>       </trans-unit>
        <trans-unit id="510" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Math.Pow(System.Double,System.Double)">
          <source>0</source>
          <target state="translated">0</target>       </trans-unit>
        <trans-unit id="511" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Math.Pow(System.Double,System.Double)">
          <source><ph id="ph1">`x`</ph><ph id="ph2"> = </ph><ph id="ph3">`NegativeInfinity`</ph>; <ph id="ph4">`y`</ph> is a positive odd integer.</source>
          <target state="translated"><ph id="ph1">`x`</ph><ph id="ph2"> = </ph><ph id="ph3">`NegativeInfinity`</ph>; <ph id="ph4">`y`</ph> es un entero impar positivo.</target>       </trans-unit>
        <trans-unit id="512" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Math.Pow(System.Double,System.Double)">
          <source><ph id="ph1">`x`</ph><ph id="ph2"> = </ph><ph id="ph3">`NegativeInfinity`</ph>; <ph id="ph4">`y`</ph> is positive but not an odd integer.</source>
          <target state="translated"><ph id="ph1">`x`</ph><ph id="ph2"> = </ph><ph id="ph3">`NegativeInfinity`</ph>; <ph id="ph4">`y`</ph> es positivo, pero no es un entero impar.</target>       </trans-unit>
        <trans-unit id="513" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Math.Pow(System.Double,System.Double)">
          <source><ph id="ph1">`x`</ph> &lt; 0 but not <ph id="ph2">`NegativeInfinity`</ph>; <ph id="ph3">`y`</ph> is not an integer, <ph id="ph4">`NegativeInfinity`</ph>, or <ph id="ph5">`PositiveInfinity`</ph>.</source>
          <target state="translated"><ph id="ph1">`x`</ph> &lt; 0, pero no <ph id="ph2">`NegativeInfinity`</ph>; <ph id="ph3">`y`</ph> no es un entero, <ph id="ph4">`NegativeInfinity`</ph>, o <ph id="ph5">`PositiveInfinity`</ph>.</target>       </trans-unit>
        <trans-unit id="514" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Math.Pow(System.Double,System.Double)">
          <source><ph id="ph1">`x`</ph> = -1; <ph id="ph2">`y`</ph><ph id="ph3"> = </ph><ph id="ph4">`NegativeInfinity`</ph> or <ph id="ph5">`PositiveInfinity`</ph>.</source>
          <target state="translated"><ph id="ph1">`x`</ph> = -1; <ph id="ph2">`y`</ph> <ph id="ph3"> = </ph> <ph id="ph4">`NegativeInfinity`</ph> o <ph id="ph5">`PositiveInfinity`</ph>.</target>       </trans-unit>
        <trans-unit id="515" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Math.Pow(System.Double,System.Double)">
          <source>-1 &lt; <ph id="ph1">`x`</ph> &lt; 1; <ph id="ph2">`y`</ph><ph id="ph3"> = </ph><ph id="ph4">`NegativeInfinity`</ph>.</source>
          <target state="translated">-1 &lt; <ph id="ph1">`x`</ph> &lt; 1; <ph id="ph2">`y`</ph><ph id="ph3"> = </ph><ph id="ph4">`NegativeInfinity`</ph>.</target>       </trans-unit>
        <trans-unit id="516" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Math.Pow(System.Double,System.Double)">
          <source>-1 &lt; <ph id="ph1">`x`</ph> &lt; 1; <ph id="ph2">`y`</ph><ph id="ph3"> = </ph><ph id="ph4">`PositiveInfinity`</ph>.</source>
          <target state="translated">-1 &lt; <ph id="ph1">`x`</ph> &lt; 1; <ph id="ph2">`y`</ph><ph id="ph3"> = </ph><ph id="ph4">`PositiveInfinity`</ph>.</target>       </trans-unit>
        <trans-unit id="517" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Math.Pow(System.Double,System.Double)">
          <source>0</source>
          <target state="translated">0</target>       </trans-unit>
        <trans-unit id="518" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Math.Pow(System.Double,System.Double)">
          <source><ph id="ph1">`x`</ph> &lt; -1 or <ph id="ph2">`x`</ph> &gt; 1; <ph id="ph3">`y`</ph><ph id="ph4"> = </ph><ph id="ph5">`NegativeInfinity`</ph>.</source>
          <target state="translated"><ph id="ph1">`x`</ph> &lt; -1 o <ph id="ph2">`x`</ph> &gt; 1; <ph id="ph3">`y`</ph><ph id="ph4"> = </ph><ph id="ph5">`NegativeInfinity`</ph>.</target>       </trans-unit>
        <trans-unit id="519" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Math.Pow(System.Double,System.Double)">
          <source>0</source>
          <target state="translated">0</target>       </trans-unit>
        <trans-unit id="520" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Math.Pow(System.Double,System.Double)">
          <source><ph id="ph1">`x`</ph> &lt; -1 or <ph id="ph2">`x`</ph> &gt; 1; <ph id="ph3">`y`</ph><ph id="ph4"> = </ph><ph id="ph5">`PositiveInfinity`</ph>.</source>
          <target state="translated"><ph id="ph1">`x`</ph> &lt; -1 o <ph id="ph2">`x`</ph> &gt; 1; <ph id="ph3">`y`</ph><ph id="ph4"> = </ph><ph id="ph5">`PositiveInfinity`</ph>.</target>       </trans-unit>
        <trans-unit id="521" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Math.Pow(System.Double,System.Double)">
          <source><ph id="ph1">`x`</ph> = 0; <ph id="ph2">`y`</ph> &lt; 0.</source>
          <target state="translated"><ph id="ph1">`x`</ph> = 0; <ph id="ph2">`y`</ph> &lt; 0.</target>       </trans-unit>
        <trans-unit id="522" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Math.Pow(System.Double,System.Double)">
          <source><ph id="ph1">`x`</ph> = 0; <ph id="ph2">`y`</ph> &gt; 0.</source>
          <target state="translated"><ph id="ph1">`x`</ph> = 0; <ph id="ph2">`y`</ph> &gt; 0.</target>       </trans-unit>
        <trans-unit id="523" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Math.Pow(System.Double,System.Double)">
          <source>0</source>
          <target state="translated">0</target>       </trans-unit>
        <trans-unit id="524" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Math.Pow(System.Double,System.Double)">
          <source><ph id="ph1">`x`</ph> = 1; <ph id="ph2">`y`</ph> is any value except <ph id="ph3">`NaN`</ph>.</source>
          <target state="translated"><ph id="ph1">`x`</ph> = 1; <ph id="ph2">`y`</ph> es cualquier valor excepto <ph id="ph3">`NaN`</ph>.</target>       </trans-unit>
        <trans-unit id="525" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Math.Pow(System.Double,System.Double)">
          <source>1</source>
          <target state="translated">1</target>       </trans-unit>
        <trans-unit id="526" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Math.Pow(System.Double,System.Double)">
          <source><ph id="ph1">`x`</ph><ph id="ph2"> = </ph><ph id="ph3">`PositiveInfinity`</ph>; <ph id="ph4">`y`</ph> &lt; 0.</source>
          <target state="translated"><ph id="ph1">`x`</ph><ph id="ph2"> = </ph><ph id="ph3">`PositiveInfinity`</ph>; <ph id="ph4">`y`</ph> &lt; 0.</target>       </trans-unit>
        <trans-unit id="527" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Math.Pow(System.Double,System.Double)">
          <source>0</source>
          <target state="translated">0</target>       </trans-unit>
        <trans-unit id="528" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Math.Pow(System.Double,System.Double)">
          <source><ph id="ph1">`x`</ph><ph id="ph2"> = </ph><ph id="ph3">`PositiveInfinity`</ph>; <ph id="ph4">`y`</ph> &gt; 0.</source>
          <target state="translated"><ph id="ph1">`x`</ph><ph id="ph2"> = </ph><ph id="ph3">`PositiveInfinity`</ph>; <ph id="ph4">`y`</ph> &gt; 0.</target>       </trans-unit>
        <trans-unit id="529" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Math.Pow(System.Double,System.Double)">
          <source>The following example uses the <ph id="ph1">&lt;xref:System.Math.Pow%2A&gt;</ph> method to calculate the value that results from raising 2 to a power ranging from 0 to 32.</source>
          <target state="translated">En el ejemplo siguiente se usa el <ph id="ph1">&lt;xref:System.Math.Pow%2A&gt;</ph> método para calcular el valor que es el resultado de elevar a 2 a una potencia comprendido entre 0 y 32.</target>       </trans-unit>
        <trans-unit id="530" translate="yes" xml:space="preserve" uid="T:System.Math">
          <source>Rounds a value to the nearest integer or to the specified number of fractional digits.</source>
          <target state="translated">Redondea un valor al entero más próximo o al número especificado de dígitos fraccionarios.</target>       </trans-unit>
        <trans-unit id="531" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Math">
          <source>In this section:</source>
          <target state="translated">En esta sección:</target>       </trans-unit>
        <trans-unit id="532" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Math">
          <source><bpt id="p1">[</bpt>Overloaded method syntax<ept id="p1">](#Syntax)</ept><ph id="ph1"> </ph></source>
          <target state="translated"><bpt id="p1">[</bpt>Sintaxis del método sobrecargado<ept id="p1">](#Syntax)</ept><ph id="ph1"> </ph></target>       </trans-unit>
        <trans-unit id="533" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Math">
          <source><bpt id="p1">[</bpt>Parameters<ept id="p1">](#Params)</ept><ph id="ph1"> </ph></source>
          <target state="translated"><bpt id="p1">[</bpt>Parámetros<ept id="p1">](#Params)</ept><ph id="ph1"> </ph></target>       </trans-unit>
        <trans-unit id="534" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Math">
          <source><bpt id="p1">[</bpt>Return value<ept id="p1">](#Returns)</ept><ph id="ph1"> </ph></source>
          <target state="translated"><bpt id="p1">[</bpt>Valor devuelto<ept id="p1">](#Returns)</ept><ph id="ph1"> </ph></target>       </trans-unit>
        <trans-unit id="535" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Math">
          <source><bpt id="p1">[</bpt>Exceptions<ept id="p1">](#Exceptions)</ept><ph id="ph1"> </ph></source>
          <target state="translated"><bpt id="p1">[</bpt>Excepciones<ept id="p1">](#Exceptions)</ept><ph id="ph1"> </ph></target>       </trans-unit>
        <trans-unit id="536" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Math">
          <source><bpt id="p1">[</bpt>Which method do I call?<ept id="p1">](#Tasks)</ept><ph id="ph1"> </ph></source>
          <target state="translated"><bpt id="p1">[</bpt>¿Qué método se debe llamar?<ept id="p1">](#Tasks)</ept><ph id="ph1"> </ph></target>       </trans-unit>
        <trans-unit id="537" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Math">
          <source><bpt id="p1">[</bpt>Midpoint values and rounding conventions<ept id="p1">](#Midpoint)</ept><ph id="ph1"> </ph></source>
          <target state="translated"><bpt id="p1">[</bpt>Valores de punto medio y convenciones de redondeo<ept id="p1">](#Midpoint)</ept><ph id="ph1"> </ph></target>       </trans-unit>
        <trans-unit id="538" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Math">
          <source><bpt id="p1">[</bpt>Rounding and precision<ept id="p1">](#Precision)</ept><ph id="ph1"> </ph></source>
          <target state="translated"><bpt id="p1">[</bpt>Redondeo y la precisión<ept id="p1">](#Precision)</ept><ph id="ph1"> </ph></target>       </trans-unit>
        <trans-unit id="539" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Math">
          <source><bpt id="p1">[</bpt>Rounding and single-precision floating-point values<ept id="p1">](#Single)</ept><ph id="ph1"> </ph></source>
          <target state="translated"><bpt id="p1">[</bpt>Valores de punto flotante de precisión sencilla y redondeo<ept id="p1">](#Single)</ept><ph id="ph1"> </ph></target>       </trans-unit>
        <trans-unit id="540" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Math">
          <source>Examples:</source>
          <target state="translated">Ejemplos:</target>       </trans-unit>
        <trans-unit id="541" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Math">
          <source><bpt id="p1">[</bpt>Math.Round(Decimal)<ept id="p1">](#Round1_Example)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Math.Round(Decimal)<ept id="p1">](#Round1_Example)</ept></target>       </trans-unit>
        <trans-unit id="542" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Math">
          <source><bpt id="p1">[</bpt>Math.Round(Double)<ept id="p1">](#Round2_Example)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Math.Round(Double)<ept id="p1">](#Round2_Example)</ept></target>       </trans-unit>
        <trans-unit id="543" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Math">
          <source><bpt id="p1">[</bpt>Math.Round(Decimal, Int32)<ept id="p1">](#Round3_Example)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Math.Round (Decimal, Int32)<ept id="p1">](#Round3_Example)</ept></target>       </trans-unit>
        <trans-unit id="544" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Math">
          <source><bpt id="p1">[</bpt>Math.Round(Decimal, MidpointRounding)<ept id="p1">](#Round4_Example)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Math.Round (Decimal, MidpointRounding)<ept id="p1">](#Round4_Example)</ept></target>       </trans-unit>
        <trans-unit id="545" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Math">
          <source><bpt id="p1">[</bpt>Math.Round(Double, Int32)<ept id="p1">](#Round5_Example)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Math.Round (Double, Int32)<ept id="p1">](#Round5_Example)</ept></target>       </trans-unit>
        <trans-unit id="546" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Math">
          <source><bpt id="p1">[</bpt>Math.Round(Double, MidpointRounding)<ept id="p1">](#Round6_Example)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Math.Round (Double, MidpointRounding)<ept id="p1">](#Round6_Example)</ept></target>       </trans-unit>
        <trans-unit id="547" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Math">
          <source><bpt id="p1">[</bpt>Math.Round(Decimal, Int32, MidpointRounding)<ept id="p1">](#Round7_Example)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Math.Round (Int32, Decimal MidpointRounding)<ept id="p1">](#Round7_Example)</ept></target>       </trans-unit>
        <trans-unit id="548" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Math">
          <source><bpt id="p1">[</bpt>Math.Round(Double, Int32, MidpointRounding)<ept id="p1">](#Round8_Example)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Math.Round (Double, Int32, MidpointRounding)<ept id="p1">](#Round8_Example)</ept></target>       </trans-unit>
        <trans-unit id="549" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Math">
          <source><bpt id="p1">[</bpt>Version information<ept id="p1">](#Round_Versions)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Información de versión<ept id="p1">](#Round_Versions)</ept></target>       </trans-unit>
        <trans-unit id="550" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Math">
          <source>Overloaded method syntax</source>
          <target state="translated">Sintaxis del método sobrecargado</target>       </trans-unit>
        <trans-unit id="551" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Math">
          <source>For additional guidance on choosing an overload, see <bpt id="p1">[</bpt>Which method do I call?<ept id="p1">](#Tasks)</ept></source>
          <target state="translated">¿Para obtener instrucciones adicionales sobre cómo elegir una sobrecarga, consulte <bpt id="p1">[</bpt>qué método se debe llamar?<ept id="p1">](#Tasks)</ept></target>       </trans-unit>
        <trans-unit id="552" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Math">
          <source><ph id="ph1">`Decimal Math.Round(Decimal`</ph> <ph id="ph2">`d`</ph> <ph id="ph3">`)`</ph></source>
          <target state="translated"><ph id="ph1">`Decimal Math.Round(Decimal`</ph> <ph id="ph2">`d`</ph> <ph id="ph3">`)`</ph></target>       </trans-unit>
        <trans-unit id="553" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Math">
          <source>Rounds a decimal value to the nearest integer, and rounds midpoint values to the nearest even number (<bpt id="p1">[</bpt>example<ept id="p1">](#Round1_Example)</ept>).</source>
          <target state="translated">Redondea un valor decimal al entero más próximo y redondea los valores de punto medio al número par más cercano (<bpt id="p1">[</bpt>ejemplo<ept id="p1">](#Round1_Example)</ept>).</target>       </trans-unit>
        <trans-unit id="554" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Math">
          <source><ph id="ph1">`Double Math.Round(Double`</ph> <ph id="ph2">`a`</ph> <ph id="ph3">`)`</ph></source>
          <target state="translated"><ph id="ph1">`Double Math.Round(Double`</ph> <ph id="ph2">`a`</ph> <ph id="ph3">`)`</ph></target>       </trans-unit>
        <trans-unit id="555" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Math">
          <source>Rounds a double-precision floating-point value to the nearest integer, and rounds midpoint values to the nearest even number (<bpt id="p1">[</bpt>example<ept id="p1">](#Round2_Example)</ept>).</source>
          <target state="translated">Redondea un valor de punto flotante de precisión doble al entero más próximo y redondea los valores de punto medio al número par más cercano (<bpt id="p1">[</bpt>ejemplo<ept id="p1">](#Round2_Example)</ept>).</target>       </trans-unit>
        <trans-unit id="556" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Math">
          <source><ph id="ph1">`Decimal Math.Round(Decimal`</ph> <ph id="ph2">`d`</ph> <ph id="ph3">`, Int32`</ph>  <ph id="ph4">`decimals`</ph> <ph id="ph5">`)`</ph></source>
          <target state="translated"><ph id="ph1">`Decimal Math.Round(Decimal`</ph> <ph id="ph2">`d`</ph> <ph id="ph3">`, Int32`</ph>  <ph id="ph4">`decimals`</ph> <ph id="ph5">`)`</ph></target>       </trans-unit>
        <trans-unit id="557" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Math">
          <source>Rounds a decimal value to a specified number of fractional digits, and rounds midpoint values to the nearest even number (<bpt id="p1">[</bpt>example<ept id="p1">](#Round3_Example)</ept>).</source>
          <target state="translated">Redondea un valor decimal al número especificado de dígitos fraccionarios y redondea los valores de punto medio al número par más cercano (<bpt id="p1">[</bpt>ejemplo<ept id="p1">](#Round3_Example)</ept>).</target>       </trans-unit>
        <trans-unit id="558" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Math">
          <source><ph id="ph1">`Double Math.Round(Double`</ph> <ph id="ph2">`value`</ph> <ph id="ph3">`, Int32`</ph>  <ph id="ph4">`digits`</ph> <ph id="ph5">`)`</ph></source>
          <target state="translated"><ph id="ph1">`Double Math.Round(Double`</ph> <ph id="ph2">`value`</ph> <ph id="ph3">`, Int32`</ph>  <ph id="ph4">`digits`</ph> <ph id="ph5">`)`</ph></target>       </trans-unit>
        <trans-unit id="559" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Math">
          <source>Rounds a double-precision floating-point value to a specified number of fractional digits, and rounds midpoint values to the nearest even number (<bpt id="p1">[</bpt>example<ept id="p1">](#Round4_Example)</ept>).</source>
          <target state="translated">Redondea un valor de punto flotante de precisión doble al número especificado de dígitos fraccionarios y redondea los valores de punto medio al número par más cercano (<bpt id="p1">[</bpt>ejemplo<ept id="p1">](#Round4_Example)</ept>).</target>       </trans-unit>
        <trans-unit id="560" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Math">
          <source><ph id="ph1">`Decimal Math.Round(Decimal`</ph> <ph id="ph2">`d`</ph> <ph id="ph3">`, MidpointRounding`</ph>  <ph id="ph4">`mode`</ph> <ph id="ph5">`)`</ph></source>
          <target state="translated"><ph id="ph1">`Decimal Math.Round(Decimal`</ph> <ph id="ph2">`d`</ph> <ph id="ph3">`, MidpointRounding`</ph>  <ph id="ph4">`mode`</ph> <ph id="ph5">`)`</ph></target>       </trans-unit>
        <trans-unit id="561" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Math">
          <source>Rounds a decimal value to the nearest integer, and uses the specified rounding convention for midpoint values (<bpt id="p1">[</bpt>example<ept id="p1">](#Round5_Example)</ept>).</source>
          <target state="translated">Redondea un valor decimal al entero más próximo y utiliza la convención de redondeo especificada para los valores de punto medio (<bpt id="p1">[</bpt>ejemplo<ept id="p1">](#Round5_Example)</ept>).</target>       </trans-unit>
        <trans-unit id="562" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Math">
          <source><ph id="ph1">`Double Math.Round(Double`</ph> <ph id="ph2">`value`</ph> <ph id="ph3">`, MidpointRounding`</ph>  <ph id="ph4">`mode`</ph> <ph id="ph5">`)`</ph></source>
          <target state="translated"><ph id="ph1">`Double Math.Round(Double`</ph> <ph id="ph2">`value`</ph> <ph id="ph3">`, MidpointRounding`</ph>  <ph id="ph4">`mode`</ph> <ph id="ph5">`)`</ph></target>       </trans-unit>
        <trans-unit id="563" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Math">
          <source>Rounds a double-precision floating-point value to the nearest integer, and uses the specified rounding convention for midpoint values (<bpt id="p1">[</bpt>example<ept id="p1">](#Round6_Example)</ept>).</source>
          <target state="translated">Redondea un valor de punto flotante de precisión doble al entero más próximo y utiliza la convención de redondeo especificada para los valores de punto medio (<bpt id="p1">[</bpt>ejemplo<ept id="p1">](#Round6_Example)</ept>).</target>       </trans-unit>
        <trans-unit id="564" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Math">
          <source><ph id="ph1">`Decimal Math.Round(Decimal`</ph> <ph id="ph2">`d`</ph> <ph id="ph3">`, Int32`</ph>  <ph id="ph4">`decimals`</ph> <ph id="ph5">`, MidpointRounding`</ph>  <ph id="ph6">`mode`</ph> <ph id="ph7">`)`</ph></source>
          <target state="translated"><ph id="ph1">`Decimal Math.Round(Decimal`</ph> <ph id="ph2">`d`</ph> <ph id="ph3">`, Int32`</ph>  <ph id="ph4">`decimals`</ph> <ph id="ph5">`, MidpointRounding`</ph>  <ph id="ph6">`mode`</ph> <ph id="ph7">`)`</ph></target>       </trans-unit>
        <trans-unit id="565" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Math">
          <source>Rounds a decimal value to a specified number of fractional digits, and uses the specified rounding convention for midpoint values (<bpt id="p1">[</bpt>example<ept id="p1">](#Round7_Example)</ept>).</source>
          <target state="translated">Redondea un valor decimal al número especificado de dígitos fraccionarios y utiliza la convención de redondeo especificada para los valores de punto medio (<bpt id="p1">[</bpt>ejemplo<ept id="p1">](#Round7_Example)</ept>).</target>       </trans-unit>
        <trans-unit id="566" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Math">
          <source><ph id="ph1">`Double Math.Round(Double`</ph> <ph id="ph2">`value`</ph> <ph id="ph3">`, Int32`</ph>  <ph id="ph4">`digits`</ph> <ph id="ph5">`, MidpointRounding`</ph>  <ph id="ph6">`mode`</ph> <ph id="ph7">`)`</ph></source>
          <target state="translated"><ph id="ph1">`Double Math.Round(Double`</ph> <ph id="ph2">`value`</ph> <ph id="ph3">`, Int32`</ph>  <ph id="ph4">`digits`</ph> <ph id="ph5">`, MidpointRounding`</ph>  <ph id="ph6">`mode`</ph> <ph id="ph7">`)`</ph></target>       </trans-unit>
        <trans-unit id="567" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Math">
          <source>Rounds a double-precision floating-point value to a specified number of fractional digits, and uses the specified rounding convention for midpoint values (<bpt id="p1">[</bpt>example<ept id="p1">](#Round8_Example)</ept>).</source>
          <target state="translated">Redondea un valor de punto flotante de precisión doble al número especificado de dígitos fraccionarios y utiliza la convención de redondeo especificada para los valores de punto medio (<bpt id="p1">[</bpt>ejemplo<ept id="p1">](#Round8_Example)</ept>).</target>       </trans-unit>
        <trans-unit id="568" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Math">
          <source>Parameters</source>
          <target state="translated">Parámetros</target>       </trans-unit>
        <trans-unit id="569" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Math">
          <source>This is a complete list of parameters for the <ph id="ph1">&lt;xref:System.Math.Round%2A&gt;</ph> method.</source>
          <target state="translated">Se trata de una lista completa de parámetros para el <ph id="ph1">&lt;xref:System.Math.Round%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="570" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Math">
          <source>For the parameters used by each overload, see the overload syntax above.</source>
          <target state="translated">Para los parámetros utilizados por cada sobrecarga, vea la sintaxis de sobrecarga anterior.</target>       </trans-unit>
        <trans-unit id="571" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Math">
          <source>Parameter</source>
          <target state="translated">Parámetro</target>       </trans-unit>
        <trans-unit id="572" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Math">
          <source>Type</source>
          <target state="translated">Tipo</target>       </trans-unit>
        <trans-unit id="573" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Math">
          <source>Description</source>
          <target state="translated">Descripción</target>       </trans-unit>
        <trans-unit id="574" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Math">
          <source>A number to be rounded.</source>
          <target state="translated">Un número que se desea redondear.</target>       </trans-unit>
        <trans-unit id="575" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Math">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="576" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Math">
          <source>A double-precision floating-point number to be rounded.</source>
          <target state="translated">Número de punto flotante de precisión doble que se va a redondear.</target>       </trans-unit>
        <trans-unit id="577" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Math">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="578" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Math">
          <source>The number of fractional digits in the return value.</source>
          <target state="translated">Número de dígitos fraccionarios del valor devuelto.</target>       </trans-unit>
        <trans-unit id="579" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Math">
          <source>For <ph id="ph1">&lt;xref:System.Decimal&gt;</ph> values, it can range from 0 to 28.</source>
          <target state="translated">Para <ph id="ph1">&lt;xref:System.Decimal&gt;</ph> valores, puede oscilar entre 0 y 28.</target>       </trans-unit>
        <trans-unit id="580" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Math">
          <source>For <ph id="ph1">&lt;xref:System.Double&gt;</ph> values, it can range from 0 to 15.</source>
          <target state="translated">Para <ph id="ph1">&lt;xref:System.Double&gt;</ph> valores, puede oscilar entre 0 y 15.</target>       </trans-unit>
        <trans-unit id="581" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Math">
          <source>Note that 15 is the maximum number of integral and fractional digits supported by the <ph id="ph1">&lt;xref:System.Double&gt;</ph> type.</source>
          <target state="translated">Tenga en cuenta que 15 es el número máximo de dígitos enteros y fraccionarios admitidos por el <ph id="ph1">&lt;xref:System.Double&gt;</ph> tipo.</target>       </trans-unit>
        <trans-unit id="582" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Math">
          <source>Default value: 0, which rounds to an integer</source>
          <target state="translated">Valor predeterminado: 0, lo que se redondea a un entero</target>       </trans-unit>
        <trans-unit id="583" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Math">
          <source>A flag that specifies the convention to use for rounding midpoint values.</source>
          <target state="translated">Una marca que especifica la convención que se usará para redondear los valores de punto medio.</target>       </trans-unit>
        <trans-unit id="584" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Math">
          <source>See <bpt id="p1">[</bpt>Midpoint values and rounding conventions<ept id="p1">](#Midpoint)</ept>.</source>
          <target state="translated">Vea <bpt id="p1">[</bpt>valores de punto medio y convenciones de redondeo<ept id="p1">](#Midpoint)</ept>.</target>       </trans-unit>
        <trans-unit id="585" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Math">
          <source>Default value: <ph id="ph1">&lt;xref:System.MidpointRounding.ToEven?displayProperty=nameWithType&gt;</ph></source>
          <target state="translated">Valor predeterminado: <ph id="ph1">&lt;xref:System.MidpointRounding.ToEven?displayProperty=nameWithType&gt;</ph></target>       </trans-unit>
        <trans-unit id="586" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Math">
          <source>Return value</source>
          <target state="translated">Valor devuelto</target>       </trans-unit>
        <trans-unit id="587" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Math">
          <source>Type: <ph id="ph1">&lt;xref:System.Decimal&gt;</ph> or <ph id="ph2">&lt;xref:System.Double&gt;</ph>, depending on the type of the value to be rounded.</source>
          <target state="translated">Tipo: <ph id="ph1">&lt;xref:System.Decimal&gt;</ph> o <ph id="ph2">&lt;xref:System.Double&gt;</ph>, según el tipo del valor que se va a redondear.</target>       </trans-unit>
        <trans-unit id="588" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Math">
          <source>A numeric value of the same type as <ph id="ph1">`d`</ph>, <ph id="ph2">`a`</ph>, or <ph id="ph3">`value`</ph>, but rounded either to an integer or to the specified number of decimal digits.</source>
          <target state="translated">Un valor numérico del mismo tipo como <ph id="ph1">`d`</ph>, <ph id="ph2">`a`</ph>, o <ph id="ph3">`value`</ph>, pero redondeado a un entero o al número especificado de dígitos decimales.</target>       </trans-unit>
        <trans-unit id="589" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Math">
          <source>See <bpt id="p1">[</bpt>Midpoint values and rounding conventions<ept id="p1">](#Midpoint)</ept> for information about rounding numbers with midpoint values.</source>
          <target state="translated">Vea <bpt id="p1">[</bpt>valores de punto medio y convenciones de redondeo<ept id="p1">](#Midpoint)</ept> para obtener información acerca de redondear los números con valores de punto medio.</target>       </trans-unit>
        <trans-unit id="590" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Math">
          <source>When rounding midpoint values, the rounding algorithm performs an equality test.</source>
          <target state="translated">Cuando se redondea los valores de punto medio, el algoritmo de redondeo realiza una prueba de igualdad.</target>       </trans-unit>
        <trans-unit id="591" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Math">
          <source>Because of problems of binary representation and precision in the floating-point format, the value returned by the method can be unexpected.</source>
          <target state="translated">Debido a problemas de representación binaria y la precisión en el formato de punto flotante, el valor devuelto por el método puede ser inesperado.</target>       </trans-unit>
        <trans-unit id="592" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Math">
          <source>For more information, see <bpt id="p1">[</bpt>Rounding and precision<ept id="p1">](#Precision)</ept>.</source>
          <target state="translated">Para obtener más información, consulte <bpt id="p1">[</bpt>redondeo y la precisión<ept id="p1">](#Precision)</ept>.</target>       </trans-unit>
        <trans-unit id="593" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Math">
          <source>If an overload with a <ph id="ph1">&lt;xref:System.Double&gt;</ph> parameter is called with <ph id="ph2">&lt;xref:System.Double.NaN?displayProperty=nameWithType&gt;</ph>, the method returns <ph id="ph3">&lt;xref:System.Double.NaN?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Si una sobrecarga con un <ph id="ph1">&lt;xref:System.Double&gt;</ph> parámetro se denomina con <ph id="ph2">&lt;xref:System.Double.NaN?displayProperty=nameWithType&gt;</ph>, el método devuelve <ph id="ph3">&lt;xref:System.Double.NaN?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="594" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Math">
          <source>If it is called with <ph id="ph1">&lt;xref:System.Double.PositiveInfinity?displayProperty=nameWithType&gt;</ph> or <ph id="ph2">&lt;xref:System.Double.NegativeInfinity?displayProperty=nameWithType&gt;</ph>, the method returns <ph id="ph3">&lt;xref:System.Double.PositiveInfinity?displayProperty=nameWithType&gt;</ph> or <ph id="ph4">&lt;xref:System.Double.NegativeInfinity?displayProperty=nameWithType&gt;</ph>, respectively.</source>
          <target state="translated">Si se llama con <ph id="ph1">&lt;xref:System.Double.PositiveInfinity?displayProperty=nameWithType&gt;</ph> o <ph id="ph2">&lt;xref:System.Double.NegativeInfinity?displayProperty=nameWithType&gt;</ph>, el método devuelve <ph id="ph3">&lt;xref:System.Double.PositiveInfinity?displayProperty=nameWithType&gt;</ph> o <ph id="ph4">&lt;xref:System.Double.NegativeInfinity?displayProperty=nameWithType&gt;</ph>, respectivamente.</target>       </trans-unit>
        <trans-unit id="595" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Math">
          <source>Exceptions</source>
          <target state="translated">Excepciones</target>       </trans-unit>
        <trans-unit id="596" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Math">
          <source>Exception</source>
          <target state="translated">Excepción</target>       </trans-unit>
        <trans-unit id="597" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Math">
          <source>Condition</source>
          <target state="translated">Condición</target>       </trans-unit>
        <trans-unit id="598" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Math">
          <source>Thrown by</source>
          <target state="translated">Producida por</target>       </trans-unit>
        <trans-unit id="599" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Math">
          <source>The result is outside the range of the <ph id="ph1">&lt;xref:System.Decimal&gt;</ph> type.</source>
          <target state="translated">El resultado está fuera del intervalo de la <ph id="ph1">&lt;xref:System.Decimal&gt;</ph> tipo.</target>       </trans-unit>
        <trans-unit id="600" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Math">
          <source><ph id="ph1">`decimals`</ph> is less than 0 or greater than 28.</source>
          <target state="translated"><ph id="ph1">`decimals`</ph> es menor que 0 o mayor que 28.</target>       </trans-unit>
        <trans-unit id="601" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Math">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="602" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Math">
          <source><ph id="ph1">`digits`</ph> is less than 0 or greater than 15.</source>
          <target state="translated"><ph id="ph1">`digits`</ph> es menor que 0 o mayor que 15.</target>       </trans-unit>
        <trans-unit id="603" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Math">
          <source><ph id="ph1">`mode`</ph> is not a valid value of <ph id="ph2">&lt;xref:System.MidpointRounding&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">`mode`</ph> no es un valor válido de <ph id="ph2">&lt;xref:System.MidpointRounding&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="604" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Math">
          <source>Which method do I call?</source>
          <target state="translated">¿Qué método se debe llamar?</target>       </trans-unit>
        <trans-unit id="605" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Math">
          <source>To</source>
          <target state="translated">En</target>       </trans-unit>
        <trans-unit id="606" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Math">
          <source>Call</source>
          <target state="translated">Call</target>       </trans-unit>
        <trans-unit id="607" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Math">
          <source>Round a number to an integer by using the rounding to nearest convention.</source>
          <target state="translated">Redondear un número en un entero utilizando el redondeo al más cercano convención.</target>       </trans-unit>
        <trans-unit id="608" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Math">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="609" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Math">
          <source>Round a number to an integer by using a specified rounding convention.</source>
          <target state="translated">Redondear un número en un entero utilizando un redondeo convención.</target>       </trans-unit>
        <trans-unit id="610" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Math">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="611" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Math">
          <source>Round a number to a specified number of fractional digits by using the rounding to nearest convention.</source>
          <target state="translated">Redondear un número a un número especificado de dígitos fraccionarios utilizando el redondeo al más cercano convención.</target>       </trans-unit>
        <trans-unit id="612" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Math">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="613" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Math">
          <source>Round a number to a specified number of fractional digits by using a specified rounding convention.</source>
          <target state="translated">Redondear un número al número especificado de dígitos fraccionarios utilizando un redondeo convención.</target>       </trans-unit>
        <trans-unit id="614" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Math">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="615" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Math">
          <source>Round a <ph id="ph1">&lt;xref:System.Single&gt;</ph> value to a specified number of fractional digits by using a specified rounding convention and minimizing the loss of precision.</source>
          <target state="translated">Redondear un <ph id="ph1">&lt;xref:System.Single&gt;</ph> valor a un número especificado de dígitos fraccionarios mediante una convención de redondeo especificado y minimiza las pérdidas de precisión.</target>       </trans-unit>
        <trans-unit id="616" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Math">
          <source>Convert the <ph id="ph1">&lt;xref:System.Single&gt;</ph> to a <ph id="ph2">&lt;xref:System.Decimal&gt;</ph> and call <ph id="ph3">&lt;xref:System.Math.Round%28System.Decimal%2CSystem.Int32%2CSystem.MidpointRounding%29&gt;</ph>.</source>
          <target state="translated">Convertir el <ph id="ph1">&lt;xref:System.Single&gt;</ph> a una <ph id="ph2">&lt;xref:System.Decimal&gt;</ph> y llame a <ph id="ph3">&lt;xref:System.Math.Round%28System.Decimal%2CSystem.Int32%2CSystem.MidpointRounding%29&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="617" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Math">
          <source>Round a number to a specified number of fractional digits while minimizing problems of precision in rounding midpoint values.</source>
          <target state="translated">Redondear un número a un número especificado de dígitos fraccionarios y minimizar los problemas de precisión en los valores de punto medio de redondeo.</target>       </trans-unit>
        <trans-unit id="618" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Math">
          <source>Call a rounding method that implements a "greater than or approximately equal to" comparison.</source>
          <target state="translated">Llamar a un método de redondeo que implementa una comparación "mayor que o aproximadamente igual a".</target>       </trans-unit>
        <trans-unit id="619" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Math">
          <source>See <bpt id="p1">[</bpt>Rounding and precision<ept id="p1">](#Precision)</ept>.</source>
          <target state="translated">Vea <bpt id="p1">[</bpt>redondeo y la precisión<ept id="p1">](#Precision)</ept>.</target>       </trans-unit>
        <trans-unit id="620" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Math">
          <source>Round a fractional value to an integer that is greater than the fractional value.</source>
          <target state="translated">Redondear un valor fraccionario en un entero que es mayor que el valor de fracciones.</target>       </trans-unit>
        <trans-unit id="621" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Math">
          <source>For example, round 3.1 to 4.</source>
          <target state="translated">Por ejemplo, redondear 3.1 a 4.</target>       </trans-unit>
        <trans-unit id="622" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Math">
          <source>Round a fractional value to an integer that is less than the fractional value.</source>
          <target state="translated">Redondear un valor fraccionario en un entero que es menor que el valor de fracciones.</target>       </trans-unit>
        <trans-unit id="623" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Math">
          <source>For example, round 3.9 to 3.</source>
          <target state="translated">Por ejemplo, redondear 3.9 a 3.</target>       </trans-unit>
        <trans-unit id="624" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Math">
          <source>Midpoint values and rounding conventions</source>
          <target state="translated">Valores de punto medio y convenciones de redondeo</target>       </trans-unit>
        <trans-unit id="625" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Math">
          <source>Rounding involves converting a numeric value with a specified precision to the nearest value with less precision.</source>
          <target state="translated">Redondeo implica convertir un valor numérico con una precisión especificada para el valor más próximo con menos precisión.</target>       </trans-unit>
        <trans-unit id="626" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Math">
          <source>For example, you can use the <ph id="ph1">&lt;xref:System.Math.Round%28System.Double%29&gt;</ph> method to round a value of 3.4 to 3.0, and the <ph id="ph2">&lt;xref:System.Math.Round%28System.Double%2CSystem.Int32%29&gt;</ph> method to round a value of 3.579 to 3.58.</source>
          <target state="translated">Por ejemplo, puede usar el <ph id="ph1">&lt;xref:System.Math.Round%28System.Double%29&gt;</ph> método para redondear un valor de 3.4 a 3.0 y el <ph id="ph2">&lt;xref:System.Math.Round%28System.Double%2CSystem.Int32%29&gt;</ph> método para redondear un valor de 3,579 a 3,58.</target>       </trans-unit>
        <trans-unit id="627" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Math">
          <source>In a midpoint value, the value after the least significant digit in the result is precisely half way between two numbers.</source>
          <target state="translated">Un valor de punto medio, el valor después de los dígitos menos significativos en el resultado es precisamente mitad de camino entre dos números.</target>       </trans-unit>
        <trans-unit id="628" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Math">
          <source>For example, 3.47500 is a midpoint value if it is to be rounded two decimal places, and 7.500 is a midpoint value if it is to be rounded to an integer.</source>
          <target state="translated">Por ejemplo, 3.47500 es un valor de punto medio si no redondea a dos posiciones decimales y 7.500 es un valor de punto medio si no se redondea a un entero.</target>       </trans-unit>
        <trans-unit id="629" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Math">
          <source>In these cases, the nearest value can't be easily identified without a rounding convention.</source>
          <target state="translated">En estos casos, el valor más cercano no se puede identificar fácilmente sin una convención de redondeo.</target>       </trans-unit>
        <trans-unit id="630" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Math">
          <source>The <ph id="ph1">&lt;xref:System.Math.Round%2A&gt;</ph> method supports two rounding conventions for handling midpoint values:</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.Math.Round%2A&gt;</ph> método es compatible con dos convenciones de redondeo para controlar los valores de punto medio:</target>       </trans-unit>
        <trans-unit id="631" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Math">
          <source><bpt id="p1">**</bpt>Rounding away from zero<ept id="p1">**</ept></source>
          <target state="translated"><bpt id="p1">**</bpt>Redondeo para evitar el cero<ept id="p1">**</ept></target>       </trans-unit>
        <trans-unit id="632" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Math">
          <source>Midpoint values are rounded to the next number away from zero.</source>
          <target state="translated">Los valores de punto medio se redondean al siguiente número de dirección contraria a cero.</target>       </trans-unit>
        <trans-unit id="633" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Math">
          <source>For example, 3.75 rounds to 3.8, 3.85 rounds to 3.9, -3.75 rounds to -3.8, and -3.85 rounds to -3.9.</source>
          <target state="translated">Por ejemplo, se redondea 3,75 a 3.8, 3.85 se redondeará a 3.9,-3.75 se redondea a-3.8, y-3.85 se redondea a-3.9.</target>       </trans-unit>
        <trans-unit id="634" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Math">
          <source>This form of rounding is represented by the <ph id="ph1">&lt;xref:System.MidpointRounding.AwayFromZero?displayProperty=nameWithType&gt;</ph> enumeration member.</source>
          <target state="translated">Esta forma de redondeo es representada por la <ph id="ph1">&lt;xref:System.MidpointRounding.AwayFromZero?displayProperty=nameWithType&gt;</ph> miembro de enumeración.</target>       </trans-unit>
        <trans-unit id="635" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Math">
          <source>Rounding away from zero is the most widely known form of rounding.</source>
          <target state="translated">Redondeo para evitar el cero es la forma más ampliamente conocida de redondeo.</target>       </trans-unit>
        <trans-unit id="636" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Math">
          <source><bpt id="p1">**</bpt>Rounding to nearest, or banker's rounding<ept id="p1">**</ept></source>
          <target state="translated"><bpt id="p1">**</bpt>Redondeo al más próximo o redondeo bancario<ept id="p1">**</ept></target>       </trans-unit>
        <trans-unit id="637" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Math">
          <source>Midpoint values are rounded to the nearest even number.</source>
          <target state="translated">Los valores de punto medio se redondean al número par más cercano.</target>       </trans-unit>
        <trans-unit id="638" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Math">
          <source>For example, both 3.75 and 3.85 round to 3.8, and both -3.75 and -3.85 round to -3.8.</source>
          <target state="translated">Por ejemplo, redondear 3.8 3,75 y 3.85 y-3.75 y-3.85 de ida y vuelta a-3.8.</target>       </trans-unit>
        <trans-unit id="639" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Math">
          <source>This form of rounding is represented by the <ph id="ph1">&lt;xref:System.MidpointRounding.ToEven?displayProperty=nameWithType&gt;</ph> enumeration member.</source>
          <target state="translated">Esta forma de redondeo es representada por la <ph id="ph1">&lt;xref:System.MidpointRounding.ToEven?displayProperty=nameWithType&gt;</ph> miembro de enumeración.</target>       </trans-unit>
        <trans-unit id="640" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Math">
          <source>Rounding to nearest is the standard form of rounding used in financial and statistical operations.</source>
          <target state="translated">Redondeo al más cercano es la forma estándar de redondeo utilizado en las operaciones financieras y estadísticas.</target>       </trans-unit>
        <trans-unit id="641" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Math">
          <source>It conforms to IEEE Standard 754, section 4.</source>
          <target state="translated">Se ajusta al estándar IEEE 754, sección 4.</target>       </trans-unit>
        <trans-unit id="642" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Math">
          <source>When used in multiple rounding operations, it reduces the rounding error that is caused by consistently rounding midpoint values in a single direction.</source>
          <target state="translated">Cuando se utiliza en varias operaciones de redondeo, reduce el error de redondeo que se debe a los valores de punto medio en una dirección única de redondear de forma consistente.</target>       </trans-unit>
        <trans-unit id="643" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Math">
          <source>In some cases, this rounding error can be significant.</source>
          <target state="translated">En algunos casos, este error de redondeo puede ser significativo.</target>       </trans-unit>
        <trans-unit id="644" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Math">
          <source>The following example illustrates the bias that can result from consistently rounding midpoint values in a single direction.</source>
          <target state="translated">En el ejemplo siguiente se muestra la diferencia que puede derivarse de redondear de forma consistente los valores de punto medio en una dirección única.</target>       </trans-unit>
        <trans-unit id="645" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Math">
          <source>The example computes the true mean of an array of <ph id="ph1">&lt;xref:System.Decimal&gt;</ph> values, and then computes the mean when the values in the array are rounded by using the two conventions.</source>
          <target state="translated">En el ejemplo se calcula la verdadera Media de una matriz de <ph id="ph1">&lt;xref:System.Decimal&gt;</ph> valores y, a continuación, calcula la media cuando los valores de la matriz se redondean usando las convenciones de dos.</target>       </trans-unit>
        <trans-unit id="646" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Math">
          <source>In this example, the true mean and the mean that results when rounding to nearest are the same.</source>
          <target state="translated">En este ejemplo, la verdadera Media y la media resultante cuando se redondea al entero más próximo son los mismos.</target>       </trans-unit>
        <trans-unit id="647" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Math">
          <source>However, the mean that results when rounding away from zero differs by .05 (or by 3.6%) from the true mean.</source>
          <target state="translated">Sin embargo, el promedio que se produce cuando el redondeo para evitar el cero difiere.05 (o 3,6%) de la verdadera Media.</target>       </trans-unit>
        <trans-unit id="648" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Math">
          <source>By default, the <ph id="ph1">&lt;xref:System.Math.Round%2A&gt;</ph> method uses the rounding to nearest convention.</source>
          <target state="translated">De forma predeterminada, la <ph id="ph1">&lt;xref:System.Math.Round%2A&gt;</ph> método utiliza el redondeo al más cercano convención.</target>       </trans-unit>
        <trans-unit id="649" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Math">
          <source>The following table lists the overloads of the <ph id="ph1">&lt;xref:System.Math.Round%2A&gt;</ph> method and the rounding convention that each uses.</source>
          <target state="translated">En la tabla siguiente se enumera las sobrecargas de los <ph id="ph1">&lt;xref:System.Math.Round%2A&gt;</ph> método y la convención de redondeo que se usa cada uno.</target>       </trans-unit>
        <trans-unit id="650" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Math">
          <source>Overload</source>
          <target state="translated">Sobrecarga</target>       </trans-unit>
        <trans-unit id="651" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Math">
          <source>Rounding convention</source>
          <target state="translated">Convención de redondeo</target>       </trans-unit>
        <trans-unit id="652" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Math">
          <source>Determined by <ph id="ph1">`mode`</ph> parameter.</source>
          <target state="translated">Determinado por <ph id="ph1">`mode`</ph> parámetro.</target>       </trans-unit>
        <trans-unit id="653" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Math">
          <source>Determined by <ph id="ph1">`mode`</ph> parameter</source>
          <target state="translated">Determinado por <ph id="ph1">`mode`</ph> parámetro</target>       </trans-unit>
        <trans-unit id="654" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Math">
          <source>Determined by <ph id="ph1">`mode`</ph> parameter</source>
          <target state="translated">Determinado por <ph id="ph1">`mode`</ph> parámetro</target>       </trans-unit>
        <trans-unit id="655" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Math">
          <source>Determined by <ph id="ph1">`mode`</ph> parameter</source>
          <target state="translated">Determinado por <ph id="ph1">`mode`</ph> parámetro</target>       </trans-unit>
        <trans-unit id="656" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Math">
          <source>Rounding and precision</source>
          <target state="translated">Redondeo y la precisión</target>       </trans-unit>
        <trans-unit id="657" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Math">
          <source>In order to determine whether a rounding operation involves a midpoint value, the <ph id="ph1">&lt;xref:System.Math.Round%2A&gt;</ph> method multiplies the original value to be rounded by 10<bpt id="p1">&lt;sup&gt;</bpt>n<ept id="p1">&lt;/sup&gt;</ept>, where <bpt id="p2">*</bpt>n<ept id="p2">*</ept> is the desired number of fractional digits in the return value, and then determines whether the remaining fractional portion of the value is greater than or equal to .5.</source>
          <target state="translated">Para determinar si una operación de redondeo implica un valor de punto medio, el <ph id="ph1">&lt;xref:System.Math.Round%2A&gt;</ph> método multiplica el valor original se redondea por 10<bpt id="p1">&lt;sup&gt;</bpt>n<ept id="p1">&lt;/sup&gt;</ept>, donde <bpt id="p2">*</bpt>n<ept id="p2">*</ept> es el número deseado de fracciones dígitos en el valor devuelto y, a continuación, determina si la parte fraccionaria restante del valor es mayor o igual que.5.</target>       </trans-unit>
        <trans-unit id="658" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Math">
          <source>This is a slight variation on a test for equality, and as discussed in the "Testing for Equality" section of the <ph id="ph1">&lt;xref:System.Double&gt;</ph> reference topic, tests for equality with floating-point values are problematic because of the floating-point format's issues with binary representation and precision.</source>
          <target state="translated">Se trata de una ligera variación en una prueba de igualdad y como hemos explicado en la sección "Probar la igualdad" de la <ph id="ph1">&lt;xref:System.Double&gt;</ph> tema de referencia, debido a problemas de formato de punto flotante con binario es problemático comprueba la igualdad con valores de punto flotante representación y precisión.</target>       </trans-unit>
        <trans-unit id="659" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Math">
          <source>This means that any fractional portion of a number that is slightly less than .5 (because of a loss of precision) will not be rounded upward.</source>
          <target state="translated">Esto significa que cualquier parte fraccionaria de un número que es un poco menos de.5 (debido a una pérdida de precisión) no se redondeará hacia arriba.</target>       </trans-unit>
        <trans-unit id="660" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Math">
          <source>The following example illustrates the problem.</source>
          <target state="translated">En el siguiente ejemplo se ilustra el problema.</target>       </trans-unit>
        <trans-unit id="661" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Math">
          <source>It repeatedly adds .1 to 11.0 and rounds the result to the nearest integer.</source>
          <target state="translated">Repetidamente agrega.1 a 11.0 y redondea el resultado al entero más próximo.</target>       </trans-unit>
        <trans-unit id="662" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Math">
          <source>Regardless of the rounding convention, 11.5 should round to 12.</source>
          <target state="translated">Independientemente de la convención de redondeo, se deben redondear 11,5 a 12.</target>       </trans-unit>
        <trans-unit id="663" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Math">
          <source>However, as the output from the example shows, it does not.</source>
          <target state="translated">Sin embargo, como la salida se muestra en el ejemplo, no la tiene.</target>       </trans-unit>
        <trans-unit id="664" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Math">
          <source>The example uses the "R" <bpt id="p1">[</bpt>standard numeric format string<ept id="p1">](~/docs/standard/base-types/standard-numeric-format-strings.md)</ept> to display the floating point value's full precision, and shows that the value to be rounded has lost precision during repeated additions, and its value is actually 11.499999999999998.</source>
          <target state="translated">En el ejemplo se utiliza la "R" <bpt id="p1">[</bpt>cadena de formato numérico estándar<ept id="p1">](~/docs/standard/base-types/standard-numeric-format-strings.md)</ept> para mostrar el de punto flotante del valor precisión completa y se muestra que el valor se redondea ha perdido la precisión durante repetidas adiciones y su valor es realmente 11.499999999999998.</target>       </trans-unit>
        <trans-unit id="665" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Math">
          <source>Because .499999999999998 is less than .5, the value is not rounded to the next highest integer.</source>
          <target state="translated">Dado que.499999999999998 es menor que.5, el valor no se redondea al entero más alto siguiente.</target>       </trans-unit>
        <trans-unit id="666" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Math">
          <source>As the example also shows, this problem does not occur if we simply assign the constant value 11.5 to a <ph id="ph1">&lt;xref:System.Double&gt;</ph> variable.</source>
          <target state="translated">Como también se muestra en el ejemplo, este problema no ocurre si simplemente se asigna el valor constante 11,5 a un <ph id="ph1">&lt;xref:System.Double&gt;</ph> variable.</target>       </trans-unit>
        <trans-unit id="667" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Math">
          <source>Problems of precision in rounding midpoint values are most likely to arise in the following conditions:</source>
          <target state="translated">Problemas de precisión en los valores de punto medio de redondeo están más probables que surgen en las condiciones siguientes:</target>       </trans-unit>
        <trans-unit id="668" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Math">
          <source>When a fractional value cannot be expressed precisely in the floating-point type's binary format.</source>
          <target state="translated">Cuando un valor fraccionario no puedan expresarse con precisión en formato binario del tipo de punto flotante.</target>       </trans-unit>
        <trans-unit id="669" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Math">
          <source>When the value to be rounded is calculated from one or more floating-point operations.</source>
          <target state="translated">Cuando el valor se redondea se calcula a partir de una o varias operaciones de punto flotante.</target>       </trans-unit>
        <trans-unit id="670" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Math">
          <source>When the value to be rounded is a <ph id="ph1">&lt;xref:System.Single&gt;</ph> rather than a <ph id="ph2">&lt;xref:System.Double&gt;</ph> or <ph id="ph3">&lt;xref:System.Decimal&gt;</ph>.</source>
          <target state="translated">Cuando el valor se redondea es un <ph id="ph1">&lt;xref:System.Single&gt;</ph> en lugar de un <ph id="ph2">&lt;xref:System.Double&gt;</ph> o <ph id="ph3">&lt;xref:System.Decimal&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="671" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Math">
          <source>For more information, see the next section, <bpt id="p1">[</bpt>Rounding and single-precision floating-point values<ept id="p1">](#Single)</ept>.</source>
          <target state="translated">Para obtener más información, vea la sección siguiente, <bpt id="p1">[</bpt>redondear y valores de punto flotante de precisión sencilla<ept id="p1">](#Single)</ept>.</target>       </trans-unit>
        <trans-unit id="672" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Math">
          <source>In cases where the lack of precision in rounding operations is problematic, you can do the following:</source>
          <target state="translated">En casos donde la falta de precisión en las operaciones de redondeo es problemática, puede hacer lo siguiente:</target>       </trans-unit>
        <trans-unit id="673" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Math">
          <source>If the rounding operation calls an overload that rounds a <ph id="ph1">&lt;xref:System.Double&gt;</ph> value, you can change the <ph id="ph2">&lt;xref:System.Double&gt;</ph> to a <ph id="ph3">&lt;xref:System.Decimal&gt;</ph> value and call an overload that rounds a <ph id="ph4">&lt;xref:System.Decimal&gt;</ph> value instead.</source>
          <target state="translated">Si la operación de redondeo llama a una sobrecarga que redondea un <ph id="ph1">&lt;xref:System.Double&gt;</ph> valor, puede cambiar la <ph id="ph2">&lt;xref:System.Double&gt;</ph> a una <ph id="ph3">&lt;xref:System.Decimal&gt;</ph> valor y llamar a una sobrecarga que redondea un <ph id="ph4">&lt;xref:System.Decimal&gt;</ph> valor en su lugar.</target>       </trans-unit>
        <trans-unit id="674" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Math">
          <source>Although the <ph id="ph1">&lt;xref:System.Decimal&gt;</ph> data type also has problems of representation and loss of precision, these issues are far less common.</source>
          <target state="translated">Aunque el <ph id="ph1">&lt;xref:System.Decimal&gt;</ph> también tiene el tipo de datos de problemas de representación y la pérdida de precisión, estos problemas son mucho menos comunes.</target>       </trans-unit>
        <trans-unit id="675" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Math">
          <source>Define a custom rounding algorithm that performs a "nearly equal" test to determine whether the value to be rounded is acceptably close to a midpoint value.</source>
          <target state="translated">Definir un algoritmo personalizado de redondeo que se realiza una prueba de "casi igual a" para determinar si el valor se redondea es aceptablemente cerca de un valor de punto medio.</target>       </trans-unit>
        <trans-unit id="676" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Math">
          <source>The following example defines a <ph id="ph1">`RoundApproximate`</ph> method that examines whether a fractional value is sufficiently near to a midpoint value to be subject to midpoint rounding.</source>
          <target state="translated">En el ejemplo siguiente se define un <ph id="ph1">`RoundApproximate`</ph> método que busca para determinar si un valor fraccionario es lo suficientemente cerca de un valor de punto medio a estar sujeto a redondeo de punto medio.</target>       </trans-unit>
        <trans-unit id="677" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Math">
          <source>As the output from the example shows, it corrects the rounding problem shown in the previous example.</source>
          <target state="translated">Como se muestra en el resultado del ejemplo, corrige el problema de redondeo que se muestra en el ejemplo anterior.</target>       </trans-unit>
        <trans-unit id="678" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Math">
          <source>Rounding and single-precision floating-point values</source>
          <target state="translated">Valores de punto flotante de precisión sencilla y redondeo</target>       </trans-unit>
        <trans-unit id="679" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Math">
          <source>The <ph id="ph1">&lt;xref:System.Math.Round%2A&gt;</ph> method includes overloads that accept arguments of type <ph id="ph2">&lt;xref:System.Decimal&gt;</ph> and <ph id="ph3">&lt;xref:System.Double&gt;</ph>.</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.Math.Round%2A&gt;</ph> método incluye sobrecargas que aceptan argumentos de tipo <ph id="ph2">&lt;xref:System.Decimal&gt;</ph> y <ph id="ph3">&lt;xref:System.Double&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="680" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Math">
          <source>There are no methods that round values of type <ph id="ph1">&lt;xref:System.Single&gt;</ph>.</source>
          <target state="translated">No existen métodos que los valores de tipo de ida y vuelta <ph id="ph1">&lt;xref:System.Single&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="681" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Math">
          <source>If you pass a <ph id="ph1">&lt;xref:System.Single&gt;</ph> value to one of the overloads of the <ph id="ph2">&lt;xref:System.Math.Round%2A&gt;</ph> method, it is cast (in C#) or converted (in Visual Basic) to a <ph id="ph3">&lt;xref:System.Double&gt;</ph>, and the corresponding <ph id="ph4">&lt;xref:System.Math.Round%2A&gt;</ph> overload with a <ph id="ph5">&lt;xref:System.Double&gt;</ph> parameter is called.</source>
          <target state="translated">Si se pasa un <ph id="ph1">&lt;xref:System.Single&gt;</ph> valor a una de las sobrecargas de la <ph id="ph2">&lt;xref:System.Math.Round%2A&gt;</ph> método, se convierte (en C#) o se convierte (en Visual Basic) a un <ph id="ph3">&lt;xref:System.Double&gt;</ph>y las correspondientes <ph id="ph4">&lt;xref:System.Math.Round%2A&gt;</ph> se puede sobrecargar con un <ph id="ph5">&lt;xref:System.Double&gt;</ph> parámetro se denomina.</target>       </trans-unit>
        <trans-unit id="682" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Math">
          <source>Although this is a widening conversion, it often involves a loss of precision, as the following example illustrates.</source>
          <target state="translated">Aunque se trata de una conversión de ampliación, suele implicar una pérdida de precisión, como se muestra en el ejemplo siguiente.</target>       </trans-unit>
        <trans-unit id="683" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Math">
          <source>When a <ph id="ph1">&lt;xref:System.Single&gt;</ph> value of 16.325 is passed to the <ph id="ph2">&lt;xref:System.Math.Round%2A&gt;</ph> method and rounded to two decimal places using the rounding to nearest convention, the result is 16.33 and not the expected result of 16.32.</source>
          <target state="translated">Cuando un <ph id="ph1">&lt;xref:System.Single&gt;</ph> valor de 16.325 se pasa a la <ph id="ph2">&lt;xref:System.Math.Round%2A&gt;</ph> método y redondea a dos posiciones decimales mediante el redondeo al más cercano convención, el resultado es el resultado de 16.33 y no esperado de 16.32.</target>       </trans-unit>
        <trans-unit id="684" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Math">
          <source>This unexpected result is due to a loss of precision in the conversion of the <ph id="ph1">&lt;xref:System.Single&gt;</ph> value to a <ph id="ph2">&lt;xref:System.Double&gt;</ph>.</source>
          <target state="translated">Este resultado inesperado es debido a la pérdida de precisión en la conversión de la <ph id="ph1">&lt;xref:System.Single&gt;</ph> valor a un <ph id="ph2">&lt;xref:System.Double&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="685" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Math">
          <source>Because the resulting <ph id="ph1">&lt;xref:System.Double&gt;</ph> value of 16.325000762939453 is not a midpoint value and is greater than 16.325, it is always rounded upward.</source>
          <target state="translated">Dado que los resultantes <ph id="ph1">&lt;xref:System.Double&gt;</ph> valor de 16.325000762939453 no es un valor de punto medio y es mayor que 16.325, siempre se redondea hacia arriba.</target>       </trans-unit>
        <trans-unit id="686" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Math">
          <source>In many cases, as the example illustrates, the loss of precision can be minimized or eliminated by casting or converting the <ph id="ph1">&lt;xref:System.Single&gt;</ph> value to a <ph id="ph2">&lt;xref:System.Decimal&gt;</ph>.</source>
          <target state="translated">En muchos casos, como se muestra en el ejemplo, la pérdida de precisión puede minimizarse o eliminar mediante la conversión del <ph id="ph1">&lt;xref:System.Single&gt;</ph> valor a un <ph id="ph2">&lt;xref:System.Decimal&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="687" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Math">
          <source>Note that, because this is a narrowing conversion, it requires using a cast operator or calling a conversion method.</source>
          <target state="translated">Tenga en cuenta que, dado que se trata de una conversión de restricción, requiere utilizando un operador de conversión o llamar a un método de conversión.</target>       </trans-unit>
        <trans-unit id="688" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Math">
          <source>Math.Round(Decimal) example</source>
          <target state="translated">Ejemplo de Math.Round(Decimal)</target>       </trans-unit>
        <trans-unit id="689" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Math">
          <source>The following example demonstrates the <ph id="ph1">&lt;xref:System.Math.Round%28System.Decimal%29&gt;</ph> method.</source>
          <target state="translated">En el ejemplo siguiente se muestra el <ph id="ph1">&lt;xref:System.Math.Round%28System.Decimal%29&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="690" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Math">
          <source>Note that the <ph id="ph1">&lt;xref:System.Decimal&gt;</ph> value of 4.5 rounds to 4 rather than 5, because this overload uses the default <ph id="ph2">&lt;xref:System.MidpointRounding.ToEven&gt;</ph> convention.</source>
          <target state="translated">Tenga en cuenta que la <ph id="ph1">&lt;xref:System.Decimal&gt;</ph> valo 4.5 se redondea a 4 en lugar de 5, dado que esta sobrecarga utiliza el valor predeterminado <ph id="ph2">&lt;xref:System.MidpointRounding.ToEven&gt;</ph> convención.</target>       </trans-unit>
        <trans-unit id="691" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Math">
          <source>Math.Round(Double) example</source>
          <target state="translated">Ejemplo de Math.Round(Double)</target>       </trans-unit>
        <trans-unit id="692" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Math">
          <source>The following example demonstrates rounding to the nearest integer value.</source>
          <target state="translated">En el ejemplo siguiente se muestra el redondeo al valor entero más cercano.</target>       </trans-unit>
        <trans-unit id="693" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Math">
          <source>Math.Round(Decimal, Int32) example</source>
          <target state="translated">En el ejemplo se Math.Round (Decimal, Int32)</target>       </trans-unit>
        <trans-unit id="694" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Math">
          <source>The following example rounds decimal values with two fractional digits to values that have a single fractional digit.</source>
          <target state="translated">En el ejemplo siguiente se redondea los valores decimales con dos dígitos decimales a valores que tienen un único dígito fraccionario.</target>       </trans-unit>
        <trans-unit id="695" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Math">
          <source>Math.Round(Double, Int32) example</source>
          <target state="translated">Math.Round (Double, Int32) ejemplo</target>       </trans-unit>
        <trans-unit id="696" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Math">
          <source>The following example rounds double values with two fractional digits to doubles that have a single fractional digit.</source>
          <target state="translated">En el ejemplo siguiente se redondea valores double con dos dígitos decimales a valores de tipo Double que tienen un único dígito fraccionario.</target>       </trans-unit>
        <trans-unit id="697" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Math">
          <source>Math.Round(Decimal, MidpointRounding) example</source>
          <target state="translated">En el ejemplo se Math.Round (Decimal, MidpointRounding)</target>       </trans-unit>
        <trans-unit id="698" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Math">
          <source>The following example displays values returned by the <ph id="ph1">&lt;xref:System.Math.Round%28System.Decimal%29&gt;</ph> method, the <ph id="ph2">&lt;xref:System.Math.Round%28System.Decimal%2CSystem.MidpointRounding%29&gt;</ph> method with a <ph id="ph3">`mode`</ph> argument of <ph id="ph4">&lt;xref:System.MidpointRounding.ToEven&gt;</ph>, and the <ph id="ph5">&lt;xref:System.Math.Round%28System.Decimal%2CSystem.MidpointRounding%29&gt;</ph> method with a <ph id="ph6">`mode`</ph> argument of <ph id="ph7">&lt;xref:System.MidpointRounding.AwayFromZero&gt;</ph>.</source>
          <target state="translated">El ejemplo siguiente muestra los valores devueltos por la <ph id="ph1">&lt;xref:System.Math.Round%28System.Decimal%29&gt;</ph> método, el <ph id="ph2">&lt;xref:System.Math.Round%28System.Decimal%2CSystem.MidpointRounding%29&gt;</ph> método con un <ph id="ph3">`mode`</ph> argumento de <ph id="ph4">&lt;xref:System.MidpointRounding.ToEven&gt;</ph>y el <ph id="ph5">&lt;xref:System.Math.Round%28System.Decimal%2CSystem.MidpointRounding%29&gt;</ph> método con un <ph id="ph6">`mode`</ph> argumento de <ph id="ph7">&lt;xref:System.MidpointRounding.AwayFromZero&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="699" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Math">
          <source>Math.Round(Double, MidpointRounding) example</source>
          <target state="translated">Math.Round (Double, MidpointRounding) ejemplo</target>       </trans-unit>
        <trans-unit id="700" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Math">
          <source>The following example displays values returned by the <ph id="ph1">&lt;xref:System.Math.Round%28System.Double%29&gt;</ph> method, the <ph id="ph2">&lt;xref:System.Math.Round%28System.Double%2CSystem.MidpointRounding%29&gt;</ph> method with a <ph id="ph3">`mode`</ph> argument of <ph id="ph4">&lt;xref:System.MidpointRounding.ToEven&gt;</ph>, and the <ph id="ph5">&lt;xref:System.Math.Round%28System.Double%2CSystem.MidpointRounding%29&gt;</ph> method with a <ph id="ph6">`mode`</ph> argument of <ph id="ph7">&lt;xref:System.MidpointRounding.AwayFromZero&gt;</ph>.</source>
          <target state="translated">El ejemplo siguiente muestra los valores devueltos por la <ph id="ph1">&lt;xref:System.Math.Round%28System.Double%29&gt;</ph> método, el <ph id="ph2">&lt;xref:System.Math.Round%28System.Double%2CSystem.MidpointRounding%29&gt;</ph> método con un <ph id="ph3">`mode`</ph> argumento de <ph id="ph4">&lt;xref:System.MidpointRounding.ToEven&gt;</ph>y el <ph id="ph5">&lt;xref:System.Math.Round%28System.Double%2CSystem.MidpointRounding%29&gt;</ph> método con un <ph id="ph6">`mode`</ph> argumento de <ph id="ph7">&lt;xref:System.MidpointRounding.AwayFromZero&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="701" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Math">
          <source>Math.Round(Decimal, Int32, MidpointRounding) example</source>
          <target state="translated">En el ejemplo se Math.Round (Int32, Decimal MidpointRounding)</target>       </trans-unit>
        <trans-unit id="702" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Math">
          <source>The following example demonstrates how to use the <ph id="ph1">&lt;xref:System.Math.Round%2A&gt;</ph> method with the <ph id="ph2">&lt;xref:System.MidpointRounding&gt;</ph> enumeration.</source>
          <target state="translated">En el ejemplo siguiente se muestra cómo utilizar el <ph id="ph1">&lt;xref:System.Math.Round%2A&gt;</ph> método con el <ph id="ph2">&lt;xref:System.MidpointRounding&gt;</ph> enumeración.</target>       </trans-unit>
        <trans-unit id="703" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Math">
          <source>Math.Round(Double, Int32, MidpointRounding) example</source>
          <target state="translated">En el ejemplo se Math.Round (Double, Int32, MidpointRounding)</target>       </trans-unit>
        <trans-unit id="704" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Math">
          <source>The following example demonstrates how to use the <ph id="ph1">&lt;xref:System.Math.Round%28System.Double%2CSystem.Int32%2CSystem.MidpointRounding%29&gt;</ph> method with the <ph id="ph2">&lt;xref:System.MidpointRounding&gt;</ph> enumeration.</source>
          <target state="translated">En el ejemplo siguiente se muestra cómo utilizar el <ph id="ph1">&lt;xref:System.Math.Round%28System.Double%2CSystem.Int32%2CSystem.MidpointRounding%29&gt;</ph> método con el <ph id="ph2">&lt;xref:System.MidpointRounding&gt;</ph> enumeración.</target>       </trans-unit>
        <trans-unit id="705" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Math">
          <source>Version information</source>
          <target state="translated">Información de versión</target>       </trans-unit>
        <trans-unit id="706" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Math">
          <source>.NET Framework</source>
          <target state="translated">.NET Framework</target>       </trans-unit>
        <trans-unit id="707" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Math">
          <source>Overloads without a <ph id="ph1">&lt;xref:System.MidpointRounding&gt;</ph> parameter are supported in: 4.5, 4, 3.5, 3.0, 2.0, 1.1, 1.0</source>
          <target state="translated">Sobrecargas sin un <ph id="ph1">&lt;xref:System.MidpointRounding&gt;</ph> parámetro se admite en: 4.5, 4, 3.5, 3.0, 2.0, 1.1, 1.0</target>       </trans-unit>
        <trans-unit id="708" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Math">
          <source>Overloads with a <ph id="ph1">&lt;xref:System.MidpointRounding&gt;</ph> parameter are supported in: 4.5, 4, 3.5, 3.0, 2.0</source>
          <target state="translated">Sobrecargas con un <ph id="ph1">&lt;xref:System.MidpointRounding&gt;</ph> parámetro se admite en: 4.5, 4, 3.5, 3.0, 2.0</target>       </trans-unit>
        <trans-unit id="709" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Math">
          <source>.NET Framework Client Profile</source>
          <target state="translated">.NET Framework Client Profile</target>       </trans-unit>
        <trans-unit id="710" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Math">
          <source>All overloads are supported in: 4, 3.5 SP1</source>
          <target state="translated">Se admiten todas las sobrecargas en: 4, 3.5 SP1</target>       </trans-unit>
        <trans-unit id="711" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Math">
          <source>Portable Class Library</source>
          <target state="translated">Biblioteca de clases portable</target>       </trans-unit>
        <trans-unit id="712" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Math">
          <source>All overloads are supported</source>
          <target state="translated">Se admiten todas las sobrecargas</target>       </trans-unit>
        <trans-unit id="713" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Math">
          <source>.NET for Windows Store apps</source>
          <target state="translated">.NET para aplicaciones de la Tienda Windows</target>       </trans-unit>
        <trans-unit id="714" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Math">
          <source>All overloads are supported in: Windows 8</source>
          <target state="translated">Se admiten todas las sobrecargas en: Windows 8</target>       </trans-unit>
        <trans-unit id="715" translate="yes" xml:space="preserve" uid="M:System.Math.Round(System.Decimal)">
          <source>A decimal number to be rounded.</source>
          <target state="translated">Número decimal que se va a redondear.</target>       </trans-unit>
        <trans-unit id="716" translate="yes" xml:space="preserve" uid="M:System.Math.Round(System.Decimal)">
          <source>Rounds a decimal value to the nearest integral value.</source>
          <target state="translated">Redondea un valor decimal al valor integral más próximo.</target>       </trans-unit>
        <trans-unit id="717" translate="yes" xml:space="preserve" uid="M:System.Math.Round(System.Decimal)">
          <source>The integer nearest parameter <ph id="ph1">&lt;paramref name="d" /&gt;</ph>.</source>
          <target state="translated">Parámetro <ph id="ph1">&lt;paramref name="d" /&gt;</ph> del entero más cercano.</target>       </trans-unit>
        <trans-unit id="718" translate="yes" xml:space="preserve" uid="M:System.Math.Round(System.Decimal)">
          <source>If the fractional component of <ph id="ph1">&lt;paramref name="d" /&gt;</ph> is halfway between two integers, one of which is even and the other odd, the even number is returned.</source>
          <target state="translated">Si el componente fraccionario de <ph id="ph1">&lt;paramref name="d" /&gt;</ph> se encuentra en medio del intervalo entre dos números, uno par y el otro impar, se devuelve el número impar.</target>       </trans-unit>
        <trans-unit id="719" translate="yes" xml:space="preserve" uid="M:System.Math.Round(System.Decimal)">
          <source>Note that this method returns a <ph id="ph1">&lt;see cref="T:System.Decimal" /&gt;</ph> instead of an integral type.</source>
          <target state="translated">Tenga en cuenta que este método devuelve un valor <ph id="ph1">&lt;see cref="T:System.Decimal" /&gt;</ph> en lugar de un tipo entero.</target>       </trans-unit>
        <trans-unit id="720" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Math.Round(System.Decimal)">
          <source>For examples and comprehensive usage information about this and other overloads of the <ph id="ph1">`Round`</ph> method, see the <ph id="ph2">&lt;xref:System.Math.Round%2A&gt;</ph> reference page.</source>
          <target state="translated">Para obtener ejemplos y la información de uso completa acerca de ésta y otras sobrecargas de la <ph id="ph1">`Round`</ph> método, consulte la <ph id="ph2">&lt;xref:System.Math.Round%2A&gt;</ph> página de referencia.</target>       </trans-unit>
        <trans-unit id="721" translate="yes" xml:space="preserve" uid="M:System.Math.Round(System.Decimal)">
          <source>The result is outside the range of a <ph id="ph1">&lt;see cref="T:System.Decimal" /&gt;</ph>.</source>
          <target state="translated">El resultado está fuera del intervalo de <ph id="ph1">&lt;see cref="T:System.Decimal" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="722" translate="yes" xml:space="preserve" uid="M:System.Math.Round(System.Double)">
          <source>A double-precision floating-point number to be rounded.</source>
          <target state="translated">Número de punto flotante de precisión doble que se va a redondear.</target>       </trans-unit>
        <trans-unit id="723" translate="yes" xml:space="preserve" uid="M:System.Math.Round(System.Double)">
          <source>Rounds a double-precision floating-point value to the nearest integral value.</source>
          <target state="translated">Redondea un valor de punto flotante de precisión doble al valor integral más cercano.</target>       </trans-unit>
        <trans-unit id="724" translate="yes" xml:space="preserve" uid="M:System.Math.Round(System.Double)">
          <source>The integer nearest <ph id="ph1">&lt;paramref name="a" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="a" /&gt;</ph> entero más cercano.</target>       </trans-unit>
        <trans-unit id="725" translate="yes" xml:space="preserve" uid="M:System.Math.Round(System.Double)">
          <source>If the fractional component of <ph id="ph1">&lt;paramref name="a" /&gt;</ph> is halfway between two integers, one of which is even and the other odd, then the even number is returned.</source>
          <target state="translated">Si el componente fraccionario de <ph id="ph1">&lt;paramref name="a" /&gt;</ph> se encuentra en medio del intervalo entre dos números, uno par y el otro impar, se devuelve el número impar.</target>       </trans-unit>
        <trans-unit id="726" translate="yes" xml:space="preserve" uid="M:System.Math.Round(System.Double)">
          <source>Note that this method returns a <ph id="ph1">&lt;see cref="T:System.Double" /&gt;</ph> instead of an integral type.</source>
          <target state="translated">Tenga en cuenta que este método devuelve un valor <ph id="ph1">&lt;see cref="T:System.Double" /&gt;</ph> en lugar de un tipo entero.</target>       </trans-unit>
        <trans-unit id="727" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Math.Round(System.Double)">
          <source>For examples and comprehensive usage information about this and other overloads of the <ph id="ph1">`Round`</ph> method, see the <ph id="ph2">&lt;xref:System.Math.Round%2A&gt;</ph> reference page.</source>
          <target state="translated">Para obtener ejemplos y la información de uso completa acerca de ésta y otras sobrecargas de la <ph id="ph1">`Round`</ph> método, consulte la <ph id="ph2">&lt;xref:System.Math.Round%2A&gt;</ph> página de referencia.</target>       </trans-unit>
        <trans-unit id="728" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Math.Round(System.Double)">
          <source>Because of the loss of precision that can result from representing decimal values as floating-point numbers or performing arithmetic operations on floating-point values, in some cases the <ph id="ph1">&lt;see cref="M:System.Math.Round(System.Double)" /&gt;</ph> method may not appear to round midpoint values to the nearest even integer.</source>
          <target state="translated">Debido a la pérdida de precisión que puede obtenerse al que representa los valores decimales como números de punto flotante o realizar operaciones aritméticas en valores de punto flotante, en algunos casos el <ph id="ph1">&lt;see cref="M:System.Math.Round(System.Double)" /&gt;</ph> método no puede aparecer redondear los valores de punto medio en el entero par más próximo.</target>       </trans-unit>
        <trans-unit id="729" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Math.Round(System.Double)">
          <source>In the following example, because the floating-point value .1 has no finite binary representation, the first call to the <ph id="ph1">&lt;see cref="M:System.Math.Round(System.Double)" /&gt;</ph> method with a value of 11.5 returns 11 instead of 12.</source>
          <target state="translated">En el ejemplo siguiente, porque el valor de punto flotante.1 no tiene ninguna representación binaria finita, la primera llamada a la <ph id="ph1">&lt;see cref="M:System.Math.Round(System.Double)" /&gt;</ph> método con un valor de 11,5 devuelve 11 en lugar de 12.</target>       </trans-unit>
        <trans-unit id="730" translate="yes" xml:space="preserve" uid="M:System.Math.Round(System.Decimal,System.Int32)">
          <source>A decimal number to be rounded.</source>
          <target state="translated">Número decimal que se va a redondear.</target>       </trans-unit>
        <trans-unit id="731" translate="yes" xml:space="preserve" uid="M:System.Math.Round(System.Decimal,System.Int32)">
          <source>The number of decimal places in the return value.</source>
          <target state="translated">Número de posiciones decimales del valor devuelto.</target>       </trans-unit>
        <trans-unit id="732" translate="yes" xml:space="preserve" uid="M:System.Math.Round(System.Decimal,System.Int32)">
          <source>Rounds a decimal value to a specified number of fractional digits.</source>
          <target state="translated">Redondea un valor decimal al número especificado de dígitos fraccionarios.</target>       </trans-unit>
        <trans-unit id="733" translate="yes" xml:space="preserve" uid="M:System.Math.Round(System.Decimal,System.Int32)">
          <source>The number nearest to <ph id="ph1">&lt;paramref name="d" /&gt;</ph> that contains a number of fractional digits equal to <ph id="ph2">&lt;paramref name="decimals" /&gt;</ph>.</source>
          <target state="translated">Número más cercano a <ph id="ph1">&lt;paramref name="d" /&gt;</ph> que contiene varios dígitos fraccionarios iguales a <ph id="ph2">&lt;paramref name="decimals" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="734" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Math.Round(System.Decimal,System.Int32)">
          <source>For examples and comprehensive usage information about this and other overloads of the <ph id="ph1">`Round`</ph> method, see the <ph id="ph2">&lt;xref:System.Math.Round%2A&gt;</ph> reference page.</source>
          <target state="translated">Para obtener ejemplos y la información de uso completa acerca de ésta y otras sobrecargas de la <ph id="ph1">`Round`</ph> método, consulte la <ph id="ph2">&lt;xref:System.Math.Round%2A&gt;</ph> página de referencia.</target>       </trans-unit>
        <trans-unit id="735" translate="yes" xml:space="preserve" uid="M:System.Math.Round(System.Decimal,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="decimals" /&gt;</ph> is less than 0 or greater than 28.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="decimals" /&gt;</ph> es menor que 0 o mayor que 28.</target>       </trans-unit>
        <trans-unit id="736" translate="yes" xml:space="preserve" uid="M:System.Math.Round(System.Decimal,System.Int32)">
          <source>The result is outside the range of a <ph id="ph1">&lt;see cref="T:System.Decimal" /&gt;</ph>.</source>
          <target state="translated">El resultado está fuera del intervalo de <ph id="ph1">&lt;see cref="T:System.Decimal" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="737" translate="yes" xml:space="preserve" uid="M:System.Math.Round(System.Decimal,System.MidpointRounding)">
          <source>A decimal number to be rounded.</source>
          <target state="translated">Número decimal que se va a redondear.</target>       </trans-unit>
        <trans-unit id="738" translate="yes" xml:space="preserve" uid="M:System.Math.Round(System.Decimal,System.MidpointRounding)">
          <source>Specification for how to round <bpt id="p1">&lt;c&gt;</bpt>d<ept id="p1">&lt;/c&gt;</ept> if it is midway between two other numbers.</source>
          <target state="translated">Especificación sobre el redondeo de <bpt id="p1">&lt;c&gt;</bpt>d<ept id="p1">&lt;/c&gt;</ept> si se encuentra a la mitad del intervalo comprendido entre otros dos números.</target>       </trans-unit>
        <trans-unit id="739" translate="yes" xml:space="preserve" uid="M:System.Math.Round(System.Decimal,System.MidpointRounding)">
          <source>Rounds a decimal value to the nearest integer.</source>
          <target state="translated">Redondea un valor decimal al entero más próximo.</target>       </trans-unit>
        <trans-unit id="740" translate="yes" xml:space="preserve" uid="M:System.Math.Round(System.Decimal,System.MidpointRounding)">
          <source>A parameter specifies how to round the value if it is midway between two numbers.</source>
          <target state="translated">Un parámetro especifica el redondeo del valor si está a la mitad del intervalo entre dos números.</target>       </trans-unit>
        <trans-unit id="741" translate="yes" xml:space="preserve" uid="M:System.Math.Round(System.Decimal,System.MidpointRounding)">
          <source>The integer nearest <ph id="ph1">&lt;paramref name="d" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="d" /&gt;</ph> entero más cercano.</target>       </trans-unit>
        <trans-unit id="742" translate="yes" xml:space="preserve" uid="M:System.Math.Round(System.Decimal,System.MidpointRounding)">
          <source>If <ph id="ph1">&lt;paramref name="d" /&gt;</ph> is halfway between two numbers, one of which is even and the other odd, then <ph id="ph2">&lt;paramref name="mode" /&gt;</ph> determines which of the two is returned.</source>
          <target state="translated">Si <ph id="ph1">&lt;paramref name="d" /&gt;</ph> se encuentra a la mitad del intervalo entre dos números, uno par y el otro impar, <ph id="ph2">&lt;paramref name="mode" /&gt;</ph> determina los dos números que se devuelven.</target>       </trans-unit>
        <trans-unit id="743" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Math.Round(System.Decimal,System.MidpointRounding)">
          <source>For examples and comprehensive usage information about this and other overloads of the <ph id="ph1">`Round`</ph> method, see the <ph id="ph2">&lt;xref:System.Math.Round%2A&gt;</ph> reference page.</source>
          <target state="translated">Para obtener ejemplos y la información de uso completa acerca de ésta y otras sobrecargas de la <ph id="ph1">`Round`</ph> método, consulte la <ph id="ph2">&lt;xref:System.Math.Round%2A&gt;</ph> página de referencia.</target>       </trans-unit>
        <trans-unit id="744" translate="yes" xml:space="preserve" uid="M:System.Math.Round(System.Decimal,System.MidpointRounding)">
          <source><ph id="ph1">&lt;paramref name="mode" /&gt;</ph> is not a valid value of <ph id="ph2">&lt;see cref="T:System.MidpointRounding" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="mode" /&gt;</ph> no es un valor válido de <ph id="ph2">&lt;see cref="T:System.MidpointRounding" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="745" translate="yes" xml:space="preserve" uid="M:System.Math.Round(System.Decimal,System.MidpointRounding)">
          <source>The result is outside the range of a <ph id="ph1">&lt;see cref="T:System.Decimal" /&gt;</ph>.</source>
          <target state="translated">El resultado está fuera del intervalo de <ph id="ph1">&lt;see cref="T:System.Decimal" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="746" translate="yes" xml:space="preserve" uid="M:System.Math.Round(System.Double,System.Int32)">
          <source>A double-precision floating-point number to be rounded.</source>
          <target state="translated">Número de punto flotante de precisión doble que se va a redondear.</target>       </trans-unit>
        <trans-unit id="747" translate="yes" xml:space="preserve" uid="M:System.Math.Round(System.Double,System.Int32)">
          <source>The number of fractional digits in the return value.</source>
          <target state="translated">Número de dígitos fraccionarios del valor devuelto.</target>       </trans-unit>
        <trans-unit id="748" translate="yes" xml:space="preserve" uid="M:System.Math.Round(System.Double,System.Int32)">
          <source>Rounds a double-precision floating-point value to a specified number of fractional digits.</source>
          <target state="translated">Redondea un valor de punto flotante de precisión doble al número especificado de dígitos fraccionarios.</target>       </trans-unit>
        <trans-unit id="749" translate="yes" xml:space="preserve" uid="M:System.Math.Round(System.Double,System.Int32)">
          <source>The number nearest to <ph id="ph1">&lt;paramref name="value" /&gt;</ph> that contains a number of fractional digits equal to <ph id="ph2">&lt;paramref name="digits" /&gt;</ph>.</source>
          <target state="translated">Número más cercano a <ph id="ph1">&lt;paramref name="value" /&gt;</ph> que contiene varios dígitos fraccionarios iguales a <ph id="ph2">&lt;paramref name="digits" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="750" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Math.Round(System.Double,System.Int32)">
          <source>For examples and comprehensive usage information about this and other overloads of the <ph id="ph1">`Round`</ph> method, see the <ph id="ph2">&lt;xref:System.Math.Round%2A&gt;</ph> reference page.</source>
          <target state="translated">Para obtener ejemplos y la información de uso completa acerca de ésta y otras sobrecargas de la <ph id="ph1">`Round`</ph> método, consulte la <ph id="ph2">&lt;xref:System.Math.Round%2A&gt;</ph> página de referencia.</target>       </trans-unit>
        <trans-unit id="751" translate="yes" xml:space="preserve" uid="M:System.Math.Round(System.Double,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="digits" /&gt;</ph> is less than 0 or greater than 15.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="digits" /&gt;</ph> es menor que 0 o mayor que 15.</target>       </trans-unit>
        <trans-unit id="752" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Math.Round(System.Double,System.Int32)">
          <source>Because of the loss of precision that can result from representing decimal values as floating-point numbers or performing arithmetic operations on floating-point values, in some cases the <ph id="ph1">&lt;see cref="M:System.Math.Round(System.Double,System.Int32)" /&gt;</ph> method may not appear to round midpoint values to the nearest even value in the <ph id="ph2">&lt;paramref name="digits" /&gt;</ph> decimal position.</source>
          <target state="translated">Debido a la pérdida de precisión que puede obtenerse al que representa los valores decimales como números de punto flotante o realizar operaciones aritméticas en valores de punto flotante, en algunos casos el <ph id="ph1">&lt;see cref="M:System.Math.Round(System.Double,System.Int32)" /&gt;</ph> método no puede aparecer redondear los valores de punto medio en el valor incluso en más cercano la <ph id="ph2">&lt;paramref name="digits" /&gt;</ph> posición decimal.</target>       </trans-unit>
        <trans-unit id="753" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Math.Round(System.Double,System.Int32)">
          <source>This is illustrated in the following example, where 2.135 is rounded to 2.13 instead of 2.14.</source>
          <target state="translated">Esto se muestra en el ejemplo siguiente, donde se redondea 2.135 2.13 en lugar de 2.14.</target>       </trans-unit>
        <trans-unit id="754" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Math.Round(System.Double,System.Int32)">
          <source>This occurs because internally the method multiplies <ph id="ph1">&lt;paramref name="value" /&gt;</ph> by 10<bpt id="p1">&lt;sup&gt;</bpt>digits<ept id="p1">&lt;/sup&gt;</ept>, and the multiplication operation in this case suffers from a loss of precision.</source>
          <target state="translated">Esto ocurre porque internamente el método multiplica <ph id="ph1">&lt;paramref name="value" /&gt;</ph> por 10<bpt id="p1">&lt;sup&gt;</bpt>dígitos<ept id="p1">&lt;/sup&gt;</ept>, y la operación de multiplicación en este caso sufre una pérdida de precisión.</target>       </trans-unit>
        <trans-unit id="755" translate="yes" xml:space="preserve" uid="M:System.Math.Round(System.Double,System.MidpointRounding)">
          <source>A double-precision floating-point number to be rounded.</source>
          <target state="translated">Número de punto flotante de precisión doble que se va a redondear.</target>       </trans-unit>
        <trans-unit id="756" translate="yes" xml:space="preserve" uid="M:System.Math.Round(System.Double,System.MidpointRounding)">
          <source>Specification for how to round <bpt id="p1">&lt;c&gt;</bpt>value<ept id="p1">&lt;/c&gt;</ept> if it is midway between two other numbers.</source>
          <target state="translated">Especificación sobre el redondeo de <bpt id="p1">&lt;c&gt;</bpt>value<ept id="p1">&lt;/c&gt;</ept> si se encuentra a la mitad del intervalo comprendido entre otros dos números.</target>       </trans-unit>
        <trans-unit id="757" translate="yes" xml:space="preserve" uid="M:System.Math.Round(System.Double,System.MidpointRounding)">
          <source>Rounds a double-precision floating-point value to the nearest integer.</source>
          <target state="translated">Redondea un valor de punto flotante de precisión doble al entero más cercano.</target>       </trans-unit>
        <trans-unit id="758" translate="yes" xml:space="preserve" uid="M:System.Math.Round(System.Double,System.MidpointRounding)">
          <source>A parameter specifies how to round the value if it is midway between two numbers.</source>
          <target state="translated">Un parámetro especifica el redondeo del valor si está a la mitad del intervalo entre dos números.</target>       </trans-unit>
        <trans-unit id="759" translate="yes" xml:space="preserve" uid="M:System.Math.Round(System.Double,System.MidpointRounding)">
          <source>The integer nearest <ph id="ph1">&lt;paramref name="value" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="value" /&gt;</ph> entero más cercano.</target>       </trans-unit>
        <trans-unit id="760" translate="yes" xml:space="preserve" uid="M:System.Math.Round(System.Double,System.MidpointRounding)">
          <source>If <ph id="ph1">&lt;paramref name="value" /&gt;</ph> is halfway between two integers, one of which is even and the other odd, then <ph id="ph2">&lt;paramref name="mode" /&gt;</ph> determines which of the two is returned.</source>
          <target state="translated">Si <ph id="ph1">&lt;paramref name="value" /&gt;</ph> se encuentra a la mitad del intervalo entre dos enteros, uno par y el otro impar, <ph id="ph2">&lt;paramref name="mode" /&gt;</ph> determina los dos números que se devuelven.</target>       </trans-unit>
        <trans-unit id="761" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Math.Round(System.Double,System.MidpointRounding)">
          <source>For examples and comprehensive usage information about this and other overloads of the <ph id="ph1">`Round`</ph> method, see the <ph id="ph2">&lt;xref:System.Math.Round%2A&gt;</ph> reference page.</source>
          <target state="translated">Para obtener ejemplos y la información de uso completa acerca de ésta y otras sobrecargas de la <ph id="ph1">`Round`</ph> método, consulte la <ph id="ph2">&lt;xref:System.Math.Round%2A&gt;</ph> página de referencia.</target>       </trans-unit>
        <trans-unit id="762" translate="yes" xml:space="preserve" uid="M:System.Math.Round(System.Double,System.MidpointRounding)">
          <source><ph id="ph1">&lt;paramref name="mode" /&gt;</ph> is not a valid value of <ph id="ph2">&lt;see cref="T:System.MidpointRounding" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="mode" /&gt;</ph> no es un valor válido de <ph id="ph2">&lt;see cref="T:System.MidpointRounding" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="763" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Math.Round(System.Double,System.MidpointRounding)">
          <source>Because of the loss of precision that can result from representing decimal values as floating-point numbers or performing arithmetic operations on floating-point values, in some cases the <ph id="ph1">&lt;see cref="M:System.Math.Round(System.Double,System.MidpointRounding)" /&gt;</ph> method may not appear to round midpoint values to the nearest even integer.</source>
          <target state="translated">Debido a la pérdida de precisión que puede obtenerse al que representa los valores decimales como números de punto flotante o realizar operaciones aritméticas en valores de punto flotante, en algunos casos el <ph id="ph1">&lt;see cref="M:System.Math.Round(System.Double,System.MidpointRounding)" /&gt;</ph> método no puede aparecer redondear los valores de punto medio en el entero par más próximo.</target>       </trans-unit>
        <trans-unit id="764" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Math.Round(System.Double,System.MidpointRounding)">
          <source>In the following example, because the floating-point value .1 has no finite binary representation, the first call to the <ph id="ph1">&lt;see cref="M:System.Math.Round(System.Double)" /&gt;</ph> method with a value of 11.5 returns 11 instead of 12.</source>
          <target state="translated">En el ejemplo siguiente, porque el valor de punto flotante.1 no tiene ninguna representación binaria finita, la primera llamada a la <ph id="ph1">&lt;see cref="M:System.Math.Round(System.Double)" /&gt;</ph> método con un valor de 11,5 devuelve 11 en lugar de 12.</target>       </trans-unit>
        <trans-unit id="765" translate="yes" xml:space="preserve" uid="M:System.Math.Round(System.Decimal,System.Int32,System.MidpointRounding)">
          <source>A decimal number to be rounded.</source>
          <target state="translated">Número decimal que se va a redondear.</target>       </trans-unit>
        <trans-unit id="766" translate="yes" xml:space="preserve" uid="M:System.Math.Round(System.Decimal,System.Int32,System.MidpointRounding)">
          <source>The number of decimal places in the return value.</source>
          <target state="translated">Número de posiciones decimales del valor devuelto.</target>       </trans-unit>
        <trans-unit id="767" translate="yes" xml:space="preserve" uid="M:System.Math.Round(System.Decimal,System.Int32,System.MidpointRounding)">
          <source>Specification for how to round <bpt id="p1">&lt;c&gt;</bpt>d<ept id="p1">&lt;/c&gt;</ept> if it is midway between two other numbers.</source>
          <target state="translated">Especificación sobre el redondeo de <bpt id="p1">&lt;c&gt;</bpt>d<ept id="p1">&lt;/c&gt;</ept> si se encuentra a la mitad del intervalo comprendido entre otros dos números.</target>       </trans-unit>
        <trans-unit id="768" translate="yes" xml:space="preserve" uid="M:System.Math.Round(System.Decimal,System.Int32,System.MidpointRounding)">
          <source>Rounds a decimal value to a specified number of fractional digits.</source>
          <target state="translated">Redondea un valor decimal al número especificado de dígitos fraccionarios.</target>       </trans-unit>
        <trans-unit id="769" translate="yes" xml:space="preserve" uid="M:System.Math.Round(System.Decimal,System.Int32,System.MidpointRounding)">
          <source>A parameter specifies how to round the value if it is midway between two numbers.</source>
          <target state="translated">Un parámetro especifica el redondeo del valor si está a la mitad del intervalo entre dos números.</target>       </trans-unit>
        <trans-unit id="770" translate="yes" xml:space="preserve" uid="M:System.Math.Round(System.Decimal,System.Int32,System.MidpointRounding)">
          <source>The number nearest to <ph id="ph1">&lt;paramref name="d" /&gt;</ph> that contains a number of fractional digits equal to <ph id="ph2">&lt;paramref name="decimals" /&gt;</ph>.</source>
          <target state="translated">Número más cercano a <ph id="ph1">&lt;paramref name="d" /&gt;</ph> que contiene varios dígitos fraccionarios iguales a <ph id="ph2">&lt;paramref name="decimals" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="771" translate="yes" xml:space="preserve" uid="M:System.Math.Round(System.Decimal,System.Int32,System.MidpointRounding)">
          <source>If <ph id="ph1">&lt;paramref name="d" /&gt;</ph> has fewer fractional digits than <ph id="ph2">&lt;paramref name="decimals" /&gt;</ph>, <ph id="ph3">&lt;paramref name="d" /&gt;</ph> is returned unchanged.</source>
          <target state="translated">Si <ph id="ph1">&lt;paramref name="d" /&gt;</ph> tiene menos dígitos fraccionarios que <ph id="ph2">&lt;paramref name="decimals" /&gt;</ph>, <ph id="ph3">&lt;paramref name="d" /&gt;</ph> se devuelve sin modificar.</target>       </trans-unit>
        <trans-unit id="772" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Math.Round(System.Decimal,System.Int32,System.MidpointRounding)">
          <source>For examples and comprehensive usage information about this and other overloads of the <ph id="ph1">`Round`</ph> method, see the <ph id="ph2">&lt;xref:System.Math.Round%2A&gt;</ph> reference page.</source>
          <target state="translated">Para obtener ejemplos y la información de uso completa acerca de ésta y otras sobrecargas de la <ph id="ph1">`Round`</ph> método, consulte la <ph id="ph2">&lt;xref:System.Math.Round%2A&gt;</ph> página de referencia.</target>       </trans-unit>
        <trans-unit id="773" translate="yes" xml:space="preserve" uid="M:System.Math.Round(System.Decimal,System.Int32,System.MidpointRounding)">
          <source><ph id="ph1">&lt;paramref name="decimals" /&gt;</ph> is less than 0 or greater than 28.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="decimals" /&gt;</ph> es menor que 0 o mayor que 28.</target>       </trans-unit>
        <trans-unit id="774" translate="yes" xml:space="preserve" uid="M:System.Math.Round(System.Decimal,System.Int32,System.MidpointRounding)">
          <source><ph id="ph1">&lt;paramref name="mode" /&gt;</ph> is not a valid value of <ph id="ph2">&lt;see cref="T:System.MidpointRounding" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="mode" /&gt;</ph> no es un valor válido de <ph id="ph2">&lt;see cref="T:System.MidpointRounding" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="775" translate="yes" xml:space="preserve" uid="M:System.Math.Round(System.Decimal,System.Int32,System.MidpointRounding)">
          <source>The result is outside the range of a <ph id="ph1">&lt;see cref="T:System.Decimal" /&gt;</ph>.</source>
          <target state="translated">El resultado está fuera del intervalo de <ph id="ph1">&lt;see cref="T:System.Decimal" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="776" translate="yes" xml:space="preserve" uid="M:System.Math.Round(System.Double,System.Int32,System.MidpointRounding)">
          <source>A double-precision floating-point number to be rounded.</source>
          <target state="translated">Número de punto flotante de precisión doble que se va a redondear.</target>       </trans-unit>
        <trans-unit id="777" translate="yes" xml:space="preserve" uid="M:System.Math.Round(System.Double,System.Int32,System.MidpointRounding)">
          <source>The number of fractional digits in the return value.</source>
          <target state="translated">Número de dígitos fraccionarios del valor devuelto.</target>       </trans-unit>
        <trans-unit id="778" translate="yes" xml:space="preserve" uid="M:System.Math.Round(System.Double,System.Int32,System.MidpointRounding)">
          <source>Specification for how to round <bpt id="p1">&lt;c&gt;</bpt>value<ept id="p1">&lt;/c&gt;</ept> if it is midway between two other numbers.</source>
          <target state="translated">Especificación sobre el redondeo de <bpt id="p1">&lt;c&gt;</bpt>value<ept id="p1">&lt;/c&gt;</ept> si se encuentra a la mitad del intervalo comprendido entre otros dos números.</target>       </trans-unit>
        <trans-unit id="779" translate="yes" xml:space="preserve" uid="M:System.Math.Round(System.Double,System.Int32,System.MidpointRounding)">
          <source>Rounds a double-precision floating-point value to a specified number of fractional digits.</source>
          <target state="translated">Redondea un valor de punto flotante de precisión doble al número especificado de dígitos fraccionarios.</target>       </trans-unit>
        <trans-unit id="780" translate="yes" xml:space="preserve" uid="M:System.Math.Round(System.Double,System.Int32,System.MidpointRounding)">
          <source>A parameter specifies how to round the value if it is midway between two numbers.</source>
          <target state="translated">Un parámetro especifica el redondeo del valor si está a la mitad del intervalo entre dos números.</target>       </trans-unit>
        <trans-unit id="781" translate="yes" xml:space="preserve" uid="M:System.Math.Round(System.Double,System.Int32,System.MidpointRounding)">
          <source>The number nearest to <ph id="ph1">&lt;paramref name="value" /&gt;</ph> that has a number of fractional digits equal to <ph id="ph2">&lt;paramref name="digits" /&gt;</ph>.</source>
          <target state="translated">Número más cercano a <ph id="ph1">&lt;paramref name="value" /&gt;</ph> que tiene varios dígitos fraccionarios iguales a <ph id="ph2">&lt;paramref name="digits" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="782" translate="yes" xml:space="preserve" uid="M:System.Math.Round(System.Double,System.Int32,System.MidpointRounding)">
          <source>If <ph id="ph1">&lt;paramref name="value" /&gt;</ph> has fewer fractional digits than <ph id="ph2">&lt;paramref name="digits" /&gt;</ph>, <ph id="ph3">&lt;paramref name="value" /&gt;</ph> is returned unchanged.</source>
          <target state="translated">Si <ph id="ph1">&lt;paramref name="value" /&gt;</ph> tiene menos dígitos fraccionarios que <ph id="ph2">&lt;paramref name="digits" /&gt;</ph>, <ph id="ph3">&lt;paramref name="value" /&gt;</ph> se devuelve sin modificar.</target>       </trans-unit>
        <trans-unit id="783" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Math.Round(System.Double,System.Int32,System.MidpointRounding)">
          <source>For examples and comprehensive usage information about this and other overloads of the <ph id="ph1">`Round`</ph> method, see the <ph id="ph2">&lt;xref:System.Math.Round%2A&gt;</ph> reference page.</source>
          <target state="translated">Para obtener ejemplos y la información de uso completa acerca de ésta y otras sobrecargas de la <ph id="ph1">`Round`</ph> método, consulte la <ph id="ph2">&lt;xref:System.Math.Round%2A&gt;</ph> página de referencia.</target>       </trans-unit>
        <trans-unit id="784" translate="yes" xml:space="preserve" uid="M:System.Math.Round(System.Double,System.Int32,System.MidpointRounding)">
          <source><ph id="ph1">&lt;paramref name="digits" /&gt;</ph> is less than 0 or greater than 15.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="digits" /&gt;</ph> es menor que 0 o mayor que 15.</target>       </trans-unit>
        <trans-unit id="785" translate="yes" xml:space="preserve" uid="M:System.Math.Round(System.Double,System.Int32,System.MidpointRounding)">
          <source><ph id="ph1">&lt;paramref name="mode" /&gt;</ph> is not a valid value of <ph id="ph2">&lt;see cref="T:System.MidpointRounding" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="mode" /&gt;</ph> no es un valor válido de <ph id="ph2">&lt;see cref="T:System.MidpointRounding" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="786" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Math.Round(System.Double,System.Int32,System.MidpointRounding)">
          <source>Because of the loss of precision that can result from representing decimal values as floating-point numbers or performing arithmetic operations on floating-point values, in some cases the <ph id="ph1">&lt;see cref="M:System.Math.Round(System.Double,System.Int32,System.MidpointRounding)" /&gt;</ph> method may not appear to round midpoint values as specified by the <ph id="ph2">&lt;paramref name="mode" /&gt;</ph> parameter.</source>
          <target state="translated">Debido a la pérdida de precisión que puede obtenerse al que representa los valores decimales como números de punto flotante o realizar operaciones aritméticas en valores de punto flotante, en algunos casos el <ph id="ph1">&lt;see cref="M:System.Math.Round(System.Double,System.Int32,System.MidpointRounding)" /&gt;</ph> método no puede aparecer a valores de punto medio tal como se especifica de ida y vuelta por el <ph id="ph2">&lt;paramref name="mode" /&gt;</ph> parámetro.</target>       </trans-unit>
        <trans-unit id="787" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Math.Round(System.Double,System.Int32,System.MidpointRounding)">
          <source>This is illustrated in the following example, where 2.135 is rounded to 2.13 instead of 2.14.</source>
          <target state="translated">Esto se muestra en el ejemplo siguiente, donde se redondea 2.135 2.13 en lugar de 2.14.</target>       </trans-unit>
        <trans-unit id="788" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Math.Round(System.Double,System.Int32,System.MidpointRounding)">
          <source>This occurs because internally the method multiplies <ph id="ph1">&lt;paramref name="value" /&gt;</ph> by 10<bpt id="p1">&lt;sup&gt;</bpt>digits<ept id="p1">&lt;/sup&gt;</ept>, and the multiplication operation in this case suffers from a loss of precision.</source>
          <target state="translated">Esto ocurre porque internamente el método multiplica <ph id="ph1">&lt;paramref name="value" /&gt;</ph> por 10<bpt id="p1">&lt;sup&gt;</bpt>dígitos<ept id="p1">&lt;/sup&gt;</ept>, y la operación de multiplicación en este caso sufre una pérdida de precisión.</target>       </trans-unit>
        <trans-unit id="789" translate="yes" xml:space="preserve" uid="T:System.Math">
          <source>Returns an integer that indicates the sign of a number.</source>
          <target state="translated">Devuelve un entero que indica el signo de un número.</target>       </trans-unit>
        <trans-unit id="790" translate="yes" xml:space="preserve" uid="M:System.Math.Sign(System.Decimal)">
          <source>A signed decimal number.</source>
          <target state="translated">Número decimal con signo.</target>       </trans-unit>
        <trans-unit id="791" translate="yes" xml:space="preserve" uid="M:System.Math.Sign(System.Decimal)">
          <source>Returns an integer that indicates the sign of a decimal number.</source>
          <target state="translated">Devuelve un entero que indica el signo de un número decimal.</target>       </trans-unit>
        <trans-unit id="792" translate="yes" xml:space="preserve" uid="M:System.Math.Sign(System.Decimal)">
          <source>A number that indicates the sign of <ph id="ph1">&lt;paramref name="value" /&gt;</ph>, as shown in the following table.</source>
          <target state="translated">Número que indica el signo de <ph id="ph1">&lt;paramref name="value" /&gt;</ph>, como puede verse en la tabla siguiente.</target>       </trans-unit>
        <trans-unit id="793" translate="yes" xml:space="preserve" uid="M:System.Math.Sign(System.Decimal)">
          <source><ph id="ph1">&lt;list type="table"&gt;</ph><ph id="ph2">&lt;listheader&gt;</ph><ph id="ph3">&lt;term&gt;</ph> Return value</source>
          <target state="translated"><ph id="ph1">&lt;list type="table"&gt;</ph><ph id="ph2">&lt;listheader&gt;</ph><ph id="ph3">&lt;term&gt;</ph> Valor devuelto</target>       </trans-unit>
        <trans-unit id="794" translate="yes" xml:space="preserve" uid="M:System.Math.Sign(System.Decimal)">
          <source><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph> Meaning</source>
          <target state="translated"><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph> Significado</target>       </trans-unit>
        <trans-unit id="795" translate="yes" xml:space="preserve" uid="M:System.Math.Sign(System.Decimal)">
          <source><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/listheader&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> -1</source>
          <target state="translated"><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/listheader&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> -1</target>       </trans-unit>
        <trans-unit id="796" translate="yes" xml:space="preserve" uid="M:System.Math.Sign(System.Decimal)">
          <source><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph><ph id="ph3">&lt;paramref name="value" /&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph><ph id="ph3">&lt;paramref name="value" /&gt;</ph> es menor que cero.</target>       </trans-unit>
        <trans-unit id="797" translate="yes" xml:space="preserve" uid="M:System.Math.Sign(System.Decimal)">
          <source><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/item&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> 0</source>
          <target state="translated"><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/item&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> 0</target>       </trans-unit>
        <trans-unit id="798" translate="yes" xml:space="preserve" uid="M:System.Math.Sign(System.Decimal)">
          <source><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph><ph id="ph3">&lt;paramref name="value" /&gt;</ph> is equal to zero.</source>
          <target state="translated"><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph><ph id="ph3">&lt;paramref name="value" /&gt;</ph> es igual a cero.</target>       </trans-unit>
        <trans-unit id="799" translate="yes" xml:space="preserve" uid="M:System.Math.Sign(System.Decimal)">
          <source><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/item&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> 1</source>
          <target state="translated"><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/item&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> 1</target>       </trans-unit>
        <trans-unit id="800" translate="yes" xml:space="preserve" uid="M:System.Math.Sign(System.Decimal)">
          <source><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph><ph id="ph3">&lt;paramref name="value" /&gt;</ph> is greater than zero.</source>
          <target state="translated"><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph><ph id="ph3">&lt;paramref name="value" /&gt;</ph> es mayor que cero.</target>       </trans-unit>
        <trans-unit id="801" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Math.Sign(System.Decimal)">
          <source>The following example demonstrates how to use the <ph id="ph1">&lt;xref:System.Math.Sign%28System.Decimal%29&gt;</ph> method to determine the sign of a <ph id="ph2">&lt;xref:System.Decimal&gt;</ph> value and display it to the console.</source>
          <target state="translated">En el ejemplo siguiente se muestra cómo utilizar el <ph id="ph1">&lt;xref:System.Math.Sign%28System.Decimal%29&gt;</ph> método para determinar el signo de un <ph id="ph2">&lt;xref:System.Decimal&gt;</ph> valor y mostrarlo en la consola.</target>       </trans-unit>
        <trans-unit id="802" translate="yes" xml:space="preserve" uid="M:System.Math.Sign(System.Double)">
          <source>A signed number.</source>
          <target state="translated">Número con signo.</target>       </trans-unit>
        <trans-unit id="803" translate="yes" xml:space="preserve" uid="M:System.Math.Sign(System.Double)">
          <source>Returns an integer that indicates the sign of a double-precision floating-point number.</source>
          <target state="translated">Devuelve un entero que indica el signo de un número de punto flotante de doble precisión.</target>       </trans-unit>
        <trans-unit id="804" translate="yes" xml:space="preserve" uid="M:System.Math.Sign(System.Double)">
          <source>A number that indicates the sign of <ph id="ph1">&lt;paramref name="value" /&gt;</ph>, as shown in the following table.</source>
          <target state="translated">Número que indica el signo de <ph id="ph1">&lt;paramref name="value" /&gt;</ph>, como puede verse en la tabla siguiente.</target>       </trans-unit>
        <trans-unit id="805" translate="yes" xml:space="preserve" uid="M:System.Math.Sign(System.Double)">
          <source><ph id="ph1">&lt;list type="table"&gt;</ph><ph id="ph2">&lt;listheader&gt;</ph><ph id="ph3">&lt;term&gt;</ph> Return value</source>
          <target state="translated"><ph id="ph1">&lt;list type="table"&gt;</ph><ph id="ph2">&lt;listheader&gt;</ph><ph id="ph3">&lt;term&gt;</ph> Valor devuelto</target>       </trans-unit>
        <trans-unit id="806" translate="yes" xml:space="preserve" uid="M:System.Math.Sign(System.Double)">
          <source><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph> Meaning</source>
          <target state="translated"><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph> Significado</target>       </trans-unit>
        <trans-unit id="807" translate="yes" xml:space="preserve" uid="M:System.Math.Sign(System.Double)">
          <source><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/listheader&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> -1</source>
          <target state="translated"><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/listheader&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> -1</target>       </trans-unit>
        <trans-unit id="808" translate="yes" xml:space="preserve" uid="M:System.Math.Sign(System.Double)">
          <source><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph><ph id="ph3">&lt;paramref name="value" /&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph><ph id="ph3">&lt;paramref name="value" /&gt;</ph> es menor que cero.</target>       </trans-unit>
        <trans-unit id="809" translate="yes" xml:space="preserve" uid="M:System.Math.Sign(System.Double)">
          <source><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/item&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> 0</source>
          <target state="translated"><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/item&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> 0</target>       </trans-unit>
        <trans-unit id="810" translate="yes" xml:space="preserve" uid="M:System.Math.Sign(System.Double)">
          <source><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph><ph id="ph3">&lt;paramref name="value" /&gt;</ph> is equal to zero.</source>
          <target state="translated"><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph><ph id="ph3">&lt;paramref name="value" /&gt;</ph> es igual a cero.</target>       </trans-unit>
        <trans-unit id="811" translate="yes" xml:space="preserve" uid="M:System.Math.Sign(System.Double)">
          <source><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/item&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> 1</source>
          <target state="translated"><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/item&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> 1</target>       </trans-unit>
        <trans-unit id="812" translate="yes" xml:space="preserve" uid="M:System.Math.Sign(System.Double)">
          <source><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph><ph id="ph3">&lt;paramref name="value" /&gt;</ph> is greater than zero.</source>
          <target state="translated"><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph><ph id="ph3">&lt;paramref name="value" /&gt;</ph> es mayor que cero.</target>       </trans-unit>
        <trans-unit id="813" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Math.Sign(System.Double)">
          <source>The following example demonstrates how to use the <ph id="ph1">&lt;xref:System.Math.Sign%28System.Double%29&gt;</ph> method to determine the sign of a <ph id="ph2">&lt;xref:System.Double&gt;</ph> value and display it to the console.</source>
          <target state="translated">En el ejemplo siguiente se muestra cómo utilizar el <ph id="ph1">&lt;xref:System.Math.Sign%28System.Double%29&gt;</ph> método para determinar el signo de un <ph id="ph2">&lt;xref:System.Double&gt;</ph> valor y mostrarlo en la consola.</target>       </trans-unit>
        <trans-unit id="814" translate="yes" xml:space="preserve" uid="M:System.Math.Sign(System.Double)">
          <source><ph id="ph1">&lt;paramref name="value" /&gt;</ph> is equal to <ph id="ph2">&lt;see cref="F:System.Double.NaN" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="value" /&gt;</ph> es igual a <ph id="ph2">&lt;see cref="F:System.Double.NaN" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="815" translate="yes" xml:space="preserve" uid="M:System.Math.Sign(System.Int16)">
          <source>A signed number.</source>
          <target state="translated">Número con signo.</target>       </trans-unit>
        <trans-unit id="816" translate="yes" xml:space="preserve" uid="M:System.Math.Sign(System.Int16)">
          <source>Returns an integer that indicates the sign of a 16-bit signed integer.</source>
          <target state="translated">Devuelve un entero que indica el signo de un entero de 16 bits con signo.</target>       </trans-unit>
        <trans-unit id="817" translate="yes" xml:space="preserve" uid="M:System.Math.Sign(System.Int16)">
          <source>A number that indicates the sign of <ph id="ph1">&lt;paramref name="value" /&gt;</ph>, as shown in the following table.</source>
          <target state="translated">Número que indica el signo de <ph id="ph1">&lt;paramref name="value" /&gt;</ph>, como puede verse en la tabla siguiente.</target>       </trans-unit>
        <trans-unit id="818" translate="yes" xml:space="preserve" uid="M:System.Math.Sign(System.Int16)">
          <source><ph id="ph1">&lt;list type="table"&gt;</ph><ph id="ph2">&lt;listheader&gt;</ph><ph id="ph3">&lt;term&gt;</ph> Return value</source>
          <target state="translated"><ph id="ph1">&lt;list type="table"&gt;</ph><ph id="ph2">&lt;listheader&gt;</ph><ph id="ph3">&lt;term&gt;</ph> Valor devuelto</target>       </trans-unit>
        <trans-unit id="819" translate="yes" xml:space="preserve" uid="M:System.Math.Sign(System.Int16)">
          <source><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph> Meaning</source>
          <target state="translated"><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph> Significado</target>       </trans-unit>
        <trans-unit id="820" translate="yes" xml:space="preserve" uid="M:System.Math.Sign(System.Int16)">
          <source><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/listheader&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> -1</source>
          <target state="translated"><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/listheader&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> -1</target>       </trans-unit>
        <trans-unit id="821" translate="yes" xml:space="preserve" uid="M:System.Math.Sign(System.Int16)">
          <source><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph><ph id="ph3">&lt;paramref name="value" /&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph><ph id="ph3">&lt;paramref name="value" /&gt;</ph> es menor que cero.</target>       </trans-unit>
        <trans-unit id="822" translate="yes" xml:space="preserve" uid="M:System.Math.Sign(System.Int16)">
          <source><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/item&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> 0</source>
          <target state="translated"><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/item&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> 0</target>       </trans-unit>
        <trans-unit id="823" translate="yes" xml:space="preserve" uid="M:System.Math.Sign(System.Int16)">
          <source><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph><ph id="ph3">&lt;paramref name="value" /&gt;</ph> is equal to zero.</source>
          <target state="translated"><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph><ph id="ph3">&lt;paramref name="value" /&gt;</ph> es igual a cero.</target>       </trans-unit>
        <trans-unit id="824" translate="yes" xml:space="preserve" uid="M:System.Math.Sign(System.Int16)">
          <source><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/item&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> 1</source>
          <target state="translated"><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/item&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> 1</target>       </trans-unit>
        <trans-unit id="825" translate="yes" xml:space="preserve" uid="M:System.Math.Sign(System.Int16)">
          <source><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph><ph id="ph3">&lt;paramref name="value" /&gt;</ph> is greater than zero.</source>
          <target state="translated"><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph><ph id="ph3">&lt;paramref name="value" /&gt;</ph> es mayor que cero.</target>       </trans-unit>
        <trans-unit id="826" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Math.Sign(System.Int16)">
          <source>The following example demonstrates how to use the <ph id="ph1">&lt;xref:System.Math.Sign%28System.Int16%29&gt;</ph> method to determine the sign of an <ph id="ph2">&lt;xref:System.Int16&gt;</ph> value and display it to the console.</source>
          <target state="translated">En el ejemplo siguiente se muestra cómo utilizar el <ph id="ph1">&lt;xref:System.Math.Sign%28System.Int16%29&gt;</ph> método para determinar el signo de un <ph id="ph2">&lt;xref:System.Int16&gt;</ph> valor y mostrarlo en la consola.</target>       </trans-unit>
        <trans-unit id="827" translate="yes" xml:space="preserve" uid="M:System.Math.Sign(System.Int32)">
          <source>A signed number.</source>
          <target state="translated">Número con signo.</target>       </trans-unit>
        <trans-unit id="828" translate="yes" xml:space="preserve" uid="M:System.Math.Sign(System.Int32)">
          <source>Returns an integer that indicates the sign of a 32-bit signed integer.</source>
          <target state="translated">Devuelve un entero que indica el signo de un entero de 32 bits con signo.</target>       </trans-unit>
        <trans-unit id="829" translate="yes" xml:space="preserve" uid="M:System.Math.Sign(System.Int32)">
          <source>A number that indicates the sign of <ph id="ph1">&lt;paramref name="value" /&gt;</ph>, as shown in the following table.</source>
          <target state="translated">Número que indica el signo de <ph id="ph1">&lt;paramref name="value" /&gt;</ph>, como puede verse en la tabla siguiente.</target>       </trans-unit>
        <trans-unit id="830" translate="yes" xml:space="preserve" uid="M:System.Math.Sign(System.Int32)">
          <source><ph id="ph1">&lt;list type="table"&gt;</ph><ph id="ph2">&lt;listheader&gt;</ph><ph id="ph3">&lt;term&gt;</ph> Return value</source>
          <target state="translated"><ph id="ph1">&lt;list type="table"&gt;</ph><ph id="ph2">&lt;listheader&gt;</ph><ph id="ph3">&lt;term&gt;</ph> Valor devuelto</target>       </trans-unit>
        <trans-unit id="831" translate="yes" xml:space="preserve" uid="M:System.Math.Sign(System.Int32)">
          <source><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph> Meaning</source>
          <target state="translated"><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph> Significado</target>       </trans-unit>
        <trans-unit id="832" translate="yes" xml:space="preserve" uid="M:System.Math.Sign(System.Int32)">
          <source><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/listheader&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> -1</source>
          <target state="translated"><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/listheader&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> -1</target>       </trans-unit>
        <trans-unit id="833" translate="yes" xml:space="preserve" uid="M:System.Math.Sign(System.Int32)">
          <source><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph><ph id="ph3">&lt;paramref name="value" /&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph><ph id="ph3">&lt;paramref name="value" /&gt;</ph> es menor que cero.</target>       </trans-unit>
        <trans-unit id="834" translate="yes" xml:space="preserve" uid="M:System.Math.Sign(System.Int32)">
          <source><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/item&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> 0</source>
          <target state="translated"><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/item&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> 0</target>       </trans-unit>
        <trans-unit id="835" translate="yes" xml:space="preserve" uid="M:System.Math.Sign(System.Int32)">
          <source><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph><ph id="ph3">&lt;paramref name="value" /&gt;</ph> is equal to zero.</source>
          <target state="translated"><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph><ph id="ph3">&lt;paramref name="value" /&gt;</ph> es igual a cero.</target>       </trans-unit>
        <trans-unit id="836" translate="yes" xml:space="preserve" uid="M:System.Math.Sign(System.Int32)">
          <source><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/item&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> 1</source>
          <target state="translated"><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/item&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> 1</target>       </trans-unit>
        <trans-unit id="837" translate="yes" xml:space="preserve" uid="M:System.Math.Sign(System.Int32)">
          <source><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph><ph id="ph3">&lt;paramref name="value" /&gt;</ph> is greater than zero.</source>
          <target state="translated"><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph><ph id="ph3">&lt;paramref name="value" /&gt;</ph> es mayor que cero.</target>       </trans-unit>
        <trans-unit id="838" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Math.Sign(System.Int32)">
          <source>The following example demonstrates how to use the <ph id="ph1">&lt;xref:System.Math.Sign%28System.Int32%29&gt;</ph> method to determine the sign of an <ph id="ph2">&lt;xref:System.Int32&gt;</ph> value and display it to the console.</source>
          <target state="translated">En el ejemplo siguiente se muestra cómo utilizar el <ph id="ph1">&lt;xref:System.Math.Sign%28System.Int32%29&gt;</ph> método para determinar el signo de un <ph id="ph2">&lt;xref:System.Int32&gt;</ph> valor y mostrarlo en la consola.</target>       </trans-unit>
        <trans-unit id="839" translate="yes" xml:space="preserve" uid="M:System.Math.Sign(System.Int64)">
          <source>A signed number.</source>
          <target state="translated">Número con signo.</target>       </trans-unit>
        <trans-unit id="840" translate="yes" xml:space="preserve" uid="M:System.Math.Sign(System.Int64)">
          <source>Returns an integer that indicates the sign of a 64-bit signed integer.</source>
          <target state="translated">Devuelve un entero que indica el signo de un entero de 64 bits con signo.</target>       </trans-unit>
        <trans-unit id="841" translate="yes" xml:space="preserve" uid="M:System.Math.Sign(System.Int64)">
          <source>A number that indicates the sign of <ph id="ph1">&lt;paramref name="value" /&gt;</ph>, as shown in the following table.</source>
          <target state="translated">Número que indica el signo de <ph id="ph1">&lt;paramref name="value" /&gt;</ph>, como puede verse en la tabla siguiente.</target>       </trans-unit>
        <trans-unit id="842" translate="yes" xml:space="preserve" uid="M:System.Math.Sign(System.Int64)">
          <source><ph id="ph1">&lt;list type="table"&gt;</ph><ph id="ph2">&lt;listheader&gt;</ph><ph id="ph3">&lt;term&gt;</ph> Return value</source>
          <target state="translated"><ph id="ph1">&lt;list type="table"&gt;</ph><ph id="ph2">&lt;listheader&gt;</ph><ph id="ph3">&lt;term&gt;</ph> Valor devuelto</target>       </trans-unit>
        <trans-unit id="843" translate="yes" xml:space="preserve" uid="M:System.Math.Sign(System.Int64)">
          <source><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph> Meaning</source>
          <target state="translated"><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph> Significado</target>       </trans-unit>
        <trans-unit id="844" translate="yes" xml:space="preserve" uid="M:System.Math.Sign(System.Int64)">
          <source><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/listheader&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> -1</source>
          <target state="translated"><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/listheader&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> -1</target>       </trans-unit>
        <trans-unit id="845" translate="yes" xml:space="preserve" uid="M:System.Math.Sign(System.Int64)">
          <source><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph><ph id="ph3">&lt;paramref name="value" /&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph><ph id="ph3">&lt;paramref name="value" /&gt;</ph> es menor que cero.</target>       </trans-unit>
        <trans-unit id="846" translate="yes" xml:space="preserve" uid="M:System.Math.Sign(System.Int64)">
          <source><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/item&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> 0</source>
          <target state="translated"><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/item&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> 0</target>       </trans-unit>
        <trans-unit id="847" translate="yes" xml:space="preserve" uid="M:System.Math.Sign(System.Int64)">
          <source><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph><ph id="ph3">&lt;paramref name="value" /&gt;</ph> is equal to zero.</source>
          <target state="translated"><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph><ph id="ph3">&lt;paramref name="value" /&gt;</ph> es igual a cero.</target>       </trans-unit>
        <trans-unit id="848" translate="yes" xml:space="preserve" uid="M:System.Math.Sign(System.Int64)">
          <source><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/item&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> 1</source>
          <target state="translated"><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/item&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> 1</target>       </trans-unit>
        <trans-unit id="849" translate="yes" xml:space="preserve" uid="M:System.Math.Sign(System.Int64)">
          <source><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph><ph id="ph3">&lt;paramref name="value" /&gt;</ph> is greater than zero.</source>
          <target state="translated"><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph><ph id="ph3">&lt;paramref name="value" /&gt;</ph> es mayor que cero.</target>       </trans-unit>
        <trans-unit id="850" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Math.Sign(System.Int64)">
          <source>The following example demonstrates how to use the <ph id="ph1">&lt;xref:System.Math.Sign%28System.Int64%29&gt;</ph> method to determine the sign of an <ph id="ph2">&lt;xref:System.Int64&gt;</ph> value and display it to the console.</source>
          <target state="translated">En el ejemplo siguiente se muestra cómo utilizar el <ph id="ph1">&lt;xref:System.Math.Sign%28System.Int64%29&gt;</ph> método para determinar el signo de un <ph id="ph2">&lt;xref:System.Int64&gt;</ph> valor y mostrarlo en la consola.</target>       </trans-unit>
        <trans-unit id="851" translate="yes" xml:space="preserve" uid="M:System.Math.Sign(System.SByte)">
          <source>A signed number.</source>
          <target state="translated">Número con signo.</target>       </trans-unit>
        <trans-unit id="852" translate="yes" xml:space="preserve" uid="M:System.Math.Sign(System.SByte)">
          <source>Returns an integer that indicates the sign of an 8-bit signed integer.</source>
          <target state="translated">Devuelve un entero que indica el signo de un entero de 8 bits con signo.</target>       </trans-unit>
        <trans-unit id="853" translate="yes" xml:space="preserve" uid="M:System.Math.Sign(System.SByte)">
          <source>A number that indicates the sign of <ph id="ph1">&lt;paramref name="value" /&gt;</ph>, as shown in the following table.</source>
          <target state="translated">Número que indica el signo de <ph id="ph1">&lt;paramref name="value" /&gt;</ph>, como puede verse en la tabla siguiente.</target>       </trans-unit>
        <trans-unit id="854" translate="yes" xml:space="preserve" uid="M:System.Math.Sign(System.SByte)">
          <source><ph id="ph1">&lt;list type="table"&gt;</ph><ph id="ph2">&lt;listheader&gt;</ph><ph id="ph3">&lt;term&gt;</ph> Return value</source>
          <target state="translated"><ph id="ph1">&lt;list type="table"&gt;</ph><ph id="ph2">&lt;listheader&gt;</ph><ph id="ph3">&lt;term&gt;</ph> Valor devuelto</target>       </trans-unit>
        <trans-unit id="855" translate="yes" xml:space="preserve" uid="M:System.Math.Sign(System.SByte)">
          <source><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph> Meaning</source>
          <target state="translated"><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph> Significado</target>       </trans-unit>
        <trans-unit id="856" translate="yes" xml:space="preserve" uid="M:System.Math.Sign(System.SByte)">
          <source><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/listheader&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> -1</source>
          <target state="translated"><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/listheader&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> -1</target>       </trans-unit>
        <trans-unit id="857" translate="yes" xml:space="preserve" uid="M:System.Math.Sign(System.SByte)">
          <source><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph><ph id="ph3">&lt;paramref name="value" /&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph><ph id="ph3">&lt;paramref name="value" /&gt;</ph> es menor que cero.</target>       </trans-unit>
        <trans-unit id="858" translate="yes" xml:space="preserve" uid="M:System.Math.Sign(System.SByte)">
          <source><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/item&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> 0</source>
          <target state="translated"><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/item&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> 0</target>       </trans-unit>
        <trans-unit id="859" translate="yes" xml:space="preserve" uid="M:System.Math.Sign(System.SByte)">
          <source><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph><ph id="ph3">&lt;paramref name="value" /&gt;</ph> is equal to zero.</source>
          <target state="translated"><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph><ph id="ph3">&lt;paramref name="value" /&gt;</ph> es igual a cero.</target>       </trans-unit>
        <trans-unit id="860" translate="yes" xml:space="preserve" uid="M:System.Math.Sign(System.SByte)">
          <source><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/item&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> 1</source>
          <target state="translated"><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/item&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> 1</target>       </trans-unit>
        <trans-unit id="861" translate="yes" xml:space="preserve" uid="M:System.Math.Sign(System.SByte)">
          <source><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph><ph id="ph3">&lt;paramref name="value" /&gt;</ph> is greater than zero.</source>
          <target state="translated"><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph><ph id="ph3">&lt;paramref name="value" /&gt;</ph> es mayor que cero.</target>       </trans-unit>
        <trans-unit id="862" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Math.Sign(System.SByte)">
          <source>The following example demonstrates how to use the <ph id="ph1">&lt;xref:System.Math.Sign%28System.SByte%29&gt;</ph> method to determine the sign of an <ph id="ph2">&lt;xref:System.SByte&gt;</ph> value and display it to the console.</source>
          <target state="translated">En el ejemplo siguiente se muestra cómo utilizar el <ph id="ph1">&lt;xref:System.Math.Sign%28System.SByte%29&gt;</ph> método para determinar el signo de un <ph id="ph2">&lt;xref:System.SByte&gt;</ph> valor y mostrarlo en la consola.</target>       </trans-unit>
        <trans-unit id="863" translate="yes" xml:space="preserve" uid="M:System.Math.Sign(System.Single)">
          <source>A signed number.</source>
          <target state="translated">Número con signo.</target>       </trans-unit>
        <trans-unit id="864" translate="yes" xml:space="preserve" uid="M:System.Math.Sign(System.Single)">
          <source>Returns an integer that indicates the sign of a single-precision floating-point number.</source>
          <target state="translated">Devuelve un entero que indica el signo de un número de punto flotante de precisión sencilla.</target>       </trans-unit>
        <trans-unit id="865" translate="yes" xml:space="preserve" uid="M:System.Math.Sign(System.Single)">
          <source>A number that indicates the sign of <ph id="ph1">&lt;paramref name="value" /&gt;</ph>, as shown in the following table.</source>
          <target state="translated">Número que indica el signo de <ph id="ph1">&lt;paramref name="value" /&gt;</ph>, como puede verse en la tabla siguiente.</target>       </trans-unit>
        <trans-unit id="866" translate="yes" xml:space="preserve" uid="M:System.Math.Sign(System.Single)">
          <source><ph id="ph1">&lt;list type="table"&gt;</ph><ph id="ph2">&lt;listheader&gt;</ph><ph id="ph3">&lt;term&gt;</ph> Return value</source>
          <target state="translated"><ph id="ph1">&lt;list type="table"&gt;</ph><ph id="ph2">&lt;listheader&gt;</ph><ph id="ph3">&lt;term&gt;</ph> Valor devuelto</target>       </trans-unit>
        <trans-unit id="867" translate="yes" xml:space="preserve" uid="M:System.Math.Sign(System.Single)">
          <source><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph> Meaning</source>
          <target state="translated"><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph> Significado</target>       </trans-unit>
        <trans-unit id="868" translate="yes" xml:space="preserve" uid="M:System.Math.Sign(System.Single)">
          <source><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/listheader&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> -1</source>
          <target state="translated"><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/listheader&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> -1</target>       </trans-unit>
        <trans-unit id="869" translate="yes" xml:space="preserve" uid="M:System.Math.Sign(System.Single)">
          <source><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph><ph id="ph3">&lt;paramref name="value" /&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph><ph id="ph3">&lt;paramref name="value" /&gt;</ph> es menor que cero.</target>       </trans-unit>
        <trans-unit id="870" translate="yes" xml:space="preserve" uid="M:System.Math.Sign(System.Single)">
          <source><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/item&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> 0</source>
          <target state="translated"><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/item&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> 0</target>       </trans-unit>
        <trans-unit id="871" translate="yes" xml:space="preserve" uid="M:System.Math.Sign(System.Single)">
          <source><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph><ph id="ph3">&lt;paramref name="value" /&gt;</ph> is equal to zero.</source>
          <target state="translated"><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph><ph id="ph3">&lt;paramref name="value" /&gt;</ph> es igual a cero.</target>       </trans-unit>
        <trans-unit id="872" translate="yes" xml:space="preserve" uid="M:System.Math.Sign(System.Single)">
          <source><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/item&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> 1</source>
          <target state="translated"><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/item&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> 1</target>       </trans-unit>
        <trans-unit id="873" translate="yes" xml:space="preserve" uid="M:System.Math.Sign(System.Single)">
          <source><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph><ph id="ph3">&lt;paramref name="value" /&gt;</ph> is greater than zero.</source>
          <target state="translated"><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph><ph id="ph3">&lt;paramref name="value" /&gt;</ph> es mayor que cero.</target>       </trans-unit>
        <trans-unit id="874" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Math.Sign(System.Single)">
          <source>The following example demonstrates how to use the <ph id="ph1">&lt;xref:System.Math.Sign%28System.Single%29&gt;</ph> method to determine the sign of a <ph id="ph2">&lt;xref:System.Single&gt;</ph> value and display it to the console.</source>
          <target state="translated">En el ejemplo siguiente se muestra cómo utilizar el <ph id="ph1">&lt;xref:System.Math.Sign%28System.Single%29&gt;</ph> método para determinar el signo de un <ph id="ph2">&lt;xref:System.Single&gt;</ph> valor y mostrarlo en la consola.</target>       </trans-unit>
        <trans-unit id="875" translate="yes" xml:space="preserve" uid="M:System.Math.Sign(System.Single)">
          <source><ph id="ph1">&lt;paramref name="value" /&gt;</ph> is equal to <ph id="ph2">&lt;see cref="F:System.Single.NaN" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="value" /&gt;</ph> es igual a <ph id="ph2">&lt;see cref="F:System.Single.NaN" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="876" translate="yes" xml:space="preserve" uid="M:System.Math.Sin(System.Double)">
          <source>An angle, measured in radians.</source>
          <target state="translated">Ángulo, medido en radianes.</target>       </trans-unit>
        <trans-unit id="877" translate="yes" xml:space="preserve" uid="M:System.Math.Sin(System.Double)">
          <source>Returns the sine of the specified angle.</source>
          <target state="translated">Devuelve el seno del ángulo especificado.</target>       </trans-unit>
        <trans-unit id="878" translate="yes" xml:space="preserve" uid="M:System.Math.Sin(System.Double)">
          <source>The sine of <ph id="ph1">&lt;paramref name="a" /&gt;</ph>.</source>
          <target state="translated">Seno de <ph id="ph1">&lt;paramref name="a" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="879" translate="yes" xml:space="preserve" uid="M:System.Math.Sin(System.Double)">
          <source>If <ph id="ph1">&lt;paramref name="a" /&gt;</ph> is equal to <ph id="ph2">&lt;see cref="F:System.Double.NaN" /&gt;</ph>, <ph id="ph3">&lt;see cref="F:System.Double.NegativeInfinity" /&gt;</ph>, or <ph id="ph4">&lt;see cref="F:System.Double.PositiveInfinity" /&gt;</ph>, this method returns <ph id="ph5">&lt;see cref="F:System.Double.NaN" /&gt;</ph>.</source>
          <target state="translated">Si <ph id="ph1">&lt;paramref name="a" /&gt;</ph> es igual a <ph id="ph2">&lt;see cref="F:System.Double.NaN" /&gt;</ph>, <ph id="ph3">&lt;see cref="F:System.Double.NegativeInfinity" /&gt;</ph> o <ph id="ph4">&lt;see cref="F:System.Double.PositiveInfinity" /&gt;</ph>, este método devuelve <ph id="ph5">&lt;see cref="F:System.Double.NaN" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="880" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Math.Sin(System.Double)">
          <source>The angle, <ph id="ph1">`a`</ph>, must be in radians.</source>
          <target state="translated">El ángulo, <ph id="ph1">`a`</ph>, deben estar en radianes.</target>       </trans-unit>
        <trans-unit id="881" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Math.Sin(System.Double)">
          <source>Multiply by <ph id="ph1">&lt;xref:System.Math.PI?displayProperty=nameWithType&gt;</ph>/180 to convert degrees to radians.</source>
          <target state="translated">Multiplicar por <ph id="ph1">&lt;xref:System.Math.PI?displayProperty=nameWithType&gt;</ph>/180 para convertir los grados en radianes.</target>       </trans-unit>
        <trans-unit id="882" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Math.Sin(System.Double)">
          <source>Acceptable values of <ph id="ph1">`a`</ph> range from approximately -9223372036854775295 to approximately 9223372036854775295.</source>
          <target state="translated">Los valores aceptables de <ph id="ph1">`a`</ph> intervalo de aproximadamente -9223372036854775295 a aproximadamente 9223372036854775295.</target>       </trans-unit>
        <trans-unit id="883" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Math.Sin(System.Double)">
          <source>For values outside of this range, the <ph id="ph1">&lt;xref:System.Math.Sin%2A&gt;</ph> method returns <ph id="ph2">`a`</ph> unchanged rather than throwing an exception.</source>
          <target state="translated">Para valores fuera de este intervalo, el <ph id="ph1">&lt;xref:System.Math.Sin%2A&gt;</ph> método <ph id="ph2">`a`</ph> sin cambios en lugar de producir una excepción.</target>       </trans-unit>
        <trans-unit id="884" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Math.Sin(System.Double)">
          <source>The following example uses <ph id="ph1">&lt;xref:System.Math.Sin%2A&gt;</ph> to evaluate certain trigonometric identities for selected angles.</source>
          <target state="translated">En el ejemplo siguiente se utiliza <ph id="ph1">&lt;xref:System.Math.Sin%2A&gt;</ph> para evaluar determinadas identidades trigonométricas de ángulos seleccionados.</target>       </trans-unit>
        <trans-unit id="885" translate="yes" xml:space="preserve" uid="M:System.Math.Sinh(System.Double)">
          <source>An angle, measured in radians.</source>
          <target state="translated">Ángulo, medido en radianes.</target>       </trans-unit>
        <trans-unit id="886" translate="yes" xml:space="preserve" uid="M:System.Math.Sinh(System.Double)">
          <source>Returns the hyperbolic sine of the specified angle.</source>
          <target state="translated">Devuelve el seno hiperbólico del ángulo especificado.</target>       </trans-unit>
        <trans-unit id="887" translate="yes" xml:space="preserve" uid="M:System.Math.Sinh(System.Double)">
          <source>The hyperbolic sine of <ph id="ph1">&lt;paramref name="value" /&gt;</ph>.</source>
          <target state="translated">Seno hiperbólico de <ph id="ph1">&lt;paramref name="value" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="888" translate="yes" xml:space="preserve" uid="M:System.Math.Sinh(System.Double)">
          <source>If <ph id="ph1">&lt;paramref name="value" /&gt;</ph> is equal to <ph id="ph2">&lt;see cref="F:System.Double.NegativeInfinity" /&gt;</ph>, <ph id="ph3">&lt;see cref="F:System.Double.PositiveInfinity" /&gt;</ph>, or <ph id="ph4">&lt;see cref="F:System.Double.NaN" /&gt;</ph>, this method returns a <ph id="ph5">&lt;see cref="T:System.Double" /&gt;</ph> equal to <ph id="ph6">&lt;paramref name="value" /&gt;</ph>.</source>
          <target state="translated">Si <ph id="ph1">&lt;paramref name="value" /&gt;</ph> es igual a <ph id="ph2">&lt;see cref="F:System.Double.NegativeInfinity" /&gt;</ph>, <ph id="ph3">&lt;see cref="F:System.Double.PositiveInfinity" /&gt;</ph> o <ph id="ph4">&lt;see cref="F:System.Double.NaN" /&gt;</ph>, este método devuelve <ph id="ph5">&lt;see cref="T:System.Double" /&gt;</ph> igual a <ph id="ph6">&lt;paramref name="value" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="889" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Math.Sinh(System.Double)">
          <source>The angle, <ph id="ph1">`value`</ph>, must be in radians.</source>
          <target state="translated">El ángulo, <ph id="ph1">`value`</ph>, deben estar en radianes.</target>       </trans-unit>
        <trans-unit id="890" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Math.Sinh(System.Double)">
          <source>Multiply by <ph id="ph1">&lt;xref:System.Math.PI?displayProperty=nameWithType&gt;</ph>/180 to convert degrees to radians.</source>
          <target state="translated">Multiplicar por <ph id="ph1">&lt;xref:System.Math.PI?displayProperty=nameWithType&gt;</ph>/180 para convertir los grados en radianes.</target>       </trans-unit>
        <trans-unit id="891" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Math.Sinh(System.Double)">
          <source>The following example uses <ph id="ph1">&lt;xref:System.Math.Sinh%2A&gt;</ph> to evaluate certain hyperbolic identities for selected values.</source>
          <target state="translated">En el ejemplo siguiente se utiliza <ph id="ph1">&lt;xref:System.Math.Sinh%2A&gt;</ph> para evaluar determinadas identidades hiperbólicas de valores seleccionados.</target>       </trans-unit>
        <trans-unit id="892" translate="yes" xml:space="preserve" uid="M:System.Math.Sqrt(System.Double)">
          <source>The number whose square root is to be found.</source>
          <target state="translated">Número cuya raíz cuadrada se va a calcular.</target>       </trans-unit>
        <trans-unit id="893" translate="yes" xml:space="preserve" uid="M:System.Math.Sqrt(System.Double)">
          <source>Returns the square root of a specified number.</source>
          <target state="translated">Devuelve la raíz cuadrada de un número especificado.</target>       </trans-unit>
        <trans-unit id="894" translate="yes" xml:space="preserve" uid="M:System.Math.Sqrt(System.Double)">
          <source>One of the values in the following table.</source>
          <target state="translated">Uno de los valores de la tabla siguiente.</target>       </trans-unit>
        <trans-unit id="895" translate="yes" xml:space="preserve" uid="M:System.Math.Sqrt(System.Double)">
          <source><ph id="ph1">&lt;list type="table"&gt;</ph><ph id="ph2">&lt;listheader&gt;</ph><ph id="ph3">&lt;term&gt;</ph><ph id="ph4">&lt;paramref name="d" /&gt;</ph> parameter</source>
          <target state="translated"><ph id="ph1">&lt;list type="table"&gt;</ph><ph id="ph2">&lt;listheader&gt;</ph><ph id="ph3">&lt;term&gt;</ph>Parámetro <ph id="ph4">&lt;paramref name="d" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="896" translate="yes" xml:space="preserve" uid="M:System.Math.Sqrt(System.Double)">
          <source><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph> Return value</source>
          <target state="translated"><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph> Valor devuelto</target>       </trans-unit>
        <trans-unit id="897" translate="yes" xml:space="preserve" uid="M:System.Math.Sqrt(System.Double)">
          <source><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/listheader&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> Zero or positive</source>
          <target state="translated"><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/listheader&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> Cero o positivo</target>       </trans-unit>
        <trans-unit id="898" translate="yes" xml:space="preserve" uid="M:System.Math.Sqrt(System.Double)">
          <source><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph> The positive square root of <ph id="ph3">&lt;paramref name="d" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph> Raíz cuadrada positiva de <ph id="ph3">&lt;paramref name="d" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="899" translate="yes" xml:space="preserve" uid="M:System.Math.Sqrt(System.Double)">
          <source><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/item&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> Negative</source>
          <target state="translated"><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/item&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> Negativo</target>       </trans-unit>
        <trans-unit id="900" translate="yes" xml:space="preserve" uid="M:System.Math.Sqrt(System.Double)">
          <source><ph id="ph1">&lt;/term&gt;</ph><bpt id="p1">&lt;description&gt;</bpt><ph id="ph2">&lt;see cref="F:System.Double.NaN" /&gt;</ph><ept id="p1">&lt;/description&gt;</ept><ph id="ph3">&lt;/item&gt;</ph><bpt id="p2">&lt;item&gt;</bpt><bpt id="p3">&lt;term&gt;</bpt> Equals <ph id="ph4">&lt;see cref="F:System.Double.NaN" /&gt;</ph><ept id="p3">&lt;/term&gt;</ept><bpt id="p4">&lt;description&gt;</bpt><ph id="ph5">&lt;see cref="F:System.Double.NaN" /&gt;</ph><ept id="p4">&lt;/description&gt;</ept><ept id="p2">&lt;/item&gt;</ept><bpt id="p5">&lt;item&gt;</bpt><bpt id="p6">&lt;term&gt;</bpt> Equals <ph id="ph6">&lt;see cref="F:System.Double.PositiveInfinity" /&gt;</ph><ept id="p6">&lt;/term&gt;</ept><bpt id="p7">&lt;description&gt;</bpt><ph id="ph7">&lt;see cref="F:System.Double.PositiveInfinity" /&gt;</ph><ept id="p7">&lt;/description&gt;</ept><ept id="p5">&lt;/item&gt;</ept><ph id="ph8">&lt;/list&gt;</ph></source>
          <target state="translated"><ph id="ph1">&lt;/term&gt;</ph><bpt id="p1">&lt;description&gt;</bpt><ph id="ph2">&lt;see cref="F:System.Double.NaN" /&gt;</ph><ept id="p1">&lt;/description&gt;</ept><ph id="ph3">&lt;/item&gt;</ph><bpt id="p2">&lt;item&gt;</bpt><bpt id="p3">&lt;term&gt;</bpt> Igual a <ph id="ph4">&lt;see cref="F:System.Double.NaN" /&gt;</ph><ept id="p3">&lt;/term&gt;</ept><bpt id="p4">&lt;description&gt;</bpt><ph id="ph5">&lt;see cref="F:System.Double.NaN" /&gt;</ph><ept id="p4">&lt;/description&gt;</ept><ept id="p2">&lt;/item&gt;</ept><bpt id="p5">&lt;item&gt;</bpt><bpt id="p6">&lt;term&gt;</bpt> Igual a <ph id="ph6">&lt;see cref="F:System.Double.PositiveInfinity" /&gt;</ph><ept id="p6">&lt;/term&gt;</ept><bpt id="p7">&lt;description&gt;</bpt><ph id="ph7">&lt;see cref="F:System.Double.PositiveInfinity" /&gt;</ph><ept id="p7">&lt;/description&gt;</ept><ept id="p5">&lt;/item&gt;</ept><ph id="ph8">&lt;/list&gt;</ph></target>       </trans-unit>
        <trans-unit id="901" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Math.Sqrt(System.Double)">
          <source>The square root of the area of a square represents the length of any side of the square.</source>
          <target state="translated">La raíz cuadrada del área de un cuadrado representa la longitud de cualquier lado del cuadrado.</target>       </trans-unit>
        <trans-unit id="902" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Math.Sqrt(System.Double)">
          <source>The following example displays the area of some cities in the United States and gives an impression of each city's size if it were represented by a square.</source>
          <target state="translated">En el ejemplo siguiente se muestra el área de algunas ciudades en los Estados Unidos y da como resultado una impresión del tamaño de cada ciudad si se han representado por un cuadrado.</target>       </trans-unit>
        <trans-unit id="903" translate="yes" xml:space="preserve" uid="M:System.Math.Tan(System.Double)">
          <source>An angle, measured in radians.</source>
          <target state="translated">Ángulo, medido en radianes.</target>       </trans-unit>
        <trans-unit id="904" translate="yes" xml:space="preserve" uid="M:System.Math.Tan(System.Double)">
          <source>Returns the tangent of the specified angle.</source>
          <target state="translated">Devuelve la tangente del ángulo especificado.</target>       </trans-unit>
        <trans-unit id="905" translate="yes" xml:space="preserve" uid="M:System.Math.Tan(System.Double)">
          <source>The tangent of <ph id="ph1">&lt;paramref name="a" /&gt;</ph>.</source>
          <target state="translated">Tangente de <ph id="ph1">&lt;paramref name="a" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="906" translate="yes" xml:space="preserve" uid="M:System.Math.Tan(System.Double)">
          <source>If <ph id="ph1">&lt;paramref name="a" /&gt;</ph> is equal to <ph id="ph2">&lt;see cref="F:System.Double.NaN" /&gt;</ph>, <ph id="ph3">&lt;see cref="F:System.Double.NegativeInfinity" /&gt;</ph>, or <ph id="ph4">&lt;see cref="F:System.Double.PositiveInfinity" /&gt;</ph>, this method returns <ph id="ph5">&lt;see cref="F:System.Double.NaN" /&gt;</ph>.</source>
          <target state="translated">Si <ph id="ph1">&lt;paramref name="a" /&gt;</ph> es igual a <ph id="ph2">&lt;see cref="F:System.Double.NaN" /&gt;</ph>, <ph id="ph3">&lt;see cref="F:System.Double.NegativeInfinity" /&gt;</ph> o <ph id="ph4">&lt;see cref="F:System.Double.PositiveInfinity" /&gt;</ph>, este método devuelve <ph id="ph5">&lt;see cref="F:System.Double.NaN" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="907" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Math.Tan(System.Double)">
          <source>The angle, <ph id="ph1">`a`</ph>, must be in radians.</source>
          <target state="translated">El ángulo, <ph id="ph1">`a`</ph>, deben estar en radianes.</target>       </trans-unit>
        <trans-unit id="908" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Math.Tan(System.Double)">
          <source>Multiply by <ph id="ph1">&lt;xref:System.Math.PI?displayProperty=nameWithType&gt;</ph>/180 to convert degrees to radians.</source>
          <target state="translated">Multiplicar por <ph id="ph1">&lt;xref:System.Math.PI?displayProperty=nameWithType&gt;</ph>/180 para convertir los grados en radianes.</target>       </trans-unit>
        <trans-unit id="909" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Math.Tan(System.Double)">
          <source>The following example demonstrates how to calculate the tangent of an angle and display it to the console.</source>
          <target state="translated">En el ejemplo siguiente se muestra cómo calcular la tangente de un ángulo y mostrarlo en la consola.</target>       </trans-unit>
        <trans-unit id="910" translate="yes" xml:space="preserve" uid="M:System.Math.Tanh(System.Double)">
          <source>An angle, measured in radians.</source>
          <target state="translated">Ángulo, medido en radianes.</target>       </trans-unit>
        <trans-unit id="911" translate="yes" xml:space="preserve" uid="M:System.Math.Tanh(System.Double)">
          <source>Returns the hyperbolic tangent of the specified angle.</source>
          <target state="translated">Devuelve la tangente hiperbólica del ángulo especificado.</target>       </trans-unit>
        <trans-unit id="912" translate="yes" xml:space="preserve" uid="M:System.Math.Tanh(System.Double)">
          <source>The hyperbolic tangent of <ph id="ph1">&lt;paramref name="value" /&gt;</ph>.</source>
          <target state="translated">Tangente hiperbólica de <ph id="ph1">&lt;paramref name="value" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="913" translate="yes" xml:space="preserve" uid="M:System.Math.Tanh(System.Double)">
          <source>If <ph id="ph1">&lt;paramref name="value" /&gt;</ph> is equal to <ph id="ph2">&lt;see cref="F:System.Double.NegativeInfinity" /&gt;</ph>, this method returns -1.</source>
          <target state="translated">Si <ph id="ph1">&lt;paramref name="value" /&gt;</ph> es igual a <ph id="ph2">&lt;see cref="F:System.Double.NegativeInfinity" /&gt;</ph>, este método devuelve -1.</target>       </trans-unit>
        <trans-unit id="914" translate="yes" xml:space="preserve" uid="M:System.Math.Tanh(System.Double)">
          <source>If value is equal to <ph id="ph1">&lt;see cref="F:System.Double.PositiveInfinity" /&gt;</ph>, this method returns 1.</source>
          <target state="translated">Si el valor es igual a <ph id="ph1">&lt;see cref="F:System.Double.PositiveInfinity" /&gt;</ph>, este método devuelve 1.</target>       </trans-unit>
        <trans-unit id="915" translate="yes" xml:space="preserve" uid="M:System.Math.Tanh(System.Double)">
          <source>If <ph id="ph1">&lt;paramref name="value" /&gt;</ph> is equal to <ph id="ph2">&lt;see cref="F:System.Double.NaN" /&gt;</ph>, this method returns <ph id="ph3">&lt;see cref="F:System.Double.NaN" /&gt;</ph>.</source>
          <target state="translated">Si <ph id="ph1">&lt;paramref name="value" /&gt;</ph> es igual a <ph id="ph2">&lt;see cref="F:System.Double.NaN" /&gt;</ph>, este método devuelve <ph id="ph3">&lt;see cref="F:System.Double.NaN" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="916" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Math.Tanh(System.Double)">
          <source>The angle, <ph id="ph1">`value`</ph>, must be in radians.</source>
          <target state="translated">El ángulo, <ph id="ph1">`value`</ph>, deben estar en radianes.</target>       </trans-unit>
        <trans-unit id="917" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Math.Tanh(System.Double)">
          <source>Multiply by <ph id="ph1">&lt;xref:System.Math.PI?displayProperty=nameWithType&gt;</ph>/180 to convert degrees to radians.</source>
          <target state="translated">Multiplicar por <ph id="ph1">&lt;xref:System.Math.PI?displayProperty=nameWithType&gt;</ph>/180 para convertir los grados en radianes.</target>       </trans-unit>
        <trans-unit id="918" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Math.Tanh(System.Double)">
          <source>The following example uses <ph id="ph1">&lt;xref:System.Math.Tanh%2A&gt;</ph> to evaluate certain hyperbolic tangent identities for selected values.</source>
          <target state="translated">En el ejemplo siguiente se utiliza <ph id="ph1">&lt;xref:System.Math.Tanh%2A&gt;</ph> para evaluar determinadas identidades de tangente hiperbólica de valores seleccionados.</target>       </trans-unit>
        <trans-unit id="919" translate="yes" xml:space="preserve" uid="T:System.Math">
          <source>Calculates the integral part of a number.</source>
          <target state="translated">Calcula la parte entera de un número.</target>       </trans-unit>
        <trans-unit id="920" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Math">
          <source>The number is rounded to the nearest integer towards zero.</source>
          <target state="translated">El número se redondea al entero más próximo a cero.</target>       </trans-unit>
        <trans-unit id="921" translate="yes" xml:space="preserve" uid="M:System.Math.Truncate(System.Decimal)">
          <source>A number to truncate.</source>
          <target state="translated">Número que se va a truncar.</target>       </trans-unit>
        <trans-unit id="922" translate="yes" xml:space="preserve" uid="M:System.Math.Truncate(System.Decimal)">
          <source>Calculates the integral part of a specified decimal number.</source>
          <target state="translated">Calcula la parte entera de un número decimal especificado.</target>       </trans-unit>
        <trans-unit id="923" translate="yes" xml:space="preserve" uid="M:System.Math.Truncate(System.Decimal)">
          <source>The integral part of <ph id="ph1">&lt;paramref name="d" /&gt;</ph>; that is, the number that remains after any fractional digits have been discarded.</source>
          <target state="translated">Parte entera de <ph id="ph1">&lt;paramref name="d" /&gt;</ph>, es decir, el número que queda después de descartar los dígitos fraccionarios.</target>       </trans-unit>
        <trans-unit id="924" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Math.Truncate(System.Decimal)">
          <source><ph id="ph1">&lt;xref:System.Math.Truncate%2A&gt;</ph> rounds <ph id="ph2">`d`</ph> to the nearest integer towards zero.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Math.Truncate%2A&gt;</ph> redondea <ph id="ph2">`d`</ph> al entero más próximo a cero.</target>       </trans-unit>
        <trans-unit id="925" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Math.Truncate(System.Decimal)">
          <source>The following example calls the <ph id="ph1">&lt;xref:System.Math.Truncate%28System.Decimal%29&gt;</ph> method to truncate both a positive and a negative <ph id="ph2">&lt;xref:System.Decimal&gt;</ph> value.</source>
          <target state="translated">El ejemplo siguiente se llama el <ph id="ph1">&lt;xref:System.Math.Truncate%28System.Decimal%29&gt;</ph> método truncar positivo y negativo <ph id="ph2">&lt;xref:System.Decimal&gt;</ph> valor.</target>       </trans-unit>
        <trans-unit id="926" translate="yes" xml:space="preserve" uid="M:System.Math.Truncate(System.Double)">
          <source>A number to truncate.</source>
          <target state="translated">Número que se va a truncar.</target>       </trans-unit>
        <trans-unit id="927" translate="yes" xml:space="preserve" uid="M:System.Math.Truncate(System.Double)">
          <source>Calculates the integral part of a specified double-precision floating-point number.</source>
          <target state="translated">Calcula la parte entera de un número de punto flotante de precisión doble especificado.</target>       </trans-unit>
        <trans-unit id="928" translate="yes" xml:space="preserve" uid="M:System.Math.Truncate(System.Double)">
          <source>The integral part of <ph id="ph1">&lt;paramref name="d" /&gt;</ph>; that is, the number that remains after any fractional digits have been discarded, or one of the values listed in the following table.</source>
          <target state="translated">La parte entera de <ph id="ph1">&lt;paramref name="d" /&gt;</ph>, es decir, el número que permanece una vez descartado cualquier dígito fraccionario o uno de los valores enumerados en la siguiente tabla.</target>       </trans-unit>
        <trans-unit id="929" translate="yes" xml:space="preserve" uid="M:System.Math.Truncate(System.Double)">
          <source><ph id="ph1">&lt;list type="table"&gt;</ph><ph id="ph2">&lt;listheader&gt;</ph><bpt id="p1">&lt;term&gt;</bpt><ph id="ph3">&lt;paramref name="d" /&gt;</ph><ept id="p1">&lt;/term&gt;</ept><ph id="ph4">&lt;description&gt;</ph> Return value</source>
          <target state="translated"><ph id="ph1">&lt;list type="table"&gt;</ph><ph id="ph2">&lt;listheader&gt;</ph><bpt id="p1">&lt;term&gt;</bpt><ph id="ph3">&lt;paramref name="d" /&gt;</ph><ept id="p1">&lt;/term&gt;</ept><ph id="ph4">&lt;description&gt;</ph> Valor devuelto</target>       </trans-unit>
        <trans-unit id="930" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Math.Truncate(System.Double)">
          <source><ph id="ph1">&lt;xref:System.Math.Truncate%2A&gt;</ph> rounds <ph id="ph2">`d`</ph> to the nearest integer towards zero.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Math.Truncate%2A&gt;</ph> redondea <ph id="ph2">`d`</ph> al entero más próximo a cero.</target>       </trans-unit>
        <trans-unit id="931" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Math.Truncate(System.Double)">
          <source>The following example calls the <ph id="ph1">&lt;xref:System.Math.Truncate%28System.Double%29&gt;</ph> method to truncate both a positive and a negative <ph id="ph2">&lt;xref:System.Double&gt;</ph> value.</source>
          <target state="translated">El ejemplo siguiente se llama el <ph id="ph1">&lt;xref:System.Math.Truncate%28System.Double%29&gt;</ph> método truncar positivo y negativo <ph id="ph2">&lt;xref:System.Double&gt;</ph> valor.</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>