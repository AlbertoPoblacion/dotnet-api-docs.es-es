<Type Name="IDisposable" FullName="System.IDisposable">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="1e6b408b88af2e3e5027106be9c33751cc9e19c3" />
    <Meta Name="ms.sourcegitcommit" Value="3907f9a5780957d9c85af2e54c0a5bc2a5bf19ab" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="es-ES" />
    <Meta Name="ms.lasthandoff" Value="06/14/2018" />
    <Meta Name="ms.locfileid" Value="34452205" />
  </Metadata>
  <TypeSignature Language="C#" Value="public interface IDisposable" />
  <TypeSignature Language="ILAsm" Value=".class public interface auto ansi abstract IDisposable" />
  <TypeSignature Language="DocId" Value="T:System.IDisposable" />
  <TypeSignature Language="VB.NET" Value="Public Interface IDisposable" />
  <TypeSignature Language="C++ CLI" Value="public interface class IDisposable" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Proporciona un mecanismo para liberar recursos no administrados.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Es el uso principal de esta interfaz liberar recursos no administrados. El recolector de elementos no utilizados libera automáticamente la memoria asignada a un objeto administrado cuando ya no se utiliza ese objeto. Sin embargo, no es posible predecir cuándo se realizará la recolección de elementos. Además, el recolector de elementos no utilizados no tiene ningún conocimiento de los recursos no administrados como identificadores de ventanas o abrir archivos y secuencias.  
  
 Use la <xref:System.IDisposable.Dispose%2A> método de esta interfaz para liberar explícitamente los recursos no administrados que junto con el recolector de elementos no utilizados. El consumidor de un objeto puede llamar a este método cuando el objeto ya no es necesario.  
  
> [!WARNING]
>  Es una novedad para agregar el <xref:System.IDisposable> interfaz a una clase existente. Porque ya existentes a los consumidores de su tipo no pueden llamar a <xref:System.IDisposable.Dispose%2A>, no puede estar seguro de que se publican los recursos no administrados mantenidos por su tipo.  
  
 Dado que la <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType> implementación es invocada por el consumidor de un tipo cuando ya no son necesarios los recursos que pertenecen a una instancia, o bien debe encapsular el objeto administrado en un <xref:System.Runtime.InteropServices.SafeHandle> (la alternativa recomendada), o se debe invalidar <xref:System.Object.Finalize%2A?displayProperty=nameWithType> para liberar recursos no administrados en caso de que el consumidor olvide llamar a <xref:System.IDisposable.Dispose%2A>.  
  
> [!IMPORTANT]
>  En .NET Framework, el compilador de C++ admite la eliminación determinista de recursos y no se permite la implementación directa de la <xref:System.IDisposable.Dispose%2A> método.  
  
 Para obtener una explicación detallada acerca de cómo esta interfaz y la <xref:System.Object.Finalize%2A?displayProperty=nameWithType> método se usan, vea la [recolección](~/docs/standard/garbage-collection/index.md) y [implementa un método Dispose](~/docs/standard/garbage-collection/implementing-dispose.md) temas.  
  
## <a name="using-an-object-that-implements-idisposable"></a>Usar un objeto que implementa la interfaz IDisposable  
 Si la aplicación simplemente utiliza un objeto que implementa el <xref:System.IDisposable> interfaz, debe llamar a del objeto <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType> implementación cuando haya terminado de usarlo. Dependiendo del lenguaje de programación, puede hacerlo de dos maneras:  
  
-   Mediante el lenguaje construir como el `using` instrucción en C# y Visual Basic.  
  
-   Al ajustar la llamada a la <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType> implementación en un `try` / `finally` bloque.  
  
> [!NOTE]
>  Documentación de los tipos que implementan <xref:System.IDisposable> tenga en cuenta este hecho e incluir un recordatorio para llamar a su <xref:System.IDisposable.Dispose%2A> implementación.  
  
<a name="Using"></a>   
### <a name="the-c-and-visual-basic-using-statement"></a>La instrucción de C# y Visual Basic utilizan  
 Si su lenguaje admite una construcción como la [con](~/docs/csharp/language-reference/keywords/using.md) instrucción en C# y la [mediante](~/docs/visual-basic/language-reference/statements/using-statement.md) instrucción en Visual Basic, puede usar en lugar de llamar explícitamente a <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType> usted mismo. En el ejemplo siguiente se usa este enfoque en la definición de un `WordCount` clase que conserva la información acerca de un archivo y el número de palabras en ella.  
  
 [!code-csharp[System.IDisposable#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.idisposable/cs/calling1.cs#1)]
 [!code-vb[System.IDisposable#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.idisposable/vb/calling1.vb#1)]  
  
 El `using` instrucción es realmente una comodidad sintáctica. En tiempo de compilación, el compilador de lenguaje implementa el lenguaje intermedio (IL) para una `try` / `finally` bloque.  
  
 Para obtener más información sobre la `using` instrucción, consulte la [instrucción Using](~/docs/visual-basic/language-reference/statements/using-statement.md) o [mediante la instrucción](~/docs/csharp/language-reference/keywords/using-statement.md) temas.  
  
### <a name="the-tryfinally-block"></a>El bloque Try/Finally  
 Si su lenguaje de programación no admite una construcción como la `using` instrucción en C# o Visual Basic, o si no desea usarlo, puede llamar a la <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType> implementación desde el `finally` bloquear de un `try` / `finally` instrucción. En el ejemplo siguiente se reemplaza el `using` bloquear en el ejemplo anterior con un `try` / `finally` bloque.  
  
 [!code-csharp[System.IDisposable#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.idisposable/cs/calling2.cs#2)]
 [!code-vb[System.IDisposable#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.idisposable/vb/calling2.vb#2)]  
  
 Para obtener más información sobre la `try` / `finally` de patrón, vea [intente... Catch... Finally (instrucción)](~/docs/visual-basic/language-reference/statements/try-catch-finally-statement.md), [try-finally](~/docs/csharp/language-reference/keywords/try-finally.md), o [try-finally (instrucción)](http://msdn.microsoft.com/library/514400c1-c322-4bf3-9e48-3047240b8a82).  
  
## <a name="implementing-idisposable"></a>Implementar IDisposable  
 Debe implementar <xref:System.IDisposable> solo si el tipo utiliza recursos no administrados directamente. Pueden llamar los consumidores de su tipo de su <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType> implementación para liberar recursos cuando ya no es necesaria la instancia. Para controlar los casos en que producirá un error al llamar a <xref:System.IDisposable.Dispose%2A>, debería usar una clase derivada de <xref:System.Runtime.InteropServices.SafeHandle> encapsular los recursos no administrados, o se debe invalidar el <xref:System.Object.Finalize%2A?displayProperty=nameWithType> método para un tipo de referencia. En cualquier caso, use el <xref:System.IDisposable.Dispose%2A> método para realizar cualquier limpieza es necesaria después de usar los recursos no administrados, como la liberación o el restablecimiento de los recursos no administrados.  
  
> [!IMPORTANT]
>  Si va a definir una clase base que utiliza los recursos no administrados y que tiene, o es probable que tenga, subclases que deben estar en su lugar, debe implementar la <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType> método y proporcionar una segunda sobrecarga de `Dispose`, como se describe en la sección siguiente.  
  
<a name="BaseClasses"></a>   
## <a name="idisposable-and-the-inheritance-hierarchy"></a>IDisposable y la jerarquía de herencia  
 Debe implementar una clase base con subclases que deben ser descartables <xref:System.IDisposable> como se indica a continuación. Debe usar este patrón siempre que implemente <xref:System.IDisposable> en cualquier tipo que no es `sealed` (`NotInheritable` en Visual Basic).  
  
-   Debe proporcionar una pública, no virtual <xref:System.IDisposable.Dispose> método y protegidos virtual `Dispose(Boolean disposing)` método.  
  
-   El <xref:System.IDisposable.Dispose> debe llamar al método `Dispose(true)` y se debe suprimir la finalización de rendimiento.  
  
-   El tipo base no debe incluir ningún finalizador.  
  
 El siguiente fragmento de código refleja el patrón de dispose para las clases base. Se supone que el tipo no reemplaza el <xref:System.Object.Finalize%2A?displayProperty=nameWithType> método.  
  
 [!code-csharp[System.IDisposable#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.idisposable/cs/base1.cs#3)]
 [!code-vb[System.IDisposable#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.idisposable/vb/base1.vb#3)]  
  
 Si invalida el <xref:System.Object.Finalize%2A?displayProperty=nameWithType> método, la clase debe implementar el patrón siguiente.  
  
 [!code-csharp[System.IDisposable#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.idisposable/cs/base2.cs#5)]
 [!code-vb[System.IDisposable#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.idisposable/vb/base2.vb#5)]  
  
 Las subclases deben implementar el patrón desechable de la siguiente forma:  
  
-   Deben invalidar `Dispose(Boolean)` y llamar a la implementación `Dispose(Boolean)` de la clase base.  
  
-   Pueden proporcionar un finalizador si es necesario. El finalizador debe llamar a `Dispose(false)`.  
  
 Tenga en cuenta que las clases derivadas no propios implementen el <xref:System.IDisposable> interfaz y no incluyen una sin parámetros <xref:System.IDisposable.Dispose%2A> método. Solo invalidan la clase base `Dispose(Boolean)` método.  
  
 El siguiente fragmento de código refleja el patrón de dispose para las clases derivadas. Se supone que el tipo no reemplaza el <xref:System.Object.Finalize%2A?displayProperty=nameWithType> método.  
  
 [!code-csharp[System.IDisposable#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.idisposable/cs/derived1.cs#4)]
 [!code-vb[System.IDisposable#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.idisposable/vb/derived1.vb#4)]  
  
   
  
## Examples  
 En el ejemplo siguiente se muestra cómo crear una clase de recurso que implementa el <xref:System.IDisposable> interfaz.  
  
 [!code-cpp[System.IDisposable.Dispose Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IDisposable.Dispose Example/CPP/idisposabledispose.cpp#1)]
 [!code-csharp[System.IDisposable.Dispose Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IDisposable.Dispose Example/CS/idisposabledispose.cs#1)]
 [!code-vb[System.IDisposable.Dispose Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IDisposable.Dispose Example/VB/idisposabledispose.vb#1)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:Microsoft.Win32.SafeHandles.SafeFileHandle" />
  </Docs>
  <Members>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IDisposable.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Dispose();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Realiza tareas definidas por la aplicación asociadas a la liberación o al restablecimiento de recursos no administrados.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilice este método para cerrar o liberar recursos no administrados como archivos, secuencias e identificadores mantenidos por una instancia de la clase que implementa esta interfaz. Por convención, este método se utiliza para todas las tareas asociadas con la liberación de los recursos mantenidos por un objeto, o preparar un objeto para su reutilización.  
  
> [!WARNING]
>  Si está utilizando una clase que implementa el <xref:System.IDisposable> interfaz, debe llamar a su <xref:System.IDisposable.Dispose%2A> cuando haya terminado de usar la clase de implementación. Para obtener más información, vea la sección "Usar un objeto que implementa la interfaz IDisposable" en el <xref:System.IDisposable> tema.  
  
 Al implementar este método, asegúrese de que todos mantienen recursos se liberan mediante la propagación de la llamada a través de la jerarquía de contención. Por ejemplo, si un objeto A asigna un objeto B, y el objeto B asigna un objeto C, a continuación, un <xref:System.IDisposable.Dispose%2A> implementación debe llamar a <xref:System.IDisposable.Dispose%2A> en B, que debe llamar a su vez <xref:System.IDisposable.Dispose%2A> en C.  
  
> [!IMPORTANT]
>  El compilador de C++ admite la eliminación determinista de recursos y no se permite la implementación directa de la <xref:System.IDisposable.Dispose%2A> método.  
  
 Un objeto también debe llamar a la <xref:System.IDisposable.Dispose%2A> método de su clase base si la clase base implementa <xref:System.IDisposable>. Para obtener más información acerca de cómo implementar <xref:System.IDisposable> en una clase base y sus subclases, vea la sección "IDisposable y la jerarquía de herencia" en el <xref:System.IDisposable> tema.  
  
 Si un objeto <xref:System.IDisposable.Dispose%2A> método se llama más de una vez, el objeto debe pasar por alto todas las llamadas después de la primera de ellas. El objeto no debe producir una excepción si su <xref:System.IDisposable.Dispose%2A> método se llama varias veces. Métodos de instancia distinto de <xref:System.IDisposable.Dispose%2A> puede producir un <xref:System.ObjectDisposedException> cuando los recursos ya se eliminan.  
  
 Los usuarios pueden esperar un tipo de recurso para utilizar una convención determinada para indicar un estado de asignación frente a un estado de liberación. Un ejemplo de esto es las clases de secuencia, que tradicionalmente se consideran como abiertas o cerradas. El implementador de una clase que tiene una convención de este tipo puede optar por implementar un método público con un nombre personalizado, como `Close`, que llama el <xref:System.IDisposable.Dispose%2A> método.  
  
 Dado que la <xref:System.IDisposable.Dispose%2A> debe llamar explícitamente al método, siempre hay un riesgo de que los recursos no administrados no será liberada, puesto que el consumidor de un objeto no se puede llamar a su <xref:System.IDisposable.Dispose%2A> método. Hay dos formas de evitar esta situación:  
  
-   Ajustar el recurso administrado en un objeto derivado de <xref:System.Runtime.InteropServices.SafeHandle?displayProperty=nameWithType>. Su <xref:System.IDisposable.Dispose%2A> implementación, a continuación, llama a la <xref:System.IDisposable.Dispose%2A> método de la <xref:System.Runtime.InteropServices.SafeHandle?displayProperty=nameWithType> instancias. Para obtener más información, consulte la sección "La alternativa SafeHandle" en el <xref:System.Object.Finalize%2A?displayProperty=nameWithType> tema.  
  
-   Implementar un finalizador para liberar recursos cuando <xref:System.IDisposable.Dispose%2A> no se llama. De forma predeterminada, el recolector de elementos no utilizados llama automáticamente a un finalizador del objeto antes de reclamar su memoria. Sin embargo, si la <xref:System.IDisposable.Dispose%2A> método se realizó llama, normalmente no es necesario para el recolector de elementos no utilizados llame al finalizador del objeto desechado. Para evitar una finalización automática, <xref:System.IDisposable.Dispose%2A> pueden llamar las implementaciones de la <xref:System.GC.SuppressFinalize%2A?displayProperty=nameWithType> método.  
  
 Cuando se usa un objeto que tiene acceso a recursos no administrados, como un <xref:System.IO.StreamWriter>, una práctica recomendada consiste en crear la instancia con un `using` instrucción. El `using` instrucción cierra automáticamente la secuencia y llamadas <xref:System.IDisposable.Dispose%2A> en el objeto cuando se haya completado el código que lo está usando. Para obtener un ejemplo, vea la <xref:System.IO.StreamWriter> clase.  
  
   
  
## Examples  
 En el ejemplo siguiente se muestra cómo puede implementar la <xref:System.IDisposable.Dispose%2A> método.  
  
 [!code-cpp[System.IDisposable.Dispose Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IDisposable.Dispose Example/CPP/idisposabledispose.cpp#1)]
 [!code-csharp[System.IDisposable.Dispose Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IDisposable.Dispose Example/CS/idisposabledispose.cs#1)]
 [!code-vb[System.IDisposable.Dispose Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IDisposable.Dispose Example/VB/idisposabledispose.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>