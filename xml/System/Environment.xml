<Type Name="Environment" FullName="System.Environment">
  <Metadata><Meta Name="ms.openlocfilehash" Value="2befc53c964784ef05f9a3c02e361d9e6aed9618" /><Meta Name="ms.sourcegitcommit" Value="61757d0366a172cdbc11436deb1c1ffa49d97238" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="es-ES" /><Meta Name="ms.lasthandoff" Value="06/28/2019" /><Meta Name="ms.locfileid" Value="67458497" /></Metadata><TypeSignature Language="C#" Value="public static class Environment" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract sealed beforefieldinit Environment extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Environment" />
  <TypeSignature Language="VB.NET" Value="Public Class Environment" />
  <TypeSignature Language="C++ CLI" Value="public ref class Environment abstract sealed" />
  <TypeSignature Language="F#" Value="type Environment = class" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime.Extensions</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Proporciona información acerca del entorno y la plataforma actuales, y la forma de manipularlos. Esta clase no puede heredarse.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use la <xref:System.Environment> clase para recuperar información como argumentos de línea de comandos, el código de salida, configuraciones de variables de entorno, el contenido de la pila de llamadas, el tiempo desde último inicio del sistema y la versión de common language runtime.  
  
   
  
## Examples  
 El ejemplo siguiente muestra que muestra una lista de información sobre el entorno actual.  
  
 [!code-cpp[environment.class#1](~/samples/snippets/cpp/VS_Snippets_CLR/environment.class/CPP/env0.cpp#1)]
 [!code-csharp[environment.class#1](~/samples/snippets/csharp/VS_Snippets_CLR/environment.class/CS/env0.cs#1)]
 [!code-vb[environment.class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/environment.class/VB/env0.vb#1)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName="CommandLine">
      <MemberSignature Language="C#" Value="public static string CommandLine { get; }" />
      <MemberSignature Language="ILAsm" Value=".property string CommandLine" />
      <MemberSignature Language="DocId" Value="P:System.Environment.CommandLine" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property CommandLine As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::String ^ CommandLine { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.CommandLine : string" Usage="System.Environment.CommandLine" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene la línea de comandos para este proceso.</summary>
        <value>Una cadena que contiene argumentos de la línea de comandos.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esta propiedad proporciona acceso para el nombre del programa y los argumentos especificados en la línea de comandos cuando se inició el proceso actual.  
  
 El nombre del programa puede incluir información de ruta de acceso, pero no es necesario hacerlo. Use el <xref:System.Environment.GetCommandLineArgs%2A> método para recuperar la información de línea de comandos analizada y almacenada en una matriz de cadenas.  
  
 El tamaño máximo del búfer de línea de comandos no se establece en un número específico de caracteres. varía según el sistema operativo Windows que se está ejecutando en el equipo.  
  
   
  
## Examples  
 El ejemplo siguiente muestra su propia línea de comandos.  
  
 [!code-cpp[environment.commandline#1](~/samples/snippets/cpp/VS_Snippets_CLR/environment.CommandLine/CPP/commandline.cpp#1)]
 [!code-csharp[environment.commandline#1](~/samples/snippets/csharp/VS_Snippets_CLR/environment.CommandLine/CS/commandline.cs#1)]
 [!code-vb[environment.commandline#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/environment.CommandLine/VB/commandline.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission">Para obtener acceso de lectura a la variable de entorno PATH. Enumeración asociada: <see cref="F:System.Security.Permissions.EnvironmentPermissionAccess.Read" /></permission>
        <altmember cref="M:System.Environment.GetCommandLineArgs" />
      </Docs>
    </Member>
    <Member MemberName="CurrentDirectory">
      <MemberSignature Language="C#" Value="public static string CurrentDirectory { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property string CurrentDirectory" />
      <MemberSignature Language="DocId" Value="P:System.Environment.CurrentDirectory" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property CurrentDirectory As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::String ^ CurrentDirectory { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.CurrentDirectory : string with get, set" Usage="System.Environment.CurrentDirectory" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece la ruta de acceso completa del directorio de trabajo actual.</summary>
        <value>Una cadena que contiene la ruta de acceso de un directorio.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Por definición, si este proceso se inicia en el directorio raíz de una variable local o una unidad de red, el valor de esta propiedad es el nombre de la unidad seguido por una barra diagonal final (por ejemplo, "C:\\"). Si este proceso se inicia en un subdirectorio, el valor de esta propiedad es la ruta de acceso de unidad y subdirectorio, sin una barra diagonal final (por ejemplo, "C:\mySubDirectory").  
  
   
  
## Examples  
 El ejemplo siguiente se muestra cómo establecer el <xref:System.Environment.CurrentDirectory%2A> propiedad.  
  
 [!code-cpp[System.Environment#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Environment/CPP/Vars1.cpp#4)]
 [!code-csharp[System.Environment#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Environment/CS/Vars1.cs#4)]
 [!code-vb[System.Environment#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Environment/VB/Vars1.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Intentó establecerse en una cadena vacía ("").</exception>
        <exception cref="T:System.ArgumentNullException">Se intentó establecer <see langword="null." />.</exception>
        <exception cref="T:System.IO.IOException">Error de E/S.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Se intentó establecer una ruta de acceso local que no se encuentra.</exception>
        <exception cref="T:System.Security.SecurityException">El autor de la llamada no dispone del permiso adecuado.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">para escribir en archivos o directorios en una operación de establecimiento. Enumeración asociada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Para obtener acceso a la información de la ruta de acceso en una operación get. Enumeración asociada: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
      </Docs>
    </Member>
    <Member MemberName="CurrentManagedThreadId">
      <MemberSignature Language="C#" Value="public static int CurrentManagedThreadId { get; }" />
      <MemberSignature Language="ILAsm" Value=".property int32 CurrentManagedThreadId" />
      <MemberSignature Language="DocId" Value="P:System.Environment.CurrentManagedThreadId" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property CurrentManagedThreadId As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property int CurrentManagedThreadId { int get(); };" />
      <MemberSignature Language="F#" Value="member this.CurrentManagedThreadId : int" Usage="System.Environment.CurrentManagedThreadId" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene un identificador único para el actual subproceso administrado.</summary>
        <value>Entero que representa un identificador único para este subproceso administrado.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Exit">
      <MemberSignature Language="C#" Value="public static void Exit (int exitCode);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Exit(int32 exitCode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Environment.Exit(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Exit (exitCode As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Exit(int exitCode);" />
      <MemberSignature Language="F#" Value="static member Exit : int -&gt; unit" Usage="System.Environment.Exit exitCode" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="exitCode" Type="System.Int32" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="exitCode">Código de salida para volver al sistema operativo. Use 0 (cero) para indicar que el proceso se completó correctamente.</param>
        <summary>Termina este proceso y devuelve un código de salida al sistema operativo.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para el `exitCode` parámetro, el número de uso distinto de cero para indicar un error. En la aplicación, puede definir sus propios códigos de error en una enumeración y devolver el código de error adecuado en función del escenario. Por ejemplo, devolver un valor de 1 para indicar que el archivo requerido no está presente y un valor de 2 para indicar que el archivo está en un formato incorrecto. Para obtener una lista de códigos de salida utilizados por el sistema operativo de Windows, consulte [códigos de Error del sistema](https://msdn.microsoft.com/library/ms681381.aspx) en la documentación de Windows.  
  
 Una llamada a la <xref:System.Environment.Exit%2A> método difiere del uso del lenguaje de programación `return` instrucción de las maneras siguientes:  
  
-   <xref:System.Environment.Exit%2A> siempre termina una aplicación. Mediante el `return` instrucción puede finalizar una aplicación solo si se usa en el punto de entrada de la aplicación, como en el `Main` método.  
  
-   <xref:System.Environment.Exit%2A> finaliza una aplicación inmediatamente, incluso si otros subprocesos se están ejecutando. Si el `return` instrucción se llama en el punto de entrada de la aplicación, hace que una aplicación a finalizar después de que se hayan anulado todos los subprocesos de primer plano.  
  
-   <xref:System.Environment.Exit%2A> requiere que el llamador tiene permiso para llamar a código no administrado. El `return` instrucción no.  
  
-   Si <xref:System.Environment.Exit%2A> se llama desde un `try` o `catch` bloquea, el código en cualquier `finally` bloque no se ejecuta. Si el `return` se utiliza la instrucción, el código en el `finally` ejecutar el bloque.  
  
-   Si <xref:System.Environment.Exit%2A> se llama cuando el código de un [región de ejecución restringida](~/docs/framework/performance/constrained-execution-regions.md) (CER) se está ejecutando, la CER no completará la ejecución. Si el `return` se utiliza la instrucción, completa la ejecución de la CER.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">El autor de llamada no tiene permisos de seguridad suficientes para realizar esta función.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Para poder llamar a código no administrado. Enumeración asociada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
      </Docs>
    </Member>
    <Member MemberName="ExitCode">
      <MemberSignature Language="C#" Value="public static int ExitCode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property int32 ExitCode" />
      <MemberSignature Language="DocId" Value="P:System.Environment.ExitCode" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property ExitCode As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property int ExitCode { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.ExitCode : int with get, set" Usage="System.Environment.ExitCode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>set: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece el código de salida del proceso.</summary>
        <value>Un entero de 32 bits con signo que contiene el código de salida. El valor predeterminado es 0 (cero), lo que indica que el proceso se completó correctamente.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si el `Main` devuelve del método `void`, puede utilizar esta propiedad para establecer el código de salida que se devolverá al entorno de llamada. Si `Main` no devuelve `void`, esta propiedad se omite. El valor inicial de esta propiedad es cero.  
  
> [!WARNING]
>  El <xref:System.Environment.ExitCode%2A> propiedad es un entero de 32 bits con signo. Para evitar que la propiedad devuelvan un código de salida negativo, no debe utilizar valores mayores o iguales a 0 x 80000000.  
  
 Use un número distinto de cero para indicar un error. En la aplicación, puede definir sus propios códigos de error en una enumeración y devolver el código de error adecuado en función del escenario. Por ejemplo, devolver un valor de 1 para indicar que el archivo requerido no está presente y un valor de 2 para indicar que el archivo está en un formato incorrecto. Para obtener una lista de códigos de salida utilizados por el sistema operativo de Windows, consulte [códigos de Error del sistema](https://msdn.microsoft.com/library/ms681381\(v=vs.85\)) en la documentación de Windows.  
  
   
  
## Examples  
 La siguiente es una aplicación sencilla denominada Double.exe que duplica un valor entero pasado como un argumento de línea de comandos. El valor asigna los códigos de error para el <xref:System.Environment.ExitCode%2A> propiedad para indicar condiciones de error. Tenga en cuenta que debe agregar una referencia al ensamblado System.Numerics.dll para compilar correctamente el ejemplo.  
  
 [!code-csharp[System.Environment.ExitCode#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.environment.exitcode/cs/double.cs#1)]
 [!code-vb[System.Environment.ExitCode#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.environment.exitcode/vb/double.vb#1)]  
  
 En el ejemplo, a continuación, se puede invocar desde un archivo por lotes, como la siguiente, que permite que sus códigos de error que sea accesible mediante el uso de la `ERRORLEVEL` comando.  
  
```  
  
echo off  
Double.exe %1  
If errorlevel 1639 goto NoArg   
if errorlevel 534 goto Overflow  
if errorlevel 160 goto BadArg  
if errorlevel 0 echo Completed Successfully   
goto :EOF  
  
:NoArg  
echo Missing argument  
goto :EOF  
  
: Overflow  
echo Arithmetic overflow  
goto :EOF  
  
:BadArg  
echo Invalid argument  
goto :EOF  
  
```  
  
 A continuación muestra algunos resultados de ejemplo generados invocando el archivo por lotes.  
  
```Output  
  
>getdouble 123>echo offResult: 246Completed Successfully>getdouble 5912323109093>echo offArithmetic overflow>getdouble>echo offMissing argument>getdouble "a string">echo offInvalid argument  
  
```  
  
 Tenga en cuenta que el código para Double.exe es idéntico en función en el ejemplo siguiente, salvo que el primero define un punto de entrada denominado `Main` que no tiene ningún valor devuelto, mientras que en este ejemplo define un punto de entrada denominado `Main` que devuelve un entero.  
  
 [!code-csharp[System.Environment.ExitCode#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.environment.exitcode/cs/double1.cs#2)]
 [!code-vb[System.Environment.ExitCode#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.environment.exitcode/vb/double1.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ExpandEnvironmentVariables">
      <MemberSignature Language="C#" Value="public static string ExpandEnvironmentVariables (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string ExpandEnvironmentVariables(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Environment.ExpandEnvironmentVariables(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ExpandEnvironmentVariables (name As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ ExpandEnvironmentVariables(System::String ^ name);" />
      <MemberSignature Language="F#" Value="static member ExpandEnvironmentVariables : string -&gt; string" Usage="System.Environment.ExpandEnvironmentVariables name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="name">Cadena que contiene los nombres de cero o más variables de entorno. Todas las variables de entorno se definen con el carácter de signo de porcentaje (%).</param>
        <summary>Reemplaza el nombre de cada variable de entorno incluida en la cadena especificada por la cadena equivalente del valor de la variable y devuelve la cadena resultante.</summary>
        <returns>Una cadena con todas las variables de entorno reemplazadas por su valor.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Interoperabilidad COM se usa para recuperar las variables de entorno del sistema operativo. Si las variables de entorno no se puede recuperar debido a un error de COM, el valor HRESULT que explica la causa del error se usa para generar una de las posibles excepciones; es decir, la excepción depende del valor HRESULT. Para obtener más información acerca de cómo se procesa el valor HRESULT, vea la sección Comentarios de la <xref:System.Runtime.InteropServices.Marshal.ThrowExceptionForHR%2A?displayProperty=nameWithType> método.  
  
 Sustitución solo se produce para las variables de entorno se establecen. Por ejemplo, supongamos que `name` es "MyENV = % MyENV %". Si se establece la variable de entorno MyENV, 42, este método devuelve "MyENV = 42". Si no se establece MyENV, se produce ningún cambio; Este método devuelve "MyENV = % MyENV %".  
  
 El tamaño del valor devuelto se limita a 32 KB.  
  
   
  
## Examples  
 El ejemplo siguiente muestra cómo obtener la unidad del sistema y variables del sistema raíz.  
  
 [!code-cpp[Environment.ExpandEnvironmentVariables#1](~/samples/snippets/cpp/VS_Snippets_CLR/environment.ExpandEnvironmentVariables/CPP/expandenvironmentvariables.cpp#1)]
 [!code-csharp[Environment.ExpandEnvironmentVariables#1](~/samples/snippets/csharp/VS_Snippets_CLR/environment.ExpandEnvironmentVariables/CS/expandenvironmentvariables.cs#1)]
 [!code-vb[Environment.ExpandEnvironmentVariables#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/environment.ExpandEnvironmentVariables/VB/expandenvironmentvariables.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> es <see langword="null" />.</exception>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission">Para poder acceder a las variables de entorno en <paramref name="name" />. Enumeración asociada: <see cref="F:System.Security.Permissions.EnvironmentPermissionAccess.Read" /></permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="FailFast">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Finaliza inmediatamente un proceso después de escribir un mensaje en el registro de eventos de la aplicación Windows y, después, incluye el mensaje y la información de excepción opcional en el informe de errores que se envía a Microsoft.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="FailFast">
      <MemberSignature Language="C#" Value="public static void FailFast (string message);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void FailFast(string message) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Environment.FailFast(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub FailFast (message As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void FailFast(System::String ^ message);" />
      <MemberSignature Language="F#" Value="static member FailFast : string -&gt; unit" Usage="System.Environment.FailFast message" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netframework-4.8;netcore-2.0;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="message" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="message">Mensaje que explica por qué finalizó el proceso o <see langword="null" /> si no se proporciona ninguna explicación.</param>
        <summary>Finaliza inmediatamente un proceso después de escribir un mensaje en el registro de eventos de la aplicación Windows y, después, incluye el mensaje en el informe de errores que se envía a Microsoft.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método finaliza un proceso sin ejecutar cualquier activo `try` / `finally` finalizadores ni bloques.
  
 El `Environment.FailFast` método escribe el `message` cadena para el registro de eventos de aplicación de Windows, crea un volcado de la aplicación y, a continuación, finaliza el proceso actual. El `message` cadena también se incluye en el informe de errores para Microsoft.  
  
 Use la `Environment.FailFast` método en lugar de la <xref:System.Environment.Exit%2A> método para finalizar la aplicación si el estado de la aplicación es irreparable y ejecutar la aplicación `try` / `finally` finalizadores y bloques va a dañar recursos del programa.  
  
 Información se notifica a Microsoft mediante el uso de informes de errores de Windows. Para obtener más información, consulte [Windows Error Reporting: Introducción a](https://msdn.microsoft.com/library/windows/hardware/dn641144.aspx).  

Una llamada a la `Environment.FailFast` método para finalizar la ejecución de una aplicación que se ejecuta en Visual Studio inicia el depurador un <xref:System.ExecutionEngineException> y desencadena automáticamente la [FatalExecutionError Asistente para depuración administrada (MDA)](https://github.com/dotnet/docs/blob/master/docs/framework/debug-trace-profile/fatalexecutionengineerror-mda.md).
  
## Examples  
 El ejemplo siguiente escribe una entrada de registro en el registro de eventos de aplicación de Windows y finaliza el proceso actual.  
  
 [!code-csharp[environment.FailFast#1](~/samples/snippets/csharp/VS_Snippets_CLR/environment.FailFast/cs/ff.cs#1)]
 [!code-vb[environment.FailFast#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/environment.FailFast/vb/ff.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requiere plena confianza para el llamador inmediato. Este miembro no se puede usar código de confianza parcial o transparente.</permission>
      </Docs>
    </Member>
    <Member MemberName="FailFast">
      <MemberSignature Language="C#" Value="public static void FailFast (string message, Exception exception);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void FailFast(string message, class System.Exception exception) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Environment.FailFast(System.String,System.Exception)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void FailFast(System::String ^ message, Exception ^ exception);" />
      <MemberSignature Language="F#" Value="static member FailFast : string * Exception -&gt; unit" Usage="System.Environment.FailFast (message, exception)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="message" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="exception" Type="System.Exception" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="message">Mensaje que explica por qué finalizó el proceso o <see langword="null" /> si no se proporciona ninguna explicación.</param>
        <param name="exception">Una excepción que representa el error que causó la finalización. Esta es normalmente la excepción en un bloque <see langword="catch" />.</param>
        <summary>Finaliza inmediatamente un proceso después de escribir un mensaje en el registro de eventos de la aplicación Windows y, luego, incluye el mensaje y la información de excepción en el informe de errores que se envía a Microsoft.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método finaliza el proceso sin ejecutar cualquier activo `try` / `finally` finalizadores ni bloques.  
  
 El `Environment.FailFast` método escribe el `message` cadena para el registro de eventos de aplicación de Windows, crea un volcado de la aplicación y, a continuación, finaliza el proceso actual.  
  
 Información se notifica a Microsoft mediante el uso de informes de errores de Windows. Para obtener más información, consulte [Windows Error Reporting: Introducción a](https://msdn.microsoft.com/library/windows/hardware/dn641144.aspx). Incluyen informes de errores para Microsoft `message` y `exception` información, que proporciona los detalles para clasificar el error. Aunque `exception` no es controlado porque se finaliza el proceso, se obtiene todavía la información contextual que provocó la excepción.  
  
 Si `exception` es `null`, o si `exception` no es se produce, este método funciona igual que el <xref:System.Environment.FailFast%28System.String%29> sobrecarga del método.  
  
 Use la `Environment.FailFast` método en lugar de la <xref:System.Environment.Exit%2A> método para finalizar la aplicación si el estado de la aplicación es irreparable y ejecutar la aplicación `try` / `finally` finalizadores y bloques va a dañar recursos del programa.  

Una llamada a la `Environment.FailFast` método para finalizar la ejecución de una aplicación que se ejecuta en Visual Studio inicia el depurador un <xref:System.ExecutionEngineException> y desencadena automáticamente la [FatalExecutionError Asistente para depuración administrada (MDA)](https://github.com/dotnet/docs/blob/master/docs/framework/debug-trace-profile/fatalexecutionengineerror-mda.md).
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requiere plena confianza para el llamador inmediato. Este miembro no se puede usar código de confianza parcial o transparente.</permission>
      </Docs>
    </Member>
    <Member MemberName="GetCommandLineArgs">
      <MemberSignature Language="C#" Value="public static string[] GetCommandLineArgs ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string[] GetCommandLineArgs() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Environment.GetCommandLineArgs" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetCommandLineArgs () As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::String ^&gt; ^ GetCommandLineArgs();" />
      <MemberSignature Language="F#" Value="static member GetCommandLineArgs : unit -&gt; string[]" Usage="System.Environment.GetCommandLineArgs " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Devuelve una matriz de cadena que contiene los argumentos de la línea de comandos del proceso actual.</summary>
        <returns>Una matriz de cadenas en la que cada elemento contiene un argumento de la línea de comandos. El primer elemento es el nombre del archivo ejecutable y los demás cero o más elementos contienen los argumentos de la línea de comandos restantes.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El primer elemento de la matriz contiene el nombre de archivo de programa en ejecución. Si el nombre de archivo no está disponible, el primer elemento es igual a <xref:System.String.Empty?displayProperty=nameWithType>. Los elementos restantes contienen tokens adicionales especificados en la línea de comandos.  
  
 El nombre del archivo de programa puede, pero no es necesario, incluir información de ruta de acceso.  
  
 Argumentos de línea de comandos están delimitados por espacios. Puede usar comillas dobles (") para incluir espacios dentro de un argumento. Sin embargo, la comilla simple ('), no proporciona esta funcionalidad.  
  
 Si una comilla doble sigue dos o un número par de barras diagonales inversas, cada par de barra diagonal inversa continuar se reemplaza por una barra diagonal inversa y se quita las comillas dobles. Si una comilla doble sigue un número impar de barras diagonales inversas, incluido uno solo, cada par anterior se reemplaza por una barra diagonal inversa y se quita la barra diagonal inversa restante; Sin embargo, en este caso las comillas dobles no se quita.  
  
 En la tabla siguiente se muestra cómo los argumentos de línea de comandos pueden estar delimitados y se da por supuesto `MyApp` como la aplicación en ejecución actual.  
  
|En la línea de comandos de entrada|Argumentos de línea de comandos resultante|  
|-------------------------------|--------------------------------------|  
|`MyApp alpha beta`|`MyApp, alpha, beta`|  
|`MyApp "alpha with spaces" "beta with spaces"`|`MyApp, alpha with spaces, beta with spaces`|  
|`MyApp 'alpha with spaces' beta`|`MyApp, 'alpha, with, spaces', beta`|  
|`MyApp \\\alpha \\\\"beta`|`MyApp, \\\alpha, \\beta`|  
|`MyApp \\\\\"alpha \"beta`|`MyApp, \\"alpha, "beta`|  
  
 Para obtener la línea de comandos como una sola cadena, use el <xref:System.Environment.CommandLine%2A> propiedad.  
  
   
  
## Examples  
 El ejemplo siguiente muestra los argumentos de línea de comandos de la aplicación.  
  
 [!code-cpp[Environment.GetCommandLineArgs#1](~/samples/snippets/cpp/VS_Snippets_CLR/Environment.GetCommandLineArgs/CPP/getcommandlineargs.cpp#1)]
 [!code-csharp[Environment.GetCommandLineArgs#1](~/samples/snippets/csharp/VS_Snippets_CLR/Environment.GetCommandLineArgs/CS/getcommandlineargs.cs#1)]
 [!code-vb[Environment.GetCommandLineArgs#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Environment.GetCommandLineArgs/VB/getcommandlineargs.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">El sistema no admite argumentos de línea de comandos.</exception>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission">Para obtener acceso de lectura a la variable de entorno PATH. Enumeración asociada: <see cref="F:System.Security.Permissions.EnvironmentPermissionAccess.Read" /></permission>
        <altmember cref="P:System.Environment.CommandLine" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetEnvironmentVariable">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Recupera el valor de una variable de entorno.</summary>
        <altmember cref="M:System.Environment.GetEnvironmentVariables" />
      </Docs>
    </MemberGroup>
    <Member MemberName="GetEnvironmentVariable">
      <MemberSignature Language="C#" Value="public static string GetEnvironmentVariable (string variable);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetEnvironmentVariable(string variable) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Environment.GetEnvironmentVariable(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetEnvironmentVariable (variable As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetEnvironmentVariable(System::String ^ variable);" />
      <MemberSignature Language="F#" Value="static member GetEnvironmentVariable : string -&gt; string" Usage="System.Environment.GetEnvironmentVariable variable" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="variable" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="variable">Nombre de la variable de entorno.</param>
        <summary>Recupera el valor de una variable de entorno del proceso actual.</summary>
        <returns>El valor de la variable de entorno especificada por <paramref name="variable" /> o <see langword="null" /> si no se encuentra la variable de entorno.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

El <xref:System.Environment.GetEnvironmentVariable%28System.String%29> método recupera una variable de entorno desde el bloque de entorno del proceso actual únicamente. Equivale a llamar a la <xref:System.Environment.GetEnvironmentVariable%28System.String%2CSystem.EnvironmentVariableTarget%29> método con un `target` valor <xref:System.EnvironmentVariableTarget.Process?displayProperty=nameWithType>. 

Para recuperar todas las variables de entorno junto con sus valores, llame el <xref:System.Environment.GetEnvironmentVariables%2A> método.  
  
Los nombres de variable de entorno distinguen mayúsculas de minúsculas en Linux y macOS, pero no distinguen mayúsculas de minúsculas en Windows.  
 
### <a name="on-windows-systems"></a>En los sistemas de Windows

 En los sistemas Windows, el bloque de entorno del proceso actual incluye:
 
- Todas las variables de entorno que le proporciona el proceso primario que lo creó. Por ejemplo, una aplicación de .NET que se inicia desde una ventana de consola hereda todas las variables de entorno de la ventana de consola. 

  Si no hay ningún proceso primario, se usan en su lugar, las variables de entorno por usuario y por equipo. Por ejemplo, una nueva ventana de consola tiene todas las variables de entorno por usuario y por equipo definidas en el momento en que se inició.

- Las variables que agregó al bloque de proceso mientras se ejecuta el proceso llamando el <xref:System.Environment.SetEnvironmentVariable%28System.String%2CSystem.String%29> método o la <xref:System.Environment.SetEnvironmentVariable%28System.String%2CSystem.String%2CSystem.EnvironmentVariableTarget%29> método con un `target` valor <xref:System.EnvironmentVariableTarget.Process?displayProperty=nameWithType>. Estas variables de entorno se mantienen hasta que finaliza la aplicación. NET.  
  
Si las variables de entorno se crean después de que se ha iniciado el proceso, puede usar este método para recuperar sólo aquellas variables que se crearon mediante una llamada a la <xref:System.Environment.SetEnvironmentVariable%28System.String%2CSystem.String%29> método o la <xref:System.Environment.SetEnvironmentVariable%28System.String%2CSystem.String%2CSystem.EnvironmentVariableTarget%29> método con un `target` valor de.<xref:System.EnvironmentVariableTarget.Process?displayProperty=nameWithType>.  

### <a name="on-macos-and-linux-systems"></a>En los sistemas de Linux y macOS

En macOS y Linux, el bloque de entorno de que el proceso actual incluye las siguientes variables de entorno:

- Todas las variables de entorno que le proporciona el proceso primario que lo creó. Aplicaciones iniciadas desde un shell de. NET, esto incluye todas las variables de entorno definidas en el shell.

- Las variables que agregó al bloque de proceso mientras se ejecuta el proceso llamando el <xref:System.Environment.SetEnvironmentVariable%28System.String%2CSystem.String%29> método o la <xref:System.Environment.SetEnvironmentVariable%28System.String%2CSystem.String%2CSystem.EnvironmentVariableTarget%29> método con un `target` valor <xref:System.EnvironmentVariableTarget.Process?displayProperty=nameWithType>. Estas variables de entorno se mantienen hasta que finaliza la aplicación. NET.  

.NET core en macOS y Linux no admite variables de entorno por equipo o por usuario.   
  
## Examples  
 En el ejemplo siguiente se usa el <xref:System.Environment.GetEnvironmentVariable%2A> método para recuperar el `windir` variable de entorno, que contiene la ruta de acceso del directorio de Windows.  
  
 [!code-cpp[System.Environment#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Environment/CPP/Vars1.cpp#4)]
 [!code-csharp[System.Environment#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Environment/CS/Vars1.cs#4)]
 [!code-vb[System.Environment#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Environment/VB/Vars1.vb#4)]  
  
 El ejemplo siguiente se intenta recuperar el valor de una variable de entorno denominada `Test1` desde el bloque de entorno de proceso. Si la variable no existe, el ejemplo se crea su y recupera su valor. En el ejemplo se muestra el valor de la variable. Si en el ejemplo se crea la variable, también llama a la <xref:System.Environment.GetEnvironmentVariables%28System.EnvironmentVariableTarget%29> método con cada miembro de la <xref:System.EnvironmentVariableTarget> enumeración para establecer que la variable se puede recuperar solo desde el bloque de entorno del proceso actual. Por último, si en el ejemplo se crea la variable, la elimina.  
  
 [!code-csharp[System.Environment.GetEnvironmentVariable#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.environment.getenvironmentvariable/cs/getenvironmentvariableex1.cs)]
 [!code-vb[System.Environment.GetEnvironmentVariable#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.environment.getenvironmentvariable/vb/getenvironmentvariableex1.vb)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="variable" /> es <see langword="null" />.</exception>
        <exception cref="T:System.Security.SecurityException">El autor de la llamada no tiene el permiso requerido para llevar a cabo esta operación.</exception>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission">Para poder leer el valor de <paramref name="variable" />. Enumeración asociada: <see cref="F:System.Security.Permissions.EnvironmentPermissionAccess.Read" /></permission>
        <altmember cref="M:System.Environment.GetEnvironmentVariables" />
        <altmember cref="M:System.Environment.SetEnvironmentVariable(System.String,System.String)" />
        <altmember cref="T:System.EnvironmentVariableTarget" />
      </Docs>
    </Member>
    <Member MemberName="GetEnvironmentVariable">
      <MemberSignature Language="C#" Value="public static string GetEnvironmentVariable (string variable, EnvironmentVariableTarget target);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetEnvironmentVariable(string variable, valuetype System.EnvironmentVariableTarget target) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Environment.GetEnvironmentVariable(System.String,System.EnvironmentVariableTarget)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetEnvironmentVariable (variable As String, target As EnvironmentVariableTarget) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetEnvironmentVariable(System::String ^ variable, EnvironmentVariableTarget target);" />
      <MemberSignature Language="F#" Value="static member GetEnvironmentVariable : string * EnvironmentVariableTarget -&gt; string" Usage="System.Environment.GetEnvironmentVariable (variable, target)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="variable" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="target" Type="System.EnvironmentVariableTarget" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="variable">Nombre de una variable de entorno.</param>
        <param name="target">Uno de los valores de <see cref="T:System.EnvironmentVariableTarget" />. Solo se admite <see cref="F:System.EnvironmentVariableTarget.Process" /> en .NET Core que se ejecute en sistemas basados en Unix.</param>
        <summary>Recupera el valor de una variable de entorno del proceso actual o de la clave del Registro del sistema operativo Windows para la máquina local o el usuario actual.</summary>
        <returns>El valor de la variable de entorno especificada por los parámetros <paramref name="variable" /> y <paramref name="target" />, o <see langword="null" /> si no se encuentra la variable de entorno.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks 

Para recuperar todas las variables de entorno junto con sus valores, llame el <xref:System.Environment.GetEnvironmentVariables%2A> método.  
  
Los nombres de variable de entorno distinguen mayúsculas de minúsculas en Linux y macOS, pero no distinguen mayúsculas de minúsculas en Windows. 

### <a name="on-windows-systems"></a>En los sistemas de Windows

En Windows, la `target` parámetro especifica si se recupera la variable de entorno del proceso actual o de la clave de registro del sistema operativo Windows para el equipo local o el usuario actual. Todas las variables de entorno por usuario y por equipo se copian automáticamente en el bloque de entorno del proceso actual, igual que otras variables de entorno que están disponibles para el proceso primario que creó el proceso. NET. Sin embargo, agregaron variables de entorno solo para el bloque de entorno del proceso actual mediante una llamada a la <xref:System.Environment.SetEnvironmentVariable%28System.String%2CSystem.String%29> método o la <xref:System.Environment.SetEnvironmentVariable%28System.String%2CSystem.String%2CSystem.EnvironmentVariableTarget%29> método con un `target` valor de <xref:System.EnvironmentVariableTarget.Process?displayProperty=nameWithType> se conservan durante el proceso.  
  
### <a name="on-macos-and-linux-systems"></a>En los sistemas de Linux y macOS

En macOS y Linux, el `GetEnvironmentVariable(String, EnvironmentVariableTarget)` método admite un `target` valor <xref:System.EnvironmentVariableTarget.Process?displayProperty=nameWithType> solo. Las llamadas con un `target` valor <xref:System.EnvironmentVariableTarget.Machine?displayProperty=nameWithType> o <xref:System.EnvironmentVariableTarget.User?displayProperty=nameWithType> no se admiten y devolver `null`. 

Las variables de entorno por proceso son:

- Los heredan del proceso primario, normalmente el shell se utiliza para invocar `dotnet.exe` o para iniciar la aplicación. NET.

- Los definidos por una llamada a la <xref:System.Environment.SetEnvironmentVariable%28System.String%2CSystem.String%29> método o la <xref:System.Environment.SetEnvironmentVariable%28System.String%2CSystem.String%2CSystem.EnvironmentVariableTarget%29> método con un `target` valor <xref:System.EnvironmentVariableTarget.Process?displayProperty=nameWithType>. Estas variables de entorno solo se mantienen hasta el `dotnet` finaliza el proceso o la aplicación. NET.   
  
## Examples

El siguiente ejemplo crea variables de entorno para la <xref:System.EnvironmentVariableTarget.Process?displayProperty=nameWithType>, <xref:System.EnvironmentVariableTarget.User?displayProperty=nameWithType>, y <xref:System.EnvironmentVariableTarget.Machine> tiene como destino, comprueba si el registro del sistema operativo contiene el usuario y las variables de entorno del equipo y, después, elimina el entorno variables. Ya no soporte por usuario y por equipo y las variables de entorno, solo lo hace .NET en sistemas basados en Unix <xref:System.Environment.SetEnvironmentVariable(System.String,System.String)> y <xref:System.Environment.SetEnvironmentVariable(System.String,System.String,System.EnvironmentVariableTarget)> con un valor de <xref:System.EnvironmentVariableTarget.Process?displayProperty=nameWithType> correctamente almacenar una variable de entorno para el bloque de entorno de proceso.

[!code-csharp[environment.getsetenvar#1](~/samples/snippets/csharp/VS_Snippets_CLR/environment.getsetenvar/CS/gsev.cs)]
[!code-vb[environment.getsetenvar#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/environment.getsetenvar/VB/gsev.vb)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="variable" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="target" /> no es un valor <see cref="T:System.EnvironmentVariableTarget" /> válido.</exception>
        <exception cref="T:System.Security.SecurityException">El autor de la llamada no tiene el permiso requerido para llevar a cabo esta operación.</exception>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission">Para poder leer el valor de <paramref name="variable" /> si <paramref name="target" /> es <see cref="F:System.EnvironmentVariableTarget.Process" /> (enumeración asociada: <see cref="F:System.Security.Permissions.EnvironmentPermissionAccess.Read" />), 
o 
Para obtener acceso completo a las variables de entorno si <paramref name="target" /> es <see cref="F:System.EnvironmentVariableTarget.User" /> o <see cref="F:System.EnvironmentVariableTarget.Machine" /> (enumeración asociada: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />).</permission>
        <altmember cref="M:System.Environment.SetEnvironmentVariable(System.String,System.String,System.EnvironmentVariableTarget)" />
        <altmember cref="M:System.Environment.GetEnvironmentVariables" />
        <altmember cref="T:System.EnvironmentVariableTarget" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetEnvironmentVariables">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Recupera todos los nombres de las variables de entorno y sus valores.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetEnvironmentVariables">
      <MemberSignature Language="C#" Value="public static System.Collections.IDictionary GetEnvironmentVariables ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.IDictionary GetEnvironmentVariables() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Environment.GetEnvironmentVariables" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetEnvironmentVariables () As IDictionary" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Collections::IDictionary ^ GetEnvironmentVariables();" />
      <MemberSignature Language="F#" Value="static member GetEnvironmentVariables : unit -&gt; System.Collections.IDictionary" Usage="System.Environment.GetEnvironmentVariables " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.IDictionary</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Recupera todos los nombres de las variables de entorno y sus valores del proceso actual.</summary>
        <returns>Un diccionario que contiene todos los nombres de las variables de entorno y sus valores; de lo contrario, un diccionario vacío si no se encuentra ninguna variable de entorno.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Los nombres y valores para las variables de entorno se almacenan como pares de clave-valor en el valor devuelto <xref:System.Collections.IDictionary>.  
  
### <a name="on-windows-systems"></a>En los sistemas de Windows

En los sistemas Windows, el `GetEnvironmentVariables` método devuelve las siguientes variables de entorno:
  
- Todos por equipo y las variables de entorno que se definen en el momento en que se crea el proceso, junto con sus valores.  
  
- Todas las variables de entorno por usuario que se definen en el momento en el proceso se crea, junto con sus valores.  

- Las variables heredadas del proceso principal desde la que se inicia o agregada para el bloque process mientras se está ejecutando el proceso de la aplicación. NET. Se agregan las variables de entorno mientras se ejecuta el proceso llamando el <xref:System.Environment.SetEnvironmentVariable%28System.String%2CSystem.String%29> método o la <xref:System.Environment.SetEnvironmentVariable%28System.String%2CSystem.String%2CSystem.EnvironmentVariableTarget%29> método con un `target` valor <xref:System.EnvironmentVariableTarget.Process?displayProperty=nameWithType>.  

### <a name="on-macos-and-linux-systems"></a>En los sistemas de Linux y macOS

En MacOS y Linux, el `GetEnvironmentVariables` método recupera el nombre y valor de todas las variables de entorno que se heredan del proceso primario que inició la `dotnet` proceso o que se definen dentro del ámbito de la `dotnet` propio proceso. Una vez el `dotnet` proceso termina, estas variables de entorno de este último dejan de existir. 

.NET core que se ejecutan en sistemas basados en Unix no es compatible con las variables de entorno por equipo o por usuario.   
  
## Examples  
 En el ejemplo siguiente se muestra el <xref:System.Environment.GetEnvironmentVariables%2A> método.  
  
 [!code-cpp[Environment.GetEnvironmentVariables#1](~/samples/snippets/cpp/VS_Snippets_CLR/Environment.GetEnvironmentVariables/CPP/getenvironmentvariables.cpp#1)]
 [!code-csharp[Environment.GetEnvironmentVariables#1](~/samples/snippets/csharp/VS_Snippets_CLR/Environment.GetEnvironmentVariables/CS/getenvironmentvariables.cs#1)]
 [!code-vb[Environment.GetEnvironmentVariables#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Environment.GetEnvironmentVariables/VB/getenvironmentvariables.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">El autor de la llamada no tiene el permiso requerido para llevar a cabo esta operación.</exception>
        <exception cref="T:System.OutOfMemoryException">El búfer no tiene memoria.</exception>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission">Para poder leer los nombres y valores de variables de entorno. Enumeración asociada: <see cref="F:System.Security.Permissions.EnvironmentPermissionAccess.Read" /></permission>
        <altmember cref="M:System.Environment.GetEnvironmentVariable(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="GetEnvironmentVariables">
      <MemberSignature Language="C#" Value="public static System.Collections.IDictionary GetEnvironmentVariables (EnvironmentVariableTarget target);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.IDictionary GetEnvironmentVariables(valuetype System.EnvironmentVariableTarget target) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Environment.GetEnvironmentVariables(System.EnvironmentVariableTarget)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetEnvironmentVariables (target As EnvironmentVariableTarget) As IDictionary" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Collections::IDictionary ^ GetEnvironmentVariables(EnvironmentVariableTarget target);" />
      <MemberSignature Language="F#" Value="static member GetEnvironmentVariables : EnvironmentVariableTarget -&gt; System.Collections.IDictionary" Usage="System.Environment.GetEnvironmentVariables target" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.IDictionary</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.EnvironmentVariableTarget" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="target">Uno de los valores de <see cref="T:System.EnvironmentVariableTarget" />. Solo se admite <see cxref="F:System.EnvironmentVariableTarget.Process" /> en .NET Core que se ejecute en sistemas basados en Unix.</param>
        <summary>Recupera todos los nombres de las variables de entorno y sus valores del proceso actual o de la clave del Registro del sistema operativo Windows para la máquina local o el usuario actual.</summary>
        <returns>Un diccionario que contiene todos los nombres de las variables de entorno y sus valores del origen especificado por el parámetro <paramref name="target" />; de lo contrario, un diccionario vacío si no se encuentra ninguna variable de entorno.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

Los nombres y valores de las variables de entorno se almacenan como pares de clave/valor en el valor devuelto <xref:System.Collections.IDictionary> objeto.  

### <a name="on-windows-systems"></a>En los sistemas de Windows

En los sistemas Windows, el `target` parámetro especifica si el origen es el proceso actual, la clave del registro para el usuario actual o la clave del registro para el equipo local.  

### <a name="on-macos-and-linux-systems"></a>En los sistemas de Linux y macOS

En macOS y Linux, solo un `target` valor de <xref:System.EnvironmentVariableTarget.Process?displayProperty=nameWithType> es compatible. Las variables de entorno por proceso se heredan del proceso primario (normalmente el shell) usado para iniciar el `dotnet` procesar o que se definen dentro del ámbito de la `dotnet` propio proceso. Una vez que finaliza el proceso de dotnet, estas variables de entorno de este último dejan de existir.  

No se admiten variables de entorno por equipo y por usuario. Un `target` valor <xref:System.EnvironmentVariableTarget.Machine?displayProperty=nameWithType> o <xref:System.EnvironmentVariableTarget.User?displayProperty=nameWithType> devuelve una matriz vacía.
  
## Examples

El siguiente ejemplo crea variables de entorno para la <xref:System.EnvironmentVariableTarget.Process?displayProperty=nameWithType>, <xref:System.EnvironmentVariableTarget.User?displayProperty=nameWithType>, y <xref:System.EnvironmentVariableTarget.Machine> tiene como destino, comprueba si el registro del sistema operativo contiene el usuario y las variables de entorno del equipo y, después, elimina el entorno variables. Ya no soporte por usuario y por equipo y las variables de entorno, solo lo hace .NET en sistemas basados en Unix <xref:System.Environment.SetEnvironmentVariable(System.String,System.String)> y <xref:System.Environment.SetEnvironmentVariable(System.String,System.String,System.EnvironmentVariableTarget)> con un valor de <xref:System.EnvironmentVariableTarget.Process?displayProperty=nameWithType> correctamente almacenar una variable de entorno para el bloque de entorno de proceso.

[!code-csharp[environment.getsetenvar#1](~/samples/snippets/csharp/VS_Snippets_CLR/environment.getsetenvar/CS/gsev.cs)]
[!code-vb[environment.getsetenvar#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/environment.getsetenvar/VB/gsev.vb)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">El llamador no dispone del permiso requerido para llevar a cabo esta operación para el valor especificado de <paramref name="target" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="target" /> contiene un valor no válido.</exception>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission">Para poder leer los nombres y valores de variables de entorno si <paramref name="target" /> es <see cref="F:System.EnvironmentVariableTarget.Process" /> (enumeración asociada: <see cref="F:System.Security.Permissions.EnvironmentPermissionAccess.Read" />), 
o 
Para obtener acceso completo a las variables de entorno si <paramref name="target" /> es <see cref="F:System.EnvironmentVariableTarget.User" /> o <see cref="F:System.EnvironmentVariableTarget.Machine" /> (enumeración asociada: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />).</permission>
        <altmember cref="M:System.Environment.SetEnvironmentVariable(System.String,System.String,System.EnvironmentVariableTarget)" />
        <altmember cref="T:System.EnvironmentVariableTarget" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetFolderPath">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Obtiene la ruta de acceso a la carpeta especial del sistema identificada por la enumeración especificada.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetFolderPath">
      <MemberSignature Language="C#" Value="public static string GetFolderPath (Environment.SpecialFolder folder);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetFolderPath(valuetype System.Environment/SpecialFolder folder) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Environment.GetFolderPath(System.Environment.SpecialFolder)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetFolderPath (folder As Environment.SpecialFolder) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetFolderPath(Environment::SpecialFolder folder);" />
      <MemberSignature Language="F#" Value="static member GetFolderPath : Environment.SpecialFolder -&gt; string" Usage="System.Environment.GetFolderPath folder" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="folder" Type="System.Environment+SpecialFolder" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="folder">Uno de los valores de enumeración que identifica una carpeta especial del sistema.</param>
        <summary>Obtiene la ruta de acceso a la carpeta especial del sistema identificada por la enumeración especificada.</summary>
        <returns>Ruta de acceso a la carpeta especial del sistema especificada, si dicha carpeta existe físicamente en el equipo; de lo contrario, una cadena vacía ("").  
  
 Una carpeta no existe físicamente si el sistema operativo no la creó, la carpeta existente se eliminó o la carpeta es un directorio virtual, como Mi PC, que no se corresponde con una ruta de acceso física.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método recupera la ruta de acceso a una carpeta especial del sistema, como archivos de programa, programas, sistema o inicio, que puede utilizarse para tener acceso a información común. Carpetas especiales se establecen de forma predeterminada, el sistema, o explícitamente por el usuario, al instalar una versión de Windows.  
  
 El `folder` parámetro designa la carpeta especial para recuperar y debe ser uno de los valores en el <xref:System.Environment.SpecialFolder> enumeración; en cualquier otro valor produce una excepción.  
  
 Para obtener más información acerca de las carpetas especiales, consulte el [CSIDL](https://go.microsoft.com/fwlink/?LinkId=116664) tema de los valores.  
  
   
  
## Examples  
 En el ejemplo siguiente se muestra cómo usar el <xref:System.Environment.GetFolderPath%2A> método para devolver y mostrar la ruta de acceso asociada con el `folder` parámetro.  
  
 [!code-cpp[Environment.GetFolderPath#1](~/samples/snippets/cpp/VS_Snippets_CLR/Environment.GetFolderPath/CPP/getfolderpath.cpp#1)]
 [!code-csharp[Environment.GetFolderPath#1](~/samples/snippets/csharp/VS_Snippets_CLR/Environment.GetFolderPath/CS/getfolderpath.cs#1)]
 [!code-vb[Environment.GetFolderPath#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Environment.GetFolderPath/VB/getfolderpath.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="folder" /> no es un miembro de <see cref="T:System.Environment.SpecialFolder" />.</exception>
        <exception cref="T:System.PlatformNotSupportedException">No se admite la plataforma actual.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Para obtener acceso a la información de la ruta de acceso. Enumeración asociada: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
      </Docs>
    </Member>
    <Member MemberName="GetFolderPath">
      <MemberSignature Language="C#" Value="public static string GetFolderPath (Environment.SpecialFolder folder, Environment.SpecialFolderOption option);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetFolderPath(valuetype System.Environment/SpecialFolder folder, valuetype System.Environment/SpecialFolderOption option) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Environment.GetFolderPath(System.Environment.SpecialFolder,System.Environment.SpecialFolderOption)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetFolderPath (folder As Environment.SpecialFolder, option As Environment.SpecialFolderOption) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetFolderPath(Environment::SpecialFolder folder, Environment::SpecialFolderOption option);" />
      <MemberSignature Language="F#" Value="static member GetFolderPath : Environment.SpecialFolder * Environment.SpecialFolderOption -&gt; string" Usage="System.Environment.GetFolderPath (folder, option)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="folder" Type="System.Environment+SpecialFolder" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="option" Type="System.Environment+SpecialFolderOption" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="folder">Uno de los valores de enumeración que identifica una carpeta especial del sistema.</param>
        <param name="option">Uno de los valores de enumeración que especifica opciones que se van a usar para tener acceso a una carpeta especial.</param>
        <summary>Obtiene la ruta de acceso a la carpeta especial del sistema identificada por la enumeración especificada y usa una opción especificada para tener acceso a carpetas especiales.</summary>
        <returns>Ruta de acceso a la carpeta especial del sistema especificada, si dicha carpeta existe físicamente en el equipo; de lo contrario, una cadena vacía ("").  
  
 Una carpeta no existe físicamente si el sistema operativo no la creó, la carpeta existente se eliminó o la carpeta es un directorio virtual, como Mi PC, que no se corresponde con una ruta de acceso física.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método recupera la ruta de acceso a una carpeta especial del sistema, como archivos de programa, programas, sistema o inicio, que puede utilizarse para tener acceso a información común. Carpetas especiales se establecen de forma predeterminada, el sistema, o explícitamente por el usuario, al instalar una versión de Windows.  
  
 El `folder` parámetro designa la carpeta especial para recuperar y debe ser uno de los valores en el <xref:System.Environment.SpecialFolder> enumeración; en cualquier otro valor produce una excepción.  
  
 Para obtener más información acerca de las carpetas especiales, consulte el [CSIDL](https://go.microsoft.com/fwlink/?LinkId=116664) tema de los valores.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="folder" /> no es un miembro de <see cref="T:System.Environment.SpecialFolder" />.
o bien

<paramref name="options" /> no es un miembro de <see cref="T:System.Environment.SpecialFolderOption" />.</exception>
        <exception cref="T:System.PlatformNotSupportedException">No se admite la plataforma actual.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Para obtener acceso a la información de la ruta de acceso. Enumeración asociada: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
      </Docs>
    </Member>
    <Member MemberName="GetLogicalDrives">
      <MemberSignature Language="C#" Value="public static string[] GetLogicalDrives ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string[] GetLogicalDrives() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Environment.GetLogicalDrives" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetLogicalDrives () As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::String ^&gt; ^ GetLogicalDrives();" />
      <MemberSignature Language="F#" Value="static member GetLogicalDrives : unit -&gt; string[]" Usage="System.Environment.GetLogicalDrives " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Devuelve una matriz de cadena que contiene los nombres de las unidades lógicas del equipo actual.</summary>
        <returns>Matriz de cadenas en la que cada elemento contiene el nombre de una unidad lógica. Por ejemplo, si la unidad de disco duro del equipo es la primera unidad lógica, el primer elemento devuelto es "C:\\".</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 El ejemplo siguiente muestra cómo se muestran las unidades lógicas del equipo actual mediante el <xref:System.Environment.GetLogicalDrives%2A> método.  
  
 [!code-cpp[Environment.GetLogicalDrives#1](~/samples/snippets/cpp/VS_Snippets_CLR/Environment.GetLogicalDrives/CPP/getlogicaldrives.cpp#1)]
 [!code-csharp[Environment.GetLogicalDrives#1](~/samples/snippets/csharp/VS_Snippets_CLR/Environment.GetLogicalDrives/CS/getlogicaldrives.cs#1)]
 [!code-vb[Environment.GetLogicalDrives#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Environment.GetLogicalDrives/VB/getlogicaldrives.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Error de E/S.</exception>
        <exception cref="T:System.Security.SecurityException">El llamador no dispone del permiso requerido.</exception>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission">Para obtener acceso completo al recurso protegido por este permiso. Enumeración asociada: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></permission>
      </Docs>
    </Member>
    <Member MemberName="HasShutdownStarted">
      <MemberSignature Language="C#" Value="public static bool HasShutdownStarted { get; }" />
      <MemberSignature Language="ILAsm" Value=".property bool HasShutdownStarted" />
      <MemberSignature Language="DocId" Value="P:System.Environment.HasShutdownStarted" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property HasShutdownStarted As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool HasShutdownStarted { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.HasShutdownStarted : bool" Usage="System.Environment.HasShutdownStarted" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene un valor que indica si el dominio de aplicación actual se está descargando o si Common Language Runtime (CLR) se está cerrando.</summary>
        <value><see langword="true" /> Si el dominio de aplicación actual se está descargando o si el CLR se está cerrando; en caso contrario, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 **.NET framework solo**: Cuando el CLR descarga un dominio de aplicación, ejecuta los finalizadores en todos los objetos que tienen un método finalizador en ese dominio de aplicación. Cuando se cierra el CLR, inicia el subproceso del finalizador en todos los objetos que tienen un método finalizador. El <xref:System.Environment.HasShutdownStarted%2A> propiedad devuelve `true` solo después de que se ha iniciado el subproceso del finalizador. Cuando se devuelve la propiedad `true`, puede determinar si un dominio de aplicación se está descargando o si se está cerrando el propio CLR mediante una llamada a la <xref:System.AppDomain.IsFinalizingForUnload%2A?displayProperty=nameWithType> método. Este método devuelve `true` si se llama a los finalizadores porque se está descargando el dominio de aplicación o `false` si CLR se está cerrando.  
  
 El <xref:System.Environment.HasShutdownStarted%2A> propiedad devuelve `false` si no se ha iniciado el subproceso del finalizador.  
  
 Mediante el uso de esta propiedad, puede determinar si el acceso a las variables estáticas en el código de finalización. Si un dominio de aplicación o el CLR se está cerrando, no se puede tener acceso a cualquier objeto que tiene un método de finalización y que se hace referencia a un campo estático confiable. Esto es porque estos objetos es posible que ya ha finalizado.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.AppDomain.IsFinalizingForUnload" />
      </Docs>
    </Member>
    <Member MemberName="Is64BitOperatingSystem">
      <MemberSignature Language="C#" Value="public static bool Is64BitOperatingSystem { get; }" />
      <MemberSignature Language="ILAsm" Value=".property bool Is64BitOperatingSystem" />
      <MemberSignature Language="DocId" Value="P:System.Environment.Is64BitOperatingSystem" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property Is64BitOperatingSystem As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool Is64BitOperatingSystem { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.Is64BitOperatingSystem : bool" Usage="System.Environment.Is64BitOperatingSystem" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Determina si el sistema operativo actual es un sistema operativo de 64 bits.</summary>
        <value>Es <see langword="true" /> si el sistema operativo es de 64 bits; de lo contrario, es <see langword="false" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Is64BitProcess">
      <MemberSignature Language="C#" Value="public static bool Is64BitProcess { get; }" />
      <MemberSignature Language="ILAsm" Value=".property bool Is64BitProcess" />
      <MemberSignature Language="DocId" Value="P:System.Environment.Is64BitProcess" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property Is64BitProcess As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool Is64BitProcess { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.Is64BitProcess : bool" Usage="System.Environment.Is64BitProcess" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Determina si el proceso actual es un proceso de 64 bits.</summary>
        <value>Es <see langword="true" /> si el proceso es de 64 bits; de lo contrario, es <see langword="false" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MachineName">
      <MemberSignature Language="C#" Value="public static string MachineName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property string MachineName" />
      <MemberSignature Language="DocId" Value="P:System.Environment.MachineName" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property MachineName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::String ^ MachineName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.MachineName : string" Usage="System.Environment.MachineName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene el nombre NetBIOS del equipo local.</summary>
        <value>Una cadena que contiene el nombre del equipo.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El nombre de este equipo se establece en el inicio del sistema cuando se lee el nombre del registro. Si este equipo es un nodo en un clúster, se devuelve el nombre del nodo.  
  
   
  
## Examples  
 El ejemplo siguiente muestra el nombre del equipo que ejecuta el ejemplo de código. (El nombre del equipo se omite del resultado del ejemplo por motivos de seguridad).  
  
 [!code-cpp[environment.machinename#1](~/samples/snippets/cpp/VS_Snippets_CLR/Environment.MachineName/CPP/machinename.cpp#1)]
 [!code-csharp[environment.machinename#1](~/samples/snippets/csharp/VS_Snippets_CLR/Environment.MachineName/CS/machinename.cs#1)]
 [!code-vb[environment.machinename#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Environment.MachineName/VB/machinename.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">No se puede obtener el nombre de este equipo.</exception>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission">acceso de lectura a la variable de entorno COMPUTERNAME. Enumeración asociada: <see cref="F:System.Security.Permissions.EnvironmentPermissionAccess.Read" /></permission>
      </Docs>
    </Member>
    <Member MemberName="NewLine">
      <MemberSignature Language="C#" Value="public static string NewLine { get; }" />
      <MemberSignature Language="ILAsm" Value=".property string NewLine" />
      <MemberSignature Language="DocId" Value="P:System.Environment.NewLine" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property NewLine As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::String ^ NewLine { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.NewLine : string" Usage="System.Environment.NewLine" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene la cadena de nueva línea definida para este entorno.</summary>
        <value>Una cadena que contiene "\r\n" para las plataformas que no son Unix o una cadena que contiene "\n" para las plataformas Unix.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El valor de propiedad <xref:System.Environment.NewLine%2A> es una constante personalizada específicamente para la plataforma actual y la implementación de .NET Framework. Para obtener más información acerca de los caracteres de escape en el valor de propiedad, vea [Escapes de carácter](~/docs/standard/base-types/character-escapes-in-regular-expressions.md).  
  
 La funcionalidad proporcionada por <xref:System.Environment.NewLine%2A> a menudo es lo que significan los términos nueva, avance de línea, salto de línea, retorno de carro, CRLF y final de línea.  
  
 <xref:System.Environment.NewLine%2A> se puede usar junto con el soporte técnico de nueva línea específica del lenguaje, como los caracteres de escape '\r' y '\n' en Microsoft C# y C o C++, o `vbCrLf` en Microsoft Visual Basic.  
  
 <xref:System.Environment.NewLine%2A> se anexa automáticamente al texto que se procesó el <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> y <xref:System.Text.StringBuilder.AppendLine%2A?displayProperty=nameWithType> métodos.  
  
   
  
## Examples  
 El ejemplo siguiente muestra tres líneas separadas por nuevas líneas.  
  
 [!code-cpp[environment.newline#1](~/samples/snippets/cpp/VS_Snippets_CLR/Environment.NewLine/CPP/newline.cpp#1)]
 [!code-csharp[environment.newline#1](~/samples/snippets/csharp/VS_Snippets_CLR/Environment.NewLine/CS/newline.cs#1)]
 [!code-vb[environment.newline#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Environment.NewLine/VB/newline.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OSVersion">
      <MemberSignature Language="C#" Value="public static OperatingSystem OSVersion { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.OperatingSystem OSVersion" />
      <MemberSignature Language="DocId" Value="P:System.Environment.OSVersion" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property OSVersion As OperatingSystem" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property OperatingSystem ^ OSVersion { OperatingSystem ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.OSVersion : OperatingSystem" Usage="System.Environment.OSVersion" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.OperatingSystem</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene un objeto <see cref="T:System.OperatingSystem" /> que contiene el identificador de la plataforma actual y el número de versión.</summary>
        <value>Un objeto que contiene el identificador de la plataforma y el número de versión.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks

El `Environment.OSVersion` propiedad no proporciona un método confiable para identificar el sistema operativo exacto y su versión. Por lo tanto, no se recomienda que utilice este método. En su lugar: 

- Para identificar la plataforma del sistema operativo, use el <xref:System.Runtime.InteropServices.RuntimeInformation.IsOSPlatform%2A?displayProperty=nameWithType> método. 

- Evite escribir código que depende de una versión de sistema operativo notificada. En su lugar, compruebe la disponibilidad de las características que necesita la aplicación.

 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Esta propiedad no pudo obtener la versión del sistema.  
  
o bien 
El identificador de plataforma obtenido no es un miembro de <see cref="T:System.PlatformID" /></exception>
      </Docs>
    </Member>
    <Member MemberName="ProcessorCount">
      <MemberSignature Language="C#" Value="public static int ProcessorCount { get; }" />
      <MemberSignature Language="ILAsm" Value=".property int32 ProcessorCount" />
      <MemberSignature Language="DocId" Value="P:System.Environment.ProcessorCount" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property ProcessorCount As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property int ProcessorCount { int get(); };" />
      <MemberSignature Language="F#" Value="member this.ProcessorCount : int" Usage="System.Environment.ProcessorCount" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene el número de procesadores de la máquina actual.</summary>
        <value>Un entero con signo de 32 bits que especifica el número de procesadores de la máquina actual. No existe ningún valor predeterminado. Si la máquina actual contiene varios grupos de procesador, esta propiedad devuelve el número de procesadores lógicos disponibles para el uso por parte de Common Language Runtime (CLR).</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para obtener más información acerca de los grupos de procesadores y los procesadores lógicos, vea [grupos de procesadores](https://msdn.microsoft.com/library/windows/desktop/dd405503.aspx).  
  
   
  
## Examples  
 En el ejemplo siguiente se muestra el <xref:System.Environment.ProcessorCount%2A> propiedad.  
  
 [!code-cpp[environment.processorcount#1](~/samples/snippets/cpp/VS_Snippets_CLR/environment.processorcount/CPP/pc.cpp#1)]
 [!code-csharp[environment.processorcount#1](~/samples/snippets/csharp/VS_Snippets_CLR/environment.processorcount/CS/pc.cs#1)]
 [!code-vb[environment.processorcount#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/environment.processorcount/VB/pc.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="SetEnvironmentVariable">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Crea, modifica o elimina una variable de entorno.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SetEnvironmentVariable">
      <MemberSignature Language="C#" Value="public static void SetEnvironmentVariable (string variable, string value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetEnvironmentVariable(string variable, string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Environment.SetEnvironmentVariable(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetEnvironmentVariable (variable As String, value As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetEnvironmentVariable(System::String ^ variable, System::String ^ value);" />
      <MemberSignature Language="F#" Value="static member SetEnvironmentVariable : string * string -&gt; unit" Usage="System.Environment.SetEnvironmentVariable (variable, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="variable" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="value" Type="System.String" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="variable">Nombre de una variable de entorno.</param>
        <param name="value">Valor que se va asignar a <paramref name="variable" />.</param>
        <summary>Crea, modifica o elimina una variable de entorno almacenada en el proceso actual.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Llamar a este método equivale a llamar a la <xref:System.Environment.SetEnvironmentVariable%28System.String%2CSystem.String%2CSystem.EnvironmentVariableTarget%29> sobrecarga con un valor de <xref:System.EnvironmentVariableTarget.Process?displayProperty=nameWithType> para el `target` argumento.  
  
 Si el `value` argumento no está vacío (vea la explicación de la eliminación de una variable de entorno más adelante en esta sección para obtener la definición de un valor vacío) y la variable de entorno denominada por el `variable` parámetro no existe, el entorno se crea y se asigna el contenido de la variable `value`. Si existe, se modifica su valor. Dado que la variable de entorno se define en el bloque de entorno del proceso actual solo, no se conserva después de finalizado el proceso.  
  
 Si `variable` contiene un valor hexadecimal no inicial caracteres de cero, los caracteres antes de que el carácter cero se consideran el nombre de variable de entorno y se omiten todos los caracteres siguientes.  
  
 Si `value` contiene un valor hexadecimal no inicial caracteres de cero, los caracteres antes de que el carácter cero se asignan a la variable de entorno y se omiten todos los caracteres siguientes.  
  
 Si `value` está vacía y la variable de entorno denominada por `variable` existe, se elimina la variable de entorno. Si `variable` no existe, se produce ningún error, aunque no se puede realizar la operación. `value` se considera vacío en cualquiera de las condiciones siguientes:  
  
-   Es `null`.  
  
-   Es <xref:System.String.Empty?displayProperty=nameWithType>.  
  
-   Consta de un solo carácter cuyo valor es u+0000.  
  
## Examples

El ejemplo siguiente se intenta recuperar el valor de una variable de entorno denominada `Test1` desde el bloque de entorno de proceso. Si la variable no existe, el ejemplo crea la variable y recupera su valor. En el ejemplo se muestra el valor de la variable. Para las implementaciones de .NET que se ejecutan en sistemas de Windows, también llama a la <xref:System.Environment.GetEnvironmentVariables%28System.EnvironmentVariableTarget%29> método con cada miembro de la <xref:System.EnvironmentVariableTarget> enumeración para establecer que la variable se puede recuperar solo desde el bloque de entorno del proceso actual. (Las implementaciones de .NET en sistemas basados en Unix admiten solo las variables en el bloque de entorno de proceso). Por último, si en el ejemplo se crea la variable, la elimina.  
  
 [!code-csharp[System.Environment.GetEnvironmentVariable#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.environment.getenvironmentvariable/cs/getenvironmentvariableex1.cs)]
 [!code-vb[System.Environment.GetEnvironmentVariable#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.environment.getenvironmentvariable/vb/getenvironmentvariableex1.vb)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="variable" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="variable" /> contiene una cadena de longitud cero, un carácter  de cero hexadecimal (0x00) o un signo de igual ("=").  
  
O bien 
La longitud de <paramref name="variable" /> o <paramref name="value" /> es mayor o igual que 32.767 caracteres.  
  
o bien 
Error durante la ejecución de esta operación.</exception>
        <exception cref="T:System.Security.SecurityException">El autor de la llamada no tiene el permiso requerido para llevar a cabo esta operación.</exception>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission">Para obtener acceso completo a las variables de entorno. Enumeración asociada: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></permission>
        <altmember cref="M:System.Environment.GetEnvironmentVariable(System.String)" />
        <altmember cref="M:System.Environment.GetEnvironmentVariables" />
      </Docs>
    </Member>
    <Member MemberName="SetEnvironmentVariable">
      <MemberSignature Language="C#" Value="public static void SetEnvironmentVariable (string variable, string value, EnvironmentVariableTarget target);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetEnvironmentVariable(string variable, string value, valuetype System.EnvironmentVariableTarget target) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Environment.SetEnvironmentVariable(System.String,System.String,System.EnvironmentVariableTarget)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetEnvironmentVariable (variable As String, value As String, target As EnvironmentVariableTarget)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetEnvironmentVariable(System::String ^ variable, System::String ^ value, EnvironmentVariableTarget target);" />
      <MemberSignature Language="F#" Value="static member SetEnvironmentVariable : string * string * EnvironmentVariableTarget -&gt; unit" Usage="System.Environment.SetEnvironmentVariable (variable, value, target)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="variable" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="value" Type="System.String" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="target" Type="System.EnvironmentVariableTarget" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="variable">Nombre de una variable de entorno.</param>
        <param name="value">Valor que se va asignar a <paramref name="variable" />.</param>
        <param name="target">Uno de los valores de enumeración que especifica la ubicación de la variable de entorno.</param>
        <summary>Crea, modifica o elimina una variable de entorno almacenada en el proceso actual o en la clave del Registro del sistema operativo Windows reservada para la máquina local o el usuario actual.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

El <xref:System.Environment.SetEnvironmentVariable%28System.String%2CSystem.String%2CSystem.EnvironmentVariableTarget%29> método le permite definir una variable de entorno que está disponible para el proceso actual (la <xref:System.EnvironmentVariableTarget.Process> valor). Variables de entorno que son únicas para el bloque de entorno del proceso actual persisten sólo hasta que finalice el proceso.

Además, Windows sólo en sistemas, la <xref:System.Environment.SetEnvironmentVariable%28System.String%2CSystem.String%2CSystem.EnvironmentVariableTarget%29> método le permite definir una variable de entorno que esté disponible para todos los procesos que se ejecutan en un equipo (el <xref:System.EnvironmentVariableTarget.Machine?displayProperty=nameWithType> valor) y para todos los procesos ejecutados por el usuario (el <xref:System.EnvironmentVariableTarget.User?displayProperty=nameWithType> valor). Variables de entorno por equipo y por usuario se copian en el bloque de entorno del proceso actual.  
 
En .NET Core en macOS y los sistemas Linux, las llamadas a la <xref:System.Environment.SetEnvironmentVariable%28System.String%2CSystem.String%2CSystem.EnvironmentVariableTarget%29> método con un valor de <xref:System.EnvironmentVariableTarget.Machine?displayProperty=nameWithType> o <xref:System.EnvironmentVariableTarget.User?displayProperty=nameWithType> se omiten. 
  
 Si el `value` argumento no está vacío (vea la explicación de la eliminación de una variable de entorno más adelante en esta sección para obtener la definición de un valor vacío) y la variable de entorno denominada por el `variable` argumento no existe, el entorno se crea y se asigna el contenido de la variable `value`.  Si existe, se modifica su valor.  
  
 Si `variable` contiene un valor hexadecimal no inicial caracteres de cero, los caracteres antes de que el carácter cero se consideran el nombre de variable de entorno y se omiten todos los caracteres siguientes.  
  
 Si `value` contiene un valor hexadecimal no inicial caracteres de cero, los caracteres antes de que el carácter cero se asignan a la variable de entorno y se omiten todos los caracteres siguientes.  
  
 Si `value` está vacía y la variable de entorno denominada por `variable` existe, se elimina la variable de entorno. `value` se considera vacío en cualquiera de las condiciones siguientes:  
  
-   Es `null`.  
  
-   Es <xref:System.String.Empty?displayProperty=nameWithType>.  
  
-   Consta de un solo carácter cuyo valor es u+0000.  
  
 Si `variable` no existe, se produce ningún error aunque no se puede realizar la operación. Tenga cuidado cuando `target` es <xref:System.EnvironmentVariableTarget.Machine>, ya que accidentalmente puede eliminar una variable de entorno que afecte a todo el equipo local, no solo el proceso actual o el usuario.  

### <a name="environmentvariabletargetmachine-and-environmentvariabletargetuser-on-windows-systems"></a>EnvironmentVariableTarget.Machine y EnvironmentVariableTarget.User en sistemas de Windows

Si `target` es <xref:System.EnvironmentVariableTarget.User?displayProperty=nameWithType>, la variable de entorno se almacena en la clave HKEY_CURRENT_USER\Environment del registro del equipo local. También se copian a las instancias del explorador de archivos que se ejecutan como el usuario actual. La variable de entorno, a continuación, se hereda los nuevos procesos que el usuario inicie desde el Explorador de archivos.  
  
 De forma similar, si `target` es <xref:System.EnvironmentVariableTarget.Machine?displayProperty=nameWithType>, la variable de entorno se almacena en la clave HKEY_LOCAL_MACHINE\SYSTEM\ControlSet001\Control\Session Manager\Environment del registro del equipo local. También se copia a todas las instancias del explorador de archivos. La variable de entorno, a continuación, se hereda los nuevos procesos que se inician desde el Explorador de archivos.  
  
 Si `target` es <xref:System.EnvironmentVariableTarget.User> o <xref:System.EnvironmentVariableTarget.Machine>, otras aplicaciones se le notificará de la operación de establecimiento mediante un Windows `WM_SETTINGCHANGE` mensaje.  
  
 Si `target` es <xref:System.EnvironmentVariableTarget.User?displayProperty=nameWithType> o <xref:System.EnvironmentVariableTarget.Machine?displayProperty=nameWithType>, se recomienda que la longitud de `value` tener menos de 2048 caracteres.  
  
## Examples

El siguiente ejemplo crea variables de entorno para la <xref:System.EnvironmentVariableTarget.Process?displayProperty=nameWithType>, <xref:System.EnvironmentVariableTarget.User?displayProperty=nameWithType>, y <xref:System.EnvironmentVariableTarget.Machine> tiene como destino, comprueba si el registro del sistema operativo contiene el usuario y las variables de entorno del equipo y, después, elimina el entorno variables. Ya no soporte por usuario y por equipo y las variables de entorno, solo lo hace .NET en sistemas basados en Unix <xref:System.Environment.SetEnvironmentVariable(System.String,System.String)> y <xref:System.Environment.SetEnvironmentVariable(System.String,System.String,System.EnvironmentVariableTarget)> con un valor de <xref:System.EnvironmentVariableTarget.Process?displayProperty=nameWithType> correctamente almacenar una variable de entorno para el bloque de entorno de proceso.
  
[!code-csharp[environment.getsetenvar#1](~/samples/snippets/csharp/VS_Snippets_CLR/environment.getsetenvar/CS/gsev.cs)]
[!code-vb[environment.getsetenvar#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/environment.getsetenvar/VB/gsev.vb)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="variable" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="variable" /> contiene una cadena de longitud cero, un carácter  de cero hexadecimal (0x00) o un signo de igual ("=").  
  
o bien 
La longitud de <paramref name="variable" /> es mayor o igual que 32.767 caracteres.  
  
O bien 
 <paramref name="target" /> no es un miembro de la enumeración <see cref="T:System.EnvironmentVariableTarget" /> .  
  
O bien 
 <paramref name="target" /> es <see cref="F:System.EnvironmentVariableTarget.Machine" /> o <see cref="F:System.EnvironmentVariableTarget.User" />y la longitud de <paramref name="variable" /> es igual o mayor que 255.  
  
O bien 
 <paramref name="target" /> es <see cref="F:System.EnvironmentVariableTarget.Process" /> y la longitud de <paramref name="value" /> es igual o mayor que 32.767 caracteres.  
  
o bien 
Error durante la ejecución de esta operación.</exception>
        <exception cref="T:System.Security.SecurityException">El autor de la llamada no tiene el permiso requerido para llevar a cabo esta operación.</exception>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission">Para obtener acceso completo a las variables de entorno. Enumeración asociada: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></permission>
        <altmember cref="M:System.Environment.GetEnvironmentVariable(System.String,System.EnvironmentVariableTarget)" />
        <altmember cref="M:System.Environment.GetEnvironmentVariables(System.EnvironmentVariableTarget)" />
        <altmember cref="T:System.EnvironmentVariableTarget" />
      </Docs>
    </Member>
    <Member MemberName="StackTrace">
      <MemberSignature Language="C#" Value="public static string StackTrace { get; }" />
      <MemberSignature Language="ILAsm" Value=".property string StackTrace" />
      <MemberSignature Language="DocId" Value="P:System.Environment.StackTrace" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property StackTrace As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::String ^ StackTrace { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.StackTrace : string" Usage="System.Environment.StackTrace" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene información de seguimiento de la pila actual.</summary>
        <value>Cadena que contiene información acerca del seguimiento de la pila. Este valor puede ser <see cref="F:System.String.Empty" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Environment.StackTrace%2A> listas de propiedades de llamadas a métodos en orden cronológico inverso, es decir, la llamada al método más reciente se describe en primer lugar y aparece una línea de información de seguimiento de pila para cada llamada de método en la pila. Sin embargo, el <xref:System.Environment.StackTrace%2A> propiedad no podría informar de las llamadas a métodos tal como se esperaba debido a las transformaciones de código que se producen durante la optimización.  
  
> [!NOTE]
>  Para obtener una vista jerárquica de la información de seguimiento de pila por clase, use la <xref:System.Diagnostics.StackTrace> clase.  
  
 El <xref:System.Environment.StackTrace%2A> propiedad da formato a la información de seguimiento de pila para cada llamada al método como sigue:  
  
 "en `FullClassName`.`MethodName` (`MethodParams`) en `FileName` : línea `LineNumber` "  
  
 El literal "en" está precedido por tres espacios, y toda la subcadena empezando por "in" se omite si los símbolos de depuración no están disponibles. Los marcadores de posición, `FullClassName`, `MethodName`, `MethodParams`, `FileName`, y `LineNumber`, se reemplazan por valores reales y se definen como sigue:  
  
 FullClassName  
 El nombre completo de la clase, incluido el espacio de nombres.  
  
 `MethodName`  
 Nombre del método.  
  
 `MethodParams`  
 La lista de pares de nombre del tipo de parámetro. Cada par se separa por una coma (","). Esta información se omite si `MethodName` no toma ningún parámetro.  
  
 `FileName`  
 El nombre del origen de archivo donde el `MethodName` se declara el método. Esta información se omite si los símbolos de depuración no están disponibles.  
  
 `LineNumber`  
 El número de la línea en `FileName` que contiene el código fuente de `MethodName` para la instrucción que se encuentra en la pila de llamadas. Esta información se omite si los símbolos de depuración no están disponibles.  
  
 El <xref:System.Environment.NewLine%2A?displayProperty=nameWithType> cadena finaliza cada línea del seguimiento de pila.  
  
   
  
## Examples  
 En el ejemplo siguiente se muestra el <xref:System.Environment.StackTrace%2A> propiedad.  
  
 [!code-cpp[environment.stacktrace#1](~/samples/snippets/cpp/VS_Snippets_CLR/Environment.StackTrace/CPP/stacktrace.cpp#1)]
 [!code-csharp[environment.stacktrace#1](~/samples/snippets/csharp/VS_Snippets_CLR/Environment.StackTrace/CS/stacktrace.cs#1)]
 [!code-vb[environment.stacktrace#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Environment.StackTrace/VB/stacktrace.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission">Para obtener acceso completo al recurso protegido por el permiso. Enumeración asociada: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></permission>
      </Docs>
    </Member>
    <Member MemberName="SystemDirectory">
      <MemberSignature Language="C#" Value="public static string SystemDirectory { get; }" />
      <MemberSignature Language="ILAsm" Value=".property string SystemDirectory" />
      <MemberSignature Language="DocId" Value="P:System.Environment.SystemDirectory" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property SystemDirectory As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::String ^ SystemDirectory { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.SystemDirectory : string" Usage="System.Environment.SystemDirectory" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene la ruta de acceso completa del directorio del sistema.</summary>
        <value>Una cadena que contiene la ruta de acceso de un directorio.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un ejemplo del valor devuelto es la cadena "C:\WinNT\System32".  
  
   
  
## Examples  
 El ejemplo siguiente muestra el directorio del sistema del equipo que ejecuta el ejemplo de código. (El directorio del sistema se omite del resultado del ejemplo por motivos de seguridad).  
  
 [!code-cpp[environment.systemdirectory#1](~/samples/snippets/cpp/VS_Snippets_CLR/Environment.SystemDirectory/CPP/systemdirectory.cpp#1)]
 [!code-csharp[environment.systemdirectory#1](~/samples/snippets/csharp/VS_Snippets_CLR/Environment.SystemDirectory/CS/systemdirectory.cs#1)]
 [!code-vb[environment.systemdirectory#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Environment.SystemDirectory/VB/systemdirectory.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Para obtener acceso a la información de la ruta de acceso. Enumeración asociada: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
      </Docs>
    </Member>
    <Member MemberName="SystemPageSize">
      <MemberSignature Language="C#" Value="public static int SystemPageSize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property int32 SystemPageSize" />
      <MemberSignature Language="DocId" Value="P:System.Environment.SystemPageSize" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property SystemPageSize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property int SystemPageSize { int get(); };" />
      <MemberSignature Language="F#" Value="member this.SystemPageSize : int" Usage="System.Environment.SystemPageSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene el número de bytes de la página de memoria del sistema operativo.</summary>
        <value>Número de bytes en una página de memoria del sistema.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esta información puede ser útil al determinar si se debe usar el <xref:System.IO.MemoryMappedFiles.MemoryMappedFileOptions.DelayAllocatePages?displayProperty=nameWithType> opción cuando se trabaja con archivos asignados a memoria.  
  
 En Windows, este valor es el `dwPageSize` miembro en el `SYSTEM_INFO` estructura.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission">Para obtener acceso a variables de entorno de usuario y del sistema. Excepción asociada: 
 <see cref="P:System.Security.SecurityException.PermissionState" /></permission>
      </Docs>
    </Member>
    <Member MemberName="TickCount">
      <MemberSignature Language="C#" Value="public static int TickCount { get; }" />
      <MemberSignature Language="ILAsm" Value=".property int32 TickCount" />
      <MemberSignature Language="DocId" Value="P:System.Environment.TickCount" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property TickCount As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property int TickCount { int get(); };" />
      <MemberSignature Language="F#" Value="member this.TickCount : int" Usage="System.Environment.TickCount" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene el número de milisegundos transcurridos desde que se inició el sistema.</summary>
        <value>Un entero de 32 bits que contiene el tiempo en milisegundos que transcurrió desde la última vez que se inició el equipo.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El valor de esta propiedad se deriva el temporizador del sistema y se almacena como un entero de 32 bits con signo. Tenga en cuenta que, dado que se deriva el temporizador del sistema, la resolución de la <xref:System.Environment.TickCount%2A> propiedad está limitada a la resolución del temporizador del sistema, que se encuentra normalmente en el intervalo de 10 a 16 milisegundos.  
  
> [!IMPORTANT]
>  Dado que el valor de la <xref:System.Environment.TickCount%2A> valor de propiedad es un entero con signo de 32 bits, si el sistema se ejecuta continuamente, <xref:System.Environment.TickCount%2A> aumentará de cero a <xref:System.Int32.MaxValue?displayProperty=nameWithType> aproximadamente 24,9 días, a continuación, vaya a <xref:System.Int32.MinValue?displayProperty=nameWithType>, que es un número negativo, a continuación, aumentar hasta cero durante los próximos días 24,9. Puede solucionar este problema mediante una llamada a la Windows [GetTickCount](https://msdn.microsoft.com/library/windows/desktop/ms724408.aspx) función, que se restablece en cero después de aproximadamente 49,7 días, o mediante una llamada a la [GetTickCount64](https://msdn.microsoft.com/library/windows/desktop/ms724411.aspx) función.  
  
 <xref:System.Environment.TickCount%2A> es diferente de la <xref:System.DateTime.Ticks%2A?displayProperty=nameWithType> propiedad, que es el número de intervalos de 100 nanosegundos que han transcurrido desde el 1/1/0001 12:00 am.  
  
 Use el <xref:System.DateTime.Now%2A?displayProperty=nameWithType> propiedad para obtener la fecha local actual y la hora en este equipo.  
  
   
  
## Examples  
 En el ejemplo siguiente se muestra cómo recuperar el intervalo de valores devueltos por positivo la <xref:System.Environment.TickCount%2A> propiedad. El <xref:System.Environment.TickCount%2A> propiedad alterna entre <xref:System.Int32.MinValue?displayProperty=nameWithType>, que es un número negativo, y <xref:System.Int32.MaxValue?displayProperty=nameWithType> cada 49,8 días. Este ejemplo de código quita el bit de signo para producir un número no negativo que alterna entre cero y <xref:System.Int32.MaxValue> cada 24,9 días.  
  
 [!code-cpp[environment.tickcount#1](~/samples/snippets/cpp/VS_Snippets_CLR/Environment.TickCount/CPP/tickcount.cpp#1)]
 [!code-csharp[environment.tickcount#1](~/samples/snippets/csharp/VS_Snippets_CLR/Environment.TickCount/CS/tickcount.cs#1)]
 [!code-vb[environment.tickcount#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Environment.TickCount/VB/tickcount.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TickCount64">
      <MemberSignature Language="C#" Value="public static long TickCount64 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property int64 TickCount64" />
      <MemberSignature Language="DocId" Value="P:System.Environment.TickCount64" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property TickCount64 As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property long TickCount64 { long get(); };" />
      <MemberSignature Language="F#" Value="member this.TickCount64 : int64" Usage="System.Environment.TickCount64" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="UserDomainName">
      <MemberSignature Language="C#" Value="public static string UserDomainName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property string UserDomainName" />
      <MemberSignature Language="DocId" Value="P:System.Environment.UserDomainName" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property UserDomainName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::String ^ UserDomainName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.UserDomainName : string" Usage="System.Environment.UserDomainName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene el nombre de dominio de red asociado al usuario actual.</summary>
        <value>El nombre de dominio de red asociado al usuario actual.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Las credenciales de cuenta de dominio para un usuario tiene el formato de nombre de dominio del usuario, la '\\' nombre de usuario y de carácter. Use la <xref:System.Environment.UserDomainName%2A> propiedad para obtener el nombre de dominio del usuario sin el nombre de usuario y la <xref:System.Environment.UserName%2A> propiedad para obtener el nombre de usuario sin el nombre de dominio.  Por ejemplo, si un usuario nombre de dominio y nombre de usuario son CORPORATENETWORK\john, el <xref:System.Environment.UserDomainName%2A> propiedad devuelve "CORPORATENETWORK".  
  
 El <xref:System.Environment.UserDomainName%2A> propiedad primero intenta obtener el componente de nombre de dominio del nombre de cuenta de Windows para el usuario actual. Si este intento falla, esta propiedad intenta obtener el nombre de dominio asociado con el nombre de usuario proporcionado por el <xref:System.Environment.UserName%2A> propiedad. Si ese intento falla porque el equipo host no está unido a un dominio, se devuelve el nombre del equipo host.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">El sistema operativo no admite la recuperación del nombre de dominio de red.</exception>
        <exception cref="T:System.InvalidOperationException">No se puede recuperar el nombre de dominio de red.</exception>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission">acceso de lectura a la variable de entorno USERDOMAIN. Enumeración asociada: <see cref="F:System.Security.Permissions.EnvironmentPermissionAccess.Read" /></permission>
        <altmember cref="P:System.Environment.UserName" />
      </Docs>
    </Member>
    <Member MemberName="UserInteractive">
      <MemberSignature Language="C#" Value="public static bool UserInteractive { get; }" />
      <MemberSignature Language="ILAsm" Value=".property bool UserInteractive" />
      <MemberSignature Language="DocId" Value="P:System.Environment.UserInteractive" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property UserInteractive As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool UserInteractive { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.UserInteractive : bool" Usage="System.Environment.UserInteractive" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene un valor que indica si el proceso actual se ejecuta en modo de interacción con el usuario.</summary>
        <value>Es <see langword="true" /> si el proceso actual se ejecuta en modo de interacción con el usuario; en caso contrario, es <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Environment.UserInteractive%2A> propiedad informes `false` para un proceso de Windows o un servicio como IIS que se ejecute sin una interfaz de usuario. Si esta propiedad es `false`, no se muestran los cuadros de diálogo modales o porque no hay ninguna interfaz gráfica de usuario para el usuario interactuar con los cuadros de mensaje.  
  
   
  
## Examples  
 El ejemplo siguiente se muestra si el proceso actual se ejecuta en modo interactivo de usuario.  
  
 [!code-cpp[Environment.UserInteractive#1](~/samples/snippets/cpp/VS_Snippets_CLR/Environment.UserInteractive/CPP/userinteractive.cpp#1)]
 [!code-csharp[Environment.UserInteractive#1](~/samples/snippets/csharp/VS_Snippets_CLR/Environment.UserInteractive/CS/userinteractive.cs#1)]
 [!code-vb[Environment.UserInteractive#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Environment.UserInteractive/VB/userinteractive.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Forms.SystemInformation" />
      </Docs>
    </Member>
    <Member MemberName="UserName">
      <MemberSignature Language="C#" Value="public static string UserName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property string UserName" />
      <MemberSignature Language="DocId" Value="P:System.Environment.UserName" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property UserName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::String ^ UserName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.UserName : string" Usage="System.Environment.UserName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene el nombre de usuario de la persona que inició sesión en el sistema operativo.</summary>
        <value>El nombre de usuario de la persona que ha iniciado sesión en el sistema operativo.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Puede usar el <xref:System.Environment.UserName%2A> propiedad para identificar al usuario en el subproceso actual, en el sistema y aplicaciones para fines de seguridad o acceso. También puede utilizarse para personalizar una aplicación determinada para cada usuario.  
 
 En Windows el <xref:System.Environment.UserName%2A> propiedad incluye una llamada a la Windows [GetUserName](https://msdn.microsoft.com/library/windows/desktop/ms724432.aspx) función. Las credenciales de cuenta de dominio para un usuario tiene el formato de nombre de dominio del usuario, la '\\' nombre de usuario y de carácter. Use la <xref:System.Environment.UserDomainName%2A> propiedad para obtener el nombre de dominio del usuario y la <xref:System.Environment.UserName%2A> propiedad para obtener el nombre de usuario.  
 
 En plataformas Unix el <xref:System.Environment.UserName%2A> propiedad incluye una llamada a la `getpwuid_r` función.
 
 Si una aplicación ASP.NET se ejecuta en un entorno de desarrollo, la <xref:System.Environment.UserName%2A> propiedad devuelve el nombre del usuario actual. En una aplicación ASP.NET publicada, esta propiedad devuelve el nombre de la cuenta de grupo de aplicaciones (por ejemplo, el grupo de aplicaciones predeterminado).  
  
   
  
## Examples  
 El ejemplo siguiente muestra el nombre de usuario de la persona que inició el subproceso actual.  
  
 [!code-cpp[Environment.UserName#1](~/samples/snippets/cpp/VS_Snippets_CLR/Environment.UserName/CPP/username.cpp#1)]
 [!code-csharp[Environment.UserName#1](~/samples/snippets/csharp/VS_Snippets_CLR/Environment.UserName/CS/username.cs#1)]
 [!code-vb[Environment.UserName#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Environment.UserName/VB/username.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission">acceso de lectura a la variable de entorno del usuario. Enumeración asociada: <see cref="F:System.Security.Permissions.EnvironmentPermissionAccess.Read" /></permission>
        <altmember cref="P:System.Environment.UserDomainName" />
      </Docs>
    </Member>
    <Member MemberName="Version">
      <MemberSignature Language="C#" Value="public static Version Version { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Version Version" />
      <MemberSignature Language="DocId" Value="P:System.Environment.Version" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property Version As Version" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property Version ^ Version { Version ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Version : Version" Usage="System.Environment.Version" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Version</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene un objeto <see cref="T:System.Version" /> que describe los números principal, secundario, de compilación y de revisión de Common Language Runtime.</summary>
        <value>Un objeto que muestra la versión de Common Language Runtime.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para las versiones 4, 4.5, 4.5.1 y 4.5.2 de .NET Framework, la propiedad <xref:System.Environment.Version%2A?displayProperty=nameWithType> devuelve un objeto <xref:System.Version> cuya representación de cadena tiene la forma `4.0.30319.xxxxx`. Para el .NET Framework 4.6 y versiones posteriores, tiene la forma `4.0.30319.42000`.  
  
> [!WARNING]
>  Para el [!INCLUDE[net_v45](~/includes/net-v45-md.md)] y versiones posteriores, no se recomienda usar el <xref:System.Environment.Version%2A> propiedad para detectar la versión del tiempo de ejecución; en su lugar, puede determinar la versión de common language runtime consultando el registro. Para obtener más información, vea [Cómo: Determinar qué versiones de .NET Framework están instaladas](~/docs/framework/migration-guide/how-to-determine-which-versions-are-installed.md).  
  
 Para obtener más información acerca de la versión de common language runtime que se instala con cada versión de .NET Framework, vea [versiones y dependencias](~/docs/framework/migration-guide/versions-and-dependencies.md).  
  
   
  
## Examples  
 El ejemplo siguiente muestra la versión de common language runtime. (La versión se omite del resultado del ejemplo por motivos de seguridad).  
  
 [!code-cpp[Environment.Version#1](~/samples/snippets/cpp/VS_Snippets_CLR/Environment.Version/CPP/version.cpp#1)]
 [!code-csharp[Environment.Version#1](~/samples/snippets/csharp/VS_Snippets_CLR/Environment.Version/CS/version.cs#1)]
 [!code-vb[Environment.Version#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Environment.Version/VB/version.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WorkingSet">
      <MemberSignature Language="C#" Value="public static long WorkingSet { get; }" />
      <MemberSignature Language="ILAsm" Value=".property int64 WorkingSet" />
      <MemberSignature Language="DocId" Value="P:System.Environment.WorkingSet" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property WorkingSet As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property long WorkingSet { long get(); };" />
      <MemberSignature Language="F#" Value="member this.WorkingSet : int64" Usage="System.Environment.WorkingSet" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene la cantidad de memoria física asignada al contexto del proceso.</summary>
        <value>Un entero de 64 bits con signo que contiene el número de bytes de memoria física asignada al contexto del proceso.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 El ejemplo siguiente muestra el tamaño del conjunto de trabajo del equipo que ejecuta el ejemplo de código.  
  
 [!code-cpp[Environment.WorkingSet#1](~/samples/snippets/cpp/VS_Snippets_CLR/Environment.WorkingSet/CPP/workingset.cpp#1)]
 [!code-csharp[Environment.WorkingSet#1](~/samples/snippets/csharp/VS_Snippets_CLR/Environment.WorkingSet/CS/workingset.cs#1)]
 [!code-vb[Environment.WorkingSet#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Environment.WorkingSet/VB/workingset.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission">Para obtener acceso completo al recurso protegido por este permiso. Enumeración asociada: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></permission>
      </Docs>
    </Member>
  </Members>
</Type>
