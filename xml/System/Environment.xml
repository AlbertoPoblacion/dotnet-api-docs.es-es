<Type Name="Environment" FullName="System.Environment">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="5f96e4916ee795fe08ea4d82b79db4cdfbbc3b65" />
    <Meta Name="ms.sourcegitcommit" Value="6a0b904069161bbaec4ffd02aa7d9cf38c61e72e" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="es-ES" />
    <Meta Name="ms.lasthandoff" Value="06/24/2018" />
    <Meta Name="ms.locfileid" Value="36431958" />
  </Metadata>
  <TypeSignature Language="C#" Value="public static class Environment" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract sealed beforefieldinit Environment extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Environment" />
  <TypeSignature Language="VB.NET" Value="Public Class Environment" />
  <TypeSignature Language="C++ CLI" Value="public ref class Environment abstract sealed" />
  <TypeSignature Language="F#" Value="type Environment = class" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime.Extensions</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Provides information about, and means to manipulate, the current environment and platform. This class cannot be inherited.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use la <xref:System.Environment> clase para recuperar información como argumentos de línea de comandos, el código de salida, los valores de variable de entorno, contenido de la pila de llamadas, el tiempo desde último inicio del sistema y la versión de common language runtime.  
  
   
  
## Examples  
 En el ejemplo siguiente se muestra cómo muestra una lista de información sobre el entorno actual.  
  
 [!code-cpp[environment.class#1](~/samples/snippets/cpp/VS_Snippets_CLR/environment.class/CPP/env0.cpp#1)]
 [!code-csharp[environment.class#1](~/samples/snippets/csharp/VS_Snippets_CLR/environment.class/CS/env0.cs#1)]
 [!code-vb[environment.class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/environment.class/VB/env0.vb#1)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName="CommandLine">
      <MemberSignature Language="C#" Value="public static string CommandLine { get; }" />
      <MemberSignature Language="ILAsm" Value=".property string CommandLine" />
      <MemberSignature Language="DocId" Value="P:System.Environment.CommandLine" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property CommandLine As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::String ^ CommandLine { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.CommandLine : string" Usage="System.Environment.CommandLine" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the command line for this process.</summary>
        <value>Una cadena que contiene argumentos de la línea de comandos.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esta propiedad proporciona acceso al nombre del programa y los argumentos especificados en la línea de comandos cuando se inició el proceso actual.  
  
 El nombre del programa puede incluir información de ruta de acceso, pero no es necesario hacerlo. Use la <xref:System.Environment.GetCommandLineArgs%2A> método para recuperar la información de línea de comandos analizada y almacenada en una matriz de cadenas.  
  
 El tamaño máximo del búfer de línea de comandos no se establece en un número específico de caracteres. varía según el sistema operativo Windows que se ejecuta en el equipo.  
  
   
  
## Examples  
 En el ejemplo siguiente se muestra su propia línea de comandos.  
  
 [!code-cpp[environment.commandline#1](~/samples/snippets/cpp/VS_Snippets_CLR/environment.CommandLine/CPP/commandline.cpp#1)]
 [!code-csharp[environment.commandline#1](~/samples/snippets/csharp/VS_Snippets_CLR/environment.CommandLine/CS/commandline.cs#1)]
 [!code-vb[environment.commandline#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/environment.CommandLine/VB/commandline.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission">Para obtener acceso de lectura a la variable de entorno PATH. Enumeración asociada: <see cref="F:System.Security.Permissions.EnvironmentPermissionAccess.Read" /></permission>
        <altmember cref="M:System.Environment.GetCommandLineArgs" />
      </Docs>
    </Member>
    <Member MemberName="CurrentDirectory">
      <MemberSignature Language="C#" Value="public static string CurrentDirectory { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property string CurrentDirectory" />
      <MemberSignature Language="DocId" Value="P:System.Environment.CurrentDirectory" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property CurrentDirectory As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::String ^ CurrentDirectory { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.CurrentDirectory : string with get, set" Usage="System.Environment.CurrentDirectory" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the fully qualified path of the current working directory.</summary>
        <value>Una cadena que contiene la ruta de acceso de un directorio.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Por definición, si este proceso se inicia en el directorio raíz de una variable local o una unidad de red, el valor de esta propiedad es el nombre de la unidad seguido por una barra diagonal final (por ejemplo, "C:\\"). Si este proceso se inicia en un subdirectorio, el valor de esta propiedad es la ruta de acceso de unidad y subdirectorio, sin una barra diagonal final (por ejemplo, "C:\mySubDirectory").  
  
   
  
## Examples  
 En el ejemplo siguiente se demuestra cómo establecer el <xref:System.Environment.CurrentDirectory%2A> propiedad.  
  
 [!code-cpp[System.Environment#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Environment/CPP/Vars1.cpp#4)]
 [!code-csharp[System.Environment#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Environment/CS/Vars1.cs#4)]
 [!code-vb[System.Environment#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Environment/VB/Vars1.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Attempted to set to an empty string ("").</exception>
        <exception cref="T:System.ArgumentNullException">Attempted to set to <see langword="null." /></exception>
        <exception cref="T:System.IO.IOException">An I/O error occurred.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Attempted to set a local path that cannot be found.</exception>
        <exception cref="T:System.Security.SecurityException">The caller does not have the appropriate permission.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">para escribir en archivos o directorios en una operación de establecimiento. Enumeración asociada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Para obtener acceso a la información de la ruta de acceso en una operación get. Enumeración asociada: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
      </Docs>
    </Member>
    <Member MemberName="CurrentManagedThreadId">
      <MemberSignature Language="C#" Value="public static int CurrentManagedThreadId { get; }" />
      <MemberSignature Language="ILAsm" Value=".property int32 CurrentManagedThreadId" />
      <MemberSignature Language="DocId" Value="P:System.Environment.CurrentManagedThreadId" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property CurrentManagedThreadId As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property int CurrentManagedThreadId { int get(); };" />
      <MemberSignature Language="F#" Value="member this.CurrentManagedThreadId : int" Usage="System.Environment.CurrentManagedThreadId" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets a unique identifier for the current managed thread.</summary>
        <value>Entero que representa un identificador único para este subproceso administrado.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Exit">
      <MemberSignature Language="C#" Value="public static void Exit (int exitCode);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Exit(int32 exitCode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Environment.Exit(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Exit (exitCode As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Exit(int exitCode);" />
      <MemberSignature Language="F#" Value="static member Exit : int -&gt; unit" Usage="System.Environment.Exit exitCode" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="exitCode" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="exitCode">The exit code to return to the operating system. Use 0 (zero) to indicate that the process completed successfully.</param>
        <summary>Terminates this process and returns an exit code to the operating system.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para el `exitCode` parámetro, número de uso de un elemento que es distinto de cero para indicar un error. En la aplicación, puede definir sus propios códigos de error de una enumeración y devolver el código de error adecuado en función del escenario. Por ejemplo, devolver un valor de 1 para indicar que el archivo necesario no está presente y un valor de 2 para indicar que el archivo está en un formato incorrecto. Para obtener una lista de códigos de salida utilizado por el sistema operativo Windows, consulte [códigos de Error de sistema](http://msdn.microsoft.com/library/ms681381.aspx) en la documentación de Windows.  
  
 Llamar a la <xref:System.Environment.Exit%2A> método difiere del uso de su lenguaje de programación `return` instrucción de las maneras siguientes:  
  
-   <xref:System.Environment.Exit%2A> siempre termina una aplicación. Mediante el `return` instrucción puede finalizar una aplicación solo si se usa en el punto de entrada de la aplicación, como en el `Main` método.  
  
-   <xref:System.Environment.Exit%2A> finaliza una aplicación inmediatamente, incluso si otros subprocesos se están ejecutando. Si el `return` instrucción se llama en el punto de entrada de la aplicación, hace que una aplicación finalizar solo una vez que han finalizado todos los subprocesos de primer plano.  
  
-   <xref:System.Environment.Exit%2A> requiere que el llamador tiene permiso para llamar a código no administrado. El `return` instrucción no.  
  
-   Si <xref:System.Environment.Exit%2A> se llama desde una `try` o `catch` bloquear, el código en cualquier `finally` bloque no se ejecuta. Si el `return` se utiliza la instrucción, el código en el `finally` bloque de ejecutarse.  
  
-   Si <xref:System.Environment.Exit%2A> se llama cuando el código de un [región de ejecución restringidas](~/docs/framework/performance/constrained-execution-regions.md) (CER) se está ejecutando, la CER no completará la ejecución. Si el `return` se utiliza la instrucción, la CER finalice la ejecución.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">The caller does not have sufficient security permission to perform this function.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Para poder llamar a código no administrado. Enumeración asociada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
      </Docs>
    </Member>
    <Member MemberName="ExitCode">
      <MemberSignature Language="C#" Value="public static int ExitCode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property int32 ExitCode" />
      <MemberSignature Language="DocId" Value="P:System.Environment.ExitCode" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property ExitCode As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property int ExitCode { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.ExitCode : int with get, set" Usage="System.Environment.ExitCode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the exit code of the process.</summary>
        <value>Un entero de 32 bits con signo que contiene el código de salida. El valor predeterminado es 0 (cero), lo que indica que el proceso se completó correctamente.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si el `Main` método `void`, puede utilizar esta propiedad para establecer el código de salida que se devolverá al entorno que realiza la llamada. Si `Main` no devuelve `void`, esta propiedad se omite. El valor inicial de esta propiedad es cero.  
  
> [!WARNING]
>  El <xref:System.Environment.ExitCode%2A> propiedad es un entero de 32 bits con signo. Para evitar que la propiedad devuelve un código de salida negativo, no se deben usar valores mayores que o iguales a 0 x 80000000.  
  
 Use un número distinto de cero para indicar un error. En la aplicación, puede definir sus propios códigos de error de una enumeración y devolver el código de error adecuado en función del escenario. Por ejemplo, devolver un valor de 1 para indicar que el archivo necesario no está presente y un valor de 2 para indicar que el archivo está en un formato incorrecto. Para obtener una lista de códigos de salida utilizado por el sistema operativo Windows, consulte [códigos de Error de sistema](http://msdn.microsoft.com/library/ms681381\(v=vs.85\)) en la documentación de Windows.  
  
   
  
## Examples  
 La siguiente es una aplicación sencilla denominada Double.exe que duplica un valor entero que se pasa como un argumento de línea de comandos. El valor asigna códigos de error para el <xref:System.Environment.ExitCode%2A> propiedad para indicar condiciones de error. Tenga en cuenta que debe agregar una referencia al ensamblado System.Numerics.dll para compilar correctamente el ejemplo.  
  
 [!code-csharp[System.Environment.ExitCode#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.environment.exitcode/cs/double.cs#1)]
 [!code-vb[System.Environment.ExitCode#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.environment.exitcode/vb/double.vb#1)]  
  
 En el ejemplo, a continuación, se puede invocar desde un archivo por lotes, como los siguientes valores, que hace que sus códigos de error accesible mediante el `ERRORLEVEL` comando.  
  
```  
  
echo off  
Double.exe %1  
If errorlevel 1639 goto NoArg   
if errorlevel 534 goto Overflow  
if errorlevel 160 goto BadArg  
if errorlevel 0 echo Completed Successfully   
goto :EOF  
  
:NoArg  
echo Missing argument  
goto :EOF  
  
: Overflow  
echo Arithmetic overflow  
goto :EOF  
  
:BadArg  
echo Invalid argument  
goto :EOF  
  
```  
  
 A continuación muestra algunos resultados de ejemplo generados invocando el archivo por lotes.  
  
```Output  
  
>getdouble 123>echo offResult: 246Completed Successfully>getdouble 5912323109093>echo offArithmetic overflow>getdouble>echo offMissing argument>getdouble "a string">echo offInvalid argument  
  
```  
  
 Tenga en cuenta que el código para Double.exe es idéntico en función en el ejemplo siguiente, salvo que el primero define un punto de entrada denominado `Main` que no tiene ningún valor devuelto, mientras que en este ejemplo se define un punto de entrada llamado `Main` que devuelve un entero.  
  
 [!code-csharp[System.Environment.ExitCode#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.environment.exitcode/cs/double1.cs#2)]
 [!code-vb[System.Environment.ExitCode#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.environment.exitcode/vb/double1.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ExpandEnvironmentVariables">
      <MemberSignature Language="C#" Value="public static string ExpandEnvironmentVariables (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string ExpandEnvironmentVariables(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Environment.ExpandEnvironmentVariables(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ExpandEnvironmentVariables (name As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ ExpandEnvironmentVariables(System::String ^ name);" />
      <MemberSignature Language="F#" Value="static member ExpandEnvironmentVariables : string -&gt; string" Usage="System.Environment.ExpandEnvironmentVariables name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">A string containing the names of zero or more environment variables. Each environment variable is quoted with the percent sign character (%).</param>
        <summary>Replaces the name of each environment variable embedded in the specified string with the string equivalent of the value of the variable, then returns the resulting string.</summary>
        <returns>A string with each environment variable replaced by its value.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Interoperabilidad COM se utiliza para recuperar las variables de entorno del sistema operativo. Si las variables de entorno no se puede recuperar debido a un error de COM, el valor HRESULT que explica la causa del error se usa para generar una de las posibles excepciones; es decir, la excepción depende del valor HRESULT. Para obtener más información acerca de cómo se procesa el valor HRESULT, vea la sección Comentarios de la <xref:System.Runtime.InteropServices.Marshal.ThrowExceptionForHR%2A?displayProperty=nameWithType> método.  
  
 Sustitución solo se produce para las variables de entorno que se establecen. Por ejemplo, suponga que `name` es "MiVAE = % MiVAE %". Si la variable de entorno, MiVAE, se establece en 42, este método devuelve "MiVAE = 42". Si no se establece MiVAE, se produce ningún cambio; Este método devuelve "MiVAE = % MiVAE %".  
  
 El tamaño del valor devuelto está limitado a 32 KB.  
  
   
  
## Examples  
 En el ejemplo siguiente se muestra cómo obtener la unidad del sistema y las variables de raíz del sistema.  
  
 [!code-cpp[Environment.ExpandEnvironmentVariables#1](~/samples/snippets/cpp/VS_Snippets_CLR/environment.ExpandEnvironmentVariables/CPP/expandenvironmentvariables.cpp#1)]
 [!code-csharp[Environment.ExpandEnvironmentVariables#1](~/samples/snippets/csharp/VS_Snippets_CLR/environment.ExpandEnvironmentVariables/CS/expandenvironmentvariables.cs#1)]
 [!code-vb[Environment.ExpandEnvironmentVariables#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/environment.ExpandEnvironmentVariables/VB/expandenvironmentvariables.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> is <see langword="null" />.</exception>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission">la capacidad tener acceso a las variables de entorno en <paramref name="name" />. Enumeración asociada: <see cref="F:System.Security.Permissions.EnvironmentPermissionAccess.Read" /></permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="FailFast">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Immediately terminates a process after writing a message to the Windows Application event log, and then includes the message and optional exception information in error reporting to Microsoft.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="FailFast">
      <MemberSignature Language="C#" Value="public static void FailFast (string message);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void FailFast(string message) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Environment.FailFast(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub FailFast (message As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void FailFast(System::String ^ message);" />
      <MemberSignature Language="F#" Value="static member FailFast : string -&gt; unit" Usage="System.Environment.FailFast message" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="message" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="message">A message that explains why the process was terminated, or <see langword="null" /> if no explanation is provided.</param>
        <summary>Immediately terminates a process after writing a message to the Windows Application event log, and then includes the message in error reporting to Microsoft.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método finaliza un proceso sin ejecutar ningún activo `try` / `finally` finalizadores ni bloques.  
  
 El <xref:System.Environment.FailFast%2A> método escribe el `message` cadena al registro de eventos de aplicación para Windows, crea un volcado de la aplicación y, a continuación, finaliza el proceso actual. El `message` cadena también se incluye en el informe a Microsoft de errores.  
  
 Use la <xref:System.Environment.FailFast%2A> en lugar del método la <xref:System.Environment.Exit%2A> método para finalizar la aplicación si se daña el estado de la aplicación no se puede reparar y ejecutar la aplicación `try` / `finally` finalizadores y bloques va a dañar recursos del programa.  
  
 Se ofrece información a Microsoft mediante el uso de informe de errores de Windows. Para obtener más información, consulte [Windows Error Reporting: Introducción a](http://msdn.microsoft.com/library/windows/hardware/dn641144.aspx).  
  
   
  
## Examples  
 En el ejemplo siguiente se escribe una entrada del registro en el registro de eventos de aplicación para Windows y finaliza el proceso actual.  
  
 [!code-csharp[environment.FailFast#1](~/samples/snippets/csharp/VS_Snippets_CLR/environment.FailFast/cs/ff.cs#1)]
 [!code-vb[environment.FailFast#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/environment.FailFast/vb/ff.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Requiere plena confianza para el llamador inmediato. Este miembro no puede usarse por código de confianza parcial o transparente.</permission>
      </Docs>
    </Member>
    <Member MemberName="FailFast">
      <MemberSignature Language="C#" Value="public static void FailFast (string message, Exception exception);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void FailFast(string message, class System.Exception exception) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Environment.FailFast(System.String,System.Exception)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void FailFast(System::String ^ message, Exception ^ exception);" />
      <MemberSignature Language="F#" Value="static member FailFast : string * Exception -&gt; unit" Usage="System.Environment.FailFast (message, exception)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="message" Type="System.String" />
        <Parameter Name="exception" Type="System.Exception" />
      </Parameters>
      <Docs>
        <param name="message">A message that explains why the process was terminated, or <see langword="null" /> if no explanation is provided.</param>
        <param name="exception">An exception that represents the error that caused the termination. This is typically the exception in a <see langword="catch" /> block.</param>
        <summary>Immediately terminates a process after writing a message to the Windows Application event log, and then includes the message and exception information in error reporting to Microsoft.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método finaliza el proceso sin ejecutar ningún activo `try` / `finally` finalizadores ni bloques.  
  
 El <xref:System.Environment.FailFast%2A> método escribe el `message` cadena al registro de eventos de aplicación para Windows, crea un volcado de la aplicación y, a continuación, finaliza el proceso actual.  
  
 Se ofrece información a Microsoft mediante el uso de informe de errores de Windows. Para obtener más información, consulte [Windows Error Reporting: Introducción a](http://msdn.microsoft.com/library/windows/hardware/dn641144.aspx). Error al informar a Microsoft incluye `message` y `exception` información, que proporciona información detallada que se usa para clasificar el error. Aunque `exception` no es controlados porque se finaliza el proceso, se obtiene todavía la información contextual que provocó la excepción.  
  
 Si `exception` es `null`, o si `exception` no es se produce, este método funciona igual que el <xref:System.Environment.FailFast%28System.String%29> sobrecarga del método.  
  
 Use la <xref:System.Environment.FailFast%2A> en lugar del método la <xref:System.Environment.Exit%2A> método para finalizar la aplicación si se daña el estado de la aplicación no se puede reparar y ejecutar la aplicación `try` / `finally` finalizadores y bloques va a dañar recursos del programa.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Requiere plena confianza para el llamador inmediato. Este miembro no puede usarse por código de confianza parcial o transparente.</permission>
      </Docs>
    </Member>
    <Member MemberName="GetCommandLineArgs">
      <MemberSignature Language="C#" Value="public static string[] GetCommandLineArgs ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string[] GetCommandLineArgs() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Environment.GetCommandLineArgs" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetCommandLineArgs () As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::String ^&gt; ^ GetCommandLineArgs();" />
      <MemberSignature Language="F#" Value="static member GetCommandLineArgs : unit -&gt; string[]" Usage="System.Environment.GetCommandLineArgs " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Returns a string array containing the command-line arguments for the current process.</summary>
        <returns>An array of string where each element contains a command-line argument. The first element is the executable file name, and the following zero or more elements contain the remaining command-line arguments.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El primer elemento de la matriz contiene el nombre de archivo del programa en ejecución. Si el nombre de archivo no está disponible, el primer elemento es igual a <xref:System.String.Empty?displayProperty=nameWithType>. Los elementos restantes contienen tokens adicionales escritos en la línea de comandos.  
  
 El nombre de archivo del programa puede, pero no es necesario, incluir información de ruta de acceso.  
  
 Argumentos de línea de comandos están delimitados por espacios. Puede utilizar comillas dobles (") para incluir espacios dentro de un argumento. Sin embargo, la comilla simple ('), no proporciona esta funcionalidad.  
  
 Si un signo de comillas dobles sigue a dos o un número par de barras diagonales inversas, cada par de barra diagonal inversa continuar se reemplaza por una barra diagonal inversa y se quita el signo de comillas dobles. Si un signo de comillas dobles sigue a un número impar de barras diagonales inversas, incluidos solo uno, cada par anterior se reemplaza por una barra diagonal inversa y se quita la barra diagonal inversa restante; Sin embargo, en este caso el signo de comillas dobles no se quita.  
  
 En la tabla siguiente se muestra cómo pueden ser delimitada por los argumentos de línea de comandos y se da por supuesto `MyApp` como la aplicación de ejecución actual.  
  
|Entrada en la línea de comandos|Argumentos de línea de comandos resultante|  
|-------------------------------|--------------------------------------|  
|`MyApp alpha beta`|`MyApp, alpha, beta`|  
|`MyApp "alpha with spaces" "beta with spaces"`|`MyApp, alpha with spaces, beta with spaces`|  
|`MyApp 'alpha with spaces' beta`|`MyApp, 'alpha, with, spaces', beta`|  
|`MyApp \\\alpha \\\\"beta`|`MyApp, \\\alpha, \\beta`|  
|`MyApp \\\\\"alpha \"beta`|`MyApp, \\"alpha, "beta`|  
  
 Para obtener la línea de comandos como una cadena única, utilice el <xref:System.Environment.CommandLine%2A> propiedad.  
  
   
  
## Examples  
 El ejemplo siguiente muestra los argumentos de línea de comandos de la aplicación.  
  
 [!code-cpp[Environment.GetCommandLineArgs#1](~/samples/snippets/cpp/VS_Snippets_CLR/Environment.GetCommandLineArgs/CPP/getcommandlineargs.cpp#1)]
 [!code-csharp[Environment.GetCommandLineArgs#1](~/samples/snippets/csharp/VS_Snippets_CLR/Environment.GetCommandLineArgs/CS/getcommandlineargs.cs#1)]
 [!code-vb[Environment.GetCommandLineArgs#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Environment.GetCommandLineArgs/VB/getcommandlineargs.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">The system does not support command-line arguments.</exception>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission">Para obtener acceso de lectura a la variable de entorno PATH. Enumeración asociada: <see cref="F:System.Security.Permissions.EnvironmentPermissionAccess.Read" /></permission>
        <altmember cref="P:System.Environment.CommandLine" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetEnvironmentVariable">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Retrieves the value of an environment variable.</summary>
        <altmember cref="M:System.Environment.GetEnvironmentVariables" />
      </Docs>
    </MemberGroup>
    <Member MemberName="GetEnvironmentVariable">
      <MemberSignature Language="C#" Value="public static string GetEnvironmentVariable (string variable);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetEnvironmentVariable(string variable) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Environment.GetEnvironmentVariable(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetEnvironmentVariable (variable As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetEnvironmentVariable(System::String ^ variable);" />
      <MemberSignature Language="F#" Value="static member GetEnvironmentVariable : string -&gt; string" Usage="System.Environment.GetEnvironmentVariable variable" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="variable" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="variable">The name of the environment variable.</param>
        <summary>Retrieves the value of an environment variable from the current process.</summary>
        <returns>The value of the environment variable specified by <paramref name="variable" />, or <see langword="null" /> if the environment variable is not found.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Environment.GetEnvironmentVariable%28System.String%29> método recupera una variable de entorno desde el bloque de entorno del proceso actual únicamente. Es equivalente a llamar a la <xref:System.Environment.GetEnvironmentVariable%28System.String%2CSystem.EnvironmentVariableTarget%29> método con un `target` valo <xref:System.EnvironmentVariableTarget.Process?displayProperty=nameWithType>. El bloque de entorno del proceso actual incluye las siguientes variables de entorno:  
  
-   Todos por equipo variables de entorno que se definen en el momento de que crea el proceso, junto con sus valores.  
  
-   Todas las variables de entorno por usuario que se definen en el momento en el proceso se crea, junto con sus valores.  
  
-   Las variables que se agregará al bloque de proceso mientras se ejecuta el proceso mediante una llamada a la <xref:System.Environment.SetEnvironmentVariable%28System.String%2CSystem.String%29> método o la <xref:System.Environment.SetEnvironmentVariable%28System.String%2CSystem.String%2CSystem.EnvironmentVariableTarget%29> método con un `target` valor de <xref:System.EnvironmentVariableTarget.Process?displayProperty=nameWithType>.  
  
 Si las variables de entorno se crean después de que ha iniciado el proceso, puede utilizar este método para recuperar sólo aquellas variables que se crearon mediante una llamada a la <xref:System.Environment.SetEnvironmentVariable%28System.String%2CSystem.String%29> método o la <xref:System.Environment.SetEnvironmentVariable%28System.String%2CSystem.String%2CSystem.EnvironmentVariableTarget%29> método con un `target` valo.<xref:System.EnvironmentVariableTarget.Process?displayProperty=nameWithType>.  
  
 Para recuperar todas las variables de entorno junto con sus valores, llame a la <xref:System.Environment.GetEnvironmentVariables%2A> método.  
  
 Los nombres de variable de entorno no distinguen mayúsculas de minúsculas.  
  
   
  
## Examples  
 En el ejemplo siguiente se usa el <xref:System.Environment.GetEnvironmentVariable%2A> método para recuperar el `windir` variable de entorno, que contiene la ruta de acceso al directorio de Windows.  
  
 [!code-cpp[System.Environment#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Environment/CPP/Vars1.cpp#4)]
 [!code-csharp[System.Environment#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Environment/CS/Vars1.cs#4)]
 [!code-vb[System.Environment#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Environment/VB/Vars1.vb#4)]  
  
 En el ejemplo siguiente se intenta recuperar el valor de una variable de entorno denominada `Test1` desde el bloque de entorno del proceso. Si la variable no existe, el ejemplo se crea su y recupera su valor. En el ejemplo se muestra el valor de la variable. Si en el ejemplo se crea la variable, también llama el <xref:System.Environment.GetEnvironmentVariables%28System.EnvironmentVariableTarget%29> método con cada miembro de la <xref:System.EnvironmentVariableTarget> enumeración para establecer que la variable se puede recuperar sólo desde el bloque de entorno del proceso actual. Por último, si en el ejemplo se crea la variable, elimina.  
  
 [!code-csharp[System.Environment.GetEnvironmentVariable#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.environment.getenvironmentvariable/cs/getenvironmentvariableex1.cs#2)]
 [!code-vb[System.Environment.GetEnvironmentVariable#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.environment.getenvironmentvariable/vb/getenvironmentvariableex1.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="variable" /> is <see langword="null" />.</exception>
        <exception cref="T:System.Security.SecurityException">The caller does not have the required permission to perform this operation.</exception>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission">la capacidad de leer el valor de <paramref name="variable" />. Enumeración asociada: <see cref="F:System.Security.Permissions.EnvironmentPermissionAccess.Read" /></permission>
        <altmember cref="M:System.Environment.GetEnvironmentVariables" />
        <altmember cref="M:System.Environment.SetEnvironmentVariable(System.String,System.String)" />
        <altmember cref="T:System.EnvironmentVariableTarget" />
      </Docs>
    </Member>
    <Member MemberName="GetEnvironmentVariable">
      <MemberSignature Language="C#" Value="public static string GetEnvironmentVariable (string variable, EnvironmentVariableTarget target);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetEnvironmentVariable(string variable, valuetype System.EnvironmentVariableTarget target) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Environment.GetEnvironmentVariable(System.String,System.EnvironmentVariableTarget)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetEnvironmentVariable (variable As String, target As EnvironmentVariableTarget) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetEnvironmentVariable(System::String ^ variable, EnvironmentVariableTarget target);" />
      <MemberSignature Language="F#" Value="static member GetEnvironmentVariable : string * EnvironmentVariableTarget -&gt; string" Usage="System.Environment.GetEnvironmentVariable (variable, target)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="variable" Type="System.String" />
        <Parameter Name="target" Type="System.EnvironmentVariableTarget" />
      </Parameters>
      <Docs>
        <param name="variable">The name of an environment variable.</param>
        <param name="target">One of the <see cref="T:System.EnvironmentVariableTarget" /> values.</param>
        <summary>Retrieves the value of an environment variable from the current process or from the Windows operating system registry key for the current user or local machine.</summary>
        <returns>The value of the environment variable specified by the <paramref name="variable" /> and <paramref name="target" /> parameters, or <see langword="null" /> if the environment variable is not found.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El `target` parámetro especifica si la variable de entorno se recupera del proceso actual o de la clave de registro del sistema operativo Windows para el usuario actual o el equipo local. Todas las variables de entorno por usuario y por equipo se copian automáticamente en el bloque de entorno del proceso actual. Sin embargo, las variables de entorno agregadas solo para el bloque de entorno del proceso actual se conservan durante el proceso.  
  
 Para recuperar todas las variables de entorno junto con sus valores, llame a la <xref:System.Environment.GetEnvironmentVariables%2A> método.  
  
 Los nombres de variable de entorno no distinguen mayúsculas de minúsculas.  
  
   
  
## Examples  
 En el ejemplo siguiente se crean variables de entorno para los destinos de proceso, usuario y equipo, comprueba si el registro del sistema operativo contiene las variables de entorno de usuario y el equipo, a continuación, elimina de las variables de entorno.  
  
 [!code-cpp[environment.getsetenvar#1](~/samples/snippets/cpp/VS_Snippets_CLR/environment.getsetenvar/CPP/source.cpp#1)]
 [!code-csharp[environment.getsetenvar#1](~/samples/snippets/csharp/VS_Snippets_CLR/environment.getsetenvar/CS/gsev.cs#1)]
 [!code-vb[environment.getsetenvar#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/environment.getsetenvar/VB/gsev.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="variable" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="target" /> is not a valid <see cref="T:System.EnvironmentVariableTarget" /> value.</exception>
        <exception cref="T:System.Security.SecurityException">The caller does not have the required permission to perform this operation.</exception>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission">la capacidad de leer el valor de <paramref name="variable" /> si <paramref name="target" /> es <see cref="F:System.EnvironmentVariableTarget.Process" /> (enumeración asociada: <see cref="F:System.Security.Permissions.EnvironmentPermissionAccess.Read" />), o para tener acceso total a las variables de entorno si <paramref name="target" /> es <see cref="F:System.EnvironmentVariableTarget.User" /> o <see cref="F:System.EnvironmentVariableTarget.Machine" /> (asociados enumeración: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />).</permission>
        <altmember cref="M:System.Environment.SetEnvironmentVariable(System.String,System.String,System.EnvironmentVariableTarget)" />
        <altmember cref="M:System.Environment.GetEnvironmentVariables" />
        <altmember cref="T:System.EnvironmentVariableTarget" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetEnvironmentVariables">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Retrieves all environment variable names and their values.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetEnvironmentVariables">
      <MemberSignature Language="C#" Value="public static System.Collections.IDictionary GetEnvironmentVariables ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.IDictionary GetEnvironmentVariables() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Environment.GetEnvironmentVariables" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetEnvironmentVariables () As IDictionary" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Collections::IDictionary ^ GetEnvironmentVariables();" />
      <MemberSignature Language="F#" Value="static member GetEnvironmentVariables : unit -&gt; System.Collections.IDictionary" Usage="System.Environment.GetEnvironmentVariables " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IDictionary</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retrieves all environment variable names and their values from the current process.</summary>
        <returns>A dictionary that contains all environment variable names and their values; otherwise, an empty dictionary if no environment variables are found.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Los nombres y valores para las variables de entorno se almacenan como pares de clave y valor en el valor devuelto <xref:System.Collections.IDictionary>.  
  
   
  
## Examples  
 En el ejemplo siguiente se muestra el <xref:System.Environment.GetEnvironmentVariables%2A> método.  
  
 [!code-cpp[Environment.GetEnvironmentVariables#1](~/samples/snippets/cpp/VS_Snippets_CLR/Environment.GetEnvironmentVariables/CPP/getenvironmentvariables.cpp#1)]
 [!code-csharp[Environment.GetEnvironmentVariables#1](~/samples/snippets/csharp/VS_Snippets_CLR/Environment.GetEnvironmentVariables/CS/getenvironmentvariables.cs#1)]
 [!code-vb[Environment.GetEnvironmentVariables#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Environment.GetEnvironmentVariables/VB/getenvironmentvariables.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">The caller does not have the required permission to perform this operation.</exception>
        <exception cref="T:System.OutOfMemoryException">The buffer is out of memory.</exception>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission">la capacidad leer los nombres y valores de variables de entorno. Enumeración asociada: <see cref="F:System.Security.Permissions.EnvironmentPermissionAccess.Read" /></permission>
        <altmember cref="M:System.Environment.GetEnvironmentVariable(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="GetEnvironmentVariables">
      <MemberSignature Language="C#" Value="public static System.Collections.IDictionary GetEnvironmentVariables (EnvironmentVariableTarget target);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.IDictionary GetEnvironmentVariables(valuetype System.EnvironmentVariableTarget target) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Environment.GetEnvironmentVariables(System.EnvironmentVariableTarget)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetEnvironmentVariables (target As EnvironmentVariableTarget) As IDictionary" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Collections::IDictionary ^ GetEnvironmentVariables(EnvironmentVariableTarget target);" />
      <MemberSignature Language="F#" Value="static member GetEnvironmentVariables : EnvironmentVariableTarget -&gt; System.Collections.IDictionary" Usage="System.Environment.GetEnvironmentVariables target" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IDictionary</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.EnvironmentVariableTarget" />
      </Parameters>
      <Docs>
        <param name="target">One of the <see cref="T:System.EnvironmentVariableTarget" /> values.</param>
        <summary>Retrieves all environment variable names and their values from the current process, or from the Windows operating system registry key for the current user or local machine.</summary>
        <returns>A dictionary that contains all environment variable names and their values from the source specified by the <paramref name="target" /> parameter; otherwise, an empty dictionary if no environment variables are found.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El `target` parámetro especifica si el origen es el proceso actual, la clave del registro para el usuario actual o la clave del registro para el equipo local.  
  
 Los nombres y valores de las variables de entorno se almacenan como pares de clave/valor en el valor devuelto <xref:System.Collections.IDictionary> objeto.  
  
   
  
## Examples  
 En el ejemplo siguiente se crean variables de entorno para los destinos de proceso, usuario y equipo, comprueba si el registro del sistema operativo contiene las variables de entorno de usuario y el equipo, a continuación, elimina de las variables de entorno.  
  
 [!code-cpp[environment.getsetenvar#1](~/samples/snippets/cpp/VS_Snippets_CLR/environment.getsetenvar/CPP/source.cpp#1)]
 [!code-csharp[environment.getsetenvar#1](~/samples/snippets/csharp/VS_Snippets_CLR/environment.getsetenvar/CS/gsev.cs#1)]
 [!code-vb[environment.getsetenvar#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/environment.getsetenvar/VB/gsev.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">The caller does not have the required permission to perform this operation for the specified value of <paramref name="target" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="target" /> contains an illegal value.</exception>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission">la capacidad de leer los nombres y valores de variables de entorno si <paramref name="target" /> es <see cref="F:System.EnvironmentVariableTarget.Process" /> (enumeración asociada: <see cref="F:System.Security.Permissions.EnvironmentPermissionAccess.Read" />), o para tener acceso total a las variables de entorno si <paramref name="target" /> es <see cref="F:System.EnvironmentVariableTarget.User" /> o <see cref="F:System.EnvironmentVariableTarget.Machine" /> () Enumeración asociada: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />).</permission>
        <altmember cref="M:System.Environment.SetEnvironmentVariable(System.String,System.String,System.EnvironmentVariableTarget)" />
        <altmember cref="T:System.EnvironmentVariableTarget" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetFolderPath">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Gets the path to the system special folder that is identified by the specified enumeration.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetFolderPath">
      <MemberSignature Language="C#" Value="public static string GetFolderPath (Environment.SpecialFolder folder);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetFolderPath(valuetype System.Environment/SpecialFolder folder) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Environment.GetFolderPath(System.Environment.SpecialFolder)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetFolderPath (folder As Environment.SpecialFolder) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetFolderPath(Environment::SpecialFolder folder);" />
      <MemberSignature Language="F#" Value="static member GetFolderPath : Environment.SpecialFolder -&gt; string" Usage="System.Environment.GetFolderPath folder" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="folder" Type="System.Environment+SpecialFolder" />
      </Parameters>
      <Docs>
        <param name="folder">An enumerated constant that identifies a system special folder.</param>
        <summary>Gets the path to the system special folder that is identified by the specified enumeration.</summary>
        <returns>The path to the specified system special folder, if that folder physically exists on your computer; otherwise, an empty string ("").  A folder will not physically exist if the operating system did not create it, the existing folder was deleted, or the folder is a virtual directory, such as My Computer, which does not correspond to a physical path.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método recupera la ruta de acceso a una carpeta especial del sistema, como archivos de programa, programas, sistema o inicio, que puede utilizarse para tener acceso a información común. Carpetas especiales se establecen de forma predeterminada por el sistema o explícitamente por el usuario, al instalar una versión de Windows.  
  
 El `folder` parámetro designa la carpeta especial para recuperar y debe ser uno de los valores en el <xref:System.Environment.SpecialFolder> enumeración; en cualquier otro valor produce una excepción.  
  
 Para obtener más información acerca de las carpetas especiales, vea el [CSIDL](http://go.microsoft.com/fwlink/?LinkId=116664) tema de valores.  
  
   
  
## Examples  
 En el ejemplo siguiente se muestra cómo utilizar el <xref:System.Environment.GetFolderPath%2A> método para devolver y mostrar la ruta de acceso asociada a la `folder` parámetro.  
  
 [!code-cpp[Environment.GetFolderPath#1](~/samples/snippets/cpp/VS_Snippets_CLR/Environment.GetFolderPath/CPP/getfolderpath.cpp#1)]
 [!code-csharp[Environment.GetFolderPath#1](~/samples/snippets/csharp/VS_Snippets_CLR/Environment.GetFolderPath/CS/getfolderpath.cs#1)]
 [!code-vb[Environment.GetFolderPath#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Environment.GetFolderPath/VB/getfolderpath.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="folder" /> is not a member of <see cref="T:System.Environment.SpecialFolder" />.</exception>
        <exception cref="T:System.PlatformNotSupportedException">The current platform is not supported.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Para obtener acceso a la información de la ruta de acceso. Enumeración asociada: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
      </Docs>
    </Member>
    <Member MemberName="GetFolderPath">
      <MemberSignature Language="C#" Value="public static string GetFolderPath (Environment.SpecialFolder folder, Environment.SpecialFolderOption option);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetFolderPath(valuetype System.Environment/SpecialFolder folder, valuetype System.Environment/SpecialFolderOption option) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Environment.GetFolderPath(System.Environment.SpecialFolder,System.Environment.SpecialFolderOption)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetFolderPath (folder As Environment.SpecialFolder, option As Environment.SpecialFolderOption) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetFolderPath(Environment::SpecialFolder folder, Environment::SpecialFolderOption option);" />
      <MemberSignature Language="F#" Value="static member GetFolderPath : Environment.SpecialFolder * Environment.SpecialFolderOption -&gt; string" Usage="System.Environment.GetFolderPath (folder, option)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="folder" Type="System.Environment+SpecialFolder" />
        <Parameter Name="option" Type="System.Environment+SpecialFolderOption" />
      </Parameters>
      <Docs>
        <param name="folder">An enumerated constant that identifies a system special folder.</param>
        <param name="option">Specifies options to use for accessing a special folder.</param>
        <summary>Gets the path to the system special folder that is identified by the specified enumeration, and uses a specified option for accessing special folders.</summary>
        <returns>The path to the specified system special folder, if that folder physically exists on your computer; otherwise, an empty string ("").  A folder will not physically exist if the operating system did not create it, the existing folder was deleted, or the folder is a virtual directory, such as My Computer, which does not correspond to a physical path.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método recupera la ruta de acceso a una carpeta especial del sistema, como archivos de programa, programas, sistema o inicio, que puede utilizarse para tener acceso a información común. Carpetas especiales se establecen de forma predeterminada por el sistema o explícitamente por el usuario, al instalar una versión de Windows.  
  
 El `folder` parámetro designa la carpeta especial para recuperar y debe ser uno de los valores en el <xref:System.Environment.SpecialFolder> enumeración; en cualquier otro valor produce una excepción.  
  
 Para obtener más información acerca de las carpetas especiales, vea el [CSIDL](http://go.microsoft.com/fwlink/?LinkId=116664) tema de valores.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="folder" /> is not a member of <see cref="T:System.Environment.SpecialFolder" /></exception>
        <exception cref="T:System.PlatformNotSupportedException">
          <see cref="T:System.PlatformNotSupportedException" />
        </exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Para obtener acceso a la información de la ruta de acceso. Enumeración asociada: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
      </Docs>
    </Member>
    <Member MemberName="GetLogicalDrives">
      <MemberSignature Language="C#" Value="public static string[] GetLogicalDrives ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string[] GetLogicalDrives() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Environment.GetLogicalDrives" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetLogicalDrives () As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::String ^&gt; ^ GetLogicalDrives();" />
      <MemberSignature Language="F#" Value="static member GetLogicalDrives : unit -&gt; string[]" Usage="System.Environment.GetLogicalDrives " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Returns an array of string containing the names of the logical drives on the current computer.</summary>
        <returns>An array of strings where each element contains the name of a logical drive. For example, if the computer's hard drive is the first logical drive, the first element returned is "C:\\".</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 En el ejemplo siguiente se muestra cómo mostrar las unidades lógicas del equipo actual mediante el <xref:System.Environment.GetLogicalDrives%2A> método.  
  
 [!code-cpp[Environment.GetLogicalDrives#1](~/samples/snippets/cpp/VS_Snippets_CLR/Environment.GetLogicalDrives/CPP/getlogicaldrives.cpp#1)]
 [!code-csharp[Environment.GetLogicalDrives#1](~/samples/snippets/csharp/VS_Snippets_CLR/Environment.GetLogicalDrives/CS/getlogicaldrives.cs#1)]
 [!code-vb[Environment.GetLogicalDrives#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Environment.GetLogicalDrives/VB/getlogicaldrives.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">An I/O error occurs.</exception>
        <exception cref="T:System.Security.SecurityException">The caller does not have the required permissions.</exception>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission">para tener acceso total al recurso protegido por este permiso. Enumeración asociada: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></permission>
      </Docs>
    </Member>
    <Member MemberName="HasShutdownStarted">
      <MemberSignature Language="C#" Value="public static bool HasShutdownStarted { get; }" />
      <MemberSignature Language="ILAsm" Value=".property bool HasShutdownStarted" />
      <MemberSignature Language="DocId" Value="P:System.Environment.HasShutdownStarted" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property HasShutdownStarted As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool HasShutdownStarted { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.HasShutdownStarted : bool" Usage="System.Environment.HasShutdownStarted" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets a value that indicates whether the current application domain is being unloaded or the common language runtime (CLR) is shutting down.</summary>
        <value>Es <see langword="true" /> si se descarga el dominio de aplicación actual o el CLR se está cerrando; de lo contrario, es <see langword="false." />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cuando el CLR descarga un dominio de aplicación, se ejecuta los finalizadores en todos los objetos que tienen un método finalizador en ese dominio de aplicación. Cuando el CLR se cierra, se inicia el subproceso finalizador en todos los objetos que tienen un método finalizador. El <xref:System.Environment.HasShutdownStarted%2A> propiedad devuelve `true` solo después de que se ha iniciado el subproceso finalizador. Cuando se devuelve la propiedad `true`, puede determinar si se está descargando un dominio de aplicación o mediante una llamada a se está cerrando el CLR la <xref:System.AppDomain.IsFinalizingForUnload%2A?displayProperty=nameWithType> método. Este método devuelve `true` si se llaman a los finalizadores porque se está descargando el dominio de aplicación o `false` si CLR se está cerrando.  
  
 El <xref:System.Environment.HasShutdownStarted%2A> propiedad devuelve `false` si no se ha iniciado el subproceso finalizador.  
  
 Mediante esta propiedad, puede determinar si el acceso a las variables estáticas en el código de finalización. Si un dominio de aplicación o el CLR se está cerrando, no se puede tener acceso a cualquier objeto que tiene un método de finalización y al que se hace referencia a un campo estático forma confiable. Esto es porque estos objetos pueden ya ha finalizado.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.AppDomain.IsFinalizingForUnload" />
      </Docs>
    </Member>
    <Member MemberName="Is64BitOperatingSystem">
      <MemberSignature Language="C#" Value="public static bool Is64BitOperatingSystem { get; }" />
      <MemberSignature Language="ILAsm" Value=".property bool Is64BitOperatingSystem" />
      <MemberSignature Language="DocId" Value="P:System.Environment.Is64BitOperatingSystem" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property Is64BitOperatingSystem As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool Is64BitOperatingSystem { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.Is64BitOperatingSystem : bool" Usage="System.Environment.Is64BitOperatingSystem" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Determines whether the current operating system is a 64-bit operating system.</summary>
        <value>Es <see langword="true" /> si el sistema operativo es de 64 bits; de lo contrario, es <see langword="false" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Is64BitProcess">
      <MemberSignature Language="C#" Value="public static bool Is64BitProcess { get; }" />
      <MemberSignature Language="ILAsm" Value=".property bool Is64BitProcess" />
      <MemberSignature Language="DocId" Value="P:System.Environment.Is64BitProcess" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property Is64BitProcess As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool Is64BitProcess { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.Is64BitProcess : bool" Usage="System.Environment.Is64BitProcess" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Determines whether the current process is a 64-bit process.</summary>
        <value>Es <see langword="true" /> si el proceso es de 64 bits; de lo contrario, es <see langword="false" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MachineName">
      <MemberSignature Language="C#" Value="public static string MachineName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property string MachineName" />
      <MemberSignature Language="DocId" Value="P:System.Environment.MachineName" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property MachineName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::String ^ MachineName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.MachineName : string" Usage="System.Environment.MachineName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the NetBIOS name of this local computer.</summary>
        <value>Una cadena que contiene el nombre del equipo.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El nombre de este equipo se establece en el inicio del sistema cuando se lee el nombre del registro. Si este equipo es un nodo en un clúster, se devuelve el nombre del nodo.  
  
   
  
## Examples  
 En el ejemplo siguiente se muestra el nombre del equipo que ejecuta el ejemplo de código. (El nombre del equipo se omite del resultado del ejemplo por razones de seguridad).  
  
 [!code-cpp[environment.machinename#1](~/samples/snippets/cpp/VS_Snippets_CLR/Environment.MachineName/CPP/machinename.cpp#1)]
 [!code-csharp[environment.machinename#1](~/samples/snippets/csharp/VS_Snippets_CLR/Environment.MachineName/CS/machinename.cs#1)]
 [!code-vb[environment.machinename#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Environment.MachineName/VB/machinename.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">The name of this computer cannot be obtained.</exception>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission">Para obtener acceso de lectura a la variable de entorno COMPUTERNAME. Enumeración asociada: <see cref="F:System.Security.Permissions.EnvironmentPermissionAccess.Read" /></permission>
      </Docs>
    </Member>
    <Member MemberName="NewLine">
      <MemberSignature Language="C#" Value="public static string NewLine { get; }" />
      <MemberSignature Language="ILAsm" Value=".property string NewLine" />
      <MemberSignature Language="DocId" Value="P:System.Environment.NewLine" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property NewLine As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::String ^ NewLine { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.NewLine : string" Usage="System.Environment.NewLine" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the newline string defined for this environment.</summary>
        <value>Una cadena que contiene "\r\n" para las plataformas que no son Unix o una cadena que contiene "\n" para las plataformas Unix.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El valor de propiedad <xref:System.Environment.NewLine%2A> es una constante personalizada específicamente para la plataforma actual y la implementación de .NET Framework. Para obtener más información acerca de los caracteres de escape en el valor de propiedad, vea [Escapes de carácter](~/docs/standard/base-types/character-escapes-in-regular-expressions.md).  
  
 La funcionalidad proporcionada por <xref:System.Environment.NewLine%2A> a menudo es lo que significan los términos nueva, avance de línea, salto de línea, retorno de carro, CRLF y final de línea.  
  
 <xref:System.Environment.NewLine%2A> puede utilizarse junto con el soporte técnico de nueva línea específica del lenguaje, como los caracteres de escape '\r' y '\n' en Microsoft C# y C o C++, o `vbCrLf` en Microsoft Visual Basic.  
  
 <xref:System.Environment.NewLine%2A> automáticamente se anexará al texto que procesan la <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> y <xref:System.Text.StringBuilder.AppendLine%2A?displayProperty=nameWithType> métodos.  
  
   
  
## Examples  
 En el ejemplo siguiente se muestra tres líneas separadas por líneas nuevas.  
  
 [!code-cpp[environment.newline#1](~/samples/snippets/cpp/VS_Snippets_CLR/Environment.NewLine/CPP/newline.cpp#1)]
 [!code-csharp[environment.newline#1](~/samples/snippets/csharp/VS_Snippets_CLR/Environment.NewLine/CS/newline.cs#1)]
 [!code-vb[environment.newline#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Environment.NewLine/VB/newline.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OSVersion">
      <MemberSignature Language="C#" Value="public static OperatingSystem OSVersion { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.OperatingSystem OSVersion" />
      <MemberSignature Language="DocId" Value="P:System.Environment.OSVersion" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property OSVersion As OperatingSystem" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property OperatingSystem ^ OSVersion { OperatingSystem ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.OSVersion : OperatingSystem" Usage="System.Environment.OSVersion" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.OperatingSystem</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets an <see cref="T:System.OperatingSystem" /> object that contains the current platform identifier and version number.</summary>
        <value>Un objeto que contiene el identificador de la plataforma y el número de versión.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  A partir de Windows 8, el <xref:System.Environment.OSVersion%2A> propiedad devuelve los mismos números de versión principal y secundaria para todas las plataformas de Windows. Por lo tanto, no se recomienda que recuperar el valor de esta propiedad para determinar la versión del sistema operativo.  
  
 Normalmente, el <xref:System.Environment.OSVersion%2A> propiedad se utiliza para garantizar que una aplicación se está ejecutando en alguna versión de base de un sistema operativo en el que se introdujo una característica determinada. Cuando esto ocurre, debe realizar una comprobación de versión comprobando si la versión actual del sistema operativo devuelto por la <xref:System.Environment.OSVersion%2A> propiedad es igual, o mayor que la versión de sistema operativo base. Para obtener más información, consulte el <xref:System.Version> tema de la clase.  
  
 A través de Windows 8, el <xref:System.Environment.OSVersion%2A> propiedad devuelve la versión indicada por las ventanas [GetVersionEx](http://msdn.microsoft.com/library/windows/desktop/ms724451\(v=vs.85\).aspx) función. Para obtener una lista de versiones de sistema operativo de escritorio de Windows y sus números de versión correspondientes, vea [versión del sistema operativo](https://msdn.microsoft.com/library/windows/desktop/ms724832.aspx) en el centro de desarrollo de Windows.  
  
> [!NOTE]
>  El <xref:System.Environment.OSVersion%2A> propiedad notifica el mismo número de versión (6.2.0.0) para ambos [!INCLUDE[win8](~/includes/win8-md.md)] y [!INCLUDE[win81](~/includes/win81-md.md)] y el mismo número de versión principal y secundaria para Windows 10.  
  
 En algunos casos, la <xref:System.Environment.OSVersion%2A> propiedad no puede devolver la versión de sistema operativo que coincide con la versión especificada para la característica de modo de compatibilidad de programas de Windows.  
  
   
  
## Examples  
 En el ejemplo siguiente se muestra el identificador de plataforma y el número de versión del equipo que ejecuta el ejemplo de código.  
  
 [!code-cpp[environment.osversion#1](~/samples/snippets/cpp/VS_Snippets_CLR/Environment.OSVersion/CPP/osversion.cpp#1)]
 [!code-csharp[environment.osversion#1](~/samples/snippets/csharp/VS_Snippets_CLR/Environment.OSVersion/CS/osversion.cs#1)]
 [!code-vb[environment.osversion#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Environment.OSVersion/VB/osversion.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">This property was unable to obtain the system version.  -or-  The obtained platform identifier is not a member of <see cref="T:System.PlatformID" /></exception>
      </Docs>
    </Member>
    <Member MemberName="ProcessorCount">
      <MemberSignature Language="C#" Value="public static int ProcessorCount { get; }" />
      <MemberSignature Language="ILAsm" Value=".property int32 ProcessorCount" />
      <MemberSignature Language="DocId" Value="P:System.Environment.ProcessorCount" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property ProcessorCount As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property int ProcessorCount { int get(); };" />
      <MemberSignature Language="F#" Value="member this.ProcessorCount : int" Usage="System.Environment.ProcessorCount" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the number of processors on the current machine.</summary>
        <value>Un entero con signo de 32 bits que especifica el número de procesadores de la máquina actual. No existe ningún valor predeterminado. Si la máquina actual contiene varios grupos de procesador, esta propiedad devuelve el número de procesadores lógicos disponibles para el uso por parte de Common Language Runtime (CLR).</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para obtener más información acerca de grupos de procesadores y los procesadores lógicos, consulte [grupos de procesadores](http://msdn.microsoft.com/library/windows/desktop/dd405503.aspx).  
  
   
  
## Examples  
 En el ejemplo siguiente se muestra el <xref:System.Environment.ProcessorCount%2A> propiedad.  
  
 [!code-cpp[environment.processorcount#1](~/samples/snippets/cpp/VS_Snippets_CLR/environment.processorcount/CPP/pc.cpp#1)]
 [!code-csharp[environment.processorcount#1](~/samples/snippets/csharp/VS_Snippets_CLR/environment.processorcount/CS/pc.cs#1)]
 [!code-vb[environment.processorcount#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/environment.processorcount/VB/pc.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="SetEnvironmentVariable">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Creates, modifies, or deletes an environment variable.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SetEnvironmentVariable">
      <MemberSignature Language="C#" Value="public static void SetEnvironmentVariable (string variable, string value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetEnvironmentVariable(string variable, string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Environment.SetEnvironmentVariable(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetEnvironmentVariable (variable As String, value As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetEnvironmentVariable(System::String ^ variable, System::String ^ value);" />
      <MemberSignature Language="F#" Value="static member SetEnvironmentVariable : string * string -&gt; unit" Usage="System.Environment.SetEnvironmentVariable (variable, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="variable" Type="System.String" />
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="variable">The name of an environment variable.</param>
        <param name="value">A value to assign to <c>variable</c>.</param>
        <summary>Creates, modifies, or deletes an environment variable stored in the current process.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Llamar a este método equivale a llamar a la <xref:System.Environment.SetEnvironmentVariable%28System.String%2CSystem.String%2CSystem.EnvironmentVariableTarget%29> sobrecarga con un valor de <xref:System.EnvironmentVariableTarget.Process?displayProperty=nameWithType> para el `target` argumento.  
  
 Si el `value` argumento no está vacío (vea la explicación de la eliminación de una variable de entorno más adelante en esta sección para obtener la definición de un valor vacío) y la variable de entorno denominada por la `variable` no existe el parámetro, el entorno se crea y se asigna el contenido de la variable `value`. Si existe, se modifica su valor. Dado que la variable de entorno se define en el bloque de entorno del proceso actual solo, no se conserva una vez finalizado el proceso.  
  
 Si `variable` contiene un hexadecimal inicial no son caracteres de cero, los caracteres antes de que el carácter cero se consideran el nombre de variable de entorno y se omiten todos los caracteres siguientes.  
  
 Si `value` contiene un hexadecimal inicial no son caracteres de cero, los caracteres antes de que el carácter cero se asignan a la variable de entorno y se omiten todos los caracteres siguientes.  
  
 Si `value` está vacía y la variable de entorno denominada por `variable` existe, se elimina la variable de entorno. Si `variable` no existe, se produce ningún error aunque no se puede realizar la operación. `value` se considera vacío en cualquiera de las condiciones siguientes:  
  
-   Es `null`.  
  
-   Es <xref:System.String.Empty?displayProperty=nameWithType>.  
  
-   Consta de un solo carácter cuyo valor es u+0000.  
  
   
  
## Examples  
 En el ejemplo siguiente se comprueba si una variable de entorno denominada `APPDOMAIN` existe en el proceso actual. Si no es así, lo crea y establece su valor en "True". Si el valor de la `APPDOMAIN` variable de entorno es "True", llama a la `Message.Display` método en un nuevo dominio de aplicación. En caso contrario, ejecuta el `Message.Display` método en el dominio de aplicación actual.  
  
 [!code-csharp[System.Environment.SetEnvironmentVariable#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.environment.setenvironmentvariable/cs/setenvironmentvariable1.cs#1)]
 [!code-vb[System.Environment.SetEnvironmentVariable#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.environment.setenvironmentvariable/vb/setenvironmentvariable1.vb#1)]  
  
 Si ejecuta el ejemplo por primera vez, muestra el mensaje "Ejecutándose en el dominio dominio2" en la consola. Si establece la variable de entorno desde la línea de comandos mediante el comando:  
  
 `Set AppDomain=False`  
  
 en el ejemplo se muestra el mensaje "ejecutar en el dominio *ejecutable*.exe", donde *ejecutable* es el nombre del archivo ejecutable.  
  
 En el ejemplo siguiente se intenta recuperar el valor de una variable de entorno denominada `Test1` desde el bloque de entorno del proceso. Si la variable no existe, el ejemplo crea la variable y recupera su valor. En el ejemplo se muestra el valor de la variable. Si en el ejemplo se crea la variable, también llama el <xref:System.Environment.GetEnvironmentVariables%28System.EnvironmentVariableTarget%29> método con cada miembro de la <xref:System.EnvironmentVariableTarget> enumeración para establecer que la variable se puede recuperar sólo desde el bloque de entorno del proceso actual. Por último, si en el ejemplo se crea la variable, elimina.  
  
 [!code-csharp[System.Environment.GetEnvironmentVariable#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.environment.getenvironmentvariable/cs/getenvironmentvariableex1.cs#2)]
 [!code-vb[System.Environment.GetEnvironmentVariable#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.environment.getenvironmentvariable/vb/getenvironmentvariableex1.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="variable" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="variable" /> contains a zero-length string, an initial hexadecimal zero character (0x00), or an equal sign ("=").  -or-  The length of <paramref name="variable" /> or <paramref name="value" /> is greater than or equal to 32,767 characters.  -or-  An error occurred during the execution of this operation.</exception>
        <exception cref="T:System.Security.SecurityException">The caller does not have the required permission to perform this operation.</exception>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission">Para obtener acceso completo a las variables de entorno. Enumeración asociada: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></permission>
        <altmember cref="M:System.Environment.GetEnvironmentVariable(System.String)" />
        <altmember cref="M:System.Environment.GetEnvironmentVariables" />
      </Docs>
    </Member>
    <Member MemberName="SetEnvironmentVariable">
      <MemberSignature Language="C#" Value="public static void SetEnvironmentVariable (string variable, string value, EnvironmentVariableTarget target);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetEnvironmentVariable(string variable, string value, valuetype System.EnvironmentVariableTarget target) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Environment.SetEnvironmentVariable(System.String,System.String,System.EnvironmentVariableTarget)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetEnvironmentVariable (variable As String, value As String, target As EnvironmentVariableTarget)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetEnvironmentVariable(System::String ^ variable, System::String ^ value, EnvironmentVariableTarget target);" />
      <MemberSignature Language="F#" Value="static member SetEnvironmentVariable : string * string * EnvironmentVariableTarget -&gt; unit" Usage="System.Environment.SetEnvironmentVariable (variable, value, target)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="variable" Type="System.String" />
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="target" Type="System.EnvironmentVariableTarget" />
      </Parameters>
      <Docs>
        <param name="variable">The name of an environment variable.</param>
        <param name="value">A value to assign to <c>variable</c>.</param>
        <param name="target">One of the enumeration values that specifies the location of the environment variable.</param>
        <summary>Creates, modifies, or deletes an environment variable stored in the current process or in the Windows operating system registry key reserved for the current user or local machine.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Environment.SetEnvironmentVariable%28System.String%2CSystem.String%2CSystem.EnvironmentVariableTarget%29> método le permite definir una variable de entorno que está disponible para todos los procesos que se ejecutan en un equipo (el <xref:System.EnvironmentVariableTarget.Machine?displayProperty=nameWithType> valor), a todos los procesos que se ejecutan por un usuario (el <xref:System.EnvironmentVariableTarget.User?displayProperty=nameWithType> valor), o para el proceso actual (la <xref:System.EnvironmentVariableTarget.Process> valor). Las variables de entorno por usuario y por equipo se copian en el bloque de entorno del proceso actual. Sin embargo, las variables de entorno que son únicas para el bloque de entorno del proceso actual se conservan solo hasta que finaliza el proceso.  
  
 Si el `value` argumento no está vacío (vea la explicación de la eliminación de una variable de entorno más adelante en esta sección para obtener la definición de un valor vacío) y la variable de entorno denominada por la `variable` no existe el parámetro, el entorno se crea y se asigna el contenido de la variable `value`.  Si existe, se modifica su valor.  
  
 Si `variable` contiene un hexadecimal inicial no son caracteres de cero, los caracteres antes de que el carácter cero se consideran el nombre de variable de entorno y se omiten todos los caracteres siguientes.  
  
 Si `value` contiene un hexadecimal inicial no son caracteres de cero, los caracteres antes de que el carácter cero se asignan a la variable de entorno y se omiten todos los caracteres siguientes.  
  
 Si `value` está vacía y la variable de entorno denominada por `variable` existe, se elimina la variable de entorno. `value` se considera vacío en cualquiera de las condiciones siguientes:  
  
-   Es `null`.  
  
-   Es <xref:System.String.Empty?displayProperty=nameWithType>.  
  
-   Consta de un solo carácter cuyo valor es u+0000.  
  
 Si `variable` no existe, se produce ningún error aunque no se puede realizar la operación. Tenga cuidado cuando `target` es <xref:System.EnvironmentVariableTarget.Machine>, ya que puede eliminar accidentalmente una variable de entorno que afecte a todo el equipo local, no solo el proceso actual o el usuario.  
  
 Si `target` es <xref:System.EnvironmentVariableTarget.User>, la variable de entorno se almacena en la clave HKEY_CURRENT_USER\Environment del registro del equipo local. También se copia a las instancias del explorador de archivos que se ejecutan como el usuario actual. La variable de entorno, es heredada por los nuevos procesos que inicia el usuario del explorador de archivos.  
  
 De forma similar, si `target` es <xref:System.EnvironmentVariableTarget.Machine?displayProperty=nameWithType>, la variable de entorno se almacena en la clave HKEY_LOCAL_MACHINE\SYSTEM\ControlSet001\Control\Session Manager\Environment del registro del equipo local. También se copia a todas las instancias del explorador de archivos. La variable de entorno, es heredada por los nuevos procesos que se abren desde el Explorador de archivos.  
  
 Si `target` es <xref:System.EnvironmentVariableTarget.User> o <xref:System.EnvironmentVariableTarget.Machine>, otras aplicaciones están por una notificación de la operación de establecimiento Windows `WM_SETTINGCHANGE` mensaje.  
  
 Si `target` es <xref:System.EnvironmentVariableTarget.User?displayProperty=nameWithType> o <xref:System.EnvironmentVariableTarget.Machine?displayProperty=nameWithType>, se recomienda que la longitud de `value` tener menos de 2048 caracteres.  
  
   
  
## Examples  
 En el ejemplo siguiente se crea variables de entorno para la <xref:System.EnvironmentVariableTarget.Process?displayProperty=nameWithType>, <xref:System.EnvironmentVariableTarget.User?displayProperty=nameWithType>, y <xref:System.EnvironmentVariableTarget.Machine> tiene como destino, comprueba si el registro del sistema operativo contiene el usuario y las variables de entorno del equipo, a continuación, elimina el entorno variables.  
  
 [!code-cpp[environment.getsetenvar#1](~/samples/snippets/cpp/VS_Snippets_CLR/environment.getsetenvar/CPP/source.cpp#1)]
 [!code-csharp[environment.getsetenvar#1](~/samples/snippets/csharp/VS_Snippets_CLR/environment.getsetenvar/CS/gsev.cs#1)]
 [!code-vb[environment.getsetenvar#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/environment.getsetenvar/VB/gsev.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="variable" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="variable" /> contains a zero-length string, an initial hexadecimal zero character (0x00), or an equal sign ("=").  -or-  The length of <paramref name="variable" /> is greater than or equal to 32,767 characters.  -or-  <paramref name="target" /> is not a member of the <see cref="T:System.EnvironmentVariableTarget" /> enumeration.  -or-  <paramref name="target" /> is <see cref="F:System.EnvironmentVariableTarget.Machine" /> or <see cref="F:System.EnvironmentVariableTarget.User" />, and the length of <paramref name="variable" /> is greater than or equal to 255.  -or-  <paramref name="target" /> is <see cref="F:System.EnvironmentVariableTarget.Process" /> and the length of <paramref name="value" /> is greater than or equal to 32,767 characters.  -or-  An error occurred during the execution of this operation.</exception>
        <exception cref="T:System.Security.SecurityException">The caller does not have the required permission to perform this operation.</exception>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission">Para obtener acceso completo a las variables de entorno. Enumeración asociada: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></permission>
        <altmember cref="M:System.Environment.GetEnvironmentVariable(System.String,System.EnvironmentVariableTarget)" />
        <altmember cref="M:System.Environment.GetEnvironmentVariables(System.EnvironmentVariableTarget)" />
        <altmember cref="T:System.EnvironmentVariableTarget" />
      </Docs>
    </Member>
    <Member MemberName="StackTrace">
      <MemberSignature Language="C#" Value="public static string StackTrace { get; }" />
      <MemberSignature Language="ILAsm" Value=".property string StackTrace" />
      <MemberSignature Language="DocId" Value="P:System.Environment.StackTrace" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property StackTrace As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::String ^ StackTrace { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.StackTrace : string" Usage="System.Environment.StackTrace" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets current stack trace information.</summary>
        <value>Cadena que contiene información acerca del seguimiento de la pila. Este valor puede ser <see cref="F:System.String.Empty" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Environment.StackTrace%2A> listas de propiedades de llamadas a métodos en orden cronológico inverso, es decir, la llamada al método más reciente se describe en primer lugar y aparece una línea de información de seguimiento de pila para cada llamada de método en la pila. Sin embargo, la <xref:System.Environment.StackTrace%2A> propiedad podría no informar de tantas llamadas a métodos tal y como se esperaba debido a las transformaciones de código que se producen durante la optimización.  
  
> [!NOTE]
>  Para obtener una vista jerárquica de la información de seguimiento de pila por clase, use la <xref:System.Diagnostics.StackTrace> clase.  
  
 El <xref:System.Environment.StackTrace%2A> propiedad da formato a la información de seguimiento de pila para cada llamada al método como sigue:  
  
 "en `FullClassName`.`MethodName` (`MethodParams`) en `FileName` : línea `LineNumber` "  
  
 El literal "arroba" va precedido de tres espacios y toda la subcadena a partir de "in" se omite si los símbolos de depuración no están disponibles. Los marcadores de posición, `FullClassName`, `MethodName`, `MethodParams`, `FileName`, y `LineNumber`, se reemplazan por valores reales y se definen como sigue:  
  
 FullClassName  
 El nombre completo de la clase, incluido el espacio de nombres.  
  
 `MethodName`  
 Nombre del método.  
  
 `MethodParams`  
 La lista de pares de nombre/tipo de parámetro. Cada par se separa por una coma (","). Esta información se omite si `MethodName` no toma ningún parámetro.  
  
 `FileName`  
 El nombre del origen de archivo donde el `MethodName` se declara el método. Esta información se omite si los símbolos de depuración no están disponibles.  
  
 `LineNumber`  
 El número de la línea en `FileName` que contiene el código fuente de `MethodName` para que la instrucción que se encuentra en la pila de llamadas. Esta información se omite si los símbolos de depuración no están disponibles.  
  
 El <xref:System.Environment.NewLine%2A?displayProperty=nameWithType> cadena finaliza cada línea del seguimiento de pila.  
  
   
  
## Examples  
 En el ejemplo siguiente se muestra el <xref:System.Environment.StackTrace%2A> propiedad.  
  
 [!code-cpp[environment.stacktrace#1](~/samples/snippets/cpp/VS_Snippets_CLR/Environment.StackTrace/CPP/stacktrace.cpp#1)]
 [!code-csharp[environment.stacktrace#1](~/samples/snippets/csharp/VS_Snippets_CLR/Environment.StackTrace/CS/stacktrace.cs#1)]
 [!code-vb[environment.stacktrace#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Environment.StackTrace/VB/stacktrace.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission">para tener acceso total al recurso protegido por el permiso. Enumeración asociada: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></permission>
      </Docs>
    </Member>
    <Member MemberName="SystemDirectory">
      <MemberSignature Language="C#" Value="public static string SystemDirectory { get; }" />
      <MemberSignature Language="ILAsm" Value=".property string SystemDirectory" />
      <MemberSignature Language="DocId" Value="P:System.Environment.SystemDirectory" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property SystemDirectory As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::String ^ SystemDirectory { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.SystemDirectory : string" Usage="System.Environment.SystemDirectory" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the fully qualified path of the system directory.</summary>
        <value>Una cadena que contiene la ruta de acceso de un directorio.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un ejemplo de valor devuelto es la cadena "C:\WinNT\System32".  
  
   
  
## Examples  
 En el ejemplo siguiente se muestra el directorio del sistema del equipo que ejecuta el ejemplo de código. (El directorio del sistema se omite del resultado del ejemplo por razones de seguridad).  
  
 [!code-cpp[environment.systemdirectory#1](~/samples/snippets/cpp/VS_Snippets_CLR/Environment.SystemDirectory/CPP/systemdirectory.cpp#1)]
 [!code-csharp[environment.systemdirectory#1](~/samples/snippets/csharp/VS_Snippets_CLR/Environment.SystemDirectory/CS/systemdirectory.cs#1)]
 [!code-vb[environment.systemdirectory#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Environment.SystemDirectory/VB/systemdirectory.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Para obtener acceso a la información de la ruta de acceso. Enumeración asociada: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
      </Docs>
    </Member>
    <Member MemberName="SystemPageSize">
      <MemberSignature Language="C#" Value="public static int SystemPageSize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property int32 SystemPageSize" />
      <MemberSignature Language="DocId" Value="P:System.Environment.SystemPageSize" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property SystemPageSize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property int SystemPageSize { int get(); };" />
      <MemberSignature Language="F#" Value="member this.SystemPageSize : int" Usage="System.Environment.SystemPageSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the number of bytes in the operating system's memory page.</summary>
        <value>Número de bytes en una página de memoria del sistema.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esta información puede ser útil al determinar si se debe usar el <xref:System.IO.MemoryMappedFiles.MemoryMappedFileOptions.DelayAllocatePages?displayProperty=nameWithType> opción cuando se trabaja con archivos asignados a memoria.  
  
 En Windows, este valor es el `dwPageSize` miembro en el `SYSTEM_INFO` estructura.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission">Para obtener acceso a variables de entorno de usuario y del sistema. Excepción asociada:  <see cref="P:System.Security.SecurityException.PermissionState" /></permission>
      </Docs>
    </Member>
    <Member MemberName="TickCount">
      <MemberSignature Language="C#" Value="public static int TickCount { get; }" />
      <MemberSignature Language="ILAsm" Value=".property int32 TickCount" />
      <MemberSignature Language="DocId" Value="P:System.Environment.TickCount" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property TickCount As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property int TickCount { int get(); };" />
      <MemberSignature Language="F#" Value="member this.TickCount : int" Usage="System.Environment.TickCount" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the number of milliseconds elapsed since the system started.</summary>
        <value>Un entero de 32 bits que contiene el tiempo en milisegundos que transcurrió desde la última vez que se inició el equipo.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El valor de esta propiedad se deriva del reloj del sistema y se almacena como un entero de 32 bits con signo. Tenga en cuenta que, dado que se deriva del reloj del sistema, la resolución de la <xref:System.Environment.TickCount%2A> propiedad está limitada a la resolución del temporizador del sistema, que normalmente está en el intervalo de 10 y 16 milisegundos.  
  
> [!IMPORTANT]
>  Dado que el valor de la <xref:System.Environment.TickCount%2A> valor de propiedad es un entero con signo de 32 bits, si el sistema se ejecuta continuamente, <xref:System.Environment.TickCount%2A> aumentará de cero a <xref:System.Int32.MaxValue?displayProperty=nameWithType> en aproximadamente 24,9 días, a continuación, pasar a <xref:System.Int32.MinValue?displayProperty=nameWithType>, que es un número negativo, a continuación, aumentar hasta cero durante los siguientes 24,9 días. Puede solucionar este problema mediante una llamada a las ventanas [GetTickCount](https://msdn.microsoft.com/library/windows/desktop/ms724408.aspx) función, que se restablece en cero después de aproximadamente 49,7 días, o mediante una llamada a la [GetTickCount64](https://msdn.microsoft.com/library/windows/desktop/ms724411.aspx) (función).  
  
 <xref:System.Environment.TickCount%2A> es diferente de la <xref:System.DateTime.Ticks%2A?displayProperty=nameWithType> propiedad, que es el número de intervalos de 100 nanosegundos transcurridos desde el 1/1/0001, 12:00 am.  
  
 Use la <xref:System.DateTime.Now%2A?displayProperty=nameWithType> propiedad que se va a obtener la actual fecha y hora local en este equipo.  
  
   
  
## Examples  
 En el ejemplo siguiente se muestra cómo recuperar el intervalo positivo de valores devueltos por la <xref:System.Environment.TickCount%2A> propiedad. El <xref:System.Environment.TickCount%2A> entre los ciclos de propiedad <xref:System.Int32.MinValue?displayProperty=nameWithType>, que es un número negativo, y <xref:System.Int32.MaxValue?displayProperty=nameWithType> cada 49,8 días. Este ejemplo de código quita el bit de signo para producir un número no negativo que ciclos entre cero y <xref:System.Int32.MaxValue> cada 24,9 días.  
  
 [!code-cpp[environment.tickcount#1](~/samples/snippets/cpp/VS_Snippets_CLR/Environment.TickCount/CPP/tickcount.cpp#1)]
 [!code-csharp[environment.tickcount#1](~/samples/snippets/csharp/VS_Snippets_CLR/Environment.TickCount/CS/tickcount.cs#1)]
 [!code-vb[environment.tickcount#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Environment.TickCount/VB/tickcount.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UserDomainName">
      <MemberSignature Language="C#" Value="public static string UserDomainName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property string UserDomainName" />
      <MemberSignature Language="DocId" Value="P:System.Environment.UserDomainName" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property UserDomainName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::String ^ UserDomainName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.UserDomainName : string" Usage="System.Environment.UserDomainName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the network domain name associated with the current user.</summary>
        <value>El nombre de dominio de red asociado al usuario actual.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Las credenciales de cuenta de dominio para un usuario con el formato de nombre de dominio del usuario, el '\\' nombre de usuario y de caracteres. Use la <xref:System.Environment.UserDomainName%2A> propiedad que se va a obtener el nombre de dominio del usuario sin el nombre de usuario y la <xref:System.Environment.UserName%2A> propiedad para obtener el nombre de usuario sin el nombre de dominio.  Por ejemplo, si un usuario nombre de dominio y nombre de usuario son CORPORATENETWORK\john, la <xref:System.Environment.UserDomainName%2A> propiedad devuelve "CORPORATENETWORK".  
  
 El <xref:System.Environment.UserDomainName%2A> propiedad primero intenta obtener el componente de nombre de dominio del nombre de cuenta de Windows del usuario actual. Si no lo consigue, esta propiedad intenta obtener el nombre de dominio asociado con el nombre de usuario proporcionado por el <xref:System.Environment.UserName%2A> propiedad. Si ese intento no tiene éxito porque el equipo host no está unido a un dominio, se devuelve el nombre del equipo host.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">The operating system does not support retrieving the network domain name.</exception>
        <exception cref="T:System.InvalidOperationException">The network domain name cannot be retrieved.</exception>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission">Para obtener acceso de lectura a la variable de entorno USERDOMAIN. Enumeración asociada: <see cref="F:System.Security.Permissions.EnvironmentPermissionAccess.Read" /></permission>
        <altmember cref="P:System.Environment.UserName" />
      </Docs>
    </Member>
    <Member MemberName="UserInteractive">
      <MemberSignature Language="C#" Value="public static bool UserInteractive { get; }" />
      <MemberSignature Language="ILAsm" Value=".property bool UserInteractive" />
      <MemberSignature Language="DocId" Value="P:System.Environment.UserInteractive" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property UserInteractive As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool UserInteractive { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.UserInteractive : bool" Usage="System.Environment.UserInteractive" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets a value indicating whether the current process is running in user interactive mode.</summary>
        <value>Es <see langword="true" /> si el proceso actual se ejecuta en modo de interacción con el usuario; en caso contrario, es <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Environment.UserInteractive%2A> propiedad informes `false` para un proceso de Windows o un servicio como IIS que se ejecuta sin una interfaz de usuario. Si esta propiedad es `false`, no se muestran cuadros de diálogo modales o cuadros de mensaje porque no hay ninguna interfaz gráfica de usuario para el usuario interactuar con.  
  
   
  
## Examples  
 En el ejemplo siguiente se muestra si el proceso actual se ejecuta en modo interactivo de usuario.  
  
 [!code-cpp[Environment.UserInteractive#1](~/samples/snippets/cpp/VS_Snippets_CLR/Environment.UserInteractive/CPP/userinteractive.cpp#1)]
 [!code-csharp[Environment.UserInteractive#1](~/samples/snippets/csharp/VS_Snippets_CLR/Environment.UserInteractive/CS/userinteractive.cs#1)]
 [!code-vb[Environment.UserInteractive#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Environment.UserInteractive/VB/userinteractive.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Forms.SystemInformation" />
      </Docs>
    </Member>
    <Member MemberName="UserName">
      <MemberSignature Language="C#" Value="public static string UserName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property string UserName" />
      <MemberSignature Language="DocId" Value="P:System.Environment.UserName" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property UserName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::String ^ UserName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.UserName : string" Usage="System.Environment.UserName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the user name of the person who is currently logged on to the operating system.</summary>
        <value>El nombre de usuario de la persona que ha iniciado sesión en el sistema operativo.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Puede usar el <xref:System.Environment.UserName%2A> propiedad para identificar al usuario en el subproceso actual, el sistema y la aplicación para fines de seguridad o de acceso. También se puede utilizar para personalizar una aplicación determinada para cada usuario.  
 
 En Windows el <xref:System.Environment.UserName%2A> propiedad contiene una llamada a las ventanas [GetUserName](http://msdn.microsoft.com/library/windows/desktop/ms724432.aspx) función. Las credenciales de cuenta de dominio para un usuario con el formato de nombre de dominio del usuario, el '\\' nombre de usuario y de caracteres. Use la <xref:System.Environment.UserDomainName%2A> propiedad que se va a obtener el nombre de dominio del usuario y la <xref:System.Environment.UserName%2A> propiedad que se va a obtener el nombre de usuario.  
 
 En las plataformas Unix la <xref:System.Environment.UserName%2A> propiedad contiene una llamada a la `getpwuid_r` (función).
 
 Si una aplicación ASP.NET se ejecuta en un entorno de desarrollo, la <xref:System.Environment.UserName%2A> propiedad devuelve el nombre del usuario actual. En una aplicación publicada de ASP.NET, esta propiedad devuelve el nombre de la cuenta de grupo de aplicaciones (por ejemplo, el grupo de aplicaciones predeterminado).  
  
   
  
## Examples  
 En el ejemplo siguiente se muestra el nombre de usuario de la persona que inició el subproceso actual.  
  
 [!code-cpp[Environment.UserName#1](~/samples/snippets/cpp/VS_Snippets_CLR/Environment.UserName/CPP/username.cpp#1)]
 [!code-csharp[Environment.UserName#1](~/samples/snippets/csharp/VS_Snippets_CLR/Environment.UserName/CS/username.cs#1)]
 [!code-vb[Environment.UserName#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Environment.UserName/VB/username.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission">Para obtener acceso de lectura a la variable de entorno de nombre de usuario. Enumeración asociada: <see cref="F:System.Security.Permissions.EnvironmentPermissionAccess.Read" /></permission>
        <altmember cref="P:System.Environment.UserDomainName" />
      </Docs>
    </Member>
    <Member MemberName="Version">
      <MemberSignature Language="C#" Value="public static Version Version { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Version Version" />
      <MemberSignature Language="DocId" Value="P:System.Environment.Version" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property Version As Version" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property Version ^ Version { Version ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Version : Version" Usage="System.Environment.Version" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Version</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets a <see cref="T:System.Version" /> object that describes the major, minor, build, and revision numbers of the common language runtime.</summary>
        <value>Un objeto que muestra la versión de Common Language Runtime.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para las versiones 4, 4.5, 4.5.1 y 4.5.2 de .NET Framework, la propiedad <xref:System.Environment.Version%2A?displayProperty=nameWithType> devuelve un objeto <xref:System.Version> cuya representación de cadena tiene la forma `4.0.30319.xxxxx`. Para el .NET Framework 4.6 y versiones posteriores, tiene la forma `4.0.30319.42000`.  
  
> [!WARNING]
>  Para el [!INCLUDE[net_v45](~/includes/net-v45-md.md)] y versiones posteriores, no se recomienda usar el <xref:System.Environment.Version%2A> propiedad para detectar la versión del tiempo de ejecución; en su lugar, se puede determinar la versión de common language runtime consultando el registro. Para obtener más información, consulte [Cómo: determinar qué .NET Framework versiones están instaladas](~/docs/framework/migration-guide/how-to-determine-which-versions-are-installed.md).  
  
 Para obtener más información acerca de la versión de common language runtime que se instala con cada versión de .NET Framework, vea [versiones y dependencias de](~/docs/framework/migration-guide/versions-and-dependencies.md).  
  
   
  
## Examples  
 En el ejemplo siguiente se muestra la versión de common language runtime. (La versión se omite del resultado del ejemplo por razones de seguridad).  
  
 [!code-cpp[Environment.Version#1](~/samples/snippets/cpp/VS_Snippets_CLR/Environment.Version/CPP/version.cpp#1)]
 [!code-csharp[Environment.Version#1](~/samples/snippets/csharp/VS_Snippets_CLR/Environment.Version/CS/version.cs#1)]
 [!code-vb[Environment.Version#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Environment.Version/VB/version.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WorkingSet">
      <MemberSignature Language="C#" Value="public static long WorkingSet { get; }" />
      <MemberSignature Language="ILAsm" Value=".property int64 WorkingSet" />
      <MemberSignature Language="DocId" Value="P:System.Environment.WorkingSet" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property WorkingSet As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property long WorkingSet { long get(); };" />
      <MemberSignature Language="F#" Value="member this.WorkingSet : int64" Usage="System.Environment.WorkingSet" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the amount of physical memory mapped to the process context.</summary>
        <value>Un entero de 64 bits con signo que contiene el número de bytes de memoria física asignada al contexto del proceso.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 En el ejemplo siguiente se muestra el tamaño del conjunto de trabajo del equipo que ejecuta el ejemplo de código.  
  
 [!code-cpp[Environment.WorkingSet#1](~/samples/snippets/cpp/VS_Snippets_CLR/Environment.WorkingSet/CPP/workingset.cpp#1)]
 [!code-csharp[Environment.WorkingSet#1](~/samples/snippets/csharp/VS_Snippets_CLR/Environment.WorkingSet/CS/workingset.cs#1)]
 [!code-vb[Environment.WorkingSet#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Environment.WorkingSet/VB/workingset.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission">para tener acceso total al recurso protegido por este permiso. Enumeración asociada: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></permission>
      </Docs>
    </Member>
  </Members>
</Type>