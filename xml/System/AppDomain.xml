<Type Name="AppDomain" FullName="System.AppDomain">
  <Metadata><Meta Name="ms.openlocfilehash" Value="e2443de03d296fbef6ce6bfadce1761fa2dda45c" /><Meta Name="ms.sourcegitcommit" Value="bac13a81377b1c4ebf3990e3287a6f1700f73751" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="es-ES" /><Meta Name="ms.lasthandoff" Value="03/19/2019" /><Meta Name="ms.locfileid" Value="57933981" /></Metadata><TypeSignature Language="C#" Value="public sealed class AppDomain : MarshalByRefObject, _AppDomain, System.Security.IEvidenceFactory" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi sealed beforefieldinit AppDomain extends System.MarshalByRefObject implements class System._AppDomain, class System.Security.IEvidenceFactory" />
  <TypeSignature Language="DocId" Value="T:System.AppDomain" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class AppDomain&#xA;Inherits MarshalByRefObject&#xA;Implements _AppDomain, IEvidenceFactory" />
  <TypeSignature Language="C++ CLI" Value="public ref class AppDomain sealed : MarshalByRefObject, _AppDomain, System::Security::IEvidenceFactory" />
  <TypeSignature Language="F#" Value="type AppDomain = class&#xA;    inherit MarshalByRefObject&#xA;    interface _AppDomain&#xA;    interface IEvidenceFactory" />
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Runtime.Extensions</AssemblyName>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.MarshalByRefObject</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System._AppDomain</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Security.IEvidenceFactory</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ClassInterface(System.Runtime.InteropServices.ClassInterfaceType.None)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComDefaultInterface(typeof(System._AppDomain))</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Representa un dominio de aplicación, que es un entorno aislado donde se ejecutan las aplicaciones. Esta clase no puede heredarse.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dominios de aplicación, que están representados por <xref:System.AppDomain> objetos, ayudan a proporcionar aislamiento, descarga y límites de seguridad para ejecutar código administrado.  
  
-   Utilizar dominios de aplicación para aislar las tareas que es posible que derrumbar un proceso. Si el estado de la <xref:System.AppDomain> que está ejecutando una tarea se vuelve inestable, el <xref:System.AppDomain> puede descargarse sin afectar al proceso. Esto es importante cuando un proceso debe ejecutarse durante largos períodos sin necesidad de reiniciar. También puede usar dominios de aplicación para aislar las tareas que no deben compartir los datos.  
  
-   Si un ensamblado se carga en el dominio de aplicación predeterminado, no se puede descargar de la memoria mientras se ejecuta el proceso. Sin embargo, si abre un segundo dominio de aplicación para cargar y ejecutar el ensamblado, se descarga el ensamblado cuando se descarga ese dominio de aplicación. Use esta técnica para minimizar el espacio de trabajo de procesos de larga ejecución que en ocasiones se utilizan grandes archivos DLL.  
  
 > [!NOTE]
 >  En .NET Core, el <xref:System.AppDomain> implementación está limitada por cuestiones de diseño y no proporciona los límites de aislamiento, descargar o seguridad. Para .NET Core, hay exactamente un <xref:System.AppDomain>. Aislamiento y descarga se proporcionan a través de <xref:System.Runtime.Loader.AssemblyLoadContext>. Los límites de seguridad deben proporcionar los límites del proceso y las técnicas de comunicación remota adecuado.
 
 Pueden ejecutar varios dominios de aplicación en un único proceso; Sin embargo, no hay una correlación uno a uno entre los dominios de aplicación y los subprocesos. Varios subprocesos pueden pertenecer a un dominio de aplicación único y, mientras que un subproceso determinado no se limita a un único dominio de aplicación, en un momento dado, un subproceso se ejecuta en un único dominio de aplicación.  
  
 Dominios de aplicación se crean mediante el <xref:System.AppDomain.CreateDomain%2A> método. <xref:System.AppDomain> las instancias se usan para cargar y ejecutar ensamblados (<xref:System.Reflection.Assembly>). Cuando un <xref:System.AppDomain> es ya no está en uso, se puede descargar.  
  
 La <xref:System.AppDomain> clase implementa un conjunto de eventos que las aplicaciones puedan responder cuando se carga un ensamblado al que se va a descargar un dominio de aplicación, o cuando se produce una excepción no controlada.  
  
 Para obtener más información sobre el uso de dominios de aplicación, consulte [dominios de aplicación](~/docs/framework/app-domains/application-domains.md).  
  
 Esta clase implementa la <xref:System.MarshalByRefObject>, <xref:System._AppDomain>, y <xref:System.Security.IEvidenceFactory> interfaces.  
  
 Nunca se debe crear un contenedor utilizable de forma remota para un <xref:System.AppDomain> objeto. Si lo hace, puede publicar una referencia remota a la que <xref:System.AppDomain>, exponer métodos, como <xref:System.AppDomain.CreateInstance%2A> para acceso remoto y destruyendo la seguridad de acceso del código para que <xref:System.AppDomain>. Los clientes malintencionados que se conectan a la remoto <xref:System.AppDomain> se puede obtener acceso a cualquier recurso el <xref:System.AppDomain> sí tiene acceso a. No cree contenedores utilizables de forma remota para cualquier tipo que extiende <xref:System.MarshalByRefObject> y que implemente métodos que podrían ser usados por los clientes malintencionados para omitir el sistema de seguridad.  
  
> [!CAUTION]
>  El valor predeterminado para el <xref:System.AppDomainSetup.DisallowCodeDownload%2A?displayProperty=nameWithType> propiedad es `false`. Esta configuración no es segura para los servicios. Para evitar que los servicios de descarga de código de confianza parcial, establezca esta propiedad en `true`.  
  
   
  
## Examples  
 En este ejemplo se muestra cómo crear un nuevo <xref:System.AppDomain>, crear instancias de un tipo en ese nuevo <xref:System.AppDomain>y comunicarse con el objeto de ese tipo. Además, este ejemplo muestra cómo descargar el <xref:System.AppDomain> provocando el objeto sea recolectado.  
  
 [!code-cpp[AppDomainX#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomainX/cpp/AppDomainX.cpp#1)]
 [!code-csharp[AppDomainX#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomainX/cs/AppDomainX.cs#1)]
 [!code-vb[AppDomainX#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomainX/VB/AppDomainX.vb#1)]  
  
 ]]></format>
    </remarks>
    <related type="Article" href="https://msdn.microsoft.com/library/07ea8438-7a34-49f0-a7e8-3d6ff7e4a482">Cómo para configurar un dominio de aplicación</related>
    <related type="Article" href="https://msdn.microsoft.com/library/ba1fa43e-49f5-47d9-bd7f-3024af16f4ba">Cómo para crear un dominio de aplicación</related>
    <related type="Article" href="https://msdn.microsoft.com/library/1432aa2d-bd83-4346-bf3b-a1b7920e2aa9">Cómo: Cargar ensamblados en un dominio de aplicación</related>
    <related type="Article" href="https://msdn.microsoft.com/library/f356116d-e415-4f7c-a332-6e6a60227192">Cómo: Descargar un dominio de aplicación</related>
  </Docs>
  <Members>
    <Member MemberName="ActivationContext">
      <MemberSignature Language="C#" Value="public ActivationContext ActivationContext { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.ActivationContext ActivationContext" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.ActivationContext" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ActivationContext As ActivationContext" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property ActivationContext ^ ActivationContext { ActivationContext ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ActivationContext : ActivationContext" Usage="System.AppDomain.ActivationContext" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ActivationContext</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene el contexto de activación para el dominio de aplicación actual.</summary>
        <value>Objeto que representa el contexto de activación para el dominio de aplicación actual, o <see langword="null" /> si el dominio no tiene ningún contexto de activación.</value>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requiere plena confianza para el llamador inmediato. Este miembro no se puede usar código de confianza parcial o transparente.</permission>
      </Docs>
    </Member>
    <Member MemberName="AppendPrivatePath">
      <MemberSignature Language="C#" Value="public void AppendPrivatePath (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void AppendPrivatePath(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.AppendPrivatePath(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AppendPrivatePath (path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void AppendPrivatePath(System::String ^ path);" />
      <MemberSignature Language="F#" Value="abstract member AppendPrivatePath : string -&gt; unit&#xA;override this.AppendPrivatePath : string -&gt; unit" Usage="appDomain.AppendPrivatePath path" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.AppendPrivatePath(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("AppDomain.AppendPrivatePath has been deprecated. Please investigate the use of AppDomainSetup.PrivateBinPath instead.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.Obsolete("AppDomain.AppendPrivatePath has been deprecated. Please investigate the use of AppDomainSetup.PrivateBinPath instead. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-3.0">
          <AttributeName>System.Obsolete("AppDomain.AppendPrivatePath has been deprecated. Please investigate the use of AppDomainSetup.PrivateBinPath instead. https://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Nombre del directorio que hay que agregar a la ruta de acceso privada.</param>
        <summary>Anexa el nombre de directorio especificado a la lista de rutas de acceso privadas.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 No se recomienda el uso de esta propiedad, porque podría cambiar la ruta de acceso de sondeo para ensamblados una vez que ya se han cargado. Utilice la propiedad <xref:System.AppDomainSetup.PrivateBinPath%2A?displayProperty=nameWithType> en su lugar.  
  
 La ruta de acceso privado, o la ruta de búsqueda relativa es la ruta de acceso relativa al directorio base donde el interpretador de ensamblados para ensamblados privados.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException">La operación se intenta en un dominio de aplicación descargado.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requiere plena confianza para el llamador inmediato. Este miembro no se puede usar código de confianza parcial o transparente.</permission>
      </Docs>
    </Member>
    <Member MemberName="ApplicationIdentity">
      <MemberSignature Language="C#" Value="public ApplicationIdentity ApplicationIdentity { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.ApplicationIdentity ApplicationIdentity" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.ApplicationIdentity" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ApplicationIdentity As ApplicationIdentity" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property ApplicationIdentity ^ ApplicationIdentity { ApplicationIdentity ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ApplicationIdentity : ApplicationIdentity" Usage="System.AppDomain.ApplicationIdentity" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ApplicationIdentity</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene la identidad de la aplicación en el dominio de aplicación.</summary>
        <value>Objeto que identifica la aplicación en el dominio de aplicación.</value>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requiere plena confianza para el llamador inmediato. Este miembro no se puede usar código de confianza parcial o transparente.</permission>
      </Docs>
    </Member>
    <Member MemberName="ApplicationTrust">
      <MemberSignature Language="C#" Value="public System.Security.Policy.ApplicationTrust ApplicationTrust { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Security.Policy.ApplicationTrust ApplicationTrust" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.ApplicationTrust" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ApplicationTrust As ApplicationTrust" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Security::Policy::ApplicationTrust ^ ApplicationTrust { System::Security::Policy::ApplicationTrust ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ApplicationTrust : System.Security.Policy.ApplicationTrust" Usage="System.AppDomain.ApplicationTrust" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Security.Policy.ApplicationTrust</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene información que describe los permisos concedidos a una aplicación y si la aplicación tiene un nivel de confianza que le permita ejecutarse.</summary>
        <value>Objeto que encapsula permisos e información de confianza para la aplicación en el dominio de aplicación.</value>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requiere plena confianza para el llamador inmediato. Este miembro no se puede usar código de confianza parcial o transparente.</permission>
      </Docs>
    </Member>
    <Member MemberName="ApplyPolicy">
      <MemberSignature Language="C#" Value="public string ApplyPolicy (string assemblyName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ApplyPolicy(string assemblyName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.ApplyPolicy(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function ApplyPolicy (assemblyName As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ApplyPolicy(System::String ^ assemblyName);" />
      <MemberSignature Language="F#" Value="member this.ApplyPolicy : string -&gt; string" Usage="appDomain.ApplyPolicy assemblyName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="assemblyName">Nombre para mostrar del ensamblado, en el formato que proporciona la propiedad <see cref="P:System.Reflection.Assembly.FullName" />.</param>
        <summary>Devuelve el nombre para mostrar del ensamblado después de aplicar la directiva.</summary>
        <returns>Cadena que contiene el nombre para mostrar del ensamblado después de aplicar la directiva.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.AppDomain.ApplyPolicy%2A> mostrar el nombre de método toma un ensamblado y devuelve el nombre para mostrar tras aplicar la directiva. Esto es útil si tiene que cargar un ensamblado mediante la directiva, porque el contexto de solo reflexión no aplica la directiva.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AssemblyLoad">
      <MemberSignature Language="C#" Value="public event AssemblyLoadEventHandler AssemblyLoad;" />
      <MemberSignature Language="ILAsm" Value=".event class System.AssemblyLoadEventHandler AssemblyLoad" />
      <MemberSignature Language="DocId" Value="E:System.AppDomain.AssemblyLoad" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event AssemblyLoad As AssemblyLoadEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event AssemblyLoadEventHandler ^ AssemblyLoad;" />
      <MemberSignature Language="F#" Value="member this.AssemblyLoad : AssemblyLoadEventHandler " Usage="member this.AssemblyLoad : System.AssemblyLoadEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System._AppDomain.AssemblyLoad</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>add: System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>remove: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.AssemblyLoadEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produce cuando se carga un ensamblado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.AssemblyLoadEventHandler> delegado para este evento indica qué ensamblado se cargó.  
  
 Para registrar un controlador de eventos para este evento, debe tener los permisos necesarios, o un <xref:System.Security.SecurityException> se produce.  
  
 Para obtener más información sobre el manejo de eventos, consulte [controlar y provocar eventos](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 El ejemplo siguiente se muestra el <xref:System.AppDomain.AssemblyLoad> eventos.  
  
 Para que poder ejecutar este ejemplo de código, debe proporcionar el nombre completo del ensamblado. Para obtener información acerca de cómo obtener el nombre completo del ensamblado, vea [nombres de ensamblado](~/docs/framework/app-domains/assembly-names.md).  
  
 [!code-cpp[AppDomain_AssemblyLoad#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_AssemblyLoad/CPP/assemblyload.cpp#1)]
 [!code-csharp[AppDomain_AssemblyLoad#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_AssemblyLoad/CS/assemblyload.cs#1)]
 [!code-vb[AppDomain_AssemblyLoad#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_AssemblyLoad/VB/assemblyload.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requiere plena confianza para el llamador inmediato. Este miembro no se puede usar código de confianza parcial o transparente.</permission>
      </Docs>
    </Member>
    <Member MemberName="AssemblyResolve">
      <MemberSignature Language="C#" Value="public event ResolveEventHandler AssemblyResolve;" />
      <MemberSignature Language="ILAsm" Value=".event class System.ResolveEventHandler AssemblyResolve" />
      <MemberSignature Language="DocId" Value="E:System.AppDomain.AssemblyResolve" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event AssemblyResolve As ResolveEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event ResolveEventHandler ^ AssemblyResolve;" />
      <MemberSignature Language="F#" Value="member this.AssemblyResolve : ResolveEventHandler " Usage="member this.AssemblyResolve : System.ResolveEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System._AppDomain.AssemblyResolve</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>add: System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>remove: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ResolveEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produce cuando la resolución de un ensamblado produce errores.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Es responsabilidad de la <xref:System.ResolveEventHandler> para este evento devolver el ensamblado especificado por el <xref:System.ResolveEventArgs.Name%2A?displayProperty=nameWithType> propiedad, o para devolver null si no se reconoce el ensamblado. El ensamblado deben cargarse en un contexto de ejecución; Si se carga en el contexto de solo reflexión, se produce un error en la carga que provocó este evento.  
  
 Para obtener instrucciones sobre el uso de este evento, vea [resolver cargas de ensamblado](~/docs/framework/app-domains/resolve-assembly-loads.md).  
  
 A partir del [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], el <xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=nameWithType> propiedad devuelve el ensamblado que solicitó la carga del ensamblado que no se pudo resolver. Por ejemplo, el cargador podría ser no se puede cargar una dependencia del ensamblado que realiza solicitud porque el ensamblado para solicitar y su dependencia no están en la ruta de acceso de sondeo. Conocer la identidad del ensamblado que realiza solicitud podría ser útil para localizar la dependencia o identificar la versión correcta, si hay más de una versión de la dependencia. Para obtener más información, vea <xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=nameWithType>.  
  
> [!IMPORTANT]
>  A partir del [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)], el <xref:System.ResolveEventHandler> evento se desencadena para todos los ensamblados, incluidos los ensamblados de recursos. En versiones anteriores, no se generó el evento para los ensamblados de recursos. Si se localiza el sistema operativo, el controlador puede llamarse varias veces: una vez para cada referencia cultural de la cadena de reserva.  
  
 Para este evento, el <xref:System.ResolveEventArgs.Name%2A?displayProperty=nameWithType> propiedad devuelve el nombre del ensamblado antes de que se aplica la directiva.  
  
> [!IMPORTANT]
>  Si más de un controlador de eventos está registrado para este evento, los controladores de eventos se llaman en orden hasta que un controlador de eventos devuelve un valor que no sea `null`. Controladores de eventos posteriores se omiten.
  
 Para obtener más información sobre el manejo de eventos, consulte [controlar y provocar eventos](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 El ejemplo siguiente se muestra el <xref:System.AppDomain.AssemblyResolve> eventos.  
  
 Para que poder ejecutar este ejemplo de código, debe proporcionar el nombre completo del ensamblado. Para obtener información acerca de cómo obtener el nombre completo del ensamblado, vea [nombres de ensamblado](~/docs/framework/app-domains/assembly-names.md).  
  
 [!code-cpp[AssemblyResolve#1](~/samples/snippets/cpp/VS_Snippets_CLR/AssemblyResolve/CPP/assemblyresolve.cpp#1)]
 [!code-csharp[AssemblyResolve#1](~/samples/snippets/csharp/VS_Snippets_CLR/AssemblyResolve/CS/assemblyresolve.cs#1)]
 [!code-vb[AssemblyResolve#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AssemblyResolve/VB/assemblyresolve.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requiere plena confianza para el llamador inmediato. Este miembro no se puede usar código de confianza parcial o transparente.</permission>
        <altmember cref="P:System.ResolveEventArgs.RequestingAssembly" />
        <related type="Article" href="https://msdn.microsoft.com/library/5099e549-f4fd-49fb-a290-549edd456c6a">resolver cargas de ensamblado</related>
      </Docs>
    </Member>
    <Member MemberName="BaseDirectory">
      <MemberSignature Language="C#" Value="public string BaseDirectory { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string BaseDirectory" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.BaseDirectory" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property BaseDirectory As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ BaseDirectory { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.BaseDirectory : string" Usage="System.AppDomain.BaseDirectory" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System._AppDomain.BaseDirectory</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene el directorio base que la resolución de ensamblado usa para buscar ensamblados.</summary>
        <value>Directorio base que la resolución de ensamblado usa para buscar ensamblados.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esta propiedad se corresponde con el <xref:System.AppDomainSetup.ApplicationBase%2A?displayProperty=nameWithType> propiedad. También se puede recuperar utilizando la <xref:System.AppDomain.GetData%2A> método con la cadena "Raíz (appbase)".  
  
   
  
## Examples  
 En el ejemplo de código siguiente se crea un nuevo dominio de aplicación, que especifica un directorio base que se usará al buscar ensamblados para cargar en el dominio. El ejemplo se utiliza el <xref:System.AppDomain.BaseDirectory%2A> propiedad para obtener la ruta de acceso del directorio base, para su presentación en la consola.  
  
 [!code-cpp[ADSetup#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADSetup/CPP/adsetup.cpp#1)]
 [!code-csharp[ADSetup#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADSetup/CS/adsetup.cs#1)]
 [!code-vb[ADSetup#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADSetup/VB/adsetup.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException">La operación se intenta en un dominio de aplicación descargado.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Para obtener acceso a la información de la ruta de acceso, incluso si la ruta de acceso tiene el formato "file://" o \\\UNC\dir o "c:\\". Enumeraciones asociadas: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</permission>
        <altmember cref="P:System.AppDomainSetup.ApplicationBase" />
      </Docs>
    </Member>
    <Member MemberName="ClearPrivatePath">
      <MemberSignature Language="C#" Value="public void ClearPrivatePath ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ClearPrivatePath() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.ClearPrivatePath" />
      <MemberSignature Language="VB.NET" Value="Public Sub ClearPrivatePath ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void ClearPrivatePath();" />
      <MemberSignature Language="F#" Value="abstract member ClearPrivatePath : unit -&gt; unit&#xA;override this.ClearPrivatePath : unit -&gt; unit" Usage="appDomain.ClearPrivatePath " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.ClearPrivatePath</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("AppDomain.ClearPrivatePath has been deprecated. Please investigate the use of AppDomainSetup.PrivateBinPath instead.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.Obsolete("AppDomain.ClearPrivatePath has been deprecated. Please investigate the use of AppDomainSetup.PrivateBinPath instead. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-3.0">
          <AttributeName>System.Obsolete("AppDomain.ClearPrivatePath has been deprecated. Please investigate the use of AppDomainSetup.PrivateBinPath instead. https://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Restablece la ruta de acceso que especifica la ubicación de ensamblados privados en la cadena vacía ("").</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La ruta de acceso privada es una ruta de acceso relativa al directorio base que common language runtime busca para buscar ensamblados privados.  
  
 Para obtener más información, vea <xref:System.AppDomainSetup.PrivateBinPath%2A?displayProperty=nameWithType>.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra cómo usar el <xref:System.AppDomain.ClearPrivatePath%2A> método para quitar todas las entradas de la lista de rutas de acceso privadas para buscar cuando se cargan los ensamblados.  
  
 Este método ahora está obsoleto y no se recomienda para nuevo desarrollo.  
  
 [!code-cpp[ADClearPrivatePath#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADClearPrivatePath/CPP/adclearprivatepath.cpp#1)]
 [!code-csharp[ADClearPrivatePath#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADClearPrivatePath/CS/adclearprivatepath.cs#1)]
 [!code-vb[ADClearPrivatePath#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADClearPrivatePath/VB/adclearprivatepath.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException">La operación se intenta en un dominio de aplicación descargado.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requiere plena confianza para el llamador inmediato. Este miembro no se puede usar código de confianza parcial o transparente.</permission>
        <altmember cref="F:System.String.Empty" />
      </Docs>
    </Member>
    <Member MemberName="ClearShadowCopyPath">
      <MemberSignature Language="C#" Value="public void ClearShadowCopyPath ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ClearShadowCopyPath() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.ClearShadowCopyPath" />
      <MemberSignature Language="VB.NET" Value="Public Sub ClearShadowCopyPath ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void ClearShadowCopyPath();" />
      <MemberSignature Language="F#" Value="abstract member ClearShadowCopyPath : unit -&gt; unit&#xA;override this.ClearShadowCopyPath : unit -&gt; unit" Usage="appDomain.ClearShadowCopyPath " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.ClearShadowCopyPath</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use AppDomainSetup.ShadowCopyDirectories")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.Obsolete("AppDomain.ClearShadowCopyPath has been deprecated. Please investigate the use of AppDomainSetup.ShadowCopyDirectories instead. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-3.0">
          <AttributeName>System.Obsolete("AppDomain.ClearShadowCopyPath has been deprecated. Please investigate the use of AppDomainSetup.ShadowCopyDirectories instead. https://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Restablece la lista de directorios que contienen instantáneas de ensamblados en la cadena vacía ("").</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La ruta de acceso de copia sombra es una lista de directorios donde sombra copiadas en los ensamblados se almacenan.  
  
 Para obtener más información, consulte <xref:System.AppDomainSetup.ShadowCopyDirectories%2A?displayProperty=nameWithType> y [copias sombra de ensamblados](~/docs/framework/app-domains/shadow-copy-assemblies.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException">La operación se intenta en un dominio de aplicación descargado.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requiere plena confianza para el llamador inmediato. Este miembro no se puede usar código de confianza parcial o transparente.</permission>
        <altmember cref="F:System.String.Empty" />
        <related type="Article" href="~/docs/framework/app-domains/shadow-copy-assemblies.md">Copias sombra de ensamblados</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateComInstanceFrom">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Crea una nueva instancia de un tipo COM especificado.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateComInstanceFrom">
      <MemberSignature Language="C#" Value="public System.Runtime.Remoting.ObjectHandle CreateComInstanceFrom (string assemblyName, string typeName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Runtime.Remoting.ObjectHandle CreateComInstanceFrom(string assemblyName, string typeName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateComInstanceFrom(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateComInstanceFrom (assemblyName As String, typeName As String) As ObjectHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Runtime::Remoting::ObjectHandle ^ CreateComInstanceFrom(System::String ^ assemblyName, System::String ^ typeName);" />
      <MemberSignature Language="F#" Value="member this.CreateComInstanceFrom : string * string -&gt; System.Runtime.Remoting.ObjectHandle" Usage="appDomain.CreateComInstanceFrom (assemblyName, typeName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="typeName" Type="System.String" Index="1" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="assemblyName">Nombre de un archivo que contiene un ensamblado que define el tipo solicitado.</param>
        <param name="typeName">Nombre del tipo solicitado.</param>
        <summary>Crea una nueva instancia de un tipo COM especificado. Los parámetros especifican el nombre de un archivo que contiene un ensamblado con el tipo y el nombre del tipo.</summary>
        <returns>Objeto contenedor de la nueva instancia especificada por <paramref name="typeName" />. El valor devuelto debe desempaquetarse para obtener acceso al objeto real.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilice este método para crear objetos de forma remota sin tener que cargar el tipo localmente.  
  
 El valor devuelto debe desempaquetarse para obtener acceso al objeto real.  
  
 Un <xref:System.Runtime.InteropServices.ComVisibleAttribute?displayProperty=nameWithType> atributo con un valor de `true` deben aplicarse explícitamente o de forma predeterminada al tipo COM para que este método para crear una instancia de ese tipo; de lo contrario, <xref:System.TypeLoadException> se produce.  
  
   
  
## Examples  
 El ejemplo siguiente se muestra  
  
 [!code-cpp[AppDomain_CreateComInstanceFrom#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_CreateComInstanceFrom/CPP/createcominstancefrom.cpp#1)]
 [!code-csharp[AppDomain_CreateComInstanceFrom#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_CreateComInstanceFrom/CS/createcominstancefrom.cs#1)]
 [!code-vb[AppDomain_CreateComInstanceFrom#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_CreateComInstanceFrom/VB/createcominstancefrom.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="assemblyName" /> o <paramref name="typeName" /> es <see langword="null" />.</exception>
        <exception cref="T:System.TypeLoadException">No se puede cargar el tipo.</exception>
        <exception cref="T:System.AppDomainUnloadedException">La operación se intenta en un dominio de aplicación descargado.</exception>
        <exception cref="T:System.MissingMethodException">No se ha encontrado ningún constructor público sin parámetros.</exception>
        <exception cref="T:System.IO.FileNotFoundException">No se ha encontrado <paramref name="assemblyName" />.</exception>
        <exception cref="T:System.MemberAccessException"><paramref name="typeName" /> es una clase abstracta.  
  
O bien 
Este miembro se invocó con un mecanismo de enlace en tiempo de ejecución.</exception>
        <exception cref="T:System.NotSupportedException">El llamador no puede ofrecer atributos de activación para un objeto que no hereda de <see cref="T:System.MarshalByRefObject" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="assemblyName" /> es una cadena vacía ("").</exception>
        <exception cref="T:System.BadImageFormatException"><paramref name="assemblyName" /> no es un ensamblado válido.</exception>
        <exception cref="T:System.IO.FileLoadException">Se cargó un ensamblado o módulo dos veces con dos evidencias diferentes.</exception>
        <exception cref="T:System.NullReferenceException">El objeto COM al que se hace referencia es <see langword="null" />.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermissionAccess">para que poder leer el archivo que contiene el manifiesto del ensamblado. Enumeración asociada: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Net.WebPermission">Para poder acceder a la ubicación del ensamblado si el ensamblado no es local.</permission>
        <altmember cref="M:System.Activator.CreateComInstanceFrom(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="CreateComInstanceFrom">
      <MemberSignature Language="C#" Value="public System.Runtime.Remoting.ObjectHandle CreateComInstanceFrom (string assemblyFile, string typeName, byte[] hashValue, System.Configuration.Assemblies.AssemblyHashAlgorithm hashAlgorithm);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Runtime.Remoting.ObjectHandle CreateComInstanceFrom(string assemblyFile, string typeName, unsigned int8[] hashValue, valuetype System.Configuration.Assemblies.AssemblyHashAlgorithm hashAlgorithm) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateComInstanceFrom(System.String,System.String,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateComInstanceFrom (assemblyFile As String, typeName As String, hashValue As Byte(), hashAlgorithm As AssemblyHashAlgorithm) As ObjectHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Runtime::Remoting::ObjectHandle ^ CreateComInstanceFrom(System::String ^ assemblyFile, System::String ^ typeName, cli::array &lt;System::Byte&gt; ^ hashValue, System::Configuration::Assemblies::AssemblyHashAlgorithm hashAlgorithm);" />
      <MemberSignature Language="F#" Value="member this.CreateComInstanceFrom : string * string * byte[] * System.Configuration.Assemblies.AssemblyHashAlgorithm -&gt; System.Runtime.Remoting.ObjectHandle" Usage="appDomain.CreateComInstanceFrom (assemblyFile, typeName, hashValue, hashAlgorithm)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="typeName" Type="System.String" Index="1" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="hashValue" Type="System.Byte[]" Index="2" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="hashAlgorithm" Type="System.Configuration.Assemblies.AssemblyHashAlgorithm" Index="3" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="assemblyFile">Nombre de un archivo que contiene un ensamblado que define el tipo solicitado.</param>
        <param name="typeName">Nombre del tipo solicitado.</param>
        <param name="hashValue">Representa el valor del código hash calculado.</param>
        <param name="hashAlgorithm">Representa el algoritmo hash que usa el manifiesto del ensamblado.</param>
        <summary>Crea una nueva instancia de un tipo COM especificado. Los parámetros especifican el nombre de un archivo que contiene un ensamblado con el tipo y el nombre del tipo.</summary>
        <returns>Objeto contenedor de la nueva instancia especificada por <paramref name="typeName" />. El valor devuelto debe desempaquetarse para obtener acceso al objeto real.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilice este método para crear objetos de forma remota sin tener que cargar el tipo localmente.  
  
 El valor devuelto debe desempaquetarse para obtener acceso al objeto real.  
  
 Un <xref:System.Runtime.InteropServices.ComVisibleAttribute?displayProperty=nameWithType> atributo con un valor de `true` deben aplicarse explícitamente o de forma predeterminada al tipo COM para que este método para crear una instancia de ese tipo; de lo contrario, <xref:System.TypeLoadException> se produce.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="assemblyName" /> o <paramref name="typeName" /> es <see langword="null" />.</exception>
        <exception cref="T:System.TypeLoadException">No se puede cargar el tipo.</exception>
        <exception cref="T:System.AppDomainUnloadedException">La operación se intenta en un dominio de aplicación descargado.</exception>
        <exception cref="T:System.MissingMethodException">No se ha encontrado ningún constructor público sin parámetros.</exception>
        <exception cref="T:System.IO.FileNotFoundException">No se ha encontrado <paramref name="assemblyFile" />.</exception>
        <exception cref="T:System.MemberAccessException"><paramref name="typeName" /> es una clase abstracta.  
  
O bien 
Este miembro se invocó con un mecanismo de enlace en tiempo de ejecución.</exception>
        <exception cref="T:System.NotSupportedException">El llamador no puede proporcionar atributos de activación para un objeto que no hereda de <see cref="T:System.MarshalByRefObject" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="assemblyFile" /> es la cadena vacía ("").</exception>
        <exception cref="T:System.BadImageFormatException"><paramref name="assemblyFile" /> no es un ensamblado válido.</exception>
        <exception cref="T:System.IO.FileLoadException">Se cargó un ensamblado o módulo dos veces con dos evidencias diferentes.</exception>
        <exception cref="T:System.NullReferenceException">El objeto COM al que se hace referencia es <see langword="null" />.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermissionAccess">para que poder leer el archivo que contiene el manifiesto del ensamblado. Enumeración asociada: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Net.WebPermission">Para poder acceder a la ubicación del ensamblado si el ensamblado no es local.</permission>
        <altmember cref="M:System.Activator.CreateComInstanceFrom(System.String,System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateDomain">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Crea un nuevo dominio de aplicación.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateDomain">
      <MemberSignature Language="C#" Value="public static AppDomain CreateDomain (string friendlyName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.AppDomain CreateDomain(string friendlyName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateDomain(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateDomain (friendlyName As String) As AppDomain" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static AppDomain ^ CreateDomain(System::String ^ friendlyName);" />
      <MemberSignature Language="F#" Value="static member CreateDomain : string -&gt; AppDomain" Usage="System.AppDomain.CreateDomain friendlyName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.AppDomain</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="friendlyName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="friendlyName">Nombre descriptivo del dominio.</param>
        <summary>Crea un nuevo dominio de aplicación con el nombre especificado.</summary>
        <returns>Dominio de aplicación recién creado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El `friendlyName` parámetro está pensado para identificar el dominio de manera que sea significativo para los seres humanos. Esta cadena debe ser adecuada para su presentación en interfaces de usuario.  
  
 Esta sobrecarga del método usa la <xref:System.AppDomainSetup> información de dominio de aplicación predeterminado.  
  
   
  
## Examples  
 El ejemplo siguiente muestra, en general, cómo crear un dominio mediante uno de los <xref:System.AppDomain.CreateDomain%2A> sobrecargas.  
  
 [!code-cpp[AppDomain_Setup#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_Setup/CPP/setup.cpp#1)]
 [!code-csharp[AppDomain_Setup#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_Setup/CS/setup.cs#1)]
 [!code-vb[AppDomain_Setup#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_Setup/VB/setup.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="friendlyName" /> es <see langword="null" />.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Método no admitido en .NET Core.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">para proporcionar evidencia. Enumeración asociada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</permission>
        <altmember cref="P:System.AppDomain.FriendlyName" />
      </Docs>
    </Member>
    <Member MemberName="CreateDomain">
      <MemberSignature Language="C#" Value="public static AppDomain CreateDomain (string friendlyName, System.Security.Policy.Evidence securityInfo);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.AppDomain CreateDomain(string friendlyName, class System.Security.Policy.Evidence securityInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateDomain (friendlyName As String, securityInfo As Evidence) As AppDomain" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static AppDomain ^ CreateDomain(System::String ^ friendlyName, System::Security::Policy::Evidence ^ securityInfo);" />
      <MemberSignature Language="F#" Value="static member CreateDomain : string * System.Security.Policy.Evidence -&gt; AppDomain" Usage="System.AppDomain.CreateDomain (friendlyName, securityInfo)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.AppDomain</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="friendlyName" Type="System.String" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="securityInfo" Type="System.Security.Policy.Evidence" Index="1" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="friendlyName">Nombre descriptivo del dominio. Este nombre descriptivo puede mostrarse en las interfaces de usuario para identificar el dominio. Para obtener más información, vea <see cref="P:System.AppDomain.FriendlyName" />.</param>
        <param name="securityInfo">Evidencia que establece la identidad del código que se ejecuta en el dominio de la aplicación. Pase <see langword="null" /> para que se use la evidencia del dominio de aplicación actual.</param>
        <summary>Crea un nuevo dominio de aplicación con el nombre especificado mediante la evidencia proporcionada.</summary>
        <returns>Dominio de aplicación recién creado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esta sobrecarga del método usa la <xref:System.AppDomainSetup> información de dominio de aplicación predeterminado.  
  
 Si `securityInfo` no es se proporciona, se utiliza la evidencia del dominio de aplicación actual.  
  
> [!IMPORTANT]
>  No utilice esta sobrecarga del método para crear dominios de aplicación en espacio aislado. A partir del [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], la evidencia suministrada para `securityInfo` ya no afecta al conjunto de permisos del dominio de la aplicación. Use el <xref:System.AppDomain.CreateDomain%28System.String%2CSystem.Security.Policy.Evidence%2CSystem.AppDomainSetup%2CSystem.Security.PermissionSet%2CSystem.Security.Policy.StrongName%5B%5D%29> sobrecarga del método para crear dominios de aplicación en espacio aislado.  
  
   
  
## Examples  
 El ejemplo siguiente muestra, en general, cómo crear un dominio mediante uno de los <xref:System.AppDomain.CreateDomain%2A> sobrecargas.  
  
 [!code-cpp[AppDomain_Setup#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_Setup/CPP/setup.cpp#1)]
 [!code-csharp[AppDomain_Setup#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_Setup/CS/setup.cs#1)]
 [!code-vb[AppDomain_Setup#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_Setup/VB/setup.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="friendlyName" /> es <see langword="null" />.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">para proporcionar evidencia. Enumeración asociada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="CreateDomain">
      <MemberSignature Language="C#" Value="public static AppDomain CreateDomain (string friendlyName, System.Security.Policy.Evidence securityInfo, AppDomainSetup info);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.AppDomain CreateDomain(string friendlyName, class System.Security.Policy.Evidence securityInfo, class System.AppDomainSetup info) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.AppDomainSetup)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateDomain (friendlyName As String, securityInfo As Evidence, info As AppDomainSetup) As AppDomain" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static AppDomain ^ CreateDomain(System::String ^ friendlyName, System::Security::Policy::Evidence ^ securityInfo, AppDomainSetup ^ info);" />
      <MemberSignature Language="F#" Value="static member CreateDomain : string * System.Security.Policy.Evidence * AppDomainSetup -&gt; AppDomain" Usage="System.AppDomain.CreateDomain (friendlyName, securityInfo, info)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.AppDomain</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="friendlyName" Type="System.String" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="securityInfo" Type="System.Security.Policy.Evidence" Index="1" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="info" Type="System.AppDomainSetup" Index="2" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="friendlyName">Nombre descriptivo del dominio. Este nombre descriptivo puede mostrarse en las interfaces de usuario para identificar el dominio. Para obtener más información, vea <see cref="P:System.AppDomain.FriendlyName" />.</param>
        <param name="securityInfo">Evidencia que establece la identidad del código que se ejecuta en el dominio de la aplicación. Pase <see langword="null" /> para que se use la evidencia del dominio de aplicación actual.</param>
        <param name="info">Objeto que contiene la información de inicialización del dominio de aplicación.</param>
        <summary>Crea un nuevo dominio de aplicación con el nombre especificado, la evidencia indicada y la correspondiente información de configuración.</summary>
        <returns>Dominio de aplicación recién creado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si `info` no es se proporciona, esta sobrecarga del método usa la <xref:System.AppDomainSetup> información de dominio de aplicación predeterminado.  
  
 Si `securityInfo` no es se proporciona, se utiliza la evidencia del dominio de aplicación actual.  
  
> [!IMPORTANT]
>  No utilice esta sobrecarga del método para crear dominios de aplicación en espacio aislado. A partir del [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], la evidencia suministrada para `securityInfo` ya no afecta al conjunto de permisos del dominio de la aplicación. Use el <xref:System.AppDomain.CreateDomain%28System.String%2CSystem.Security.Policy.Evidence%2CSystem.AppDomainSetup%2CSystem.Security.PermissionSet%2CSystem.Security.Policy.StrongName%5B%5D%29> sobrecarga del método para crear dominios de aplicación en espacio aislado.  
  
   
  
## Examples  
 El ejemplo siguiente muestra, en general, cómo crear un dominio mediante uno de los <xref:System.AppDomain.CreateDomain%2A> sobrecargas.  
  
 [!code-cpp[AppDomain_Setup#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_Setup/CPP/setup.cpp#1)]
 [!code-csharp[AppDomain_Setup#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_Setup/CS/setup.cs#1)]
 [!code-vb[AppDomain_Setup#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_Setup/VB/setup.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="friendlyName" /> es <see langword="null" />.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">para proporcionar evidencia. Enumeración asociada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="CreateDomain">
      <MemberSignature Language="C#" Value="public static AppDomain CreateDomain (string friendlyName, System.Security.Policy.Evidence securityInfo, AppDomainSetup info, System.Security.PermissionSet grantSet, params System.Security.Policy.StrongName[] fullTrustAssemblies);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.AppDomain CreateDomain(string friendlyName, class System.Security.Policy.Evidence securityInfo, class System.AppDomainSetup info, class System.Security.PermissionSet grantSet, class System.Security.Policy.StrongName[] fullTrustAssemblies) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.AppDomainSetup,System.Security.PermissionSet,System.Security.Policy.StrongName[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateDomain (friendlyName As String, securityInfo As Evidence, info As AppDomainSetup, grantSet As PermissionSet, ParamArray fullTrustAssemblies As StrongName()) As AppDomain" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static AppDomain ^ CreateDomain(System::String ^ friendlyName, System::Security::Policy::Evidence ^ securityInfo, AppDomainSetup ^ info, System::Security::PermissionSet ^ grantSet, ... cli::array &lt;System::Security::Policy::StrongName ^&gt; ^ fullTrustAssemblies);" />
      <MemberSignature Language="F#" Value="static member CreateDomain : string * System.Security.Policy.Evidence * AppDomainSetup * System.Security.PermissionSet * System.Security.Policy.StrongName[] -&gt; AppDomain" Usage="System.AppDomain.CreateDomain (friendlyName, securityInfo, info, grantSet, fullTrustAssemblies)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.AppDomain</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="friendlyName" Type="System.String" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="securityInfo" Type="System.Security.Policy.Evidence" Index="1" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="info" Type="System.AppDomainSetup" Index="2" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="grantSet" Type="System.Security.PermissionSet" Index="3" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="fullTrustAssemblies" Type="System.Security.Policy.StrongName[]" Index="4" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="friendlyName">Nombre descriptivo del dominio. Este nombre descriptivo puede mostrarse en las interfaces de usuario para identificar el dominio. Para obtener más información, vea la descripción de <see cref="P:System.AppDomain.FriendlyName" />.</param>
        <param name="securityInfo">Evidencia que establece la identidad del código que se ejecuta en el dominio de la aplicación. Pase <see langword="null" /> para que se use la evidencia del dominio de aplicación actual.</param>
        <param name="info">Objeto que contiene la información de inicialización del dominio de aplicación.</param>
        <param name="grantSet">Conjunto predeterminado de permisos que se concede a todos los ensamblados cargados en el nuevo dominio de aplicación que no tienen concesiones concretas.</param>
        <param name="fullTrustAssemblies">Matriz de nombres seguros que representan ensamblados que se van a considerar de plena confianza en el nuevo dominio de aplicación.</param>
        <summary>Crea un nuevo dominio de aplicación usando el nombre, la evidencia, la información de configuración del dominio de aplicación, el conjunto predeterminado de permisos y la matriz de ensamblados de plena confianza que se hayan especificado.</summary>
        <returns>Dominio de aplicación recién creado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Debe establecer el <xref:System.AppDomainSetup.ApplicationBase%2A> propiedad de la <xref:System.AppDomainSetup> objeto que proporciona para `info`. De lo contrario, se inicia una excepción.  
  
 Si `securityInfo` no es se proporciona, se utiliza la evidencia del dominio de aplicación actual.  
  
 La información proporcionada para `grantSet` y `fullTrustAssemblies` se utiliza para crear un <xref:System.Security.Policy.ApplicationTrust> objeto para el nuevo dominio de aplicación.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="friendlyName" /> es <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">El dominio de aplicación es <see langword="null" />.  
  
O bien 
La propiedad <see cref="P:System.AppDomainSetup.ApplicationBase" /> no se establece en el objeto <see cref="T:System.AppDomainSetup" /> que se proporciona para <paramref name="info" />.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Para poder crear y manipular un dominio de aplicación. Enumeración asociada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlAppDomain" />. Acción de seguridad: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="CreateDomain">
      <MemberSignature Language="C#" Value="public static AppDomain CreateDomain (string friendlyName, System.Security.Policy.Evidence securityInfo, string appBasePath, string appRelativeSearchPath, bool shadowCopyFiles);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.AppDomain CreateDomain(string friendlyName, class System.Security.Policy.Evidence securityInfo, string appBasePath, string appRelativeSearchPath, bool shadowCopyFiles) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.String,System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateDomain (friendlyName As String, securityInfo As Evidence, appBasePath As String, appRelativeSearchPath As String, shadowCopyFiles As Boolean) As AppDomain" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static AppDomain ^ CreateDomain(System::String ^ friendlyName, System::Security::Policy::Evidence ^ securityInfo, System::String ^ appBasePath, System::String ^ appRelativeSearchPath, bool shadowCopyFiles);" />
      <MemberSignature Language="F#" Value="static member CreateDomain : string * System.Security.Policy.Evidence * string * string * bool -&gt; AppDomain" Usage="System.AppDomain.CreateDomain (friendlyName, securityInfo, appBasePath, appRelativeSearchPath, shadowCopyFiles)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.AppDomain</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="friendlyName" Type="System.String" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="securityInfo" Type="System.Security.Policy.Evidence" Index="1" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="appBasePath" Type="System.String" Index="2" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="appRelativeSearchPath" Type="System.String" Index="3" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="shadowCopyFiles" Type="System.Boolean" Index="4" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="friendlyName">Nombre descriptivo del dominio. Este nombre descriptivo puede mostrarse en las interfaces de usuario para identificar el dominio. Para obtener más información, vea <see cref="P:System.AppDomain.FriendlyName" />.</param>
        <param name="securityInfo">Evidencia que establece la identidad del código que se ejecuta en el dominio de la aplicación. Pase <see langword="null" /> para que se use la evidencia del dominio de aplicación actual.</param>
        <param name="appBasePath">Directorio base que la resolución de ensamblado usa para buscar ensamblados. Para obtener más información, vea <see cref="P:System.AppDomain.BaseDirectory" />.</param>
        <param name="appRelativeSearchPath">Ruta de acceso correspondiente al directorio base donde la resolución de ensamblado debe buscar ensamblados privados. Para obtener más información, vea <see cref="P:System.AppDomain.RelativeSearchPath" />.</param>
        <param name="shadowCopyFiles">Si es <see langword="true" />, se carga una instantánea de un ensamblado en este dominio de aplicación.</param>
        <summary>Crea un nuevo dominio de aplicación con el nombre especificado usando la evidencia, la ruta de acceso base de la aplicación, la ruta de búsqueda relativa y un parámetro que especifica si debe cargarse una instantánea de un ensamblado en el dominio de aplicación.</summary>
        <returns>Dominio de aplicación recién creado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si `securityInfo` no es se proporciona, se utiliza la evidencia del dominio de aplicación actual.  
  
 Para obtener más información acerca de las instantáneas, vea <xref:System.AppDomain.ShadowCopyFiles%2A> y [copias sombra de ensamblados](~/docs/framework/app-domains/shadow-copy-assemblies.md).  
  
> [!IMPORTANT]
>  No utilice esta sobrecarga del método para crear dominios de aplicación en espacio aislado. A partir del [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], la evidencia suministrada para `securityInfo` ya no afecta al conjunto de permisos del dominio de la aplicación. Use el <xref:System.AppDomain.CreateDomain%28System.String%2CSystem.Security.Policy.Evidence%2CSystem.AppDomainSetup%2CSystem.Security.PermissionSet%2CSystem.Security.Policy.StrongName%5B%5D%29> sobrecarga del método para crear dominios de aplicación en espacio aislado.  
  
   
  
## Examples  
 El ejemplo siguiente muestra, en general, cómo crear un dominio mediante uno de los <xref:System.AppDomain.CreateDomain%2A> sobrecargas.  
  
 [!code-cpp[AppDomain_Setup#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_Setup/CPP/setup.cpp#1)]
 [!code-csharp[AppDomain_Setup#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_Setup/CS/setup.cs#1)]
 [!code-vb[AppDomain_Setup#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_Setup/VB/setup.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="friendlyName" /> es <see langword="null" />.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">para proporcionar evidencia. Enumeración asociada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="CreateDomain">
      <MemberSignature Language="C#" Value="public static AppDomain CreateDomain (string friendlyName, System.Security.Policy.Evidence securityInfo, string appBasePath, string appRelativeSearchPath, bool shadowCopyFiles, AppDomainInitializer adInit, string[] adInitArgs);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.AppDomain CreateDomain(string friendlyName, class System.Security.Policy.Evidence securityInfo, string appBasePath, string appRelativeSearchPath, bool shadowCopyFiles, class System.AppDomainInitializer adInit, string[] adInitArgs) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.String,System.String,System.Boolean,System.AppDomainInitializer,System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateDomain (friendlyName As String, securityInfo As Evidence, appBasePath As String, appRelativeSearchPath As String, shadowCopyFiles As Boolean, adInit As AppDomainInitializer, adInitArgs As String()) As AppDomain" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static AppDomain ^ CreateDomain(System::String ^ friendlyName, System::Security::Policy::Evidence ^ securityInfo, System::String ^ appBasePath, System::String ^ appRelativeSearchPath, bool shadowCopyFiles, AppDomainInitializer ^ adInit, cli::array &lt;System::String ^&gt; ^ adInitArgs);" />
      <MemberSignature Language="F#" Value="static member CreateDomain : string * System.Security.Policy.Evidence * string * string * bool * AppDomainInitializer * string[] -&gt; AppDomain" Usage="System.AppDomain.CreateDomain (friendlyName, securityInfo, appBasePath, appRelativeSearchPath, shadowCopyFiles, adInit, adInitArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.AppDomain</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="friendlyName" Type="System.String" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="securityInfo" Type="System.Security.Policy.Evidence" Index="1" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="appBasePath" Type="System.String" Index="2" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="appRelativeSearchPath" Type="System.String" Index="3" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="shadowCopyFiles" Type="System.Boolean" Index="4" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="adInit" Type="System.AppDomainInitializer" Index="5" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="adInitArgs" Type="System.String[]" Index="6" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="friendlyName">Nombre descriptivo del dominio. Este nombre descriptivo puede mostrarse en las interfaces de usuario para identificar el dominio. Para obtener más información, vea <see cref="P:System.AppDomain.FriendlyName" />.</param>
        <param name="securityInfo">Evidencia que establece la identidad del código que se ejecuta en el dominio de la aplicación. Pase <see langword="null" /> para que se use la evidencia del dominio de aplicación actual.</param>
        <param name="appBasePath">Directorio base que la resolución de ensamblado usa para buscar ensamblados. Para obtener más información, vea <see cref="P:System.AppDomain.BaseDirectory" />.</param>
        <param name="appRelativeSearchPath">Ruta de acceso correspondiente al directorio base donde la resolución de ensamblado debe buscar ensamblados privados. Para obtener más información, vea <see cref="P:System.AppDomain.RelativeSearchPath" />.</param>
        <param name="shadowCopyFiles">Es <see langword="true" /> para cargar una instantánea de un ensamblado en el dominio de aplicación.</param>
        <param name="adInit">Delegado <see cref="T:System.AppDomainInitializer" /> que representa un método de devolución de llamada que se va a invocar cuando se inicialice el nuevo objeto <see cref="T:System.AppDomain" />.</param>
        <param name="adInitArgs">Matriz de argumentos de cadena que se va a pasar a la devolución de llamada que representa <paramref name="adInit" /> cuando se inicialice el nuevo objeto <see cref="T:System.AppDomain" />.</param>
        <summary>Crea un nuevo dominio de aplicación con el nombre especificado usando la evidencia, la ruta de acceso base de la aplicación, la ruta de búsqueda relativa y un parámetro que especifica si debe cargarse una instantánea de un ensamblado en el dominio de aplicación. Especifica un método de devolución de llamada que se invoca cuando se inicializa el dominio de aplicación, así como una matriz de argumentos de cadena para pasar al método de devolución de llamada.</summary>
        <returns>Dominio de aplicación recién creado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El método representado por `adInit` se ejecuta en el contexto del dominio de aplicación recién creado.  
  
 Si `securityInfo` no es se proporciona, se utiliza la evidencia del dominio de aplicación actual.  
  
 Para obtener más información acerca de las instantáneas, vea <xref:System.AppDomain.ShadowCopyFiles%2A> y [copias sombra de ensamblados](~/docs/framework/app-domains/shadow-copy-assemblies.md).  
  
> [!IMPORTANT]
>  No utilice esta sobrecarga del método para crear dominios de aplicación en espacio aislado. A partir del [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], la evidencia suministrada para `securityInfo` ya no afecta al conjunto de permisos del dominio de la aplicación. Use el <xref:System.AppDomain.CreateDomain%28System.String%2CSystem.Security.Policy.Evidence%2CSystem.AppDomainSetup%2CSystem.Security.PermissionSet%2CSystem.Security.Policy.StrongName%5B%5D%29> sobrecarga del método para crear dominios de aplicación en espacio aislado.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="friendlyName" /> es <see langword="null" />.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">para proporcionar evidencia. Enumeración asociada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateInstance">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Crea una nueva instancia de un tipo especificado definido en un ensamblado especificado.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public System.Runtime.Remoting.ObjectHandle CreateInstance (string assemblyName, string typeName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Runtime.Remoting.ObjectHandle CreateInstance(string assemblyName, string typeName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateInstance(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateInstance (assemblyName As String, typeName As String) As ObjectHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Runtime::Remoting::ObjectHandle ^ CreateInstance(System::String ^ assemblyName, System::String ^ typeName);" />
      <MemberSignature Language="F#" Value="abstract member CreateInstance : string * string -&gt; System.Runtime.Remoting.ObjectHandle&#xA;override this.CreateInstance : string * string -&gt; System.Runtime.Remoting.ObjectHandle" Usage="appDomain.CreateInstance (assemblyName, typeName)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.CreateInstance(System.String,System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" Index="0" FrameworkAlternate="netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="typeName" Type="System.String" Index="1" FrameworkAlternate="netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="assemblyName">Nombre para mostrar del ensamblado. Vea <see cref="P:System.Reflection.Assembly.FullName" />.</param>
        <param name="typeName">Nombre completo del tipo solicitado, incluido el espacio de nombres, pero no el ensamblado, tal y como lo devuelve la propiedad <see cref="P:System.Type.FullName" />.</param>
        <summary>Crea una nueva instancia del tipo especificado definido en el ensamblado especificado.</summary>
        <returns>Objeto contenedor de la nueva instancia especificada por <paramref name="typeName" />. El valor devuelto debe desempaquetarse para obtener acceso al objeto real.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método llama al constructor predeterminado para `typeName`.  
  
 Consulte <xref:System.Reflection.AssemblyName> de formato de `assemblyName`.  
  
 Un intento de llamar a <xref:System.AppDomain.CreateInstance%2A> en un destino de dominio de aplicación que no sea el dominio de aplicación actual se producirá en una carga correcta del ensamblado en el dominio de aplicación de destino. Puesto que un <xref:System.Reflection.Assembly> no <xref:System.MarshalByRefObject>, cuando este método intente devolver el <xref:System.Reflection.Assembly> para el ensamblado cargado en el dominio de aplicación actual, common language runtime intenta cargar el ensamblado en el dominio de aplicación actual y el puede producir un error de carga. El ensamblado que se carga en el dominio de aplicación actual podría ser diferente del ensamblado que se cargó en primer lugar si los valores de ruta de acceso para los dos dominios de aplicación son diferentes.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException">La operación se intenta en un dominio de aplicación descargado.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="assemblyName" /> o <paramref name="typeName" /> es <see langword="null" />.</exception>
        <exception cref="T:System.BadImageFormatException"><paramref name="assemblyName" /> no es un ensamblado válido.  
  
O bien 
La versión 2.0 u otra posterior del Common Language Runtime está cargada actualmente y <paramref name="assemblyName" /> se compiló con una versión posterior.</exception>
        <exception cref="T:System.IO.FileLoadException">Se cargó un ensamblado o módulo dos veces con dos evidencias diferentes.</exception>
        <exception cref="T:System.IO.FileNotFoundException">No se encontró <paramref name="assemblyName" />.</exception>
        <exception cref="T:System.MethodAccessException">El llamador no tiene permiso para llamar a este constructor.</exception>
        <exception cref="T:System.MissingMethodException">No se encontró ningún constructor público coincidente.</exception>
        <exception cref="T:System.TypeLoadException">No se encontró <paramref name="typename" /> en <paramref name="assemblyName" />.</exception>
        <exception cref="T:System.NullReferenceException">La instancia es <see langword="null" />.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Para obtener acceso desde un archivo o directorio y para tener acceso a la información de la ruta de acceso de lectura. Enumeraciones asociadas: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</permission>
        <permission cref="T:System.Net.WebPermission">Para poder acceder a la ubicación del ensamblado si el ensamblado no es local.</permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Para poder llamar a código no administrado al crear una instancia de un delegado. Enumeración asociada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <altmember cref="M:System.Activator.CreateInstance(System.Type,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)" />
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public System.Runtime.Remoting.ObjectHandle CreateInstance (string assemblyName, string typeName, object[] activationAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Runtime.Remoting.ObjectHandle CreateInstance(string assemblyName, string typeName, object[] activationAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateInstance(System.String,System.String,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateInstance (assemblyName As String, typeName As String, activationAttributes As Object()) As ObjectHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Runtime::Remoting::ObjectHandle ^ CreateInstance(System::String ^ assemblyName, System::String ^ typeName, cli::array &lt;System::Object ^&gt; ^ activationAttributes);" />
      <MemberSignature Language="F#" Value="abstract member CreateInstance : string * string * obj[] -&gt; System.Runtime.Remoting.ObjectHandle&#xA;override this.CreateInstance : string * string * obj[] -&gt; System.Runtime.Remoting.ObjectHandle" Usage="appDomain.CreateInstance (assemblyName, typeName, activationAttributes)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.CreateInstance(System.String,System.String,System.Object[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" Index="0" FrameworkAlternate="netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="typeName" Type="System.String" Index="1" FrameworkAlternate="netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="activationAttributes" Type="System.Object[]" Index="2" FrameworkAlternate="netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="assemblyName">Nombre para mostrar del ensamblado. Vea <see cref="P:System.Reflection.Assembly.FullName" />.</param>
        <param name="typeName">Nombre completo del tipo solicitado, incluido el espacio de nombres, pero no el ensamblado, tal y como lo devuelve la propiedad <see cref="P:System.Type.FullName" />.</param>
        <param name="activationAttributes">Matriz de uno o más atributos que puede participar en la activación. Normalmente, una matriz que contiene un único objeto <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> que especifica la dirección URL necesaria para activar un objeto remoto.  
  
Este parámetro está relacionado con los objetos activados por el cliente. La activación por parte del cliente es una tecnología heredada que se conserva para la compatibilidad con versiones anteriores, pero no se recomienda para nuevo desarrollo. Las aplicaciones distribuidas deberían usar Windows Communication Foundation.</param>
        <summary>Crea una nueva instancia del tipo especificado definido en el ensamblado especificado. Un parámetro especifica una matriz de atributos de activación.</summary>
        <returns>Objeto contenedor de la nueva instancia especificada por <paramref name="typeName" />. El valor devuelto debe desempaquetarse para obtener acceso al objeto real.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método llama al constructor predeterminado para `typeName`.  
  
 Consulte <xref:System.Reflection.AssemblyName> de formato de `assemblyName`.  
  
 Un intento de llamar a <xref:System.AppDomain.CreateInstance%2A> en un destino de dominio de aplicación que no sea el dominio de aplicación actual se producirá en una carga correcta del ensamblado en el dominio de aplicación de destino. Puesto que un <xref:System.Reflection.Assembly> no <xref:System.MarshalByRefObject>, cuando este método intente devolver el <xref:System.Reflection.Assembly> para el ensamblado cargado en el dominio de aplicación actual, common language runtime intenta cargar el ensamblado en el dominio de aplicación actual y el puede producir un error de carga. El ensamblado que se carga en el dominio de aplicación actual podría ser diferente del ensamblado que se cargó en primer lugar si los valores de ruta de acceso para los dos dominios de aplicación son diferentes.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException">La operación se intenta en un dominio de aplicación descargado.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="assemblyName" /> o <paramref name="typeName" /> es <see langword="null" />.</exception>
        <exception cref="T:System.BadImageFormatException"><paramref name="assemblyName" /> no es un ensamblado válido.  
  
O bien 
La versión 2.0 u otra posterior del Common Language Runtime está cargada actualmente y <paramref name="assemblyName" /> se compiló con una versión posterior.</exception>
        <exception cref="T:System.IO.FileLoadException">Se cargó un ensamblado o módulo dos veces con dos evidencias diferentes.</exception>
        <exception cref="T:System.IO.FileNotFoundException">No se encontró <paramref name="assemblyName" />.</exception>
        <exception cref="T:System.MethodAccessException">El llamador no tiene permiso para llamar a este constructor.</exception>
        <exception cref="T:System.MissingMethodException">No se encontró ningún constructor público coincidente.</exception>
        <exception cref="T:System.NotSupportedException">El llamador no puede ofrecer atributos de activación para un objeto que no hereda de <see cref="T:System.MarshalByRefObject" />.</exception>
        <exception cref="T:System.TypeLoadException">No se encontró <paramref name="typename" /> en <paramref name="assemblyName" />.</exception>
        <exception cref="T:System.NullReferenceException">La instancia es <see langword="null" />.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermissionAccess">para que poder leer el archivo que contiene el manifiesto del ensamblado. Enumeración asociada: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Net.WebPermission">Para poder acceder a la ubicación del ensamblado si el ensamblado no es local.</permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Para poder llamar a código no administrado al crear una instancia de un delegado. Enumeración asociada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">la capacidad invocar operaciones en todos los miembros de tipo. Enumeración asociada: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="M:System.Activator.CreateInstance(System.Type,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)" />
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public System.Runtime.Remoting.ObjectHandle CreateInstance (string assemblyName, string typeName, bool ignoreCase, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Runtime.Remoting.ObjectHandle CreateInstance(string assemblyName, string typeName, bool ignoreCase, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, object[] args, class System.Globalization.CultureInfo culture, object[] activationAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateInstance(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Runtime::Remoting::ObjectHandle ^ CreateInstance(System::String ^ assemblyName, System::String ^ typeName, bool ignoreCase, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, cli::array &lt;System::Object ^&gt; ^ args, System::Globalization::CultureInfo ^ culture, cli::array &lt;System::Object ^&gt; ^ activationAttributes);" />
      <MemberSignature Language="F#" Value="member this.CreateInstance : string * string * bool * System.Reflection.BindingFlags * System.Reflection.Binder * obj[] * System.Globalization.CultureInfo * obj[] -&gt; System.Runtime.Remoting.ObjectHandle" Usage="appDomain.CreateInstance (assemblyName, typeName, ignoreCase, bindingAttr, binder, args, culture, activationAttributes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" Index="0" FrameworkAlternate="netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="typeName" Type="System.String" Index="1" FrameworkAlternate="netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="ignoreCase" Type="System.Boolean" Index="2" FrameworkAlternate="netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" Index="3" FrameworkAlternate="netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="binder" Type="System.Reflection.Binder" Index="4" FrameworkAlternate="netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="args" Type="System.Object[]" Index="5" FrameworkAlternate="netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" Index="6" FrameworkAlternate="netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="activationAttributes" Type="System.Object[]" Index="7" FrameworkAlternate="netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="assemblyName">Nombre para mostrar del ensamblado. Vea <see cref="P:System.Reflection.Assembly.FullName" />.</param>
        <param name="typeName">Nombre completo del tipo solicitado, incluido el espacio de nombres, pero no el ensamblado, tal y como lo devuelve la propiedad <see cref="P:System.Type.FullName" />.</param>
        <param name="ignoreCase">Valor booleano que especifica si va a realizarse una búsqueda con distinción de mayúsculas y minúsculas.</param>
        <param name="bindingAttr">Combinación de cero o más marcadores de bits que afectan a la búsqueda del constructor de <paramref name="typeName" />. Si <paramref name="bindingAttr" /> es cero, se realiza una búsqueda de constructores públicos que distingue mayúsculas de minúsculas.</param>
        <param name="binder">Objeto que permite el enlace, la conversión de tipos de argumentos, la invocación de miembros y la recuperación de objetos <see cref="T:System.Reflection.MemberInfo" /> mediante la reflexión. Si <paramref name="binder" /> es null, se usará el enlazador predeterminado.</param>
        <param name="args">Argumentos que se van a pasar al constructor. Esta matriz de argumentos debe coincidir en número, orden y tipo con los parámetros del constructor que se va a invocar. Si se prefiere usar el constructor predeterminado, <paramref name="args" /> debe ser una matriz vacía o null.</param>
        <param name="culture">Información específica de la referencia cultural que controla la conversión de <paramref name="args" /> en los tipos formales declarados para el constructor de <paramref name="typeName" />. Si <paramref name="culture" /> es <see langword="null" />, se usa <see cref="T:System.Globalization.CultureInfo" /> del subproceso actual.</param>
        <param name="activationAttributes">Matriz de uno o más atributos que puede participar en la activación. Normalmente, una matriz que contiene un único objeto <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> que especifica la dirección URL necesaria para activar un objeto remoto.  
  
Este parámetro está relacionado con los objetos activados por el cliente. La activación por parte del cliente es una tecnología heredada que se conserva por compatibilidad con versiones anteriores, pero no se recomienda para nuevo desarrollo. Las aplicaciones distribuidas deberían usar Windows Communication Foundation.</param>
        <summary>Crea una nueva instancia del tipo especificado definido en el ensamblado especificado. Los parámetros especifican un enlazador, marcas de enlace, argumentos de constructor, información específica de la referencia cultural usada para interpretar argumentos y atributos de activación opcionales.</summary>
        <returns>Objeto contenedor de la nueva instancia especificada por <paramref name="typeName" />. El valor devuelto debe desempaquetarse para obtener acceso al objeto real.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Consulte <xref:System.Reflection.AssemblyName> de formato de `assemblyName`.  
  
 Un intento de llamar a <xref:System.AppDomain.CreateInstance%2A> en un destino de dominio de aplicación que no sea el dominio de aplicación actual se producirá en una carga correcta del ensamblado en el dominio de aplicación de destino. Puesto que un <xref:System.Reflection.Assembly> no <xref:System.MarshalByRefObject>, cuando este método intente devolver el <xref:System.Reflection.Assembly> para el ensamblado cargado en el dominio de aplicación actual, common language runtime intenta cargar el ensamblado en el dominio de aplicación actual y el puede producir un error de carga. El ensamblado que se carga en el dominio de aplicación actual podría ser diferente del ensamblado que se cargó en primer lugar si los valores de ruta de acceso para los dos dominios de aplicación son diferentes.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException">La operación se intenta en un dominio de aplicación descargado.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="assemblyName" /> o <paramref name="typeName" /> es <see langword="null" />.</exception>
        <exception cref="T:System.BadImageFormatException"><paramref name="assemblyName" /> no es un ensamblado válido.  
  
O bien 
 <paramref name="assemblyName" /> se compiló con una versión de Common Language Runtime posterior a la versión que está cargada actualmente.</exception>
        <exception cref="T:System.IO.FileLoadException">Se cargó un ensamblado o módulo dos veces con dos evidencias diferentes.</exception>
        <exception cref="T:System.IO.FileNotFoundException">No se encontró <paramref name="assemblyName" />.</exception>
        <exception cref="T:System.MethodAccessException">El llamador no tiene permiso para llamar a este constructor.</exception>
        <exception cref="T:System.MissingMethodException">No se encontró ningún constructor coincidente.</exception>
        <exception cref="T:System.NotSupportedException">El llamador no puede ofrecer atributos de activación para un objeto que no hereda de <see cref="T:System.MarshalByRefObject" />.</exception>
        <exception cref="T:System.TypeLoadException">No se encontró <paramref name="typename" /> en <paramref name="assemblyName" />.</exception>
        <exception cref="T:System.NullReferenceException">La instancia es <see langword="null" />.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermissionAccess">para que poder leer el archivo que contiene el manifiesto del ensamblado. Enumeración asociada: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Net.WebPermission">Para poder acceder a la ubicación del ensamblado si el ensamblado no es local.</permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Para poder llamar a código no administrado al crear una instancia de un delegado. Enumeración asociada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">la capacidad invocar operaciones en todos los miembros de tipo. Enumeración asociada: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="M:System.Activator.CreateInstance(System.Type,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)" />
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public System.Runtime.Remoting.ObjectHandle CreateInstance (string assemblyName, string typeName, bool ignoreCase, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes, System.Security.Policy.Evidence securityAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Runtime.Remoting.ObjectHandle CreateInstance(string assemblyName, string typeName, bool ignoreCase, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, object[] args, class System.Globalization.CultureInfo culture, object[] activationAttributes, class System.Security.Policy.Evidence securityAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateInstance(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Runtime::Remoting::ObjectHandle ^ CreateInstance(System::String ^ assemblyName, System::String ^ typeName, bool ignoreCase, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, cli::array &lt;System::Object ^&gt; ^ args, System::Globalization::CultureInfo ^ culture, cli::array &lt;System::Object ^&gt; ^ activationAttributes, System::Security::Policy::Evidence ^ securityAttributes);" />
      <MemberSignature Language="F#" Value="abstract member CreateInstance : string * string * bool * System.Reflection.BindingFlags * System.Reflection.Binder * obj[] * System.Globalization.CultureInfo * obj[] * System.Security.Policy.Evidence -&gt; System.Runtime.Remoting.ObjectHandle&#xA;override this.CreateInstance : string * string * bool * System.Reflection.BindingFlags * System.Reflection.Binder * obj[] * System.Globalization.CultureInfo * obj[] * System.Security.Policy.Evidence -&gt; System.Runtime.Remoting.ObjectHandle" Usage="appDomain.CreateInstance (assemblyName, typeName, ignoreCase, bindingAttr, binder, args, culture, activationAttributes, securityAttributes)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.CreateInstance(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use an overload that does not take an Evidence parameter")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("Methods which use evidence to sandbox are obsolete and will be removed in a future release of the .NET Framework. Please use an overload of CreateInstance which does not take an Evidence parameter. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="typeName" Type="System.String" Index="1" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="ignoreCase" Type="System.Boolean" Index="2" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" Index="3" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="binder" Type="System.Reflection.Binder" Index="4" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="args" Type="System.Object[]" Index="5" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" Index="6" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="activationAttributes" Type="System.Object[]" Index="7" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="securityAttributes" Type="System.Security.Policy.Evidence" Index="8" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="assemblyName">Nombre para mostrar del ensamblado. Vea <see cref="P:System.Reflection.Assembly.FullName" />.</param>
        <param name="typeName">Nombre completo del tipo solicitado, incluido el espacio de nombres, pero no el ensamblado, tal y como lo devuelve la propiedad <see cref="P:System.Type.FullName" />.</param>
        <param name="ignoreCase">Valor booleano que especifica si va a realizarse una búsqueda con distinción de mayúsculas y minúsculas.</param>
        <param name="bindingAttr">Combinación de cero o más marcadores de bits que afectan a la búsqueda del constructor de <paramref name="typeName" />. Si <paramref name="bindingAttr" /> es cero, se realiza una búsqueda de constructores públicos que distingue mayúsculas de minúsculas.</param>
        <param name="binder">Objeto que permite el enlace, la conversión de tipos de argumentos, la invocación de miembros y la recuperación de objetos <see cref="T:System.Reflection.MemberInfo" /> mediante la reflexión. Si <paramref name="binder" /> es null, se usará el enlazador predeterminado.</param>
        <param name="args">Argumentos que se van a pasar al constructor. Esta matriz de argumentos debe coincidir en número, orden y tipo con los parámetros del constructor que se va a invocar. Si se prefiere usar el constructor predeterminado, <paramref name="args" /> debe ser una matriz vacía o null.</param>
        <param name="culture">Información específica de la referencia cultural que controla la conversión de <paramref name="args" /> en los tipos formales declarados para el constructor de <paramref name="typeName" />. Si <paramref name="culture" /> es <see langword="null" />, se usa <see cref="T:System.Globalization.CultureInfo" /> del subproceso actual.</param>
        <param name="activationAttributes">Matriz de uno o más atributos que puede participar en la activación. Normalmente, una matriz que contiene un único objeto <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> que especifica la dirección URL necesaria para activar un objeto remoto.  
  
Este parámetro está relacionado con los objetos activados por el cliente. La activación por parte del cliente es una tecnología heredada que se conserva para la compatibilidad con versiones anteriores, pero no se recomienda para nuevo desarrollo. Las aplicaciones distribuidas deberían usar Windows Communication Foundation.</param>
        <param name="securityAttributes">Información que se usa para autorizar la creación de <paramref name="typeName" />.</param>
        <summary>Crea una nueva instancia del tipo especificado definido en el ensamblado especificado. Los parámetros establecen un enlazador, marcas de enlace, argumentos de constructor, información específica de la referencia cultural usada para interpretar argumentos, atributos de activación y autorización para crear el tipo.</summary>
        <returns>Objeto contenedor de la nueva instancia especificada por <paramref name="typeName" />. El valor devuelto debe desempaquetarse para obtener acceso al objeto real.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Consulte <xref:System.Reflection.AssemblyName> de formato de `assemblyName`.  
  
 Un intento de llamar a <xref:System.AppDomain.CreateInstance%2A> en un destino de dominio de aplicación que no sea el dominio de aplicación actual se producirá en una carga correcta del ensamblado en el dominio de aplicación de destino. Puesto que un <xref:System.Reflection.Assembly> no <xref:System.MarshalByRefObject>, cuando este método intente devolver el <xref:System.Reflection.Assembly> para el ensamblado cargado en el dominio de aplicación actual, common language runtime intenta cargar el ensamblado en el dominio de aplicación actual y el puede producir un error de carga. El ensamblado que se carga en el dominio de aplicación actual podría ser diferente del ensamblado que se cargó en primer lugar si los valores de ruta de acceso para los dos dominios de aplicación son diferentes.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException">La operación se intenta en un dominio de aplicación descargado.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="assemblyName" /> o <paramref name="typeName" /> es <see langword="null" />.</exception>
        <exception cref="T:System.BadImageFormatException"><paramref name="assemblyName" /> no es un ensamblado válido.  
  
O bien 
La versión 2.0 u otra posterior del Common Language Runtime está cargada actualmente y <paramref name="assemblyName" /> se compiló con una versión posterior.</exception>
        <exception cref="T:System.IO.FileLoadException">Se cargó un ensamblado o módulo dos veces con dos evidencias diferentes.</exception>
        <exception cref="T:System.IO.FileNotFoundException">No se encontró <paramref name="assemblyName" />.</exception>
        <exception cref="T:System.MethodAccessException">El llamador no tiene permiso para llamar a este constructor.</exception>
        <exception cref="T:System.MissingMethodException">No se encontró ningún constructor coincidente.</exception>
        <exception cref="T:System.NotSupportedException">El llamador no puede ofrecer atributos de activación para un objeto que no hereda de <see cref="T:System.MarshalByRefObject" />.  
  
O bien 
 <paramref name="securityAttributes" /> no es <see langword="null" />. Si la directiva CAS heredada no está habilitada, <paramref name="securityAttributes" /> debería ser <see langword="null." /></exception>
        <exception cref="T:System.TypeLoadException">No se encontró <paramref name="typename" /> en <paramref name="assemblyName" />.</exception>
        <exception cref="T:System.NullReferenceException">La instancia es <see langword="null" />.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermissionAccess">para que poder leer el archivo que contiene el manifiesto del ensamblado. Enumeración asociada: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Net.WebPermission">Para poder acceder a la ubicación del ensamblado si el ensamblado no es local.</permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">para proporcionar evidencia. Enumeración asociada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</permission>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">la capacidad invocar operaciones en todos los miembros de tipo. Enumeración asociada: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="M:System.Activator.CreateInstance(System.Type,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateInstanceAndUnwrap">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Crea una nueva instancia del tipo especificado.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateInstanceAndUnwrap">
      <MemberSignature Language="C#" Value="public object CreateInstanceAndUnwrap (string assemblyName, string typeName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object CreateInstanceAndUnwrap(string assemblyName, string typeName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateInstanceAndUnwrap (assemblyName As String, typeName As String) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ CreateInstanceAndUnwrap(System::String ^ assemblyName, System::String ^ typeName);" />
      <MemberSignature Language="F#" Value="member this.CreateInstanceAndUnwrap : string * string -&gt; obj" Usage="appDomain.CreateInstanceAndUnwrap (assemblyName, typeName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" Index="0" FrameworkAlternate="netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="typeName" Type="System.String" Index="1" FrameworkAlternate="netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="assemblyName">Nombre para mostrar del ensamblado. Vea <see cref="P:System.Reflection.Assembly.FullName" />.</param>
        <param name="typeName">Nombre completo del tipo solicitado, incluido el espacio de nombres, pero no el ensamblado, tal y como lo devuelve la propiedad <see cref="P:System.Type.FullName" />.</param>
        <summary>Crea una nueva instancia del tipo especificado. Los parámetros especifican el ensamblado en el que se definen el tipo y el nombre del tipo.</summary>
        <returns>Instancia del objeto especificado por <paramref name="typeName" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se trata de un método de conveniencia que combina <xref:System.AppDomain.CreateInstance%2A> y <xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType>. Este método llama al constructor predeterminado para `typeName`.  
  
 Consulte <xref:System.Reflection.AssemblyName> de formato de `assemblyName`. Consulte la <xref:System.Type.FullName%2A?displayProperty=nameWithType> propiedad de formato de `typeName`.  
  
> [!NOTE]
>  Si realiza una llamada enlazada a un método `M` de un objeto de tipo `T1` que devolvió <xref:System.AppDomain.CreateInstanceAndUnwrap%2A>, y que el método realiza una llamada enlazada a un método de un objeto de tipo `T2` en un ensamblado `C` distinto el ensamblado actual o el ensamblado que contiene `T1`, ensamblado `C` se carga en el dominio de aplicación actual. Esta carga se produce incluso si el enlace anticipado llamada a `T1.M()` se realizó en el cuerpo de un <xref:System.Reflection.Emit.DynamicMethod>, o en otro código generado dinámicamente. Si el dominio actual es el dominio predeterminado, el ensamblado `C` no se puede descargar hasta que finaliza el proceso. Si más adelante, el dominio actual intenta cargar el ensamblado `C`, podría producir un error en la carga.  
  
   
  
## Examples  
 El ejemplo de código siguiente muestra la manera más sencilla para ejecutar código en otro dominio de aplicación. El ejemplo define una clase denominada `Worker` que hereda de <xref:System.MarshalByRefObject>. La `Worker` clase define un método que muestra el nombre del dominio de aplicación en el que se está ejecutando. El ejemplo crea instancias de `Worker` en el dominio de aplicación predeterminado y en un dominio de aplicación.  
  
> [!NOTE]
>  El ensamblado que contiene `Worker` deben cargarse en ambos dominios de aplicación, pero se pueden cargar otros ensamblados que solo existen en el nuevo dominio de aplicación.  
  
 [!code-cpp[CreateInstanceAndUnwrap2#1](~/samples/snippets/cpp/VS_Snippets_CLR/CreateInstanceAndUnwrap2/cpp/source.cpp#1)]
 [!code-csharp[CreateInstanceAndUnwrap2#1](~/samples/snippets/csharp/VS_Snippets_CLR/CreateInstanceAndUnwrap2/cs/source.cs#1)]
 [!code-vb[CreateInstanceAndUnwrap2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/CreateInstanceAndUnwrap2/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="assemblyName" /> o <paramref name="typeName" /> es <see langword="null" />.</exception>
        <exception cref="T:System.MissingMethodException">No se encontró ningún constructor público coincidente.</exception>
        <exception cref="T:System.TypeLoadException">No se encontró <paramref name="typename" /> en <paramref name="assemblyName" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">No se encontró <paramref name="assemblyName" />.</exception>
        <exception cref="T:System.MethodAccessException">El llamador no tiene permiso para llamar a este constructor.</exception>
        <exception cref="T:System.AppDomainUnloadedException">La operación se intenta en un dominio de aplicación descargado.</exception>
        <exception cref="T:System.BadImageFormatException"><paramref name="assemblyName" /> no es un ensamblado válido.  
  
O bien 
La versión 2.0 u otra posterior del Common Language Runtime está cargada actualmente y <paramref name="assemblyName" /> se compiló con una versión posterior.</exception>
        <exception cref="T:System.IO.FileLoadException">Se cargó un ensamblado o módulo dos veces con dos evidencias diferentes.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermissionAccess">Para poder leer el archivo que contiene el manifiesto del ensamblado, o si va a crear un tipo desde un módulo que no sea el archivo de manifiesto. Enumeración asociada: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Net.WebPermission">Para poder acceder a la ubicación del ensamblado si el ensamblado no es local.</permission>
        <altmember cref="M:System.AppDomain.CreateInstance(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="CreateInstanceAndUnwrap">
      <MemberSignature Language="C#" Value="public object CreateInstanceAndUnwrap (string assemblyName, string typeName, object[] activationAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object CreateInstanceAndUnwrap(string assemblyName, string typeName, object[] activationAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateInstanceAndUnwrap (assemblyName As String, typeName As String, activationAttributes As Object()) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ CreateInstanceAndUnwrap(System::String ^ assemblyName, System::String ^ typeName, cli::array &lt;System::Object ^&gt; ^ activationAttributes);" />
      <MemberSignature Language="F#" Value="member this.CreateInstanceAndUnwrap : string * string * obj[] -&gt; obj" Usage="appDomain.CreateInstanceAndUnwrap (assemblyName, typeName, activationAttributes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" Index="0" FrameworkAlternate="netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="typeName" Type="System.String" Index="1" FrameworkAlternate="netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="activationAttributes" Type="System.Object[]" Index="2" FrameworkAlternate="netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="assemblyName">Nombre para mostrar del ensamblado. Vea <see cref="P:System.Reflection.Assembly.FullName" />.</param>
        <param name="typeName">Nombre completo del tipo solicitado, incluido el espacio de nombres, pero no el ensamblado, tal y como lo devuelve la propiedad <see cref="P:System.Type.FullName" />.</param>
        <param name="activationAttributes">Matriz de uno o más atributos que puede participar en la activación. Normalmente, una matriz que contiene un único objeto <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> que especifica la dirección URL necesaria para activar un objeto remoto.  
  
Este parámetro está relacionado con los objetos activados por el cliente. La activación por parte del cliente es una tecnología heredada que se conserva para la compatibilidad con versiones anteriores, pero no se recomienda para nuevo desarrollo. Las aplicaciones distribuidas deberían usar Windows Communication Foundation.</param>
        <summary>Crea una nueva instancia del tipo especificado. Los parámetros especifican el ensamblado en el que se definen el tipo, el nombre del tipo y una matriz de atributos de activación.</summary>
        <returns>Instancia del objeto especificado por <paramref name="typeName" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se trata de un método de conveniencia que combina <xref:System.AppDomain.CreateInstance%2A> y <xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType>. Este método llama al constructor predeterminado para `typeName`.  
  
 Consulte <xref:System.Reflection.AssemblyName> de formato de `assemblyName`. Consulte la <xref:System.Type.FullName%2A?displayProperty=nameWithType> propiedad de formato de `typeName`.  
  
> [!NOTE]
>  Si realiza una llamada enlazada a un método `M` de un objeto de tipo `T1` que devolvió <xref:System.AppDomain.CreateInstanceAndUnwrap%2A>, y que el método realiza una llamada enlazada a un método de un objeto de tipo `T2` en un ensamblado `C` distinto el ensamblado actual o el ensamblado que contiene `T1`, ensamblado `C` se carga en el dominio de aplicación actual. Esta carga se produce incluso si el enlace anticipado llamada a `T1.M()` se realizó en el cuerpo de un <xref:System.Reflection.Emit.DynamicMethod>, o en otro código generado dinámicamente. Si el dominio actual es el dominio predeterminado, el ensamblado `C` no se puede descargar hasta que finaliza el proceso. Si más adelante, el dominio actual intenta cargar el ensamblado `C`, podría producir un error en la carga.  
  
   
  
## Examples  
 [!code-cpp[ADDyno#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADDyno/CPP/addyno.cpp#1)]
 [!code-csharp[ADDyno#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADDyno/CS/addyno.cs#1)]
 [!code-vb[ADDyno#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADDyno/VB/addyno.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="assemblyName" /> o <paramref name="typeName" /> es <see langword="null" />.</exception>
        <exception cref="T:System.MissingMethodException">No se encontró ningún constructor público coincidente.</exception>
        <exception cref="T:System.TypeLoadException">No se encontró <paramref name="typename" /> en <paramref name="assemblyName" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">No se encontró <paramref name="assemblyName" />.</exception>
        <exception cref="T:System.MethodAccessException">El llamador no tiene permiso para llamar a este constructor.</exception>
        <exception cref="T:System.NotSupportedException">El llamador no puede ofrecer atributos de activación para un objeto que no hereda de <see cref="T:System.MarshalByRefObject" />.</exception>
        <exception cref="T:System.AppDomainUnloadedException">La operación se intenta en un dominio de aplicación descargado.</exception>
        <exception cref="T:System.BadImageFormatException"><paramref name="assemblyName" /> no es un ensamblado válido.  
  
O bien 
La versión 2.0 u otra posterior del Common Language Runtime está cargada actualmente y <paramref name="assemblyName" /> se compiló con una versión posterior.</exception>
        <exception cref="T:System.IO.FileLoadException">Se cargó un ensamblado o módulo dos veces con dos evidencias diferentes.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermissionAccess">para que poder leer el archivo que contiene el manifiesto del ensamblado. Enumeración asociada: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Net.WebPermission">Para poder acceder a la ubicación del ensamblado si el ensamblado no es local.</permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Para poder llamar a código no administrado al crear una instancia de un delegado. Enumeración asociada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">la capacidad invocar operaciones en todos los miembros de tipo. Enumeración asociada: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="M:System.AppDomain.CreateInstance(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="CreateInstanceAndUnwrap">
      <MemberSignature Language="C#" Value="public object CreateInstanceAndUnwrap (string assemblyName, string typeName, bool ignoreCase, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object CreateInstanceAndUnwrap(string assemblyName, string typeName, bool ignoreCase, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, object[] args, class System.Globalization.CultureInfo culture, object[] activationAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ CreateInstanceAndUnwrap(System::String ^ assemblyName, System::String ^ typeName, bool ignoreCase, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, cli::array &lt;System::Object ^&gt; ^ args, System::Globalization::CultureInfo ^ culture, cli::array &lt;System::Object ^&gt; ^ activationAttributes);" />
      <MemberSignature Language="F#" Value="member this.CreateInstanceAndUnwrap : string * string * bool * System.Reflection.BindingFlags * System.Reflection.Binder * obj[] * System.Globalization.CultureInfo * obj[] -&gt; obj" Usage="appDomain.CreateInstanceAndUnwrap (assemblyName, typeName, ignoreCase, bindingAttr, binder, args, culture, activationAttributes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" Index="0" FrameworkAlternate="netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="typeName" Type="System.String" Index="1" FrameworkAlternate="netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="ignoreCase" Type="System.Boolean" Index="2" FrameworkAlternate="netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" Index="3" FrameworkAlternate="netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="binder" Type="System.Reflection.Binder" Index="4" FrameworkAlternate="netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="args" Type="System.Object[]" Index="5" FrameworkAlternate="netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" Index="6" FrameworkAlternate="netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="activationAttributes" Type="System.Object[]" Index="7" FrameworkAlternate="netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="assemblyName">Nombre para mostrar del ensamblado. Vea <see cref="P:System.Reflection.Assembly.FullName" />.</param>
        <param name="typeName">Nombre completo del tipo solicitado, incluido el espacio de nombres, pero no el ensamblado, tal y como lo devuelve la propiedad <see cref="P:System.Type.FullName" />.</param>
        <param name="ignoreCase">Valor booleano que especifica si va a realizarse una búsqueda con distinción de mayúsculas y minúsculas.</param>
        <param name="bindingAttr">Combinación de cero o más marcadores de bits que afectan a la búsqueda del constructor de <paramref name="typeName" />. Si <paramref name="bindingAttr" /> es cero, se realiza una búsqueda de constructores públicos que distingue mayúsculas de minúsculas.</param>
        <param name="binder">Objeto que permite el enlace, la conversión de tipos de argumentos, la invocación de miembros y la recuperación de objetos <see cref="T:System.Reflection.MemberInfo" /> mediante la reflexión. Si <paramref name="binder" /> es null, se usará el enlazador predeterminado.</param>
        <param name="args">Argumentos que se van a pasar al constructor. Esta matriz de argumentos debe coincidir en número, orden y tipo con los parámetros del constructor que se va a invocar. Si se prefiere usar el constructor predeterminado, <paramref name="args" /> debe ser una matriz vacía o null.</param>
        <param name="culture">Objeto específico de la referencia cultural que se usa para regir la conversión de tipos. Si <paramref name="culture" /> es <see langword="null" />, se usa <see langword="CultureInfo" /> del subproceso actual.</param>
        <param name="activationAttributes">Matriz de uno o más atributos que puede participar en la activación. Normalmente, una matriz que contiene un solo objeto <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" />. que especifica la dirección URL necesaria para activar un objeto remoto.  
  
Este parámetro está relacionado con los objetos activados por el cliente. La activación por parte del cliente es una tecnología heredada que se conserva por compatibilidad con versiones anteriores, pero no se recomienda para nuevo desarrollo. Las aplicaciones distribuidas deberían usar Windows Communication Foundation.</param>
        <summary>Crea una nueva instancia del tipo especificado definido en el ensamblado indicado, especificando si se pasa por alto el modelo de mayúsculas y minúsculas del nombre de tipo, los atributos de enlace y el enlazador que se usan para seleccionar el tipo que se va a crear, los argumentos del constructor, la referencia cultural y los atributos de activación.</summary>
        <returns>Instancia del objeto especificado por <paramref name="typeName" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se trata de un método de conveniencia que combina <xref:System.AppDomain.CreateInstance%2A> y <xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType>.  
  
 Consulte <xref:System.Reflection.AssemblyName> de formato de `assemblyName`. Consulte la <xref:System.Type.FullName%2A?displayProperty=nameWithType> propiedad de formato de `typeName`.  
  
> [!NOTE]
>  Si realiza una llamada enlazada a un método `M` de un objeto de tipo `T1` que devolvió <xref:System.AppDomain.CreateInstanceAndUnwrap%2A>, y que el método realiza una llamada enlazada a un método de un objeto de tipo `T2` en un ensamblado `C` distinto el ensamblado actual o el ensamblado que contiene `T1`, ensamblado `C` se carga en el dominio de aplicación actual. Esta carga se produce incluso si el enlace anticipado llamada a `T1.M()` se realizó en el cuerpo de un <xref:System.Reflection.Emit.DynamicMethod>, o en otro código generado dinámicamente. Si el dominio actual es el dominio predeterminado, el ensamblado `C` no se puede descargar hasta que finaliza el proceso. Si más adelante, el dominio actual intenta cargar el ensamblado `C`, podría producir un error en la carga.  
  
   
  
## Examples  
 El ejemplo siguiente muestra el uso de la `ignoreCase` parámetro.  
  
 [!code-cpp[AppDomain_CreateInstance_IgnoreCase#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_CreateInstance_IgnoreCase/CPP/ignorecase.cpp#1)]
 [!code-csharp[AppDomain_CreateInstance_IgnoreCase#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_CreateInstance_IgnoreCase/CS/ignorecase.cs#1)]
 [!code-vb[AppDomain_CreateInstance_IgnoreCase#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_CreateInstance_IgnoreCase/VB/ignorecase.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="assemblyName" /> o <paramref name="typeName" /> es <see langword="null" />.</exception>
        <exception cref="T:System.MissingMethodException">No se encontró ningún constructor coincidente.</exception>
        <exception cref="T:System.TypeLoadException">No se encontró <paramref name="typename" /> en <paramref name="assemblyName" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">No se encontró <paramref name="assemblyName" />.</exception>
        <exception cref="T:System.MethodAccessException">El llamador no tiene permiso para llamar a este constructor.</exception>
        <exception cref="T:System.NotSupportedException">El llamador no puede ofrecer atributos de activación para un objeto que no hereda de <see cref="T:System.MarshalByRefObject" />.</exception>
        <exception cref="T:System.AppDomainUnloadedException">La operación se intenta en un dominio de aplicación descargado.</exception>
        <exception cref="T:System.BadImageFormatException"><paramref name="assemblyName" /> no es un ensamblado válido.  
  
O bien 
 <paramref name="assemblyName" /> se compiló con una versión de Common Language Runtime posterior a la versión que está cargada actualmente.</exception>
        <exception cref="T:System.IO.FileLoadException">Se cargó un ensamblado o módulo dos veces con dos evidencias diferentes.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermissionAccess">para que poder leer el archivo que contiene el manifiesto del ensamblado. Enumeración asociada: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Net.WebPermission">Para poder acceder a la ubicación del ensamblado si el ensamblado no es local.</permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Para poder llamar a código no administrado al crear una instancia de un delegado. Enumeración asociada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">la capacidad invocar operaciones en todos los miembros de tipo. Enumeración asociada: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="M:System.AppDomain.CreateInstance(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="CreateInstanceAndUnwrap">
      <MemberSignature Language="C#" Value="public object CreateInstanceAndUnwrap (string assemblyName, string typeName, bool ignoreCase, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes, System.Security.Policy.Evidence securityAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object CreateInstanceAndUnwrap(string assemblyName, string typeName, bool ignoreCase, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, object[] args, class System.Globalization.CultureInfo culture, object[] activationAttributes, class System.Security.Policy.Evidence securityAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ CreateInstanceAndUnwrap(System::String ^ assemblyName, System::String ^ typeName, bool ignoreCase, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, cli::array &lt;System::Object ^&gt; ^ args, System::Globalization::CultureInfo ^ culture, cli::array &lt;System::Object ^&gt; ^ activationAttributes, System::Security::Policy::Evidence ^ securityAttributes);" />
      <MemberSignature Language="F#" Value="member this.CreateInstanceAndUnwrap : string * string * bool * System.Reflection.BindingFlags * System.Reflection.Binder * obj[] * System.Globalization.CultureInfo * obj[] * System.Security.Policy.Evidence -&gt; obj" Usage="appDomain.CreateInstanceAndUnwrap (assemblyName, typeName, ignoreCase, bindingAttr, binder, args, culture, activationAttributes, securityAttributes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use an overload that does not take an Evidence parameter")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("Methods which use evidence to sandbox are obsolete and will be removed in a future release of the .NET Framework. Please use an overload of CreateInstanceAndUnwrap which does not take an Evidence parameter. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="typeName" Type="System.String" Index="1" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="ignoreCase" Type="System.Boolean" Index="2" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" Index="3" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="binder" Type="System.Reflection.Binder" Index="4" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="args" Type="System.Object[]" Index="5" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" Index="6" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="activationAttributes" Type="System.Object[]" Index="7" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="securityAttributes" Type="System.Security.Policy.Evidence" Index="8" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="assemblyName">Nombre para mostrar del ensamblado. Vea <see cref="P:System.Reflection.Assembly.FullName" />.</param>
        <param name="typeName">Nombre completo del tipo solicitado, incluido el espacio de nombres, pero no el ensamblado, tal y como lo devuelve la propiedad <see cref="P:System.Type.FullName" />.</param>
        <param name="ignoreCase">Valor booleano que especifica si va a realizarse una búsqueda con distinción de mayúsculas y minúsculas.</param>
        <param name="bindingAttr">Combinación de cero o más marcadores de bits que afectan a la búsqueda del constructor de <paramref name="typeName" />. Si <paramref name="bindingAttr" /> es cero, se realiza una búsqueda de constructores públicos que distingue mayúsculas de minúsculas.</param>
        <param name="binder">Objeto que permite el enlace, la conversión de tipos de argumentos, la invocación de miembros y la recuperación de objetos <see cref="T:System.Reflection.MemberInfo" /> mediante la reflexión. Si <paramref name="binder" /> es null, se usará el enlazador predeterminado.</param>
        <param name="args">Argumentos que se van a pasar al constructor. Esta matriz de argumentos debe coincidir en número, orden y tipo con los parámetros del constructor que se va a invocar. Si se prefiere usar el constructor predeterminado, <paramref name="args" /> debe ser una matriz vacía o null.</param>
        <param name="culture">Objeto específico de la referencia cultural que se usa para regir la conversión de tipos. Si <paramref name="culture" /> es <see langword="null" />, se usa <see langword="CultureInfo" /> del subproceso actual.</param>
        <param name="activationAttributes">Matriz de uno o más atributos que puede participar en la activación. Normalmente, una matriz que contiene un único objeto <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> que especifica la dirección URL necesaria para activar un objeto remoto.  
  
Este parámetro está relacionado con los objetos activados por el cliente. La activación por parte del cliente es una tecnología heredada que se conserva por compatibilidad con versiones anteriores, pero no se recomienda para nuevo desarrollo. Las aplicaciones distribuidas deberían usar Windows Communication Foundation.</param>
        <param name="securityAttributes">Información que se usa para autorizar la creación de <paramref name="typeName" />.</param>
        <summary>Crea una nueva instancia del tipo especificado. Los parámetros especifican el nombre del tipo, así como la forma en que se encontró y se creó.</summary>
        <returns>Instancia del objeto especificado por <paramref name="typeName" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se trata de un método de conveniencia que combina <xref:System.AppDomain.CreateInstance%2A> y <xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType>.  
  
 Consulte <xref:System.Reflection.AssemblyName> de formato de `assemblyName`. Consulte la <xref:System.Type.FullName%2A?displayProperty=nameWithType> propiedad de formato de `typeName`.  
  
> [!NOTE]
>  Si realiza una llamada enlazada a un método `M` de un objeto de tipo `T1` que devolvió <xref:System.AppDomain.CreateInstanceAndUnwrap%2A>, y que el método realiza una llamada enlazada a un método de un objeto de tipo `T2` en un ensamblado `C` distinto el ensamblado actual o el ensamblado que contiene `T1`, ensamblado `C` se carga en el dominio de aplicación actual. Esta carga se produce incluso si el enlace anticipado llamada a `T1.M()` se realizó en el cuerpo de un <xref:System.Reflection.Emit.DynamicMethod>, o en otro código generado dinámicamente. Si el dominio actual es el dominio predeterminado, el ensamblado `C` no se puede descargar hasta que finaliza el proceso. Si más adelante, el dominio actual intenta cargar el ensamblado `C`, podría producir un error en la carga.  
  
   
  
## Examples  
 El ejemplo siguiente muestra el uso de la `ignoreCase` parámetro.  
  
 [!code-cpp[AppDomain_CreateInstance_IgnoreCase#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_CreateInstance_IgnoreCase/CPP/ignorecase.cpp#1)]
 [!code-csharp[AppDomain_CreateInstance_IgnoreCase#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_CreateInstance_IgnoreCase/CS/ignorecase.cs#1)]
 [!code-vb[AppDomain_CreateInstance_IgnoreCase#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_CreateInstance_IgnoreCase/VB/ignorecase.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="assemblyName" /> o <paramref name="typeName" /> es <see langword="null" />.</exception>
        <exception cref="T:System.MissingMethodException">No se encontró ningún constructor coincidente.</exception>
        <exception cref="T:System.TypeLoadException">No se encontró <paramref name="typename" /> en <paramref name="assemblyName" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">No se encontró <paramref name="assemblyName" />.</exception>
        <exception cref="T:System.MethodAccessException">El llamador no tiene permiso para llamar a este constructor.</exception>
        <exception cref="T:System.NotSupportedException">El llamador no puede ofrecer atributos de activación para un objeto que no hereda de <see cref="T:System.MarshalByRefObject" />.</exception>
        <exception cref="T:System.AppDomainUnloadedException">La operación se intenta en un dominio de aplicación descargado.</exception>
        <exception cref="T:System.BadImageFormatException"><paramref name="assemblyName" /> no es un ensamblado válido.  
  
O bien 
La versión 2.0 u otra posterior del Common Language Runtime está cargada actualmente y <paramref name="assemblyName" /> se compiló con una versión posterior.</exception>
        <exception cref="T:System.IO.FileLoadException">Se cargó un ensamblado o módulo dos veces con dos evidencias diferentes.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermissionAccess">para que poder leer el archivo que contiene el manifiesto del ensamblado. Enumeración asociada: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Net.WebPermission">Para poder acceder a la ubicación del ensamblado si el ensamblado no es local.</permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">para cargar un ensamblado con la evidencia. Enumeración asociada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</permission>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">la capacidad invocar operaciones en todos los miembros de tipo. Enumeración asociada: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="M:System.AppDomain.CreateInstance(System.String,System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateInstanceFrom">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Crea una nueva instancia de un tipo especificado definido en el archivo de ensamblado especificado.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateInstanceFrom">
      <MemberSignature Language="C#" Value="public System.Runtime.Remoting.ObjectHandle CreateInstanceFrom (string assemblyFile, string typeName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Runtime.Remoting.ObjectHandle CreateInstanceFrom(string assemblyFile, string typeName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateInstanceFrom(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateInstanceFrom (assemblyFile As String, typeName As String) As ObjectHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Runtime::Remoting::ObjectHandle ^ CreateInstanceFrom(System::String ^ assemblyFile, System::String ^ typeName);" />
      <MemberSignature Language="F#" Value="abstract member CreateInstanceFrom : string * string -&gt; System.Runtime.Remoting.ObjectHandle&#xA;override this.CreateInstanceFrom : string * string -&gt; System.Runtime.Remoting.ObjectHandle" Usage="appDomain.CreateInstanceFrom (assemblyFile, typeName)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.CreateInstanceFrom(System.String,System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" Index="0" FrameworkAlternate="netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="typeName" Type="System.String" Index="1" FrameworkAlternate="netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="assemblyFile">Nombre, incluida la ruta de acceso, de un archivo que contiene un ensamblado que define el tipo solicitado. El ensamblado se carga mediante el método <see cref="M:System.Reflection.Assembly.LoadFrom(System.String)" />.</param>
        <param name="typeName">Nombre completo del tipo solicitado, incluido el espacio de nombres, pero no el ensamblado, tal y como lo devuelve la propiedad <see cref="P:System.Type.FullName" />.</param>
        <summary>Crea una nueva instancia del tipo especificado definido en el archivo de ensamblado especificado.</summary>
        <returns>Objeto contenedor de la nueva instancia o <see langword="null" />, si no se encuentra el parámetro <paramref name="typeName" />. El valor devuelto debe desempaquetarse para obtener acceso al objeto real.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El constructor predeterminado para `typeName` se invoca.  
  
 Para obtener más información, vea el método <xref:System.Activator.CreateInstanceFrom%2A?displayProperty=nameWithType>.  
  
 Cuando el <xref:System.AppDomain.CreateInstanceFrom%2A> método se utiliza para crear una instancia en un dominio de aplicación de destino que no sea el dominio de aplicación desde el que se realiza la llamada, el ensamblado se carga en el dominio de aplicación de destino. Sin embargo, si la instancia está sin ajustar en el dominio de aplicación que realiza la llamada, utilizando la instancia sin ajustar en ciertos aspectos puede provocar que el ensamblado se carga en el dominio de aplicación que realiza la llamada. Por ejemplo, una vez sin ajustar la instancia, se podría solicitar su información de tipo, para poder llamar a sus métodos en tiempo de ejecución. Cuando el ensamblado se carga en el dominio de aplicación que realiza la llamada, se pueden producir excepciones.  
  
-   Si previamente se ha cargado otra versión del mismo ensamblado en el dominio de aplicación que realiza la llamada, o si la ruta de acceso de carga del dominio de aplicación que realiza la llamada es diferente del dominio de aplicación de destino, las excepciones, como <xref:System.MissingMethodException> pueden producirse.  
  
-   Si el dominio de aplicación que realiza la llamada realiza las llamadas enlazadas al tipo de instancia, <xref:System.InvalidCastException> se puede producir cuando se realiza un intento para convertir la instancia.  
  
   
  
## Examples  
 El ejemplo siguiente muestra cómo usar el <xref:System.AppDomain.CreateInstanceFrom%28System.String%2CSystem.String%29> sobrecarga del método para crear una instancia de un objeto en un dominio de aplicación de destino y llamar a sus métodos.  
  
 El ejemplo se define la `MarshallableExample` (clase), que se puede calcular referencias entre los límites del dominio de aplicación. En el ejemplo se crea una ruta de acceso al ensamblado actualmente en ejecución, crea un dominio de aplicación de destino y utiliza el <xref:System.AppDomain.CreateInstanceFrom%28System.String%2CSystem.String%29> sobrecarga del método para cargar el ensamblado de ejemplo en el dominio de aplicación de destino y crear una instancia de `MarshallableExample`.  
  
> [!NOTE]
>  La ruta de acceso es absoluta en este ejemplo, sin embargo, una ruta de acceso relativa también funcionaría porque el <xref:System.Reflection.Assembly.LoadFrom%2A?displayProperty=nameWithType> método se usa para cargar el ensamblado.  
  
 Después de la acción de desencapsular el identificador del objeto, el ejemplo demuestra tres formas de usar un objeto en un dominio de aplicación de destino:  
  
-   Invocar un método con el enlace en tiempo de ejecución, mediante la reflexión. Esto requiere información de tipo, lo que hace que el ensamblado se cargue en el dominio de aplicación del llamador. (En este ejemplo, que ya esté cargado.)  
  
-   Convierte el objeto en una interfaz conocida para el llamador y destinatario de la llamada. Si la interfaz se define en el ensamblado de llamada o en un ensamblado terceros al que hace referencia el llamador y destinatario de la llamada, el ensamblado llamado no se carga en el dominio de aplicación del llamador.  
  
-   Uso del objeto directamente cuando su tipo se conoce el llamador. El ensamblado deben cargarse en el dominio de aplicación del llamador.  
  
 Es otra manera de evitar la carga del ensamblado llamado en el dominio de aplicación del llamador del llamador se derivan de la <xref:System.MarshalByRefObject> clase y definir un método que se puede ejecutar en el dominio de aplicación de destino. Ese método puede usar la reflexión para examinar un ensamblado de destino, porque el ensamblado de destino ya está cargado en el dominio de aplicación de destino. Vea el ejemplo de la <xref:System.AppDomain.DynamicDirectory%2A> propiedad.  
  
 [!code-cpp[System.AppDomain.CreateInstanceFrom_StringString#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.appdomain.createinstancefrom_stringstring/cpp/example.cpp#1)]
 [!code-csharp[System.AppDomain.CreateInstanceFrom_StringString#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.appdomain.createinstancefrom_stringstring/cs/example.cs#1)]
 [!code-vb[System.AppDomain.CreateInstanceFrom_StringString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.appdomain.createinstancefrom_stringstring/vb/example.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="assemblyFile" /> es <see langword="null" />.  
  
O bien 
 <paramref name="typeName" /> es <see langword="null" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">No se encontró <paramref name="assemblyFile" />.</exception>
        <exception cref="T:System.TypeLoadException">No se encontró <paramref name="typeName" /> en <paramref name="assemblyFile" />.</exception>
        <exception cref="T:System.AppDomainUnloadedException">La operación se intenta en un dominio de aplicación descargado.</exception>
        <exception cref="T:System.MissingMethodException">No se ha encontrado ningún constructor público sin parámetros.</exception>
        <exception cref="T:System.MethodAccessException">El autor de la llamada no tiene permiso suficiente para llamar a este constructor.</exception>
        <exception cref="T:System.BadImageFormatException"><paramref name="assemblyFile" /> no es un ensamblado válido.  
  
O bien 
La versión 2.0 u otra posterior del Common Language Runtime está cargada actualmente y <paramref name="assemblyFile" /> se compiló con una versión posterior.</exception>
        <exception cref="T:System.IO.FileLoadException">Se cargó un ensamblado o módulo dos veces con dos evidencias diferentes.</exception>
        <exception cref="T:System.NullReferenceException">La instancia es <see langword="null" />.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermissionAccess">para que poder leer el archivo que contiene el manifiesto del ensamblado. Enumeración asociada: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Net.WebPermission">Para poder acceder a la ubicación del ensamblado si el ensamblado no es local.</permission>
        <altmember cref="M:System.Activator.CreateInstanceFrom(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="CreateInstanceFrom">
      <MemberSignature Language="C#" Value="public System.Runtime.Remoting.ObjectHandle CreateInstanceFrom (string assemblyFile, string typeName, object[] activationAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Runtime.Remoting.ObjectHandle CreateInstanceFrom(string assemblyFile, string typeName, object[] activationAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateInstanceFrom (assemblyFile As String, typeName As String, activationAttributes As Object()) As ObjectHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Runtime::Remoting::ObjectHandle ^ CreateInstanceFrom(System::String ^ assemblyFile, System::String ^ typeName, cli::array &lt;System::Object ^&gt; ^ activationAttributes);" />
      <MemberSignature Language="F#" Value="abstract member CreateInstanceFrom : string * string * obj[] -&gt; System.Runtime.Remoting.ObjectHandle&#xA;override this.CreateInstanceFrom : string * string * obj[] -&gt; System.Runtime.Remoting.ObjectHandle" Usage="appDomain.CreateInstanceFrom (assemblyFile, typeName, activationAttributes)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.CreateInstanceFrom(System.String,System.String,System.Object[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" Index="0" FrameworkAlternate="netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="typeName" Type="System.String" Index="1" FrameworkAlternate="netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="activationAttributes" Type="System.Object[]" Index="2" FrameworkAlternate="netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="assemblyFile">Nombre, incluida la ruta de acceso, de un archivo que contiene un ensamblado que define el tipo solicitado. El ensamblado se carga mediante el método <see cref="M:System.Reflection.Assembly.LoadFrom(System.String)" />.</param>
        <param name="typeName">Nombre completo del tipo solicitado, incluido el espacio de nombres, pero no el ensamblado, tal y como lo devuelve la propiedad <see cref="P:System.Type.FullName" />.</param>
        <param name="activationAttributes">Matriz de uno o más atributos que puede participar en la activación. Normalmente, una matriz que contiene un único objeto <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> que especifica la dirección URL necesaria para activar un objeto remoto.  
  
Este parámetro está relacionado con los objetos activados por el cliente. La activación por parte del cliente es una tecnología heredada que se conserva para la compatibilidad con versiones anteriores, pero no se recomienda para nuevo desarrollo. Las aplicaciones distribuidas deberían usar Windows Communication Foundation.</param>
        <summary>Crea una nueva instancia del tipo especificado definido en el archivo de ensamblado especificado.</summary>
        <returns>Objeto contenedor de la nueva instancia o <see langword="null" />, si no se encuentra el parámetro <paramref name="typeName" />. El valor devuelto debe desempaquetarse para obtener acceso al objeto real.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El constructor predeterminado para `typeName` se invoca.  
  
 Para obtener más información acerca de este método, consulte el <xref:System.Activator.CreateInstanceFrom%2A?displayProperty=nameWithType> método.  
  
 Cuando el <xref:System.AppDomain.CreateInstanceFrom%2A> método se utiliza para crear una instancia en un dominio de aplicación de destino que no sea el dominio de aplicación desde el que se realiza la llamada, el ensamblado se carga en el dominio de aplicación de destino. Sin embargo, si la instancia está sin ajustar en el dominio de aplicación que realiza la llamada, utilizando la instancia sin ajustar en ciertos aspectos puede provocar que el ensamblado se carga en el dominio de aplicación que realiza la llamada. Por ejemplo, una vez sin ajustar la instancia, se podría solicitar su información de tipo, para poder llamar a sus métodos en tiempo de ejecución. Cuando el ensamblado se carga en el dominio de aplicación que realiza la llamada, se pueden producir excepciones.  
  
-   Si previamente se ha cargado otra versión del mismo ensamblado en el dominio de aplicación que realiza la llamada, o si la ruta de acceso de carga del dominio de aplicación que realiza la llamada es diferente del dominio de aplicación de destino, las excepciones, como <xref:System.MissingMethodException> pueden producirse.  
  
-   Si el dominio de aplicación que realiza la llamada realiza las llamadas enlazadas al tipo de instancia, <xref:System.InvalidCastException> se puede producir cuando se realiza un intento para convertir la instancia.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="assemblyFile" /> es <see langword="null" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">No se encontró <paramref name="assemblyFile" />.</exception>
        <exception cref="T:System.TypeLoadException">No se encontró <paramref name="typeName" /> en <paramref name="assemblyFile" />.</exception>
        <exception cref="T:System.MethodAccessException">El autor de la llamada no tiene permiso suficiente para llamar a este constructor.</exception>
        <exception cref="T:System.MissingMethodException">No se encontró ningún constructor público coincidente.</exception>
        <exception cref="T:System.NotSupportedException">El llamador no puede ofrecer atributos de activación para un objeto que no hereda de <see cref="T:System.MarshalByRefObject" />.</exception>
        <exception cref="T:System.AppDomainUnloadedException">La operación se intenta en un dominio de aplicación descargado.</exception>
        <exception cref="T:System.BadImageFormatException"><paramref name="assemblyFile" /> no es un ensamblado válido.  
  
O bien 
La versión 2.0 u otra posterior del Common Language Runtime está cargada actualmente y <paramref name="assemblyFile" /> se compiló con una versión posterior.</exception>
        <exception cref="T:System.IO.FileLoadException">Se cargó un ensamblado o módulo dos veces con dos evidencias diferentes.</exception>
        <exception cref="T:System.NullReferenceException">La instancia es <see langword="null" />.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermissionAccess">para que poder leer el archivo que contiene el manifiesto del ensamblado. Enumeración asociada: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Net.WebPermission">Para poder acceder a la ubicación del ensamblado si el ensamblado no es local.</permission>
        <altmember cref="M:System.Activator.CreateInstanceFrom(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="CreateInstanceFrom">
      <MemberSignature Language="C#" Value="public System.Runtime.Remoting.ObjectHandle CreateInstanceFrom (string assemblyFile, string typeName, bool ignoreCase, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Runtime.Remoting.ObjectHandle CreateInstanceFrom(string assemblyFile, string typeName, bool ignoreCase, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, object[] args, class System.Globalization.CultureInfo culture, object[] activationAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Runtime::Remoting::ObjectHandle ^ CreateInstanceFrom(System::String ^ assemblyFile, System::String ^ typeName, bool ignoreCase, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, cli::array &lt;System::Object ^&gt; ^ args, System::Globalization::CultureInfo ^ culture, cli::array &lt;System::Object ^&gt; ^ activationAttributes);" />
      <MemberSignature Language="F#" Value="member this.CreateInstanceFrom : string * string * bool * System.Reflection.BindingFlags * System.Reflection.Binder * obj[] * System.Globalization.CultureInfo * obj[] -&gt; System.Runtime.Remoting.ObjectHandle" Usage="appDomain.CreateInstanceFrom (assemblyFile, typeName, ignoreCase, bindingAttr, binder, args, culture, activationAttributes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" Index="0" FrameworkAlternate="netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="typeName" Type="System.String" Index="1" FrameworkAlternate="netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="ignoreCase" Type="System.Boolean" Index="2" FrameworkAlternate="netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" Index="3" FrameworkAlternate="netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="binder" Type="System.Reflection.Binder" Index="4" FrameworkAlternate="netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="args" Type="System.Object[]" Index="5" FrameworkAlternate="netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" Index="6" FrameworkAlternate="netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="activationAttributes" Type="System.Object[]" Index="7" FrameworkAlternate="netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="assemblyFile">Nombre, incluida la ruta de acceso, de un archivo que contiene un ensamblado que define el tipo solicitado. El ensamblado se carga mediante el método <see cref="M:System.Reflection.Assembly.LoadFrom(System.String)" />.</param>
        <param name="typeName">Nombre completo del tipo solicitado, incluido el espacio de nombres, pero no el ensamblado, tal y como lo devuelve la propiedad <see cref="P:System.Type.FullName" />.</param>
        <param name="ignoreCase">Valor booleano que especifica si va a realizarse una búsqueda con distinción de mayúsculas y minúsculas.</param>
        <param name="bindingAttr">Combinación de cero o más marcadores de bits que afectan a la búsqueda del constructor de <paramref name="typeName" />. Si <paramref name="bindingAttr" /> es cero, se realiza una búsqueda de constructores públicos que distingue mayúsculas de minúsculas.</param>
        <param name="binder">Objeto que permite el enlace, la conversión de tipos de argumentos, la llamada de miembros y la recuperación de objetos <see cref="T:System.Reflection.MemberInfo" /> mediante reflexión. Si <paramref name="binder" /> es null, se usará el enlazador predeterminado.</param>
        <param name="args">Argumentos que se van a pasar al constructor. Esta matriz de argumentos debe coincidir en número, orden y tipo con los parámetros del constructor que se va a invocar. Si se prefiere usar el constructor predeterminado, <paramref name="args" /> debe ser una matriz vacía o null.</param>
        <param name="culture">Información específica de la referencia cultural que controla la conversión de <paramref name="args" /> en los tipos formales declarados para el constructor de <paramref name="typeName" />. Si <paramref name="culture" /> es <see langword="null" />, se usa <see cref="T:System.Globalization.CultureInfo" /> del subproceso actual.</param>
        <param name="activationAttributes">Matriz de uno o más atributos que puede participar en la activación. Normalmente, una matriz que contiene un único objeto <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> que especifica la dirección URL necesaria para activar un objeto remoto.  
  
Este parámetro está relacionado con los objetos activados por el cliente. La activación por parte del cliente es una tecnología heredada que se conserva por compatibilidad con versiones anteriores, pero no se recomienda para nuevo desarrollo. Las aplicaciones distribuidas deberían usar Windows Communication Foundation.</param>
        <summary>Crea una nueva instancia del tipo especificado definido en el archivo de ensamblado especificado.</summary>
        <returns>Objeto contenedor de la nueva instancia o <see langword="null" />, si no se encuentra el parámetro <paramref name="typeName" />. El valor devuelto debe desempaquetarse para obtener acceso al objeto real.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para obtener más información, vea el método <xref:System.Activator.CreateInstanceFrom%2A?displayProperty=nameWithType>.  
  
 Cuando el <xref:System.AppDomain.CreateInstanceFrom%2A> método se utiliza para crear una instancia en un dominio de aplicación de destino que no sea el dominio de aplicación desde el que se realiza la llamada, el ensamblado se carga en el dominio de aplicación de destino. Sin embargo, si la instancia está sin ajustar en el dominio de aplicación que realiza la llamada, utilizando la instancia sin ajustar en ciertos aspectos puede provocar que el ensamblado se carga en el dominio de aplicación que realiza la llamada. Por ejemplo, una vez sin ajustar la instancia, se podría solicitar su información de tipo, para poder llamar a sus métodos en tiempo de ejecución. Cuando el ensamblado se carga en el dominio de aplicación que realiza la llamada, se pueden producir excepciones.  
  
-   Si previamente se ha cargado otra versión del mismo ensamblado en el dominio de aplicación que realiza la llamada, o si la ruta de acceso de carga del dominio de aplicación que realiza la llamada es diferente del dominio de aplicación de destino, las excepciones, como <xref:System.MissingMethodException> pueden producirse.  
  
-   Si el dominio de aplicación que realiza la llamada realiza las llamadas enlazadas al tipo de instancia, <xref:System.InvalidCastException> se puede producir cuando se realiza un intento para convertir la instancia.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="assemblyFile" /> es <see langword="null" />.  
  
O bien 
 <paramref name="typeName" /> es <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException">El llamador no puede ofrecer atributos de activación para un objeto que no hereda de <see cref="T:System.MarshalByRefObject" />.</exception>
        <exception cref="T:System.AppDomainUnloadedException">La operación se intenta en un dominio de aplicación descargado.</exception>
        <exception cref="T:System.IO.FileNotFoundException">No se encontró <paramref name="assemblyFile" />.</exception>
        <exception cref="T:System.TypeLoadException">No se encontró <paramref name="typeName" /> en <paramref name="assemblyFile" />.</exception>
        <exception cref="T:System.MissingMethodException">No se encontró ningún constructor público coincidente.</exception>
        <exception cref="T:System.MethodAccessException">El autor de la llamada no tiene permiso suficiente para llamar a este constructor.</exception>
        <exception cref="T:System.BadImageFormatException"><paramref name="assemblyFile" /> no es un ensamblado válido.  
  
O bien 
 <paramref name="assemblyFile" /> se compiló con una versión de Common Language Runtime posterior a la versión que está cargada actualmente.</exception>
        <exception cref="T:System.IO.FileLoadException">Se cargó un ensamblado o módulo dos veces con dos evidencias diferentes.</exception>
        <exception cref="T:System.NullReferenceException">La instancia es <see langword="null" />.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermissionAccess">para que poder leer el archivo que contiene el manifiesto del ensamblado. Enumeración asociada: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Net.WebPermission">Para poder acceder a la ubicación del ensamblado si el ensamblado no es local.</permission>
        <altmember cref="M:System.Activator.CreateInstanceFrom(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="CreateInstanceFrom">
      <MemberSignature Language="C#" Value="public System.Runtime.Remoting.ObjectHandle CreateInstanceFrom (string assemblyFile, string typeName, bool ignoreCase, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes, System.Security.Policy.Evidence securityAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Runtime.Remoting.ObjectHandle CreateInstanceFrom(string assemblyFile, string typeName, bool ignoreCase, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, object[] args, class System.Globalization.CultureInfo culture, object[] activationAttributes, class System.Security.Policy.Evidence securityAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Runtime::Remoting::ObjectHandle ^ CreateInstanceFrom(System::String ^ assemblyFile, System::String ^ typeName, bool ignoreCase, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, cli::array &lt;System::Object ^&gt; ^ args, System::Globalization::CultureInfo ^ culture, cli::array &lt;System::Object ^&gt; ^ activationAttributes, System::Security::Policy::Evidence ^ securityAttributes);" />
      <MemberSignature Language="F#" Value="abstract member CreateInstanceFrom : string * string * bool * System.Reflection.BindingFlags * System.Reflection.Binder * obj[] * System.Globalization.CultureInfo * obj[] * System.Security.Policy.Evidence -&gt; System.Runtime.Remoting.ObjectHandle&#xA;override this.CreateInstanceFrom : string * string * bool * System.Reflection.BindingFlags * System.Reflection.Binder * obj[] * System.Globalization.CultureInfo * obj[] * System.Security.Policy.Evidence -&gt; System.Runtime.Remoting.ObjectHandle" Usage="appDomain.CreateInstanceFrom (assemblyFile, typeName, ignoreCase, bindingAttr, binder, args, culture, activationAttributes, securityAttributes)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use an overload that does not take an Evidence parameter")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("Methods which use evidence to sandbox are obsolete and will be removed in a future release of the .NET Framework. Please use an overload of CreateInstanceFrom which does not take an Evidence parameter. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="typeName" Type="System.String" Index="1" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="ignoreCase" Type="System.Boolean" Index="2" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" Index="3" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="binder" Type="System.Reflection.Binder" Index="4" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="args" Type="System.Object[]" Index="5" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" Index="6" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="activationAttributes" Type="System.Object[]" Index="7" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="securityAttributes" Type="System.Security.Policy.Evidence" Index="8" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="assemblyFile">Nombre, incluida la ruta de acceso, de un archivo que contiene un ensamblado que define el tipo solicitado. El ensamblado se carga mediante el método <see cref="M:System.Reflection.Assembly.LoadFrom(System.String)" />.</param>
        <param name="typeName">Nombre completo del tipo solicitado, incluido el espacio de nombres, pero no el ensamblado, tal y como lo devuelve la propiedad <see cref="P:System.Type.FullName" />.</param>
        <param name="ignoreCase">Valor booleano que especifica si va a realizarse una búsqueda con distinción de mayúsculas y minúsculas.</param>
        <param name="bindingAttr">Combinación de cero o más marcadores de bits que afectan a la búsqueda del constructor de <paramref name="typeName" />. Si <paramref name="bindingAttr" /> es cero, se realiza una búsqueda de constructores públicos que distingue mayúsculas de minúsculas.</param>
        <param name="binder">Objeto que permite el enlace, la conversión de tipos de argumentos, la llamada de miembros y la recuperación de objetos <see cref="T:System.Reflection.MemberInfo" /> mediante reflexión. Si <paramref name="binder" /> es null, se usará el enlazador predeterminado.</param>
        <param name="args">Argumentos que se van a pasar al constructor. Esta matriz de argumentos debe coincidir en número, orden y tipo con los parámetros del constructor que se va a invocar. Si se prefiere usar el constructor predeterminado, <paramref name="args" /> debe ser una matriz vacía o null.</param>
        <param name="culture">Información específica de la referencia cultural que controla la conversión de <paramref name="args" /> en los tipos formales declarados para el constructor de <paramref name="typeName" />. Si <paramref name="culture" /> es <see langword="null" />, se usa <see cref="T:System.Globalization.CultureInfo" /> del subproceso actual.</param>
        <param name="activationAttributes">Matriz de uno o más atributos que puede participar en la activación. Normalmente, una matriz que contiene un único objeto <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> que especifica la dirección URL necesaria para activar un objeto remoto.  
  
Este parámetro está relacionado con los objetos activados por el cliente. La activación por parte del cliente es una tecnología heredada que se conserva por compatibilidad con versiones anteriores, pero no se recomienda para nuevo desarrollo. Las aplicaciones distribuidas deberían usar Windows Communication Foundation.</param>
        <param name="securityAttributes">Información que se usa para autorizar la creación de <paramref name="typeName" />.</param>
        <summary>Crea una nueva instancia del tipo especificado definido en el archivo de ensamblado especificado.</summary>
        <returns>Objeto contenedor de la nueva instancia o <see langword="null" />, si no se encuentra el parámetro <paramref name="typeName" />. El valor devuelto debe desempaquetarse para obtener acceso al objeto real.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para obtener más información acerca de este método, consulte el <xref:System.Activator.CreateInstanceFrom%2A?displayProperty=nameWithType> método.  
  
 Cuando el <xref:System.AppDomain.CreateInstanceFrom%2A> método se utiliza para crear una instancia en un dominio de aplicación de destino que no sea el dominio de aplicación desde el que se realiza la llamada, el ensamblado se carga en el dominio de aplicación de destino. Sin embargo, si la instancia está sin ajustar en el dominio de aplicación que realiza la llamada, utilizando la instancia sin ajustar en ciertos aspectos puede provocar que el ensamblado se carga en el dominio de aplicación que realiza la llamada. Por ejemplo, una vez sin ajustar la instancia, se podría solicitar su información de tipo, para poder llamar a sus métodos en tiempo de ejecución. Cuando el ensamblado se carga en el dominio de aplicación que realiza la llamada, se pueden producir excepciones.  
  
-   Si previamente se ha cargado otra versión del mismo ensamblado en el dominio de aplicación que realiza la llamada, o si la ruta de acceso de carga del dominio de aplicación que realiza la llamada es diferente del dominio de aplicación de destino, las excepciones, como <xref:System.MissingMethodException> pueden producirse.  
  
-   Si el dominio de aplicación que realiza la llamada realiza las llamadas enlazadas al tipo de instancia, <xref:System.InvalidCastException> se puede producir cuando se realiza un intento para convertir la instancia.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="assemblyFile" /> es <see langword="null" />.  
  
O bien 
 <paramref name="typeName" /> es <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException">El llamador no puede ofrecer atributos de activación para un objeto que no hereda de <see cref="T:System.MarshalByRefObject" />.  
  
O bien 
 <paramref name="securityAttributes" /> no es <see langword="null" />. Cuando no se habilita la directiva CAS heredada, <paramref name="securityAttributes" /> debe ser <see langword="null" />.</exception>
        <exception cref="T:System.AppDomainUnloadedException">La operación se intenta en un dominio de aplicación descargado.</exception>
        <exception cref="T:System.IO.FileNotFoundException">No se encontró <paramref name="assemblyFile" />.</exception>
        <exception cref="T:System.TypeLoadException">No se encontró <paramref name="typeName" /> en <paramref name="assemblyFile" />.</exception>
        <exception cref="T:System.MissingMethodException">No se encontró ningún constructor público coincidente.</exception>
        <exception cref="T:System.MethodAccessException">El autor de la llamada no tiene permiso suficiente para llamar a este constructor.</exception>
        <exception cref="T:System.BadImageFormatException"><paramref name="assemblyFile" /> no es un ensamblado válido.  
  
O bien 
La versión 2.0 u otra posterior del Common Language Runtime está cargada actualmente y <paramref name="assemblyFile" /> se compiló con una versión posterior.</exception>
        <exception cref="T:System.IO.FileLoadException">Se cargó un ensamblado o módulo dos veces con dos evidencias diferentes.</exception>
        <exception cref="T:System.NullReferenceException">La instancia es <see langword="null" />.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermissionAccess">para que poder leer el archivo que contiene el manifiesto del ensamblado. Enumeración asociada: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Net.WebPermission">Para poder acceder a la ubicación del ensamblado si el ensamblado no es local.</permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">para proporcionar evidencia. Enumeración asociada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</permission>
        <altmember cref="M:System.Activator.CreateInstanceFrom(System.String,System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateInstanceFromAndUnwrap">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Crea una nueva instancia de un tipo especificado definido en el archivo de ensamblado especificado.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateInstanceFromAndUnwrap">
      <MemberSignature Language="C#" Value="public object CreateInstanceFromAndUnwrap (string assemblyName, string typeName);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object CreateInstanceFromAndUnwrap(string assemblyName, string typeName) cil managed" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String)" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateInstanceFromAndUnwrap (assemblyName As String, typeName As String) As Object" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ CreateInstanceFromAndUnwrap(System::String ^ assemblyName, System::String ^ typeName);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.CreateInstanceFromAndUnwrap : string * string -&gt; obj" Usage="appDomain.CreateInstanceFromAndUnwrap (assemblyName, typeName)" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C#" Value="public object CreateInstanceFromAndUnwrap (string assemblyFile, string typeName);" FrameworkAlternate="netcore-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object CreateInstanceFromAndUnwrap(string assemblyFile, string typeName) cil managed" FrameworkAlternate="netcore-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateInstanceFromAndUnwrap (assemblyFile As String, typeName As String) As Object" FrameworkAlternate="netcore-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ CreateInstanceFromAndUnwrap(System::String ^ assemblyFile, System::String ^ typeName);" FrameworkAlternate="netcore-3.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="assemblyFile" Type="System.String" Index="0" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="typeName" Type="System.String" Index="1" FrameworkAlternate="netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="assemblyName">Nombre de archivo y ruta de acceso del ensamblado que define el tipo solicitado.</param>
        <param name="assemblyFile">To be added.</param>
        <param name="typeName">Nombre completo del tipo solicitado, incluido el espacio de nombres, pero no el ensamblado, tal y como lo devuelve la propiedad <see cref="P:System.Type.FullName" />.</param>
        <summary>Crea una nueva instancia del tipo especificado definido en el archivo de ensamblado especificado.</summary>
        <returns>Objeto solicitado o <see langword="null" /> si no se encuentra <paramref name="typeName" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se trata de un método de conveniencia que combina <xref:System.AppDomain.CreateInstanceFrom%2A> y <xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType>. Este método llama al constructor predeterminado para `typeName`.  
  
 Para obtener más información, vea el método <xref:System.Activator.CreateInstanceFrom%2A?displayProperty=nameWithType>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="assemblyName" /> es <see langword="null" />.  
  
O bien 
 <paramref name="typeName" /> es <see langword="null" />.</exception>
        <exception cref="T:System.AppDomainUnloadedException">La operación se intenta en un dominio de aplicación descargado.</exception>
        <exception cref="T:System.IO.FileNotFoundException">No se encontró <paramref name="assemblyName" />.</exception>
        <exception cref="T:System.TypeLoadException">No se encontró <paramref name="typeName" /> en <paramref name="assemblyName" />.</exception>
        <exception cref="T:System.MissingMethodException">No se ha encontrado ningún constructor público sin parámetros.</exception>
        <exception cref="T:System.MethodAccessException">El autor de la llamada no tiene permiso suficiente para llamar a este constructor.</exception>
        <exception cref="T:System.BadImageFormatException"><paramref name="assemblyName" /> no es un ensamblado válido.  
  
O bien 
La versión 2.0 u otra posterior del Common Language Runtime está cargada actualmente y <paramref name="assemblyName" /> se compiló con una versión posterior.</exception>
        <exception cref="T:System.IO.FileLoadException">Se cargó un ensamblado o módulo dos veces con dos evidencias diferentes.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermissionAccess">para que poder leer el archivo que contiene el manifiesto del ensamblado. Enumeración asociada: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Net.WebPermission">Para poder acceder a la ubicación del ensamblado si el ensamblado no es local.</permission>
        <altmember cref="M:System.Activator.CreateInstanceFrom(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="CreateInstanceFromAndUnwrap">
      <MemberSignature Language="C#" Value="public object CreateInstanceFromAndUnwrap (string assemblyName, string typeName, object[] activationAttributes);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object CreateInstanceFromAndUnwrap(string assemblyName, string typeName, object[] activationAttributes) cil managed" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Object[])" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateInstanceFromAndUnwrap (assemblyName As String, typeName As String, activationAttributes As Object()) As Object" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ CreateInstanceFromAndUnwrap(System::String ^ assemblyName, System::String ^ typeName, cli::array &lt;System::Object ^&gt; ^ activationAttributes);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.CreateInstanceFromAndUnwrap : string * string * obj[] -&gt; obj" Usage="appDomain.CreateInstanceFromAndUnwrap (assemblyName, typeName, activationAttributes)" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C#" Value="public object CreateInstanceFromAndUnwrap (string assemblyFile, string typeName, object[] activationAttributes);" FrameworkAlternate="netcore-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object CreateInstanceFromAndUnwrap(string assemblyFile, string typeName, object[] activationAttributes) cil managed" FrameworkAlternate="netcore-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateInstanceFromAndUnwrap (assemblyFile As String, typeName As String, activationAttributes As Object()) As Object" FrameworkAlternate="netcore-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ CreateInstanceFromAndUnwrap(System::String ^ assemblyFile, System::String ^ typeName, cli::array &lt;System::Object ^&gt; ^ activationAttributes);" FrameworkAlternate="netcore-3.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="assemblyFile" Type="System.String" Index="0" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="typeName" Type="System.String" Index="1" FrameworkAlternate="netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="activationAttributes" Type="System.Object[]" Index="2" FrameworkAlternate="netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="assemblyName">Nombre de archivo y ruta de acceso del ensamblado que define el tipo solicitado.</param>
        <param name="assemblyFile">To be added.</param>
        <param name="typeName">Nombre completo del tipo solicitado, incluido el espacio de nombres pero no el ensamblado (vea la propiedad <see cref="P:System.Type.FullName" />).</param>
        <param name="activationAttributes">Matriz de uno o más atributos que puede participar en la activación. Normalmente, una matriz que contiene un único objeto <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> que especifica la dirección URL necesaria para activar un objeto remoto.  
  
Este parámetro está relacionado con los objetos activados por el cliente. La activación por parte del cliente es una tecnología heredada que se conserva para la compatibilidad con versiones anteriores, pero no se recomienda para nuevo desarrollo. Las aplicaciones distribuidas deberían usar Windows Communication Foundation.</param>
        <summary>Crea una nueva instancia del tipo especificado definido en el archivo de ensamblado especificado.</summary>
        <returns>Objeto solicitado o <see langword="null" /> si no se encuentra <paramref name="typeName" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se trata de un método de conveniencia que combina <xref:System.AppDomain.CreateInstanceFrom%2A> y <xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType>. Este método llama al constructor predeterminado para `typeName`.  
  
 Para obtener más información acerca de este método, consulte el <xref:System.Activator.CreateInstanceFrom%2A?displayProperty=nameWithType> método.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="assemblyName" /> es <see langword="null" />.  
  
O bien 
 <paramref name="typeName" /> es <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException">El llamador no puede ofrecer atributos de activación para un objeto que no hereda de <see cref="T:System.MarshalByRefObject" />.</exception>
        <exception cref="T:System.AppDomainUnloadedException">La operación se intenta en un dominio de aplicación descargado.</exception>
        <exception cref="T:System.IO.FileNotFoundException">No se encontró <paramref name="assemblyName" />.</exception>
        <exception cref="T:System.TypeLoadException">No se encontró <paramref name="typeName" /> en <paramref name="assemblyName" />.</exception>
        <exception cref="T:System.MissingMethodException">No se ha encontrado ningún constructor público sin parámetros.</exception>
        <exception cref="T:System.MethodAccessException">El autor de la llamada no tiene permiso suficiente para llamar a este constructor.</exception>
        <exception cref="T:System.BadImageFormatException"><paramref name="assemblyName" /> no es un ensamblado válido.  
  
O bien 
La versión 2.0 u otra posterior del Common Language Runtime está cargada actualmente y <paramref name="assemblyName" /> se compiló con una versión posterior.</exception>
        <exception cref="T:System.IO.FileLoadException">Se cargó un ensamblado o módulo dos veces con dos evidencias diferentes.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermissionAccess">para que poder leer el archivo que contiene el manifiesto del ensamblado. Enumeración asociada: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Net.WebPermission">Para poder acceder a la ubicación del ensamblado si el ensamblado no es local.</permission>
        <altmember cref="M:System.Activator.CreateInstanceFrom(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="CreateInstanceFromAndUnwrap">
      <MemberSignature Language="C#" Value="public object CreateInstanceFromAndUnwrap (string assemblyFile, string typeName, bool ignoreCase, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object CreateInstanceFromAndUnwrap(string assemblyFile, string typeName, bool ignoreCase, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, object[] args, class System.Globalization.CultureInfo culture, object[] activationAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ CreateInstanceFromAndUnwrap(System::String ^ assemblyFile, System::String ^ typeName, bool ignoreCase, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, cli::array &lt;System::Object ^&gt; ^ args, System::Globalization::CultureInfo ^ culture, cli::array &lt;System::Object ^&gt; ^ activationAttributes);" />
      <MemberSignature Language="F#" Value="member this.CreateInstanceFromAndUnwrap : string * string * bool * System.Reflection.BindingFlags * System.Reflection.Binder * obj[] * System.Globalization.CultureInfo * obj[] -&gt; obj" Usage="appDomain.CreateInstanceFromAndUnwrap (assemblyFile, typeName, ignoreCase, bindingAttr, binder, args, culture, activationAttributes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" Index="0" FrameworkAlternate="netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="typeName" Type="System.String" Index="1" FrameworkAlternate="netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="ignoreCase" Type="System.Boolean" Index="2" FrameworkAlternate="netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" Index="3" FrameworkAlternate="netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="binder" Type="System.Reflection.Binder" Index="4" FrameworkAlternate="netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="args" Type="System.Object[]" Index="5" FrameworkAlternate="netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" Index="6" FrameworkAlternate="netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="activationAttributes" Type="System.Object[]" Index="7" FrameworkAlternate="netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="assemblyFile">Nombre de archivo y ruta de acceso del ensamblado que define el tipo solicitado.</param>
        <param name="typeName">Nombre completo del tipo solicitado, incluido el espacio de nombres, pero no el ensamblado, tal y como lo devuelve la propiedad <see cref="P:System.Type.FullName" />.</param>
        <param name="ignoreCase">Valor booleano que especifica si va a realizarse una búsqueda con distinción de mayúsculas y minúsculas.</param>
        <param name="bindingAttr">Combinación de cero o más marcadores de bits que afectan a la búsqueda del constructor de <paramref name="typeName" />. Si <paramref name="bindingAttr" /> es cero, se realiza una búsqueda de constructores públicos que distingue mayúsculas de minúsculas.</param>
        <param name="binder">Objeto que permite el enlace, la conversión de tipos de argumentos, la llamada de miembros y la recuperación de objetos <see cref="T:System.Reflection.MemberInfo" /> mediante reflexión. Si <paramref name="binder" /> es null, se usará el enlazador predeterminado.</param>
        <param name="args">Argumentos que se van a pasar al constructor. Esta matriz de argumentos debe coincidir en número, orden y tipo con los parámetros del constructor que se va a invocar. Si se prefiere usar el constructor predeterminado, <paramref name="args" /> debe ser una matriz vacía o null.</param>
        <param name="culture">Información específica de la referencia cultural que controla la conversión de <paramref name="args" /> en los tipos formales declarados para el constructor de <paramref name="typeName" />. Si <paramref name="culture" /> es <see langword="null" />, se usa <see cref="T:System.Globalization.CultureInfo" /> del subproceso actual.</param>
        <param name="activationAttributes">Matriz de uno o más atributos que puede participar en la activación. Normalmente, una matriz que contiene un único objeto <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> que especifica la dirección URL necesaria para activar un objeto remoto.  
  
Este parámetro está relacionado con los objetos activados por el cliente. La activación por parte del cliente es una tecnología heredada que se conserva por compatibilidad con versiones anteriores, pero no se recomienda para nuevo desarrollo. Las aplicaciones distribuidas deberían usar Windows Communication Foundation.</param>
        <summary>Crea una nueva instancia del tipo especificado definido en el archivo de ensamblado indicado, especificando si se pasa por alto el modelo de mayúsculas y minúsculas del nombre de tipo, los atributos de enlace y el enlazador que se usan para seleccionar el tipo que se va a crear, los argumentos del constructor, la referencia cultural y los atributos de activación.</summary>
        <returns>Objeto solicitado o <see langword="null" /> si no se encuentra <paramref name="typeName" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se trata de un método de conveniencia que combina <xref:System.AppDomain.CreateInstanceFrom%2A> y <xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType>.  
  
 Para obtener más información acerca de este método, consulte el <xref:System.Activator.CreateInstanceFrom%2A?displayProperty=nameWithType> método.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="assemblyName" /> es <see langword="null" />.  
  
O bien 
 <paramref name="typeName" /> es <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException">El llamador no puede ofrecer atributos de activación para un objeto que no hereda de <see cref="T:System.MarshalByRefObject" />.</exception>
        <exception cref="T:System.AppDomainUnloadedException">La operación se intenta en un dominio de aplicación descargado.</exception>
        <exception cref="T:System.IO.FileNotFoundException">No se encontró <paramref name="assemblyName" />.</exception>
        <exception cref="T:System.TypeLoadException">No se encontró <paramref name="typeName" /> en <paramref name="assemblyName" />.</exception>
        <exception cref="T:System.MissingMethodException">No se encontró ningún constructor público coincidente.</exception>
        <exception cref="T:System.MethodAccessException">El autor de la llamada no tiene permiso suficiente para llamar a este constructor.</exception>
        <exception cref="T:System.BadImageFormatException"><paramref name="assemblyName" /> no es un ensamblado válido.  
  
O bien 
 <paramref name="assemblyName" /> se compiló con una versión de Common Language Runtime posterior a la versión que está cargada actualmente.</exception>
        <exception cref="T:System.IO.FileLoadException">Se cargó un ensamblado o módulo dos veces con dos evidencias diferentes.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermissionAccess">para que poder leer el archivo que contiene el manifiesto del ensamblado. Enumeración asociada: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Net.WebPermission">Para poder acceder a la ubicación del ensamblado si el ensamblado no es local.</permission>
        <altmember cref="M:System.Activator.CreateInstanceFrom(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="CreateInstanceFromAndUnwrap">
      <MemberSignature Language="C#" Value="public object CreateInstanceFromAndUnwrap (string assemblyName, string typeName, bool ignoreCase, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes, System.Security.Policy.Evidence securityAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object CreateInstanceFromAndUnwrap(string assemblyName, string typeName, bool ignoreCase, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, object[] args, class System.Globalization.CultureInfo culture, object[] activationAttributes, class System.Security.Policy.Evidence securityAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ CreateInstanceFromAndUnwrap(System::String ^ assemblyName, System::String ^ typeName, bool ignoreCase, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, cli::array &lt;System::Object ^&gt; ^ args, System::Globalization::CultureInfo ^ culture, cli::array &lt;System::Object ^&gt; ^ activationAttributes, System::Security::Policy::Evidence ^ securityAttributes);" />
      <MemberSignature Language="F#" Value="member this.CreateInstanceFromAndUnwrap : string * string * bool * System.Reflection.BindingFlags * System.Reflection.Binder * obj[] * System.Globalization.CultureInfo * obj[] * System.Security.Policy.Evidence -&gt; obj" Usage="appDomain.CreateInstanceFromAndUnwrap (assemblyName, typeName, ignoreCase, bindingAttr, binder, args, culture, activationAttributes, securityAttributes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use an overload that does not take an Evidence parameter")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("Methods which use evidence to sandbox are obsolete and will be removed in a future release of the .NET Framework. Please use an overload of CreateInstanceFromAndUnwrap which does not take an Evidence parameter. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="typeName" Type="System.String" Index="1" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="ignoreCase" Type="System.Boolean" Index="2" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" Index="3" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="binder" Type="System.Reflection.Binder" Index="4" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="args" Type="System.Object[]" Index="5" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" Index="6" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="activationAttributes" Type="System.Object[]" Index="7" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="securityAttributes" Type="System.Security.Policy.Evidence" Index="8" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="assemblyName">Nombre de archivo y ruta de acceso del ensamblado que define el tipo solicitado.</param>
        <param name="typeName">Nombre completo del tipo solicitado, incluido el espacio de nombres, pero no el ensamblado, tal y como lo devuelve la propiedad <see cref="P:System.Type.FullName" />.</param>
        <param name="ignoreCase">Valor booleano que especifica si va a realizarse una búsqueda con distinción de mayúsculas y minúsculas.</param>
        <param name="bindingAttr">Combinación de cero o más marcadores de bits que afectan a la búsqueda del constructor de <paramref name="typeName" />. Si <paramref name="bindingAttr" /> es cero, se realiza una búsqueda de constructores públicos que distingue mayúsculas de minúsculas.</param>
        <param name="binder">Objeto que permite el enlace, la conversión de tipos de argumentos, la llamada de miembros y la recuperación de objetos <see cref="T:System.Reflection.MemberInfo" /> mediante reflexión. Si <paramref name="binder" /> es null, se usará el enlazador predeterminado.</param>
        <param name="args">Argumentos que se van a pasar al constructor. Esta matriz de argumentos debe coincidir en número, orden y tipo con los parámetros del constructor que se va a invocar. Si se prefiere usar el constructor predeterminado, <paramref name="args" /> debe ser una matriz vacía o null.</param>
        <param name="culture">Información específica de la referencia cultural que controla la conversión de <paramref name="args" /> en los tipos formales declarados para el constructor de <paramref name="typeName" />. Si <paramref name="culture" /> es <see langword="null" />, se usa <see cref="T:System.Globalization.CultureInfo" /> del subproceso actual.</param>
        <param name="activationAttributes">Matriz de uno o más atributos que puede participar en la activación. Normalmente, una matriz que contiene un único objeto <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> que especifica la dirección URL necesaria para activar un objeto remoto.  
  
Este parámetro está relacionado con los objetos activados por el cliente. La activación por parte del cliente es una tecnología heredada que se conserva por compatibilidad con versiones anteriores, pero no se recomienda para nuevo desarrollo. Las aplicaciones distribuidas deberían usar Windows Communication Foundation.</param>
        <param name="securityAttributes">Información que se usa para autorizar la creación de <paramref name="typeName" />.</param>
        <summary>Crea una nueva instancia del tipo especificado definido en el archivo de ensamblado especificado.</summary>
        <returns>Objeto solicitado o <see langword="null" /> si no se encuentra <paramref name="typeName" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se trata de un método de conveniencia que combina <xref:System.AppDomain.CreateInstanceFrom%2A> y <xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType>.  
  
 Para obtener más información acerca de este método, consulte el <xref:System.Activator.CreateInstanceFrom%2A?displayProperty=nameWithType> método.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="assemblyName" /> es <see langword="null" />.  
  
O bien 
 <paramref name="typeName" /> es <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException">El llamador no puede ofrecer atributos de activación para un objeto que no hereda de <see cref="T:System.MarshalByRefObject" />.</exception>
        <exception cref="T:System.AppDomainUnloadedException">La operación se intenta en un dominio de aplicación descargado.</exception>
        <exception cref="T:System.IO.FileNotFoundException">No se encontró <paramref name="assemblyName" />.</exception>
        <exception cref="T:System.TypeLoadException">No se encontró <paramref name="typeName" /> en <paramref name="assemblyName" />.</exception>
        <exception cref="T:System.MissingMethodException">No se encontró ningún constructor público coincidente.</exception>
        <exception cref="T:System.MethodAccessException">El autor de la llamada no tiene permiso suficiente para llamar a este constructor.</exception>
        <exception cref="T:System.BadImageFormatException"><paramref name="assemblyName" /> no es un ensamblado válido.  
  
O bien 
La versión 2.0 u otra posterior del Common Language Runtime está cargada actualmente y <paramref name="assemblyName" /> se compiló con una versión posterior.</exception>
        <exception cref="T:System.IO.FileLoadException">Se cargó un ensamblado o módulo dos veces con dos evidencias diferentes.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermissionAccess">para que poder leer el archivo que contiene el manifiesto del ensamblado. Enumeración asociada: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Net.WebPermission">Para poder acceder a la ubicación del ensamblado si el ensamblado no es local.</permission>
        <altmember cref="M:System.Activator.CreateInstanceFrom(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="CurrentDomain">
      <MemberSignature Language="C#" Value="public static AppDomain CurrentDomain { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.AppDomain CurrentDomain" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.CurrentDomain" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property CurrentDomain As AppDomain" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property AppDomain ^ CurrentDomain { AppDomain ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.CurrentDomain : AppDomain" Usage="System.AppDomain.CurrentDomain" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.AppDomain</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene el actual dominio de aplicación del actual <see cref="T:System.Threading.Thread" />.</summary>
        <value>Dominio de aplicación actual.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 En el ejemplo de código siguiente se crea un nuevo dominio de aplicación. El <xref:System.AppDomain.CurrentDomain%2A> propiedad se utiliza para obtener un <xref:System.AppDomain> objeto que representa el dominio de aplicación actual. El <xref:System.AppDomain.FriendlyName%2A> proporciona el nombre de dominio de aplicación actual, que se muestra a continuación, en la línea de comandos.  
  
 [!code-cpp[ADApplicationBase#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADApplicationBase/CPP/adapplicationbase.cpp#1)]
 [!code-csharp[ADApplicationBase#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADApplicationBase/CS/adapplicationbase.cs#1)]
 [!code-vb[ADApplicationBase#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADApplicationBase/VB/adapplicationbase.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="DefineDynamicAssembly">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Define un ensamblado dinámico en el dominio de aplicación actual.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="DefineDynamicAssembly">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly(class System.Reflection.AssemblyName name, valuetype System.Reflection.Emit.AssemblyBuilderAccess access) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess)" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineDynamicAssembly (name As AssemblyName, access As AssemblyBuilderAccess) As AssemblyBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Emit::AssemblyBuilder ^ DefineDynamicAssembly(System::Reflection::AssemblyName ^ name, System::Reflection::Emit::AssemblyBuilderAccess access);" />
      <MemberSignature Language="F#" Value="abstract member DefineDynamicAssembly : System.Reflection.AssemblyName * System.Reflection.Emit.AssemblyBuilderAccess -&gt; System.Reflection.Emit.AssemblyBuilder&#xA;override this.DefineDynamicAssembly : System.Reflection.AssemblyName * System.Reflection.Emit.AssemblyBuilderAccess -&gt; System.Reflection.Emit.AssemblyBuilder" Usage="appDomain.DefineDynamicAssembly (name, access)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.AssemblyBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.Reflection.AssemblyName" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="access" Type="System.Reflection.Emit.AssemblyBuilderAccess" Index="1" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="name">Identidad única del ensamblado dinámico.</param>
        <param name="access">Modo de acceso del ensamblado dinámico.</param>
        <summary>Define un ensamblado dinámico con el nombre y modo de acceso especificados.</summary>
        <returns>Un ensamblado dinámico con el nombre y modo de acceso especificados.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método solo debe usarse para definir un ensamblado dinámico en el dominio de aplicación actual. Para obtener más información, consulte el <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29> sobrecarga del método.  
  
> [!NOTE]
>  Durante el desarrollo de código que emite ensamblados dinámicos, se recomienda que use una sobrecarga de la <xref:System.AppDomain.DefineDynamicAssembly%2A> método que especifica la evidencia y permisos, proporcione la evidencia que desea que el ensamblado dinámico tiene e incluir <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification?displayProperty=nameWithType> en `refusedPermissions`. Incluyendo <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification> en el `refusedPermissions` parámetro garantiza que se debe comprobar el código MSIL. Una limitación de esta técnica es que también hace que <xref:System.Security.SecurityException> se produce cuando se usa con el código que solicita plena confianza.  
  
   
  
## Examples  
 El ejemplo siguiente se muestra el <xref:System.AppDomain.DefineDynamicAssembly%2A> método y <xref:System.AppDomain.AssemblyResolve> eventos.  
  
 Para que poder ejecutar este ejemplo de código, debe proporcionar el nombre completo del ensamblado. Para obtener información acerca de cómo obtener el nombre completo del ensamblado, vea [nombres de ensamblado](~/docs/framework/app-domains/assembly-names.md).  
  
 [!code-cpp[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CPP/definedynamicassembly.cpp#1)]
 [!code-csharp[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CS/definedynamicassembly.cs#1)]
 [!code-vb[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/VB/definedynamicassembly.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">La propiedad <see langword="Name" /> de <paramref name="name" /> es <see langword="null" />.  
  
O bien 
La propiedad <see langword="Name" /> de <paramref name="name" /> empieza con un espacio en blanco o contiene una barra diagonal o una barra diagonal inversa.</exception>
        <exception cref="T:System.AppDomainUnloadedException">La operación se intenta en un dominio de aplicación descargado.</exception>
      </Docs>
    </Member>
    <Member MemberName="DefineDynamicAssembly">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, System.Collections.Generic.IEnumerable&lt;System.Reflection.Emit.CustomAttributeBuilder&gt; assemblyAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly(class System.Reflection.AssemblyName name, valuetype System.Reflection.Emit.AssemblyBuilderAccess access, class System.Collections.Generic.IEnumerable`1&lt;class System.Reflection.Emit.CustomAttributeBuilder&gt; assemblyAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder})" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineDynamicAssembly (name As AssemblyName, access As AssemblyBuilderAccess, assemblyAttributes As IEnumerable(Of CustomAttributeBuilder)) As AssemblyBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::AssemblyBuilder ^ DefineDynamicAssembly(System::Reflection::AssemblyName ^ name, System::Reflection::Emit::AssemblyBuilderAccess access, System::Collections::Generic::IEnumerable&lt;System::Reflection::Emit::CustomAttributeBuilder ^&gt; ^ assemblyAttributes);" />
      <MemberSignature Language="F#" Value="member this.DefineDynamicAssembly : System.Reflection.AssemblyName * System.Reflection.Emit.AssemblyBuilderAccess * seq&lt;System.Reflection.Emit.CustomAttributeBuilder&gt; -&gt; System.Reflection.Emit.AssemblyBuilder" Usage="appDomain.DefineDynamicAssembly (name, access, assemblyAttributes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.AssemblyBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.Reflection.AssemblyName" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="access" Type="System.Reflection.Emit.AssemblyBuilderAccess" Index="1" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="assemblyAttributes" Type="System.Collections.Generic.IEnumerable&lt;System.Reflection.Emit.CustomAttributeBuilder&gt;" Index="2" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="name">Identidad única del ensamblado dinámico.</param>
        <param name="access">Modo de acceso del ensamblado dinámico.</param>
        <param name="assemblyAttributes">Lista enumerable de atributos que se va a aplicarse al ensamblado o <see langword="null" /> si no hay ningún atributo.</param>
        <summary>Define un ensamblado dinámico con el nombre especificado, el modo de acceso y los atributos personalizados.</summary>
        <returns>Ensamblado dinámico con el nombre y las características especificados.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilice esta sobrecarga del método para especificar atributos que no funcionan correctamente a menos que se aplican cuando se crea un ensamblado dinámico. Por ejemplo, atributos, como seguridad <xref:System.Security.SecurityTransparentAttribute> y <xref:System.Security.SecurityCriticalAttribute> no funcionan correctamente si se agregan una vez creado un ensamblado dinámico.  
  
 Este método debe usarse únicamente para definir un ensamblado dinámico en el dominio de aplicación actual. Para obtener más información acerca de esta restricción, consulte el <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29> sobrecarga del método.  
  
 Esta sobrecarga del método se introdujo en la [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)].  
  
   
  
## Examples  
 Ejemplo de código siguiente muestra cómo crear un ensamblado dinámico que tiene el <xref:System.Security.SecurityTransparentAttribute>. El atributo debe especificarse como un elemento de una matriz de <xref:System.Reflection.Emit.CustomAttributeBuilder> objetos.  
  
 El primer paso para crear el <xref:System.Reflection.Emit.CustomAttributeBuilder> es obtener un constructor para el atributo. El constructor no tiene parámetros, por lo que la <xref:System.Type.GetConstructor%2A> se llama al método con una matriz vacía de <xref:System.Type> objetos que representan los tipos de los parámetros. El segundo paso consiste en pasar resultante <xref:System.Reflection.ConstructorInfo> objeto al constructor para la <xref:System.Reflection.Emit.CustomAttributeBuilder> (clase), junto con una matriz vacía de tipo <xref:System.Object> para representar los argumentos.  
  
 Resultante <xref:System.Reflection.Emit.CustomAttributeBuilder> , a continuación, se pasa a la <xref:System.AppDomain.DefineDynamicAssembly%2A> método como el único elemento de una matriz.  
  
 El código de ejemplo define un módulo y un tipo en el nuevo ensamblado dinámico y, a continuación, muestra los atributos del ensamblado.  
  
 [!code-cpp[DefineDynamicAssemblyWithAttributes#1](~/samples/snippets/cpp/VS_Snippets_CLR/DefineDynamicAssemblyWithAttributes/cpp/source.cpp#1)]
 [!code-csharp[DefineDynamicAssemblyWithAttributes#1](~/samples/snippets/csharp/VS_Snippets_CLR/DefineDynamicAssemblyWithAttributes/cs/source.cs#1)]
 [!code-vb[DefineDynamicAssemblyWithAttributes#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/DefineDynamicAssemblyWithAttributes/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">La propiedad <see langword="Name" /> de <paramref name="name" /> es <see langword="null" />.  
  
O bien 
La propiedad <see langword="Name" /> de <paramref name="name" /> empieza con un espacio en blanco o contiene una barra diagonal o una barra diagonal inversa.</exception>
        <exception cref="T:System.AppDomainUnloadedException">La operación se intenta en un dominio de aplicación descargado.</exception>
        <altmember cref="M:System.Reflection.Emit.AssemblyBuilder.SetCustomAttribute(System.Reflection.Emit.CustomAttributeBuilder)" />
      </Docs>
    </Member>
    <Member MemberName="DefineDynamicAssembly">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, System.Security.Policy.Evidence evidence);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly(class System.Reflection.AssemblyName name, valuetype System.Reflection.Emit.AssemblyBuilderAccess access, class System.Security.Policy.Evidence evidence) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.Policy.Evidence)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Emit::AssemblyBuilder ^ DefineDynamicAssembly(System::Reflection::AssemblyName ^ name, System::Reflection::Emit::AssemblyBuilderAccess access, System::Security::Policy::Evidence ^ evidence);" />
      <MemberSignature Language="F#" Value="abstract member DefineDynamicAssembly : System.Reflection.AssemblyName * System.Reflection.Emit.AssemblyBuilderAccess * System.Security.Policy.Evidence -&gt; System.Reflection.Emit.AssemblyBuilder&#xA;override this.DefineDynamicAssembly : System.Reflection.AssemblyName * System.Reflection.Emit.AssemblyBuilderAccess * System.Security.Policy.Evidence -&gt; System.Reflection.Emit.AssemblyBuilder" Usage="appDomain.DefineDynamicAssembly (name, access, evidence)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.Policy.Evidence)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Declarative security for assembly level is no longer enforced")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("Assembly level declarative security is obsolete and is no longer enforced by the CLR by default.  See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.AssemblyBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.Reflection.AssemblyName" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="access" Type="System.Reflection.Emit.AssemblyBuilderAccess" Index="1" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="evidence" Type="System.Security.Policy.Evidence" Index="2" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="name">Identidad única del ensamblado dinámico.</param>
        <param name="access">Modo de acceso al ensamblado dinámico.</param>
        <param name="evidence">Evidencia suministrada para el ensamblado dinámico. La evidencia se usa sin modificaciones como conjunto final de evidencia para la resolución de directivas.</param>
        <summary>Define un ensamblado dinámico usando el nombre especificado, el modo de acceso y la evidencia.</summary>
        <returns>Ensamblado dinámico con el nombre y las características especificados.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Solo de plena confianza para los llamadores pueden suministrar sus `evidence` al definir un dinámico <xref:System.Reflection.Assembly>. El tiempo de ejecución se asignará el <xref:System.Security.Policy.Evidence> a través de la directiva de seguridad para determinar los permisos concedidos. Los llamadores deben suministrar un valor null de confianza parcial `evidence`. Si `evidence` es `null`, el tiempo de ejecución copia los conjuntos de permisos, es decir, actual otorgar y denegar los conjuntos, desde el llamador <xref:System.Reflection.Assembly> a dinámico <xref:System.Reflection.Assembly> que se está definiendo y marca la directiva como resuelta.  
  
 Si el dinámico <xref:System.Reflection.Assembly> está guardado en el disco, carga posteriores obtendrán las concesiones en función de las directivas asociadas a la ubicación donde el <xref:System.Reflection.Assembly> se guardó.  
  
 Este método solo debe usarse para definir un ensamblado dinámico en el dominio de aplicación actual. Para obtener más información, consulte el <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29> sobrecarga del método.  
  
> [!NOTE]
>  Durante el desarrollo de código que emite ensamblados dinámicos, se recomienda que use una sobrecarga de la <xref:System.AppDomain.DefineDynamicAssembly%2A> método que especifica la evidencia y permisos, proporcione la evidencia que desea que el ensamblado dinámico tiene e incluir <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification?displayProperty=nameWithType> en `refusedPermissions`. Incluyendo <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification> en el `refusedPermissions` parámetro garantiza que se debe comprobar el código MSIL. Una limitación de esta técnica es que también hace que <xref:System.Security.SecurityException> se produce cuando se usa con el código que solicita plena confianza.  
  
   
  
## Examples  
 El ejemplo siguiente se muestra el <xref:System.AppDomain.DefineDynamicAssembly%2A> método y el <xref:System.AppDomain.AssemblyResolve> eventos.  
  
 En primer lugar, el ejemplo de código se intenta crear una instancia de `MyDynamicType` mediante una llamada a la <xref:System.AppDomain.CreateInstance%2A> método con un nombre de ensamblado no válido y detecta la excepción resultante.  
  
 El ejemplo de código, a continuación, agrega un controlador de eventos para el <xref:System.AppDomain.AssemblyResolve> eventos y vuelva a intenta crear una instancia de`MyDynamicType`. Durante la llamada a <xref:System.AppDomain.CreateInstance%2A>, el <xref:System.AppDomain.AssemblyResolve> evento se desencadena para el ensamblado no válido. El controlador de eventos crea un ensamblado dinámico que contiene un tipo denominado `MyDynamicType`, proporciona el tipo de un constructor sin parámetros y devuelve el nuevo ensamblado dinámico. La llamada a <xref:System.AppDomain.CreateInstance%2A> , a continuación, finaliza correctamente y el constructor para `MyDynamicType` muestra un mensaje en la consola.  
  
 [!code-cpp[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CPP/definedynamicassembly.cpp#1)]
 [!code-csharp[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CS/definedynamicassembly.cs#1)]
 [!code-vb[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/VB/definedynamicassembly.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">La propiedad <see langword="Name" /> de <paramref name="name" /> es <see langword="null" />.  
  
O bien 
La propiedad <see langword="Name" /> de <paramref name="name" /> empieza con un espacio en blanco o contiene una barra diagonal o una barra diagonal inversa.</exception>
        <exception cref="T:System.AppDomainUnloadedException">La operación se intenta en un dominio de aplicación descargado.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">para cargar un ensamblado con la evidencia. Enumeración asociada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="DefineDynamicAssembly">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, string dir);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly(class System.Reflection.AssemblyName name, valuetype System.Reflection.Emit.AssemblyBuilderAccess access, string dir) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineDynamicAssembly (name As AssemblyName, access As AssemblyBuilderAccess, dir As String) As AssemblyBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Emit::AssemblyBuilder ^ DefineDynamicAssembly(System::Reflection::AssemblyName ^ name, System::Reflection::Emit::AssemblyBuilderAccess access, System::String ^ dir);" />
      <MemberSignature Language="F#" Value="abstract member DefineDynamicAssembly : System.Reflection.AssemblyName * System.Reflection.Emit.AssemblyBuilderAccess * string -&gt; System.Reflection.Emit.AssemblyBuilder&#xA;override this.DefineDynamicAssembly : System.Reflection.AssemblyName * System.Reflection.Emit.AssemblyBuilderAccess * string -&gt; System.Reflection.Emit.AssemblyBuilder" Usage="appDomain.DefineDynamicAssembly (name, access, dir)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.AssemblyBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.Reflection.AssemblyName" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="access" Type="System.Reflection.Emit.AssemblyBuilderAccess" Index="1" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="dir" Type="System.String" Index="2" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="name">Identidad única del ensamblado dinámico.</param>
        <param name="access">Modo de acceso al ensamblado dinámico.</param>
        <param name="dir">Nombre del directorio donde se guardará el ensamblado. Si <paramref name="dir" /> es <see langword="null" />, el directorio predeterminado es el directorio actual.</param>
        <summary>Define un ensamblado dinámico usando el nombre especificado, el modo de acceso y el directorio de almacenamiento.</summary>
        <returns>Ensamblado dinámico con el nombre y las características especificados.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método solo debe usarse para definir un ensamblado dinámico en el dominio de aplicación actual. Para obtener más información, consulte el <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29> sobrecarga del método.  
  
> [!NOTE]
>  Durante el desarrollo de código que emite ensamblados dinámicos, se recomienda que use una sobrecarga de la <xref:System.AppDomain.DefineDynamicAssembly%2A> método que especifica la evidencia y permisos, proporcione la evidencia que desea que el ensamblado dinámico tiene e incluir <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification?displayProperty=nameWithType> en `refusedPermissions`. Incluyendo <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification> en el `refusedPermissions` parámetro garantiza que se debe comprobar el código MSIL. Una limitación de esta técnica es que también hace que <xref:System.Security.SecurityException> se produce cuando se usa con el código que solicita plena confianza.  
  
   
  
## Examples  
 El ejemplo siguiente se muestra el <xref:System.AppDomain.DefineDynamicAssembly%2A> método y <xref:System.AppDomain.AssemblyResolve> eventos.  
  
 Para que poder ejecutar este ejemplo de código, debe proporcionar el nombre completo del ensamblado. Para obtener información acerca de cómo obtener el nombre completo del ensamblado, vea [nombres de ensamblado](~/docs/framework/app-domains/assembly-names.md).  
  
 [!code-cpp[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CPP/definedynamicassembly.cpp#1)]
 [!code-csharp[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CS/definedynamicassembly.cs#1)]
 [!code-vb[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/VB/definedynamicassembly.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">La propiedad <see langword="Name" /> de <paramref name="name" /> es <see langword="null" />.  
  
O bien 
La propiedad <see langword="Name" /> de <paramref name="name" /> empieza con un espacio en blanco o contiene una barra diagonal o una barra diagonal inversa.</exception>
        <exception cref="T:System.AppDomainUnloadedException">La operación se intenta en un dominio de aplicación descargado.</exception>
      </Docs>
    </Member>
    <Member MemberName="DefineDynamicAssembly">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, System.Collections.Generic.IEnumerable&lt;System.Reflection.Emit.CustomAttributeBuilder&gt; assemblyAttributes, System.Security.SecurityContextSource securityContextSource);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly(class System.Reflection.AssemblyName name, valuetype System.Reflection.Emit.AssemblyBuilderAccess access, class System.Collections.Generic.IEnumerable`1&lt;class System.Reflection.Emit.CustomAttributeBuilder&gt; assemblyAttributes, valuetype System.Security.SecurityContextSource securityContextSource) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder},System.Security.SecurityContextSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::AssemblyBuilder ^ DefineDynamicAssembly(System::Reflection::AssemblyName ^ name, System::Reflection::Emit::AssemblyBuilderAccess access, System::Collections::Generic::IEnumerable&lt;System::Reflection::Emit::CustomAttributeBuilder ^&gt; ^ assemblyAttributes, System::Security::SecurityContextSource securityContextSource);" />
      <MemberSignature Language="F#" Value="member this.DefineDynamicAssembly : System.Reflection.AssemblyName * System.Reflection.Emit.AssemblyBuilderAccess * seq&lt;System.Reflection.Emit.CustomAttributeBuilder&gt; * System.Security.SecurityContextSource -&gt; System.Reflection.Emit.AssemblyBuilder" Usage="appDomain.DefineDynamicAssembly (name, access, assemblyAttributes, securityContextSource)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.AssemblyBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.Reflection.AssemblyName" Index="0" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="access" Type="System.Reflection.Emit.AssemblyBuilderAccess" Index="1" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="assemblyAttributes" Type="System.Collections.Generic.IEnumerable&lt;System.Reflection.Emit.CustomAttributeBuilder&gt;" Index="2" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="securityContextSource" Type="System.Security.SecurityContextSource" Index="3" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="name">Identidad única del ensamblado dinámico.</param>
        <param name="access">Modo de acceso del ensamblado dinámico.</param>
        <param name="assemblyAttributes">Lista enumerable de atributos que se va a aplicarse al ensamblado o <see langword="null" /> si no hay ningún atributo.</param>
        <param name="securityContextSource">Origen del contexto de seguridad.</param>
        <summary>Define un ensamblado dinámico con el nombre, el modo de acceso y los atributos personalizados especificados, y usando el origen indicado para su contexto de seguridad.</summary>
        <returns>Ensamblado dinámico con el nombre y las características especificados.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilice esta sobrecarga del método para especificar atributos que no funcionan correctamente a menos que se aplican cuando se crea un ensamblado dinámico. Por ejemplo, atributos, como seguridad <xref:System.Security.SecurityTransparentAttribute> y <xref:System.Security.SecurityCriticalAttribute> no funcionan correctamente si se agregan una vez creado un ensamblado dinámico.  
  
 Este método debe usarse únicamente para definir un ensamblado dinámico en el dominio de aplicación actual. Para obtener más información acerca de esta restricción, consulte el <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29> sobrecarga del método.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">La propiedad <see langword="Name" /> de <paramref name="name" /> es <see langword="null" />.  
  
O bien 
La propiedad <see langword="Name" /> de <paramref name="name" /> empieza con un espacio en blanco o contiene una barra diagonal o una barra diagonal inversa.</exception>
        <exception cref="T:System.AppDomainUnloadedException">La operación se intenta en un dominio de aplicación descargado.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">El valor de <paramref name="securityContextSource" /> no era ninguno de los valores de enumeración.</exception>
      </Docs>
    </Member>
    <Member MemberName="DefineDynamicAssembly">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, string dir, System.Security.Policy.Evidence evidence);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly(class System.Reflection.AssemblyName name, valuetype System.Reflection.Emit.AssemblyBuilderAccess access, string dir, class System.Security.Policy.Evidence evidence) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Emit::AssemblyBuilder ^ DefineDynamicAssembly(System::Reflection::AssemblyName ^ name, System::Reflection::Emit::AssemblyBuilderAccess access, System::String ^ dir, System::Security::Policy::Evidence ^ evidence);" />
      <MemberSignature Language="F#" Value="abstract member DefineDynamicAssembly : System.Reflection.AssemblyName * System.Reflection.Emit.AssemblyBuilderAccess * string * System.Security.Policy.Evidence -&gt; System.Reflection.Emit.AssemblyBuilder&#xA;override this.DefineDynamicAssembly : System.Reflection.AssemblyName * System.Reflection.Emit.AssemblyBuilderAccess * string * System.Security.Policy.Evidence -&gt; System.Reflection.Emit.AssemblyBuilder" Usage="appDomain.DefineDynamicAssembly (name, access, dir, evidence)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Declarative security for assembly level is no longer enforced")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("Methods which use evidence to sandbox are obsolete and will be removed in a future release of the .NET Framework. Please use an overload of DefineDynamicAssembly which does not take an Evidence parameter. See http://go.microsoft.com/fwlink/?LinkId=155570 for more information.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.AssemblyBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.Reflection.AssemblyName" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="access" Type="System.Reflection.Emit.AssemblyBuilderAccess" Index="1" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="dir" Type="System.String" Index="2" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="evidence" Type="System.Security.Policy.Evidence" Index="3" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="name">Identidad única del ensamblado dinámico.</param>
        <param name="access">Modo de acceso al ensamblado dinámico.</param>
        <param name="dir">Nombre del directorio donde se guardará el ensamblado. Si <paramref name="dir" /> es <see langword="null" />, el directorio predeterminado es el directorio actual.</param>
        <param name="evidence">Evidencia suministrada para el ensamblado dinámico. La evidencia se usa sin modificaciones como conjunto final de evidencia para la resolución de directivas.</param>
        <summary>Define un ensamblado dinámico usando el nombre especificado, el modo de acceso, el directorio de almacenamiento y la evidencia.</summary>
        <returns>Ensamblado dinámico con el nombre y las características especificados.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Solo de plena confianza para los llamadores pueden suministrar sus `evidence` al definir un dinámico <xref:System.Reflection.Assembly>. El tiempo de ejecución se asignará el <xref:System.Security.Policy.Evidence> a través de la directiva de seguridad para determinar los permisos concedidos. Los llamadores deben suministrar un valor null de confianza parcial `evidence`. Si `evidence` es `null`, el tiempo de ejecución copia los conjuntos de permisos, es decir, actual otorgar y denegar los conjuntos, desde el llamador <xref:System.Reflection.Assembly> a dinámico <xref:System.Reflection.Assembly> que se está definiendo y marca la directiva como resuelta.  
  
 Si el dinámico <xref:System.Reflection.Assembly> está guardado en el disco, carga posteriores obtendrán las concesiones en función de las directivas asociadas a la ubicación donde el <xref:System.Reflection.Assembly> se guardó.  
  
 Este método solo debe usarse para definir un ensamblado dinámico en el dominio de aplicación actual. Para obtener más información, consulte el <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29> sobrecarga del método.  
  
> [!NOTE]
>  Durante el desarrollo de código que emite ensamblados dinámicos, se recomienda que use una sobrecarga de la <xref:System.AppDomain.DefineDynamicAssembly%2A> método que especifica la evidencia y permisos, proporcione la evidencia que desea que el ensamblado dinámico tiene e incluir <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification?displayProperty=nameWithType> en `refusedPermissions`. Incluyendo <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification> en el `refusedPermissions` parámetro garantiza que se debe comprobar el código MSIL. Una limitación de esta técnica es que también hace que <xref:System.Security.SecurityException> se produce cuando se usa con el código que solicita plena confianza.  
  
   
  
## Examples  
 El ejemplo siguiente se muestra el <xref:System.AppDomain.DefineDynamicAssembly%2A> método y <xref:System.AppDomain.AssemblyResolve> eventos.  
  
 Para que poder ejecutar este ejemplo de código, debe proporcionar el nombre completo del ensamblado. Para obtener información acerca de cómo obtener el nombre completo del ensamblado, vea [nombres de ensamblado](~/docs/framework/app-domains/assembly-names.md).  
  
 [!code-cpp[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CPP/definedynamicassembly.cpp#1)]
 [!code-csharp[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CS/definedynamicassembly.cs#1)]
 [!code-vb[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/VB/definedynamicassembly.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">La propiedad <see langword="Name" /> de <paramref name="name" /> es <see langword="null" />.  
  
O bien 
La propiedad <see langword="Name" /> de <paramref name="name" /> empieza con un espacio en blanco o contiene una barra diagonal o una barra diagonal inversa.</exception>
        <exception cref="T:System.AppDomainUnloadedException">La operación se intenta en un dominio de aplicación descargado.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">para cargar un ensamblado con la evidencia. Enumeración asociada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="DefineDynamicAssembly">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, System.Security.PermissionSet requiredPermissions, System.Security.PermissionSet optionalPermissions, System.Security.PermissionSet refusedPermissions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly(class System.Reflection.AssemblyName name, valuetype System.Reflection.Emit.AssemblyBuilderAccess access, class System.Security.PermissionSet requiredPermissions, class System.Security.PermissionSet optionalPermissions, class System.Security.PermissionSet refusedPermissions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineDynamicAssembly (name As AssemblyName, access As AssemblyBuilderAccess, requiredPermissions As PermissionSet, optionalPermissions As PermissionSet, refusedPermissions As PermissionSet) As AssemblyBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Emit::AssemblyBuilder ^ DefineDynamicAssembly(System::Reflection::AssemblyName ^ name, System::Reflection::Emit::AssemblyBuilderAccess access, System::Security::PermissionSet ^ requiredPermissions, System::Security::PermissionSet ^ optionalPermissions, System::Security::PermissionSet ^ refusedPermissions);" />
      <MemberSignature Language="F#" Value="abstract member DefineDynamicAssembly : System.Reflection.AssemblyName * System.Reflection.Emit.AssemblyBuilderAccess * System.Security.PermissionSet * System.Security.PermissionSet * System.Security.PermissionSet -&gt; System.Reflection.Emit.AssemblyBuilder&#xA;override this.DefineDynamicAssembly : System.Reflection.AssemblyName * System.Reflection.Emit.AssemblyBuilderAccess * System.Security.PermissionSet * System.Security.PermissionSet * System.Security.PermissionSet -&gt; System.Reflection.Emit.AssemblyBuilder" Usage="appDomain.DefineDynamicAssembly (name, access, requiredPermissions, optionalPermissions, refusedPermissions)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Declarative security for assembly level is no longer enforced")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("Assembly level declarative security is obsolete and is no longer enforced by the CLR by default.  See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.AssemblyBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.Reflection.AssemblyName" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="access" Type="System.Reflection.Emit.AssemblyBuilderAccess" Index="1" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="requiredPermissions" Type="System.Security.PermissionSet" Index="2" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="optionalPermissions" Type="System.Security.PermissionSet" Index="3" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="refusedPermissions" Type="System.Security.PermissionSet" Index="4" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="name">Identidad única del ensamblado dinámico.</param>
        <param name="access">Modo de acceso al ensamblado dinámico.</param>
        <param name="requiredPermissions">Solicitud de permisos requeridos.</param>
        <param name="optionalPermissions">Solicitud de permisos opcionales.</param>
        <param name="refusedPermissions">Solicitud de permisos rechazados.</param>
        <summary>Define un ensamblado dinámico usando el nombre especificado, el modo de acceso y las solicitudes de permiso.</summary>
        <returns>Ensamblado dinámico con el nombre y las características especificados.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Las solicitudes de permisos especificadas para `requiredPermissions`, `optionalPermissions`, y `refusedPermissions` no se usan a menos que el ensamblado dinámico se ha guardado y vuelve a cargar en memoria. Para especificar las solicitudes de permiso para un ensamblado transitorio que nunca se guarda en disco, use una sobrecarga de la <xref:System.AppDomain.DefineDynamicAssembly%2A> método que especifica la evidencia como solicitado así como los permisos y proporcionar un <xref:System.Security.Policy.Evidence> objeto.  
  
> [!NOTE]
>  Durante el desarrollo de código que emite ensamblados dinámicos, se recomienda que use una sobrecarga de la <xref:System.AppDomain.DefineDynamicAssembly%2A> método que especifica la evidencia y permisos, proporcione la evidencia que desea que el ensamblado dinámico tiene e incluir <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification?displayProperty=nameWithType> en `refusedPermissions`. Incluyendo <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification> en el `refusedPermissions` parámetro garantiza que se debe comprobar el código MSIL. Una limitación de esta técnica es que también hace que <xref:System.Security.SecurityException> se produce cuando se usa con el código que solicita plena confianza.  
  
 Este método solo debe usarse para definir un ensamblado dinámico en el dominio de aplicación actual. Para obtener más información, consulte el <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29> sobrecarga del método.  
  
   
  
## Examples  
 El ejemplo siguiente se muestra el <xref:System.AppDomain.DefineDynamicAssembly%2A> método y <xref:System.AppDomain.AssemblyResolve> eventos.  
  
 Para que poder ejecutar este ejemplo de código, debe proporcionar el nombre completo del ensamblado. Para obtener información acerca de cómo obtener el nombre completo del ensamblado, vea [nombres de ensamblado](~/docs/framework/app-domains/assembly-names.md).  
  
 [!code-cpp[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CPP/definedynamicassembly.cpp#1)]
 [!code-csharp[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CS/definedynamicassembly.cs#1)]
 [!code-vb[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/VB/definedynamicassembly.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">La propiedad <see langword="Name" /> de <paramref name="name" /> es <see langword="null" />.  
  
O bien 
La propiedad <see langword="Name" /> de <paramref name="name" /> empieza con un espacio en blanco o contiene una barra diagonal o una barra diagonal inversa.</exception>
        <exception cref="T:System.AppDomainUnloadedException">La operación se intenta en un dominio de aplicación descargado.</exception>
      </Docs>
    </Member>
    <Member MemberName="DefineDynamicAssembly">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, string dir, bool isSynchronized, System.Collections.Generic.IEnumerable&lt;System.Reflection.Emit.CustomAttributeBuilder&gt; assemblyAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly(class System.Reflection.AssemblyName name, valuetype System.Reflection.Emit.AssemblyBuilderAccess access, string dir, bool isSynchronized, class System.Collections.Generic.IEnumerable`1&lt;class System.Reflection.Emit.CustomAttributeBuilder&gt; assemblyAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Boolean,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder})" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineDynamicAssembly (name As AssemblyName, access As AssemblyBuilderAccess, dir As String, isSynchronized As Boolean, assemblyAttributes As IEnumerable(Of CustomAttributeBuilder)) As AssemblyBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::AssemblyBuilder ^ DefineDynamicAssembly(System::Reflection::AssemblyName ^ name, System::Reflection::Emit::AssemblyBuilderAccess access, System::String ^ dir, bool isSynchronized, System::Collections::Generic::IEnumerable&lt;System::Reflection::Emit::CustomAttributeBuilder ^&gt; ^ assemblyAttributes);" />
      <MemberSignature Language="F#" Value="member this.DefineDynamicAssembly : System.Reflection.AssemblyName * System.Reflection.Emit.AssemblyBuilderAccess * string * bool * seq&lt;System.Reflection.Emit.CustomAttributeBuilder&gt; -&gt; System.Reflection.Emit.AssemblyBuilder" Usage="appDomain.DefineDynamicAssembly (name, access, dir, isSynchronized, assemblyAttributes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.AssemblyBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.Reflection.AssemblyName" Index="0" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="access" Type="System.Reflection.Emit.AssemblyBuilderAccess" Index="1" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="dir" Type="System.String" Index="2" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="isSynchronized" Type="System.Boolean" Index="3" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="assemblyAttributes" Type="System.Collections.Generic.IEnumerable&lt;System.Reflection.Emit.CustomAttributeBuilder&gt;" Index="4" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="name">Identidad única del ensamblado dinámico.</param>
        <param name="access">Modo de acceso al ensamblado dinámico.</param>
        <param name="dir">Nombre del directorio donde se guardará el ensamblado dinámico. Si <paramref name="dir" /> es <see langword="null" />, se usa el directorio actual.</param>
        <param name="isSynchronized"><see langword="true" /> para sincronizar la creación de módulos, tipos y miembros en el ensamblado dinámico; en caso contrario, <see langword="false" />.</param>
        <param name="assemblyAttributes">Lista enumerable de atributos que se va a aplicarse al ensamblado o <see langword="null" /> si no hay ningún atributo.</param>
        <summary>Define un ensamblado dinámico usando el nombre, el modo de acceso, el directorio de almacenamiento y la opción de sincronización especificados.</summary>
        <returns>Ensamblado dinámico con el nombre y las características especificados.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilice esta sobrecarga del método para especificar atributos que no funcionan correctamente a menos que se aplican cuando se crea un ensamblado dinámico. Por ejemplo, atributos, como seguridad <xref:System.Security.SecurityTransparentAttribute> y <xref:System.Security.SecurityCriticalAttribute> no funcionan correctamente si se agregan una vez creado un ensamblado dinámico.  
  
 Si `isSynchronized` es `true`, los métodos siguientes de resultante <xref:System.Reflection.Emit.AssemblyBuilder> se sincronizarán: <xref:System.Reflection.Emit.AssemblyBuilder.DefineDynamicModule%2A>, <xref:System.Reflection.Emit.AssemblyBuilder.DefineResource%2A>, <xref:System.Reflection.Emit.AssemblyBuilder.AddResourceFile%2A>, <xref:System.Reflection.Emit.AssemblyBuilder.GetDynamicModule%2A>, <xref:System.Reflection.Emit.AssemblyBuilder.SetEntryPoint%2A>, y <xref:System.Reflection.Emit.AssemblyBuilder.Save%2A>. Si dos de estos métodos se llaman en subprocesos diferentes, uno se bloqueará hasta que se complete la otra.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">La propiedad <see langword="Name" /> de <paramref name="name" /> es <see langword="null" />.  
  
O bien 
La propiedad <see langword="Name" /> de <paramref name="name" /> empieza con un espacio en blanco o contiene una barra diagonal o una barra diagonal inversa.</exception>
        <exception cref="T:System.AppDomainUnloadedException">La operación se intenta en un dominio de aplicación descargado.</exception>
        <altmember cref="M:System.Reflection.Emit.AssemblyBuilder.SetCustomAttribute(System.Reflection.Emit.CustomAttributeBuilder)" />
      </Docs>
    </Member>
    <Member MemberName="DefineDynamicAssembly">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, System.Security.Policy.Evidence evidence, System.Security.PermissionSet requiredPermissions, System.Security.PermissionSet optionalPermissions, System.Security.PermissionSet refusedPermissions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly(class System.Reflection.AssemblyName name, valuetype System.Reflection.Emit.AssemblyBuilderAccess access, class System.Security.Policy.Evidence evidence, class System.Security.PermissionSet requiredPermissions, class System.Security.PermissionSet optionalPermissions, class System.Security.PermissionSet refusedPermissions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Emit::AssemblyBuilder ^ DefineDynamicAssembly(System::Reflection::AssemblyName ^ name, System::Reflection::Emit::AssemblyBuilderAccess access, System::Security::Policy::Evidence ^ evidence, System::Security::PermissionSet ^ requiredPermissions, System::Security::PermissionSet ^ optionalPermissions, System::Security::PermissionSet ^ refusedPermissions);" />
      <MemberSignature Language="F#" Value="abstract member DefineDynamicAssembly : System.Reflection.AssemblyName * System.Reflection.Emit.AssemblyBuilderAccess * System.Security.Policy.Evidence * System.Security.PermissionSet * System.Security.PermissionSet * System.Security.PermissionSet -&gt; System.Reflection.Emit.AssemblyBuilder&#xA;override this.DefineDynamicAssembly : System.Reflection.AssemblyName * System.Reflection.Emit.AssemblyBuilderAccess * System.Security.Policy.Evidence * System.Security.PermissionSet * System.Security.PermissionSet * System.Security.PermissionSet -&gt; System.Reflection.Emit.AssemblyBuilder" Usage="appDomain.DefineDynamicAssembly (name, access, evidence, requiredPermissions, optionalPermissions, refusedPermissions)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Declarative security for assembly level is no longer enforced")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("Assembly level declarative security is obsolete and is no longer enforced by the CLR by default. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.AssemblyBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.Reflection.AssemblyName" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="access" Type="System.Reflection.Emit.AssemblyBuilderAccess" Index="1" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="evidence" Type="System.Security.Policy.Evidence" Index="2" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="requiredPermissions" Type="System.Security.PermissionSet" Index="3" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="optionalPermissions" Type="System.Security.PermissionSet" Index="4" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="refusedPermissions" Type="System.Security.PermissionSet" Index="5" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="name">Identidad única del ensamblado dinámico.</param>
        <param name="access">Modo de acceso al ensamblado dinámico.</param>
        <param name="evidence">Evidencia suministrada para el ensamblado dinámico. La evidencia se usa sin modificaciones como conjunto final de evidencia para la resolución de directivas.</param>
        <param name="requiredPermissions">Solicitud de permisos requeridos.</param>
        <param name="optionalPermissions">Solicitud de permisos opcionales.</param>
        <param name="refusedPermissions">Solicitud de permisos rechazados.</param>
        <summary>Define un ensamblado dinámico usando el nombre especificado, el modo de acceso, la evidencia y las solicitudes de permiso.</summary>
        <returns>Ensamblado dinámico con el nombre y las características especificados.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Las solicitudes de permisos especificadas para `requiredPermissions`, `optionalPermissions`, y `refusedPermissions` sólo se utilizan si `evidence` también se proporciona, o si el ensamblado dinámico se guarda y vuelve a cargar en memoria.  
  
> [!NOTE]
>  Durante el desarrollo de código que emite ensamblados dinámicos, se recomienda que incluya <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification?displayProperty=nameWithType> en `refusedPermissions`. Incluyendo <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification> en el `refusedPermissions` parámetro garantiza que se debe comprobar el código MSIL. Una limitación de esta técnica es que también hace que <xref:System.Security.SecurityException> se produce cuando se usa con el código que solicita plena confianza.  
  
 Solo de plena confianza para los llamadores pueden suministrar sus `evidence` al definir un dinámico <xref:System.Reflection.Assembly>. El tiempo de ejecución se asignará el <xref:System.Security.Policy.Evidence> a través de la directiva de seguridad para determinar los permisos concedidos. Los llamadores deben suministrar un valor null de confianza parcial `evidence`. Si `evidence` es `null`, el tiempo de ejecución copia los conjuntos de permisos, es decir, actual otorgar y denegar los conjuntos, desde el llamador <xref:System.Reflection.Assembly> a dinámico <xref:System.Reflection.Assembly> que se está definiendo y marca la directiva como resuelta.  
  
 Si el dinámico <xref:System.Reflection.Assembly> está guardado en el disco, carga posteriores obtendrán las concesiones en función de las directivas asociadas a la ubicación donde el <xref:System.Reflection.Assembly> se guardó.  
  
 Este método solo debe usarse para definir un ensamblado dinámico en el dominio de aplicación actual. Para obtener más información, consulte el <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29> sobrecarga del método.  
  
   
  
## Examples  
 El ejemplo siguiente se muestra el <xref:System.AppDomain.DefineDynamicAssembly%2A> método y <xref:System.AppDomain.AssemblyResolve> eventos.  
  
 Para que poder ejecutar este ejemplo de código, debe proporcionar el nombre completo del ensamblado. Para obtener información acerca de cómo obtener el nombre completo del ensamblado, vea [nombres de ensamblado](~/docs/framework/app-domains/assembly-names.md).  
  
 [!code-cpp[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CPP/definedynamicassembly.cpp#1)]
 [!code-csharp[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CS/definedynamicassembly.cs#1)]
 [!code-vb[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/VB/definedynamicassembly.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">La propiedad <see langword="Name" /> de <paramref name="name" /> es <see langword="null" />.  
  
O bien 
La propiedad <see langword="Name" /> de <paramref name="name" /> empieza con un espacio en blanco o contiene una barra diagonal o una barra diagonal inversa.</exception>
        <exception cref="T:System.AppDomainUnloadedException">La operación se intenta en un dominio de aplicación descargado.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">para cargar un ensamblado con la evidencia. Enumeración asociada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="DefineDynamicAssembly">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, string dir, System.Security.PermissionSet requiredPermissions, System.Security.PermissionSet optionalPermissions, System.Security.PermissionSet refusedPermissions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly(class System.Reflection.AssemblyName name, valuetype System.Reflection.Emit.AssemblyBuilderAccess access, string dir, class System.Security.PermissionSet requiredPermissions, class System.Security.PermissionSet optionalPermissions, class System.Security.PermissionSet refusedPermissions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineDynamicAssembly (name As AssemblyName, access As AssemblyBuilderAccess, dir As String, requiredPermissions As PermissionSet, optionalPermissions As PermissionSet, refusedPermissions As PermissionSet) As AssemblyBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Emit::AssemblyBuilder ^ DefineDynamicAssembly(System::Reflection::AssemblyName ^ name, System::Reflection::Emit::AssemblyBuilderAccess access, System::String ^ dir, System::Security::PermissionSet ^ requiredPermissions, System::Security::PermissionSet ^ optionalPermissions, System::Security::PermissionSet ^ refusedPermissions);" />
      <MemberSignature Language="F#" Value="abstract member DefineDynamicAssembly : System.Reflection.AssemblyName * System.Reflection.Emit.AssemblyBuilderAccess * string * System.Security.PermissionSet * System.Security.PermissionSet * System.Security.PermissionSet -&gt; System.Reflection.Emit.AssemblyBuilder&#xA;override this.DefineDynamicAssembly : System.Reflection.AssemblyName * System.Reflection.Emit.AssemblyBuilderAccess * string * System.Security.PermissionSet * System.Security.PermissionSet * System.Security.PermissionSet -&gt; System.Reflection.Emit.AssemblyBuilder" Usage="appDomain.DefineDynamicAssembly (name, access, dir, requiredPermissions, optionalPermissions, refusedPermissions)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Declarative security for assembly level is no longer enforced")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("Assembly level declarative security is obsolete and is no longer enforced by the CLR by default. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.AssemblyBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.Reflection.AssemblyName" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="access" Type="System.Reflection.Emit.AssemblyBuilderAccess" Index="1" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="dir" Type="System.String" Index="2" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="requiredPermissions" Type="System.Security.PermissionSet" Index="3" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="optionalPermissions" Type="System.Security.PermissionSet" Index="4" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="refusedPermissions" Type="System.Security.PermissionSet" Index="5" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="name">Identidad única del ensamblado dinámico.</param>
        <param name="access">Modo de acceso al ensamblado dinámico.</param>
        <param name="dir">Nombre del directorio donde se guardará el ensamblado. Si <paramref name="dir" /> es <see langword="null" />, el directorio predeterminado es el directorio actual.</param>
        <param name="requiredPermissions">Solicitud de permisos requeridos.</param>
        <param name="optionalPermissions">Solicitud de permisos opcionales.</param>
        <param name="refusedPermissions">Solicitud de permisos rechazados.</param>
        <summary>Define un ensamblado dinámico usando el nombre especificado, el modo de acceso, el directorio de almacenamiento y las solicitudes de permiso.</summary>
        <returns>Ensamblado dinámico con el nombre y las características especificados.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Las solicitudes de permisos especificadas para `requiredPermissions`, `optionalPermissions`, y `refusedPermissions` no se usan a menos que el ensamblado dinámico se ha guardado y vuelve a cargar en memoria. Para especificar las solicitudes de permiso para un ensamblado transitorio que nunca se guarda en disco, use una sobrecarga de la <xref:System.AppDomain.DefineDynamicAssembly%2A> método que especifica la evidencia como solicitado así como los permisos y proporcionar un <xref:System.Security.Policy.Evidence> objeto.  
  
> [!NOTE]
>  Durante el desarrollo de código que emite ensamblados dinámicos, se recomienda que use una sobrecarga de la <xref:System.AppDomain.DefineDynamicAssembly%2A> método que especifica la evidencia y permisos, proporcione la evidencia que desea que el ensamblado dinámico tiene e incluir <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification?displayProperty=nameWithType> en `refusedPermissions`. Incluyendo <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification> en el `refusedPermissions` parámetro garantiza que se debe comprobar el código MSIL. Una limitación de esta técnica es que también hace que <xref:System.Security.SecurityException> se produce cuando se usa con el código que solicita plena confianza.  
  
 Este método solo debe usarse para definir un ensamblado dinámico en el dominio de aplicación actual. Para obtener más información, consulte el <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29> sobrecarga del método.  
  
   
  
## Examples  
 El ejemplo siguiente se muestra el <xref:System.AppDomain.DefineDynamicAssembly%2A> método y <xref:System.AppDomain.AssemblyResolve> eventos.  
  
 Para que poder ejecutar este ejemplo de código, debe proporcionar el nombre completo del ensamblado. Para obtener información acerca de cómo obtener el nombre completo del ensamblado, vea [nombres de ensamblado](~/docs/framework/app-domains/assembly-names.md).  
  
 [!code-cpp[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CPP/definedynamicassembly.cpp#1)]
 [!code-csharp[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CS/definedynamicassembly.cs#1)]
 [!code-vb[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/VB/definedynamicassembly.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">La propiedad <see langword="Name" /> de <paramref name="name" /> es <see langword="null" />.  
  
O bien 
La propiedad <see langword="Name" /> de <paramref name="name" /> empieza con un espacio en blanco o contiene una barra diagonal o una barra diagonal inversa.</exception>
        <exception cref="T:System.AppDomainUnloadedException">La operación se intenta en un dominio de aplicación descargado.</exception>
      </Docs>
    </Member>
    <Member MemberName="DefineDynamicAssembly">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, string dir, System.Security.Policy.Evidence evidence, System.Security.PermissionSet requiredPermissions, System.Security.PermissionSet optionalPermissions, System.Security.PermissionSet refusedPermissions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly(class System.Reflection.AssemblyName name, valuetype System.Reflection.Emit.AssemblyBuilderAccess access, string dir, class System.Security.Policy.Evidence evidence, class System.Security.PermissionSet requiredPermissions, class System.Security.PermissionSet optionalPermissions, class System.Security.PermissionSet refusedPermissions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Emit::AssemblyBuilder ^ DefineDynamicAssembly(System::Reflection::AssemblyName ^ name, System::Reflection::Emit::AssemblyBuilderAccess access, System::String ^ dir, System::Security::Policy::Evidence ^ evidence, System::Security::PermissionSet ^ requiredPermissions, System::Security::PermissionSet ^ optionalPermissions, System::Security::PermissionSet ^ refusedPermissions);" />
      <MemberSignature Language="F#" Value="abstract member DefineDynamicAssembly : System.Reflection.AssemblyName * System.Reflection.Emit.AssemblyBuilderAccess * string * System.Security.Policy.Evidence * System.Security.PermissionSet * System.Security.PermissionSet * System.Security.PermissionSet -&gt; System.Reflection.Emit.AssemblyBuilder&#xA;override this.DefineDynamicAssembly : System.Reflection.AssemblyName * System.Reflection.Emit.AssemblyBuilderAccess * string * System.Security.Policy.Evidence * System.Security.PermissionSet * System.Security.PermissionSet * System.Security.PermissionSet -&gt; System.Reflection.Emit.AssemblyBuilder" Usage="appDomain.DefineDynamicAssembly (name, access, dir, evidence, requiredPermissions, optionalPermissions, refusedPermissions)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Declarative security for assembly level is no longer enforced")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("Assembly level declarative security is obsolete and is no longer enforced by the CLR by default.  Please see http://go.microsoft.com/fwlink/?LinkId=155570 for more information.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.AssemblyBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.Reflection.AssemblyName" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="access" Type="System.Reflection.Emit.AssemblyBuilderAccess" Index="1" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="dir" Type="System.String" Index="2" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="evidence" Type="System.Security.Policy.Evidence" Index="3" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="requiredPermissions" Type="System.Security.PermissionSet" Index="4" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="optionalPermissions" Type="System.Security.PermissionSet" Index="5" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="refusedPermissions" Type="System.Security.PermissionSet" Index="6" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="name">Identidad única del ensamblado dinámico.</param>
        <param name="access">Modo de acceso al ensamblado dinámico.</param>
        <param name="dir">Nombre del directorio donde se guardará el ensamblado. Si <paramref name="dir" /> es <see langword="null" />, el directorio predeterminado es el directorio actual.</param>
        <param name="evidence">Evidencia suministrada para el ensamblado dinámico. La evidencia se usa sin modificaciones como conjunto final de evidencia para la resolución de directivas.</param>
        <param name="requiredPermissions">Solicitud de permisos requeridos.</param>
        <param name="optionalPermissions">Solicitud de permisos opcionales.</param>
        <param name="refusedPermissions">Solicitud de permisos rechazados.</param>
        <summary>Define un ensamblado dinámico usando el nombre especificado, el modo de acceso, el directorio de almacenamiento, la evidencia y las solicitudes de permiso.</summary>
        <returns>Ensamblado dinámico con el nombre y las características especificados.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Las solicitudes de permisos especificadas para `requiredPermissions`, `optionalPermissions`, y `refusedPermissions` sólo se utilizan si `evidence` también se proporciona, o si el ensamblado dinámico se guarda y vuelve a cargar en memoria.  
  
> [!NOTE]
>  Durante el desarrollo de código que emite ensamblados dinámicos, se recomienda que incluya <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification?displayProperty=nameWithType> en `refusedPermissions`. Incluyendo <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification> en el `refusedPermissions` parámetro garantiza que se debe comprobar el código MSIL. Una limitación de esta técnica es que también hace que <xref:System.Security.SecurityException> se produce cuando se usa con el código que solicita plena confianza.  
  
 Solo de plena confianza para los llamadores pueden suministrar sus `evidence` al definir un dinámico <xref:System.Reflection.Assembly>. El tiempo de ejecución se asignará el <xref:System.Security.Policy.Evidence> a través de la directiva de seguridad para determinar los permisos concedidos. Los llamadores deben suministrar un valor null de confianza parcial `evidence`. Si `evidence` es `null`, el tiempo de ejecución copia los conjuntos de permisos, es decir, actual otorgar y denegar los conjuntos, desde el llamador <xref:System.Reflection.Assembly> a dinámico <xref:System.Reflection.Assembly> que se está definiendo y marca la directiva como resuelta.  
  
 Si el dinámico <xref:System.Reflection.Assembly> está guardado en el disco, carga posteriores obtendrán las concesiones en función de las directivas asociadas a la ubicación donde el <xref:System.Reflection.Assembly> se guardó.  
  
 Este método solo debe usarse para definir un ensamblado dinámico en el dominio de aplicación actual. Para obtener más información, consulte el <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29> sobrecarga del método.  
  
   
  
## Examples  
 El ejemplo siguiente se muestra el <xref:System.AppDomain.DefineDynamicAssembly%2A> método y <xref:System.AppDomain.AssemblyResolve> eventos.  
  
 Para que poder ejecutar este ejemplo de código, debe proporcionar el nombre completo del ensamblado. Para obtener información acerca de cómo obtener el nombre completo del ensamblado, vea [nombres de ensamblado](~/docs/framework/app-domains/assembly-names.md).  
  
 [!code-cpp[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CPP/definedynamicassembly.cpp#1)]
 [!code-csharp[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CS/definedynamicassembly.cs#1)]
 [!code-vb[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/VB/definedynamicassembly.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">La propiedad <see langword="Name" /> de <paramref name="name" /> es <see langword="null" />.  
  
O bien 
La propiedad <see langword="Name" /> de <paramref name="name" /> empieza con un espacio en blanco o contiene una barra diagonal o una barra diagonal inversa.</exception>
        <exception cref="T:System.AppDomainUnloadedException">La operación se intenta en un dominio de aplicación descargado.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">para cargar un ensamblado con la evidencia. Enumeración asociada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="DefineDynamicAssembly">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, string dir, System.Security.Policy.Evidence evidence, System.Security.PermissionSet requiredPermissions, System.Security.PermissionSet optionalPermissions, System.Security.PermissionSet refusedPermissions, bool isSynchronized);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly(class System.Reflection.AssemblyName name, valuetype System.Reflection.Emit.AssemblyBuilderAccess access, string dir, class System.Security.Policy.Evidence evidence, class System.Security.PermissionSet requiredPermissions, class System.Security.PermissionSet optionalPermissions, class System.Security.PermissionSet refusedPermissions, bool isSynchronized) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Emit::AssemblyBuilder ^ DefineDynamicAssembly(System::Reflection::AssemblyName ^ name, System::Reflection::Emit::AssemblyBuilderAccess access, System::String ^ dir, System::Security::Policy::Evidence ^ evidence, System::Security::PermissionSet ^ requiredPermissions, System::Security::PermissionSet ^ optionalPermissions, System::Security::PermissionSet ^ refusedPermissions, bool isSynchronized);" />
      <MemberSignature Language="F#" Value="abstract member DefineDynamicAssembly : System.Reflection.AssemblyName * System.Reflection.Emit.AssemblyBuilderAccess * string * System.Security.Policy.Evidence * System.Security.PermissionSet * System.Security.PermissionSet * System.Security.PermissionSet * bool -&gt; System.Reflection.Emit.AssemblyBuilder&#xA;override this.DefineDynamicAssembly : System.Reflection.AssemblyName * System.Reflection.Emit.AssemblyBuilderAccess * string * System.Security.Policy.Evidence * System.Security.PermissionSet * System.Security.PermissionSet * System.Security.PermissionSet * bool -&gt; System.Reflection.Emit.AssemblyBuilder" Usage="appDomain.DefineDynamicAssembly (name, access, dir, evidence, requiredPermissions, optionalPermissions, refusedPermissions, isSynchronized)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet,System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Declarative security for assembly level is no longer enforced")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("Assembly level declarative security is obsolete and is no longer enforced by the CLR by default. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.AssemblyBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.Reflection.AssemblyName" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="access" Type="System.Reflection.Emit.AssemblyBuilderAccess" Index="1" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="dir" Type="System.String" Index="2" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="evidence" Type="System.Security.Policy.Evidence" Index="3" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="requiredPermissions" Type="System.Security.PermissionSet" Index="4" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="optionalPermissions" Type="System.Security.PermissionSet" Index="5" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="refusedPermissions" Type="System.Security.PermissionSet" Index="6" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="isSynchronized" Type="System.Boolean" Index="7" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="name">Identidad única del ensamblado dinámico.</param>
        <param name="access">Modo de acceso al ensamblado dinámico.</param>
        <param name="dir">Nombre del directorio donde se guardará el ensamblado dinámico. Si <paramref name="dir" /> es <see langword="null" />, el directorio predeterminado es el directorio actual.</param>
        <param name="evidence">Evidencia suministrada para el ensamblado dinámico. La evidencia se usa sin modificaciones como conjunto final de evidencia para la resolución de directivas.</param>
        <param name="requiredPermissions">Solicitud de permisos requeridos.</param>
        <param name="optionalPermissions">Solicitud de permisos opcionales.</param>
        <param name="refusedPermissions">Solicitud de permisos rechazados.</param>
        <param name="isSynchronized"><see langword="true" /> para sincronizar la creación de módulos, tipos y miembros en el ensamblado dinámico; en caso contrario, <see langword="false" />.</param>
        <summary>Define un ensamblado dinámico usando el nombre especificado, el modo de acceso, el directorio de almacenamiento, la evidencia, las solicitudes de permiso y la opción de sincronización.</summary>
        <returns>Ensamblado dinámico con el nombre y las características especificados.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Las solicitudes de permisos especificadas para `requiredPermissions`, `optionalPermissions`, y `refusedPermissions` sólo se utilizan si `evidence` también se proporciona, o si el ensamblado dinámico se guarda y vuelve a cargar en memoria.  
  
> [!NOTE]
>  Durante el desarrollo de código que emite ensamblados dinámicos, se recomienda que incluya <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification?displayProperty=nameWithType> en `refusedPermissions`. Incluyendo <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification> en el `refusedPermissions` parámetro garantiza que se debe comprobar el código MSIL. Una limitación de esta técnica es que también hace que <xref:System.Security.SecurityException> se produce cuando se usa con el código que solicita plena confianza.  
  
 Solo los llamadores de plena confianza pueden suministrar su evidencia al definir un dinámico <xref:System.Reflection.Assembly>. El tiempo de ejecución se asignará el <xref:System.Security.Policy.Evidence> a través de la directiva de seguridad para determinar los permisos concedidos. Deben proporcionar los llamadores de confianza parcial `null` para el `evidence` parámetro. Si `evidence` es `null`, el tiempo de ejecución copia los conjuntos de permisos, es decir, actual otorgar y denegar los conjuntos, desde el llamador <xref:System.Reflection.Assembly> a dinámico <xref:System.Reflection.Assembly> que se está definiendo y marca la directiva como resuelta.  
  
 Si el dinámico <xref:System.Reflection.Assembly> está guardado en el disco, carga posteriores obtendrán las concesiones en función de las directivas asociadas a la ubicación donde el <xref:System.Reflection.Assembly> se guardó.  
  
 Si `isSynchronized` es `true`, los métodos siguientes de resultante <xref:System.Reflection.Emit.AssemblyBuilder> se sincronizarán: <xref:System.Reflection.Emit.AssemblyBuilder.DefineDynamicModule%2A>, <xref:System.Reflection.Emit.AssemblyBuilder.DefineResource%2A>, <xref:System.Reflection.Emit.AssemblyBuilder.AddResourceFile%2A>, <xref:System.Reflection.Emit.AssemblyBuilder.GetDynamicModule%2A>, <xref:System.Reflection.Emit.AssemblyBuilder.SetEntryPoint%2A>, y <xref:System.Reflection.Emit.AssemblyBuilder.Save%2A>. Si dos de estos métodos se llaman en subprocesos diferentes, uno se bloqueará hasta que se complete la otra.  
  
   
  
## Examples  
 El ejemplo siguiente se muestra el <xref:System.AppDomain.DefineDynamicAssembly%2A> método y <xref:System.AppDomain.AssemblyResolve> eventos.  
  
 Para que poder ejecutar este ejemplo de código, debe proporcionar el nombre completo del ensamblado. Para obtener información acerca de cómo obtener el nombre completo del ensamblado, vea [nombres de ensamblado](~/docs/framework/app-domains/assembly-names.md).  
  
 [!code-cpp[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CPP/definedynamicassembly.cpp#1)]
 [!code-csharp[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CS/definedynamicassembly.cs#1)]
 [!code-vb[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/VB/definedynamicassembly.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">La propiedad <see langword="Name" /> de <paramref name="name" /> es <see langword="null" />.  
  
O bien 
La propiedad <see langword="Name" /> de <paramref name="name" /> empieza con un espacio en blanco o contiene una barra diagonal o una barra diagonal inversa.</exception>
        <exception cref="T:System.AppDomainUnloadedException">La operación se intenta en un dominio de aplicación descargado.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">para cargar un ensamblado con la evidencia. Enumeración asociada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="DefineDynamicAssembly">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, string dir, System.Security.Policy.Evidence evidence, System.Security.PermissionSet requiredPermissions, System.Security.PermissionSet optionalPermissions, System.Security.PermissionSet refusedPermissions, bool isSynchronized, System.Collections.Generic.IEnumerable&lt;System.Reflection.Emit.CustomAttributeBuilder&gt; assemblyAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly(class System.Reflection.AssemblyName name, valuetype System.Reflection.Emit.AssemblyBuilderAccess access, string dir, class System.Security.Policy.Evidence evidence, class System.Security.PermissionSet requiredPermissions, class System.Security.PermissionSet optionalPermissions, class System.Security.PermissionSet refusedPermissions, bool isSynchronized, class System.Collections.Generic.IEnumerable`1&lt;class System.Reflection.Emit.CustomAttributeBuilder&gt; assemblyAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet,System.Boolean,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::AssemblyBuilder ^ DefineDynamicAssembly(System::Reflection::AssemblyName ^ name, System::Reflection::Emit::AssemblyBuilderAccess access, System::String ^ dir, System::Security::Policy::Evidence ^ evidence, System::Security::PermissionSet ^ requiredPermissions, System::Security::PermissionSet ^ optionalPermissions, System::Security::PermissionSet ^ refusedPermissions, bool isSynchronized, System::Collections::Generic::IEnumerable&lt;System::Reflection::Emit::CustomAttributeBuilder ^&gt; ^ assemblyAttributes);" />
      <MemberSignature Language="F#" Value="member this.DefineDynamicAssembly : System.Reflection.AssemblyName * System.Reflection.Emit.AssemblyBuilderAccess * string * System.Security.Policy.Evidence * System.Security.PermissionSet * System.Security.PermissionSet * System.Security.PermissionSet * bool * seq&lt;System.Reflection.Emit.CustomAttributeBuilder&gt; -&gt; System.Reflection.Emit.AssemblyBuilder" Usage="appDomain.DefineDynamicAssembly (name, access, dir, evidence, requiredPermissions, optionalPermissions, refusedPermissions, isSynchronized, assemblyAttributes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Declarative security for assembly level is no longer enforced")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("Assembly level declarative security is obsolete and is no longer enforced by the CLR by default. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.AssemblyBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.Reflection.AssemblyName" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="access" Type="System.Reflection.Emit.AssemblyBuilderAccess" Index="1" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="dir" Type="System.String" Index="2" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="evidence" Type="System.Security.Policy.Evidence" Index="3" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="requiredPermissions" Type="System.Security.PermissionSet" Index="4" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="optionalPermissions" Type="System.Security.PermissionSet" Index="5" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="refusedPermissions" Type="System.Security.PermissionSet" Index="6" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="isSynchronized" Type="System.Boolean" Index="7" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="assemblyAttributes" Type="System.Collections.Generic.IEnumerable&lt;System.Reflection.Emit.CustomAttributeBuilder&gt;" Index="8" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="name">Identidad única del ensamblado dinámico.</param>
        <param name="access">Modo de acceso al ensamblado dinámico.</param>
        <param name="dir">Nombre del directorio donde se guardará el ensamblado dinámico. Si <paramref name="dir" /> es <see langword="null" />, se usa el directorio actual.</param>
        <param name="evidence">Evidencia suministrada para el ensamblado dinámico. La evidencia se usa sin modificaciones como conjunto final de evidencia para la resolución de directivas.</param>
        <param name="requiredPermissions">Solicitud de permisos requeridos.</param>
        <param name="optionalPermissions">Solicitud de permisos opcionales.</param>
        <param name="refusedPermissions">Solicitud de permisos rechazados.</param>
        <param name="isSynchronized"><see langword="true" /> para sincronizar la creación de módulos, tipos y miembros en el ensamblado dinámico; en caso contrario, <see langword="false" />.</param>
        <param name="assemblyAttributes">Lista enumerable de atributos que se va a aplicarse al ensamblado o <see langword="null" /> si no hay ningún atributo.</param>
        <summary>Define un ensamblado dinámico con el nombre especificado, el modo de acceso, el directorio de almacenamiento, la evidencia, las solicitudes de permiso, la opción de sincronización y los atributos personalizados.</summary>
        <returns>Ensamblado dinámico con el nombre y las características especificados.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilice esta sobrecarga del método para especificar atributos que no funcionan correctamente a menos que se aplican cuando se crea un ensamblado dinámico. Por ejemplo, atributos, como seguridad <xref:System.Security.SecurityTransparentAttribute> y <xref:System.Security.SecurityCriticalAttribute> no funcionan correctamente si se agregan una vez creado un ensamblado dinámico.  
  
 Las solicitudes de permisos especificadas para el `requiredPermissions`, `optionalPermissions`, y `refusedPermissions` parámetros se usan solo si el `evidence` también se proporciona el parámetro, o si el ensamblado dinámico se guarda y vuelve a cargar en memoria.  
  
> [!NOTE]
>  Al desarrollar código que emite ensamblados dinámicos, se recomienda que incluya el <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification?displayProperty=nameWithType> marca en el `refusedPermissions` parámetro. La inclusión de esta marca garantiza que se comprobará el lenguaje intermedio (MSIL) de Microsoft. Esta técnica detectará la generación de código no comprobable, que en caso contrario, es muy difícil detectar involuntaria. Una limitación de esta técnica es que también hace que <xref:System.Security.SecurityException> se produce cuando se utiliza con código que requiere plena confianza.  
  
 Solo los llamadores de plena confianza pueden suministrar la evidencia al definir un dinámico <xref:System.Reflection.Assembly>. El tiempo de ejecución asigna el <xref:System.Security.Policy.Evidence> a través de la directiva de seguridad para determinar los permisos concedidos. Deben proporcionar los llamadores de confianza parcial `null` para el `evidence` parámetro. Si `evidence` es `null`, el tiempo de ejecución copia los conjuntos de permisos (es decir, la concesión actual y denegar conjuntos) desde el ensamblado del llamador en el ensamblado dinámico que se está definiendo y marca la directiva como resuelta.  
  
 Si el ensamblado dinámico se guarda en disco, posteriores cargas obtendrán las concesiones en función de las directivas que están asociadas con la ubicación donde guardó el ensamblado dinámico.  
  
 Si `isSynchronized` es `true`, los métodos siguientes de resultante <xref:System.Reflection.Emit.AssemblyBuilder> se sincronizarán: <xref:System.Reflection.Emit.AssemblyBuilder.DefineDynamicModule%2A>, <xref:System.Reflection.Emit.AssemblyBuilder.DefineResource%2A>, <xref:System.Reflection.Emit.AssemblyBuilder.AddResourceFile%2A>, <xref:System.Reflection.Emit.AssemblyBuilder.GetDynamicModule%2A>, <xref:System.Reflection.Emit.AssemblyBuilder.SetEntryPoint%2A>, y <xref:System.Reflection.Emit.AssemblyBuilder.Save%2A>. Si dos de estos métodos se llaman en subprocesos diferentes, uno se bloqueará hasta que se complete la otra.  
  
 Esta sobrecarga del método se introdujo en la [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)].  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">La propiedad <see langword="Name" /> de <paramref name="name" /> es <see langword="null" />.  
  
O bien 
La propiedad <see langword="Name" /> de <paramref name="name" /> empieza con un espacio en blanco o contiene una barra diagonal o una barra diagonal inversa.</exception>
        <exception cref="T:System.AppDomainUnloadedException">La operación se intenta en un dominio de aplicación descargado.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">para cargar un ensamblado con la evidencia. Enumeración asociada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</permission>
        <altmember cref="M:System.Reflection.Emit.AssemblyBuilder.SetCustomAttribute(System.Reflection.Emit.CustomAttributeBuilder)" />
      </Docs>
    </Member>
    <Member MemberName="DoCallBack">
      <MemberSignature Language="C#" Value="public void DoCallBack (CrossAppDomainDelegate callBackDelegate);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void DoCallBack(class System.CrossAppDomainDelegate callBackDelegate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.DoCallBack(System.CrossAppDomainDelegate)" />
      <MemberSignature Language="VB.NET" Value="Public Sub DoCallBack (callBackDelegate As CrossAppDomainDelegate)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void DoCallBack(CrossAppDomainDelegate ^ callBackDelegate);" />
      <MemberSignature Language="F#" Value="abstract member DoCallBack : CrossAppDomainDelegate -&gt; unit&#xA;override this.DoCallBack : CrossAppDomainDelegate -&gt; unit" Usage="appDomain.DoCallBack callBackDelegate" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.DoCallBack(System.CrossAppDomainDelegate)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callBackDelegate" Type="System.CrossAppDomainDelegate" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="callBackDelegate">Delegado que especifica un método al que se va a llamar.</param>
        <summary>Ejecuta el código en otro dominio de aplicación identificado por el delegado especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `callBackDelegate` puede especificar un cálculo de referencias por valor, <xref:System.MarshalByRefObject>, o <xref:System.ContextBoundObject>.  
  
   
  
## Examples  
 El ejemplo siguiente muestra cómo utilizar una variable static <xref:System.AppDomain.DoCallBack%2A> método.  
  
 [!code-cpp[AppDomain_DoCallBack#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_DoCallBack/CPP/docallback_static.cpp#1)]
 [!code-csharp[AppDomain_DoCallBack#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_DoCallBack/CS/docallback_static.cs#1)]
 [!code-vb[AppDomain_DoCallBack#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_DoCallBack/VB/docallback_static.vb#1)]  
  
 El ejemplo siguiente muestra cómo utilizar el <xref:System.AppDomain.DoCallBack%2A> método por valor.  
  
 [!code-cpp[AppDomain_DoCallBack#2](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_DoCallBack/CPP/docallback_byval.cpp#2)]
 [!code-csharp[AppDomain_DoCallBack#2](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_DoCallBack/CS/docallback_byval.cs#2)]
 [!code-vb[AppDomain_DoCallBack#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_DoCallBack/VB/docallback_byval.vb#2)]  
  
 El ejemplo siguiente muestra cómo utilizar el <xref:System.AppDomain.DoCallBack%2A> método por referencia.  
  
 [!code-cpp[AppDomain_DoCallBack#3](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_DoCallBack/CPP/docallback_byref.cpp#3)]
 [!code-csharp[AppDomain_DoCallBack#3](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_DoCallBack/CS/docallback_byref.cs#3)]
 [!code-vb[AppDomain_DoCallBack#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_DoCallBack/VB/docallback_byref.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="callBackDelegate" /> es <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="DomainManager">
      <MemberSignature Language="C#" Value="public AppDomainManager DomainManager { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.AppDomainManager DomainManager" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.DomainManager" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DomainManager As AppDomainManager" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property AppDomainManager ^ DomainManager { AppDomainManager ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DomainManager : AppDomainManager" Usage="System.AppDomain.DomainManager" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.AppDomainManager</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene el administrador de dominio que ha proporcionado el host al inicializar el dominio de aplicación.</summary>
        <value>Objeto que representa el administrador de dominio que proporcionó el host al inicializar el dominio de aplicación, o <see langword="null" /> si no se proporcionó un administrador de dominio.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un host no administrado de common language runtime (CLR) puede proporcionar un administrador de dominio. El Administrador de dominio puede participar en la inicialización del nuevo dominio de aplicación y proporcionar otros administradores, como un <xref:System.Security.HostSecurityManager>, que participen en las operaciones del dominio de aplicación.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requiere plena confianza para el llamador inmediato. Este miembro no se puede usar código de confianza parcial o transparente.</permission>
      </Docs>
    </Member>
    <Member MemberName="DomainUnload">
      <MemberSignature Language="C#" Value="public event EventHandler DomainUnload;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler DomainUnload" />
      <MemberSignature Language="DocId" Value="E:System.AppDomain.DomainUnload" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event DomainUnload As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event EventHandler ^ DomainUnload;" />
      <MemberSignature Language="F#" Value="member this.DomainUnload : EventHandler " Usage="member this.DomainUnload : System.EventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System._AppDomain.DomainUnload</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>add: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>remove: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produce cuando un <see cref="T:System.AppDomain" /> está a punto de descargarse.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.EventHandler> delegado para este evento puede realizar cualquier actividad de finalización antes de que se descarga el dominio de aplicación.  
  
 Cada dominio de aplicación que necesita para realizar el procesamiento cuando se descargue debe registrar un controlador de eventos para este evento. Un controlador de eventos compartidos no se debe usar, porque el <xref:System.EventHandler> delegado no identifica el dominio al que se está descargando.  
  
> [!NOTE]
>  Nunca se genera este evento en el dominio de aplicación predeterminado.  
  
 No haga suposiciones sobre el subproceso que se genera el evento en. El evento puede generarse en un subproceso distinto al que llama el <xref:System.AppDomain.Unload%2A> método.  
  
 Para obtener más información sobre el manejo de eventos, consulte [controlar y provocar eventos](~/docs/standard/events/index.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DynamicDirectory">
      <MemberSignature Language="C#" Value="public string DynamicDirectory { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string DynamicDirectory" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.DynamicDirectory" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DynamicDirectory As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ DynamicDirectory { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DynamicDirectory : string" Usage="System.AppDomain.DynamicDirectory" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System._AppDomain.DynamicDirectory</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene el directorio que la resolución de ensamblado usa para buscar ensamblados creados de forma dinámica.</summary>
        <value>Directorio que la resolución de ensamblado usa para buscar ensamblados creados de forma dinámica.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para establecer el directorio dinámico, asigne una ruta de acceso del directorio base para el <xref:System.AppDomainSetup.DynamicBase%2A?displayProperty=nameWithType> propiedad de la <xref:System.AppDomainSetup> objeto que se usará para crear el nuevo dominio de aplicación. La ruta de acceso del directorio base asigne a la propiedad se modifica mediante la adición de un subdirectorio cuyo nombre simple es el código hash de la cadena que asigne a la <xref:System.AppDomainSetup.ApplicationName%2A?displayProperty=nameWithType> propiedad, por lo que es el formato del directorio base *ruta de acceso original* \\ *código hash*. El directorio dinámico es un subdirectorio del directorio base. Su nombre simple es el valor de la <xref:System.AppDomainSetup.ApplicationName%2A?displayProperty=nameWithType> propiedad, por lo que su formato es *ruta de acceso original*\\*código hash*\\*nombre de la aplicación*.  
  
   
  
## Examples  
 El ejemplo siguiente crea un dominio de aplicación con un directorio para los ensamblados dinámicos, emite un ensamblado dinámico y lo almacena en el directorio dinámico y, a continuación, carga el ensamblado en el nuevo dominio de aplicación y lo usa.  
  
 El ejemplo se crea un <xref:System.AppDomainSetup> objeto y establece su <xref:System.AppDomainSetup.ApplicationName%2A> propiedad en "Ejemplo" y su <xref:System.AppDomainSetup.DynamicBase%2A> propiedad en "C:\DynamicAssemblyDir". El ejemplo se muestra a continuación, el <xref:System.AppDomainSetup.DynamicBase%2A> propiedad para mostrar que el código hash del nombre de la aplicación se ha anexado como un subdirectorio de la ruta de acceso que se asignó originalmente.  
  
> [!NOTE]
>  El directorio base en este ejemplo está pensado para estar fuera de la ruta de acceso de sondeo para la aplicación de ejemplo. Asegúrese de compilar el ejemplo en una ubicación diferente. Eliminar el directorio base y todos sus subdirectorios cada vez que ejecute el ejemplo.  
  
 El ejemplo crea un nuevo dominio de aplicación, utilizando el <xref:System.AppDomainSetup> objeto. El ejemplo se usa el <xref:System.AppDomain.DynamicDirectory%2A> propiedad que se va a recuperar el nombre del directorio, por lo que puede crear el directorio. (En el ejemplo se podría crear fácilmente el directorio con antelación mediante la concatenación de la ruta de acceso original, el código hash del nombre de la aplicación y el nombre de la aplicación.)  
  
 El ejemplo tiene un `GenerateDynamicAssembly` método que emite un ensamblado denominado `DynamicHelloWorld.dll` y lo almacena en el directorio dinámico del dominio de aplicación nuevo. El ensamblado dinámico contiene un solo tipo, `HelloWorld`, que tiene un método estático (`Shared` método en Visual Basic) denominada `HelloFromAD`. Llamar a este método muestra el nombre del dominio de aplicación.  
  
 El `Example` clase se deriva de <xref:System.MarshalByRefObject>, por lo que en el ejemplo se puede crear una instancia de la clase en el nuevo dominio de aplicación y llamar a su `Test` método. El `Test` método carga el ensamblado dinámico por su nombre para mostrar y llama a estático `HelloFromAD` método.  
  
 Puede mostrar que se busca en el directorio dinámico después de las rutas de acceso de sondeo normales al escribir código para un ensamblado denominado `DynamicHelloWorld.dll` y compilarlo en el mismo directorio que este ejemplo. El ensamblado debe tener una clase denominada `HelloWorld` con un método estático denominado `HelloFromAD`. Este método no tiene que tienen la misma funcionalidad que aparece en el ejemplo; simplemente puede mostrar una cadena en la consola. El ensamblado debe tener también un <xref:System.Reflection.AssemblyVersionAttribute> atributo que se establece su versión a 1.0.0.0. Al ejecutar el ejemplo, se encuentra el ensamblado que se ha compilado en el directorio actual antes de que se busca en el directorio dinámico.  
  
 [!code-cpp[ADDynamicBase#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADDynamicBase/CPP/addynamicbase.cpp#1)]
 [!code-csharp[ADDynamicBase#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADDynamicBase/CS/addynamicbase.cs#1)]
 [!code-vb[ADDynamicBase#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADDynamicBase/VB/addynamicbase.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException">La operación se intenta en un dominio de aplicación descargado.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Para obtener acceso a la información de ruta de acceso. Enumeración asociada: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="Evidence">
      <MemberSignature Language="C#" Value="public System.Security.Policy.Evidence Evidence { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Security.Policy.Evidence Evidence" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.Evidence" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Evidence As Evidence" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Security::Policy::Evidence ^ Evidence { System::Security::Policy::Evidence ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Evidence : System.Security.Policy.Evidence" Usage="System.AppDomain.Evidence" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Security.IEvidenceFactory.Evidence</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Security.Policy.Evidence</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene el objeto <see cref="T:System.Security.Policy.Evidence" /> asociado a este dominio de aplicación.</summary>
        <value>Evidencia asociada a este dominio de aplicación.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.AppDomainUnloadedException">La operación se intenta en un dominio de aplicación descargado.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">para cargar un ensamblado con la evidencia. Enumeración asociada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />. Acción de seguridad: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />.</permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="ExecuteAssembly">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Ejecuta el ensamblado que contiene el archivo especificado.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ExecuteAssembly">
      <MemberSignature Language="C#" Value="public int ExecuteAssembly (string assemblyFile);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 ExecuteAssembly(string assemblyFile) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.ExecuteAssembly(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function ExecuteAssembly (assemblyFile As String) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int ExecuteAssembly(System::String ^ assemblyFile);" />
      <MemberSignature Language="F#" Value="abstract member ExecuteAssembly : string -&gt; int&#xA;override this.ExecuteAssembly : string -&gt; int" Usage="appDomain.ExecuteAssembly assemblyFile" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.ExecuteAssembly(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="assemblyFile">Nombre del archivo que contiene el ensamblado que se va a ejecutar.</param>
        <summary>Ejecuta el ensamblado que contiene el archivo especificado.</summary>
        <returns>Valor devuelto por el punto de entrada del ensamblado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El ensamblado comienza a ejecutarse en el punto de entrada especificado en el encabezado de .NET Framework.  
  
 Este método no crea un nuevo proceso o un dominio de aplicación y no se ejecuta el método de punto de entrada en un nuevo subproceso.  
  
 Este método carga ensamblados utilizando la <xref:System.Reflection.Assembly.LoadFile%2A> método. También puede ejecutar ensamblados mediante la <xref:System.AppDomain.ExecuteAssemblyByName%2A> método, que carga los ensamblados que utilizan el <xref:System.Reflection.Assembly.Load%2A> método.  
  
 Para crear el <xref:System.AppDomain> para cargar y ejecutar, utilice el <xref:System.AppDomain.CreateDomain%2A> método.  
  
   
  
## Examples  
 El ejemplo siguiente muestra cómo utilizar una de las sobrecargas de <xref:System.AppDomain.ExecuteAssembly%2A> en dos dominios diferentes.  
  
 [!code-cpp[AppDomain_ExecuteAssembly#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_ExecuteAssembly/CPP/executeassembly.cpp#1)]
 [!code-csharp[AppDomain_ExecuteAssembly#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_ExecuteAssembly/CS/executeassembly.cs#1)]
 [!code-vb[AppDomain_ExecuteAssembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_ExecuteAssembly/VB/executeassembly.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="assemblyFile" /> es <see langword="null" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">No se ha encontrado <paramref name="assemblyFile" />.</exception>
        <exception cref="T:System.BadImageFormatException"><paramref name="assemblyFile" /> no es un ensamblado válido.  
  
O bien 
La versión 2.0 u otra posterior de Common Language Runtime está cargada actualmente y <paramref name="assemblyFile" /> se compiló con una versión posterior.</exception>
        <exception cref="T:System.AppDomainUnloadedException">La operación se intenta en un dominio de aplicación descargado.</exception>
        <exception cref="T:System.IO.FileLoadException">Se cargó un ensamblado o módulo dos veces con dos evidencias diferentes.</exception>
        <exception cref="T:System.MissingMethodException">El ensamblado especificado no tiene ningún punto de entrada.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Para obtener acceso desde un archivo o directorio y para tener acceso a la información de la ruta de acceso de lectura. Enumeraciones asociadas: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</permission>
        <permission cref="T:System.Net.WebPermission">para leer un URI que no comienzan con "file://".</permission>
        <permission cref="T:System.Security.Permissions.UIPermission">Para ejecutar una aplicación de consola. Enumeración asociada: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="ExecuteAssembly">
      <MemberSignature Language="C#" Value="public int ExecuteAssembly (string assemblyFile, System.Security.Policy.Evidence assemblySecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 ExecuteAssembly(string assemblyFile, class System.Security.Policy.Evidence assemblySecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.ExecuteAssembly(System.String,System.Security.Policy.Evidence)" />
      <MemberSignature Language="VB.NET" Value="Public Function ExecuteAssembly (assemblyFile As String, assemblySecurity As Evidence) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int ExecuteAssembly(System::String ^ assemblyFile, System::Security::Policy::Evidence ^ assemblySecurity);" />
      <MemberSignature Language="F#" Value="abstract member ExecuteAssembly : string * System.Security.Policy.Evidence -&gt; int&#xA;override this.ExecuteAssembly : string * System.Security.Policy.Evidence -&gt; int" Usage="appDomain.ExecuteAssembly (assemblyFile, assemblySecurity)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.ExecuteAssembly(System.String,System.Security.Policy.Evidence)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use an overload that does not take an Evidence parameter")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("Methods which use evidence to sandbox are obsolete and will be removed in a future release of the .NET Framework. Please use an overload of ExecuteAssembly which does not take an Evidence parameter. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="assemblySecurity" Type="System.Security.Policy.Evidence" Index="1" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="assemblyFile">Nombre del archivo que contiene el ensamblado que se va a ejecutar.</param>
        <param name="assemblySecurity">Evidencia para cargar el ensamblado.</param>
        <summary>Ejecuta el ensamblado que contiene el archivo especificado, usando la evidencia especificada.</summary>
        <returns>Valor devuelto por el punto de entrada del ensamblado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El ensamblado comienza a ejecutarse en el punto de entrada especificado en el encabezado de .NET Framework.  
  
 El <xref:System.AppDomain.ExecuteAssembly%2A> método no crea un nuevo proceso o un dominio de aplicación y no se ejecuta el método de punto de entrada en un nuevo subproceso.  
  
 Este método carga ensamblados utilizando la <xref:System.Reflection.Assembly.LoadFile%2A> método. También puede ejecutar ensamblados mediante la <xref:System.AppDomain.ExecuteAssemblyByName%2A> método, que carga los ensamblados que utilizan el <xref:System.Reflection.Assembly.Load%2A> método.  
  
   
  
## Examples  
 El ejemplo siguiente muestra cómo utilizar una de las sobrecargas de <xref:System.AppDomain.ExecuteAssembly%2A> en dos dominios diferentes.  
  
 [!code-cpp[AppDomain_ExecuteAssembly#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_ExecuteAssembly/CPP/executeassembly.cpp#1)]
 [!code-csharp[AppDomain_ExecuteAssembly#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_ExecuteAssembly/CS/executeassembly.cs#1)]
 [!code-vb[AppDomain_ExecuteAssembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_ExecuteAssembly/VB/executeassembly.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="assemblyFile" /> es <see langword="null" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">No se ha encontrado <paramref name="assemblyFile" />.</exception>
        <exception cref="T:System.BadImageFormatException"><paramref name="assemblyFile" /> no es un ensamblado válido.  
  
O bien 
La versión 2.0 u otra posterior de Common Language Runtime está cargada actualmente y <paramref name="assemblyFile" /> se compiló con una versión posterior.</exception>
        <exception cref="T:System.AppDomainUnloadedException">La operación se intenta en un dominio de aplicación descargado.</exception>
        <exception cref="T:System.IO.FileLoadException">Se cargó un ensamblado o módulo dos veces con dos evidencias diferentes.</exception>
        <exception cref="T:System.MissingMethodException">El ensamblado especificado no tiene ningún punto de entrada.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">para cargar un ensamblado con la evidencia. Enumeración asociada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Para obtener acceso desde un archivo o directorio y para tener acceso a la información de la ruta de acceso de lectura. Enumeraciones asociadas: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</permission>
        <permission cref="T:System.Net.WebPermission">para leer un URI que no comienzan con "file://".</permission>
        <permission cref="T:System.Security.Permissions.UIPermission">Para ejecutar una aplicación de consola. Enumeración asociada: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="ExecuteAssembly">
      <MemberSignature Language="C#" Value="public int ExecuteAssembly (string assemblyFile, string[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ExecuteAssembly(string assemblyFile, string[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.ExecuteAssembly(System.String,System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Function ExecuteAssembly (assemblyFile As String, args As String()) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int ExecuteAssembly(System::String ^ assemblyFile, cli::array &lt;System::String ^&gt; ^ args);" />
      <MemberSignature Language="F#" Value="member this.ExecuteAssembly : string * string[] -&gt; int" Usage="appDomain.ExecuteAssembly (assemblyFile, args)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="args" Type="System.String[]" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="assemblyFile">Nombre del archivo que contiene el ensamblado que se va a ejecutar.</param>
        <param name="args">Argumentos del punto de entrada del ensamblado.</param>
        <summary>Ejecuta el ensamblado contenido en el archivo especificado, usando los argumentos especificados.</summary>
        <returns>Valor devuelto por el punto de entrada del ensamblado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El ensamblado comienza a ejecutarse en el punto de entrada especificado en el encabezado de .NET Framework.  
  
 Este método no crea un nuevo proceso o un dominio de aplicación y no se ejecuta el método de punto de entrada en un nuevo subproceso.  
  
 Este método carga ensamblados utilizando la <xref:System.Reflection.Assembly.LoadFile%2A> método. También puede ejecutar ensamblados mediante la <xref:System.AppDomain.ExecuteAssemblyByName%2A> método, que carga los ensamblados que utilizan el <xref:System.Reflection.Assembly.Load%2A> método.  
  
   
  
## Examples  
 El ejemplo siguiente muestra cómo utilizar una de las sobrecargas de <xref:System.AppDomain.ExecuteAssembly%2A> en dos dominios diferentes.  
  
 [!code-cpp[AppDomain_ExecuteAssembly#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_ExecuteAssembly/CPP/executeassembly.cpp#1)]
 [!code-csharp[AppDomain_ExecuteAssembly#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_ExecuteAssembly/CS/executeassembly.cs#1)]
 [!code-vb[AppDomain_ExecuteAssembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_ExecuteAssembly/VB/executeassembly.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="assemblyFile" /> es <see langword="null" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">No se ha encontrado <paramref name="assemblyFile" />.</exception>
        <exception cref="T:System.BadImageFormatException"><paramref name="assemblyFile" /> no es un ensamblado válido.  
  
O bien 
 <paramref name="assemblyFile" /> se compiló con una versión de Common Language Runtime posterior a la versión que está cargada actualmente.</exception>
        <exception cref="T:System.AppDomainUnloadedException">La operación se intenta en un dominio de aplicación descargado.</exception>
        <exception cref="T:System.IO.FileLoadException">Se cargó un ensamblado o módulo dos veces con dos evidencias diferentes.</exception>
        <exception cref="T:System.MissingMethodException">El ensamblado especificado no tiene ningún punto de entrada.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Para obtener acceso desde un archivo o directorio y para tener acceso a la información de la ruta de acceso de lectura. Enumeraciones asociadas: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</permission>
        <permission cref="T:System.Net.WebPermission">para leer un URI que no comienzan con "file://".</permission>
        <permission cref="T:System.Security.Permissions.UIPermission">Para ejecutar una aplicación de consola. Enumeración asociada: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="ExecuteAssembly">
      <MemberSignature Language="C#" Value="public int ExecuteAssembly (string assemblyFile, System.Security.Policy.Evidence assemblySecurity, string[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 ExecuteAssembly(string assemblyFile, class System.Security.Policy.Evidence assemblySecurity, string[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.ExecuteAssembly(System.String,System.Security.Policy.Evidence,System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Function ExecuteAssembly (assemblyFile As String, assemblySecurity As Evidence, args As String()) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int ExecuteAssembly(System::String ^ assemblyFile, System::Security::Policy::Evidence ^ assemblySecurity, cli::array &lt;System::String ^&gt; ^ args);" />
      <MemberSignature Language="F#" Value="abstract member ExecuteAssembly : string * System.Security.Policy.Evidence * string[] -&gt; int&#xA;override this.ExecuteAssembly : string * System.Security.Policy.Evidence * string[] -&gt; int" Usage="appDomain.ExecuteAssembly (assemblyFile, assemblySecurity, args)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.ExecuteAssembly(System.String,System.Security.Policy.Evidence,System.String[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use an overload that does not take an Evidence parameter")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("Methods which use evidence to sandbox are obsolete and will be removed in a future release of the .NET Framework. Please use an overload of ExecuteAssembly which does not take an Evidence parameter. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="assemblySecurity" Type="System.Security.Policy.Evidence" Index="1" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="args" Type="System.String[]" Index="2" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="assemblyFile">Nombre del archivo que contiene el ensamblado que se va a ejecutar.</param>
        <param name="assemblySecurity">Evidencia suministrada para el ensamblado.</param>
        <param name="args">Argumentos del punto de entrada del ensamblado.</param>
        <summary>Ejecuta el ensamblado que contiene el archivo especificado, usando la evidencia y los argumentos especificados.</summary>
        <returns>Valor devuelto por el punto de entrada del ensamblado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El ensamblado comienza a ejecutarse en el punto de entrada especificado en el encabezado de .NET Framework.  
  
 Este método no crea un nuevo proceso o un dominio de aplicación y no se ejecuta el método de punto de entrada en un nuevo subproceso.  
  
 Este método carga ensamblados utilizando la <xref:System.Reflection.Assembly.LoadFile%2A> método. También puede ejecutar ensamblados mediante la <xref:System.AppDomain.ExecuteAssemblyByName%2A> método, que carga los ensamblados que utilizan el <xref:System.Reflection.Assembly.Load%2A> método.  
  
   
  
## Examples  
 El ejemplo siguiente muestra cómo utilizar una de las sobrecargas de <xref:System.AppDomain.ExecuteAssembly%2A> en dos dominios diferentes.  
  
 [!code-cpp[AppDomain_ExecuteAssembly#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_ExecuteAssembly/CPP/executeassembly.cpp#1)]
 [!code-csharp[AppDomain_ExecuteAssembly#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_ExecuteAssembly/CS/executeassembly.cs#1)]
 [!code-vb[AppDomain_ExecuteAssembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_ExecuteAssembly/VB/executeassembly.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="assemblyFile" /> es <see langword="null" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">No se ha encontrado <paramref name="assemblyFile" />.</exception>
        <exception cref="T:System.BadImageFormatException"><paramref name="assemblyFile" /> no es un ensamblado válido.  
  
O bien 
La versión 2.0 u otra posterior de Common Language Runtime está cargada actualmente y <paramref name="assemblyFile" /> se compiló con una versión posterior.</exception>
        <exception cref="T:System.AppDomainUnloadedException">La operación se intenta en un dominio de aplicación descargado.</exception>
        <exception cref="T:System.IO.FileLoadException">Se cargó un ensamblado o módulo dos veces con dos evidencias diferentes.</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="assemblySecurity" /> no es <see langword="null" />. Cuando no se habilita la directiva CAS heredada, <paramref name="assemblySecurity" /> debe ser <see langword="null" />.</exception>
        <exception cref="T:System.MissingMethodException">El ensamblado especificado no tiene ningún punto de entrada.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">para cargar un ensamblado con la evidencia. Enumeración asociada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Para obtener acceso desde un archivo o directorio y para tener acceso a la información de la ruta de acceso de lectura. Enumeraciones asociadas: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</permission>
        <permission cref="T:System.Net.WebPermission">para leer un URI que no comienzan con "file://".</permission>
        <permission cref="T:System.Security.Permissions.UIPermission">Para ejecutar una aplicación de consola. Enumeración asociada: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="ExecuteAssembly">
      <MemberSignature Language="C#" Value="public int ExecuteAssembly (string assemblyFile, string[] args, byte[] hashValue, System.Configuration.Assemblies.AssemblyHashAlgorithm hashAlgorithm);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ExecuteAssembly(string assemblyFile, string[] args, unsigned int8[] hashValue, valuetype System.Configuration.Assemblies.AssemblyHashAlgorithm hashAlgorithm) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.ExecuteAssembly(System.String,System.String[],System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)" />
      <MemberSignature Language="VB.NET" Value="Public Function ExecuteAssembly (assemblyFile As String, args As String(), hashValue As Byte(), hashAlgorithm As AssemblyHashAlgorithm) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int ExecuteAssembly(System::String ^ assemblyFile, cli::array &lt;System::String ^&gt; ^ args, cli::array &lt;System::Byte&gt; ^ hashValue, System::Configuration::Assemblies::AssemblyHashAlgorithm hashAlgorithm);" />
      <MemberSignature Language="F#" Value="member this.ExecuteAssembly : string * string[] * byte[] * System.Configuration.Assemblies.AssemblyHashAlgorithm -&gt; int" Usage="appDomain.ExecuteAssembly (assemblyFile, args, hashValue, hashAlgorithm)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="args" Type="System.String[]" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="hashValue" Type="System.Byte[]" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="hashAlgorithm" Type="System.Configuration.Assemblies.AssemblyHashAlgorithm" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="assemblyFile">Nombre del archivo que contiene el ensamblado que se va a ejecutar.</param>
        <param name="args">Argumentos del punto de entrada del ensamblado.</param>
        <param name="hashValue">Representa el valor del código hash calculado.</param>
        <param name="hashAlgorithm">Representa el algoritmo hash que usa el manifiesto del ensamblado.</param>
        <summary>Ejecuta el ensamblado contenido en el archivo especificado, usando los argumentos, el valor hash y el algoritmo hash especificados.</summary>
        <returns>Valor devuelto por el punto de entrada del ensamblado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El ensamblado comienza a ejecutarse en el punto de entrada especificado en el encabezado de .NET Framework.  
  
 Este método no crea un nuevo proceso o un dominio de aplicación y no se ejecuta el método de punto de entrada en un nuevo subproceso.  
  
 Este método carga ensamblados utilizando la <xref:System.Reflection.Assembly.LoadFile%2A> método. También puede ejecutar ensamblados mediante la <xref:System.AppDomain.ExecuteAssemblyByName%2A> método, que carga los ensamblados que utilizan el <xref:System.Reflection.Assembly.Load%2A> método.  
  
   
  
## Examples  
 El ejemplo siguiente muestra cómo utilizar una de las sobrecargas de <xref:System.AppDomain.ExecuteAssembly%2A> en dos dominios diferentes.  
  
 [!code-cpp[AppDomain_ExecuteAssembly#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_ExecuteAssembly/CPP/executeassembly.cpp#1)]
 [!code-csharp[AppDomain_ExecuteAssembly#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_ExecuteAssembly/CS/executeassembly.cs#1)]
 [!code-vb[AppDomain_ExecuteAssembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_ExecuteAssembly/VB/executeassembly.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="assemblyFile" /> es <see langword="null" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">No se ha encontrado <paramref name="assemblyFile" />.</exception>
        <exception cref="T:System.BadImageFormatException"><paramref name="assemblyFile" /> no es un ensamblado válido.  
  
O bien 
 <paramref name="assemblyFile" /> se compiló con una versión de Common Language Runtime posterior a la versión que está cargada actualmente.</exception>
        <exception cref="T:System.AppDomainUnloadedException">La operación se intenta en un dominio de aplicación descargado.</exception>
        <exception cref="T:System.IO.FileLoadException">Se cargó un ensamblado o módulo dos veces con dos evidencias diferentes.</exception>
        <exception cref="T:System.MissingMethodException">El ensamblado especificado no tiene ningún punto de entrada.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Para obtener acceso desde un archivo o directorio y para tener acceso a la información de la ruta de acceso de lectura. Enumeraciones asociadas: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</permission>
        <permission cref="T:System.Net.WebPermission">para leer un URI que no comienzan con "file://".</permission>
        <permission cref="T:System.Security.Permissions.UIPermission">Para ejecutar una aplicación de consola. Enumeración asociada: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="ExecuteAssembly">
      <MemberSignature Language="C#" Value="public int ExecuteAssembly (string assemblyFile, System.Security.Policy.Evidence assemblySecurity, string[] args, byte[] hashValue, System.Configuration.Assemblies.AssemblyHashAlgorithm hashAlgorithm);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ExecuteAssembly(string assemblyFile, class System.Security.Policy.Evidence assemblySecurity, string[] args, unsigned int8[] hashValue, valuetype System.Configuration.Assemblies.AssemblyHashAlgorithm hashAlgorithm) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.ExecuteAssembly(System.String,System.Security.Policy.Evidence,System.String[],System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)" />
      <MemberSignature Language="VB.NET" Value="Public Function ExecuteAssembly (assemblyFile As String, assemblySecurity As Evidence, args As String(), hashValue As Byte(), hashAlgorithm As AssemblyHashAlgorithm) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int ExecuteAssembly(System::String ^ assemblyFile, System::Security::Policy::Evidence ^ assemblySecurity, cli::array &lt;System::String ^&gt; ^ args, cli::array &lt;System::Byte&gt; ^ hashValue, System::Configuration::Assemblies::AssemblyHashAlgorithm hashAlgorithm);" />
      <MemberSignature Language="F#" Value="member this.ExecuteAssembly : string * System.Security.Policy.Evidence * string[] * byte[] * System.Configuration.Assemblies.AssemblyHashAlgorithm -&gt; int" Usage="appDomain.ExecuteAssembly (assemblyFile, assemblySecurity, args, hashValue, hashAlgorithm)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use an overload that does not take an Evidence parameter")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("Methods which use evidence to sandbox are obsolete and will be removed in a future release of the .NET Framework. Please use an overload of ExecuteAssembly which does not take an Evidence parameter. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="assemblySecurity" Type="System.Security.Policy.Evidence" Index="1" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="args" Type="System.String[]" Index="2" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="hashValue" Type="System.Byte[]" Index="3" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="hashAlgorithm" Type="System.Configuration.Assemblies.AssemblyHashAlgorithm" Index="4" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="assemblyFile">Nombre del archivo que contiene el ensamblado que se va a ejecutar.</param>
        <param name="assemblySecurity">Evidencia suministrada para el ensamblado.</param>
        <param name="args">Argumentos del punto de entrada del ensamblado.</param>
        <param name="hashValue">Representa el valor del código hash calculado.</param>
        <param name="hashAlgorithm">Representa el algoritmo hash que usa el manifiesto del ensamblado.</param>
        <summary>Ejecuta el ensamblado contenido en el archivo especificado, usando la evidencia, los argumentos, el valor hash y el algoritmo hash especificados.</summary>
        <returns>Valor devuelto por el punto de entrada del ensamblado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El ensamblado comienza a ejecutarse en el punto de entrada especificado en el encabezado de .NET Framework.  
  
 Este método no crea un nuevo proceso o un dominio de aplicación y no se ejecuta el método de punto de entrada en un nuevo subproceso.  
  
 Este método carga ensamblados utilizando la <xref:System.Reflection.Assembly.LoadFile%2A> método. También puede ejecutar ensamblados mediante la <xref:System.AppDomain.ExecuteAssemblyByName%2A> método, que carga los ensamblados que utilizan el <xref:System.Reflection.Assembly.Load%2A> método.  
  
   
  
## Examples  
 Ejemplo de Thefollowing muestra cómo utilizar una de las sobrecargas de <xref:System.AppDomain.ExecuteAssembly%2A> en dos dominios diferentes.  
  
 [!code-cpp[AppDomain_ExecuteAssembly#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_ExecuteAssembly/CPP/executeassembly.cpp#1)]
 [!code-csharp[AppDomain_ExecuteAssembly#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_ExecuteAssembly/CS/executeassembly.cs#1)]
 [!code-vb[AppDomain_ExecuteAssembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_ExecuteAssembly/VB/executeassembly.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="assemblyFile" /> es <see langword="null" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">No se ha encontrado <paramref name="assemblyFile" />.</exception>
        <exception cref="T:System.BadImageFormatException"><paramref name="assemblyFile" /> no es un ensamblado válido.  
  
O bien 
La versión 2.0 u otra posterior de Common Language Runtime está cargada actualmente y <paramref name="assemblyFile" /> se compiló con una versión posterior.</exception>
        <exception cref="T:System.AppDomainUnloadedException">La operación se intenta en un dominio de aplicación descargado.</exception>
        <exception cref="T:System.IO.FileLoadException">Se cargó un ensamblado o módulo dos veces con dos evidencias diferentes.</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="assemblySecurity" /> no es <see langword="null" />. Cuando no se habilita la directiva CAS heredada, <paramref name="assemblySecurity" /> debe ser <see langword="null" />.</exception>
        <exception cref="T:System.MissingMethodException">El ensamblado especificado no tiene ningún punto de entrada.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">para cargar un ensamblado con la evidencia. Enumeración asociada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Para obtener acceso desde un archivo o directorio y para tener acceso a la información de la ruta de acceso de lectura. Enumeraciones asociadas: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</permission>
        <permission cref="T:System.Net.WebPermission">para leer un URI que no comienzan con "file://".</permission>
        <permission cref="T:System.Security.Permissions.UIPermission">Para ejecutar una aplicación de consola. Enumeración asociada: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="ExecuteAssemblyByName">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Ejecuta un ensamblado.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ExecuteAssemblyByName">
      <MemberSignature Language="C#" Value="public int ExecuteAssemblyByName (string assemblyName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ExecuteAssemblyByName(string assemblyName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.ExecuteAssemblyByName(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function ExecuteAssemblyByName (assemblyName As String) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int ExecuteAssemblyByName(System::String ^ assemblyName);" />
      <MemberSignature Language="F#" Value="member this.ExecuteAssemblyByName : string -&gt; int" Usage="appDomain.ExecuteAssemblyByName assemblyName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="assemblyName">Nombre para mostrar del ensamblado. Vea <see cref="P:System.Reflection.Assembly.FullName" />.</param>
        <summary>Ejecuta un ensamblado a partir de su nombre para mostrar.</summary>
        <returns>Valor devuelto por el punto de entrada del ensamblado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.AppDomain.ExecuteAssemblyByName%2A> método proporciona una funcionalidad similar a la <xref:System.AppDomain.ExecuteAssembly%2A> método, pero especifica el ensamblado por nombre para mostrar o <xref:System.Reflection.AssemblyName> en lugar de por la ubicación del archivo. Por lo tanto, <xref:System.AppDomain.ExecuteAssemblyByName%2A> carga ensamblados con el <xref:System.Reflection.Assembly.Load%2A> método en lugar de con el <xref:System.Reflection.Assembly.LoadFile%2A> método.  
  
 El ensamblado comienza a ejecutarse en el punto de entrada especificado en el encabezado de .NET Framework.  
  
 Este método no crea un nuevo proceso o un dominio de aplicación y no se ejecuta el método de punto de entrada en un nuevo subproceso.  
  
 Para crear el <xref:System.AppDomain> para cargar y ejecutar, utilice el <xref:System.AppDomain.CreateDomain%2A> método.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="assemblyName" /> es <see langword="null" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">El ensamblado especificado por <paramref name="assemblyName" /> no se encuentra.</exception>
        <exception cref="T:System.BadImageFormatException">El ensamblado especificado por <paramref name="assemblyName" /> no es válido.  
  
O bien 
La versión 2.0 u otra posterior de Common Language Runtime está cargada actualmente y <paramref name="assemblyName" /> se compiló con una versión posterior.</exception>
        <exception cref="T:System.AppDomainUnloadedException">La operación se intenta en un dominio de aplicación descargado.</exception>
        <exception cref="T:System.IO.FileLoadException">El ensamblado especificado por <paramref name="assemblyName" /> se encontró, pero no se pudo cargar.</exception>
        <exception cref="T:System.MissingMethodException">El ensamblado especificado no tiene ningún punto de entrada.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Para obtener acceso leer de un archivo o directorio para el acceso a la información de la ruta de acceso y para redirigir un nombre para mostrar a una ruta de acceso. Enumeraciones asociadas: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</permission>
        <permission cref="T:System.Net.WebPermission">Para obtener acceso a un sitio Web, cuando un nombre para mostrar se redirige a una dirección URL.</permission>
        <permission cref="T:System.Security.Permissions.UIPermission">Para ejecutar una aplicación de consola. Enumeración asociada: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <altmember cref="T:System.Reflection.AssemblyName" />
        <altmember cref="M:System.Reflection.Assembly.Load(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="ExecuteAssemblyByName">
      <MemberSignature Language="C#" Value="public int ExecuteAssemblyByName (System.Reflection.AssemblyName assemblyName, params string[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ExecuteAssemblyByName(class System.Reflection.AssemblyName assemblyName, string[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.ExecuteAssemblyByName(System.Reflection.AssemblyName,System.String[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int ExecuteAssemblyByName(System::Reflection::AssemblyName ^ assemblyName, ... cli::array &lt;System::String ^&gt; ^ args);" />
      <MemberSignature Language="F#" Value="member this.ExecuteAssemblyByName : System.Reflection.AssemblyName * string[] -&gt; int" Usage="appDomain.ExecuteAssemblyByName (assemblyName, args)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.Reflection.AssemblyName" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="args" Type="System.String[]" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <Attributes>
            <Attribute FrameworkAlternate="netcore-2.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="assemblyName">Objeto <see cref="T:System.Reflection.AssemblyName" /> que representa el nombre del ensamblado.</param>
        <param name="args">Argumentos de línea de comandos que se van a pasar al iniciar el proceso.</param>
        <summary>Ejecuta el ensamblado a partir de un objeto <see cref="T:System.Reflection.AssemblyName" />, usando los argumentos especificados.</summary>
        <returns>Valor devuelto por el punto de entrada del ensamblado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.AppDomain.ExecuteAssemblyByName%2A> método proporciona una funcionalidad similar a la <xref:System.AppDomain.ExecuteAssembly%2A> método, pero especifica el ensamblado por nombre para mostrar o <xref:System.Reflection.AssemblyName> en lugar de por la ubicación del archivo. Por lo tanto, <xref:System.AppDomain.ExecuteAssemblyByName%2A> carga ensamblados con el <xref:System.Reflection.Assembly.Load%2A> método en lugar de con el <xref:System.Reflection.Assembly.LoadFile%2A> método.  
  
 El ensamblado comienza a ejecutarse en el punto de entrada especificado en el encabezado de .NET Framework.  
  
 Este método no crea un nuevo proceso o un dominio de aplicación y no se ejecuta el método de punto de entrada en un nuevo subproceso.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.FileNotFoundException">El ensamblado especificado por <paramref name="assemblyName" /> no se encuentra.</exception>
        <exception cref="T:System.IO.FileLoadException">El ensamblado especificado por <paramref name="assemblyName" /> se encontró, pero no se pudo cargar.</exception>
        <exception cref="T:System.BadImageFormatException">El ensamblado especificado por <paramref name="assemblyName" /> no es válido.  
  
O bien 
 <paramref name="assemblyName" /> se compiló con una versión de Common Language Runtime posterior a la versión que está cargada actualmente.</exception>
        <exception cref="T:System.AppDomainUnloadedException">La operación se intenta en un dominio de aplicación descargado.</exception>
        <exception cref="T:System.MissingMethodException">El ensamblado especificado no tiene ningún punto de entrada.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Para obtener acceso leer de un archivo o directorio para el acceso a la información de la ruta de acceso y para redirigir un nombre para mostrar a una ruta de acceso. Enumeraciones asociadas: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</permission>
        <permission cref="T:System.Net.WebPermission">Para obtener acceso a un sitio Web, cuando un nombre para mostrar se redirige a una dirección URL.</permission>
        <permission cref="T:System.Security.Permissions.UIPermission">Para ejecutar una aplicación de consola. Enumeración asociada: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="ExecuteAssemblyByName">
      <MemberSignature Language="C#" Value="public int ExecuteAssemblyByName (string assemblyName, System.Security.Policy.Evidence assemblySecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ExecuteAssemblyByName(string assemblyName, class System.Security.Policy.Evidence assemblySecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.ExecuteAssemblyByName(System.String,System.Security.Policy.Evidence)" />
      <MemberSignature Language="VB.NET" Value="Public Function ExecuteAssemblyByName (assemblyName As String, assemblySecurity As Evidence) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int ExecuteAssemblyByName(System::String ^ assemblyName, System::Security::Policy::Evidence ^ assemblySecurity);" />
      <MemberSignature Language="F#" Value="member this.ExecuteAssemblyByName : string * System.Security.Policy.Evidence -&gt; int" Usage="appDomain.ExecuteAssemblyByName (assemblyName, assemblySecurity)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use an overload that does not take an Evidence parameter")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("Methods which use evidence to sandbox are obsolete and will be removed in a future release of the .NET Framework. Please use an overload of ExecuteAssemblyByName which does not take an Evidence parameter. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="assemblySecurity" Type="System.Security.Policy.Evidence" Index="1" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="assemblyName">Nombre para mostrar del ensamblado. Vea <see cref="P:System.Reflection.Assembly.FullName" />.</param>
        <param name="assemblySecurity">Evidencia para cargar el ensamblado.</param>
        <summary>Ejecuta un ensamblado a partir de su nombre para mostrar, usando la evidencia especificada.</summary>
        <returns>Valor devuelto por el punto de entrada del ensamblado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.AppDomain.ExecuteAssemblyByName%2A> método proporciona una funcionalidad similar a la <xref:System.AppDomain.ExecuteAssembly%2A> método, pero especifica el ensamblado por nombre para mostrar o <xref:System.Reflection.AssemblyName> en lugar de por la ubicación del archivo. Por lo tanto, <xref:System.AppDomain.ExecuteAssemblyByName%2A> carga ensamblados con el <xref:System.Reflection.Assembly.Load%2A> método en lugar de con el <xref:System.Reflection.Assembly.LoadFile%2A> método.  
  
 El ensamblado comienza a ejecutarse en el punto de entrada especificado en el encabezado de .NET Framework.  
  
 El <xref:System.AppDomain.ExecuteAssemblyByName%2A> método no crea un nuevo proceso o un dominio de aplicación y no se ejecuta el método de punto de entrada en un nuevo subproceso.  
  
> [!NOTE]
>  Cuando se usa el <xref:System.AppDomain.ExecuteAssemblyByName%2A> método con un <xref:System.Security.Policy.Evidence> parámetro, evidencias se combinan. Evidencias proporcionada como argumento a la <xref:System.AppDomain.ExecuteAssemblyByName%2A> método sustituyen a los elementos de la evidencia proporcionada por el cargador.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="assemblyName" /> es <see langword="null" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">El ensamblado especificado por <paramref name="assemblyName" /> no se encuentra.</exception>
        <exception cref="T:System.IO.FileLoadException">El ensamblado especificado por <paramref name="assemblyName" /> se encontró, pero no se pudo cargar.</exception>
        <exception cref="T:System.BadImageFormatException">El ensamblado especificado por <paramref name="assemblyName" /> no es válido.  
  
O bien 
La versión 2.0 u otra posterior de Common Language Runtime está cargada actualmente y <paramref name="assemblyName" /> se compiló con una versión posterior.</exception>
        <exception cref="T:System.AppDomainUnloadedException">La operación se intenta en un dominio de aplicación descargado.</exception>
        <exception cref="T:System.MissingMethodException">El ensamblado especificado no tiene ningún punto de entrada.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Para obtener acceso leer de un archivo o directorio para el acceso a la información de la ruta de acceso y para redirigir un nombre para mostrar a una ruta de acceso. Enumeraciones asociadas: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">para cargar un ensamblado con la evidencia. Enumeración asociada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</permission>
        <permission cref="T:System.Net.WebPermission">Para obtener acceso a un sitio Web, cuando un nombre para mostrar se redirige a una dirección URL.</permission>
        <permission cref="T:System.Security.Permissions.UIPermission">Para ejecutar una aplicación de consola. Enumeración asociada: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <altmember cref="T:System.Security.Policy.Evidence" />
      </Docs>
    </Member>
    <Member MemberName="ExecuteAssemblyByName">
      <MemberSignature Language="C#" Value="public int ExecuteAssemblyByName (string assemblyName, params string[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ExecuteAssemblyByName(string assemblyName, string[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.ExecuteAssemblyByName(System.String,System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Function ExecuteAssemblyByName (assemblyName As String, ParamArray args As String()) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int ExecuteAssemblyByName(System::String ^ assemblyName, ... cli::array &lt;System::String ^&gt; ^ args);" />
      <MemberSignature Language="F#" Value="member this.ExecuteAssemblyByName : string * string[] -&gt; int" Usage="appDomain.ExecuteAssemblyByName (assemblyName, args)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="args" Type="System.String[]" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <Attributes>
            <Attribute FrameworkAlternate="netcore-2.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="assemblyName">Nombre para mostrar del ensamblado. Vea <see cref="P:System.Reflection.Assembly.FullName" />.</param>
        <param name="args">Argumentos de línea de comandos que se van a pasar al iniciar el proceso.</param>
        <summary>Ejecuta el ensamblado a partir de su nombre para mostrar, usando los argumentos especificados.</summary>
        <returns>Valor devuelto por el punto de entrada del ensamblado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.AppDomain.ExecuteAssemblyByName%2A> método proporciona una funcionalidad similar a la <xref:System.AppDomain.ExecuteAssembly%2A> método, pero especifica el ensamblado por nombre para mostrar o <xref:System.Reflection.AssemblyName> en lugar de por la ubicación del archivo. Por lo tanto, <xref:System.AppDomain.ExecuteAssemblyByName%2A> carga ensamblados con el <xref:System.Reflection.Assembly.Load%2A> método en lugar de con el <xref:System.Reflection.Assembly.LoadFile%2A> método.  
  
 El ensamblado comienza a ejecutarse en el punto de entrada especificado en el encabezado de .NET Framework.  
  
 Este método no crea un nuevo proceso o un dominio de aplicación y no se ejecuta el método de punto de entrada en un nuevo subproceso.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="assemblyName" /> es <see langword="null" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">El ensamblado especificado por <paramref name="assemblyName" /> no se encuentra.</exception>
        <exception cref="T:System.IO.FileLoadException">El ensamblado especificado por <paramref name="assemblyName" /> se encontró, pero no se pudo cargar.</exception>
        <exception cref="T:System.BadImageFormatException">El ensamblado especificado por <paramref name="assemblyName" /> no es válido.  
  
O bien 
 <paramref name="assemblyName" /> se compiló con una versión de Common Language Runtime posterior a la versión que está cargada actualmente.</exception>
        <exception cref="T:System.AppDomainUnloadedException">La operación se intenta en un dominio de aplicación descargado.</exception>
        <exception cref="T:System.MissingMethodException">El ensamblado especificado no tiene ningún punto de entrada.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Para obtener acceso leer de un archivo o directorio para el acceso a la información de la ruta de acceso y para redirigir un nombre para mostrar a una ruta de acceso. Enumeraciones asociadas: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</permission>
        <permission cref="T:System.Net.WebPermission">Para obtener acceso a un sitio Web, cuando un nombre para mostrar se redirige a una dirección URL.</permission>
        <permission cref="T:System.Security.Permissions.UIPermission">Para ejecutar una aplicación de consola. Enumeración asociada: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="ExecuteAssemblyByName">
      <MemberSignature Language="C#" Value="public int ExecuteAssemblyByName (System.Reflection.AssemblyName assemblyName, System.Security.Policy.Evidence assemblySecurity, params string[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ExecuteAssemblyByName(class System.Reflection.AssemblyName assemblyName, class System.Security.Policy.Evidence assemblySecurity, string[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.ExecuteAssemblyByName(System.Reflection.AssemblyName,System.Security.Policy.Evidence,System.String[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int ExecuteAssemblyByName(System::Reflection::AssemblyName ^ assemblyName, System::Security::Policy::Evidence ^ assemblySecurity, ... cli::array &lt;System::String ^&gt; ^ args);" />
      <MemberSignature Language="F#" Value="member this.ExecuteAssemblyByName : System.Reflection.AssemblyName * System.Security.Policy.Evidence * string[] -&gt; int" Usage="appDomain.ExecuteAssemblyByName (assemblyName, assemblySecurity, args)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use an overload that does not take an Evidence parameter")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("Methods which use evidence to sandbox are obsolete and will be removed in a future release of the .NET Framework. Please use an overload of ExecuteAssemblyByName which does not take an Evidence parameter. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.Reflection.AssemblyName" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="assemblySecurity" Type="System.Security.Policy.Evidence" Index="1" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="args" Type="System.String[]" Index="2" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="assemblyName">Objeto <see cref="T:System.Reflection.AssemblyName" /> que representa el nombre del ensamblado.</param>
        <param name="assemblySecurity">Evidencia para cargar el ensamblado.</param>
        <param name="args">Argumentos de línea de comandos que se van a pasar al iniciar el proceso.</param>
        <summary>Ejecuta el ensamblado a partir de un objeto <see cref="T:System.Reflection.AssemblyName" />, usando la evidencia y los argumentos especificados.</summary>
        <returns>Valor devuelto por el punto de entrada del ensamblado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.AppDomain.ExecuteAssemblyByName%2A> método proporciona una funcionalidad similar a la <xref:System.AppDomain.ExecuteAssembly%2A> método, pero especifica el ensamblado por nombre para mostrar o <xref:System.Reflection.AssemblyName> en lugar de por la ubicación del archivo. Por lo tanto, <xref:System.AppDomain.ExecuteAssemblyByName%2A> carga ensamblados con el <xref:System.Reflection.Assembly.Load%2A> método en lugar de con el <xref:System.Reflection.Assembly.LoadFile%2A> método.  
  
 El ensamblado comienza a ejecutarse en el punto de entrada especificado en el encabezado de .NET Framework.  
  
 Este método no crea un nuevo proceso o un dominio de aplicación y no se ejecuta el método de punto de entrada en un nuevo subproceso.  
  
> [!NOTE]
>  Cuando se usa el <xref:System.AppDomain.ExecuteAssemblyByName%2A> método con un <xref:System.Security.Policy.Evidence> parámetro, evidencias se combinan. Evidencias proporcionada como argumento a la <xref:System.AppDomain.ExecuteAssemblyByName%2A> método sustituyen a los elementos de la evidencia proporcionada por el cargador.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.FileNotFoundException">El ensamblado especificado por <paramref name="assemblyName" /> no se encuentra.</exception>
        <exception cref="T:System.IO.FileLoadException">El ensamblado especificado por <paramref name="assemblyName" /> se encontró, pero no se pudo cargar.</exception>
        <exception cref="T:System.BadImageFormatException">El ensamblado especificado por <paramref name="assemblyName" /> no es válido.  
  
O bien 
La versión 2.0 u otra posterior de Common Language Runtime está cargada actualmente y <paramref name="assemblyName" /> se compiló con una versión posterior.</exception>
        <exception cref="T:System.AppDomainUnloadedException">La operación se intenta en un dominio de aplicación descargado.</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="assemblySecurity" /> no es <see langword="null" />. Cuando no se habilita la directiva CAS heredada, <paramref name="assemblySecurity" /> debe ser <see langword="null" />.</exception>
        <exception cref="T:System.MissingMethodException">El ensamblado especificado no tiene ningún punto de entrada.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Para obtener acceso leer de un archivo o directorio para el acceso a la información de la ruta de acceso y para redirigir un nombre para mostrar a una ruta de acceso. Enumeraciones asociadas: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">para cargar un ensamblado con la evidencia. Enumeración asociada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</permission>
        <permission cref="T:System.Net.WebPermission">Para obtener acceso a un sitio Web, cuando un nombre para mostrar se redirige a una dirección URL.</permission>
        <permission cref="T:System.Security.Permissions.UIPermission">Para ejecutar una aplicación de consola. Enumeración asociada: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <altmember cref="T:System.Security.Policy.Evidence" />
      </Docs>
    </Member>
    <Member MemberName="ExecuteAssemblyByName">
      <MemberSignature Language="C#" Value="public int ExecuteAssemblyByName (string assemblyName, System.Security.Policy.Evidence assemblySecurity, params string[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ExecuteAssemblyByName(string assemblyName, class System.Security.Policy.Evidence assemblySecurity, string[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.ExecuteAssemblyByName(System.String,System.Security.Policy.Evidence,System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Function ExecuteAssemblyByName (assemblyName As String, assemblySecurity As Evidence, ParamArray args As String()) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int ExecuteAssemblyByName(System::String ^ assemblyName, System::Security::Policy::Evidence ^ assemblySecurity, ... cli::array &lt;System::String ^&gt; ^ args);" />
      <MemberSignature Language="F#" Value="member this.ExecuteAssemblyByName : string * System.Security.Policy.Evidence * string[] -&gt; int" Usage="appDomain.ExecuteAssemblyByName (assemblyName, assemblySecurity, args)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use an overload that does not take an Evidence parameter")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("Methods which use evidence to sandbox are obsolete and will be removed in a future release of the .NET Framework. Please use an overload of ExecuteAssemblyByName which does not take an Evidence parameter. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="assemblySecurity" Type="System.Security.Policy.Evidence" Index="1" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="args" Type="System.String[]" Index="2" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="assemblyName">Nombre para mostrar del ensamblado. Vea <see cref="P:System.Reflection.Assembly.FullName" />.</param>
        <param name="assemblySecurity">Evidencia para cargar el ensamblado.</param>
        <param name="args">Argumentos de línea de comandos que se van a pasar al iniciar el proceso.</param>
        <summary>Ejecuta el ensamblado a partir de su nombre para mostrar, usando la evidencia y argumentos especificados.</summary>
        <returns>Valor devuelto por el punto de entrada del ensamblado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.AppDomain.ExecuteAssemblyByName%2A> método proporciona una funcionalidad similar a la <xref:System.AppDomain.ExecuteAssembly%2A> método, pero especifica el ensamblado por nombre para mostrar o <xref:System.Reflection.AssemblyName> en lugar de por la ubicación del archivo. Por lo tanto, <xref:System.AppDomain.ExecuteAssemblyByName%2A> carga ensamblados con el <xref:System.Reflection.Assembly.Load%2A> método en lugar de con el <xref:System.Reflection.Assembly.LoadFile%2A> método.  
  
 El ensamblado comienza a ejecutarse en el punto de entrada especificado en el encabezado de .NET Framework.  
  
 Este método no crea un nuevo proceso o un dominio de aplicación y no se ejecuta el método de punto de entrada en un nuevo subproceso.  
  
> [!NOTE]
>  Cuando se usa el <xref:System.AppDomain.ExecuteAssemblyByName%2A> método con un <xref:System.Security.Policy.Evidence> parámetro, evidencias se combinan. Evidencias proporcionada como argumento a la <xref:System.AppDomain.ExecuteAssemblyByName%2A> método sustituyen a los elementos de la evidencia proporcionada por el cargador.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="assemblyName" /> es <see langword="null" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">El ensamblado especificado por <paramref name="assemblyName" /> no se encuentra.</exception>
        <exception cref="T:System.IO.FileLoadException">El ensamblado especificado por <paramref name="assemblyName" /> se encontró, pero no se pudo cargar.</exception>
        <exception cref="T:System.BadImageFormatException">El ensamblado especificado por <paramref name="assemblyName" /> no es válido.  
  
O bien 
La versión 2.0 u otra posterior de Common Language Runtime está cargada actualmente y <paramref name="assemblyName" /> se compiló con una versión posterior.</exception>
        <exception cref="T:System.AppDomainUnloadedException">La operación se intenta en un dominio de aplicación descargado.</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="assemblySecurity" /> no es <see langword="null" />. Cuando no se habilita la directiva CAS heredada, <paramref name="assemblySecurity" /> debe ser <see langword="null" />.</exception>
        <exception cref="T:System.MissingMethodException">El ensamblado especificado no tiene ningún punto de entrada.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Para obtener acceso leer de un archivo o directorio para el acceso a la información de la ruta de acceso y para redirigir un nombre para mostrar a una ruta de acceso. Enumeraciones asociadas: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">para cargar un ensamblado con la evidencia. Enumeración asociada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</permission>
        <permission cref="T:System.Net.WebPermission">Para obtener acceso a un sitio Web, cuando un nombre para mostrar se redirige a una dirección URL.</permission>
        <permission cref="T:System.Security.Permissions.UIPermission">Para ejecutar una aplicación de consola. Enumeración asociada: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <altmember cref="T:System.Security.Policy.Evidence" />
      </Docs>
    </Member>
    <Member MemberName="FirstChanceException">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Runtime.ExceptionServices.FirstChanceExceptionEventArgs&gt; FirstChanceException;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Runtime.ExceptionServices.FirstChanceExceptionEventArgs&gt; FirstChanceException" />
      <MemberSignature Language="DocId" Value="E:System.AppDomain.FirstChanceException" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event FirstChanceException As EventHandler(Of FirstChanceExceptionEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler&lt;System::Runtime::ExceptionServices::FirstChanceExceptionEventArgs ^&gt; ^ FirstChanceException;" />
      <MemberSignature Language="F#" Value="member this.FirstChanceException : EventHandler&lt;System.Runtime.ExceptionServices.FirstChanceExceptionEventArgs&gt; " Usage="member this.FirstChanceException : System.EventHandler&lt;System.Runtime.ExceptionServices.FirstChanceExceptionEventArgs&gt; " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>add: System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>remove: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Runtime.ExceptionServices.FirstChanceExceptionEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ocurre cuando se produce una excepción en código administrado, antes de que el runtime busque un controlador de excepciones en la pila de llamadas del dominio de aplicación.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este evento es sólo una notificación. Controle este evento no controla la excepción ni afectan de ninguna forma de control de excepciones posteriores. Después de que se ha provocado el evento y se han invocado los controladores de eventos, common language runtime (CLR) comienza a buscar un controlador para la excepción. <xref:System.AppDomain.FirstChanceException> proporciona el dominio de aplicación con la primera oportunidad de examinar cualquier excepción administrada.  
  
 El evento se puede controlar por dominio de aplicación. Si un subproceso pasa a través de varios dominios de aplicación mientras se ejecuta una llamada, el evento se produce en cada dominio de aplicación que ha registrado un controlador de eventos, antes de que el CLR comienza a buscar un controlador de excepciones coincidente en ese dominio de aplicación. Después de que se ha controlado el evento, se realizará una búsqueda de un controlador de excepciones coincidente en ese dominio de aplicación. Si se encuentra ninguno, se produce el evento en el siguiente dominio de aplicación.  
  
 Debe controlar todas las excepciones que se producen en el evento del controlador para el <xref:System.AppDomain.FirstChanceException> eventos. En caso contrario, <xref:System.AppDomain.FirstChanceException> es generada de forma recursiva. Esto podría producir un desbordamiento de pila y la finalización de la aplicación. Se recomienda implementar controladores de eventos para este evento como regiones de ejecución restringida (CER), para evitar que las excepciones relacionadas con la infraestructura como de memoria insuficiente o desbordamiento de pila que afectan a la máquina virtual mientras la notificación de excepción es se está procesando.  
  
 Este evento no se genera para las excepciones que indican los daños de estado del proceso, como las infracciones de acceso, a menos que el controlador de eventos es crítico para la seguridad y tiene el <xref:System.Runtime.ExceptionServices.HandleProcessCorruptedStateExceptionsAttribute> atributo.  
  
 Common language runtime suspende las anulaciones de subprocesos mientras se controla este evento de notificación.  
  
   
  
## Examples  
 En el ejemplo siguiente se crea una serie de dominios de aplicación denominada `AD0` a través de `AD3`, con un `Worker` objeto en cada dominio de aplicación. Cada `Worker` objeto tiene una referencia a la `Worker` objeto en el siguiente dominio de aplicación, excepto para el `Worker` en el último dominio de aplicación. El <xref:System.AppDomain.FirstChanceException> evento se controla en todos los dominios de aplicación, excepto `AD1`.  
  
> [!NOTE]
>  Además de este ejemplo, que muestra las notificaciones de excepciones de primera oportunidad en varios dominios de aplicación, puede encontrar casos de uso sencillos de [Cómo: Recibir notificaciones de excepciones de primera oportunidad](~/docs/framework/app-domains/how-to-receive-first-chance-exception-notifications.md).  
  
 Cuando se han creado los dominios de aplicación, el dominio de aplicación predeterminado llama el `TestException` método para el primer dominio de aplicación. Cada `Worker` de objeto llama el `TestException` método del siguiente dominio de aplicación, hasta el último `Worker` produce una excepción que es controlada o no. Por lo tanto, el subproceso actual se pasa a través de todos los dominios de aplicación, y `TestException` se agrega a la pila en cada dominio de aplicación.  
  
 Cuando el último `Worker` objeto controla la excepción, el <xref:System.AppDomain.FirstChanceException> evento se produce solo en el último dominio de aplicación. Los demás dominios de aplicación nunca tienen la oportunidad para controlar la excepción, por lo que no se genera el evento.  
  
 Cuando el último `Worker` objeto no controla la excepción, el <xref:System.AppDomain.FirstChanceException> evento se genera en cada dominio de aplicación que tiene un controlador de eventos. Una vez terminada cada controlador de eventos, la pila continúa desenredar hasta que la excepción ha sido detectada por el dominio de aplicación predeterminado.  
  
> [!NOTE]
>  Para ver cómo la presentación de la pila crece a medida que se genera el evento más cercanos y cuanto más se acerque al dominio de aplicación predeterminado, cambie `e.Exception.Message` a `e.Exception` en el `FirstChanceHandler` controladores de eventos. Tenga en cuenta que, cuando `TestException` se llama a través de los límites del dominio de aplicación, aparece dos veces: una vez para el proxy y otra para el código auxiliar.  
  
 [!code-csharp[System.AppDomain.FirstChanceException#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.appdomain.firstchanceexception/cs/example.cs#1)]
 [!code-vb[System.AppDomain.FirstChanceException#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.appdomain.firstchanceexception/vb/example.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requiere plena confianza para el llamador inmediato. Este miembro no se puede usar código de confianza parcial o transparente.</permission>
        <altmember cref="T:System.Runtime.ExceptionServices.FirstChanceExceptionEventArgs" />
        <altmember cref="E:System.AppDomain.UnhandledException" />
        <related type="Article" href="https://msdn.microsoft.com/library/66f002b8-a97d-4a6e-a503-2cec01689113">Cómo: Recibir notificaciones de excepciones de primera oportunidad</related>
      </Docs>
    </Member>
    <Member MemberName="FriendlyName">
      <MemberSignature Language="C#" Value="public string FriendlyName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string FriendlyName" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.FriendlyName" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property FriendlyName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ FriendlyName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.FriendlyName : string" Usage="System.AppDomain.FriendlyName" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System._AppDomain.FriendlyName</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene el nombre descriptivo de este dominio de aplicación.</summary>
        <value>Nombre descriptivo de este dominio de aplicación.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El nombre descriptivo del dominio de aplicación predeterminado es el nombre de archivo del proceso ejecutable. Por ejemplo, si usa el archivo ejecutable para iniciar el proceso es `"c:\MyAppDirectory\MyAssembly.exe"`, es el nombre descriptivo del dominio de aplicación predeterminado `"MyAssembly.exe"`.  
  
   
  
## Examples  
 El siguiente ejemplo de código utiliza el <xref:System.AppDomain.FriendlyName%2A> propiedad va a obtener el nombre descriptivo del dominio de aplicación actual. Para el dominio de aplicación predeterminado, el nombre descriptivo es el nombre del archivo ejecutable de la aplicación. El ejemplo de código también muestra información adicional sobre el dominio de aplicación.  
  
 [!code-cpp[ADApplicationBase#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADApplicationBase/CPP/adapplicationbase.cpp#1)]
 [!code-csharp[ADApplicationBase#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADApplicationBase/CS/adapplicationbase.cs#1)]
 [!code-vb[ADApplicationBase#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADApplicationBase/VB/adapplicationbase.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException">La operación se intenta en un dominio de aplicación descargado.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetAssemblies">
      <MemberSignature Language="C#" Value="public System.Reflection.Assembly[] GetAssemblies ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Assembly[] GetAssemblies() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.GetAssemblies" />
      <MemberSignature Language="VB.NET" Value="Public Function GetAssemblies () As Assembly()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::Assembly ^&gt; ^ GetAssemblies();" />
      <MemberSignature Language="F#" Value="abstract member GetAssemblies : unit -&gt; System.Reflection.Assembly[]&#xA;override this.GetAssemblies : unit -&gt; System.Reflection.Assembly[]" Usage="appDomain.GetAssemblies " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.GetAssemblies</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Obtiene los ensamblados que se han cargado en el contexto de ejecución de este dominio de aplicación.</summary>
        <returns>Matriz de ensamblados de este dominio de aplicación.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 El siguiente ejemplo de código utiliza el <xref:System.AppDomain.GetAssemblies%2A> método para obtener una lista de todos los ensamblados que se han cargado en el dominio de aplicación. Los ensamblados, a continuación, se muestran en la consola.  
  
 Para ejecutar este ejemplo de código, deberá crear un ensamblado denominado `CustomLibrary.dll`, o cambiar el nombre del ensamblado que se pasa a la <xref:System.AppDomain.GetAssemblies%2A> método.  
  
 [!code-cpp[ADGetAssemblies#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADGetAssemblies/CPP/adgetassemblies.cpp#1)]
 [!code-csharp[ADGetAssemblies#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADGetAssemblies/CS/adgetassemblies.cs#1)]
 [!code-vb[ADGetAssemblies#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADGetAssemblies/VB/adgetassemblies.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException">La operación se intenta en un dominio de aplicación descargado.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetCurrentThreadId">
      <MemberSignature Language="C#" Value="public static int GetCurrentThreadId ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 GetCurrentThreadId() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.GetCurrentThreadId" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetCurrentThreadId () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int GetCurrentThreadId();" />
      <MemberSignature Language="F#" Value="static member GetCurrentThreadId : unit -&gt; int" Usage="System.AppDomain.GetCurrentThreadId " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("AppDomain.GetCurrentThreadId has been deprecated because it does not provide a stable Id when managed threads are running on fibers (aka lightweight threads). To get a stable identifier for a managed thread, use the ManagedThreadId property on Thread.'")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.Obsolete("AppDomain.GetCurrentThreadId has been deprecated because it does not provide a stable Id when managed threads are running on fibers (aka lightweight threads). To get a stable identifier for a managed thread, use the ManagedThreadId property on Thread.  http://go.microsoft.com/fwlink/?linkid=14202", false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-3.0">
          <AttributeName>System.Obsolete("AppDomain.GetCurrentThreadId has been deprecated because it does not provide a stable Id when managed threads are running on fibers (aka lightweight threads). To get a stable identifier for a managed thread, use the ManagedThreadId property on Thread.  https://go.microsoft.com/fwlink/?linkid=14202", false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Obtiene el identificador del subproceso actual.</summary>
        <returns>Entero de 32 bits con signo que representa el identificador del actual subproceso.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use el <xref:System.Threading.Thread.ManagedThreadId%2A?displayProperty=nameWithType> propiedad, que es estable incluso cuando .NET Framework está hospedada en un entorno que admite fibras (es decir, subprocesos pequeños).  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">llamar a este método. Enumeración asociada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />. Acción de seguridad: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />.</permission>
        <altmember cref="T:System.Int32" />
        <altmember cref="P:System.Threading.Thread.ManagedThreadId" />
      </Docs>
    </Member>
    <Member MemberName="GetData">
      <MemberSignature Language="C#" Value="public object GetData (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object GetData(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.GetData(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetData (name As String) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ GetData(System::String ^ name);" />
      <MemberSignature Language="F#" Value="abstract member GetData : string -&gt; obj&#xA;override this.GetData : string -&gt; obj" Usage="appDomain.GetData name" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.GetData(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Nombre de una propiedad de dominio de aplicación predefinida o nombre de una propiedad de dominio de aplicación que se haya definido.</param>
        <summary>Obtiene el valor almacenado en el dominio de aplicación actual para el nombre especificado.</summary>
        <returns>El valor de la propiedad o <paramref name="name" /> o <see langword="null" /> si la propiedad no existe.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use este método para recuperar el valor de una entrada en una memoria caché interna de pares de nombre y datos que describen las propiedades de esta instancia de <xref:System.AppDomain>. Tenga en cuenta que la comparación de `name` con el nombre de pares de clave y valor distingue mayúsculas de minúsculas.  
  
 La memoria caché contiene automáticamente las entradas del sistema predefinidos que se insertan cuando se crea el dominio de aplicación. Puede examinar sus valores con el <xref:System.AppDomain.GetData%2A> método o el equivalente <xref:System.AppDomainSetup> propiedades.  
  
 Puede insertar o modificar sus propios pares de nombre y datos definidos por el usuario con el <xref:System.AppDomain.SetData%2A> método y examinar sus valores con el <xref:System.AppDomain.GetData%2A> método.  
  
 La tabla siguiente se describen los `name` de cada entrada de sistema y su correspondiente predefinidos <xref:System.AppDomainSetup> propiedad.  
  
|Valor de 'name'|Propiedad.|  
|---------------------|--------------|  
|"RAÍZ (APPBASE)"|<xref:System.AppDomainSetup.ApplicationBase%2A?displayProperty=nameWithType>|  
|"APP_CONFIG_FILE"|<xref:System.AppDomainSetup.ConfigurationFile%2A?displayProperty=nameWithType>|  
|"APP_LAUNCH_URL"|(ninguna propiedad)<br /><br /> "APP_LAUNCH_URL" representa la dirección URL solicitada originalmente por el usuario, antes de cualquier redirección. Está disponible solo cuando la aplicación se ha iniciado con un explorador como Internet Explorer. No todos los exploradores proporcionan este valor.|  
|"APP_NAME"|<xref:System.AppDomainSetup.ApplicationName%2A?displayProperty=nameWithType>|  
|"BINPATH_PROBE_ONLY"|<xref:System.AppDomainSetup.PrivateBinPathProbe%2A?displayProperty=nameWithType>|  
|"CACHE_BASE"|<xref:System.AppDomainSetup.CachePath%2A?displayProperty=nameWithType>|  
|"CODE_DOWNLOAD_DISABLED"|<xref:System.AppDomainSetup.DisallowCodeDownload%2A?displayProperty=nameWithType>|  
|"DEV_PATH"|(ninguna propiedad)|  
|"DISALLOW_APP"|<xref:System.AppDomainSetup.DisallowPublisherPolicy%2A?displayProperty=nameWithType>|  
|"DISALLOW_APP_BASE_PROBING"|<xref:System.AppDomainSetup.DisallowApplicationBaseProbing%2A?displayProperty=nameWithType>|  
|"DISALLOW_APP_REDIRECTS"|<xref:System.AppDomainSetup.DisallowBindingRedirects%2A?displayProperty=nameWithType>|  
|"DYNAMIC_BASE"|<xref:System.AppDomainSetup.DynamicBase%2A?displayProperty=nameWithType>|  
|"FORCE_CACHE_INSTALL"|<xref:System.AppDomainSetup.ShadowCopyFiles%2A?displayProperty=nameWithType>|  
|"LICENSE_FILE" o una cadena específica de la aplicación|<xref:System.AppDomainSetup.LicenseFile%2A?displayProperty=nameWithType>|  
|"LOADER_OPTIMIZATION"|<xref:System.AppDomainSetup.LoaderOptimization%2A?displayProperty=nameWithType>|  
|"LOCATION_URI"|(ninguna propiedad)|  
|"PRIVATE_BINPATH"|<xref:System.AppDomainSetup.PrivateBinPath%2A?displayProperty=nameWithType>|  
|"REGEX_DEFAULT_MATCH_TIMEOUT"|<xref:System.Text.RegularExpressions.Regex.MatchTimeout%2A?displayProperty=nameWithType><br /><br /> "REGEX_DEFAULT_MATCH_TIMEOUT" no es una entrada de sistema y su valor se puede establecer mediante una llamada a la <xref:System.AppDomain.SetData%2A> método.|  
|"SHADOW_COPY_DIRS"|<xref:System.AppDomainSetup.ShadowCopyDirectories%2A?displayProperty=nameWithType>|  
  
   
  
## Examples  
 El ejemplo siguiente crea un nuevo dominio de aplicación, establece un valor proporcionado por el sistema para el dominio y agrega un nuevo par de valor para el dominio. El ejemplo, a continuación, muestra cómo usar el <xref:System.AppDomain.GetData%2A> método para recuperar los datos de estos pares de valor y mostrarlos en la consola.  
  
 [!code-cpp[ADGetData#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADGetData/CPP/adgetdata.cpp#1)]
 [!code-csharp[ADGetData#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADGetData/CS/adgetdata.cs#1)]
 [!code-vb[ADGetData#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADGetData/VB/adgetdata.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> es <see langword="null" />.</exception>
        <exception cref="T:System.AppDomainUnloadedException">La operación se intenta en un dominio de aplicación descargado.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Para obtener acceso a la información de la ruta de acceso, si la propiedad se aplica a una ruta de acceso. Enumeración asociada: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</permission>
        <altmember cref="M:System.AppDomain.SetData(System.String,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public Type GetType ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.GetType" />
      <MemberSignature Language="VB.NET" Value="Public Function GetType () As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ GetType();" />
      <MemberSignature Language="F#" Value="override this.GetType : unit -&gt; Type" Usage="appDomain.GetType " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.GetType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Obtiene el tipo de la instancia actual.</summary>
        <returns>Tipo de la instancia actual.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Id">
      <MemberSignature Language="C#" Value="public int Id { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Id" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.Id" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Id As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Id { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Id : int" Usage="System.AppDomain.Id" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>get: System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene un entero que identifica únicamente el dominio de aplicación en el proceso.</summary>
        <value>Entero que identifica el dominio de aplicación.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 En el ejemplo de código siguiente se crea un segundo dominio de aplicación y muestra información sobre el dominio predeterminado y el nuevo dominio.  
  
 [!code-cpp[System.AppDomain.IsDefaultAppDomain#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.AppDomain.IsDefaultAppDomain/CPP/System.AppDomain.IsDefaultAppDomain.cpp#1)]
 [!code-csharp[System.AppDomain.IsDefaultAppDomain#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.AppDomain.IsDefaultAppDomain/CS/source.cs#1)]
 [!code-vb[System.AppDomain.IsDefaultAppDomain#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.AppDomain.IsDefaultAppDomain/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="InitializeLifetimeService">
      <MemberSignature Language="C#" Value="public override object InitializeLifetimeService ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance object InitializeLifetimeService() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.InitializeLifetimeService" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function InitializeLifetimeService () As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Object ^ InitializeLifetimeService();" />
      <MemberSignature Language="F#" Value="override this.InitializeLifetimeService : unit -&gt; obj" Usage="appDomain.InitializeLifetimeService " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.InitializeLifetimeService</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Concede al <see cref="T:System.AppDomain" /> una duración infinita, ya que impide que se genere una concesión.</summary>
        <returns>Siempre es <see langword="null" />.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.AppDomainUnloadedException">La operación se intenta en un dominio de aplicación descargado.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requiere plena confianza para el llamador inmediato. Este miembro no se puede usar código de confianza parcial o transparente.</permission>
      </Docs>
    </Member>
    <Member MemberName="IsCompatibilitySwitchSet">
      <MemberSignature Language="C#" Value="public Nullable&lt;bool&gt; IsCompatibilitySwitchSet (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Nullable`1&lt;bool&gt; IsCompatibilitySwitchSet(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.IsCompatibilitySwitchSet(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function IsCompatibilitySwitchSet (value As String) As Nullable(Of Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Nullable&lt;bool&gt; IsCompatibilitySwitchSet(System::String ^ value);" />
      <MemberSignature Language="F#" Value="member this.IsCompatibilitySwitchSet : string -&gt; Nullable&lt;bool&gt;" Usage="appDomain.IsCompatibilitySwitchSet value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Boolean&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="value">Modificador de compatibilidad que se va a comprobar.</param>
        <summary>Obtiene un valor booleano que acepta valores NULL que indica si se ha establecido algún modificador de compatibilidad y, en ese caso, si se ha establecido el modificador de compatibilidad especificado.</summary>
        <returns>Una referencia nula (<see langword="Nothing" /> en Visual Basic) si no se estableció ningún modificador de compatibilidad; de lo contrario, es un valor booleano que indica si se estableció el modificador de compatibilidad especificado por <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método comprueba si se ha establecido el modificador de compatibilidad especificado para el dominio de aplicación actual. Modificadores de compatibilidad normalmente restauración un comportamiento (por ejemplo, las cadenas de manera se ordenan) que se ha cambiado entre las versiones de .NET Framework.  Se establecen mediante una llamada a la <xref:System.AppDomainSetup.SetCompatibilitySwitches%2A?displayProperty=nameWithType> método antes de crear un dominio de aplicación.  
  
 En la tabla siguiente se proporciona ejemplos de modificadores de compatibilidad que se pueden establecer para restaurar el comportamiento de versiones anteriores de .NET Framework.  
  
|Modificador|Significado|  
|------------|-------------|  
|"NetFx40_LegacySecurityPolicy"|Acceso del código (CAS) para el [!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)] está habilitada en este dominio de aplicación. Consulte [ &lt;NetFx40_LegacySecurityPolicy&gt; elemento](~/docs/framework/configure-apps/file-schema/runtime/netfx40-legacysecuritypolicy-element.md).|  
|"NetFx40_Legacy20SortingBehavior"|Cadena de ordenación de los valores predeterminados para el [!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)] están habilitados en este dominio de aplicación. Su éxito requiere sort00001000.dll para instalarse. Consulte [ &lt;CompatSortNLSVersion&gt; elemento](~/docs/framework/configure-apps/file-schema/runtime/compatsortnlsversion-element.md).|  
|"NetFx40_Legacy40SortingBehavior"|Cadena de ordenación de los valores predeterminados para el [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]y Unicode 5.0 están habilitadas en este dominio de aplicación. Su éxito requiere sort00060101.dll para instalarse.|  
|"NetFx40_TimeSpanLegacyFormatMode"|<xref:System.TimeSpan> formato de comportamiento para el [!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)] está habilitada en este dominio de aplicación.  Consulte [ &lt;TimeSpan_LegacyFormatMode&gt; elemento](~/docs/framework/configure-apps/file-schema/runtime/timespan-legacyformatmode-element.md) y la sección "Restauración de formato de TimeSpan de heredado" de la <xref:System.TimeSpan> tema.|  
|"UseRandomizedStringHashAlgorithm"|El runtime calcula los códigos hash para cadenas en una por cada dominio de aplicación en lugar de usar un solo algoritmo hash que genera un código hash coherente entre dominios de aplicación. Consulte [ &lt;UseRandomizedStringHashAlgorithm&gt; elemento](~/docs/framework/configure-apps/file-schema/runtime/userandomizedstringhashalgorithm-element.md).|  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.AppDomainSetup.SetCompatibilitySwitches(System.Collections.Generic.IEnumerable{System.String})" />
      </Docs>
    </Member>
    <Member MemberName="IsDefaultAppDomain">
      <MemberSignature Language="C#" Value="public bool IsDefaultAppDomain ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsDefaultAppDomain() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.IsDefaultAppDomain" />
      <MemberSignature Language="VB.NET" Value="Public Function IsDefaultAppDomain () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsDefaultAppDomain();" />
      <MemberSignature Language="F#" Value="member this.IsDefaultAppDomain : unit -&gt; bool" Usage="appDomain.IsDefaultAppDomain " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Devuelve un valor que indica si el dominio de aplicación es el dominio de aplicación predeterminado para el proceso.</summary>
        <returns><see langword="true" /> si el objeto <see cref="T:System.AppDomain" /> actual representa el dominio de aplicación predeterminado para el proceso; de lo contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cada proceso administrado tiene un dominio de aplicación predeterminado. La ejecución comienza en el dominio predeterminado.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se crea un segundo dominio de aplicación y muestra información sobre el dominio predeterminado y el nuevo dominio.  
  
 [!code-cpp[System.AppDomain.IsDefaultAppDomain#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.AppDomain.IsDefaultAppDomain/CPP/System.AppDomain.IsDefaultAppDomain.cpp#1)]
 [!code-csharp[System.AppDomain.IsDefaultAppDomain#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.AppDomain.IsDefaultAppDomain/CS/source.cs#1)]
 [!code-vb[System.AppDomain.IsDefaultAppDomain#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.AppDomain.IsDefaultAppDomain/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsFinalizingForUnload">
      <MemberSignature Language="C#" Value="public bool IsFinalizingForUnload ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsFinalizingForUnload() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.IsFinalizingForUnload" />
      <MemberSignature Language="VB.NET" Value="Public Function IsFinalizingForUnload () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsFinalizingForUnload();" />
      <MemberSignature Language="F#" Value="member this.IsFinalizingForUnload : unit -&gt; bool" Usage="appDomain.IsFinalizingForUnload " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Indica si se está descargando este dominio de aplicación y si Common Language Runtime está finalizando los objetos que contiene.</summary>
        <returns>Es <see langword="true" /> si se está descargando este dominio de aplicación y si Common Language Runtime comenzó el proceso de invocación de los finalizadores; en caso contrario, es <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El método de finalización de un objeto proporciona una oportunidad para realizar cualquier operación de limpieza necesaria antes de que el objeto se recopila. Después de la finalización, el objeto es accesible, pero en un estado no válido y, por tanto, no utilizable. Finalmente, colección de elementos no utilizados completa y reclama el objeto.  
  
 Se llama el método de finalización de un objeto en una de las siguientes situaciones: durante la recolección de elementos no utilizados, cuando common language runtime se está cerrando, o cuando se descarga el dominio de aplicación que contiene el objeto. El <xref:System.AppDomain.IsFinalizingForUnload%2A> devuelve del método `true` sólo en el último caso; no devolver `true` si da como resultado de finalización de la rutina de recolección o de apagado CLR.  
  
> [!NOTE]
>  Para determinar si la finalización es debido al cierre del CLR, use el <xref:System.Environment.HasShutdownStarted%2A?displayProperty=nameWithType> propiedad. Devuelve `true` si tiene lugar la finalización es debido a un dominio de aplicación que se está descargando o al CLR que se va a cerrar.  
  
 Mientras se ejecutan en el método de finalización durante la descarga del dominio, puede tener acceso a otro objeto que se hace referencia a un campo estático y tiene un método de finalización. Sin embargo, no puede confiable hacerlo porque el objeto que se accede podría haber finalizado.  
  
> [!NOTE]
>  Una excepción a esta regla es la <xref:System.Console> (clase), que contiene los campos estáticos que hacen referencia a objetos de secuencia, pero se implementa especialmente por lo que siempre puede escribir en la consola del sistema, incluso durante el cierre del dominio de descarga o el sistema.  
  
 Utilice este método en el método de finalización de un objeto para determinar si se está descargando el dominio de aplicación que contiene el objeto. Si es así, no se puede tener acceso a cualquier objeto que tiene un método de finalización y se hace referencia a un campo estático confiable.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Environment.HasShutdownStarted" />
      </Docs>
    </Member>
    <Member MemberName="IsFullyTrusted">
      <MemberSignature Language="C#" Value="public bool IsFullyTrusted { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsFullyTrusted" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.IsFullyTrusted" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsFullyTrusted As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsFullyTrusted { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsFullyTrusted : bool" Usage="System.AppDomain.IsFullyTrusted" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene un valor que indica si los ensamblados que se cargan en el dominio de aplicación actual se ejecutan con plena confianza.</summary>
        <value>Es <see langword="true" /> si los ensamblados que se cargan en el dominio de aplicación actual se ejecutan con plena confianza; de lo contrario, es <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método siempre devuelve `true` para el dominio de aplicación predeterminado de una aplicación que se ejecuta en el escritorio. Devuelve `false` para un dominio de aplicación en espacio aislado que se creó mediante el <xref:System.AppDomain.CreateDomain%28System.String%2CSystem.Security.Policy.Evidence%2CSystem.AppDomainSetup%2CSystem.Security.PermissionSet%2CSystem.Security.Policy.StrongName%5B%5D%29?displayProperty=nameWithType> sobrecarga del método, a menos que los permisos que se conceden al dominio de aplicación son equivalentes a plena confianza.  
  
   
  
## Examples  
 En el ejemplo siguiente se muestra el <xref:System.AppDomain.IsFullyTrusted%2A> propiedad y el <xref:System.Reflection.Assembly.IsFullyTrusted%2A?displayProperty=nameWithType> propiedad con dominios de aplicación de plena confianza y confianza parcial. El dominio de aplicación de plena confianza es el dominio de aplicación predeterminado para la aplicación. Se crea el dominio de aplicación de confianza parcial mediante la <xref:System.AppDomain.CreateDomain%28System.String%2CSystem.Security.Policy.Evidence%2CSystem.AppDomainSetup%2CSystem.Security.PermissionSet%2CSystem.Security.Policy.StrongName%5B%5D%29?displayProperty=nameWithType> sobrecarga del método.  
  
 El ejemplo se usa un `Worker` clase que derive de <xref:System.MarshalByRefObject>, por lo que se pueden calcular las referencias entre los límites del dominio de aplicación. El ejemplo se crea un `Worker` objeto en el dominio de aplicación predeterminado. A continuación, llama el `TestIsFullyTrusted` método para mostrar el valor de propiedad del dominio de aplicación y de dos ensamblados que se cargan en el dominio de aplicación: mscorlib, que forma parte de .NET Framework y el ensamblado de ejemplo. El dominio de aplicación es de plena confianza, por lo que ambos ensamblados son de plena confianza.  
  
 En el ejemplo se crea otro `Worker` objeto en un dominio de aplicación en espacio aislado y llama de nuevo el `TestIsFullyTrusted` método. Mscorlib siempre es de confianza, incluso en un dominio de aplicación de confianza parcial, pero el ensamblado de ejemplo es de confianza parcial.  
  
 [!code-csharp[System.AppDomain.IsFullyTrusted#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.appdomain.isfullytrusted/cs/example.cs#1)]
 [!code-vb[System.AppDomain.IsFullyTrusted#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.appdomain.isfullytrusted/vb/example.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsHomogenous">
      <MemberSignature Language="C#" Value="public bool IsHomogenous { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsHomogenous" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.IsHomogenous" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsHomogenous As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsHomogenous { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsHomogenous : bool" Usage="System.AppDomain.IsHomogenous" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene un valor que indica si el dominio de aplicación actual tiene un conjunto de permisos concedido a todos los ensamblados que se cargan en el dominio de aplicación.</summary>
        <value>Es <see langword="true" /> si el dominio de aplicación actual tiene un conjunto homogéneo de permisos; de lo contrario, es <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esta propiedad devuelve `true` para dominios de aplicación en espacio aislado que se crearon con la <xref:System.AppDomain.CreateDomain%28System.String%2CSystem.Security.Policy.Evidence%2CSystem.AppDomainSetup%2CSystem.Security.PermissionSet%2CSystem.Security.Policy.StrongName%5B%5D%29?displayProperty=nameWithType> sobrecarga del método. Dominios de aplicación en espacio aislado tienen un conjunto homogéneo de permisos; es decir, el mismo conjunto de permisos se concede a todos los ensamblados de confianza parcial que se cargan en el dominio de aplicación. Un dominio de aplicación en espacio aislado, opcionalmente, tiene una lista de ensamblados con nombre seguro que están exentos de este conjunto de permisos y en su lugar se ejecute con plena confianza.  
  
 Plena confianza para el código puede utilizar el <xref:System.AppDomain.PermissionSet%2A> propiedad para determinar el conjunto de permisos homogéneo de un dominio de aplicación en espacio aislado.  
  
 Esta propiedad devuelve también `true` para el dominio de aplicación predeterminado de una aplicación de escritorio, porque ese dominio de aplicación concede plena confianza a todos los ensamblados.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.AppDomain.PermissionSet" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Load">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Carga un <see cref="T:System.Reflection.Assembly" /> en este dominio de aplicación.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public System.Reflection.Assembly Load (byte[] rawAssembly);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Assembly Load(unsigned int8[] rawAssembly) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.Load(System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Function Load (rawAssembly As Byte()) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Assembly ^ Load(cli::array &lt;System::Byte&gt; ^ rawAssembly);" />
      <MemberSignature Language="F#" Value="abstract member Load : byte[] -&gt; System.Reflection.Assembly&#xA;override this.Load : byte[] -&gt; System.Reflection.Assembly" Usage="appDomain.Load rawAssembly" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.Load(System.Byte[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rawAssembly" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="rawAssembly">Matriz de tipo <see langword="byte" /> que es una imagen basada en COFF que contiene un ensamblado emitido.</param>
        <summary>Carga el <see cref="T:System.Reflection.Assembly" /> con una imagen basada en el formato COFF (Common Object File Format) que contiene un <see cref="T:System.Reflection.Assembly" /> emitido.</summary>
        <returns>Ensamblado cargado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A partir del [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], el nivel de confianza de un ensamblado que se carga mediante el uso de este método es el mismo que el nivel de confianza del dominio de aplicación.  
  
 Este método debe usarse solo para cargar un ensamblado en el dominio de aplicación actual. Este método se proporciona como una comodidad para los llamadores de interoperabilidad que no se pueden llamar a estático <xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType> método. Para cargar ensamblados en otros dominios de aplicación, use un método como <xref:System.AppDomain.CreateInstanceAndUnwrap%2A>.  
  
 Para obtener información que es común a todas las sobrecargas de este método, consulte el <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29> sobrecarga del método.  
  
   
  
## Examples  
 El ejemplo siguiente muestra el uso de la carga de un ensamblado sin procesar.  
  
 Para que poder ejecutar este ejemplo de código, debe proporcionar el nombre completo del ensamblado. Para obtener información acerca de cómo obtener el nombre completo del ensamblado, vea [nombres de ensamblado](~/docs/framework/app-domains/assembly-names.md).  
  
 [!code-cpp[AppDomain_LoadRaw#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_LoadRaw/CPP/loadraw.cpp#1)]
 [!code-csharp[AppDomain_LoadRaw#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_LoadRaw/CS/loadraw.cs#1)]
 [!code-vb[AppDomain_LoadRaw#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_LoadRaw/VB/loadraw.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="rawAssembly" /> es <see langword="null" />.</exception>
        <exception cref="T:System.BadImageFormatException"><paramref name="rawAssembly" /> no es un ensamblado válido.  
  
O bien 
La versión 2.0 u otra posterior de Common Language Runtime está cargada actualmente y <paramref name="rawAssembly" /> se compiló con una versión posterior.</exception>
        <exception cref="T:System.AppDomainUnloadedException">La operación se intenta en un dominio de aplicación descargado.</exception>
        <exception cref="T:System.IO.FileLoadException">Se cargó un ensamblado o módulo dos veces con dos evidencias diferentes.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Para obtener acceso desde un archivo o directorio y para tener acceso a la información de la ruta de acceso de lectura. Enumeraciones asociadas: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public System.Reflection.Assembly Load (System.Reflection.AssemblyName assemblyRef);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Assembly Load(class System.Reflection.AssemblyName assemblyRef) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.Load(System.Reflection.AssemblyName)" />
      <MemberSignature Language="VB.NET" Value="Public Function Load (assemblyRef As AssemblyName) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Assembly ^ Load(System::Reflection::AssemblyName ^ assemblyRef);" />
      <MemberSignature Language="F#" Value="abstract member Load : System.Reflection.AssemblyName -&gt; System.Reflection.Assembly&#xA;override this.Load : System.Reflection.AssemblyName -&gt; System.Reflection.Assembly" Usage="appDomain.Load assemblyRef" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.Load(System.Reflection.AssemblyName)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyRef" Type="System.Reflection.AssemblyName" />
      </Parameters>
      <Docs>
        <param name="assemblyRef">Objeto que describe el ensamblado que se va a cargar.</param>
        <summary>Carga un <see cref="T:System.Reflection.Assembly" /> a partir de su <see cref="T:System.Reflection.AssemblyName" />.</summary>
        <returns>Ensamblado cargado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método debe usarse solo para cargar un ensamblado en el dominio de aplicación actual. Este método se proporciona como una comodidad para los llamadores de interoperabilidad que no se pueden llamar a estático <xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType> método. Para cargar ensamblados en otros dominios de aplicación, use un método como <xref:System.AppDomain.CreateInstanceAndUnwrap%2A>.  
  
 Si ya se ha cargado una versión del ensamblado solicitado, este método devuelve el ensamblado cargado, incluso si se solicita una versión diferente.  
  
 Proporcionar un nombre de ensamblado parciales para `assemblyRef` no se recomienda. (Un nombre parcial omite uno o varios de la referencia cultural, versión o token de clave pública. Para las sobrecargas que toman una cadena en lugar de un <xref:System.Reflection.AssemblyName> objeto, "MyAssembly, Version = 1.0.0.0" es un ejemplo de un nombre parcial y "MyAssembly, Version = 1.0.0.0, Culture = neutral, PublicKeyToken = 18ab3442da84b47" es un ejemplo de un nombre completo.) Uso de nombres parciales tiene un efecto negativo en el rendimiento. Además, un nombre de ensamblado parcial puede cargar un ensamblado de la caché global de ensamblados solo si hay una copia exacta del ensamblado en el directorio de base de la aplicación (<xref:System.AppDomain.BaseDirectory%2A> o <xref:System.AppDomainSetup.ApplicationBase%2A?displayProperty=nameWithType>).  
  
 Si el actual <xref:System.AppDomain> objeto representa el dominio de aplicación `A`y el <xref:System.AppDomain.Load%2A> se llama al método desde el dominio de aplicación `B`, el ensamblado se carga en ambos dominios de aplicación. Por ejemplo, el siguiente código carga `MyAssembly` en el nuevo dominio de aplicación `ChildDomain` y también en el dominio de aplicación donde se ejecuta el código:  
  
 [!code-cpp[System.AppDomain.Load#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.appdomain.load/cpp/source.cpp#1)]
 [!code-csharp[System.AppDomain.Load#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.appdomain.load/cs/source.cs#1)]
 [!code-vb[System.AppDomain.Load#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.appdomain.load/vb/source.vb#1)]  
  
 El ensamblado se carga en ambos dominios porque <xref:System.Reflection.Assembly> no se deriva de <xref:System.MarshalByRefObject>y por lo tanto, el valor devuelto de la <xref:System.AppDomain.Load%2A> método no se pueden serializar. En su lugar, common language runtime intenta cargar el ensamblado en el dominio de aplicación que realiza la llamada. Los ensamblados que se cargan en los dos dominios de aplicación pueden ser diferentes si los valores de ruta de acceso para los dos dominios de aplicación son diferentes.  
  
> [!NOTE]
>  Si tanto el <xref:System.Reflection.AssemblyName.Name%2A?displayProperty=nameWithType> propiedad y el <xref:System.Reflection.AssemblyName.CodeBase%2A?displayProperty=nameWithType> propiedad se establece, el primer intento de cargar el ensamblado utiliza el nombre para mostrar (incluida la versión, referencia cultural y así sucesivamente, tal como lo devuelve el <xref:System.Reflection.Assembly.FullName%2A?displayProperty=nameWithType> propiedad). Si no se encuentra el archivo, el <xref:System.Reflection.AssemblyName.CodeBase%2A> propiedad se utiliza para buscar el ensamblado. Si se encuentra el ensamblado mediante <xref:System.Reflection.AssemblyName.CodeBase%2A>, el nombre para mostrar se compara con el ensamblado. Si se produce un error en la coincidencia, un <xref:System.IO.FileLoadException> se produce.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="assemblyRef" /> es <see langword="null" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">No se ha encontrado <paramref name="assemblyRef" />.</exception>
        <exception cref="T:System.BadImageFormatException"><paramref name="assemblyRef" /> no es un ensamblado válido.  
  
O bien 
La versión 2.0 u otra posterior de Common Language Runtime está cargada actualmente y <paramref name="assemblyRef" /> se compiló con una versión posterior.</exception>
        <exception cref="T:System.AppDomainUnloadedException">La operación se intenta en un dominio de aplicación descargado.</exception>
        <exception cref="T:System.IO.FileLoadException">Se cargó un ensamblado o módulo dos veces con dos evidencias diferentes.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Para obtener acceso desde un archivo o directorio y para tener acceso a la información de la ruta de acceso de lectura. Enumeraciones asociadas: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public System.Reflection.Assembly Load (string assemblyString);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Assembly Load(string assemblyString) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.Load(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function Load (assemblyString As String) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Assembly ^ Load(System::String ^ assemblyString);" />
      <MemberSignature Language="F#" Value="abstract member Load : string -&gt; System.Reflection.Assembly&#xA;override this.Load : string -&gt; System.Reflection.Assembly" Usage="appDomain.Load assemblyString" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.Load(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyString" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="assemblyString">Nombre para mostrar del ensamblado. Vea <see cref="P:System.Reflection.Assembly.FullName" />.</param>
        <summary>Carga un <see cref="T:System.Reflection.Assembly" /> a partir de su nombre de presentación.</summary>
        <returns>Ensamblado cargado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método debe usarse solo para cargar un ensamblado en el dominio de aplicación actual. Este método se proporciona como una comodidad para los llamadores de interoperabilidad que no se pueden llamar a estático <xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType> método. Para cargar ensamblados en otros dominios de aplicación, use un método como <xref:System.AppDomain.CreateInstanceAndUnwrap%2A>.  
  
 Para obtener información que es común a todas las sobrecargas de este método, consulte el <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29> sobrecarga del método.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="assemblyString" /> es <see langword="null" /></exception>
        <exception cref="T:System.IO.FileNotFoundException">No se ha encontrado <paramref name="assemblyString" />.</exception>
        <exception cref="T:System.BadImageFormatException"><paramref name="assemblyString" /> no es un ensamblado válido.  
  
O bien 
La versión 2.0 u otra posterior de Common Language Runtime está cargada actualmente y <paramref name="assemblyString" /> se compiló con una versión posterior.</exception>
        <exception cref="T:System.AppDomainUnloadedException">La operación se intenta en un dominio de aplicación descargado.</exception>
        <exception cref="T:System.IO.FileLoadException">Se cargó un ensamblado o módulo dos veces con dos evidencias diferentes.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Para obtener acceso desde un archivo o directorio y para tener acceso a la información de la ruta de acceso de lectura. Enumeraciones asociadas: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</permission>
        <permission cref="T:System.Net.WebPermission">Para poder acceder a la ubicación del ensamblado si el ensamblado no es local.</permission>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public System.Reflection.Assembly Load (byte[] rawAssembly, byte[] rawSymbolStore);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Assembly Load(unsigned int8[] rawAssembly, unsigned int8[] rawSymbolStore) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.Load(System.Byte[],System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Function Load (rawAssembly As Byte(), rawSymbolStore As Byte()) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Assembly ^ Load(cli::array &lt;System::Byte&gt; ^ rawAssembly, cli::array &lt;System::Byte&gt; ^ rawSymbolStore);" />
      <MemberSignature Language="F#" Value="abstract member Load : byte[] * byte[] -&gt; System.Reflection.Assembly&#xA;override this.Load : byte[] * byte[] -&gt; System.Reflection.Assembly" Usage="appDomain.Load (rawAssembly, rawSymbolStore)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.Load(System.Byte[],System.Byte[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rawAssembly" Type="System.Byte[]" />
        <Parameter Name="rawSymbolStore" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="rawAssembly">Matriz de tipo <see langword="byte" /> que es una imagen basada en COFF que contiene un ensamblado emitido.</param>
        <param name="rawSymbolStore">Matriz de tipo <see langword="byte" /> que contiene los bytes sin formato que representan los símbolos del ensamblado.</param>
        <summary>Carga el <see cref="T:System.Reflection.Assembly" /> con una imagen basada en el formato COFF (Common Object File Format) que contiene un <see cref="T:System.Reflection.Assembly" /> emitido. También se cargan los bytes sin formato que representan los símbolos del <see cref="T:System.Reflection.Assembly" />.</summary>
        <returns>Ensamblado cargado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A partir del [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], el nivel de confianza de un ensamblado que se carga mediante el uso de este método es el mismo que el nivel de confianza del dominio de aplicación.  
  
 Este método debe usarse solo para cargar un ensamblado en el dominio de aplicación actual. Este método se proporciona como una comodidad para los llamadores de interoperabilidad que no se pueden llamar a estático <xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType> método. Para cargar ensamblados en otros dominios de aplicación, use un método como <xref:System.AppDomain.CreateInstanceAndUnwrap%2A>.  
  
 Para obtener información que es común a todas las sobrecargas de este método, consulte el <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29> sobrecarga del método.  
  
   
  
## Examples  
 El ejemplo siguiente muestra el uso de la carga de un ensamblado sin procesar.  
  
 Para que poder ejecutar este ejemplo de código, debe proporcionar el nombre completo del ensamblado. Para obtener información acerca de cómo obtener el nombre completo del ensamblado, vea [nombres de ensamblado](~/docs/framework/app-domains/assembly-names.md).  
  
 [!code-cpp[AppDomain_LoadRaw#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_LoadRaw/CPP/loadraw.cpp#1)]
 [!code-csharp[AppDomain_LoadRaw#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_LoadRaw/CS/loadraw.cs#1)]
 [!code-vb[AppDomain_LoadRaw#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_LoadRaw/VB/loadraw.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="rawAssembly" /> es <see langword="null" />.</exception>
        <exception cref="T:System.BadImageFormatException"><paramref name="rawAssembly" /> no es un ensamblado válido.  
  
O bien 
La versión 2.0 u otra posterior de Common Language Runtime está cargada actualmente y <paramref name="rawAssembly" /> se compiló con una versión posterior.</exception>
        <exception cref="T:System.AppDomainUnloadedException">La operación se intenta en un dominio de aplicación descargado.</exception>
        <exception cref="T:System.IO.FileLoadException">Se cargó un ensamblado o módulo dos veces con dos evidencias diferentes.</exception>
        <permission cref="T:System.Net.WebPermission">para leer un URI que no comienzan con "file://".</permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Para obtener acceso desde un archivo o directorio y para tener acceso a la información de la ruta de acceso de lectura. Enumeraciones asociadas: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public System.Reflection.Assembly Load (System.Reflection.AssemblyName assemblyRef, System.Security.Policy.Evidence assemblySecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Assembly Load(class System.Reflection.AssemblyName assemblyRef, class System.Security.Policy.Evidence assemblySecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.Load(System.Reflection.AssemblyName,System.Security.Policy.Evidence)" />
      <MemberSignature Language="VB.NET" Value="Public Function Load (assemblyRef As AssemblyName, assemblySecurity As Evidence) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Assembly ^ Load(System::Reflection::AssemblyName ^ assemblyRef, System::Security::Policy::Evidence ^ assemblySecurity);" />
      <MemberSignature Language="F#" Value="abstract member Load : System.Reflection.AssemblyName * System.Security.Policy.Evidence -&gt; System.Reflection.Assembly&#xA;override this.Load : System.Reflection.AssemblyName * System.Security.Policy.Evidence -&gt; System.Reflection.Assembly" Usage="appDomain.Load (assemblyRef, assemblySecurity)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.Load(System.Reflection.AssemblyName,System.Security.Policy.Evidence)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use an overload that does not take an Evidence parameter")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("Methods which use evidence to sandbox are obsolete and will be removed in a future release of the .NET Framework. Please use an overload of Load which does not take an Evidence parameter. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyRef" Type="System.Reflection.AssemblyName" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="assemblySecurity" Type="System.Security.Policy.Evidence" Index="1" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="assemblyRef">Objeto que describe el ensamblado que se va a cargar.</param>
        <param name="assemblySecurity">Evidencia para cargar el ensamblado.</param>
        <summary>Carga un <see cref="T:System.Reflection.Assembly" /> a partir de su <see cref="T:System.Reflection.AssemblyName" />.</summary>
        <returns>Ensamblado cargado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método debe usarse solo para cargar un ensamblado en el dominio de aplicación actual. Este método se proporciona como una comodidad para los llamadores de interoperabilidad que no se pueden llamar a estático <xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType> método. Para cargar ensamblados en otros dominios de aplicación, use un método como <xref:System.AppDomain.CreateInstanceAndUnwrap%2A>.  
  
 Para obtener información que es común a todas las sobrecargas de este método, consulte el <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29> sobrecarga del método.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="assemblyRef" /> es <see langword="null" /></exception>
        <exception cref="T:System.IO.FileNotFoundException">No se ha encontrado <paramref name="assemblyRef" />.</exception>
        <exception cref="T:System.BadImageFormatException"><paramref name="assemblyRef" /> no es un ensamblado válido.  
  
O bien 
La versión 2.0 u otra posterior de Common Language Runtime está cargada actualmente y <paramref name="assemblyRef" /> se compiló con una versión posterior.</exception>
        <exception cref="T:System.AppDomainUnloadedException">La operación se intenta en un dominio de aplicación descargado.</exception>
        <exception cref="T:System.IO.FileLoadException">Se cargó un ensamblado o módulo dos veces con dos evidencias diferentes.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Para obtener acceso desde un archivo o directorio y para tener acceso a la información de la ruta de acceso de lectura. Enumeraciones asociadas: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">para cargar un ensamblado con la evidencia. Enumeración asociada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</permission>
        <permission cref="T:System.Net.WebPermission">para leer una ruta de acceso que no está en el formulario "file://" o "\\\UNC\dir\\" o "c:\\".</permission>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public System.Reflection.Assembly Load (string assemblyString, System.Security.Policy.Evidence assemblySecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Assembly Load(string assemblyString, class System.Security.Policy.Evidence assemblySecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.Load(System.String,System.Security.Policy.Evidence)" />
      <MemberSignature Language="VB.NET" Value="Public Function Load (assemblyString As String, assemblySecurity As Evidence) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Assembly ^ Load(System::String ^ assemblyString, System::Security::Policy::Evidence ^ assemblySecurity);" />
      <MemberSignature Language="F#" Value="abstract member Load : string * System.Security.Policy.Evidence -&gt; System.Reflection.Assembly&#xA;override this.Load : string * System.Security.Policy.Evidence -&gt; System.Reflection.Assembly" Usage="appDomain.Load (assemblyString, assemblySecurity)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.Load(System.String,System.Security.Policy.Evidence)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use an overload that does not take an Evidence parameter")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("Methods which use evidence to sandbox are obsolete and will be removed in a future release of the .NET Framework. Please use an overload of Load which does not take an Evidence parameter. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyString" Type="System.String" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="assemblySecurity" Type="System.Security.Policy.Evidence" Index="1" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="assemblyString">Nombre para mostrar del ensamblado. Vea <see cref="P:System.Reflection.Assembly.FullName" />.</param>
        <param name="assemblySecurity">Evidencia para cargar el ensamblado.</param>
        <summary>Carga un <see cref="T:System.Reflection.Assembly" /> a partir de su nombre de presentación.</summary>
        <returns>Ensamblado cargado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método debe usarse solo para cargar un ensamblado en el dominio de aplicación actual. Este método se proporciona como una comodidad para los llamadores de interoperabilidad que no se pueden llamar a estático <xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType> método. Para cargar ensamblados en otros dominios de aplicación, use un método como <xref:System.AppDomain.CreateInstanceAndUnwrap%2A>.  
  
 Para obtener información que es común a todas las sobrecargas de este método, consulte el <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29> sobrecarga del método.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="assemblyString" /> es <see langword="null" /></exception>
        <exception cref="T:System.IO.FileNotFoundException">No se ha encontrado <paramref name="assemblyString" />.</exception>
        <exception cref="T:System.BadImageFormatException"><paramref name="assemblyString" /> no es un ensamblado válido.  
  
O bien 
La versión 2.0 u otra posterior de Common Language Runtime está cargada actualmente y <paramref name="assemblyString" /> se compiló con una versión posterior.</exception>
        <exception cref="T:System.AppDomainUnloadedException">La operación se intenta en un dominio de aplicación descargado.</exception>
        <exception cref="T:System.IO.FileLoadException">Se cargó un ensamblado o módulo dos veces con dos evidencias diferentes.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">para cargar un ensamblado con la evidencia. Enumeración asociada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Para obtener acceso desde un archivo o directorio y para tener acceso a la información de la ruta de acceso de lectura. Enumeraciones asociadas: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</permission>
        <permission cref="T:System.Net.WebPermission">para leer una ruta de acceso que no está en el formulario "file://" o "\\\UNC\dir\\" o "c:\\".</permission>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public System.Reflection.Assembly Load (byte[] rawAssembly, byte[] rawSymbolStore, System.Security.Policy.Evidence securityEvidence);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Assembly Load(unsigned int8[] rawAssembly, unsigned int8[] rawSymbolStore, class System.Security.Policy.Evidence securityEvidence) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.Load(System.Byte[],System.Byte[],System.Security.Policy.Evidence)" />
      <MemberSignature Language="VB.NET" Value="Public Function Load (rawAssembly As Byte(), rawSymbolStore As Byte(), securityEvidence As Evidence) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Assembly ^ Load(cli::array &lt;System::Byte&gt; ^ rawAssembly, cli::array &lt;System::Byte&gt; ^ rawSymbolStore, System::Security::Policy::Evidence ^ securityEvidence);" />
      <MemberSignature Language="F#" Value="abstract member Load : byte[] * byte[] * System.Security.Policy.Evidence -&gt; System.Reflection.Assembly&#xA;override this.Load : byte[] * byte[] * System.Security.Policy.Evidence -&gt; System.Reflection.Assembly" Usage="appDomain.Load (rawAssembly, rawSymbolStore, securityEvidence)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.Load(System.Byte[],System.Byte[],System.Security.Policy.Evidence)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use an overload that does not take an Evidence parameter")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("Methods which use evidence to sandbox are obsolete and will be removed in a future release of the .NET Framework. Please use an overload of Load which does not take an Evidence parameter. See http://go.microsoft.com/fwlink/?LinkId=155570 for more information.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rawAssembly" Type="System.Byte[]" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="rawSymbolStore" Type="System.Byte[]" Index="1" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="securityEvidence" Type="System.Security.Policy.Evidence" Index="2" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="rawAssembly">Matriz de tipo <see langword="byte" /> que es una imagen basada en COFF que contiene un ensamblado emitido.</param>
        <param name="rawSymbolStore">Matriz de tipo <see langword="byte" /> que contiene los bytes sin formato que representan los símbolos del ensamblado.</param>
        <param name="securityEvidence">Evidencia para cargar el ensamblado.</param>
        <summary>Carga el <see cref="T:System.Reflection.Assembly" /> con una imagen basada en el formato COFF (Common Object File Format) que contiene un <see cref="T:System.Reflection.Assembly" /> emitido. También se cargan los bytes sin formato que representan los símbolos del <see cref="T:System.Reflection.Assembly" />.</summary>
        <returns>Ensamblado cargado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A partir del [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], el nivel de confianza de un ensamblado que se carga mediante el uso de este método es el mismo que el nivel de confianza del dominio de aplicación.  
  
 Este método debe usarse solo para cargar un ensamblado en el dominio de aplicación actual. Este método se proporciona como una comodidad para los llamadores de interoperabilidad que no se pueden llamar a estático <xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType> método. Para cargar ensamblados en otros dominios de aplicación, use un método como <xref:System.AppDomain.CreateInstanceAndUnwrap%2A>.  
  
 Para obtener información que es común a todas las sobrecargas de este método, consulte el <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29> sobrecarga del método.  
  
   
  
## Examples  
 El ejemplo siguiente muestra el uso de la carga de un ensamblado sin procesar.  
  
 Para que poder ejecutar este ejemplo de código, debe proporcionar el nombre completo del ensamblado. Para obtener información acerca de cómo obtener el nombre completo del ensamblado, vea [nombres de ensamblado](~/docs/framework/app-domains/assembly-names.md).  
  
 [!code-cpp[AppDomain_LoadRaw#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_LoadRaw/CPP/loadraw.cpp#1)]
 [!code-csharp[AppDomain_LoadRaw#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_LoadRaw/CS/loadraw.cs#1)]
 [!code-vb[AppDomain_LoadRaw#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_LoadRaw/VB/loadraw.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="rawAssembly" /> es <see langword="null" />.</exception>
        <exception cref="T:System.BadImageFormatException"><paramref name="rawAssembly" /> no es un ensamblado válido.  
  
O bien 
La versión 2.0 u otra posterior de Common Language Runtime está cargada actualmente y <paramref name="rawAssembly" /> se compiló con una versión posterior.</exception>
        <exception cref="T:System.AppDomainUnloadedException">La operación se intenta en un dominio de aplicación descargado.</exception>
        <exception cref="T:System.IO.FileLoadException">Se cargó un ensamblado o módulo dos veces con dos evidencias diferentes.</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="securityEvidence" /> no es <see langword="null" />. Cuando no se habilita la directiva CAS heredada, <paramref name="securityEvidence" /> debe ser <see langword="null" />.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">para proporcionar evidencia. Enumeración asociada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />. Acción de seguridad: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />.</permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Para obtener acceso desde un archivo o directorio y para tener acceso a la información de la ruta de acceso de lectura. Enumeraciones asociadas: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</permission>
        <permission cref="T:System.Net.WebPermission">para leer una ruta de acceso que no está en el formulario "file://" o "\\\UNC\dir\\" o "c:\\".</permission>
      </Docs>
    </Member>
    <Member MemberName="MonitoringIsEnabled">
      <MemberSignature Language="C#" Value="public static bool MonitoringIsEnabled { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property bool MonitoringIsEnabled" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.MonitoringIsEnabled" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property MonitoringIsEnabled As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool MonitoringIsEnabled { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.MonitoringIsEnabled : bool with get, set" Usage="System.AppDomain.MonitoringIsEnabled" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>set: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece un valor que indica si la supervisión de la CPU y de la memoria del dominio de aplicación está habilitada para el proceso actual. Una vez que se habilita la supervisión para un proceso, no se puede deshabilitar.</summary>
        <value>Es <see langword="true" /> si la supervisión está habilitada; de lo contrario, es <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esto `static` propiedad (`Shared` propiedad en Visual Basic) controla la CPU y memoria de supervisión de todos los dominios de aplicación en el proceso.  
  
 Si se intenta establecer esta propiedad en `false`, un <xref:System.ArgumentException> se produce la excepción, incluso si el valor actual de la propiedad es `false`.  
  
 Una vez habilitada la supervisión, puede usar el <xref:System.AppDomain.MonitoringSurvivedMemorySize%2A>, <xref:System.AppDomain.MonitoringSurvivedProcessMemorySize%2A>, <xref:System.AppDomain.MonitoringTotalAllocatedMemorySize%2A>, y <xref:System.AppDomain.MonitoringTotalProcessorTime%2A> propiedades para supervisar el uso de CPU y memoria de dominios de aplicación individuales de la instancia.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">El proceso actual ha intentado asignar el valor <see langword="false" /> a esta propiedad.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requiere plena confianza para el llamador inmediato. Este miembro no se puede usar código de confianza parcial o transparente.</permission>
        <related type="Article" href="https://msdn.microsoft.com/library/318bedf8-7f35-4f00-b34a-2b7b8e3fa315">Supervisión de recursos de dominio de aplicación</related>
        <related type="Article" href="https://msdn.microsoft.com/library/02119ab6-1e91-448e-97ad-e7b2e5c4bbbd">&lt;appdomainResourceMonitoring&gt; elemento</related>
      </Docs>
    </Member>
    <Member MemberName="MonitoringSurvivedMemorySize">
      <MemberSignature Language="C#" Value="public long MonitoringSurvivedMemorySize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 MonitoringSurvivedMemorySize" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.MonitoringSurvivedMemorySize" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property MonitoringSurvivedMemorySize As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long MonitoringSurvivedMemorySize { long get(); };" />
      <MemberSignature Language="F#" Value="member this.MonitoringSurvivedMemorySize : int64" Usage="System.AppDomain.MonitoringSurvivedMemorySize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene el número de bytes que sobrevivieron a la última recolección y a la que se sabe que hace referencia el dominio de aplicación actual.</summary>
        <value>Número de bytes supervivientes.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Las estadísticas se actualizan con cada recolección de elementos. Sin embargo, se garantiza que sea precisa solo después de una recolección completa de bloqueo; es decir, se produce una colección que incluye todas las generaciones y que detiene la aplicación mientras la colección. Por ejemplo, el <xref:System.GC.Collect?displayProperty=nameWithType> sobrecarga del método realiza una recolección completa de bloqueo. (Colección simultánea se produce en segundo plano y no bloquea la aplicación).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">La propiedad <see langword="static" /> (<see langword="Shared" /> en Visual Basic) <see cref="P:System.AppDomain.MonitoringIsEnabled" /> propiedad está establecida en <see langword="false" />.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requiere plena confianza para el llamador inmediato. Este miembro no se puede usar código de confianza parcial o transparente.</permission>
        <related type="Article" href="https://msdn.microsoft.com/library/318bedf8-7f35-4f00-b34a-2b7b8e3fa315">Supervisión de recursos de dominio de aplicación</related>
      </Docs>
    </Member>
    <Member MemberName="MonitoringSurvivedProcessMemorySize">
      <MemberSignature Language="C#" Value="public static long MonitoringSurvivedProcessMemorySize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property int64 MonitoringSurvivedProcessMemorySize" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.MonitoringSurvivedProcessMemorySize" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property MonitoringSurvivedProcessMemorySize As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property long MonitoringSurvivedProcessMemorySize { long get(); };" />
      <MemberSignature Language="F#" Value="member this.MonitoringSurvivedProcessMemorySize : int64" Usage="System.AppDomain.MonitoringSurvivedProcessMemorySize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene los bytes totales que sobrevivieron a la última recolección para todos los dominios de aplicación del proceso.</summary>
        <value>Número total de bytes supervivientes para el proceso.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Después de una recolección completa, bloquea, este número representa el número de bytes actualmente mantienen activos en administra montones. Debe ser casi el número notificado por el <xref:System.GC.GetTotalMemory%2A> método. Después de una recolección efímera, este número representa el número de bytes actualmente mantiene activo en generaciones efímeras.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">La propiedad <see langword="static" /> (<see langword="Shared" /> en Visual Basic) <see cref="P:System.AppDomain.MonitoringIsEnabled" /> propiedad está establecida en <see langword="false" />.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requiere plena confianza para el llamador inmediato. Este miembro no se puede usar código de confianza parcial o transparente.</permission>
        <related type="Article" href="https://msdn.microsoft.com/library/318bedf8-7f35-4f00-b34a-2b7b8e3fa315">Supervisión de recursos de dominio de aplicación</related>
      </Docs>
    </Member>
    <Member MemberName="MonitoringTotalAllocatedMemorySize">
      <MemberSignature Language="C#" Value="public long MonitoringTotalAllocatedMemorySize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 MonitoringTotalAllocatedMemorySize" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.MonitoringTotalAllocatedMemorySize" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property MonitoringTotalAllocatedMemorySize As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long MonitoringTotalAllocatedMemorySize { long get(); };" />
      <MemberSignature Language="F#" Value="member this.MonitoringTotalAllocatedMemorySize : int64" Usage="System.AppDomain.MonitoringTotalAllocatedMemorySize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene el tamaño total, en bytes, de todas las asignaciones de memoria realizadas por el dominio de aplicación desde que se creó, sin restar la memoria recopilada.</summary>
        <value>Tamaño total de todas las asignaciones de memoria.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException">La propiedad <see langword="static" /> (<see langword="Shared" /> en Visual Basic) <see cref="P:System.AppDomain.MonitoringIsEnabled" /> propiedad está establecida en <see langword="false" />.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requiere plena confianza para el llamador inmediato. Este miembro no se puede usar código de confianza parcial o transparente.</permission>
        <related type="Article" href="https://msdn.microsoft.com/library/318bedf8-7f35-4f00-b34a-2b7b8e3fa315">Supervisión de recursos de dominio de aplicación</related>
      </Docs>
    </Member>
    <Member MemberName="MonitoringTotalProcessorTime">
      <MemberSignature Language="C#" Value="public TimeSpan MonitoringTotalProcessorTime { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.TimeSpan MonitoringTotalProcessorTime" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.MonitoringTotalProcessorTime" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property MonitoringTotalProcessorTime As TimeSpan" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property TimeSpan MonitoringTotalProcessorTime { TimeSpan get(); };" />
      <MemberSignature Language="F#" Value="member this.MonitoringTotalProcessorTime : TimeSpan" Usage="System.AppDomain.MonitoringTotalProcessorTime" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene el tiempo total de procesador usado por todos los subprocesos mientras se ejecutaban en el dominio de aplicación actual, desde que el proceso se inició.</summary>
        <value>Tiempo total de procesador para el dominio de aplicación actual.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El tiempo total que se notifica para un dominio de aplicación incluye el tiempo dedicado a cada subproceso en el proceso de ejecutar en ese dominio de aplicación.  
  
 Un subproceso que llama a código no administrado aún está asociado a un dominio de aplicación y el tiempo de procesador dedicado a ejecutar que el código no administrado se notifica para el dominio de aplicación donde se realizó la llamada.  
  
 Cuando un subproceso está bloqueado o en modo de suspensión, no consume tiempo de procesador.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">La propiedad <see langword="static" /> (<see langword="Shared" /> en Visual Basic) <see cref="P:System.AppDomain.MonitoringIsEnabled" /> propiedad está establecida en <see langword="false" />.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requiere plena confianza para el llamador inmediato. Este miembro no se puede usar código de confianza parcial o transparente.</permission>
        <related type="Article" href="https://msdn.microsoft.com/library/318bedf8-7f35-4f00-b34a-2b7b8e3fa315">Supervisión de recursos de dominio de aplicación</related>
      </Docs>
    </Member>
    <Member MemberName="PermissionSet">
      <MemberSignature Language="C#" Value="public System.Security.PermissionSet PermissionSet { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Security.PermissionSet PermissionSet" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.PermissionSet" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PermissionSet As PermissionSet" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Security::PermissionSet ^ PermissionSet { System::Security::PermissionSet ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.PermissionSet : System.Security.PermissionSet" Usage="System.AppDomain.PermissionSet" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Security.PermissionSet</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene el conjunto de permisos de un dominio de aplicación en un espacio aislado.</summary>
        <value>Conjunto de permisos del dominio de aplicación en un espacio aislado.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dominios de aplicación en espacio aislado que se crearon con la <xref:System.AppDomain.CreateDomain%28System.String%2CSystem.Security.Policy.Evidence%2CSystem.AppDomainSetup%2CSystem.Security.PermissionSet%2CSystem.Security.Policy.StrongName%5B%5D%29?displayProperty=nameWithType> sobrecarga del método tienen un conjunto homogéneo de permisos; es decir, el mismo conjunto de permisos se concede a todos los ensamblados de confianza parcial que se cargan en el dominio de aplicación. Un dominio de aplicación en espacio aislado, opcionalmente, tiene una lista de ensamblados con nombre seguro que están exentos de este conjunto de permisos y en su lugar se ejecute con plena confianza.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requiere plena confianza para el llamador inmediato. Este miembro no se puede usar código de confianza parcial o transparente.</permission>
        <altmember cref="P:System.AppDomain.IsHomogenous" />
      </Docs>
    </Member>
    <Member MemberName="ProcessExit">
      <MemberSignature Language="C#" Value="public event EventHandler ProcessExit;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler ProcessExit" />
      <MemberSignature Language="DocId" Value="E:System.AppDomain.ProcessExit" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ProcessExit As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event EventHandler ^ ProcessExit;" />
      <MemberSignature Language="F#" Value="member this.ProcessExit : EventHandler " Usage="member this.ProcessExit : System.EventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System._AppDomain.ProcessExit</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>add: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>remove: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produce al salir del proceso primario del dominio de aplicación predeterminado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.EventHandler> de este evento puede realizar actividades de terminación, como cerrar archivos, liberar almacenamiento, y así sucesivamente, antes de que finalice el proceso.  
  
 A partir de la versión 2.0 de .NET Framework, este evento se produce en cada dominio de aplicación que registra un controlador de eventos.  
  
> [!NOTE]
>  En .NET Framework, el tiempo de ejecución total de todos los <xref:System.AppDomain.ProcessExit> controladores de eventos es limitada, tal como el tiempo de ejecución total de todos los finalizadores se limita al proceso de cierre. El valor predeterminado es de dos segundos. Un host no administrado puede cambiar este tiempo de ejecución mediante una llamada a la [ICLRPolicyManager:: SetTimeout](~/docs/framework/unmanaged-api/hosting/iclrpolicymanager-settimeout-method.md) método con el [OPR_ProcessExit](~/docs/framework/unmanaged-api/hosting/eclroperation-enumeration.md) valor de enumeración. No existe este límite de tiempo en .NET Core.  
  
 En las versiones 1.0 y 1.1 de .NET Framework, este evento es sólo se desencadena en el dominio de aplicación predeterminado y solo si un controlador de eventos está registrado en el dominio de aplicación predeterminado.  
  
 Para registrar un controlador de eventos para este evento, debe tener los permisos necesarios, o un <xref:System.Security.SecurityException> se produce.  
  
 Para obtener más información sobre el manejo de eventos, consulte [controlar y provocar eventos](~/docs/standard/events/index.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReflectionOnlyAssemblyResolve">
      <MemberSignature Language="C#" Value="public event ResolveEventHandler ReflectionOnlyAssemblyResolve;" />
      <MemberSignature Language="ILAsm" Value=".event class System.ResolveEventHandler ReflectionOnlyAssemblyResolve" />
      <MemberSignature Language="DocId" Value="E:System.AppDomain.ReflectionOnlyAssemblyResolve" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ReflectionOnlyAssemblyResolve As ResolveEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event ResolveEventHandler ^ ReflectionOnlyAssemblyResolve;" />
      <MemberSignature Language="F#" Value="member this.ReflectionOnlyAssemblyResolve : ResolveEventHandler " Usage="member this.ReflectionOnlyAssemblyResolve : System.ResolveEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>add: System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>remove: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ResolveEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Aparece cuando se produce un error en la resolución de un ensamblado en el contexto de solo reflexión.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 En el contexto de solo reflexión, no se resuelven automáticamente las dependencias. Debe cargar previamente o devuelto por el controlador para este evento. Este evento se desencadena cuando un ensamblado tiene una dependencia que ya no está cargada en el contexto de solo reflexión. La falta de dependencia especificado por el <xref:System.ResolveEventArgs.Name%2A?displayProperty=nameWithType> propiedad. El <xref:System.ResolveEventHandler> para este evento debe devolver un ensamblado que cumpla la dependencia. El ensamblado que se devuelve se debe cargar en el contexto de solo reflexión.  
  
> [!IMPORTANT]
>  Este evento se genera solo para las dependencias que faltan del ensamblado que se va a cargar en el contexto de solo reflexión (por ejemplo, mediante el <xref:System.Reflection.Assembly.ReflectionOnlyLoad%2A?displayProperty=nameWithType> método). No se genera si no se encuentra el ensamblado que va a cargar.  
  
 A partir del [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], el <xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=nameWithType> propiedad devuelve el ensamblado que solicitó la carga del ensamblado que no se pudo resolver. Conocer la identidad del ensamblado que realiza solicitud podría ser útil para identificar la versión correcta de la dependencia, si más de una versión está disponible. Para obtener más información, vea <xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=nameWithType>.  
  
 Para este evento, el <xref:System.ResolveEventArgs.Name%2A?displayProperty=nameWithType> propiedad devuelve el nombre del ensamblado antes de que se aplica la directiva.  
  
 Para obtener más información sobre el manejo de eventos, consulte [controlar y provocar eventos](~/docs/standard/events/index.md).  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requiere plena confianza para el llamador inmediato. Este miembro no se puede usar código de confianza parcial o transparente.</permission>
        <altmember cref="P:System.ResolveEventArgs.RequestingAssembly" />
      </Docs>
    </Member>
    <Member MemberName="ReflectionOnlyGetAssemblies">
      <MemberSignature Language="C#" Value="public System.Reflection.Assembly[] ReflectionOnlyGetAssemblies ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Assembly[] ReflectionOnlyGetAssemblies() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.ReflectionOnlyGetAssemblies" />
      <MemberSignature Language="VB.NET" Value="Public Function ReflectionOnlyGetAssemblies () As Assembly()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::Reflection::Assembly ^&gt; ^ ReflectionOnlyGetAssemblies();" />
      <MemberSignature Language="F#" Value="member this.ReflectionOnlyGetAssemblies : unit -&gt; System.Reflection.Assembly[]" Usage="appDomain.ReflectionOnlyGetAssemblies " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Devuelve los ensamblados que se han cargado en el contexto de solo reflexión del dominio de aplicación.</summary>
        <returns>Matriz de objetos <see cref="T:System.Reflection.Assembly" /> que representan los ensamblados cargados en el contexto de solo reflexión del dominio de aplicación.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método devuelve los ensamblados que se han cargado en el contexto de solo reflexión. Para obtener los ensamblados que se han cargado para la ejecución, use el <xref:System.AppDomain.GetAssemblies%2A> método.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se carga el ensamblado System.dll en el contexto de ejecución y, a continuación, en el contexto de solo reflexión. El <xref:System.AppDomain.GetAssemblies%2A> y <xref:System.AppDomain.ReflectionOnlyGetAssemblies%2A> métodos se usan para mostrar los ensamblados cargados en cada contexto.  
  
 [!code-cpp[AppDomain.ReflectionOnlyGetAssemblies#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain.ReflectionOnlyGetAssemblies/CPP/reflectiononly.cpp#1)]
 [!code-csharp[AppDomain.ReflectionOnlyGetAssemblies#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain.ReflectionOnlyGetAssemblies/CS/reflectiononly.cs#1)]
 [!code-vb[AppDomain.ReflectionOnlyGetAssemblies#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain.ReflectionOnlyGetAssemblies/VB/reflectiononly.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException">Se ha intentado realizar una operación en un dominio de aplicación descargado.</exception>
        <altmember cref="M:System.AppDomain.GetAssemblies" />
      </Docs>
    </Member>
    <Member MemberName="RelativeSearchPath">
      <MemberSignature Language="C#" Value="public string RelativeSearchPath { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string RelativeSearchPath" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.RelativeSearchPath" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property RelativeSearchPath As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ RelativeSearchPath { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.RelativeSearchPath : string" Usage="System.AppDomain.RelativeSearchPath" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System._AppDomain.RelativeSearchPath</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene la ruta de acceso del directorio base en que la resolución de ensamblado debe buscar ensamblados privados.</summary>
        <value>La ruta de acceso del directorio base en que la resolución de ensamblado debe buscar ensamblados privados.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Los ensamblados privados se implementan en la misma estructura de directorio que la aplicación. Si la ruta de acceso especificada por el <xref:System.AppDomain.RelativeSearchPath%2A> propiedad no está bajo <xref:System.AppDomainSetup.ApplicationBase%2A?displayProperty=nameWithType>, se omite.  
  
 Esta propiedad devuelve el valor establecido mediante <xref:System.AppDomainSetup.PrivateBinPath%2A?displayProperty=nameWithType>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException">La operación se intenta en un dominio de aplicación descargado.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Para obtener acceso a la información de ruta de acceso. Enumeración asociada: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</permission>
        <altmember cref="P:System.AppDomainSetup.PrivateBinPath" />
      </Docs>
    </Member>
    <Member MemberName="ResourceResolve">
      <MemberSignature Language="C#" Value="public event ResolveEventHandler ResourceResolve;" />
      <MemberSignature Language="ILAsm" Value=".event class System.ResolveEventHandler ResourceResolve" />
      <MemberSignature Language="DocId" Value="E:System.AppDomain.ResourceResolve" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ResourceResolve As ResolveEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event ResolveEventHandler ^ ResourceResolve;" />
      <MemberSignature Language="F#" Value="member this.ResourceResolve : ResolveEventHandler " Usage="member this.ResourceResolve : System.ResolveEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System._AppDomain.ResourceResolve</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>add: System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>remove: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ResolveEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Aparece cuando se produce un error en la resolución de un recurso porque éste no es un recurso vinculado válido o incrustado en el ensamblado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.ResolveEventHandler> de este evento puede intentar localizar el ensamblado que contiene el recurso y devolverlo.  
  
> [!IMPORTANT]
>  Este evento no se produce si se produce un error en la resolución porque no se encuentra ningún archivo para un recurso vinculado válido. Se produce si no se encuentra una secuencia de recurso del manifiesto, pero no se genera si no se encuentra una clave de recurso individual.  
  
 A partir del [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], el <xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=nameWithType> propiedad contiene el ensamblado que el recurso solicitado. Para obtener más información, vea <xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=nameWithType>.  
  
 Para registrar un controlador de eventos para este evento, debe tener los permisos necesarios, o un <xref:System.Security.SecurityException> se produce.  
  
 Para obtener más información sobre el manejo de eventos, consulte [controlar y provocar eventos](~/docs/standard/events/index.md).  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requiere plena confianza para el llamador inmediato. Este miembro no se puede usar código de confianza parcial o transparente.</permission>
        <altmember cref="P:System.ResolveEventArgs.RequestingAssembly" />
      </Docs>
    </Member>
    <Member MemberName="SetAppDomainPolicy">
      <MemberSignature Language="C#" Value="public void SetAppDomainPolicy (System.Security.Policy.PolicyLevel domainPolicy);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetAppDomainPolicy(class System.Security.Policy.PolicyLevel domainPolicy) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.SetAppDomainPolicy(System.Security.Policy.PolicyLevel)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetAppDomainPolicy (domainPolicy As PolicyLevel)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetAppDomainPolicy(System::Security::Policy::PolicyLevel ^ domainPolicy);" />
      <MemberSignature Language="F#" Value="member this.SetAppDomainPolicy : System.Security.Policy.PolicyLevel -&gt; unit" Usage="appDomain.SetAppDomainPolicy domainPolicy" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("AppDomain policy levels are obsolete")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("AppDomain policy levels are obsolete and will be removed in a future release of the .NET Framework. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="domainPolicy" Type="System.Security.Policy.PolicyLevel" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="domainPolicy">Nivel de directiva de seguridad.</param>
        <summary>Establece el nivel de directiva de seguridad para este dominio de aplicación.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Llame a este método antes de que un ensamblado se carga en el <xref:System.AppDomain> en orden para la directiva de seguridad que tienen efecto.  
  
   
  
## Examples  
 En el ejemplo siguiente se muestra cómo usar el <xref:System.AppDomain.SetAppDomainPolicy%2A> método para establecer el nivel de directiva de seguridad de un dominio de aplicación.  
  
 [!code-cpp[ADSetAppDomainPolicy#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADSetAppDomainPolicy/CPP/adsetappdomainpolicy.cpp#1)]
 [!code-csharp[ADSetAppDomainPolicy#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADSetAppDomainPolicy/CS/adsetappdomainpolicy.cs#1)]
 [!code-vb[ADSetAppDomainPolicy#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADSetAppDomainPolicy/VB/adsetappdomainpolicy.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="domainPolicy" /> es <see langword="null" />.</exception>
        <exception cref="T:System.Security.Policy.PolicyException">Ya se ha establecido el nivel de directiva de seguridad.</exception>
        <exception cref="T:System.AppDomainUnloadedException">La operación se intenta en un dominio de aplicación descargado.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requiere plena confianza para el llamador inmediato. Este miembro no se puede usar código de confianza parcial o transparente.</permission>
      </Docs>
    </Member>
    <Member MemberName="SetCachePath">
      <MemberSignature Language="C#" Value="public void SetCachePath (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void SetCachePath(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.SetCachePath(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetCachePath (path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void SetCachePath(System::String ^ path);" />
      <MemberSignature Language="F#" Value="abstract member SetCachePath : string -&gt; unit&#xA;override this.SetCachePath : string -&gt; unit" Usage="appDomain.SetCachePath path" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.SetCachePath(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use AppDomainSetup.SetCachePath")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.Obsolete("AppDomain.SetCachePath has been deprecated. Please investigate the use of AppDomainSetup.CachePath instead. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-3.0">
          <AttributeName>System.Obsolete("AppDomain.SetCachePath has been deprecated. Please investigate the use of AppDomainSetup.CachePath instead. https://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Ruta de acceso completa a la ubicación de la instantánea.</param>
        <summary>Establece la ruta de acceso al directorio especificado como la ubicación donde se almacenan las instantáneas de los ensamblados.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La ruta de acceso de la memoria caché se omite si el <xref:System.AppDomainSetup.ApplicationName%2A> no se establece la propiedad. Vea la propiedad <xref:System.AppDomainSetup.CachePath%2A?displayProperty=nameWithType>.  
  
 Para obtener más información sobre la copia sombra vea [copias sombra de ensamblados](~/docs/framework/app-domains/shadow-copy-assemblies.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException">La operación se intenta en un dominio de aplicación descargado.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requiere plena confianza para el llamador inmediato. Este miembro no se puede usar código de confianza parcial o transparente.</permission>
        <altmember cref="P:System.AppDomainSetup.CachePath" />
        <related type="Article" href="~/docs/framework/app-domains/shadow-copy-assemblies.md">Copias sombra de ensamblados</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="SetData">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Asigna un valor a una propiedad de dominio de aplicación.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SetData">
      <MemberSignature Language="C#" Value="public void SetData (string name, object data);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void SetData(string name, object data) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.SetData(System.String,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetData (name As String, data As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void SetData(System::String ^ name, System::Object ^ data);" />
      <MemberSignature Language="F#" Value="abstract member SetData : string * obj -&gt; unit&#xA;override this.SetData : string * obj -&gt; unit" Usage="appDomain.SetData (name, data)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.SetData(System.String,System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="data" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="name">Nombre de una propiedad de dominio de aplicación definida por el usuario que se va a crear o cambiar.</param>
        <param name="data">Valor de la propiedad.</param>
        <summary>Asigna el valor especificado a la propiedad especificada del dominio de aplicación.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use este método para insertar una entrada o modificar el valor de una entrada en una memoria caché interna de pares de nombre y datos que describen las propiedades de esta instancia de <xref:System.AppDomain>.  
  
 La memoria caché contiene automáticamente las entradas del sistema predefinidos que se insertan cuando se crea el dominio de aplicación. No se puede insertar o modificar las entradas del sistema con este método. Una llamada al método que intenta modificar una entrada de sistema no tiene ningún efecto; el método no produce una excepción. Puede inspeccionar los valores de las entradas del sistema con el <xref:System.AppDomain.GetData%2A> método o el equivalente <xref:System.AppDomainSetup> describen las propiedades en <xref:System.AppDomain.GetData%2A>.  
  
 Puede llamar a este método para establecer el valor del intervalo de tiempo de espera predeterminado para evaluar patrones de expresiones regulares mediante la fuente de alimentación "REGEX_DEFAULT_MATCH_TIMEOUT" como valor de la `name` argumento y un <xref:System.TimeSpan> valor que representa el tiempo de espera intervalo como el valor de la `data` argumento. También puede insertar o modificar sus propios pares de nombre y datos definidos por el usuario con este método y examinar sus valores con el <xref:System.AppDomain.GetData%2A> método.  
  
   
  
## Examples  
 En el ejemplo siguiente se muestra cómo usar el <xref:System.AppDomain.SetData%28System.String%2CSystem.Object%29> método para crear un nuevo par de valor. El ejemplo se utiliza el <xref:System.AppDomain.GetData%2A> método para recuperar el valor y se muestra en la consola.  
  
 [!code-cpp[ADGetData#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADGetData/CPP/adgetdata.cpp#1)]
 [!code-csharp[ADGetData#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADGetData/CS/adgetdata.cs#1)]
 [!code-vb[ADGetData#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADGetData/VB/adgetdata.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException">La operación se intenta en un dominio de aplicación descargado.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requiere plena confianza para el llamador inmediato. Este miembro no se puede usar código de confianza parcial o transparente.</permission>
        <altmember cref="M:System.AppDomain.GetData(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="SetData">
      <MemberSignature Language="C#" Value="public void SetData (string name, object data, System.Security.IPermission permission);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetData(string name, object data, class System.Security.IPermission permission) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.SetData(System.String,System.Object,System.Security.IPermission)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetData (name As String, data As Object, permission As IPermission)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetData(System::String ^ name, System::Object ^ data, System::Security::IPermission ^ permission);" />
      <MemberSignature Language="F#" Value="member this.SetData : string * obj * System.Security.IPermission -&gt; unit" Usage="appDomain.SetData (name, data, permission)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="data" Type="System.Object" Index="1" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="permission" Type="System.Security.IPermission" Index="2" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="name">Nombre de una propiedad de dominio de aplicación definida por el usuario que se va a crear o cambiar.</param>
        <param name="data">Valor de la propiedad.</param>
        <param name="permission">Permiso que se va a exigir al llamador cuando se recupere la propiedad.</param>
        <summary>Asigna el valor especificado a la propiedad de dominio de aplicación indicada, con un permiso especificado que se exige al llamador cuando se recupera la propiedad.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilice este método para insertar o modificar sus propias entradas definidas por el usuario en una memoria caché interna de pares de nombre/datos que describen las propiedades del dominio de aplicación. Cuando se inserta una entrada, puede especificar una demanda de permiso para aplicar cuando se recupera la entrada. Además, puede llamar a este método para establecer el valor del intervalo de tiempo de espera predeterminado para evaluar patrones de expresiones regulares mediante la fuente de alimentación "REGEX_DEFAULT_MATCH_TIMEOUT" como el valor de la `name` argumento y un <xref:System.TimeSpan> valor que representa el intervalo de tiempo de espera que el valor de la `data` argumento.  
  
 No se puede usar este método para asignar una petición de seguridad a una cadena de propiedad definido por el sistema.  
  
 La memoria caché contiene automáticamente las entradas del sistema predefinidos que se insertan cuando se crea el dominio de aplicación. No se puede insertar o modificar las entradas del sistema con este método. Una llamada al método que intenta modificar una entrada de sistema no tiene ningún efecto; el método no produce una excepción. Puede inspeccionar los valores de las entradas del sistema con el <xref:System.AppDomain.GetData%2A> método o el equivalente <xref:System.AppDomainSetup> las propiedades descritas en la sección Comentarios para el <xref:System.AppDomain.GetData%2A> método.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> es <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="name" /> especifica una cadena de propiedad definida por el sistema y <paramref name="permission" /> no es <see langword="null" />.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requiere plena confianza para el llamador inmediato. Este miembro no se puede usar código de confianza parcial o transparente.</permission>
      </Docs>
    </Member>
    <Member MemberName="SetDynamicBase">
      <MemberSignature Language="C#" Value="public void SetDynamicBase (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetDynamicBase(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.SetDynamicBase(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetDynamicBase (path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetDynamicBase(System::String ^ path);" />
      <MemberSignature Language="F#" Value="member this.SetDynamicBase : string -&gt; unit" Usage="appDomain.SetDynamicBase path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use AppDomainSetup.DynamicBase")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.Obsolete("AppDomain.SetDynamicBase has been deprecated. Please investigate the use of AppDomainSetup.DynamicBase instead. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-3.0">
          <AttributeName>System.Obsolete("AppDomain.SetDynamicBase has been deprecated. Please investigate the use of AppDomainSetup.DynamicBase instead. https://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Ruta de acceso completa que es el directorio base de los subdirectorios donde se almacenan los ensamblados dinámicos.</param>
        <summary>Establece la ruta de acceso al directorio especificado como directorio base de los subdirectorios donde se almacenan los archivos generados de forma dinámica y se obtiene acceso a ellos.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método establece el <xref:System.AppDomainSetup.DynamicBase%2A> propiedad de interno <xref:System.AppDomainSetup> asociado con esta instancia.  
  
   
  
## Examples  
 Este método ahora está obsoleto y no se recomienda para nuevo desarrollo. El ejemplo siguiente muestra cómo usar la alternativa no obsoleta, la <xref:System.AppDomainSetup.DynamicBase%2A?displayProperty=nameWithType> propiedad. Para obtener una explicación de este ejemplo, vea el <xref:System.AppDomainSetup.DynamicBase%2A?displayProperty=nameWithType> propiedad o el <xref:System.AppDomain.DynamicDirectory%2A> propiedad.  
  
 [!code-cpp[ADDynamicBase#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADDynamicBase/CPP/addynamicbase.cpp#1)]
 [!code-csharp[ADDynamicBase#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADDynamicBase/CS/addynamicbase.cs#1)]
 [!code-vb[ADDynamicBase#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADDynamicBase/VB/addynamicbase.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException">La operación se intenta en un dominio de aplicación descargado.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requiere plena confianza para el llamador inmediato. Este miembro no se puede usar código de confianza parcial o transparente.</permission>
        <altmember cref="P:System.AppDomainSetup.DynamicBase" />
      </Docs>
    </Member>
    <Member MemberName="SetPrincipalPolicy">
      <MemberSignature Language="C#" Value="public void SetPrincipalPolicy (System.Security.Principal.PrincipalPolicy policy);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetPrincipalPolicy(valuetype System.Security.Principal.PrincipalPolicy policy) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.SetPrincipalPolicy(System.Security.Principal.PrincipalPolicy)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetPrincipalPolicy (policy As PrincipalPolicy)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetPrincipalPolicy(System::Security::Principal::PrincipalPolicy policy);" />
      <MemberSignature Language="F#" Value="member this.SetPrincipalPolicy : System.Security.Principal.PrincipalPolicy -&gt; unit" Usage="appDomain.SetPrincipalPolicy policy" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="policy" Type="System.Security.Principal.PrincipalPolicy" />
      </Parameters>
      <Docs>
        <param name="policy">Uno de los valores de <see cref="T:System.Security.Principal.PrincipalPolicy" /> que especifica el tipo del objeto principal que se va a asociar a los subprocesos.</param>
        <summary>Especifica la forma en que los objetos principales y de identidad deben asociarse a un subproceso si éste intenta enlazarse a un principal mientas se ejecuta en este dominio de aplicación.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Al establecer este valor sólo serán efectivo si se establece antes de usar el <xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=nameWithType> propiedad. Por ejemplo, si establece <xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=nameWithType> a una entidad determinada (por ejemplo, una entidad de seguridad genérico) y, después, use el <xref:System.AppDomain.SetPrincipalPolicy%2A> método para establecer el <xref:System.Security.Principal.PrincipalPolicy> a <xref:System.Security.Principal.PrincipalPolicy.WindowsPrincipal>, la entidad de seguridad actual seguirá siendo la entidad de seguridad genérico.  
  
   
  
## Examples  
 El ejemplo siguiente muestra el efecto en los subprocesos del uso de la <xref:System.AppDomain.SetPrincipalPolicy%2A> método para cambiar la directiva de entidad del dominio de aplicación. También se muestra el efecto de usar el <xref:System.AppDomain.SetThreadPrincipal%2A> método para cambiar la entidad de seguridad que está disponible para asociar a los subprocesos en el dominio de aplicación.  
  
 [!code-cpp[ADPrincipal#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADPrincipal/CPP/adprincipal.cpp#1)]
 [!code-csharp[ADPrincipal#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADPrincipal/CS/adprincipal.cs#1)]
 [!code-vb[ADPrincipal#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADPrincipal/VB/adprincipal.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException">La operación se intenta en un dominio de aplicación descargado.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Para poder manipular el objeto principal. Enumeración asociada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlPrincipal" />. Acción de seguridad: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="SetShadowCopyFiles">
      <MemberSignature Language="C#" Value="public void SetShadowCopyFiles ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetShadowCopyFiles() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.SetShadowCopyFiles" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetShadowCopyFiles ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetShadowCopyFiles();" />
      <MemberSignature Language="F#" Value="member this.SetShadowCopyFiles : unit -&gt; unit" Usage="appDomain.SetShadowCopyFiles " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use AppDomainSetup.ShadowCopyFiles")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.Obsolete("AppDomain.SetShadowCopyFiles has been deprecated. Please investigate the use of AppDomainSetup.ShadowCopyFiles instead. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-3.0">
          <AttributeName>System.Obsolete("AppDomain.SetShadowCopyFiles has been deprecated. Please investigate the use of AppDomainSetup.ShadowCopyFiles instead. https://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Activa la creación de instantáneas.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para obtener más información sobre las instantáneas, vea [copias sombra de ensamblados](~/docs/framework/app-domains/shadow-copy-assemblies.md).  
  
   
  
## Examples  
 Este método ahora está obsoleto y no se recomienda para nuevo desarrollo.  
  
 [!code-cpp[adproperties#1](~/samples/snippets/cpp/VS_Snippets_CLR/adproperties/CPP/adproperties.cpp#1)]
 [!code-csharp[adproperties#1](~/samples/snippets/csharp/VS_Snippets_CLR/adproperties/CS/adproperties.cs#1)]
 [!code-vb[adproperties#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/adproperties/VB/adproperties.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException">La operación se intenta en un dominio de aplicación descargado.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requiere plena confianza para el llamador inmediato. Este miembro no se puede usar código de confianza parcial o transparente.</permission>
        <related type="Article" href="~/docs/framework/app-domains/shadow-copy-assemblies.md">Copias sombra de ensamblados</related>
      </Docs>
    </Member>
    <Member MemberName="SetShadowCopyPath">
      <MemberSignature Language="C#" Value="public void SetShadowCopyPath (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void SetShadowCopyPath(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.SetShadowCopyPath(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetShadowCopyPath (path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void SetShadowCopyPath(System::String ^ path);" />
      <MemberSignature Language="F#" Value="abstract member SetShadowCopyPath : string -&gt; unit&#xA;override this.SetShadowCopyPath : string -&gt; unit" Usage="appDomain.SetShadowCopyPath path" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.SetShadowCopyPath(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use AppDomainSetup.ShadowCopyDirectories")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.Obsolete("AppDomain.SetShadowCopyPath has been deprecated. Please investigate the use of AppDomainSetup.ShadowCopyDirectories instead. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-3.0">
          <AttributeName>System.Obsolete("AppDomain.SetShadowCopyPath has been deprecated. Please investigate the use of AppDomainSetup.ShadowCopyDirectories instead. https://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Lista de nombres de directorio separados por puntos y comas.</param>
        <summary>Establece la ruta de acceso al directorio especificado como la ubicación de las instantáneas de los ensamblados.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 De forma predeterminada, una copia sombra incluye todos los ensamblados que se encuentran a través de sondeo. El <xref:System.AppDomain.SetShadowCopyPath%2A> método restringe la instantánea a los ensamblados en los directorios especificados por `path`.  
  
 El <xref:System.AppDomain.SetShadowCopyPath%2A> método no especificar directorios adicionales que se buscarán los ensamblados. Los ensamblados se hiciera deben estar ubicados en la ruta de búsqueda, por ejemplo en <xref:System.AppDomain.BaseDirectory%2A>. El <xref:System.AppDomain.SetShadowCopyPath%2A> método especifica qué rutas de acceso de búsqueda son aptas para realizar una copia sombra.  
  
 Este método establece el <xref:System.AppDomainSetup.ShadowCopyDirectories%2A> propiedad de interno <xref:System.AppDomainSetup> asociado con esta instancia.  
  
 Para obtener más información sobre las instantáneas, vea [copias sombra de ensamblados](~/docs/framework/app-domains/shadow-copy-assemblies.md).  
  
   
  
## Examples  
 Este método ahora está obsoleto y no se recomienda para nuevo desarrollo.  
  
 [!code-cpp[ADShadowCopy#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADShadowCopy/CPP/adshadowcopy.cpp#1)]
 [!code-csharp[ADShadowCopy#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADShadowCopy/CS/adshadowcopy.cs#1)]
 [!code-vb[ADShadowCopy#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADShadowCopy/VB/adshadowcopy.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException">La operación se intenta en un dominio de aplicación descargado.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requiere plena confianza para el llamador inmediato. Este miembro no se puede usar código de confianza parcial o transparente.</permission>
        <related type="Article" href="~/docs/framework/app-domains/shadow-copy-assemblies.md">Copias sombra de ensamblados</related>
      </Docs>
    </Member>
    <Member MemberName="SetThreadPrincipal">
      <MemberSignature Language="C#" Value="public void SetThreadPrincipal (System.Security.Principal.IPrincipal principal);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetThreadPrincipal(class System.Security.Principal.IPrincipal principal) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.SetThreadPrincipal(System.Security.Principal.IPrincipal)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetThreadPrincipal (principal As IPrincipal)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetThreadPrincipal(System::Security::Principal::IPrincipal ^ principal);" />
      <MemberSignature Language="F#" Value="member this.SetThreadPrincipal : System.Security.Principal.IPrincipal -&gt; unit" Usage="appDomain.SetThreadPrincipal principal" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="principal" Type="System.Security.Principal.IPrincipal" />
      </Parameters>
      <Docs>
        <param name="principal">Objeto principal que se va a asociar a los subprocesos.</param>
        <summary>Establece el objeto principal predeterminado que se va a asociar a los subprocesos si éstos intentan enlazarse a un principal mientras se ejecutan en este dominio de aplicación.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 El ejemplo siguiente muestra el efecto de usar el <xref:System.AppDomain.SetThreadPrincipal%2A> método para cambiar la entidad de seguridad que está disponible para asociar a los subprocesos que se ejecutan en el dominio de aplicación. También se muestra el efecto en los subprocesos del uso de la <xref:System.AppDomain.SetPrincipalPolicy%2A> método para cambiar la directiva de entidad del dominio de aplicación.  
  
 [!code-cpp[ADPrincipal#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADPrincipal/CPP/adprincipal.cpp#1)]
 [!code-csharp[ADPrincipal#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADPrincipal/CS/adprincipal.cs#1)]
 [!code-vb[ADPrincipal#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADPrincipal/VB/adprincipal.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="principal" /> es <see langword="null" />.</exception>
        <exception cref="T:System.Security.Policy.PolicyException">Ya se ha establecido la entidad de seguridad del subproceso.</exception>
        <exception cref="T:System.AppDomainUnloadedException">La operación se intenta en un dominio de aplicación descargado.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Para poder manipular el objeto principal. Enumeración asociada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlPrincipal" />. Acción de seguridad: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="SetupInformation">
      <MemberSignature Language="C#" Value="public AppDomainSetup SetupInformation { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.AppDomainSetup SetupInformation" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.SetupInformation" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property SetupInformation As AppDomainSetup" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property AppDomainSetup ^ SetupInformation { AppDomainSetup ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.SetupInformation : AppDomainSetup" Usage="System.AppDomain.SetupInformation" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.AppDomainSetup</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene la información de configuración del dominio de aplicación correspondiente a esta instancia.</summary>
        <value>Información de inicialización del dominio de aplicación.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.AppDomainUnloadedException">La operación se intenta en un dominio de aplicación descargado.</exception>
      </Docs>
    </Member>
    <Member MemberName="ShadowCopyFiles">
      <MemberSignature Language="C#" Value="public bool ShadowCopyFiles { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ShadowCopyFiles" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.ShadowCopyFiles" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ShadowCopyFiles As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool ShadowCopyFiles { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.ShadowCopyFiles : bool" Usage="System.AppDomain.ShadowCopyFiles" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System._AppDomain.ShadowCopyFiles</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene una indicación si el dominio de aplicación se configura para archivos de instantánea.</summary>
        <value><see langword="true" /> si el dominio de aplicación se configura para archivos de instantánea; de lo contrario, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para obtener más información, consulte <xref:System.AppDomainSetup.ShadowCopyFiles%2A?displayProperty=nameWithType> y [copias sombra de ensamblados](~/docs/framework/app-domains/shadow-copy-assemblies.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException">La operación se intenta en un dominio de aplicación descargado.</exception>
        <altmember cref="P:System.AppDomainSetup.ShadowCopyFiles" />
        <related type="Article" href="~/docs/framework/app-domains/shadow-copy-assemblies.md">Copias sombra de ensamblados</related>
      </Docs>
    </Member>
    <Member MemberName="System._AppDomain.GetIDsOfNames">
      <MemberSignature Language="C#" Value="void _AppDomain.GetIDsOfNames (ref Guid riid, IntPtr rgszNames, uint cNames, uint lcid, IntPtr rgDispId);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System._AppDomain.GetIDsOfNames([in]valuetype System.Guid&amp; riid, native int rgszNames, unsigned int32 cNames, unsigned int32 lcid, native int rgDispId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.System#_AppDomain#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub GetIDsOfNames (ByRef riid As Guid, rgszNames As IntPtr, cNames As UInteger, lcid As UInteger, rgDispId As IntPtr) Implements _AppDomain.GetIDsOfNames" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System._AppDomain.GetIDsOfNames(Guid % riid, IntPtr rgszNames, System::UInt32 cNames, System::UInt32 lcid, IntPtr rgDispId) = _AppDomain::GetIDsOfNames;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="riid" Type="System.Guid" RefType="ref" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="rgszNames" Type="System.IntPtr" Index="1" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="cNames" Type="System.UInt32" Index="2" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="lcid" Type="System.UInt32" Index="3" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="rgDispId" Type="System.IntPtr" Index="4" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="riid">Reservado para un uso futuro. Debe ser IID_NULL.</param>
        <param name="rgszNames">Matriz que se pasa con los nombres que se van a asignar.</param>
        <param name="cNames">Número de nombres que se van a asignar.</param>
        <param name="lcid">Contexto de configuración regional en el que se van a interpretar los nombres.</param>
        <param name="rgDispId">Matriz asignada por el llamador que recibe los identificadores que corresponden a los nombres.</param>
        <summary>Asigna un conjunto de nombres a un conjunto correspondiente de identificadores de envío.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método es para el acceso a las clases administradas desde código no administrado y no debe llamarse desde código administrado. Para obtener más información sobre `IDispatch::GetIDsOfNames`, vea MSDN Library.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">No se admite el acceso enlazado en tiempo de ejecución mediante la interfaz <c>IDispatch</c> de COM.</exception>
      </Docs>
    </Member>
    <Member MemberName="System._AppDomain.GetTypeInfo">
      <MemberSignature Language="C#" Value="void _AppDomain.GetTypeInfo (uint iTInfo, uint lcid, IntPtr ppTInfo);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System._AppDomain.GetTypeInfo(unsigned int32 iTInfo, unsigned int32 lcid, native int ppTInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.System#_AppDomain#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub GetTypeInfo (iTInfo As UInteger, lcid As UInteger, ppTInfo As IntPtr) Implements _AppDomain.GetTypeInfo" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System._AppDomain.GetTypeInfo(System::UInt32 iTInfo, System::UInt32 lcid, IntPtr ppTInfo) = _AppDomain::GetTypeInfo;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="iTInfo" Type="System.UInt32" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="lcid" Type="System.UInt32" Index="1" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="ppTInfo" Type="System.IntPtr" Index="2" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="iTInfo">Información de tipos que se va a devolver.</param>
        <param name="lcid">Identificador de la configuración regional de la información de tipo.</param>
        <param name="ppTInfo">Recibe un puntero al objeto de información de tipo solicitado.</param>
        <summary>Recupera la información de tipo de un objeto, que se puede usar después para obtener la información de tipo de una interfaz.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método es para el acceso a las clases administradas desde código no administrado y no debe llamarse desde código administrado. Para obtener más información sobre `IDispatch::GetTypeInfo`, vea MSDN Library.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">No se admite el acceso enlazado en tiempo de ejecución mediante la interfaz <c>IDispatch</c> de COM.</exception>
      </Docs>
    </Member>
    <Member MemberName="System._AppDomain.GetTypeInfoCount">
      <MemberSignature Language="C#" Value="void _AppDomain.GetTypeInfoCount (out uint pcTInfo);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System._AppDomain.GetTypeInfoCount([out] unsigned int32&amp; pcTInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.System#_AppDomain#GetTypeInfoCount(System.UInt32@)" />
      <MemberSignature Language="VB.NET" Value="Sub GetTypeInfoCount (ByRef pcTInfo As UInteger) Implements _AppDomain.GetTypeInfoCount" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System._AppDomain.GetTypeInfoCount([Runtime::InteropServices::Out] System::UInt32 % pcTInfo) = _AppDomain::GetTypeInfoCount;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.GetTypeInfoCount(System.UInt32@)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pcTInfo" Type="System.UInt32" RefType="out" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="pcTInfo">Señala a una ubicación que recibe el número de interfaces de información de tipo proporcionado por el objeto.</param>
        <summary>Recupera el número de interfaces de información de tipo que proporciona un objeto (0 ó 1).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método es para el acceso a las clases administradas desde código no administrado y no debe llamarse desde código administrado. Para obtener más información sobre `IDispatch::GetTypeInfoCount`, vea MSDN Library.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">No se admite el acceso enlazado en tiempo de ejecución mediante la interfaz <c>IDispatch</c> de COM.</exception>
      </Docs>
    </Member>
    <Member MemberName="System._AppDomain.Invoke">
      <MemberSignature Language="C#" Value="void _AppDomain.Invoke (uint dispIdMember, ref Guid riid, uint lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System._AppDomain.Invoke(unsigned int32 dispIdMember, [in]valuetype System.Guid&amp; riid, unsigned int32 lcid, int16 wFlags, native int pDispParams, native int pVarResult, native int pExcepInfo, native int puArgErr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.System#_AppDomain#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub Invoke (dispIdMember As UInteger, ByRef riid As Guid, lcid As UInteger, wFlags As Short, pDispParams As IntPtr, pVarResult As IntPtr, pExcepInfo As IntPtr, puArgErr As IntPtr) Implements _AppDomain.Invoke" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System._AppDomain.Invoke(System::UInt32 dispIdMember, Guid % riid, System::UInt32 lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr) = _AppDomain::Invoke;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dispIdMember" Type="System.UInt32" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="riid" Type="System.Guid" RefType="ref" Index="1" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="lcid" Type="System.UInt32" Index="2" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="wFlags" Type="System.Int16" Index="3" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="pDispParams" Type="System.IntPtr" Index="4" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="pVarResult" Type="System.IntPtr" Index="5" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="pExcepInfo" Type="System.IntPtr" Index="6" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="puArgErr" Type="System.IntPtr" Index="7" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="dispIdMember">Identifica el miembro.</param>
        <param name="riid">Reservado para un uso futuro. Debe ser IID_NULL.</param>
        <param name="lcid">Contexto de la configuración regional en que se interpretan los argumentos.</param>
        <param name="wFlags">Marcas que describen el contexto de la llamada.</param>
        <param name="pDispParams">Puntero a una estructura que contiene una matriz de argumentos, una matriz de valores DISPID de argumento para argumentos con nombre y recuentos del número de elementos de cada matriz.</param>
        <param name="pVarResult">Puntero a la ubicación donde se va a almacenar el resultado.</param>
        <param name="pExcepInfo">Puntero a una estructura que contiene información de excepciones.</param>
        <param name="puArgErr">Índice del primer argumento que tiene un error.</param>
        <summary>Proporciona acceso a las propiedades y los métodos expuestos por un objeto.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método es para el acceso a las clases administradas desde código no administrado y no debe llamarse desde código administrado. Para obtener más información sobre `IDispatch::Invoke`, vea MSDN Library.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">No se admite el acceso enlazado en tiempo de ejecución mediante la interfaz <c>IDispatch</c> de COM.</exception>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="appDomain.ToString " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.ToString</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Obtiene una representación en forma de cadena que incluye el nombre descriptivo del dominio de aplicación y cualquier directiva del contexto.</summary>
        <returns>Cadena formada al concatenar la cadena literal "Nombre:", el nombre descriptivo del dominio de aplicación y las representaciones en forma de cadena de las directivas de contexto o la cadena "No hay directivas de contexto".</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 En el ejemplo de código siguiente se muestra el valor devuelto de la <xref:System.AppDomain.ToString%2A> método.  
  
 [!code-cpp[ADToString#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADToString/CPP/adtostring.cpp#1)]
 [!code-csharp[ADToString#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADToString/CS/adtostring.cs#1)]
 [!code-vb[ADToString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADToString/VB/adtostring.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException">Se ha descargado el dominio de aplicación que representa el objeto <see cref="T:System.AppDomain" /> actual.</exception>
      </Docs>
    </Member>
    <Member MemberName="TypeResolve">
      <MemberSignature Language="C#" Value="public event ResolveEventHandler TypeResolve;" />
      <MemberSignature Language="ILAsm" Value=".event class System.ResolveEventHandler TypeResolve" />
      <MemberSignature Language="DocId" Value="E:System.AppDomain.TypeResolve" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event TypeResolve As ResolveEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event ResolveEventHandler ^ TypeResolve;" />
      <MemberSignature Language="F#" Value="member this.TypeResolve : ResolveEventHandler " Usage="member this.TypeResolve : System.ResolveEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System._AppDomain.TypeResolve</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>add: System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>remove: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ResolveEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produce cuando la resolución de un tipo produce errores.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.AppDomain.TypeResolve> evento se produce cuando common language runtime no puede determinar el ensamblado que se puede crear el tipo solicitado. Esto puede ocurrir si el tipo está definido en un ensamblado dinámico, o el tipo no está definido en un ensamblado dinámico, pero el tiempo de ejecución no sabe qué ensamblado está definido el tipo. La última situación puede producirse cuando <xref:System.Type.GetType%2A?displayProperty=nameWithType> se denomina con un nombre de tipo que no está calificado con el nombre del ensamblado.  
  
 El <xref:System.ResolveEventHandler> de este evento puede intentar localizar y crear el tipo.  
  
 Sin embargo, el <xref:System.AppDomain.TypeResolve> evento no se produce si el tiempo de ejecución sabe que no es posible encontrar un tipo en determinados ensamblados. Por ejemplo, este evento no se produce si el tipo no se encuentra en un ensamblado estático porque el tiempo de ejecución sepa tipos no se puede agregar dinámicamente a los ensamblados estáticos.  
  
 A partir del [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], el <xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=nameWithType> propiedad contiene el ensamblado que solicitó el tipo. Para obtener más información, vea <xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=nameWithType>.  
  
 Para registrar un controlador de eventos para este evento, debe tener los permisos necesarios, o un <xref:System.Security.SecurityException> se produce.  
  
 Para obtener más información sobre el manejo de eventos, consulte [controlar y provocar eventos](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 El ejemplo siguiente se muestra el <xref:System.AppDomain.TypeResolve> eventos.  
  
 Para que poder ejecutar este ejemplo de código, debe proporcionar el nombre completo del ensamblado. Para obtener información acerca de cómo obtener el nombre completo del ensamblado, vea [nombres de ensamblado](~/docs/framework/app-domains/assembly-names.md).  
  
 [!code-cpp[AppDomain_TypeResolve#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_TypeResolve/CPP/typeresolve.cpp#1)]
 [!code-csharp[AppDomain_TypeResolve#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_TypeResolve/CS/typeresolve.cs#1)]
 [!code-vb[AppDomain_TypeResolve#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_TypeResolve/VB/typeresolve.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requiere plena confianza para el llamador inmediato. Este miembro no se puede usar código de confianza parcial o transparente.</permission>
        <altmember cref="P:System.ResolveEventArgs.RequestingAssembly" />
      </Docs>
    </Member>
    <Member MemberName="UnhandledException">
      <MemberSignature Language="C#" Value="public event UnhandledExceptionEventHandler UnhandledException;" />
      <MemberSignature Language="ILAsm" Value=".event class System.UnhandledExceptionEventHandler UnhandledException" />
      <MemberSignature Language="DocId" Value="E:System.AppDomain.UnhandledException" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event UnhandledException As UnhandledExceptionEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event UnhandledExceptionEventHandler ^ UnhandledException;" />
      <MemberSignature Language="F#" Value="member this.UnhandledException : UnhandledExceptionEventHandler " Usage="member this.UnhandledException : System.UnhandledExceptionEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System._AppDomain.UnhandledException</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>add: System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>remove: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UnhandledExceptionEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produce cuando no se detecta una excepción.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este evento proporciona una notificación de excepciones no detectadas. Permite que la aplicación registrar información sobre la excepción antes de que el controlador predeterminado del sistema notifica la excepción al usuario y finaliza la aplicación. Si hay suficiente información sobre el estado de la aplicación de acciones disponibles, otras pueden emprenderse - por ejemplo, guardar los datos de programa para su posterior recuperación. Precaución, porque los datos de programa pueden dañarse cuando no se controlan las excepciones.  
  
> [!NOTE]
>  En las versiones 1.0 y 1.1 de .NET Framework, opciones de depuración y de finalización de la aplicación se notifican al usuario antes de que se genera este evento, en lugar de después.  
  
 Este evento se puede controlar en cualquier dominio de aplicación. Sin embargo, el evento no se genera necesariamente en el dominio de aplicación donde se produjo la excepción. Una excepción es no controlada solo si se ha quitado toda la pila del subproceso sin encontrar un controlador de excepciones es aplicable, por lo que es el primer lugar que el evento puede generarse en el dominio de aplicación donde se originó el subproceso.  
  
> [!NOTE]
>  En las versiones 1.0 y 1.1 de .NET Framework, este evento se produce solo en el dominio de aplicación predeterminado creado por el sistema cuando se inicia una aplicación. Si una aplicación crea dominios de aplicación adicionales, especificando a un delegado para este evento en dichos dominios de aplicación no tiene ningún efecto.  
  
 Si el <xref:System.AppDomain.UnhandledException> evento se controla en el dominio de aplicación predeterminado, se producirá allí para cualquier excepción no controlada en cualquier subproceso, independientemente de qué dominio de aplicación la ha iniciado el subproceso. Si se ha iniciado el subproceso en un dominio de aplicación que tiene un controlador de eventos <xref:System.AppDomain.UnhandledException>, se genera el evento en ese dominio de aplicación. Si ese dominio de aplicación no es el dominio de aplicación predeterminado, y también hay un controlador de eventos en el dominio de aplicación predeterminado, el evento se produce en dos dominios de aplicación.  
  
 Por ejemplo, supongamos que un subproceso se inicia en el dominio de aplicación "AD1", llama a un método en el dominio de aplicación "AD2" y, a partir de ahí llama a un método en el dominio de aplicación "AD3", donde produce una excepción. El primer dominio de aplicación en el que el <xref:System.AppDomain.UnhandledException> puede generarse el evento es "AD1". Si ese dominio de aplicación no es el dominio de aplicación predeterminado, también se provoca el evento en el dominio de aplicación predeterminado.  
  
> [!NOTE]
>  Common language runtime suspende las anulaciones de subproceso mientras los controladores de eventos para el <xref:System.AppDomain.UnhandledException> eventos se ejecutan.  
  
 Si el controlador de eventos tiene un <xref:System.Runtime.ConstrainedExecution.ReliabilityContractAttribute> atributo con las marcas apropiadas, el controlador de eventos se trata como una región de ejecución restringida.  
  
 A partir de la [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], no se provoca este evento para las excepciones que se dañan el estado del proceso, como desbordamientos de pila o infracciones de acceso, a menos que el controlador de eventos es crítico para la seguridad y tiene el <xref:System.Runtime.ExceptionServices.HandleProcessCorruptedStateExceptionsAttribute> atributo.  
  
 En las versiones 1.0 y 1.1 de .NET Framework, una excepción no controlada que se produce en un subproceso distinto del subproceso principal de la aplicación ha sido detectada por el tiempo de ejecución y, por tanto, no hace que la aplicación finalice. Por lo tanto, es posible que el <xref:System.AppDomain.UnhandledException> evento sin la terminación de la aplicación. A partir de la versión 2.0 de .NET Framework, este mecanismo de seguridad para las excepciones no controladas en subprocesos secundarios se ha quitado, puesto que el efecto acumulativo de errores sin incluido una degradación del rendimiento, datos dañados y bloqueos, que eran difíciles depurar. Para obtener más información, incluida una lista de los casos en los que no finaliza el tiempo de ejecución, consulte [excepciones en subprocesos administrados](~/docs/standard/threading/exceptions-in-managed-threads.md).  
  
 Para registrar un controlador de eventos para este evento, debe tener los permisos necesarios, o un <xref:System.Security.SecurityException> se produce.  
  
 Para obtener más información sobre el manejo de eventos, consulte [controlar y provocar eventos](~/docs/standard/events/index.md).  
  
## <a name="other-events-for-unhandled-exceptions"></a>Otros eventos para las excepciones no controladas  
 Para determinados modelos de aplicación, el <xref:System.AppDomain.UnhandledException> evento puede ser adelantado por otros eventos si se produce la excepción no controlada en el subproceso principal de la aplicación.  
  
 En las aplicaciones que usan Windows Forms, excepciones no controladas en la causa del subproceso principal de la aplicación la <xref:System.Windows.Forms.Application.ThreadException?displayProperty=nameWithType> evento. Si se controla este evento, el comportamiento predeterminado es que la excepción no controlada finaliza la aplicación, aunque la aplicación se queda en un estado desconocido. En ese caso, el <xref:System.AppDomain.UnhandledException> no se produce el evento. Este comportamiento puede modificarse mediante el archivo de configuración de aplicación, o mediante el uso de la <xref:System.Windows.Forms.Application.SetUnhandledExceptionMode%2A?displayProperty=nameWithType> método para cambiar el modo a <xref:System.Windows.Forms.UnhandledExceptionMode.ThrowException?displayProperty=nameWithType> antes el <xref:System.Windows.Forms.Application.ThreadException> se enlazó el controlador de eventos. Esto se aplica sólo al subproceso principal de la aplicación. El <xref:System.AppDomain.UnhandledException> evento se desencadena para excepciones no controladas producidas en otros subprocesos.  
  
 A partir de Microsoft Visual Studio 2005, el marco de aplicación de Visual Basic proporciona otro evento para las excepciones no controladas en el subproceso principal de la aplicación. Consulte la <xref:Microsoft.VisualBasic.ApplicationServices.WindowsFormsApplicationBase.UnhandledException?displayProperty=nameWithType> eventos. Este evento tiene un objeto de argumentos de evento con el mismo nombre que el objeto de argumentos de evento utilizado por <xref:System.AppDomain.UnhandledException?displayProperty=nameWithType>, pero con diferentes propiedades. En concreto, este objeto de argumentos de evento tiene un <xref:Microsoft.VisualBasic.ApplicationServices.UnhandledExceptionEventArgs.ExitApplication%2A> propiedad que permite que la aplicación continuar la ejecución, se omitirá la excepción no controlada (y dejar la aplicación en un estado desconocido). En ese caso, el <xref:System.AppDomain.UnhandledException?displayProperty=nameWithType> no se produce el evento.  
  
   
  
## Examples  
 El siguiente ejemplo se muestra el <xref:System.AppDomain.UnhandledException> eventos. Define un controlador de eventos, `MyHandler`, que se invoca cuando se produce una excepción no controlada en el dominio de aplicación predeterminado. A continuación, se produce dos excepciones. La primera se controla mediante un **try/catch** bloque. El segundo es controlado y se invoca el `MyHandle` rutina antes de que termine la aplicación.  
  
 [!code-cpp[AppDomain_UnhandledException#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_UnhandledException/CPP/unhandledexception.cpp#1)]
 [!code-csharp[AppDomain_UnhandledException#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_UnhandledException/CS/unhandledexception.cs#1)]
 [!code-vb[AppDomain_UnhandledException#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_UnhandledException/VB/unhandledexception.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requiere plena confianza para el llamador inmediato. Este miembro no se puede usar código de confianza parcial o transparente.</permission>
      </Docs>
    </Member>
    <Member MemberName="Unload">
      <MemberSignature Language="C#" Value="public static void Unload (AppDomain domain);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Unload(class System.AppDomain domain) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.Unload(System.AppDomain)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Unload (domain As AppDomain)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Unload(AppDomain ^ domain);" />
      <MemberSignature Language="F#" Value="static member Unload : AppDomain -&gt; unit" Usage="System.AppDomain.Unload domain" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptAppDomain, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="domain" Type="System.AppDomain" />
      </Parameters>
      <Docs>
        <param name="domain">Dominio de aplicación que se va a descargar.</param>
        <summary>Descarga el dominio de aplicación especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 En la versión 2.0 de .NET Framework, hay un subproceso dedicado para descargar dominios de aplicación. Esto mejora la confiabilidad, especialmente cuando se hospeda .NET Framework. Cuando un subproceso llama <xref:System.AppDomain.Unload%2A>, el dominio de destino se ha marcado para descarga. El subproceso dedicado intenta descargar el dominio, y anulan todos los subprocesos del dominio. Si un subproceso no anula, por ejemplo porque se está ejecutando código no administrado, o porque se está ejecutando un `finally` bloque, a continuación, tras un período de tiempo un <xref:System.CannotUnloadAppDomainException> se produce en el subproceso que llamó originalmente <xref:System.AppDomain.Unload%2A>. Si el subproceso que no se pudo anular finalmente finaliza, no se descarga el dominio de destino. Por lo tanto, en la versión 2.0 de .NET Framework `domain` no se garantiza que se descargue porque podría no ser posible terminar subprocesos en ejecución.  
  
> [!NOTE]
>  En algunos casos, una llamada a <xref:System.AppDomain.Unload%2A> hace inmediato <xref:System.CannotUnloadAppDomainException>, por ejemplo si se llama en un finalizador.  
  
 Los subprocesos en `domain` se terminan con el <xref:System.Threading.Thread.Abort%2A> método que inicia un <xref:System.Threading.ThreadAbortException> en el subproceso. Aunque el subproceso debe terminar rápidamente, puede seguir ejecutándose durante un período de tiempo en impredecibles un `finally` cláusula.  
  
## <a name="version-compatibility"></a>Compatibilidad de versiones  
 En .NET Framework versiones 1.0 y 1.1, si el subproceso que llama a <xref:System.AppDomain.Unload%2A> se está ejecutando en `domain`, se inicia otro subproceso para realizar la operación de descarga. Si `domain` no se puede descargar, un <xref:System.CannotUnloadAppDomainException> se produce en ese subproceso, no en el subproceso original que llamó a <xref:System.AppDomain.Unload%2A>. Sin embargo, si el subproceso que llama a <xref:System.AppDomain.Unload%2A> se está ejecutando fuera `domain`, que el subproceso recibe la excepción.  
  
   
  
## Examples  
 El ejemplo de código siguiente muestra cómo descargar un dominio de aplicación.  
  
 [!code-cpp[ADUnload#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADUnload/CPP/adunload.cpp#1)]
 [!code-csharp[ADUnload#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADUnload/CS/adunload.cs#1)]
 [!code-vb[ADUnload#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADUnload/VB/adunload.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="domain" /> es <see langword="null" />.</exception>
        <exception cref="T:System.CannotUnloadAppDomainException">No se pudo descargar <paramref name="domain" />.</exception>
        <exception cref="T:System.Exception">Error durante el proceso de descarga.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Para agregar un controlador de eventos para este evento. Enumeración asociada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlAppDomain" />. Acción de seguridad: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />.</permission>
      </Docs>
    </Member>
  </Members>
</Type>