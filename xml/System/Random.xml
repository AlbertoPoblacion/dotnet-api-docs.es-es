<Type Name="Random" FullName="System.Random">
  <Metadata><Meta Name="ms.openlocfilehash" Value="adf29f522d3625dba7e4bd956743ac3e35b25683" /><Meta Name="ms.sourcegitcommit" Value="a3e01ec36374fac54a55add0dcc1e754e394abeb" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="es-ES" /><Meta Name="ms.lasthandoff" Value="03/30/2019" /><Meta Name="ms.locfileid" Value="58716530" /></Metadata><TypeSignature Language="C#" Value="public class Random" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable beforefieldinit Random extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Random" />
  <TypeSignature Language="VB.NET" Value="Public Class Random" />
  <TypeSignature Language="C++ CLI" Value="public ref class Random" />
  <TypeSignature Language="F#" Value="type Random = class" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime.Extensions</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Representa un generador de números pseudoaleatorios, que es un dispositivo que produce una secuencia de números que cumplen determinados requisitos estadísticos de aleatoriedad.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Números pseudoaleatorios se eligen con la misma probabilidad de un conjunto finito de números. Los números elegidos no son completamente aleatorios porque se utiliza un algoritmo matemático para seleccionarlos, pero son lo suficientemente aleatorios por motivos prácticos. La implementación actual de la <xref:System.Random> clase se basa en una versión modificada de sustracción generador algoritmo de números aleatorios de Knuth. Para obtener más información, consulte E. D. Knuth. *El arte de programación informática, volumen 2: Algoritmos Seminumerical*. Addison-Wesley, Reading, MA, tercera edición, 1997.  
  
 Para generar un número aleatorio criptográficamente seguro, por ejemplo, uno que sea adecuado para la creación de una contraseña aleatoria, use el <xref:System.Security.Cryptography.RNGCryptoServiceProvider> de clase o derivar una clase de <xref:System.Security.Cryptography.RandomNumberGenerator?displayProperty=nameWithType>.  
  
 En este tema:  
  
 [Crear una instancia de generador de números aleatorios](#Instantiate)   
 [Evitar varias creaciones de instancias](#Multiple)   
 [La seguridad de clase y subproceso System.Random](#ThreadSafety)   
 [Generación de diferentes tipos de números aleatorios](#Functionality)   
 [Sustituya su propio algoritmo](#Overriding)   
 [¿Cómo usar System.Random para...](#Operations)   
 [Recuperar la misma secuencia de valores aleatorios](#Same)  
 [Recuperar secuencias únicas de valores aleatorios](#Unique)  
 [Recuperar enteros en un intervalo especificado](#Range)  
 [Recuperar los enteros con un número especificado de dígitos](#Digits)  
 [Recuperar valores de punto flotante de un intervalo especificado](#Floats)  
 [Generar valores booleanos aleatorios](#Boolean)  
 [Generar enteros de 64 bits aleatorios](#Long)  
 [Recuperar bytes en un intervalo especificado](#Bytes)  
 [Recuperar un elemento de una matriz o colección de forma aleatoria](#Array)  
 [Recuperar un único elemento de una matriz o colección](#UniqueArray)  
  
<a name="Instantiate"></a>   
## <a name="instantiating-the-random-number-generator"></a>Crear una instancia de generador de números aleatorios  
 Crear instancias del generador de números aleatorios, proporcionando un valor de inicialización (un valor inicial para el algoritmo de generación de números pseudoaleatorios) a un <xref:System.Random.%23ctor%2A> constructor de clase.  Puede proporcionar el valor de inicialización de forma explícita o implícita:  
  
-   El <xref:System.Random.%23ctor%28System.Int32%29> constructor usa un valor de inicialización explícita que suministre.  
  
-   El <xref:System.Random.%23ctor> constructor utiliza el reloj del sistema para proporcionar un valor de inicialización. Se trata de la manera más común de crear instancias de generador de números aleatorios.  
  
 Si se usa el mismo valor de inicialización para otro <xref:System.Random> objetos, generará la misma serie de números aleatorios. Esto puede ser útil para crear un conjunto de pruebas que procesa los valores aleatorios o para reproducir juegos que se derivan sus datos de números aleatorios. Sin embargo, tenga en cuenta que <xref:System.Random> objetos en los procesos que se ejecutan con las distintas versiones de .NET Framework pueden devolver otra serie de números aleatorios, incluso si se crea una instancia con los valores de inicialización idénticos.  
  
 Para producir distintas secuencias de números aleatorios, puede realizar el valor de inicialización dependiente del tiempo, con lo que se genere una serie diferente con cada nueva instancia de <xref:System.Random>. Parametrizado <xref:System.Random.%23ctor%28System.Int32%29> constructor puede aceptar un <xref:System.Int32> valor según el número de pasos en la hora actual, mientras que sin parámetros <xref:System.Random.%23ctor> constructor utiliza el reloj del sistema para generar su valor de inicialización. Sin embargo, dado que el reloj tiene una resolución finita, utilizando el constructor sin parámetros para crear diferentes <xref:System.Random> objetos en sucesión cerrar crea generadores de números aleatorios que generan secuencias idénticas de números aleatorios. El ejemplo siguiente se muestra cómo dos <xref:System.Random> objetos que se crean instancias en estrecha sucesión generan una serie idéntica de números aleatorios. En la mayoría de los sistemas de Windows, <xref:System.Random> los objetos creados dentro de 15 milisegundos entre sí están probable que tengan valores de inicialización idénticos.  
  
 [!code-cpp[System.Random#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/random1.cpp#1)]
 [!code-csharp[System.Random#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/Random1.cs#1)]
 [!code-vb[System.Random#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/Random1.vb#1)]  
  
 Para evitar este problema, cree una sola <xref:System.Random> objeto en lugar de varios objetos.  
  
<a name="Multiple"></a>   
## <a name="avoiding-multiple-instantiations"></a>Evitar varias creaciones de instancias  
 Inicializar dos generadores de números aleatorios en un bucle ajustado, o en una sucesión rápida crea dos generadores de números aleatorios que pueden producir secuencias idénticas de números aleatorios. En la mayoría de los casos, esto no es la intención del desarrollador y puede dar lugar a problemas de rendimiento, ya que crear instancias e inicializar un generador de números aleatorios son un proceso relativamente costoso.  
  
 Para mejorar el rendimiento tanto para evitar crear inadvertidamente independientes generadores de números aleatorios que generan secuencias numéricas idénticas, se recomienda crear uno <xref:System.Random> objeto para generar muchos números aleatorios con el tiempo, en lugar de crear nuevo <xref:System.Random> objetos para generar un número aleatorio.  
  
 Sin embargo, la <xref:System.Random> clase no es seguro para subprocesos. Si se llama a <xref:System.Random> métodos desde varios subprocesos, siga las directrices analizadas en la sección siguiente.  
  
<a name="ThreadSafety"></a>   
## <a name="the-systemrandom-class-and-thread-safety"></a>La seguridad de clase y subproceso System.Random  
 En lugar de crear instancias individuales <xref:System.Random> objetos, le recomendamos que cree una sola <xref:System.Random> instancia para generar todos los números aleatorios necesarios para la aplicación. Sin embargo, <xref:System.Random> objetos no son seguros para subprocesos. Si su aplicación llama a <xref:System.Random> métodos desde varios subprocesos, debe usar un objeto de sincronización para asegurarse de que sólo un subproceso puede tener acceso a generador de números aleatorios en un momento. Si no está seguro de que el <xref:System.Random> acceso al objeto de una manera segura para subprocesos, las llamadas a métodos que devuelven números aleatorios devuelven 0.  
  
 En el ejemplo siguiente se usa C# [lock (instrucción)](~/docs/csharp/language-reference/keywords/lock-statement.md) y Visual Basic [instrucción SyncLock](~/docs/visual-basic/language-reference/statements/synclock-statement.md) para asegurarse de que un único generador de números aleatorios se obtiene acceso a 11 subprocesos de manera segura para subprocesos. Cada subproceso genera números aleatorios de 2 millones, cuenta el número de números aleatorios generados y calcula su suma y, a continuación, actualiza los totales de todos los subprocesos cuando finaliza la ejecución.  
  
 [!code-cpp[System.Random#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/threadsafeex1.cpp#3)]
 [!code-csharp[System.Random#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/threadsafeex1.cs#3)]
 [!code-vb[System.Random#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/threadsafeex1.vb#3)]  
  
 En el ejemplo se garantiza la seguridad para subprocesos de las maneras siguientes:  
  
-   El <xref:System.ThreadStaticAttribute> atributo se utiliza para definir las variables locales de subprocesos que realizan el seguimiento del número total de números aleatorios generados y su suma para cada subproceso.  
  
-   Un bloqueo (el `lock` instrucción en C# y el `SyncLock` instrucción en Visual Basic) protege el acceso a las variables para el recuento total y la suma de todos los números aleatorios que se generan en todos los subprocesos.  
  
-   Un semáforo (el <xref:System.Threading.CountdownEvent> objeto) se utiliza para garantizar que el subproceso principal se bloquea hasta que todos los demás subprocesos complete la ejecución.  
  
-   El ejemplo se comprueba si se ha dañado el generador de números aleatorios mediante la determinación de si las dos llamadas consecutivas a métodos de generación de números aleatorios devuelven 0. Si se detectan daños, el ejemplo utiliza la <xref:System.Threading.CancellationTokenSource> objeto para indicar que se deben cancelar todos los subprocesos.  
  
-   Antes de generar cada número aleatorio, cada subproceso comprueba el estado de la <xref:System.Threading.CancellationToken> objeto. Si se solicita la cancelación, el ejemplo llama a la <xref:System.Threading.CancellationToken.ThrowIfCancellationRequested%2A?displayProperty=nameWithType> método para cancelar el subproceso.  
  
 El ejemplo siguiente es idéntico al primero, salvo que usa un <xref:System.Threading.Tasks.Task> objeto y una expresión lambda en lugar de <xref:System.Threading.Thread> objetos.  
  
 [!code-csharp[System.Random#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/threadsafeex2.cs#4)]
 [!code-vb[System.Random#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/threadsafeex2.vb#4)]  
  
 El primer ejemplo difiere de las maneras siguientes:  
  
-   Las variables para realizar un seguimiento de la cantidad de números aleatorios generados y su suma de cada tarea son locales a la tarea, así que no hay ninguna necesidad de usar el <xref:System.ThreadStaticAttribute> atributo.  
  
-   Estático <xref:System.Threading.Tasks.Task.WaitAll%2A?displayProperty=nameWithType> método se utiliza para asegurarse de que el subproceso principal no se completa antes de que han terminado de todas las tareas. No es necesario para la <xref:System.Threading.CountdownEvent> objeto.  
  
-   La excepción que se origina la cancelación de tareas aparece en el <xref:System.Threading.Tasks.Task.WaitAll%2A?displayProperty=nameWithType> método. En el ejemplo anterior, se controlan por cada subproceso.  
  
<a name="Functionality"></a>   
## <a name="generating-different-types-of-random-numbers"></a>Generación de diferentes tipos de números aleatorios  
 El generador de números aleatorios proporciona métodos que permiten generar los siguientes tipos de números aleatorios:  
  
-   Una serie de <xref:System.Byte> valores. Determinar el número de valores de byte al pasar una matriz que se inicializa en el número de elementos que desea que el método para volver a la <xref:System.Random.NextBytes%2A> método. El ejemplo siguiente genera 20 bytes.  
  
     [!code-cpp[System.Random#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/nextbytes1.cpp#5)]
     [!code-csharp[System.Random#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/nextbytes1.cs#5)]
     [!code-vb[System.Random#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/nextbytes1.vb#5)]  
  
-   Un entero único. Puede elegir si desea que un entero entre 0 y el valor máximo (<xref:System.Int32.MaxValue?displayProperty=nameWithType> - 1) mediante una llamada a la <xref:System.Random.Next> método, un número entero entre 0 y un valor específico mediante una llamada a la <xref:System.Random.Next%28System.Int32%29> método o un número entero en un intervalo de valores mediante una llamada a la <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29>método. En las sobrecargas con parámetros, el valor máximo especificado es exclusivo; es decir, el número máximo real generado es uno menos que el valor especificado.  
  
     El ejemplo siguiente se llama el <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29> método para generar 10 números aleatorios entre -10 y 10. Tenga en cuenta que el segundo argumento al método especifica el límite superior exclusivo del intervalo de valores aleatorios devuelto por el método. En otras palabras, el entero más grande que el método puede devolver uno es menor que este valor.  
  
     [!code-cpp[System.Random#6](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/nextex1.cpp#6)]
     [!code-csharp[System.Random#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/nextex1.cs#6)]
     [!code-vb[System.Random#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/nextex1.vb#6)]  
  
-   Único valor de punto flotante entre 0,0 y menor que 1,0 mediante una llamada a la <xref:System.Random.NextDouble%2A> método. Límite superior exclusivo del número aleatorio devuelto por el método es 1, por lo que su límite superior real es 0.99999999999999978. El ejemplo siguiente genera 10 números de punto flotante aleatorios.  
  
     [!code-cpp[System.Random#7](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/nextdoubleex1.cpp#7)]
     [!code-csharp[System.Random#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/nextdoubleex1.cs#7)]
     [!code-vb[System.Random#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/nextdoubleex1.vb#7)]  
  
> [!IMPORTANT]
>  El <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29> método le permite especificar el intervalo del número aleatorio devuelto. Sin embargo, el `maxValue` parámetro, que especifica el intervalo superior devuelve el número, es exclusivo, no un inclusivo valor. Esto significa que la llamada al método `Next(0, 100)` devuelve un valor entre 0 y 99 y no está comprendido entre 0 y 100.  
  
 También puede usar el <xref:System.Random> clase para tareas como la generación de [aleatoria de valores Boolean](#Boolean), generar [los valores de punto flotante aleatorio con un intervalo distinto de 0 a 1](#Floats), generar [enteros de 64 bits aleatorios](#Long), y [aleatoriamente recuperar un único elemento de una matriz o colección](#UniqueArray). Para estas y otras tareas comunes, consulte el [cómo usar System.Random para...](#Operations) sección.  
  
<a name="Overriding"></a>   
## <a name="substituting-your-own-algorithm"></a>Sustituya su propio algoritmo  
 Puede implementar su propio generador de números aleatorios que se herede de la <xref:System.Random> clase y proporcionar el algoritmo de generación de números aleatorios. Para proporcionar su propio algoritmo, se debe reemplazar el <xref:System.Random.Sample%2A> método, que implementa el algoritmo de generación de números aleatorios. También debe reemplazar el <xref:System.Random.Next>, <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29>, y <xref:System.Random.NextBytes%2A> métodos para asegurarse de que llame a su invalidado <xref:System.Random.Sample%2A> método. No tiene que invalidar el <xref:System.Random.Next%28System.Int32%29> y <xref:System.Random.NextDouble%2A> métodos.  
  
 Para obtener un ejemplo que se deriva el <xref:System.Random> clase y modifica su generador de números pseudoaleatorios de forma predeterminada, consulte la <xref:System.Random.Sample%2A> página de referencia.  
  
<a name="Operations"></a>   
## <a name="how-do-you-use-systemrandom-to"></a>¿Cómo usar System.Random para...  
 Las siguientes secciones se describen y proporcionan código de ejemplo para algunas de las formas que desea usar números aleatorios en la aplicación.  
  
<a name="Same"></a>   
### <a name="retrieve-the-same-sequence-of-random-values"></a>Recuperar la misma secuencia de valores aleatorios  
 A veces desea generar la misma secuencia de números aleatorios en escenarios de prueba de software y juegos. Las pruebas con la misma secuencia de números aleatorios permite detectar las regresiones y confirme las correcciones de errores. Uso de la misma secuencia de número aleatorio en juegos le permite reproducir juegos anteriores.  
  
 Puede generar la misma secuencia de números aleatorios, ya que proporciona el mismo valor de inicialización para el <xref:System.Random.%23ctor%28System.Int32%29> constructor. El valor de inicialización, proporciona un valor inicial para el algoritmo de generación de números pseudoaleatorios. En el ejemplo siguiente se usa 100100 como un valor de inicialización arbitrario para crear instancias de la <xref:System.Random> objeto, muestra 20 valores de punto flotante aleatorios y conserva el valor de inicialización. A continuación, restaura el valor de inicialización, crea una instancia de un nuevo generador de números aleatorios y muestra los mismos valores de punto flotante aleatorios 20.  Tenga en cuenta que el ejemplo puede producir distintas secuencias de números aleatorios si se ejecutan en diferentes versiones de .NET Framework.  
  
 [!code-cpp[System.Random#12](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/same1.cpp#12)]
 [!code-csharp[System.Random#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/same1.cs#12)]
 [!code-vb[System.Random#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/same1.vb#12)]  
  
<a name="Unique"></a>   
### <a name="retrieve-unique-sequences-of-random-numbers"></a>Recuperar secuencias únicas de números aleatorios  
 Proporcionar valores de inicialización distintos a las instancias de la <xref:System.Random> clase hace que cada generador de números aleatorios generar una secuencia de valores diferentes. Puede proporcionar un valor de inicialización explícitamente mediante una llamada a la <xref:System.Random.%23ctor%28System.Int32%29> constructor, o implícitamente mediante una llamada a la <xref:System.Random.%23ctor> constructor. La mayoría de los desarrolladores llaman al constructor sin parámetros, que utiliza el reloj del sistema. En el ejemplo siguiente se usa este enfoque para crear dos instancias de <xref:System.Random> instancias. Cada instancia muestra una serie de 10 números enteros aleatorios.  
  
 [!code-cpp[System.Random#13](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/unique.cpp#13)]
 [!code-csharp[System.Random#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/unique.cs#13)]
 [!code-vb[System.Random#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/unique.vb#13)]  
  
 Sin embargo, debido a su resolución finito, el reloj del sistema no detecta las diferencias horarias que son menos de aproximadamente 15 milisegundos. Por lo tanto, si el código llama el <xref:System.Random.%23ctor> sobrecarga al crear una instancia de dos <xref:System.Random> objetos en sucesión, es posible que accidentalmente se proporcionar los objetos con valores de inicialización idénticos. Para ver esto en el ejemplo anterior, marque como comentario el <xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType> llamada al método y la compilación y vuelva a ejecutar el ejemplo.  
  
 Para evitar que esto suceda, se recomienda que cree una instancia de una sola <xref:System.Random> objeto en lugar de varias. Sin embargo, dado que <xref:System.Random> no es seguro para subprocesos, debe usar algún dispositivo de sincronización si tiene acceso a un <xref:System.Random> instancia desde varios subprocesos; para obtener más información, vea [aleatorio de la seguridad de clase y subproceso](#ThreadSafety) anteriormente en este tema. Como alternativa, puede usar un mecanismo de retardo, como el <xref:System.Threading.Thread.Sleep%2A> método utilizado en el ejemplo anterior, para asegurarse de que la creación de instancias produce más de 15 milisegundos de diferencia.  
  
<a name="Range"></a>   
### <a name="retrieve-integers-in-a-specified-range"></a>Recuperar enteros en un intervalo especificado  
 Enteros en un intervalo especificado se pueden recuperar mediante una llamada a la <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29> método, que le permite especificar la parte inferior y el límite superior de los números que desea que el generador de números aleatorios para devolver. El límite superior es exclusivo, no un inclusivo valor. Es decir, no se incluya en el intervalo de valores devueltos por el método. El ejemplo siguiente usa este método para generar enteros aleatorios entre -10 y 10. Tenga en cuenta que especifica 11, que es una unidad mayor que el valor deseado, como el valor de la `maxValue` argumento en la llamada al método.  
  
 [!code-cpp[System.Random#15](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/range1.cpp#15)]
 [!code-csharp[System.Random#15](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/range1.cs#15)]
 [!code-vb[System.Random#15](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/range1.vb#15)]  
  
<a name="Digits"></a>   
### <a name="retrieve-integers-with-a-specified-number-of-digits"></a>Recuperar los enteros con un número especificado de dígitos  
 Puede llamar a la <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29> método para recuperar números con un número especificado de dígitos. Por ejemplo, para recuperar números con cuatro dígitos (es decir, los números comprendidos entre 1000 y 9999), se llama a la <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29> método con un `minValue` valor de 1000 y un `maxValue` valor de 10000, como se muestra en el ejemplo siguiente.  
  
 [!code-cpp[System.Random#16](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/range2.cpp#16)]
 [!code-csharp[System.Random#16](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/range2.cs#16)]
 [!code-vb[System.Random#16](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/range2.vb#16)]  
  
<a name="Floats"></a>   
### <a name="retrieve-floating-point-values-in-a-specified-range"></a>Recuperar valores de punto flotante de un intervalo especificado  
 El <xref:System.Random.NextDouble%2A> método devuelve valores de punto flotante aleatorios comprendidos entre 0 y menor que 1. Sin embargo, a menudo es conveniente generar valores aleatorios en algún otro intervalo.  
  
 Si el intervalo entre los valores mínimos y máximo deseados es 1, puede agregar la diferencia entre el intervalo de inicio deseado y 0 para el número devuelto por la <xref:System.Random.NextDouble%2A> método. El ejemplo siguiente hace esto para generar 10 números aleatorios entre -1 y 0.  
  
 [!code-cpp[System.Random#17](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/doublerange2.cpp#17)]
 [!code-csharp[System.Random#17](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/doublerange2.cs#17)]
 [!code-vb[System.Random#17](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/doublerange2.vb#17)]  
  
 Para generar números de punto flotante aleatorios cuyo límite inferior es 0 pero límite superior es mayor que 1 (o, en el caso de números negativos, cuyo límite inferior es menor que -1 y límite superior es 0), multiplique el número aleatorio por el límite distinto de cero. El ejemplo siguiente hace esto para generar números de punto flotante aleatorios de 20 millones de ese intervalo de 0 a <xref:System.Int64.MaxValue?displayProperty=nameWithType>. También muestra en la distribución de los valores aleatorios generados por el método.  
  
 [!code-cpp[System.Random#18](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/doublerange1.cpp#18)]
 [!code-csharp[System.Random#18](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/doublerange1.cs#18)]
 [!code-vb[System.Random#18](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/doublerange1.vb#18)]  
  
 Para generar números de punto flotante aleatorios entre dos valores arbitrarios, como el <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29> hace el método para números enteros, use la siguiente fórmula:  
  
```csharp  
Random.NextDouble() * (maxValue - minValue) + minValue  
```  
  
 El ejemplo siguiente genera números aleatorios de 1 millón que van desde 10.0 a 11.0 y muestra su distribución.  
  
 [!code-cpp[System.Random#19](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/doublerange3.cpp#19)]
 [!code-csharp[System.Random#19](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/doublerange3.cs#19)]
 [!code-vb[System.Random#19](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/doublerange3.vb#19)]  
  
<a name="Boolean"></a>   
### <a name="generate-random-boolean-values"></a>Generar valores booleanos aleatorios  
 El <xref:System.Random> clase no proporciona métodos que generan <xref:System.Boolean> valores. Sin embargo, puede definir su propia clase o método para hacerlo. En el ejemplo siguiente se define una clase, `BooleanGenerator`, con un único método, `NextBoolean`. El `BooleanGenerator` clase almacena un <xref:System.Random> objeto como una variable privada. El `NextBoolean` llamadas al método el <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29?displayProperty=nameWithType> método y pasa el resultado a la <xref:System.Convert.ToBoolean%28System.Int32%29?displayProperty=nameWithType> método. Tenga en cuenta que 2 se usa como argumento para especificar el límite superior del número aleatorio. Puesto que este es un valor exclusivo, la llamada al método devuelve 0 ó 1.  
  
 [!code-cpp[System.Random#8](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/booleans1.cpp#8)]
 [!code-csharp[System.Random#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/booleans1.cs#8)]
 [!code-vb[System.Random#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/booleans1.vb#8)]  
  
 En lugar de crear una clase independiente para generar aleatorio <xref:System.Boolean> valores, en el ejemplo podrían haber definido simplemente un único método. En ese caso, sin embargo, el <xref:System.Random> objeto debería haberse definido como una variable de nivel de clase para evitar las instancias de un nuevo <xref:System.Random> instancia en cada llamada al método. En Visual Basic, la instancia de Random puede definirse como un [estático](~/docs/visual-basic/language-reference/modifiers/static.md) variable en el `NextBoolean` método.  El ejemplo siguiente proporciona una implementación.  
  
 [!code-cpp[System.Random#20](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/booleans2.cpp#20)]
 [!code-csharp[System.Random#20](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/booleans2.cs#20)]
 [!code-vb[System.Random#20](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/booleans2.vb#20)]  
  
<a name="Long"></a>   
### <a name="generate-random-64-bit-integers"></a>Generar enteros de 64 bits aleatorios  
 Las sobrecargas de los <xref:System.Random.Next%2A> método devuelven enteros de 32 bits. Sin embargo, en algunos casos, es posible que desee trabajar con números enteros de 64 bits. Puede hacerlo de la siguiente manera:  
  
1.  Llame a la <xref:System.Random.NextDouble%2A> valor de punto de método para recuperar un flotante de precisión doble.  
  
2.  Multiplicar ese valor a <xref:System.Int64.MaxValue?displayProperty=nameWithType>.  
  
 El ejemplo siguiente usa esta técnica para generar 20 millones de enteros largos aleatorios y ellos clasifica en 10 grupos de iguales. A continuación, evalúa la distribución de los números aleatorios contando el número de cada grupo de 0 a <xref:System.Int64.MaxValue?displayProperty=nameWithType>. Como se muestra el resultado del ejemplo, los números se distribuyen por más o menos igual a través del intervalo de un entero largo.  
  
 [!code-cpp[System.Random#14](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/long1.cpp#14)]
 [!code-csharp[System.Random#14](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/long1.cs#14)]
 [!code-vb[System.Random#14](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/long1.vb#14)]  
  
 Una técnica alternativa que usa manipulación de bits no genera números aleatorios. Esta técnica se llama <xref:System.Random.Next> para generar dos enteros, uno por 32 izquierda: desplaza los bits y ORs ellos juntos. Esta técnica tiene dos limitaciones:  
  
1.  Dado que el bit 31 es el bit de signo, el valor de bit 31 del entero largo resultante siempre es 0.  Esto puede solucionarse mediante la generación de 31 bits y ORing un aleatorio 0 o 1, desplazamiento hacia la izquierda, con el entero largo aleatorio original.  
  
2.  Más en serio, porque la probabilidad de que el valor devuelto por <xref:System.Random.Next> será 0, habrá algunos si los números aleatorios en el intervalo 0 x 0 0x00000000FFFFFFFF.  
  
<a name="Bytes"></a>   
### <a name="retrieve-bytes-in-a-specified-range"></a>Recuperar bytes en un intervalo especificado  
 Las sobrecargas de los <xref:System.Random.Next%2A> método le permiten especificar el intervalo de números aleatorios, pero la <xref:System.Random.NextBytes%2A> método no lo hace. El ejemplo siguiente implementa un `NextBytes` método que le permite especificar el intervalo de bytes devueltos. Define un `Random2` clase que derive de <xref:System.Random> y overloads su `NextBytes` método.  
  
 [!code-cpp[System.Random#9](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/bytes1.cpp#9)]
 [!code-csharp[System.Random#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/bytes1.cs#9)]
 [!code-vb[System.Random#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/bytes1.vb#9)]  
  
 El `NextBytes(Byte[], Byte, Byte)` método ajusta una llamada a la <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29> método y especifica el valor mínimo y uno mayor que el valor máximo (en este caso, 0 y 101) que desea que se devuelvan en la matriz de bytes. Dado que estamos seguros de que los valores enteros devuelven por la <xref:System.Random.Next%2A> método están dentro del intervalo de la <xref:System.Byte> tipo de datos, podemos sin ningún riesgo a convertirlos (en C#) o convertirlos (en Visual Basic) de enteros a bytes.  
  
<a name="Array"></a>   
### <a name="retrieve-an-element-from-an-array-or-collection-at-random"></a>Recuperar un elemento de una matriz o colección de forma aleatoria  
 Números aleatorios suelen servir de índices para recuperar valores de las matrices o colecciones. Para recuperar un valor de índice aleatorio, puede llamar a la <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29> método y el uso límite inferior de la matriz como el valor de su `minValue` argumento y una unidad mayor que el límite superior de la matriz como el valor de su `maxValue` argumento. Para una matriz de base cero, esto es equivalente a su <xref:System.Array.Length%2A> propiedad o una unidad mayor que el valor devuelto por la <xref:System.Array.GetUpperBound%2A?displayProperty=nameWithType> método. En el ejemplo siguiente se recupera de forma aleatoria el nombre de una ciudad en Estados Unidos desde una matriz de ciudades.  
  
 [!code-cpp[System.Random#10](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/array1.cpp#10)]
 [!code-csharp[System.Random#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/array1.cs#10)]
 [!code-vb[System.Random#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/array1.vb#10)]  
  
<a name="UniqueArray"></a>   
### <a name="retrieve-a-unique-element-from-an-array-or-collection"></a>Recuperar un único elemento de una matriz o colección  
 Un generador de números aleatorios siempre puede devolver valores duplicados. Como el intervalo de números se vuelve más pequeño o el número de valores generados se vuelve mayor, aumenta la probabilidad de duplicados. Si los valores aleatorios deben ser únicos, se generan más números para compensar los duplicados, lo que resulta en un rendimiento deficiente cada vez más.  
  
 Hay una serie de técnicas para controlar este escenario. Una solución habitual consiste en crear una matriz o colección que contiene los valores que se van a recuperar y una matriz paralela que contiene los números de punto flotante aleatorios. La segunda matriz se rellena con números aleatorios en el momento en que se crea la primera matriz, y el <xref:System.Array.Sort%28System.Array%2CSystem.Array%29?displayProperty=nameWithType> método se usa para ordenar la primera matriz con los valores de la matriz en paralelo.  
  
 Por ejemplo, si está desarrollando un juego Solitario, desea asegurarse de que se utiliza una sola vez cada tarjeta. En lugar de generar números aleatorios para recuperar una tarjeta y el seguimiento de si ya ha se ha trabajado esa tarjeta, puede crear una matriz paralela de números aleatorios que se pueden usar para ordenar la baraja. Una vez que se ordena la baraja, la aplicación puede mantener un puntero para indicar el índice de la tarjeta siguiente en la baraja.  
  
 En el ejemplo siguiente se muestra este enfoque. Define un `Card` clase que representa una carta de una baraja y `Dealer` clase que se encarga de una baraja de cartas ordenarse. El `Dealer` constructor de clase rellena dos matrices: una `deck` matriz que tiene ámbito de clase y que representa todas las cartas de la baraja; y una variable local `order` matriz que tiene el mismo número de elementos como el `deck` de matriz y se rellena con generado aleatoriamente <xref:System.Double> valores.  El <xref:System.Array.Sort%28System.Array%2CSystem.Array%29?displayProperty=nameWithType> , a continuación, se llama el método para ordenar el `deck` matriz basándose en los valores en el `order` matriz.  
  
 [!code-cpp[System.Random#11](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/uniquearray1.cpp#11)]
 [!code-csharp[System.Random#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/uniquearray1.cs#11)]
 [!code-vb[System.Random#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/uniquearray1.vb#11)]  
  
   
  
## Examples  
 El ejemplo siguiente crea un único generador de números aleatorios y llama a su <xref:System.Random.NextBytes%2A>, <xref:System.Random.Next%2A>, y <xref:System.Random.NextDouble%2A> métodos para generar secuencias de números aleatorios en intervalos diferentes.  
  
 [!code-cpp[System.Random#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/random2.cpp#2)]
 [!code-csharp[System.Random#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/Random2.cs#2)]
 [!code-vb[System.Random#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/Random2.vb#2)]  
  
 El ejemplo siguiente genera un entero aleatorio que usa como índice para recuperar un valor de cadena de una matriz.  
  
 [!code-cpp[System.Random.Next#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random.Next/CPP/next1.cpp#3)]
 [!code-csharp[System.Random.Next#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random.Next/CS/next1.cs#3)]
 [!code-vb[System.Random.Next#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random.Next/VB/next1.vb#3)]  
  
 ]]></format>
    </remarks>
    <block subset="none" type="overrides"><para>En .NET Framework 1.0 y 1.1, una implementación mínima de una clase derivada de <see cref="T:System.Random" /> necesario reemplazar el <see cref="M:System.Random.Sample" /> método para definir un algoritmo nuevo o modificado para generar números aleatorios. La clase derivada, a continuación, se podría confiar en la implementación de clase base la <see cref="M:System.Random.Next" />, <see cref="M:System.Random.Next(System.Int32)" />, <see cref="M:System.Random.Next(System.Int32,System.Int32)" />, <see cref="M:System.Random.NextBytes(System.Byte[])" />, y <see cref="M:System.Random.NextDouble" /> métodos para llamar a la implementación de la clase derivada de la <see cref="M:System.Random.Sample" /> método.  
  
En .NET Framework 2.0 y versiones posterior, el comportamiento de la <see cref="M:System.Random.Next" />, <see cref="M:System.Random.Next(System.Int32,System.Int32)" />, y <see cref="M:System.Random.NextBytes(System.Byte[])" /> han cambiado los métodos para que estos métodos llamar necesariamente a la implementación de clase derivada de la <see cref="M:System.Random.Sample" /> método. Como resultado, las clases derivadas de <see cref="T:System.Random" /> que tener como destino .NET Framework 2.0 y versiones posteriores también debe reemplazar estos tres métodos.</para></block>
    <block subset="none" type="usage"><para>La implementación del generador de números aleatorios en el <see cref="T:System.Random" /> clase no está garantizado que siguen siendo los mismos en las versiones principales de .NET Framework. Como resultado, no debe asumir que dará como resultado el mismo valor de inicialización en la misma secuencia pseudoaleatoria en diferentes versiones de .NET Framework.</para></block>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Random" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Random ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Random.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Random();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Random" /> mediante un valor de inicialización predeterminado que depende del tiempo.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El valor de inicialización predeterminado se deriva del reloj del sistema y tiene una resolución finita. Como resultado, diferentes <xref:System.Random> objetos que se crean en estrecha sucesión mediante una llamada al constructor predeterminado tendrá los valores de inicialización predeterminados idénticos y, por lo tanto, se producirá conjuntos idénticos de números aleatorios. Este problema puede evitarse mediante el uso de una sola <xref:System.Random> objeto que se va a generar todos los números aleatorios. También puede trabajar a su alrededor modificando el valor de inicialización devuelto por el reloj del sistema y, a continuación, proporcionar explícitamente este nuevo valor de inicialización para el <xref:System.Random.%23ctor%28System.Int32%29> constructor. Para obtener más información, consulte el <xref:System.Random.%23ctor%28System.Int32%29> constructor.  
  
 Llamar a este constructor si desea que el generador de números aleatorios para generar una secuencia aleatoria de números. Para generar una secuencia fija de números aleatorios que serán el mismo para distintos generadores de números aleatorios, llame a la <xref:System.Random.%23ctor%28System.Int32%29> constructor con un valor de inicialización fijo. Esto <xref:System.Random> sobrecarga del constructor se utiliza con frecuencia al probar las aplicaciones que usan números aleatorios.  
  
 Una vez que haya creado la instancia de generador de números aleatorios, llame a individuales <xref:System.Random> métodos, como <xref:System.Random.Next> o <xref:System.Random.NextDouble>, para generar números aleatorios.  
  
   
  
## Examples  
 En el ejemplo siguiente se usa el constructor predeterminado para crear instancias de tres <xref:System.Random> objetos y muestra una secuencia de cinco enteros aleatorios para cada uno. Dado que los dos primeros <xref:System.Random> objetos se crean en estrecha sucesión, sus instancias se crean con los valores de inicialización idénticos según el reloj del sistema y, por lo tanto, generan una secuencia idéntica de números aleatorios. Por otro lado, el constructor predeterminado de la tercera <xref:System.Random> objeto se llama después de un retraso de dos segundos causado por una llamada a la <xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType> método. Dado que esto genera un valor de inicialización distinto para la tercera <xref:System.Random> objeto, genera una secuencia diferente de números aleatorios.  
  
 [!code-csharp[System.Random.Ctor#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random.Ctor/CS/ctor1.cs#2)]
 [!code-vb[System.Random.Ctor#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random.Ctor/VB/ctor1.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Random (int Seed);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 Seed) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Random.#ctor(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (Seed As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Random(int Seed);" />
      <MemberSignature Language="F#" Value="new Random : int -&gt; Random" Usage="new System.Random Seed" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="Seed" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="Seed">Número que se utiliza para calcular el valor inicial de la secuencia de números seudoaleatorios. Si se especifica un número negativo, se utiliza el valor absoluto del número.</param>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Random" /> utilizando el valor de inicialización especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Proporcionar un valor de inicialización idéntico a distintos <xref:System.Random> objetos hace que cada instancia generar secuencias idénticas de números aleatorios. A menudo, esto se hace al probar las aplicaciones que dependen de generadores de números aleatorios.  
  
 Si la aplicación requiere diferentes secuencias de números aleatorios, invoque este constructor varias veces con valores de inicialización distinto. Es una forma de generar un valor de inicialización única para que sea dependiente del tiempo. Por ejemplo, derivar el valor de inicialización del reloj del sistema, como el <xref:System.Random.%23ctor> sobrecarga. Sin embargo, el reloj del sistema podría no tener suficiente resolución para proporcionar las distintas invocaciones de este constructor con un valor de inicialización distinto. Esto da como resultado los generadores de números aleatorios que generan secuencias idénticas de números seudoaleatorios, como se muestra en los dos primeros <xref:System.Random> objetos en el ejemplo siguiente. Para evitar esto, aplique un algoritmo para diferenciar el valor de inicialización en cada invocación o llame a la <xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType> método para asegurarse de que proporciona cada constructor con un valor de inicialización distinto.  
  
 [!code-csharp[System.Random.Ctor#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random.Ctor/CS/ctor4.cs#4)]
 [!code-vb[System.Random.Ctor#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random.Ctor/VB/ctor4.vb#4)]  
  
 Otra opción consiste en crear una instancia de una sola <xref:System.Random> objeto que utilizan para generar todos los números aleatorios en la aplicación. Esto da como resultado un rendimiento ligeramente mejor, puesto que la creación de instancias de un generador de números aleatorios es bastante costosa.  
  
   
  
## Examples  
 En el ejemplo siguiente se crea <xref:System.Random> objetos con el constructor de clase que toma un parámetro de inicialización y genera una secuencia de enteros aleatorios y Double. En el ejemplo se muestra que la misma secuencia se genera cuando el <xref:System.Random> objeto se vuelve a crear con el parámetro de constructor y el valor de inicialización.  
  
 [!code-cpp[System.Random.Ctor#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random.Ctor/CPP/ctor.cpp#1)]
 [!code-csharp[System.Random.Ctor#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random.Ctor/CS/ctor.cs#1)]
 [!code-vb[System.Random.Ctor#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random.Ctor/VB/ctor.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Next">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Devuelve un entero aleatorio.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Next">
      <MemberSignature Language="C#" Value="public virtual int Next ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 Next() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Random.Next" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Next () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int Next();" />
      <MemberSignature Language="F#" Value="abstract member Next : unit -&gt; int&#xA;override this.Next : unit -&gt; int" Usage="random.Next " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Devuelve un entero aleatorio no negativo.</summary>
        <returns>Número entero de 32 bits con signo mayor o igual que 0 y menor que <see cref="F:System.Int32.MaxValue" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Random.Next%2A?displayProperty=nameWithType> genera un número aleatorio cuyo valor oscila entre 0 y menor que <xref:System.Int32.MaxValue?displayProperty=nameWithType>. Para generar un número aleatorio cuyo valor oscila de 0 a un número positivo, use el <xref:System.Random.Next%28System.Int32%29?displayProperty=nameWithType> sobrecarga del método. Para generar un número aleatorio dentro de un intervalo diferente, use el <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29?displayProperty=nameWithType> sobrecarga del método.  
  
   
  
## Examples  
 En el ejemplo siguiente se realiza llamadas repetidas a la <xref:System.Random.Next%2A> método para generar un número específico de números aleatorios que se ha solicitado el usuario. El <xref:System.Console.ReadLine%2A?displayProperty=nameWithType> método se usa para obtener la entrada del cliente.  
  
 [!code-cpp[System.Random.Next#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random.Next/CPP/next3.cpp#5)]
 [!code-csharp[System.Random.Next#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random.Next/CS/next3.cs#5)]
 [!code-vb[System.Random.Next#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random.Next/VB/next3.vb#5)]  
  
 El ejemplo siguiente deriva una clase de <xref:System.Random> para generar una secuencia de números aleatorios cuya distribución difiere de la distribución uniforme generada por el <xref:System.Random.Sample%2A> método de la clase base. Invalida el <xref:System.Random.Sample%2A> método para proporcionar la distribución de números aleatorios e invalida el <xref:System.Random.Next%2A?displayProperty=nameWithType> método que se usará la serie de números aleatorios.  
  
 [!code-cpp[System.Random.Sample#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random.Sample/cpp/sampleex.cpp#1)]
 [!code-csharp[System.Random.Sample#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random.Sample/CS/sample.cs#1)]
 [!code-vb[System.Random.Sample#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random.Sample/VB/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>A partir de .NET Framework versión 2.0, si deriva una clase de <see cref="T:System.Random" /> e invalidar la <see cref="M:System.Random.Sample" /> método, la distribución proporcionada por la implementación de la clase derivada de la <see cref="M:System.Random.Sample" /> método no se utiliza en las llamadas a la clase base implementación de la <see cref="M:System.Random.Next" /> método. En su lugar, devuelve la base de la distribución uniforme <see cref="T:System.Random" /> se utiliza la clase. Este comportamiento mejora el rendimiento general de la <see cref="T:System.Random" /> clase. Para modificar este comportamiento para llamar a la <see cref="M:System.Random.Sample" /> método en la clase derivada, también debe invalidar el <see cref="M:System.Random.Next" /> método.</para></block>
        <altmember cref="T:System.Int32" />
      </Docs>
    </Member>
    <Member MemberName="Next">
      <MemberSignature Language="C#" Value="public virtual int Next (int maxValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 Next(int32 maxValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Random.Next(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Next (maxValue As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int Next(int maxValue);" />
      <MemberSignature Language="F#" Value="abstract member Next : int -&gt; int&#xA;override this.Next : int -&gt; int" Usage="random.Next maxValue" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="maxValue" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="maxValue">Límite superior exclusivo del número aleatorio que se va a generar. <paramref name="maxValue" /> debe ser mayor o igual que 0.</param>
        <summary>Devuelve un entero aleatorio no negativo que es inferior al máximo especificado.</summary>
        <returns>Número entero de 32 bits con signo mayor o igual que 0 y menor que <paramref name="maxValue" />; es decir, dentro del intervalo de valores devueltos se incluye 0, pero no <paramref name="maxValue" />. Pero si <paramref name="maxValue" /> es igual a 0, se devuelve <paramref name="maxValue" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Random.Next%28System.Int32%29> sobrecarga devuelve enteros aleatorios ese intervalo de 0 a `maxValue` - 1. Sin embargo, si `maxValue` es 0, el método devuelve 0.  
  
   
  
## Examples  
 El ejemplo siguiente genera enteros aleatorios con varias sobrecargas de los <xref:System.Random.Next%2A> método.  
  
 [!code-cpp[System.Random.Next#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random.Next/CPP/next.cpp#1)]
 [!code-csharp[System.Random.Next#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random.Next/CS/next.cs#1)]
 [!code-vb[System.Random.Next#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random.Next/VB/next.vb#1)]  
  
 El ejemplo siguiente genera un entero aleatorio que usa como índice para recuperar un valor de cadena de una matriz. Dado que el índice más alto de la matriz es uno menor que su longitud, el valor de la <xref:System.Array.Length%2A?displayProperty=nameWithType> propiedad se proporciona como un el `maxValue` parámetro.  
  
 [!code-cpp[System.Random.Next#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random.Next/CPP/next1.cpp#3)]
 [!code-csharp[System.Random.Next#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random.Next/CS/next1.cs#3)]
 [!code-vb[System.Random.Next#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random.Next/VB/next1.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="maxValue" /> es menor que 0.</exception>
        <altmember cref="T:System.Int32" />
      </Docs>
    </Member>
    <Member MemberName="Next">
      <MemberSignature Language="C#" Value="public virtual int Next (int minValue, int maxValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 Next(int32 minValue, int32 maxValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Random.Next(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Next (minValue As Integer, maxValue As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int Next(int minValue, int maxValue);" />
      <MemberSignature Language="F#" Value="abstract member Next : int * int -&gt; int&#xA;override this.Next : int * int -&gt; int" Usage="random.Next (minValue, maxValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="minValue" Type="System.Int32" />
        <Parameter Name="maxValue" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="minValue">Límite inferior inclusivo del número aleatorio devuelto.</param>
        <param name="maxValue">Límite superior exclusivo del número aleatorio devuelto. <paramref name="maxValue" /> debe ser mayor o igual que <paramref name="minValue" />.</param>
        <summary>Devuelve un entero aleatorio que está dentro de un intervalo especificado.</summary>
        <returns>Número entero de 32 bits con signo mayor o igual que <paramref name="minValue" /> y menor que <paramref name="maxValue" />; es decir, dentro del intervalo de valores devueltos se incluye <paramref name="minValue" /> pero no <paramref name="maxValue" />. Si <paramref name="minValue" /> es igual que <paramref name="maxValue" />, se devuelve <paramref name="minValue" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29> sobrecarga devuelve enteros aleatorios que van desde `minValue` a `maxValue` - 1. Sin embargo, si `maxValue` es igual a `minValue`, el método devuelve `minValue`.  
  
 A diferencia de las demás sobrecargas de los <xref:System.Random.Next%2A> método, que devuelven valores solo no negativo, este método puede devolver un entero aleatorio negativo.  
  
   
  
## Examples  
 En el ejemplo siguiente se usa el <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29?displayProperty=nameWithType> método para generar enteros aleatorios con tres intervalos distintos. Tenga en cuenta que el resultado del ejemplo exacto depende del valor de inicialización proporcionado por el sistema pasando a la <xref:System.Random> constructor de clase.  
  
 [!code-cpp[System.Random.Next#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random.Next/CPP/next2.cpp#2)]
 [!code-csharp[System.Random.Next#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random.Next/CS/Next2.cs#2)]
 [!code-vb[System.Random.Next#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random.Next/VB/next2.vb#2)]  
  
 El ejemplo siguiente genera un entero aleatorio que usa como índice para recuperar un valor de cadena de una matriz. Dado que el índice más alto de la matriz es uno menor que su longitud, el valor de la <xref:System.Array.Length%2A?displayProperty=nameWithType> propiedad se proporciona como un el `maxValue` parámetro.  
  
 [!code-cpp[System.Random.Next#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random.Next/CPP/next4.cpp#4)]
 [!code-csharp[System.Random.Next#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random.Next/CS/next4.cs#4)]
 [!code-vb[System.Random.Next#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random.Next/VB/next4.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="minValue" /> es mayor que <paramref name="maxValue" />.</exception>
        <block subset="none" type="overrides"><para>A partir de .NET Framework versión 2.0, si deriva una clase de <see cref="T:System.Random" /> e invalidar la <see cref="M:System.Random.Sample" /> método, la distribución proporcionada por la implementación de la clase derivada de la <see cref="M:System.Random.Sample" /> método no se utiliza en las llamadas a la clase base implementación de la <see cref="M:System.Random.Next(System.Int32,System.Int32)" /> sobrecarga del método si la diferencia entre el <paramref name="minValue" /> y <paramref name="maxValue" /> parámetros es mayor que <see cref="F:System.Int32.MaxValue" />. En su lugar, devuelve la base de la distribución uniforme <see cref="T:System.Random" /> se utiliza la clase. Este comportamiento mejora el rendimiento general de la <see cref="T:System.Random" /> clase. Para modificar este comportamiento para llamar a la <see cref="M:System.Random.Sample" /> método en la clase derivada, también debe invalidar el <see cref="M:System.Random.Next(System.Int32,System.Int32)" /> sobrecarga del método.</para></block>
        <altmember cref="T:System.Int32" />
      </Docs>
    </Member>
    <Member MemberName="NextBytes">
      <MemberSignature Language="C#" Value="public virtual void NextBytes (byte[] buffer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void NextBytes(unsigned int8[] buffer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Random.NextBytes(System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub NextBytes (buffer As Byte())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void NextBytes(cli::array &lt;System::Byte&gt; ^ buffer);" />
      <MemberSignature Language="F#" Value="abstract member NextBytes : byte[] -&gt; unit&#xA;override this.NextBytes : byte[] -&gt; unit" Usage="random.NextBytes buffer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="buffer">Matriz de bytes que contiene números aleatorios.</param>
        <summary>Rellena con números aleatorios los elementos de una matriz de bytes especificada.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cada elemento de la matriz de bytes se establece en un número aleatorio mayor o igual a 0 y menor o igual que <xref:System.Byte.MaxValue>.  
  
 Por ejemplo, para generar un número aleatorio criptográficamente seguro adecuado para la creación de una contraseña aleatoria, use como un método <xref:System.Security.Cryptography.RNGCryptoServiceProvider.GetBytes%2A?displayProperty=nameWithType>.  
  
   
  
## Examples  
 En el ejemplo siguiente se muestra cómo usar el <xref:System.Random.NextBytes%2A> método para rellenar una matriz de bytes con valores de byte aleatorios.  
  
 [!code-cpp[Classic Random.NextBytes Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Random.NextBytes Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Random.NextBytes Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Random.NextBytes Example/CS/source.cs#1)]
 [!code-vb[Classic Random.NextBytes Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Random.NextBytes Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" /> es <see langword="null" />.</exception>
        <block subset="none" type="overrides"><para>A partir de .NET Framework versión 2.0, si deriva una clase de <see cref="T:System.Random" /> e invalidar la <see cref="M:System.Random.Sample" /> método, la distribución proporcionada por la implementación de la clase derivada de la <see cref="M:System.Random.Sample" /> método no se utiliza en las llamadas a la clase base implementación de la <see cref="M:System.Random.NextBytes(System.Byte[])" /> método. En su lugar, devuelve la base de la distribución uniforme <see cref="T:System.Random" /> se utiliza la clase. Este comportamiento mejora el rendimiento general de la <see cref="T:System.Random" /> clase. Para modificar este comportamiento para llamar a la <see cref="M:System.Random.Sample" /> método en la clase derivada, también debe invalidar el <see cref="M:System.Random.NextBytes(System.Byte[])" /> método.</para></block>
        <altmember cref="T:System.Byte" />
      </Docs>
    </Member>
    <Member MemberName="NextBytes">
      <MemberSignature Language="C#" Value="public virtual void NextBytes (Span&lt;byte&gt; buffer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void NextBytes(valuetype System.Span`1&lt;unsigned int8&gt; buffer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Random.NextBytes(System.Span{System.Byte})" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub NextBytes (buffer As Span(Of Byte))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void NextBytes(Span&lt;System::Byte&gt; buffer);" />
      <MemberSignature Language="F#" Value="abstract member NextBytes : Span&lt;byte&gt; -&gt; unit&#xA;override this.NextBytes : Span&lt;byte&gt; -&gt; unit" Usage="random.NextBytes buffer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Span&lt;System.Byte&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffer">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="NextDouble">
      <MemberSignature Language="C#" Value="public virtual double NextDouble ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance float64 NextDouble() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Random.NextDouble" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function NextDouble () As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual double NextDouble();" />
      <MemberSignature Language="F#" Value="abstract member NextDouble : unit -&gt; double&#xA;override this.NextDouble : unit -&gt; double" Usage="random.NextDouble " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Devuelve un número de punto flotante aleatorio que es mayor o igual que 0,0 y menor que 1,0.</summary>
        <returns>Número de punto flotante de doble precisión que es mayor o igual que 0,0 y menor que 1,0.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El límite superior real del número aleatorio devuelto por este método es 0.99999999999999978.  
  
 Para recuperar valores de punto flotante aleatorios dentro de un intervalo distinto de 0,0 y 1,0, consulte la sección "Recuperar valores de punto flotante de un intervalo especificado" de la <xref:System.Random> tema de la clase.  
  
 Este método es la versión pública del método protegido, <xref:System.Random.Sample%2A>.  
  
   
  
## Examples  
 En el ejemplo siguiente se usa el <xref:System.Random.NextDouble%2A> método para generar secuencias de dobles aleatorios.  
  
 [!code-cpp[System.Random.Ctor#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random.Ctor/CPP/ctor.cpp#1)]
 [!code-csharp[System.Random.Ctor#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random.Ctor/CS/ctor.cs#1)]
 [!code-vb[System.Random.Ctor#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random.Ctor/VB/ctor.vb#1)]  
  
 El ejemplo siguiente se llama el <xref:System.Random.NextDouble%2A> método para generar aleatorio 100 números y muestra la distribución de su frecuencia.  
  
 [!code-csharp[System.Random.NextDouble#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.random.nextdouble/cs/nextdouble1.cs#2)]
 [!code-vb[System.Random.NextDouble#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.random.nextdouble/vb/nextdouble1.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Sample">
      <MemberSignature Language="C#" Value="protected virtual double Sample ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance float64 Sample() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Random.Sample" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function Sample () As Double" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual double Sample();" />
      <MemberSignature Language="F#" Value="abstract member Sample : unit -&gt; double&#xA;override this.Sample : unit -&gt; double" Usage="random.Sample " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Devuelve un número de punto flotante aleatorio entre 0,0 y 1,0.</summary>
        <returns>Número de punto flotante de doble precisión que es mayor o igual que 0,0 y menor que 1,0.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para generar una distribución aleatoria distinta o un principio generador de números aleatorios diferentes, derive una clase de la <xref:System.Random> clase e invalidar el <xref:System.Random.Sample%2A> método.  
  
> [!IMPORTANT]
>  El <xref:System.Random.Sample%2A> método es `protected`, lo que significa que es accesible únicamente dentro de la <xref:System.Random> clase y sus clases derivadas. Para generar un número aleatorio entre 0 y 1 desde un <xref:System.Random> de la instancia, llame a la <xref:System.Random.NextDouble%2A> método.  
  
   
  
## Examples  
 El ejemplo siguiente deriva una clase de <xref:System.Random> e invalida el <xref:System.Random.Sample%2A> método para generar una distribución de números aleatorios. Esta distribución es diferente de la distribución uniforme generada por el <xref:System.Random.Sample%2A> método de la clase base.  
  
 [!code-cpp[System.Random.Sample#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random.Sample/cpp/sampleex.cpp#1)]
 [!code-csharp[System.Random.Sample#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random.Sample/CS/sample.cs#1)]
 [!code-vb[System.Random.Sample#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random.Sample/VB/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>A partir de .NET Framework versión 2.0, si deriva una clase de <see cref="T:System.Random" /> e invalidar la <see cref="M:System.Random.Sample" /> método, la distribución proporcionada por la implementación de la clase derivada de la <see cref="M:System.Random.Sample" /> método no se utiliza en las llamadas a la clase base implementación de los métodos siguientes: 
-   El método <see cref="M:System.Random.NextBytes(System.Byte[])" />.  
  
-   El método <see cref="M:System.Random.Next" />.  
  
-El <see cref="M:System.Random.Next(System.Int32,System.Int32)" /> método, si (<paramref name="maxValue" /> - <paramref name="minValue" />) es mayor que <see cref="F:System.Int32.MaxValue" />.  
  
En su lugar, proporciona la base de la distribución uniforme <see cref="T:System.Random" /> se utiliza la clase. Este comportamiento mejora el rendimiento general de la <see cref="T:System.Random" /> clase. Para modificar este comportamiento para llamar a la implementación de la <see cref="M:System.Random.Sample" /> método en la clase derivada, también debe invalidar el comportamiento de estos tres miembros. En este ejemplo se ilustra.</para></block>
        <altmember cref="M:System.Random.NextDouble" />
      </Docs>
    </Member>
  </Members>
</Type>