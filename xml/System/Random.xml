<Type Name="Random" FullName="System.Random">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="4ad7a7caff000dc43adcd1a90679ce6c6f419bc0" />
    <Meta Name="ms.sourcegitcommit" Value="3907f9a5780957d9c85af2e54c0a5bc2a5bf19ab" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="es-ES" />
    <Meta Name="ms.lasthandoff" Value="06/14/2018" />
    <Meta Name="ms.locfileid" Value="34174131" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class Random" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable beforefieldinit Random extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Random" />
  <TypeSignature Language="VB.NET" Value="Public Class Random" />
  <TypeSignature Language="C++ CLI" Value="public ref class Random" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime.Extensions</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>
      <span data-ttu-id="744ed-101">Representa un generador de números seudoaleatorios, que es un dispositivo que genera una secuencia de números que cumplen determinados requisitos estadísticos de aleatoriedad.</span>
      <span class="sxs-lookup">
        <span data-stu-id="744ed-101">Represents a pseudo-random number generator, which is a device that produces a sequence of numbers that meet certain statistical requirements for randomness.</span>
      </span>
    </summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="744ed-102">Números pseudoaleatorios se eligen con la misma probabilidad en un conjunto finito de números.</span><span class="sxs-lookup"><span data-stu-id="744ed-102">Pseudo-random numbers are chosen with equal probability from a finite set of numbers.</span></span> <span data-ttu-id="744ed-103">Los números elegidos no son completamente aleatorios porque se utiliza un algoritmo matemático para seleccionarlos, pero son lo suficientemente aleatorios por motivos prácticos.</span><span class="sxs-lookup"><span data-stu-id="744ed-103">The chosen numbers are not completely random because a mathematical algorithm is used to select them, but they are sufficiently random for practical purposes.</span></span> <span data-ttu-id="744ed-104">La implementación actual de la <xref:System.Random> clase se basa en una versión modificada del algoritmo en Generador de sustracción de Knuth aleatorio números.</span><span class="sxs-lookup"><span data-stu-id="744ed-104">The current implementation of the <xref:System.Random> class is based on a modified version of Donald E. Knuth's subtractive random number generator algorithm.</span></span> <span data-ttu-id="744ed-105">Para obtener más información, consulte E. D.</span><span class="sxs-lookup"><span data-stu-id="744ed-105">For more information, see D. E.</span></span> <span data-ttu-id="744ed-106">Knuth.</span><span class="sxs-lookup"><span data-stu-id="744ed-106">Knuth.</span></span> <span data-ttu-id="744ed-107">*El arte de la programación de equipos, volumen 2: algoritmos Seminumerical*.</span><span class="sxs-lookup"><span data-stu-id="744ed-107">*The Art of Computer Programming, Volume 2: Seminumerical Algorithms*.</span></span> <span data-ttu-id="744ed-108">Addison-Wesley, lectura, MA, tercera edición, 1997.</span><span class="sxs-lookup"><span data-stu-id="744ed-108">Addison-Wesley, Reading, MA, third edition, 1997.</span></span>  
  
 <span data-ttu-id="744ed-109">Para generar un número aleatorio criptográficamente seguro, por ejemplo, uno que es adecuado para la creación de una contraseña aleatoria, use la <xref:System.Security.Cryptography.RNGCryptoServiceProvider> de clase o derivar una clase de <xref:System.Security.Cryptography.RandomNumberGenerator?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="744ed-109">To generate a cryptographically secure random number, such as one that's suitable for creating a random password, use the <xref:System.Security.Cryptography.RNGCryptoServiceProvider> class or derive a class from <xref:System.Security.Cryptography.RandomNumberGenerator?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="744ed-110">En este tema:</span><span class="sxs-lookup"><span data-stu-id="744ed-110">In this topic:</span></span>  
  
 <span data-ttu-id="744ed-111">[Crear una instancia del generador de números aleatorios](#Instantiate) </span><span class="sxs-lookup"><span data-stu-id="744ed-111">[Instantiating the random number generator](#Instantiate) </span></span>  
 <span data-ttu-id="744ed-112">[Evitar varias instancias](#Multiple) </span><span class="sxs-lookup"><span data-stu-id="744ed-112">[Avoiding multiple instantiations](#Multiple) </span></span>  
 <span data-ttu-id="744ed-113">[La seguridad de clase y el subproceso de System.Random](#ThreadSafety) </span><span class="sxs-lookup"><span data-stu-id="744ed-113">[The System.Random class and thread safety](#ThreadSafety) </span></span>  
 <span data-ttu-id="744ed-114">[Generar diferentes tipos de números aleatorios](#Functionality) </span><span class="sxs-lookup"><span data-stu-id="744ed-114">[Generating different types of random numbers](#Functionality) </span></span>  
 <span data-ttu-id="744ed-115">[Sustituir su propio algoritmo](#Overriding) </span><span class="sxs-lookup"><span data-stu-id="744ed-115">[Substituting your own algorithm](#Overriding) </span></span>  
 <span data-ttu-id="744ed-116">[¿Cómo usa System.Random a...](#Operations) </span><span class="sxs-lookup"><span data-stu-id="744ed-116">[How do you use System.Random to…](#Operations) </span></span>  
 [<span data-ttu-id="744ed-117">Recuperar la misma secuencia de valores aleatorios</span><span class="sxs-lookup"><span data-stu-id="744ed-117">Retrieve the same sequence of random values</span></span>](#Same)  
 [<span data-ttu-id="744ed-118">Recuperar secuencias únicas de valores aleatorios</span><span class="sxs-lookup"><span data-stu-id="744ed-118">Retrieve unique sequences of random values</span></span>](#Unique)  
 [<span data-ttu-id="744ed-119">Recuperar enteros en un intervalo especificado</span><span class="sxs-lookup"><span data-stu-id="744ed-119">Retrieve integers in a specified range</span></span>](#Range)  
 [<span data-ttu-id="744ed-120">Recuperar los enteros con un número especificado de dígitos</span><span class="sxs-lookup"><span data-stu-id="744ed-120">Retrieve integers with a specified number of digits</span></span>](#Digits)  
 [<span data-ttu-id="744ed-121">Recuperar valores de punto flotante en un intervalo especificado</span><span class="sxs-lookup"><span data-stu-id="744ed-121">Retrieve floating-point values in a specified range</span></span>](#Floats)  
 [<span data-ttu-id="744ed-122">Generar valores booleanos aleatorios</span><span class="sxs-lookup"><span data-stu-id="744ed-122">Generate random Boolean values</span></span>](#Boolean)  
 [<span data-ttu-id="744ed-123">Generar números enteros de 64 bits aleatorios</span><span class="sxs-lookup"><span data-stu-id="744ed-123">Generate random 64-bit integers</span></span>](#Long)  
 [<span data-ttu-id="744ed-124">Recuperar los bytes en un intervalo especificado</span><span class="sxs-lookup"><span data-stu-id="744ed-124">Retrieve bytes in a specified range</span></span>](#Bytes)  
 [<span data-ttu-id="744ed-125">Recupera un elemento de una matriz o colección de forma aleatoria</span><span class="sxs-lookup"><span data-stu-id="744ed-125">Retrieve an element from an array or collection at random</span></span>](#Array)  
 [<span data-ttu-id="744ed-126">Recuperar un único elemento de una matriz o colección</span><span class="sxs-lookup"><span data-stu-id="744ed-126">Retrieve a unique element from an array or collection</span></span>](#UniqueArray)  
  
<a name="Instantiate"></a>   
## <a name="instantiating-the-random-number-generator"></a><span data-ttu-id="744ed-127">Crear una instancia del generador de números aleatorios</span><span class="sxs-lookup"><span data-stu-id="744ed-127">Instantiating the random number generator</span></span>  
 <span data-ttu-id="744ed-128">Crear instancias del generador de números aleatorios, proporcionando un valor de inicialización (un valor inicial para el algoritmo de generación de números seudoaleatorios) a un <xref:System.Random.%23ctor%2A> constructor de clase.</span><span class="sxs-lookup"><span data-stu-id="744ed-128">You instantiate the random number generator by providing a seed value (a starting value for the pseudo-random number generation algorithm) to a <xref:System.Random.%23ctor%2A> class constructor.</span></span>  <span data-ttu-id="744ed-129">Puede proporcionar el valor de inicialización explícita o implícitamente:</span><span class="sxs-lookup"><span data-stu-id="744ed-129">You can supply the seed value either explicitly or implicitly:</span></span>  
  
-   <span data-ttu-id="744ed-130">El <xref:System.Random.%23ctor%28System.Int32%29> constructor utiliza un valor de inicialización explícita que suministre.</span><span class="sxs-lookup"><span data-stu-id="744ed-130">The <xref:System.Random.%23ctor%28System.Int32%29> constructor uses an explicit seed value that you supply.</span></span>  
  
-   <span data-ttu-id="744ed-131">El <xref:System.Random.%23ctor> constructor utiliza el reloj del sistema para proporcionar un valor de inicialización.</span><span class="sxs-lookup"><span data-stu-id="744ed-131">The <xref:System.Random.%23ctor> constructor uses the system clock to provide a seed value.</span></span> <span data-ttu-id="744ed-132">Se trata de la manera más común de una instancia del generador de números aleatorios.</span><span class="sxs-lookup"><span data-stu-id="744ed-132">This is the most common way of instantiating the random number generator.</span></span>  
  
 <span data-ttu-id="744ed-133">Si se usa el mismo valor de inicialización para independiente <xref:System.Random> objetos, generará la misma serie de números aleatorios.</span><span class="sxs-lookup"><span data-stu-id="744ed-133">If the same seed is used for separate <xref:System.Random> objects, they will generate the same series of random numbers.</span></span> <span data-ttu-id="744ed-134">Esto puede ser útil para crear un conjunto de pruebas que procesa los valores aleatorios, o para reproducir juegos que derivan sus datos de números aleatorios.</span><span class="sxs-lookup"><span data-stu-id="744ed-134">This can be useful for creating a test suite that processes random values, or for replaying games that derive their data from random numbers.</span></span> <span data-ttu-id="744ed-135">Sin embargo, tenga en cuenta que <xref:System.Random> objetos en procesos que se ejecutan en diferentes versiones de .NET Framework podrían devolver otra serie de números aleatorios, incluso si se crea una instancia con valores de inicialización idénticos.</span><span class="sxs-lookup"><span data-stu-id="744ed-135">However, note that <xref:System.Random> objects in processes running under different versions of the .NET Framework may return different series of random numbers even if they're instantiated with identical seed values.</span></span>  
  
 <span data-ttu-id="744ed-136">Para generar diferentes secuencias de números aleatorios, hacer que el valor de inicialización dependa del tiempo, con lo que se genere una serie diferente con cada nueva instancia de <xref:System.Random>.</span><span class="sxs-lookup"><span data-stu-id="744ed-136">To produce different sequences of random numbers, you can make the seed value time-dependent, thereby producing a different series with each new instance of <xref:System.Random>.</span></span> <span data-ttu-id="744ed-137">Parametrizado <xref:System.Random.%23ctor%28System.Int32%29> constructor puede tomar un <xref:System.Int32> valor depende del número de pasos en la hora actual, mientras que sin parámetros <xref:System.Random.%23ctor> constructor utiliza el reloj del sistema para generar su valor de inicialización.</span><span class="sxs-lookup"><span data-stu-id="744ed-137">The parameterized <xref:System.Random.%23ctor%28System.Int32%29> constructor can take an <xref:System.Int32> value based on the number of ticks in the current time, whereas the parameterless <xref:System.Random.%23ctor> constructor uses the system clock to generate its seed value.</span></span> <span data-ttu-id="744ed-138">Sin embargo, dado que el reloj tiene una resolución finita, utilizando el constructor sin parámetros para crear diferentes <xref:System.Random> objetos en estrecha sucesión crea generadores de números aleatorios que generan secuencias idénticas de números aleatorios.</span><span class="sxs-lookup"><span data-stu-id="744ed-138">However, because the clock has finite resolution, using the parameterless constructor to create different <xref:System.Random> objects in close succession creates random number generators that produce identical sequences of random numbers.</span></span> <span data-ttu-id="744ed-139">En el ejemplo siguiente se muestra cómo dos <xref:System.Random> objetos que se crean instancias en estrecha sucesión generan una serie idéntica de números aleatorios.</span><span class="sxs-lookup"><span data-stu-id="744ed-139">The following example illustrates how two <xref:System.Random> objects that are instantiated in close succession generate an identical series of random numbers.</span></span> <span data-ttu-id="744ed-140">En la mayoría de los sistemas de Windows, <xref:System.Random> objetos creados dentro de 15 milisegundos de otra suelen tener valores de inicialización idénticos.</span><span class="sxs-lookup"><span data-stu-id="744ed-140">On most Windows systems, <xref:System.Random> objects created within 15 milliseconds of one another are likely to have identical seed values.</span></span>  
  
 [!code-cpp[System.Random#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/random1.cpp#1)]
 [!code-csharp[System.Random#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/Random1.cs#1)]
 [!code-vb[System.Random#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/Random1.vb#1)]  
  
 <span data-ttu-id="744ed-141">Para evitar este problema, cree un único <xref:System.Random> objeto en lugar de varios objetos.</span><span class="sxs-lookup"><span data-stu-id="744ed-141">To avoid this problem, create a single <xref:System.Random> object instead of multiple objects.</span></span>  
  
<a name="Multiple"></a>   
## <a name="avoiding-multiple-instantiations"></a><span data-ttu-id="744ed-142">Evitar varias instancias</span><span class="sxs-lookup"><span data-stu-id="744ed-142">Avoiding multiple instantiations</span></span>  
 <span data-ttu-id="744ed-143">Inicializar dos generadores de números aleatorios en un bucle ajustado o en una sucesión rápida crea dos generadores de números aleatorios que pueden generar secuencias idénticas de números aleatorios.</span><span class="sxs-lookup"><span data-stu-id="744ed-143">Initializing two random number generators in a tight loop or in rapid succession creates two random number generators that can produce identical sequences of random numbers.</span></span> <span data-ttu-id="744ed-144">En la mayoría de los casos, esto no es la intención del programador y puede causar problemas de rendimiento, como crear instancias e inicializar un generador de números aleatorios son un proceso relativamente costoso.</span><span class="sxs-lookup"><span data-stu-id="744ed-144">In most cases, this is not the developer's intent and can lead to performance issues, because instantiating and initializing a random number generator is a relatively expensive process.</span></span>  
  
 <span data-ttu-id="744ed-145">Tanto para mejorar el rendimiento y para evitar crear accidentalmente independientes generadores de números aleatorios que generan secuencias numéricas idénticas, le recomendamos que cree uno <xref:System.Random> objeto para generar muchos números aleatorios con el tiempo, en lugar de crear nuevos <xref:System.Random> objetos que se va a generar un número aleatorio.</span><span class="sxs-lookup"><span data-stu-id="744ed-145">Both to improve performance and to avoid inadvertently creating separate random number generators that generate identical numeric sequences, we recommend that you create one <xref:System.Random> object to generate many random numbers over time, instead of creating new <xref:System.Random> objects to generate one random number.</span></span>  
  
 <span data-ttu-id="744ed-146">Sin embargo, la <xref:System.Random> clase no es seguro para subprocesos.</span><span class="sxs-lookup"><span data-stu-id="744ed-146">However, the <xref:System.Random> class isn't thread safe.</span></span> <span data-ttu-id="744ed-147">Si se llama a <xref:System.Random> métodos desde varios subprocesos, siga las instrucciones que se describen en la sección siguiente.</span><span class="sxs-lookup"><span data-stu-id="744ed-147">If you call <xref:System.Random> methods from multiple threads, follow the guidelines discussed in the next section.</span></span>  
  
<a name="ThreadSafety"></a>   
## <a name="the-systemrandom-class-and-thread-safety"></a><span data-ttu-id="744ed-148">La seguridad de clase y el subproceso de System.Random</span><span class="sxs-lookup"><span data-stu-id="744ed-148">The System.Random class and thread safety</span></span>  
 <span data-ttu-id="744ed-149">En lugar de crear instancias individuales <xref:System.Random> objetos, le recomendamos que cree una sola <xref:System.Random> instancia para generar todos los números aleatorios que se necesita la aplicación.</span><span class="sxs-lookup"><span data-stu-id="744ed-149">Instead of instantiating individual <xref:System.Random> objects, we recommend that you create a single <xref:System.Random> instance to generate all the random numbers needed by your app.</span></span> <span data-ttu-id="744ed-150">Sin embargo, <xref:System.Random> objetos no son seguros para subprocesos.</span><span class="sxs-lookup"><span data-stu-id="744ed-150">However, <xref:System.Random> objects are not thread safe.</span></span> <span data-ttu-id="744ed-151">Si su aplicación llama <xref:System.Random> métodos desde varios subprocesos, debe usar un objeto de sincronización para asegurarse de que solo un subproceso puede tener acceso a un generador de números aleatorios cada vez.</span><span class="sxs-lookup"><span data-stu-id="744ed-151">If your app calls <xref:System.Random> methods from multiple threads, you must use a synchronization object to ensure that only one thread can access the random number generator at a time.</span></span> <span data-ttu-id="744ed-152">Si no está seguro de que el <xref:System.Random> se tiene acceso a objetos de una manera segura para subprocesos, las llamadas a métodos que devuelven números aleatorios devuelven 0.</span><span class="sxs-lookup"><span data-stu-id="744ed-152">If you don't ensure that the <xref:System.Random> object is accessed in a thread-safe way, calls to methods that return random numbers return 0.</span></span>  
  
 <span data-ttu-id="744ed-153">En el ejemplo siguiente se usa C# [lock (instrucción)](~/docs/csharp/language-reference/keywords/lock-statement.md) y Visual Basic [SyncLock (instrucción)](~/docs/visual-basic/language-reference/statements/synclock-statement.md) para asegurarse de que un generador de números aleatorios único acceden a 11 subprocesos de manera segura para subprocesos.</span><span class="sxs-lookup"><span data-stu-id="744ed-153">The following example uses the C# [lock Statement](~/docs/csharp/language-reference/keywords/lock-statement.md) and the Visual Basic [SyncLock statement](~/docs/visual-basic/language-reference/statements/synclock-statement.md) to ensure that a single random number generator is accessed by 11 threads in a thread-safe manner.</span></span> <span data-ttu-id="744ed-154">Cada subproceso genera números aleatorios de 2 millones, cuenta el número de números aleatorios generados y calcula su suma y, a continuación, actualiza los totales de todos los subprocesos cuando termina de ejecutarse.</span><span class="sxs-lookup"><span data-stu-id="744ed-154">Each thread generates 2 million random numbers, counts the number of random numbers generated and calculates their sum, and then updates the totals for all threads when it finishes executing.</span></span>  
  
 [!code-cpp[System.Random#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/threadsafeex1.cpp#3)]
 [!code-csharp[System.Random#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/threadsafeex1.cs#3)]
 [!code-vb[System.Random#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/threadsafeex1.vb#3)]  
  
 <span data-ttu-id="744ed-155">En el ejemplo se garantiza la seguridad para subprocesos de las maneras siguientes:</span><span class="sxs-lookup"><span data-stu-id="744ed-155">The example ensures thread-safety in the following ways:</span></span>  
  
-   <span data-ttu-id="744ed-156">El <xref:System.ThreadStaticAttribute> atributo se utiliza para definir variables locales de subproceso que realizan el seguimiento del número total de números aleatorios generados y la suma de cada subproceso.</span><span class="sxs-lookup"><span data-stu-id="744ed-156">The <xref:System.ThreadStaticAttribute> attribute is used to define thread-local variables that track the total number of random numbers generated and their sum for each thread.</span></span>  
  
-   <span data-ttu-id="744ed-157">Un bloqueo (el `lock` instrucción en C# y el `SyncLock` instrucción en Visual Basic) protege el acceso a las variables para el recuento total y la suma de todos los números aleatorios generados en todos los subprocesos.</span><span class="sxs-lookup"><span data-stu-id="744ed-157">A lock (the `lock` statement in C# and the `SyncLock` statement in Visual Basic) protects access to the variables for the total count and sum of all random numbers generated on all threads.</span></span>  
  
-   <span data-ttu-id="744ed-158">Un semáforo (la <xref:System.Threading.CountdownEvent> objeto) se utiliza para garantizar que el subproceso principal se bloquea hasta que todos los demás subprocesos complete la ejecución.</span><span class="sxs-lookup"><span data-stu-id="744ed-158">A semaphore (the <xref:System.Threading.CountdownEvent> object) is used to ensure that the main thread blocks until all other threads complete execution.</span></span>  
  
-   <span data-ttu-id="744ed-159">En el ejemplo se comprueba si se ha dañado el generador de números aleatorios mediante la determinación de si los dos llamadas consecutivas a métodos de generación de números aleatorios devuelven 0.</span><span class="sxs-lookup"><span data-stu-id="744ed-159">The example checks whether the random number generator has become corrupted by determining whether two consecutive calls to random number generation methods return 0.</span></span> <span data-ttu-id="744ed-160">Si se detectan daños, el ejemplo se utiliza la <xref:System.Threading.CancellationTokenSource> objeto para indicar que se deberían cancelar todos los subprocesos.</span><span class="sxs-lookup"><span data-stu-id="744ed-160">If corruption is detected, the example uses the <xref:System.Threading.CancellationTokenSource> object to signal that all threads should be canceled.</span></span>  
  
-   <span data-ttu-id="744ed-161">Antes de generar cada número aleatorio, cada subproceso comprueba el estado de la <xref:System.Threading.CancellationToken> objeto.</span><span class="sxs-lookup"><span data-stu-id="744ed-161">Before generating each random number, each thread checks the state of the <xref:System.Threading.CancellationToken> object.</span></span> <span data-ttu-id="744ed-162">Si se solicita la cancelación, el ejemplo llama el <xref:System.Threading.CancellationToken.ThrowIfCancellationRequested%2A?displayProperty=nameWithType> método pueda cancelar el subproceso.</span><span class="sxs-lookup"><span data-stu-id="744ed-162">If cancellation is requested, the example calls the <xref:System.Threading.CancellationToken.ThrowIfCancellationRequested%2A?displayProperty=nameWithType> method to cancel the thread.</span></span>  
  
 <span data-ttu-id="744ed-163">El ejemplo siguiente es idéntico al primero, salvo que usa un <xref:System.Threading.Tasks.Task> objeto y una expresión lambda en lugar de <xref:System.Threading.Thread> objetos.</span><span class="sxs-lookup"><span data-stu-id="744ed-163">The following example is identical to the first, except that it uses a <xref:System.Threading.Tasks.Task> object and a lambda expression instead of <xref:System.Threading.Thread> objects.</span></span>  
  
 [!code-csharp[System.Random#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/threadsafeex2.cs#4)]
 [!code-vb[System.Random#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/threadsafeex2.vb#4)]  
  
 <span data-ttu-id="744ed-164">Se diferencia del primer ejemplo de las maneras siguientes:</span><span class="sxs-lookup"><span data-stu-id="744ed-164">It differs from the first example in the following ways:</span></span>  
  
-   <span data-ttu-id="744ed-165">Las variables para realizar un seguimiento de la cantidad de números aleatorios generados y la suma de cada tarea son locales a la tarea, así que no hay ninguna necesidad de utilizar el <xref:System.ThreadStaticAttribute> atributo.</span><span class="sxs-lookup"><span data-stu-id="744ed-165">The variables to keep track of the number of random numbers generated and their sum in each task are local to the task, so there is no need to use the <xref:System.ThreadStaticAttribute> attribute.</span></span>  
  
-   <span data-ttu-id="744ed-166">El método estático <xref:System.Threading.Tasks.Task.WaitAll%2A?displayProperty=nameWithType> método se utiliza para garantizar que el subproceso principal no se completa antes de que han terminado de todas las tareas.</span><span class="sxs-lookup"><span data-stu-id="744ed-166">The static <xref:System.Threading.Tasks.Task.WaitAll%2A?displayProperty=nameWithType> method is used to ensure that the main thread doesn't complete before all tasks have finished.</span></span> <span data-ttu-id="744ed-167">No es necesario para la <xref:System.Threading.CountdownEvent> objeto.</span><span class="sxs-lookup"><span data-stu-id="744ed-167">There is no need for the <xref:System.Threading.CountdownEvent> object.</span></span>  
  
-   <span data-ttu-id="744ed-168">La excepción que se produce de cancelación de tareas aparece en el <xref:System.Threading.Tasks.Task.WaitAll%2A?displayProperty=nameWithType> método.</span><span class="sxs-lookup"><span data-stu-id="744ed-168">The exception that results from task cancellation is surfaced in the <xref:System.Threading.Tasks.Task.WaitAll%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="744ed-169">En el ejemplo anterior, se trata por cada subproceso.</span><span class="sxs-lookup"><span data-stu-id="744ed-169">In the previous example, it is handled by each thread.</span></span>  
  
<a name="Functionality"></a>   
## <a name="generating-different-types-of-random-numbers"></a><span data-ttu-id="744ed-170">Generar diferentes tipos de números aleatorios</span><span class="sxs-lookup"><span data-stu-id="744ed-170">Generating different types of random numbers</span></span>  
 <span data-ttu-id="744ed-171">El generador de números aleatorios proporciona métodos que permiten generar los siguientes tipos de números aleatorios:</span><span class="sxs-lookup"><span data-stu-id="744ed-171">The random number generator provides methods that let you generate the following kinds of random numbers:</span></span>  
  
-   <span data-ttu-id="744ed-172">Una serie de <xref:System.Byte> valores.</span><span class="sxs-lookup"><span data-stu-id="744ed-172">A series of <xref:System.Byte> values.</span></span> <span data-ttu-id="744ed-173">Determinar el número de valores de byte al pasar una matriz que se inicializa en el número de elementos que desea que el método para volver a la <xref:System.Random.NextBytes%2A> método.</span><span class="sxs-lookup"><span data-stu-id="744ed-173">You determine the number of byte values by passing an array initialized to the number of elements you want the method to return to the <xref:System.Random.NextBytes%2A> method.</span></span> <span data-ttu-id="744ed-174">El ejemplo siguiente genera 20 bytes.</span><span class="sxs-lookup"><span data-stu-id="744ed-174">The following example generates 20 bytes.</span></span>  
  
     [!code-cpp[System.Random#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/nextbytes1.cpp#5)]
     [!code-csharp[System.Random#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/nextbytes1.cs#5)]
     [!code-vb[System.Random#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/nextbytes1.vb#5)]  
  
-   <span data-ttu-id="744ed-175">Un entero único.</span><span class="sxs-lookup"><span data-stu-id="744ed-175">A single integer.</span></span> <span data-ttu-id="744ed-176">Puede elegir si desea que un entero comprendido entre 0 y el valor máximo (<xref:System.Int32.MaxValue?displayProperty=nameWithType> – 1) mediante una llamada a la <xref:System.Random.Next> /método siguiente, un número entero entre 0 y un valor específico mediante una llamada a la <xref:System.Random.Next%28System.Int32%29> método o un número entero dentro de un intervalo de valores mediante una llamada a la <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29> método.</span><span class="sxs-lookup"><span data-stu-id="744ed-176">You can choose whether you want an integer from 0 to a maximum value (<xref:System.Int32.MaxValue?displayProperty=nameWithType> – 1) by calling the <xref:System.Random.Next> method, an integer between 0 and a specific value by calling the <xref:System.Random.Next%28System.Int32%29> method, or an integer within a range of values by calling the <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29> method.</span></span> <span data-ttu-id="744ed-177">En las sobrecargas con parámetros, el valor máximo especificado es exclusivo; es decir, el número máximo real genera uno menor que el valor especificado.</span><span class="sxs-lookup"><span data-stu-id="744ed-177">In the parameterized overloads, the specified maximum value is exclusive; that is, the actual maximum number generated is one less than the specified value.</span></span>  
  
     <span data-ttu-id="744ed-178">El ejemplo siguiente se llama el <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29> método para generar 10 números aleatorios entre -10 y 10.</span><span class="sxs-lookup"><span data-stu-id="744ed-178">The following example calls the <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29> method to generate 10 random numbers between -10 and 10.</span></span> <span data-ttu-id="744ed-179">Tenga en cuenta que el segundo argumento al método especifica el límite superior exclusivo del intervalo de valores aleatorios devuelto por el método.</span><span class="sxs-lookup"><span data-stu-id="744ed-179">Note that the second argument to the method specifies the exclusive upper bound of the range of random values returned by the method.</span></span> <span data-ttu-id="744ed-180">En otras palabras, el entero más grande que el método puede devolver uno es menor que este valor.</span><span class="sxs-lookup"><span data-stu-id="744ed-180">In other words, the largest integer that the method can return is one less than this value.</span></span>  
  
     [!code-cpp[System.Random#6](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/nextex1.cpp#6)]
     [!code-csharp[System.Random#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/nextex1.cs#6)]
     [!code-vb[System.Random#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/nextex1.vb#6)]  
  
-   <span data-ttu-id="744ed-181">Un único valor de punto flotante comprendido entre 0,0 y menor que 1,0 mediante una llamada a la <xref:System.Random.NextDouble%2A> método.</span><span class="sxs-lookup"><span data-stu-id="744ed-181">A single floating-point value from 0.0 to less than 1.0 by calling the <xref:System.Random.NextDouble%2A> method.</span></span> <span data-ttu-id="744ed-182">El límite superior exclusivo del número aleatorio devuelto por el método es 1, por lo que su límite superior real es 0.99999999999999978.</span><span class="sxs-lookup"><span data-stu-id="744ed-182">The exclusive upper bound of the random number returned by the method is 1, so its actual upper bound is 0.99999999999999978.</span></span> <span data-ttu-id="744ed-183">El ejemplo siguiente genera 10 números de punto flotante aleatorios.</span><span class="sxs-lookup"><span data-stu-id="744ed-183">The following example generates 10 random floating-point numbers.</span></span>  
  
     [!code-cpp[System.Random#7](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/nextdoubleex1.cpp#7)]
     [!code-csharp[System.Random#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/nextdoubleex1.cs#7)]
     [!code-vb[System.Random#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/nextdoubleex1.vb#7)]  
  
> [!IMPORTANT]
>  <span data-ttu-id="744ed-184">El <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29> método le permite especificar el intervalo del número aleatorio devuelto.</span><span class="sxs-lookup"><span data-stu-id="744ed-184">The <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29> method allows you to specify the range of the returned random number.</span></span> <span data-ttu-id="744ed-185">Sin embargo, la `maxValue` parámetro, que especifica el intervalo superior devolver número, es exclusivo, no un inclusive, valor.</span><span class="sxs-lookup"><span data-stu-id="744ed-185">However, the `maxValue` parameter, which specifies the upper range returned number, is an exclusive, not an inclusive, value.</span></span> <span data-ttu-id="744ed-186">Esto significa que la llamada al método `Next(0, 100)` devuelve un valor entre 0 y 99 y no está comprendido entre 0 y 100.</span><span class="sxs-lookup"><span data-stu-id="744ed-186">This means that the method call `Next(0, 100)` returns a value between 0 and 99, and not between 0 and 100.</span></span>  
  
 <span data-ttu-id="744ed-187">También puede usar el <xref:System.Random> clase para realizar tareas tales como la generadora de [valores Boolean aleatorios](#Boolean), generar [los valores de punto flotante aleatorio con un intervalo distinto de 0 a 1](#Floats), generar [enteros de 64 bits aleatorios](#Long), y [aleatoriamente recuperar un único elemento de una matriz o colección](#UniqueArray).</span><span class="sxs-lookup"><span data-stu-id="744ed-187">You can also use the <xref:System.Random> class for such tasks as generating [random T:System.Boolean values](#Boolean), generating [random floating point values with a range other than 0 to 1](#Floats), generating [random 64-bit integers](#Long), and [randomly retrieving a unique element from an array or collection](#UniqueArray).</span></span> <span data-ttu-id="744ed-188">Para estas y otras tareas comunes, vea el [cómo usar System.Random a...](#Operations)</span><span class="sxs-lookup"><span data-stu-id="744ed-188">For these and other common tasks, see the [How do you use System.Random to…](#Operations)</span></span> <span data-ttu-id="744ed-189">sección.</span><span class="sxs-lookup"><span data-stu-id="744ed-189">section.</span></span>  
  
<a name="Overriding"></a>   
## <a name="substituting-your-own-algorithm"></a><span data-ttu-id="744ed-190">Sustituir su propio algoritmo</span><span class="sxs-lookup"><span data-stu-id="744ed-190">Substituting your own algorithm</span></span>  
 <span data-ttu-id="744ed-191">Puede implementar su propio generador de números aleatorios heredando de la <xref:System.Random> clase y proporciona el algoritmo de generación de números aleatorios.</span><span class="sxs-lookup"><span data-stu-id="744ed-191">You can implement your own random number generator by inheriting from the <xref:System.Random> class and supplying your random number generation algorithm.</span></span> <span data-ttu-id="744ed-192">Para proporcionar su propio algoritmo, es necesario reemplazar el <xref:System.Random.Sample%2A> método, que implementa el algoritmo de generación de números aleatorios.</span><span class="sxs-lookup"><span data-stu-id="744ed-192">To supply your own algorithm, you must override the <xref:System.Random.Sample%2A> method, which implements the random number generation algorithm.</span></span> <span data-ttu-id="744ed-193">También debe invalidar el <xref:System.Random.Next>, <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29>, y <xref:System.Random.NextBytes%2A> métodos para asegurarse de que llame a su invalidado <xref:System.Random.Sample%2A> método.</span><span class="sxs-lookup"><span data-stu-id="744ed-193">You should also override the <xref:System.Random.Next>, <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29>, and <xref:System.Random.NextBytes%2A> methods to ensure that they call your overridden <xref:System.Random.Sample%2A> method.</span></span> <span data-ttu-id="744ed-194">No tiene que invalidar el <xref:System.Random.Next%28System.Int32%29> y <xref:System.Random.NextDouble%2A> métodos.</span><span class="sxs-lookup"><span data-stu-id="744ed-194">You don't have to override the <xref:System.Random.Next%28System.Int32%29> and <xref:System.Random.NextDouble%2A> methods.</span></span>  
  
 <span data-ttu-id="744ed-195">Para obtener un ejemplo que se deriva de la <xref:System.Random> clase y se modifica su generador de números seudoaleatorios de manera predeterminada, consulte la <xref:System.Random.Sample%2A> página de referencia.</span><span class="sxs-lookup"><span data-stu-id="744ed-195">For an example that derives from the <xref:System.Random> class and modifies its default pseudo-random number generator, see the <xref:System.Random.Sample%2A> reference page.</span></span>  
  
<a name="Operations"></a>   
## <a name="how-do-you-use-systemrandom-to"></a><span data-ttu-id="744ed-196">¿Cómo usa System.Random a...</span><span class="sxs-lookup"><span data-stu-id="744ed-196">How do you use System.Random to…</span></span>  
 <span data-ttu-id="744ed-197">Las siguientes secciones explican y muestran código de ejemplo para algunas de las formas que desea usar números aleatorios en la aplicación.</span><span class="sxs-lookup"><span data-stu-id="744ed-197">The following sections discuss and provide sample code for some of the ways you might want to use random numbers in your app.</span></span>  
  
<a name="Same"></a>   
### <a name="retrieve-the-same-sequence-of-random-values"></a><span data-ttu-id="744ed-198">Recuperar la misma secuencia de valores aleatorios</span><span class="sxs-lookup"><span data-stu-id="744ed-198">Retrieve the same sequence of random values</span></span>  
 <span data-ttu-id="744ed-199">A veces desea que generen la misma secuencia de números aleatorios en escenarios de prueba de software y juegos.</span><span class="sxs-lookup"><span data-stu-id="744ed-199">Sometimes you want to generate the same sequence of random numbers in software test scenarios and in game playing.</span></span> <span data-ttu-id="744ed-200">Las pruebas con la misma secuencia de números aleatorios permite detectar regresiones y confirmar correcciones de errores.</span><span class="sxs-lookup"><span data-stu-id="744ed-200">Testing with the same sequence of random numbers allows you to detect regressions and confirm bug fixes.</span></span> <span data-ttu-id="744ed-201">Usar la misma secuencia de número aleatorio en juegos, podrá reproducir juegos anteriores.</span><span class="sxs-lookup"><span data-stu-id="744ed-201">Using the same sequence of random number in games allows you to replay previous games.</span></span>  
  
 <span data-ttu-id="744ed-202">Puede generar la misma secuencia de números aleatorios proporcionando el mismo valor de inicialización para el <xref:System.Random.%23ctor%28System.Int32%29> constructor.</span><span class="sxs-lookup"><span data-stu-id="744ed-202">You can generate the same sequence of random numbers by providing the same seed value to the <xref:System.Random.%23ctor%28System.Int32%29> constructor.</span></span> <span data-ttu-id="744ed-203">El valor de inicialización, proporciona un valor inicial para el algoritmo de generación de números seudoaleatorios.</span><span class="sxs-lookup"><span data-stu-id="744ed-203">The seed value provides a starting value for the pseudo-random number generation algorithm.</span></span> <span data-ttu-id="744ed-204">En el ejemplo siguiente se utiliza 100100 como un valor de inicialización arbitrario para crear instancias de la <xref:System.Random> objeto, muestra 20 valores de punto flotante aleatorios y conserva el valor de inicialización.</span><span class="sxs-lookup"><span data-stu-id="744ed-204">The following example uses 100100 as an arbitrary seed value to instantiate the <xref:System.Random> object, displays 20 random floating-point values, and persists the seed value.</span></span> <span data-ttu-id="744ed-205">A continuación, se restaura el valor de inicialización, crea un nuevo generador de números aleatorios y muestra los mismos valores de punto flotante aleatorios 20.</span><span class="sxs-lookup"><span data-stu-id="744ed-205">It then restores the seed value, instantiates a new random number generator, and displays the same 20 random floating-point values.</span></span>  <span data-ttu-id="744ed-206">Tenga en cuenta que el ejemplo puede producir diferentes secuencias de números aleatorios si se ejecutan en diferentes versiones de .NET Framework.</span><span class="sxs-lookup"><span data-stu-id="744ed-206">Note that the example may produce different sequences of random numbers if run on different versions of the .NET Framework.</span></span>  
  
 [!code-cpp[System.Random#12](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/same1.cpp#12)]
 [!code-csharp[System.Random#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/same1.cs#12)]
 [!code-vb[System.Random#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/same1.vb#12)]  
  
<a name="Unique"></a>   
### <a name="retrieve-unique-sequences-of-random-numbers"></a><span data-ttu-id="744ed-207">Recuperar secuencias únicas de números aleatorios</span><span class="sxs-lookup"><span data-stu-id="744ed-207">Retrieve unique sequences of random numbers</span></span>  
 <span data-ttu-id="744ed-208">Proporcionar valores de inicialización distintos para instancias de la <xref:System.Random> clase provoca cada generador de números aleatorios generar una secuencia de valores diferentes.</span><span class="sxs-lookup"><span data-stu-id="744ed-208">Providing different seed values to instances of the <xref:System.Random> class causes each random number generator to produce a different sequence of values.</span></span> <span data-ttu-id="744ed-209">Puede proporcionar un valor de inicialización explícitamente mediante una llamada a la <xref:System.Random.%23ctor%28System.Int32%29> constructor, o implícitamente mediante una llamada a la <xref:System.Random.%23ctor> constructor.</span><span class="sxs-lookup"><span data-stu-id="744ed-209">You can provide a seed value either explicitly by calling the <xref:System.Random.%23ctor%28System.Int32%29> constructor, or implicitly by calling the <xref:System.Random.%23ctor> constructor.</span></span> <span data-ttu-id="744ed-210">Mayoría de los desarrolladores llama al constructor sin parámetros, que utiliza el reloj del sistema.</span><span class="sxs-lookup"><span data-stu-id="744ed-210">Most developers call the parameterless constructor, which uses the system clock.</span></span> <span data-ttu-id="744ed-211">En el ejemplo siguiente se usa este enfoque para crear instancias de dos <xref:System.Random> instancias.</span><span class="sxs-lookup"><span data-stu-id="744ed-211">The following example uses this approach to instantiate two <xref:System.Random> instances.</span></span> <span data-ttu-id="744ed-212">Cada instancia muestra una serie de 10 números enteros aleatorios.</span><span class="sxs-lookup"><span data-stu-id="744ed-212">Each instance displays a series of 10 random integers.</span></span>  
  
 [!code-cpp[System.Random#13](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/unique.cpp#13)]
 [!code-csharp[System.Random#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/unique.cs#13)]
 [!code-vb[System.Random#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/unique.vb#13)]  
  
 <span data-ttu-id="744ed-213">Sin embargo, debido a su resolución finito, el reloj del sistema no detecta las diferencias de tiempo que son menos de aproximadamente 15 milisegundos.</span><span class="sxs-lookup"><span data-stu-id="744ed-213">However, because of its finite resolution, the system clock doesn't detect time differences that are less than approximately 15 milliseconds.</span></span> <span data-ttu-id="744ed-214">Por lo tanto, si el código llama el <xref:System.Random.%23ctor> sobrecarga al crear una instancia de dos <xref:System.Random> objetos en sucesión, podría sin darse cuenta debe estar proporcionando los objetos con valores de inicialización idénticos.</span><span class="sxs-lookup"><span data-stu-id="744ed-214">Therefore, if your code calls the <xref:System.Random.%23ctor> overload to instantiate two <xref:System.Random> objects in succession, you might inadvertently be providing the objects with identical seed values.</span></span> <span data-ttu-id="744ed-215">Para ver esto en el ejemplo anterior, comente la <xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType> llamada al método y la compilación y vuelva a ejecutar el ejemplo.</span><span class="sxs-lookup"><span data-stu-id="744ed-215">To see this in the previous example, comment out the <xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType> method call, and compile and run the example again.</span></span>  
  
 <span data-ttu-id="744ed-216">Para evitar que esto suceda, se recomienda que cree instancias de una sola <xref:System.Random> objeto en lugar de varias.</span><span class="sxs-lookup"><span data-stu-id="744ed-216">To prevent this from happening, we recommend that you instantiate a single <xref:System.Random> object rather than multiple ones.</span></span> <span data-ttu-id="744ed-217">Sin embargo, puesto que <xref:System.Random> no subprocesos, debe utilizar algún dispositivo de sincronización si tiene acceso a un <xref:System.Random> instancia desde varios subprocesos; para obtener más información, vea [aleatorio de la seguridad de clase y el subproceso](#ThreadSafety) anteriormente en este tema.</span><span class="sxs-lookup"><span data-stu-id="744ed-217">However, since <xref:System.Random> isn't thread safe, you must use some synchronization device if you access a <xref:System.Random> instance from multiple threads; for more information, see [The Random class and thread safety](#ThreadSafety) earlier in this topic.</span></span> <span data-ttu-id="744ed-218">Como alternativa, puede usar un mecanismo de retardo, como el <xref:System.Threading.Thread.Sleep%2A> método utilizado en el ejemplo anterior, para asegurarse de que la creación de instancias realizan más de 15 milisegundos separadas.</span><span class="sxs-lookup"><span data-stu-id="744ed-218">Alternately, you can use a delay mechanism, such as the <xref:System.Threading.Thread.Sleep%2A> method used in the previous example, to ensure that the instantiations occur more than 15 millisecond apart.</span></span>  
  
<a name="Range"></a>   
### <a name="retrieve-integers-in-a-specified-range"></a><span data-ttu-id="744ed-219">Recuperar enteros en un intervalo especificado</span><span class="sxs-lookup"><span data-stu-id="744ed-219">Retrieve integers in a specified range</span></span>  
 <span data-ttu-id="744ed-220">Enteros en un intervalo especificado se pueden recuperar llamando el <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29> método, que le permite especificar la parte inferior y el límite superior de los números que desea que el generador de números aleatorios para devolver.</span><span class="sxs-lookup"><span data-stu-id="744ed-220">You can retrieve integers in a specified range by calling the <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29> method, which lets you specify both the lower and the upper bound of the numbers you'd like the random number generator to return.</span></span> <span data-ttu-id="744ed-221">El límite superior es exclusivo, no un inclusive, valor.</span><span class="sxs-lookup"><span data-stu-id="744ed-221">The upper bound is an exclusive, not an inclusive, value.</span></span> <span data-ttu-id="744ed-222">Es decir, no se incluye, en el intervalo de valores devueltos por el método.</span><span class="sxs-lookup"><span data-stu-id="744ed-222">That is, it isn't included in the range of values returned by the method.</span></span> <span data-ttu-id="744ed-223">En el ejemplo siguiente se usa este método para generar números enteros aleatorios entre -10 y 10.</span><span class="sxs-lookup"><span data-stu-id="744ed-223">The following example uses this method to generate random integers between -10 and 10.</span></span> <span data-ttu-id="744ed-224">Tenga en cuenta que especifica 11, que es una unidad mayor que el valor deseado, como el valor de la `maxValue` argumento en la llamada al método.</span><span class="sxs-lookup"><span data-stu-id="744ed-224">Note that it specifies 11, which is one greater than the desired value, as the value of the `maxValue` argument in the method call.</span></span>  
  
 [!code-cpp[System.Random#15](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/range1.cpp#15)]
 [!code-csharp[System.Random#15](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/range1.cs#15)]
 [!code-vb[System.Random#15](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/range1.vb#15)]  
  
<a name="Digits"></a>   
### <a name="retrieve-integers-with-a-specified-number-of-digits"></a><span data-ttu-id="744ed-225">Recuperar los enteros con un número especificado de dígitos</span><span class="sxs-lookup"><span data-stu-id="744ed-225">Retrieve integers with a specified number of digits</span></span>  
 <span data-ttu-id="744ed-226">Puede llamar a la <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29> método para recuperar los números con un número especificado de dígitos.</span><span class="sxs-lookup"><span data-stu-id="744ed-226">You can call the <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29> method to retrieve numbers with a specified number of digits.</span></span> <span data-ttu-id="744ed-227">Por ejemplo, para recuperar los números con cuatro dígitos (es decir, los números comprendidos entre 1000 y 9999), se llama a la <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29> método con un `minValue` valor de 1000 y un `maxValue` valor de 10000, como se muestra en el ejemplo siguiente.</span><span class="sxs-lookup"><span data-stu-id="744ed-227">For example, to retrieve numbers with four digits (that is, numbers that range from 1000 to 9999), you call the <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29> method with a `minValue` value of 1000 and a `maxValue` value of 10000, as the following example shows.</span></span>  
  
 [!code-cpp[System.Random#16](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/range2.cpp#16)]
 [!code-csharp[System.Random#16](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/range2.cs#16)]
 [!code-vb[System.Random#16](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/range2.vb#16)]  
  
<a name="Floats"></a>   
### <a name="retrieve-floating-point-values-in-a-specified-range"></a><span data-ttu-id="744ed-228">Recuperar valores de punto flotante en un intervalo especificado</span><span class="sxs-lookup"><span data-stu-id="744ed-228">Retrieve floating-point values in a specified range</span></span>  
 <span data-ttu-id="744ed-229">El <xref:System.Random.NextDouble%2A> método devuelve valores de punto flotante aleatorios ese intervalo entre 0 y menor que 1.</span><span class="sxs-lookup"><span data-stu-id="744ed-229">The <xref:System.Random.NextDouble%2A> method returns random floating-point values that range from 0 to less than 1.</span></span> <span data-ttu-id="744ed-230">Sin embargo, a menudo deseará generar valores aleatorios en algún otro intervalo.</span><span class="sxs-lookup"><span data-stu-id="744ed-230">However, you'll often want to generate random values in some other range.</span></span>  
  
 <span data-ttu-id="744ed-231">Si el intervalo entre los valores mínimos y máximo deseados es 1, puede agregar la diferencia entre el intervalo de inicio deseado y 0 para el número devuelto por la <xref:System.Random.NextDouble%2A> método.</span><span class="sxs-lookup"><span data-stu-id="744ed-231">If the interval between the minimum and maximum desired values is 1, you can add the difference between the desired starting interval and 0 to the number returned by the <xref:System.Random.NextDouble%2A> method.</span></span> <span data-ttu-id="744ed-232">En el ejemplo siguiente se realiza para generar 10 números aleatorios entre -1 y 0.</span><span class="sxs-lookup"><span data-stu-id="744ed-232">The following example does this to generate 10 random numbers between -1 and 0.</span></span>  
  
 [!code-cpp[System.Random#17](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/doublerange2.cpp#17)]
 [!code-csharp[System.Random#17](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/doublerange2.cs#17)]
 [!code-vb[System.Random#17](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/doublerange2.vb#17)]  
  
 <span data-ttu-id="744ed-233">Para generar números de punto flotante aleatorios cuyo límite inferior es 0, pero el límite superior es mayor que 1 (o, en el caso de los números negativos, cuyo límite inferior es menor que -1 y límite superior es 0), multiplique el número aleatorio por el límite distinto de cero.</span><span class="sxs-lookup"><span data-stu-id="744ed-233">To generate random floating-point numbers whose lower bound is 0 but upper bound is greater than 1 (or, in the case of negative numbers, whose lower bound is less than -1 and upper bound is 0), multiply the random number by the non-zero bound.</span></span> <span data-ttu-id="744ed-234">En el ejemplo siguiente se realiza esto para generar números de punto flotante aleatorios de 20 millones de ese intervalo de 0 a <xref:System.Int64.MaxValue?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="744ed-234">The following example does this to generate 20 million random floating-point numbers that range from 0 to <xref:System.Int64.MaxValue?displayProperty=nameWithType>.</span></span> <span data-ttu-id="744ed-235">En también muestra la distribución de los valores aleatorios generados por el método.</span><span class="sxs-lookup"><span data-stu-id="744ed-235">In also displays the distribution of the random values generated by the method.</span></span>  
  
 [!code-cpp[System.Random#18](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/doublerange1.cpp#18)]
 [!code-csharp[System.Random#18](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/doublerange1.cs#18)]
 [!code-vb[System.Random#18](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/doublerange1.vb#18)]  
  
 <span data-ttu-id="744ed-236">Para generar números de punto flotante aleatorios entre dos valores arbitrarios, como el <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29> hace el método para números enteros, use la siguiente fórmula:</span><span class="sxs-lookup"><span data-stu-id="744ed-236">To generate random floating-point numbers between two arbitrary values, like the <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29> method does for integers, use the following formula:</span></span>  
  
```csharp  
Random.NextDouble() * (maxValue – minValue) + minValue  
```  
  
 <span data-ttu-id="744ed-237">En el ejemplo siguiente se genera números aleatorios de 1 millón que van desde 10.0 a 11.0 y muestra su distribución.</span><span class="sxs-lookup"><span data-stu-id="744ed-237">The following example generates 1 million random numbers that range from 10.0 to 11.0, and displays their distribution.</span></span>  
  
 [!code-cpp[System.Random#19](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/doublerange3.cpp#19)]
 [!code-csharp[System.Random#19](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/doublerange3.cs#19)]
 [!code-vb[System.Random#19](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/doublerange3.vb#19)]  
  
<a name="Boolean"></a>   
### <a name="generate-random-boolean-values"></a><span data-ttu-id="744ed-238">Generar valores booleanos aleatorios</span><span class="sxs-lookup"><span data-stu-id="744ed-238">Generate random Boolean values</span></span>  
 <span data-ttu-id="744ed-239">El <xref:System.Random> clase no proporciona métodos que generan <xref:System.Boolean> valores.</span><span class="sxs-lookup"><span data-stu-id="744ed-239">The <xref:System.Random> class doesn't provide methods that generate <xref:System.Boolean> values.</span></span> <span data-ttu-id="744ed-240">Sin embargo, puede definir su propia clase o método para hacerlo.</span><span class="sxs-lookup"><span data-stu-id="744ed-240">However, you can define your own class or method to do that.</span></span> <span data-ttu-id="744ed-241">En el ejemplo siguiente se define una clase, `BooleanGenerator`, con un único método, `NextBoolean`.</span><span class="sxs-lookup"><span data-stu-id="744ed-241">The following example defines a class, `BooleanGenerator`, with a single method, `NextBoolean`.</span></span> <span data-ttu-id="744ed-242">El `BooleanGenerator` clase almacena un <xref:System.Random> objeto como una variable privada.</span><span class="sxs-lookup"><span data-stu-id="744ed-242">The `BooleanGenerator` class stores a <xref:System.Random> object as a private variable.</span></span> <span data-ttu-id="744ed-243">El `NextBoolean` llamadas al método el <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29?displayProperty=nameWithType> método y pasa el resultado a la <xref:System.Convert.ToBoolean%28System.Int32%29?displayProperty=nameWithType> método.</span><span class="sxs-lookup"><span data-stu-id="744ed-243">The `NextBoolean` method calls the <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29?displayProperty=nameWithType> method and passes the result to the <xref:System.Convert.ToBoolean%28System.Int32%29?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="744ed-244">Tenga en cuenta que 2 se usa como argumento para especificar el límite superior del número aleatorio.</span><span class="sxs-lookup"><span data-stu-id="744ed-244">Note that 2 is used as the argument to specify the upper bound of the random number.</span></span> <span data-ttu-id="744ed-245">Puesto que se trata de un valor exclusivo, la llamada al método devuelve 0 ó 1.</span><span class="sxs-lookup"><span data-stu-id="744ed-245">Since this is an exclusive value, the method call returns either 0 or 1.</span></span>  
  
 [!code-cpp[System.Random#8](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/booleans1.cpp#8)]
 [!code-csharp[System.Random#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/booleans1.cs#8)]
 [!code-vb[System.Random#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/booleans1.vb#8)]  
  
 <span data-ttu-id="744ed-246">En lugar de crear una clase independiente para generar aleatorio <xref:System.Boolean> valores, en el ejemplo pudieron haber definido simplemente un único método.</span><span class="sxs-lookup"><span data-stu-id="744ed-246">Instead of creating a separate class to generate random <xref:System.Boolean> values, the example could simply have defined a single method.</span></span> <span data-ttu-id="744ed-247">En ese caso, sin embargo, el <xref:System.Random> objeto debería haberse definido como una variable de nivel de clase para evitar crear instancias de un nuevo <xref:System.Random> instancia en cada llamada al método.</span><span class="sxs-lookup"><span data-stu-id="744ed-247">In that case, however, the <xref:System.Random> object should have been defined as a class-level variable to avoid instantiating a new <xref:System.Random> instance in each method call.</span></span> <span data-ttu-id="744ed-248">En Visual Basic, la instancia de Random puede definirse como un [estático](~/docs/visual-basic/language-reference/modifiers/static.md) variable en el `NextBoolean` método.</span><span class="sxs-lookup"><span data-stu-id="744ed-248">In Visual Basic, the Random instance can be defined as a [Static](~/docs/visual-basic/language-reference/modifiers/static.md) variable in the `NextBoolean` method.</span></span>  <span data-ttu-id="744ed-249">En el ejemplo siguiente se proporciona una implementación.</span><span class="sxs-lookup"><span data-stu-id="744ed-249">The following example provides an implementation.</span></span>  
  
 [!code-cpp[System.Random#20](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/booleans2.cpp#20)]
 [!code-csharp[System.Random#20](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/booleans2.cs#20)]
 [!code-vb[System.Random#20](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/booleans2.vb#20)]  
  
<a name="Long"></a>   
### <a name="generate-random-64-bit-integers"></a><span data-ttu-id="744ed-250">Generar números enteros de 64 bits aleatorios</span><span class="sxs-lookup"><span data-stu-id="744ed-250">Generate random 64-bit integers</span></span>  
 <span data-ttu-id="744ed-251">Las sobrecargas de los <xref:System.Random.Next%2A> método devuelven enteros de 32 bits.</span><span class="sxs-lookup"><span data-stu-id="744ed-251">The overloads of the <xref:System.Random.Next%2A> method return 32-bit integers.</span></span> <span data-ttu-id="744ed-252">Sin embargo, en algunos casos, puede trabajar con números enteros de 64 bits.</span><span class="sxs-lookup"><span data-stu-id="744ed-252">However, in some cases, you might want to work with 64-bit integers.</span></span> <span data-ttu-id="744ed-253">Puede hacerlo de la siguiente manera:</span><span class="sxs-lookup"><span data-stu-id="744ed-253">You can do this as follows:</span></span>  
  
1.  <span data-ttu-id="744ed-254">Llame a la <xref:System.Random.NextDouble%2A> valor de punto de método para recuperar un flotante de precisión doble.</span><span class="sxs-lookup"><span data-stu-id="744ed-254">Call the <xref:System.Random.NextDouble%2A> method to retrieve a double-precision floating point value.</span></span>  
  
2.  <span data-ttu-id="744ed-255">Multiplica ese valor por <xref:System.Int64.MaxValue?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="744ed-255">Multiply that value by <xref:System.Int64.MaxValue?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="744ed-256">En el ejemplo siguiente se utiliza esta técnica para generar enteros largos aleatorios de 20 millones y clasifica en 10 grupos iguales.</span><span class="sxs-lookup"><span data-stu-id="744ed-256">The following example uses this technique to generate 20 million random long integers and categorizes them in 10 equal groups.</span></span> <span data-ttu-id="744ed-257">A continuación, evalúa la distribución de los números aleatorios contando el número de cada grupo de 0 a <xref:System.Int64.MaxValue?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="744ed-257">It then evaluates the distribution of the random numbers by counting the number in each group from 0 to <xref:System.Int64.MaxValue?displayProperty=nameWithType>.</span></span> <span data-ttu-id="744ed-258">Como se muestra en el resultado del ejemplo, los números se distribuyen más o menos igual a lo largo del intervalo de un entero largo.</span><span class="sxs-lookup"><span data-stu-id="744ed-258">As the output from the example shows, the numbers are distributed more or less equally through the range of a long integer.</span></span>  
  
 [!code-cpp[System.Random#14](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/long1.cpp#14)]
 [!code-csharp[System.Random#14](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/long1.cs#14)]
 [!code-vb[System.Random#14](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/long1.vb#14)]  
  
 <span data-ttu-id="744ed-259">Una técnica alternativa que usa bits manipulación no genera números aleatorios realmente.</span><span class="sxs-lookup"><span data-stu-id="744ed-259">An alternative technique that uses bit manipulation does not generate truly random numbers.</span></span> <span data-ttu-id="744ed-260">Esta técnica llama <xref:System.Random.Next> para generar dos números enteros, uno por 32 izquierda-desplaza los bits y OR ellos juntos.</span><span class="sxs-lookup"><span data-stu-id="744ed-260">This technique calls <xref:System.Random.Next> to generate two integers, left-shifts one by 32 bits, and ORs them together.</span></span> <span data-ttu-id="744ed-261">Esta técnica tiene dos limitaciones:</span><span class="sxs-lookup"><span data-stu-id="744ed-261">This technique has two limitations:</span></span>  
  
1.  <span data-ttu-id="744ed-262">Dado que el bit 31 es el bit de signo, el valor de bit 31 del entero largo resultante siempre es 0.</span><span class="sxs-lookup"><span data-stu-id="744ed-262">Because bit 31 is the sign bit, the value in bit 31 of the resulting long integer is always 0.</span></span>  <span data-ttu-id="744ed-263">Esto puede solucionarse generando un aleatorio 0 ó 1, desplazamiento hacia la izquierda, 31 bits y operaciones OR con entero largo aleatorio original.</span><span class="sxs-lookup"><span data-stu-id="744ed-263">This can be addressed by generating a random 0 or 1, left-shifting it 31 bits, and ORing it with the original random long integer.</span></span>  
  
2.  <span data-ttu-id="744ed-264">Más en serio, porque la probabilidad de que el valor devuelto por <xref:System.Random.Next> será 0, habrá pocos si los números aleatorios en el intervalo 0 x 0-0x00000000FFFFFFFF.</span><span class="sxs-lookup"><span data-stu-id="744ed-264">More seriously, because the probability that the value returned by <xref:System.Random.Next> will be 0, there will be few if any random numbers in the range 0x0-0x00000000FFFFFFFF.</span></span>  
  
<a name="Bytes"></a>   
### <a name="retrieve-bytes-in-a-specified-range"></a><span data-ttu-id="744ed-265">Recuperar los bytes en un intervalo especificado</span><span class="sxs-lookup"><span data-stu-id="744ed-265">Retrieve bytes in a specified range</span></span>  
 <span data-ttu-id="744ed-266">Las sobrecargas de la <xref:System.Random.Next%2A> método le permiten especificar el intervalo de números aleatorios, pero la <xref:System.Random.NextBytes%2A> método no lo hace.</span><span class="sxs-lookup"><span data-stu-id="744ed-266">The overloads of the <xref:System.Random.Next%2A> method allow you to specify the range of random numbers, but the <xref:System.Random.NextBytes%2A> method does not.</span></span> <span data-ttu-id="744ed-267">En el ejemplo siguiente se implementa un `NextBytes` método que le permite especificar el intervalo de bytes devueltas.</span><span class="sxs-lookup"><span data-stu-id="744ed-267">The following example implements a `NextBytes` method that lets you specify the range of the returned bytes.</span></span> <span data-ttu-id="744ed-268">Define un `Random2` clase que deriva de <xref:System.Random> y overloads su `NextBytes` método.</span><span class="sxs-lookup"><span data-stu-id="744ed-268">It defines a `Random2` class that derives from <xref:System.Random> and overloads its `NextBytes` method.</span></span>  
  
 [!code-cpp[System.Random#9](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/bytes1.cpp#9)]
 [!code-csharp[System.Random#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/bytes1.cs#9)]
 [!code-vb[System.Random#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/bytes1.vb#9)]  
  
 <span data-ttu-id="744ed-269">El `NextBytes(Byte[], Byte, Byte)` método contiene una llamada a la <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29> método y especifica el valor mínimo y uno mayor que el valor máximo (en este caso, 0 y 101) que desea que se devuelvan en la matriz de bytes.</span><span class="sxs-lookup"><span data-stu-id="744ed-269">The `NextBytes(Byte[], Byte, Byte)` method wraps a call to the <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29> method and specifies the minimum value and one greater than the maximum value (in this case, 0 and 101) that we want returned in the byte array.</span></span> <span data-ttu-id="744ed-270">Porque se está seguro de que los valores enteros devuelven por la <xref:System.Random.Next%2A> método están dentro del intervalo de la <xref:System.Byte> tipo de datos, podemos sin ningún riesgo convertirlos (en C#) o convertirlos (en Visual Basic) de enteros en bytes.</span><span class="sxs-lookup"><span data-stu-id="744ed-270">Because we are sure that the integer values returned by the <xref:System.Random.Next%2A> method are within the range of the <xref:System.Byte> data type, we can safely cast them (in C#) or convert them (in Visual Basic) from integers to bytes.</span></span>  
  
<a name="Array"></a>   
### <a name="retrieve-an-element-from-an-array-or-collection-at-random"></a><span data-ttu-id="744ed-271">Recupera un elemento de una matriz o colección de forma aleatoria</span><span class="sxs-lookup"><span data-stu-id="744ed-271">Retrieve an element from an array or collection at random</span></span>  
 <span data-ttu-id="744ed-272">Números aleatorios sirven a menudo como índices para recuperar valores de las matrices o colecciones.</span><span class="sxs-lookup"><span data-stu-id="744ed-272">Random numbers often serve as indexes to retrieve values from arrays or collections.</span></span> <span data-ttu-id="744ed-273">Para recuperar un valor de índice aleatorio, puede llamar a la <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29> método y el uso límite inferior de la matriz como el valor de su `minValue` argumento y una unidad mayor que el límite superior de la matriz como el valor de su `maxValue` argumento.</span><span class="sxs-lookup"><span data-stu-id="744ed-273">To retrieve a random index value, you can call the <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29> method, and use the lower bound of the array as the value of its `minValue` argument and one greater than the upper bound of the array as the value of its `maxValue` argument.</span></span> <span data-ttu-id="744ed-274">Para una matriz de base cero, esto es equivalente a su <xref:System.Array.Length%2A> propiedad o una unidad mayor que el valor devuelto por la <xref:System.Array.GetUpperBound%2A?displayProperty=nameWithType> método.</span><span class="sxs-lookup"><span data-stu-id="744ed-274">For a zero-based array, this is equivalent to its <xref:System.Array.Length%2A> property, or one greater than the value returned by the <xref:System.Array.GetUpperBound%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="744ed-275">En el ejemplo siguiente se recupera de forma aleatoria el nombre de una ciudad en los Estados Unidos de una matriz de ciudades.</span><span class="sxs-lookup"><span data-stu-id="744ed-275">The following example randomly retrieves the name of a city in the United States from an array of cities.</span></span>  
  
 [!code-cpp[System.Random#10](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/array1.cpp#10)]
 [!code-csharp[System.Random#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/array1.cs#10)]
 [!code-vb[System.Random#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/array1.vb#10)]  
  
<a name="UniqueArray"></a>   
### <a name="retrieve-a-unique-element-from-an-array-or-collection"></a><span data-ttu-id="744ed-276">Recuperar un único elemento de una matriz o colección</span><span class="sxs-lookup"><span data-stu-id="744ed-276">Retrieve a unique element from an array or collection</span></span>  
 <span data-ttu-id="744ed-277">Un generador de números aleatorios siempre puede devolver valores duplicados.</span><span class="sxs-lookup"><span data-stu-id="744ed-277">A random number generator can always return duplicate values.</span></span> <span data-ttu-id="744ed-278">Como el intervalo de números se vuelve más pequeño o el número de valores generados se vuelve mayor, aumenta la probabilidad de duplicados.</span><span class="sxs-lookup"><span data-stu-id="744ed-278">As the range of numbers becomes smaller or the number of values generated becomes larger, the probability of duplicates grows.</span></span> <span data-ttu-id="744ed-279">Si valores aleatorios deben ser únicos, más números se generan para compensar duplicados, lo que produce un rendimiento bajo cada vez más.</span><span class="sxs-lookup"><span data-stu-id="744ed-279">If random values must be unique, more numbers are generated to compensate for duplicates, resulting in increasingly poor performance.</span></span>  
  
 <span data-ttu-id="744ed-280">Hay una serie de técnicas para controlar este escenario.</span><span class="sxs-lookup"><span data-stu-id="744ed-280">There are a number of techniques to handle this scenario.</span></span> <span data-ttu-id="744ed-281">Una solución habitual consiste en crear una matriz o colección que contiene los valores que se van a recuperar y una matriz paralela que contiene números de punto flotante aleatorios.</span><span class="sxs-lookup"><span data-stu-id="744ed-281">One common solution is to create an array or collection that contains the values to be retrieved, and a parallel array that contains random floating-point numbers.</span></span> <span data-ttu-id="744ed-282">La segunda matriz se rellena con números aleatorios en el momento de crea la primera matriz, y la <xref:System.Array.Sort%28System.Array%2CSystem.Array%29?displayProperty=nameWithType> método se utiliza para ordenar la primera matriz mediante el uso de los valores de la matriz en paralelo.</span><span class="sxs-lookup"><span data-stu-id="744ed-282">The second array is populated with random numbers at the time the first array is created, and the <xref:System.Array.Sort%28System.Array%2CSystem.Array%29?displayProperty=nameWithType> method is used to sort the first array by using the values in the parallel array.</span></span>  
  
 <span data-ttu-id="744ed-283">Por ejemplo, si está desarrollando un juego Solitario, desea asegurarse de que se utiliza una sola vez cada tarjeta.</span><span class="sxs-lookup"><span data-stu-id="744ed-283">For example, if you're developing a Solitaire game, you want to ensure that each card is used only once.</span></span> <span data-ttu-id="744ed-284">En lugar de generar números aleatorios para recuperar una tarjeta y si ya se ha trabajado esa tarjeta de seguimiento, puede crear una matriz paralela de números aleatorios que se pueden utilizar para ordenar la baraja.</span><span class="sxs-lookup"><span data-stu-id="744ed-284">Instead of generating random numbers to retrieve a card and tracking whether that card has already been dealt, you can create a parallel array of random numbers that can be used to sort the deck.</span></span> <span data-ttu-id="744ed-285">Una vez que se ordena la baraja, la aplicación puede mantener un puntero para indicar el índice de la tarjeta siguiente en la cubierta.</span><span class="sxs-lookup"><span data-stu-id="744ed-285">Once the deck is sorted, your app can maintain a pointer to indicate the index of the next card on the deck.</span></span>  
  
 <span data-ttu-id="744ed-286">En el ejemplo siguiente se muestra este enfoque.</span><span class="sxs-lookup"><span data-stu-id="744ed-286">The following example illustrates this approach.</span></span> <span data-ttu-id="744ed-287">Define un `Card` clase que representa una tarjeta de juego y `Dealer` clase que se encarga de una baraja de cartas orden aleatorios.</span><span class="sxs-lookup"><span data-stu-id="744ed-287">It defines a `Card` class that represents a playing card and a `Dealer` class that deals a deck of shuffled cards.</span></span> <span data-ttu-id="744ed-288">El `Dealer` constructor de clase rellena dos matrices: una `deck` matriz que tiene ámbito de clase y que representa todas las tarjetas de la baraja; y una variable local `order` matriz que tiene el mismo número de elementos como la `deck` de matriz y se rellena con genera de forma aleatoria <xref:System.Double> valores.</span><span class="sxs-lookup"><span data-stu-id="744ed-288">The `Dealer` class constructor populates two arrays: a `deck` array that has class scope and that represents all the cards in the deck; and a local `order` array that has the same number of elements as the `deck` array and is populated with randomly generated <xref:System.Double> values.</span></span>  <span data-ttu-id="744ed-289">El <xref:System.Array.Sort%28System.Array%2CSystem.Array%29?displayProperty=nameWithType> , a continuación, se llama el método para ordenar el `deck` matriz basándose en los valores en el `order` matriz.</span><span class="sxs-lookup"><span data-stu-id="744ed-289">The <xref:System.Array.Sort%28System.Array%2CSystem.Array%29?displayProperty=nameWithType> method is then called to sort the `deck` array based on the values in the `order` array.</span></span>  
  
 [!code-cpp[System.Random#11](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/uniquearray1.cpp#11)]
 [!code-csharp[System.Random#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/uniquearray1.cs#11)]
 [!code-vb[System.Random#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/uniquearray1.vb#11)]  
  
   
  
## Examples  
 <span data-ttu-id="744ed-290">En el ejemplo siguiente se crea un generador de números aleatorios único y llama su <xref:System.Random.NextBytes%2A>, <xref:System.Random.Next%2A>, y <xref:System.Random.NextDouble%2A> métodos para generar secuencias de números aleatorios en intervalos diferentes.</span><span class="sxs-lookup"><span data-stu-id="744ed-290">The following example creates a single random number generator and calls its <xref:System.Random.NextBytes%2A>, <xref:System.Random.Next%2A>, and <xref:System.Random.NextDouble%2A> methods to generate sequences of random numbers within different ranges.</span></span>  
  
 [!code-cpp[System.Random#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/random2.cpp#2)]
 [!code-csharp[System.Random#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/Random2.cs#2)]
 [!code-vb[System.Random#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/Random2.vb#2)]  
  
 <span data-ttu-id="744ed-291">En el ejemplo siguiente se genera un entero aleatorio que utiliza como un índice para recuperar un valor de cadena de una matriz.</span><span class="sxs-lookup"><span data-stu-id="744ed-291">The following example generates a random integer that it uses as an index to retrieve a string value from an array.</span></span>  
  
 [!code-cpp[System.Random.Next#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random.Next/CPP/next1.cpp#3)]
 [!code-csharp[System.Random.Next#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random.Next/CS/next1.cs#3)]
 [!code-vb[System.Random.Next#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random.Next/VB/next1.vb#3)]  
  
 ]]></format>
    </remarks>
    <block subset="none" type="overrides">
      <span data-ttu-id="744ed-292">
        <para>En .NET Framework 1.0 y 1.1, una implementación mínima de una clase derivada de <see cref="T:System.Random" /> necesario reemplazar el <see cref="M:System.Random.Sample" /> método para definir un algoritmo nuevo o modificado para generar números aleatorios. La clase derivada, a continuación, podían confiar en la implementación de la clase base de la <see cref="M:System.Random.Next" />, <see cref="M:System.Random.Next(System.Int32)" />, <see cref="M:System.Random.Next(System.Int32,System.Int32)" />, <see cref="M:System.Random.NextBytes(System.Byte[])" />, y <see cref="M:System.Random.NextDouble" /> métodos para llamar a la implementación de clase derivada de la <see cref="M:System.Random.Sample" /> método.  En .NET Framework 2.0 y versiones posterior, el comportamiento de la <see cref="M:System.Random.Next" />, <see cref="M:System.Random.Next(System.Int32,System.Int32)" />, y <see cref="M:System.Random.NextBytes(System.Byte[])" /> métodos han cambiado para que estos métodos no llaman necesariamente a la implementación de clase derivada de la <see cref="M:System.Random.Sample" /> método. Como resultado, las clases derivadas de <see cref="T:System.Random" /> que tener como destino .NET Framework 2.0 y versiones posteriores también deben invalidar estos tres métodos.</para>
      </span>
      <span class="sxs-lookup">
        <span data-stu-id="744ed-292">
          <para>In the .NET Framework 1.0 and 1.1, a minimum implementation of a class derived from <see cref="T:System.Random" /> required overriding the <see cref="M:System.Random.Sample" /> method to define a new or modified algorithm for generating random numbers. The derived class could then rely on the base class implementation of the <see cref="M:System.Random.Next" />, <see cref="M:System.Random.Next(System.Int32)" />, <see cref="M:System.Random.Next(System.Int32,System.Int32)" />, <see cref="M:System.Random.NextBytes(System.Byte[])" />, and <see cref="M:System.Random.NextDouble" /> methods to call the derived class implementation of the <see cref="M:System.Random.Sample" /> method.  In the .NET Framework 2.0 and later, the behavior of the <see cref="M:System.Random.Next" />, <see cref="M:System.Random.Next(System.Int32,System.Int32)" />, and <see cref="M:System.Random.NextBytes(System.Byte[])" /> methods have changed so that these methods do not necessarily call the derived class implementation of the <see cref="M:System.Random.Sample" /> method. As a result, classes derived from <see cref="T:System.Random" /> that target the .NET Framework 2.0 and later should also override these three methods.</para>
        </span>
      </span>
    </block>
    <block subset="none" type="usage">
      <span data-ttu-id="744ed-293">
        <para>La implementación del generador de números aleatorios en la <see cref="T:System.Random" /> clase no siempre sea la misma en las versiones principales de .NET Framework. Como resultado, no debe asumir que dará como resultado el mismo valor de inicialización en la misma secuencia pseudoaleatoria en diferentes versiones de .NET Framework.</para>
      </span>
      <span class="sxs-lookup">
        <span data-stu-id="744ed-293">
          <para>The implementation of the random number generator in the <see cref="T:System.Random" /> class isn't guaranteed to remain the same across major versions of the .NET Framework. As a result, you shouldn't assume that the same seed will result in the same pseudo-random sequence in different versions of the .NET Framework.</para>
        </span>
      </span>
    </block>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="744ed-294">Inicializa una nueva instancia de la clase <see cref="T:System.Random" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="744ed-294">Initializes a new instance of the <see cref="T:System.Random" /> class.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Random ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Random.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Random();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="744ed-295">Inicializa una nueva instancia de la clase <see cref="T:System.Random" /> mediante un valor de inicialización predeterminado que depende del tiempo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="744ed-295">Initializes a new instance of the <see cref="T:System.Random" /> class, using a time-dependent default seed value.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="744ed-296">El valor de inicialización predeterminado se deriva del reloj del sistema y tiene una resolución finita.</span><span class="sxs-lookup"><span data-stu-id="744ed-296">The default seed value is derived from the system clock and has finite resolution.</span></span> <span data-ttu-id="744ed-297">Como consecuencia, diferentes <xref:System.Random> objetos que se crean en estrecha sucesión mediante una llamada al constructor predeterminado tendrán valores de inicialización predeterminados idénticos y, por consiguiente, generarán conjuntos idénticos de números aleatorios.</span><span class="sxs-lookup"><span data-stu-id="744ed-297">As a result, different <xref:System.Random> objects that are created in close succession by a call to the default constructor will have identical default seed values and, therefore, will produce identical sets of random numbers.</span></span> <span data-ttu-id="744ed-298">Este problema puede evitarse mediante un único <xref:System.Random> objeto que se va a generar todos los números aleatorios.</span><span class="sxs-lookup"><span data-stu-id="744ed-298">This problem can be avoided by using a single <xref:System.Random> object to generate all random numbers.</span></span> <span data-ttu-id="744ed-299">También puede trabajar alrededor de ella modificando el valor de inicialización devuelto por el reloj del sistema y, a continuación, proporcionar explícitamente este nuevo valor de inicialización para el <xref:System.Random.%23ctor%28System.Int32%29> constructor.</span><span class="sxs-lookup"><span data-stu-id="744ed-299">You can also work around it by modifying the seed value returned by the system clock and then explicitly providing this new seed value to the <xref:System.Random.%23ctor%28System.Int32%29> constructor.</span></span> <span data-ttu-id="744ed-300">Para obtener más información, consulte el <xref:System.Random.%23ctor%28System.Int32%29> constructor.</span><span class="sxs-lookup"><span data-stu-id="744ed-300">For more information, see the <xref:System.Random.%23ctor%28System.Int32%29> constructor.</span></span>  
  
 <span data-ttu-id="744ed-301">Llamar a este constructor si desea que el generador de números aleatorios para generar una secuencia aleatoria de números.</span><span class="sxs-lookup"><span data-stu-id="744ed-301">Call this constructor if you want your random number generator to generate a random sequence of numbers.</span></span> <span data-ttu-id="744ed-302">Para generar una secuencia de números aleatorios que serán el mismo para los generadores de números aleatorios diferentes fija, llame a la <xref:System.Random.%23ctor%28System.Int32%29> constructor con un valor de inicialización fijo.</span><span class="sxs-lookup"><span data-stu-id="744ed-302">To generate a fixed  sequence of random numbers that will be the same for different random number generators, call the <xref:System.Random.%23ctor%28System.Int32%29> constructor with a fixed seed value .</span></span> <span data-ttu-id="744ed-303">Esto <xref:System.Random> sobrecarga del constructor se utiliza con frecuencia al probar aplicaciones que usan números aleatorios.</span><span class="sxs-lookup"><span data-stu-id="744ed-303">This <xref:System.Random> constructor overload is frequently used when testing apps that use random numbers.</span></span>  
  
 <span data-ttu-id="744ed-304">Una vez que haya creado la instancia de generador de números aleatorios, llame a individuales <xref:System.Random> métodos, como <xref:System.Random.Next> o <xref:System.Random.NextDouble>, para generar números aleatorios.</span><span class="sxs-lookup"><span data-stu-id="744ed-304">Once you've instantiated the random number generator, you call individual <xref:System.Random> methods, such as <xref:System.Random.Next> or <xref:System.Random.NextDouble>, to generate random numbers.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="744ed-305">En el ejemplo siguiente se utiliza el constructor predeterminado para crear instancias de tres <xref:System.Random> objetos y muestra una secuencia de cinco enteros aleatorios para cada uno.</span><span class="sxs-lookup"><span data-stu-id="744ed-305">The following example uses the default constructor to instantiate three <xref:System.Random> objects and displays a sequence of five random integers for each.</span></span> <span data-ttu-id="744ed-306">Dado que las dos primeras <xref:System.Random> objetos se crean en estrecha sucesión, sus instancias se crean utilizando valores de inicialización idénticos basados en el reloj del sistema y, por lo tanto, generan una secuencia idéntica de números aleatorios.</span><span class="sxs-lookup"><span data-stu-id="744ed-306">Because the first two <xref:System.Random> objects are created in close succession, they are instantiated using identical seed values based on the system clock and, therefore, they produce an identical sequence of random numbers.</span></span> <span data-ttu-id="744ed-307">Por otro lado, el constructor predeterminado del tercer <xref:System.Random> objeto se llama después de un retraso de dos segundos causado por una llamada a la <xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType> método.</span><span class="sxs-lookup"><span data-stu-id="744ed-307">On the other hand, the default constructor of the third <xref:System.Random> object is called after a two-second delay caused by calling the <xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="744ed-308">Dado que esto genera un valor de inicialización diferente para la tercera <xref:System.Random> de objeto, genera una secuencia diferente de números aleatorios.</span><span class="sxs-lookup"><span data-stu-id="744ed-308">Because this produces a different seed value for the third <xref:System.Random> object, it produces a different sequence of random numbers.</span></span>  
  
 [!code-csharp[System.Random.Ctor#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random.Ctor/CS/ctor1.cs#2)]
 [!code-vb[System.Random.Ctor#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random.Ctor/VB/ctor1.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Random (int Seed);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 Seed) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Random.#ctor(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (Seed As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Random(int Seed);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="Seed" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="Seed">
          <span data-ttu-id="744ed-309">Número que se usa para calcular el valor inicial de la secuencia de números seudoaleatorios.</span>
          <span class="sxs-lookup">
            <span data-stu-id="744ed-309">A number used to calculate a starting value for the pseudo-random number sequence.</span>
          </span>
          <span data-ttu-id="744ed-310">Si se especifica un número negativo, se usa el valor absoluto del número.</span>
          <span class="sxs-lookup">
            <span data-stu-id="744ed-310">If a negative number is specified, the absolute value of the number is used.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="744ed-311">Inicializa una nueva instancia de la clase <see cref="T:System.Random" /> utilizando el valor de inicialización especificado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="744ed-311">Initializes a new instance of the <see cref="T:System.Random" /> class, using the specified seed value.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="744ed-312">Proporcionar un valor de inicialización idéntico a diferentes <xref:System.Random> objetos hace que cada instancia genere secuencias idénticas de números aleatorios.</span><span class="sxs-lookup"><span data-stu-id="744ed-312">Providing an identical seed value to different <xref:System.Random> objects causes each instance to produce identical sequences of random numbers.</span></span> <span data-ttu-id="744ed-313">Esto se suele hacer al probar las aplicaciones que se basan en los generadores de números aleatorios.</span><span class="sxs-lookup"><span data-stu-id="744ed-313">This is often done when testing apps that rely on random number generators.</span></span>  
  
 <span data-ttu-id="744ed-314">Si la aplicación requiere diferentes secuencias de números aleatorios, invocar a este constructor varias veces con valores de inicialización distintos.</span><span class="sxs-lookup"><span data-stu-id="744ed-314">If your application requires different random number sequences, invoke this constructor repeatedly with different seed values.</span></span> <span data-ttu-id="744ed-315">Es una manera de generar un valor de inicialización único para que sea dependiente del tiempo.</span><span class="sxs-lookup"><span data-stu-id="744ed-315">One way to produce a unique seed value is to make it time-dependent.</span></span> <span data-ttu-id="744ed-316">Por ejemplo, derivar el valor de inicialización del reloj del sistema, como el <xref:System.Random.%23ctor> does de sobrecarga.</span><span class="sxs-lookup"><span data-stu-id="744ed-316">For example, derive the seed value from the system clock, as the <xref:System.Random.%23ctor> overload does.</span></span> <span data-ttu-id="744ed-317">Sin embargo, el reloj del sistema podría no tener suficiente resolución para proporcionar las distintas invocaciones de este constructor con un valor de inicialización diferente.</span><span class="sxs-lookup"><span data-stu-id="744ed-317">However, the system clock might not have sufficient resolution to provide different invocations of this constructor with a different seed value.</span></span> <span data-ttu-id="744ed-318">Esto da como resultado de los generadores de números aleatorios que generan secuencias idénticas de números seudoaleatorios, como se muestra en los dos primeros <xref:System.Random> objetos en el ejemplo siguiente.</span><span class="sxs-lookup"><span data-stu-id="744ed-318">This results in random number generators that generate identical sequences of pseudo-random numbers, as illustrated by the first two <xref:System.Random> objects in the following example.</span></span> <span data-ttu-id="744ed-319">Para evitar esto, aplique un algoritmo para diferenciar el valor de inicialización de cada invocación o llame a la <xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType> método para asegurarse de que proporciona cada constructor con un valor de inicialización diferente.</span><span class="sxs-lookup"><span data-stu-id="744ed-319">To prevent this, apply an algorithm to differentiate the seed value in each invocation, or call the <xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType> method to ensure that you provide each constructor with a different seed value.</span></span>  
  
 [!code-csharp[System.Random.Ctor#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random.Ctor/CS/ctor4.cs#4)]
 [!code-vb[System.Random.Ctor#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random.Ctor/VB/ctor4.vb#4)]  
  
 <span data-ttu-id="744ed-320">Otra opción consiste en crear una instancia de una sola <xref:System.Random> del objeto que se usa para generar todos los números aleatorios en la aplicación.</span><span class="sxs-lookup"><span data-stu-id="744ed-320">Another option is to instantiate a single <xref:System.Random> object that you use to generate all the random numbers in your application.</span></span> <span data-ttu-id="744ed-321">Esto da como resultado un rendimiento ligeramente mejor, ya que crear instancias de un generador de números aleatorios es bastante costosa.</span><span class="sxs-lookup"><span data-stu-id="744ed-321">This yields slightly better performance, since instantiating a random number generator is fairly expensive.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="744ed-322">En el ejemplo siguiente se crea <xref:System.Random> objetos con el constructor de clase que toma un parámetro de inicialización y genera una secuencia de enteros y dobles aleatorios.</span><span class="sxs-lookup"><span data-stu-id="744ed-322">The following example creates <xref:System.Random> objects with the class constructor that takes a seed parameter and generates a sequence of random integers and doubles.</span></span> <span data-ttu-id="744ed-323">El ejemplo se muestra que se genera la misma secuencia cuando el <xref:System.Random> objeto se vuelve a crear con el parámetro de constructor y el valor de inicialización.</span><span class="sxs-lookup"><span data-stu-id="744ed-323">The example illustrates that the same sequence is generated when the <xref:System.Random> object is created again with the constructor and seed parameter.</span></span>  
  
 [!code-cpp[System.Random.Ctor#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random.Ctor/CPP/ctor.cpp#1)]
 [!code-csharp[System.Random.Ctor#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random.Ctor/CS/ctor.cs#1)]
 [!code-vb[System.Random.Ctor#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random.Ctor/VB/ctor.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Next">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="744ed-324">Devuelve un entero aleatorio.</span>
          <span class="sxs-lookup">
            <span data-stu-id="744ed-324">Returns a random integer.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Next">
      <MemberSignature Language="C#" Value="public virtual int Next ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 Next() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Random.Next" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Next () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int Next();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="744ed-325">Devuelve un entero aleatorio no negativo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="744ed-325">Returns a non-negative random integer.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="744ed-326">Número entero de 32 bits con signo mayor o igual que 0 y menor que <see cref="F:System.Int32.MaxValue" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="744ed-326">A 32-bit signed integer that is greater than or equal to 0 and less than <see cref="F:System.Int32.MaxValue" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="744ed-327"><xref:System.Random.Next%2A?displayProperty=nameWithType> genera un número aleatorio cuyo valor oscila entre 0 y menor que <xref:System.Int32.MaxValue?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="744ed-327"><xref:System.Random.Next%2A?displayProperty=nameWithType> generates a random number whose value ranges from 0 to less than <xref:System.Int32.MaxValue?displayProperty=nameWithType>.</span></span> <span data-ttu-id="744ed-328">Para generar un número aleatorio cuyo valor oscila entre 0 a otro número positivo, use la <xref:System.Random.Next%28System.Int32%29?displayProperty=nameWithType> sobrecarga del método.</span><span class="sxs-lookup"><span data-stu-id="744ed-328">To generate a random number whose value ranges from 0 to some other positive number, use the <xref:System.Random.Next%28System.Int32%29?displayProperty=nameWithType> method overload.</span></span> <span data-ttu-id="744ed-329">Para generar un número aleatorio dentro de un intervalo diferente, use el <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29?displayProperty=nameWithType> sobrecarga del método.</span><span class="sxs-lookup"><span data-stu-id="744ed-329">To generate a random number within a different range, use the <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29?displayProperty=nameWithType> method overload.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="744ed-330">En el ejemplo siguiente se realiza llamadas repetidas a la <xref:System.Random.Next%2A> método para generar un número específico de números aleatorios solicitados por el usuario.</span><span class="sxs-lookup"><span data-stu-id="744ed-330">The following example makes repeated calls to the <xref:System.Random.Next%2A> method to generate a specific number of random numbers requested by the user.</span></span> <span data-ttu-id="744ed-331">El <xref:System.Console.ReadLine%2A?displayProperty=nameWithType> método se utiliza para obtener comentarios de los clientes.</span><span class="sxs-lookup"><span data-stu-id="744ed-331">The <xref:System.Console.ReadLine%2A?displayProperty=nameWithType> method is used to get customer input.</span></span>  
  
 [!code-cpp[System.Random.Next#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random.Next/CPP/next3.cpp#5)]
 [!code-csharp[System.Random.Next#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random.Next/CS/next3.cs#5)]
 [!code-vb[System.Random.Next#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random.Next/VB/next3.vb#5)]  
  
 <span data-ttu-id="744ed-332">En el ejemplo siguiente se deriva una clase de <xref:System.Random> para generar una secuencia de números aleatorios cuya distribución difiere de la distribución uniforme generada por el <xref:System.Random.Sample%2A> método de la clase base.</span><span class="sxs-lookup"><span data-stu-id="744ed-332">The following example derives a class from <xref:System.Random> to generate a sequence of random numbers whose distribution differs from the uniform distribution generated by the <xref:System.Random.Sample%2A> method of the base class.</span></span> <span data-ttu-id="744ed-333">Reemplaza el <xref:System.Random.Sample%2A> método para proporcionar la distribución de números aleatorios e invalida el <xref:System.Random.Next%2A?displayProperty=nameWithType> método que desea utilizar la serie de números aleatorios.</span><span class="sxs-lookup"><span data-stu-id="744ed-333">It overrides the <xref:System.Random.Sample%2A> method to provide the distribution of random numbers, and overrides the <xref:System.Random.Next%2A?displayProperty=nameWithType> method to use series of random numbers.</span></span>  
  
 [!code-cpp[System.Random.Sample#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random.Sample/cpp/sampleex.cpp#1)]
 [!code-csharp[System.Random.Sample#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random.Sample/CS/sample.cs#1)]
 [!code-vb[System.Random.Sample#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random.Sample/VB/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <span data-ttu-id="744ed-334">
            <para>A partir de .NET Framework versión 2.0, si se deriva una clase de <see cref="T:System.Random" /> e invalide el <see cref="M:System.Random.Sample" /> /método siguiente, la distribución proporcionada por la implementación de clase derivada de la <see cref="M:System.Random.Sample" /> método no se utiliza en las llamadas a la clase base implementación de la <see cref="M:System.Random.Next" /> método. En su lugar, la distribución uniforme devuelto por la base de <see cref="T:System.Random" /> se utiliza la clase. Este comportamiento mejora el rendimiento general de la <see cref="T:System.Random" /> clase. Para modificar este comportamiento para llamar a la <see cref="M:System.Random.Sample" /> método en la clase derivada, también debe invalidar el <see cref="M:System.Random.Next" /> método.</para>
          </span>
          <span class="sxs-lookup">
            <span data-stu-id="744ed-334">
              <para>Starting with the .NET Framework version 2.0, if you derive a class from <see cref="T:System.Random" /> and override the <see cref="M:System.Random.Sample" /> method, the distribution provided by the derived class implementation of the <see cref="M:System.Random.Sample" /> method is not used in calls to the base class implementation of the <see cref="M:System.Random.Next" /> method. Instead, the uniform distribution returned by the base <see cref="T:System.Random" /> class is used. This behavior improves the overall performance of the <see cref="T:System.Random" /> class. To modify this behavior to call the <see cref="M:System.Random.Sample" /> method in the derived class, you must also override the <see cref="M:System.Random.Next" /> method.</para>
            </span>
          </span>
        </block>
        <altmember cref="T:System.Int32" />
      </Docs>
    </Member>
    <Member MemberName="Next">
      <MemberSignature Language="C#" Value="public virtual int Next (int maxValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 Next(int32 maxValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Random.Next(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Next (maxValue As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int Next(int maxValue);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="maxValue" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="maxValue">
          <span data-ttu-id="744ed-335">Límite superior exclusivo del número aleatorio que se va a generar.</span>
          <span class="sxs-lookup">
            <span data-stu-id="744ed-335">The exclusive upper bound of the random number to be generated.</span>
          </span>
          <span data-ttu-id="744ed-336">
            <c>maxValue</c> debe ser igual o mayor que 0.</span>
          <span class="sxs-lookup">
            <span data-stu-id="744ed-336">
              <c>maxValue</c> must be greater than or equal to 0.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="744ed-337">Devuelve un entero aleatorio no negativo que es menor que el valor máximo especificado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="744ed-337">Returns a non-negative random integer that is less than the specified maximum.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="744ed-338">Número entero de 32 bits con signo mayor o igual que 0 y menor que <paramref name="maxValue" />; es decir, dentro del intervalo de valores devueltos se incluye 0, pero no <paramref name="maxValue" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="744ed-338">A 32-bit signed integer that is greater than or equal to 0, and less than <paramref name="maxValue" />; that is, the range of return values ordinarily includes 0 but not <paramref name="maxValue" />.</span>
          </span>
          <span data-ttu-id="744ed-339">Pero si <paramref name="maxValue" /> es igual a 0, se devuelve <paramref name="maxValue" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="744ed-339">However, if <paramref name="maxValue" /> equals 0, <paramref name="maxValue" /> is returned.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="744ed-340">El <xref:System.Random.Next%28System.Int32%29> sobrecarga devuelve enteros aleatorios que van de 0 a `maxValue` – 1.</span><span class="sxs-lookup"><span data-stu-id="744ed-340">The <xref:System.Random.Next%28System.Int32%29> overload returns random integers that range from 0 to `maxValue` – 1.</span></span> <span data-ttu-id="744ed-341">Sin embargo, si `maxValue` es 0, el método devuelve 0.</span><span class="sxs-lookup"><span data-stu-id="744ed-341">However, if `maxValue` is 0, the method returns 0.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="744ed-342">El ejemplo siguiente genera números enteros aleatorios con varias sobrecargas de la <xref:System.Random.Next%2A> método.</span><span class="sxs-lookup"><span data-stu-id="744ed-342">The following example generates random integers with various overloads of the <xref:System.Random.Next%2A> method.</span></span>  
  
 [!code-cpp[System.Random.Next#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random.Next/CPP/next.cpp#1)]
 [!code-csharp[System.Random.Next#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random.Next/CS/next.cs#1)]
 [!code-vb[System.Random.Next#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random.Next/VB/next.vb#1)]  
  
 <span data-ttu-id="744ed-343">En el ejemplo siguiente se genera un entero aleatorio que utiliza como un índice para recuperar un valor de cadena de una matriz.</span><span class="sxs-lookup"><span data-stu-id="744ed-343">The following example generates a random integer that it uses as an index to retrieve a string value from an array.</span></span> <span data-ttu-id="744ed-344">Dado que el índice más alto de la matriz es una menor que su longitud, el valor de la <xref:System.Array.Length%2A?displayProperty=nameWithType> propiedad se proporciona como un el `maxValue` parámetro.</span><span class="sxs-lookup"><span data-stu-id="744ed-344">Because the highest index of the array is one less than its length, the value of the <xref:System.Array.Length%2A?displayProperty=nameWithType> property is supplied as a the `maxValue` parameter.</span></span>  
  
 [!code-cpp[System.Random.Next#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random.Next/CPP/next1.cpp#3)]
 [!code-csharp[System.Random.Next#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random.Next/CS/next1.cs#3)]
 [!code-vb[System.Random.Next#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random.Next/VB/next1.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="744ed-345">
            <paramref name="maxValue" /> es menor que 0.</span>
          <span class="sxs-lookup">
            <span data-stu-id="744ed-345">
              <paramref name="maxValue" /> is less than 0.</span>
          </span>
        </exception>
        <altmember cref="T:System.Int32" />
      </Docs>
    </Member>
    <Member MemberName="Next">
      <MemberSignature Language="C#" Value="public virtual int Next (int minValue, int maxValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 Next(int32 minValue, int32 maxValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Random.Next(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Next (minValue As Integer, maxValue As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int Next(int minValue, int maxValue);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="minValue" Type="System.Int32" />
        <Parameter Name="maxValue" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="minValue">
          <span data-ttu-id="744ed-346">Límite inferior inclusivo del número aleatorio devuelto.</span>
          <span class="sxs-lookup">
            <span data-stu-id="744ed-346">The inclusive lower bound of the random number returned.</span>
          </span>
        </param>
        <param name="maxValue">
          <span data-ttu-id="744ed-347">Límite superior exclusivo del número aleatorio devuelto.</span>
          <span class="sxs-lookup">
            <span data-stu-id="744ed-347">The exclusive upper bound of the random number returned.</span>
          </span>
          <span data-ttu-id="744ed-348">
            <c>maxValue</c> debe ser mayor o igual que <c>minValue</c>.</span>
          <span class="sxs-lookup">
            <span data-stu-id="744ed-348">
              <c>maxValue</c> must be greater than or equal to <c>minValue</c>.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="744ed-349">Devuelve un entero aleatorio que está dentro de un intervalo especificado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="744ed-349">Returns a random integer that is within a specified range.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="744ed-350">Número entero de 32 bits con signo mayor o igual que <paramref name="minValue" /> y menor que <paramref name="maxValue" />; es decir, dentro del intervalo de valores devueltos se incluye <paramref name="minValue" /> pero no <paramref name="maxValue" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="744ed-350">A 32-bit signed integer greater than or equal to <paramref name="minValue" /> and less than <paramref name="maxValue" />; that is, the range of return values includes <paramref name="minValue" /> but not <paramref name="maxValue" />.</span>
          </span>
          <span data-ttu-id="744ed-351">Si <paramref name="minValue" /> es igual que <paramref name="maxValue" />, se devuelve <paramref name="minValue" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="744ed-351">If <paramref name="minValue" /> equals <paramref name="maxValue" />, <paramref name="minValue" /> is returned.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="744ed-352">El <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29> sobrecarga devuelve enteros aleatorios comprendidos entre `minValue` a `maxValue` – 1.</span><span class="sxs-lookup"><span data-stu-id="744ed-352">The <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29> overload returns random integers that range from `minValue` to `maxValue` – 1.</span></span> <span data-ttu-id="744ed-353">Sin embargo, si `maxValue` es igual a `minValue`, el método devuelve `minValue`.</span><span class="sxs-lookup"><span data-stu-id="744ed-353">However, if `maxValue` equals `minValue`, the method returns `minValue`.</span></span>  
  
 <span data-ttu-id="744ed-354">A diferencia de las otras sobrecargas de la <xref:System.Random.Next%2A> método, que devuelven valores no negativos solo, este método puede devolver un entero aleatorio negativo.</span><span class="sxs-lookup"><span data-stu-id="744ed-354">Unlike the other overloads of the <xref:System.Random.Next%2A> method, which return only non-negative values, this method can return a negative random integer.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="744ed-355">En el ejemplo siguiente se usa el <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29?displayProperty=nameWithType> método para generar números enteros aleatorios con tres intervalos distintos.</span><span class="sxs-lookup"><span data-stu-id="744ed-355">The following example uses the <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29?displayProperty=nameWithType> method to generate random integers with three distinct ranges.</span></span> <span data-ttu-id="744ed-356">Tenga en cuenta que el resultado exacto del ejemplo depende del valor de inicialización proporcionado por el sistema que se pasa a la <xref:System.Random> constructor de clase.</span><span class="sxs-lookup"><span data-stu-id="744ed-356">Note that the exact output from the example depends on the system-supplied seed value passed to the <xref:System.Random> class constructor.</span></span>  
  
 [!code-cpp[System.Random.Next#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random.Next/CPP/next2.cpp#2)]
 [!code-csharp[System.Random.Next#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random.Next/CS/Next2.cs#2)]
 [!code-vb[System.Random.Next#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random.Next/VB/next2.vb#2)]  
  
 <span data-ttu-id="744ed-357">En el ejemplo siguiente se genera un entero aleatorio que utiliza como un índice para recuperar un valor de cadena de una matriz.</span><span class="sxs-lookup"><span data-stu-id="744ed-357">The following example generates a random integer that it uses as an index to retrieve a string value from an array.</span></span> <span data-ttu-id="744ed-358">Dado que el índice más alto de la matriz es una menor que su longitud, el valor de la <xref:System.Array.Length%2A?displayProperty=nameWithType> propiedad se proporciona como un el `maxValue` parámetro.</span><span class="sxs-lookup"><span data-stu-id="744ed-358">Because the highest index of the array is one less than its length, the value of the <xref:System.Array.Length%2A?displayProperty=nameWithType> property is supplied as a the `maxValue` parameter.</span></span>  
  
 [!code-cpp[System.Random.Next#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random.Next/CPP/next4.cpp#4)]
 [!code-csharp[System.Random.Next#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random.Next/CS/next4.cs#4)]
 [!code-vb[System.Random.Next#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random.Next/VB/next4.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="744ed-359">
            <paramref name="minValue" /> es mayor que <paramref name="maxValue" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="744ed-359">
              <paramref name="minValue" /> is greater than <paramref name="maxValue" />.</span>
          </span>
        </exception>
        <block subset="none" type="overrides">
          <span data-ttu-id="744ed-360">
            <para>A partir de .NET Framework versión 2.0, si se deriva una clase de <see cref="T:System.Random" /> e invalide el <see cref="M:System.Random.Sample" /> /método siguiente, la distribución proporcionada por la implementación de clase derivada de la <see cref="M:System.Random.Sample" /> método no se utiliza en las llamadas a la clase base implementación de la <see cref="M:System.Random.Next(System.Int32,System.Int32)" /> sobrecarga del método si la diferencia entre el <paramref name="minValue" /> y <paramref name="maxValue" /> parámetros es mayor que <see cref="F:System.Int32.MaxValue" />. En su lugar, la distribución uniforme devuelto por la base de <see cref="T:System.Random" /> se utiliza la clase. Este comportamiento mejora el rendimiento general de la <see cref="T:System.Random" /> clase. Para modificar este comportamiento para llamar a la <see cref="M:System.Random.Sample" /> método en la clase derivada, también debe invalidar el <see cref="M:System.Random.Next(System.Int32,System.Int32)" /> sobrecarga del método.</para>
          </span>
          <span class="sxs-lookup">
            <span data-stu-id="744ed-360">
              <para>Starting with the .NET Framework version 2.0, if you derive a class from <see cref="T:System.Random" /> and override the <see cref="M:System.Random.Sample" /> method, the distribution provided by the derived class implementation of the <see cref="M:System.Random.Sample" /> method is not used in calls to the base class implementation of the <see cref="M:System.Random.Next(System.Int32,System.Int32)" /> method overload if the difference between the <paramref name="minValue" /> and <paramref name="maxValue" /> parameters is greater than <see cref="F:System.Int32.MaxValue" />. Instead, the uniform distribution returned by the base <see cref="T:System.Random" /> class is used. This behavior improves the overall performance of the <see cref="T:System.Random" /> class. To modify this behavior to call the <see cref="M:System.Random.Sample" /> method in the derived class, you must also override the <see cref="M:System.Random.Next(System.Int32,System.Int32)" /> method overload.</para>
            </span>
          </span>
        </block>
        <altmember cref="T:System.Int32" />
      </Docs>
    </Member>
    <Member MemberName="NextBytes">
      <MemberSignature Language="C#" Value="public virtual void NextBytes (byte[] buffer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void NextBytes(unsigned int8[] buffer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Random.NextBytes(System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub NextBytes (buffer As Byte())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void NextBytes(cli::array &lt;System::Byte&gt; ^ buffer);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="buffer">
          <span data-ttu-id="744ed-361">Matriz de bytes que contiene números aleatorios.</span>
          <span class="sxs-lookup">
            <span data-stu-id="744ed-361">An array of bytes to contain random numbers.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="744ed-362">Rellena con números aleatorios los elementos de una matriz de bytes especificada.</span>
          <span class="sxs-lookup">
            <span data-stu-id="744ed-362">Fills the elements of a specified array of bytes with random numbers.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="744ed-363">Cada elemento de la matriz de bytes se establece en un número aleatorio mayor o igual a 0 y menor o igual que <xref:System.Byte.MaxValue>.</span><span class="sxs-lookup"><span data-stu-id="744ed-363">Each element of the array of bytes is set to a random number greater than or equal to 0, and less than or equal to <xref:System.Byte.MaxValue>.</span></span>  
  
 <span data-ttu-id="744ed-364">Por ejemplo, para generar un número aleatorio criptográficamente seguro idóneos para crear una contraseña aleatoria, use como un método <xref:System.Security.Cryptography.RNGCryptoServiceProvider.GetBytes%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="744ed-364">For example, to generate a cryptographically secured random number suitable for creating a random password, use a method such as <xref:System.Security.Cryptography.RNGCryptoServiceProvider.GetBytes%2A?displayProperty=nameWithType>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="744ed-365">En el ejemplo siguiente se muestra cómo utilizar el <xref:System.Random.NextBytes%2A> método para rellenar una matriz de bytes con valores de byte aleatorios.</span><span class="sxs-lookup"><span data-stu-id="744ed-365">The following example demonstrates how to use the <xref:System.Random.NextBytes%2A> method to fill an array of bytes with random byte values.</span></span>  
  
 [!code-cpp[Classic Random.NextBytes Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Random.NextBytes Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Random.NextBytes Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Random.NextBytes Example/CS/source.cs#1)]
 [!code-vb[Classic Random.NextBytes Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Random.NextBytes Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="744ed-366">
            <paramref name="buffer" /> es <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="744ed-366">
              <paramref name="buffer" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <block subset="none" type="overrides">
          <span data-ttu-id="744ed-367">
            <para>A partir de .NET Framework versión 2.0, si se deriva una clase de <see cref="T:System.Random" /> e invalide el <see cref="M:System.Random.Sample" /> /método siguiente, la distribución proporcionada por la implementación de clase derivada de la <see cref="M:System.Random.Sample" /> método no se utiliza en las llamadas a la clase base implementación de la <see cref="M:System.Random.NextBytes(System.Byte[])" /> método. En su lugar, la distribución uniforme devuelto por la base de <see cref="T:System.Random" /> se utiliza la clase. Este comportamiento mejora el rendimiento general de la <see cref="T:System.Random" /> clase. Para modificar este comportamiento para llamar a la <see cref="M:System.Random.Sample" /> método en la clase derivada, también debe invalidar el <see cref="M:System.Random.NextBytes(System.Byte[])" /> método.</para>
          </span>
          <span class="sxs-lookup">
            <span data-stu-id="744ed-367">
              <para>Starting with the .NET Framework version 2.0, if you derive a class from <see cref="T:System.Random" /> and override the <see cref="M:System.Random.Sample" /> method, the distribution provided by the derived class implementation of the <see cref="M:System.Random.Sample" /> method is not used in calls to the base class implementation of the <see cref="M:System.Random.NextBytes(System.Byte[])" /> method. Instead, the uniform distribution returned by the base <see cref="T:System.Random" /> class is used. This behavior improves the overall performance of the <see cref="T:System.Random" /> class. To modify this behavior to call the <see cref="M:System.Random.Sample" /> method in the derived class, you must also override the <see cref="M:System.Random.NextBytes(System.Byte[])" /> method.</para>
            </span>
          </span>
        </block>
        <altmember cref="T:System.Byte" />
      </Docs>
    </Member>
    <Member MemberName="NextBytes">
      <MemberSignature Language="C#" Value="public virtual void NextBytes (Span&lt;byte&gt; buffer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void NextBytes(valuetype System.Span`1&lt;unsigned int8&gt; buffer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Random.NextBytes(System.Span{System.Byte})" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub NextBytes (buffer As Span(Of Byte))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void NextBytes(Span&lt;System::Byte&gt; buffer);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Span&lt;System.Byte&gt;" />
      </Parameters>
      <Docs>
        <param name="buffer">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="NextDouble">
      <MemberSignature Language="C#" Value="public virtual double NextDouble ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance float64 NextDouble() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Random.NextDouble" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function NextDouble () As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual double NextDouble();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="744ed-368">Devuelve un número de punto flotante aleatorio que es mayor o igual que 0,0 y menor que 1,0.</span>
          <span class="sxs-lookup">
            <span data-stu-id="744ed-368">Returns a random floating-point number that is greater than or equal to 0.0, and less than 1.0.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="744ed-369">Número de punto flotante de doble precisión que es mayor o igual que 0,0 y menor que 1,0.</span>
          <span class="sxs-lookup">
            <span data-stu-id="744ed-369">A double-precision floating point number that is greater than or equal to 0.0, and less than 1.0.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="744ed-370">El límite superior real del número aleatorio devuelto por este método es 0.99999999999999978.</span><span class="sxs-lookup"><span data-stu-id="744ed-370">The actual upper bound of the random number returned by this method is 0.99999999999999978.</span></span>  
  
 <span data-ttu-id="744ed-371">Para recuperar los valores de punto flotante aleatorios dentro de un intervalo que no sea de 0,0 y 1,0, vea la sección "Recuperar valores de punto flotante en un intervalo especificado" de la <xref:System.Random> tema de la clase.</span><span class="sxs-lookup"><span data-stu-id="744ed-371">To retrieve random floating-point values within a range other than 0.0 and 1.0, see the "Retrieve floating-point values in a specified range" section of the <xref:System.Random> class topic.</span></span>  
  
 <span data-ttu-id="744ed-372">Este método es la versión pública del método protegido, <xref:System.Random.Sample%2A>.</span><span class="sxs-lookup"><span data-stu-id="744ed-372">This method is the public version of the protected method, <xref:System.Random.Sample%2A>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="744ed-373">En el ejemplo siguiente se usa el <xref:System.Random.NextDouble%2A> método para generar secuencias de precisión doble aleatorios.</span><span class="sxs-lookup"><span data-stu-id="744ed-373">The following example uses the <xref:System.Random.NextDouble%2A> method to generate sequences of random doubles.</span></span>  
  
 [!code-cpp[System.Random.Ctor#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random.Ctor/CPP/ctor.cpp#1)]
 [!code-csharp[System.Random.Ctor#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random.Ctor/CS/ctor.cs#1)]
 [!code-vb[System.Random.Ctor#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random.Ctor/VB/ctor.vb#1)]  
  
 <span data-ttu-id="744ed-374">El ejemplo siguiente se llama el <xref:System.Random.NextDouble%2A> método para generar 100 aleatorio números y muestra su distribución de frecuencia.</span><span class="sxs-lookup"><span data-stu-id="744ed-374">The following example calls the <xref:System.Random.NextDouble%2A> method to generate 100 random numbers and displays their frequency distribution.</span></span>  
  
 [!code-csharp[System.Random.NextDouble#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.random.nextdouble/cs/nextdouble1.cs#2)]
 [!code-vb[System.Random.NextDouble#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.random.nextdouble/vb/nextdouble1.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Sample">
      <MemberSignature Language="C#" Value="protected virtual double Sample ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance float64 Sample() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Random.Sample" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function Sample () As Double" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual double Sample();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="744ed-375">Devuelve un número de punto flotante aleatorio entre 0,0 y 1,0.</span>
          <span class="sxs-lookup">
            <span data-stu-id="744ed-375">Returns a random floating-point number between 0.0 and 1.0.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="744ed-376">Número de punto flotante de doble precisión que es mayor o igual que 0,0 y menor que 1,0.</span>
          <span class="sxs-lookup">
            <span data-stu-id="744ed-376">A double-precision floating point number that is greater than or equal to 0.0, and less than 1.0.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="744ed-377">Para generar una distribución aleatoria distinta o un principio generador de números aleatorios diferentes, derive una clase de la <xref:System.Random> clase e invalidar el <xref:System.Random.Sample%2A> método.</span><span class="sxs-lookup"><span data-stu-id="744ed-377">To produce a different random distribution or a different random number generator principle, derive a class from the <xref:System.Random> class and override the <xref:System.Random.Sample%2A> method.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="744ed-378">El <xref:System.Random.Sample%2A> método es `protected`, lo que significa que es accesible únicamente dentro de la <xref:System.Random> clase y sus clases derivadas.</span><span class="sxs-lookup"><span data-stu-id="744ed-378">The <xref:System.Random.Sample%2A> method is `protected`, which means that it is accessible only within the <xref:System.Random> class and its derived classes.</span></span> <span data-ttu-id="744ed-379">Para generar un número aleatorio entre 0 y 1 de un <xref:System.Random> de la instancia, llame a la <xref:System.Random.NextDouble%2A> método.</span><span class="sxs-lookup"><span data-stu-id="744ed-379">To generate a random number between 0 and 1 from a <xref:System.Random> instance, call the <xref:System.Random.NextDouble%2A> method.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="744ed-380">En el ejemplo siguiente se deriva una clase de <xref:System.Random> e invalida el <xref:System.Random.Sample%2A> método para generar una distribución de números aleatorios.</span><span class="sxs-lookup"><span data-stu-id="744ed-380">The following example derives a class from <xref:System.Random> and overrides the <xref:System.Random.Sample%2A> method to generate a distribution of random numbers.</span></span> <span data-ttu-id="744ed-381">Esta distribución es diferente de la distribución uniforme generada por el <xref:System.Random.Sample%2A> método de la clase base.</span><span class="sxs-lookup"><span data-stu-id="744ed-381">This distribution is different than the uniform distribution generated by the <xref:System.Random.Sample%2A> method of the base class.</span></span>  
  
 [!code-cpp[System.Random.Sample#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random.Sample/cpp/sampleex.cpp#1)]
 [!code-csharp[System.Random.Sample#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random.Sample/CS/sample.cs#1)]
 [!code-vb[System.Random.Sample#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random.Sample/VB/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <span data-ttu-id="744ed-382">
            <para>A partir de .NET Framework versión 2.0, si se deriva una clase de <see cref="T:System.Random" /> e invalide el <see cref="M:System.Random.Sample" /> /método siguiente, la distribución proporcionada por la implementación de clase derivada de la <see cref="M:System.Random.Sample" /> método no se utiliza en las llamadas a la clase base implementación de los métodos siguientes: - la <see cref="M:System.Random.NextBytes(System.Byte[])" /> método.  -El <see cref="M:System.Random.Next" /> método.  -El <see cref="M:System.Random.Next(System.Int32,System.Int32)" /> método, si (<paramref name="maxValue" /> - <paramref name="minValue" />) es mayor que <see cref="F:System.Int32.MaxValue" />.  En su lugar, la distribución uniforme proporcionada por la base de <see cref="T:System.Random" /> se utiliza la clase. Este comportamiento mejora el rendimiento general de la <see cref="T:System.Random" /> clase. Para modificar este comportamiento para llamar a la implementación de la <see cref="M:System.Random.Sample" /> método en la clase derivada, también debe invalidar el comportamiento de estos tres miembros. El ejemplo proporciona una ilustración.</para>
          </span>
          <span class="sxs-lookup">
            <span data-stu-id="744ed-382">
              <para>Starting with the .NET Framework version 2.0, if you derive a class from <see cref="T:System.Random" /> and override the <see cref="M:System.Random.Sample" /> method, the distribution provided by the derived class implementation of the <see cref="M:System.Random.Sample" /> method is not used in calls to the base class implementation of the following methods:  -   The <see cref="M:System.Random.NextBytes(System.Byte[])" /> method.  -   The <see cref="M:System.Random.Next" /> method.  -   The <see cref="M:System.Random.Next(System.Int32,System.Int32)" /> method, if (<paramref name="maxValue" /> - <paramref name="minValue" />) is greater than <see cref="F:System.Int32.MaxValue" />.  Instead, the uniform distribution provided by the base <see cref="T:System.Random" /> class is used. This behavior improves the overall performance of the <see cref="T:System.Random" /> class. To modify this behavior to call the implementation of the <see cref="M:System.Random.Sample" /> method in the derived class, you must also override the behavior of these three members. The example provides an illustration.</para>
            </span>
          </span>
        </block>
        <altmember cref="M:System.Random.NextDouble" />
      </Docs>
    </Member>
  </Members>
</Type>