<Type Name="FlagsAttribute" FullName="System.FlagsAttribute">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="4b2417901d3ec970c72a2c6cc0524b2108855ce0" />
    <Meta Name="ms.sourcegitcommit" Value="6a0b904069161bbaec4ffd02aa7d9cf38c61e72e" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="es-ES" />
    <Meta Name="ms.lasthandoff" Value="06/24/2018" />
    <Meta Name="ms.locfileid" Value="36431669" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class FlagsAttribute : Attribute" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable beforefieldinit FlagsAttribute extends System.Attribute" />
  <TypeSignature Language="DocId" Value="T:System.FlagsAttribute" />
  <TypeSignature Language="VB.NET" Value="Public Class FlagsAttribute&#xA;Inherits Attribute" />
  <TypeSignature Language="C++ CLI" Value="public ref class FlagsAttribute : Attribute" />
  <TypeSignature Language="F#" Value="type FlagsAttribute = class&#xA;    inherit Attribute" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Attribute</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.AttributeUsage(System.AttributeTargets.Enum, Inherited=false)</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Indica que una enumeración se puede tratar como un campo de bits, es decir, un conjunto de marcas.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Campos de bits se utilizan normalmente para listas de elementos que pueden producirse en combinaciones, mientras que las constantes de enumeración se utilizan generalmente para listas de elementos mutuamente excluyentes. Por lo tanto, los campos de bits están diseñados para combinarse con una operación OR bit a bit para generar valores sin nombre, mientras que las constantes enumeradas que no lo son. Idiomas varían en su uso de campos de bits en comparación con las constantes de enumeración.  
  
## <a name="attributes-of-the-flagsattribute"></a>Atributos de FlagsAttribute  
 <xref:System.AttributeUsageAttribute> se aplica a esta clase y sus <xref:System.AttributeUsageAttribute.Inherited%2A> propiedad especifica `false`. Este atributo solo puede aplicarse a las enumeraciones.  
  
## <a name="guidelines-for-flagsattribute-and-enum"></a>Instrucciones para FlagsAttribute y Enum  
  
-   Use la <xref:System.FlagsAttribute> atributos personalizados para una enumeración solo si una operación bit a bit (AND, OR exclusivo o) se pueden realizar en un valor numérico.  
  
-   Definir constantes de enumeración en potencias de dos, es decir, 1, 2, 4, 8 y así sucesivamente. Esto significa que las marcas individuales en constantes de enumeración combinadas no se superpongan.  
  
-   Considere la creación de una constante enumerada para las combinaciones de indicadores utilizadas frecuentemente. Por ejemplo, si tiene una enumeración que se usa para las operaciones de E/S de archivo que contiene las constantes enumeradas `Read = 1` y `Write = 2`, considere la posibilidad de crear la constante enumerada `ReadWrite = Read OR Write`, que combina la `Read` y `Write` marcas. Además, la operación de OR bit a bit usada para combinar los indicadores se pueden considerar un concepto avanzado en algunas circunstancias que no debería ser necesario para tareas sencillas.  
  
-   Tenga cuidado si define un número negativo como constante enumerada del marcador porque muchas de las posiciones indicador pueden establecerse en 1, lo que podría hacer que el código confuso y le animamos a errores de codificación.  
  
-   Una manera cómoda para comprobar si se establece un indicador en un valor numérico es realizar una operación AND bit a bit entre el valor numérico y la constante enumerada de marca, que establece todos los bits del valor numérico en cero que no se corresponden con la marca , a continuación, pruebe si el resultado de esa operación es igual a la constante enumerada del indicador.  
  
-   Use `None` como el nombre de la marca enumerada constante cuyo valor es cero. No se puede utilizar el `None` constante enumerada en una operación AND bit a bit para probar un indicador porque el resultado siempre es cero. Sin embargo, puede realizar una operación lógica, no una comparación bit a bit, entre el valor numérico y el `None` constante enumerada para determinar si se establecen los bits del valor numérico.  
  
     Si crea un valor de enumeración en lugar de una enumeración de marcas, merece la pena seguir para crear un `None` constante enumerada. La razón es que, de forma predeterminada, la memoria utilizada para la enumeración se inicializa en cero por common language runtime. Por lo tanto, si no se define una constante cuyo valor es cero, la enumeración contendrá un valor no válido cuando se crea.  
  
     Si hay un caso predeterminado obvio que la aplicación necesita para representar, considere el uso de una constante enumerada cuyo valor sea cero para representar el valor predeterminado. Si no hay ningún caso predeterminado, considere la posibilidad de usar una constante enumerada cuyo valor sea cero que significa que el caso de que no está representado por cualquiera de las demás constantes enumeradas.  
  
-   No se define un valor de enumeración únicamente para reflejar el estado de la propia enumeración. Por ejemplo, no defina una constante enumerada que simplemente marca el final de la enumeración. Si necesita determinar el último valor de la enumeración, compruebe ese valor explícitamente. Además, puede realizar una comprobación de intervalo para la constante enumerada de primera y última si todos los valores dentro del intervalo son válidos.  
  
-   No especifique las constantes enumeradas que se han reservado para uso futuro.  
  
-   Cuando se define un método o propiedad que toma una constante enumerada como un valor, considere la posibilidad de validar el valor. La razón es que puede convertir un valor numérico para el tipo de enumeración incluso si dicho valor numérico no está definido en la enumeración.  
  
   
  
## Examples  
 En el ejemplo siguiente se muestra el uso de la `FlagsAttribute` de atributo y se muestra el efecto en el <xref:System.Enum.ToString%2A> método de utilizar `FlagsAttribute` en un <xref:System.Enum> declaración.  
  
 [!code-cpp[System.FlagsAttribute#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.FlagsAttribute/CPP/flags.cpp#1)]
 [!code-csharp[System.FlagsAttribute#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.FlagsAttribute/CS/flags.cs#1)]
 [!code-vb[System.FlagsAttribute#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.FlagsAttribute/VB/flags.vb#1)]  
  
 El siguiente ejemplo define dos enumeraciones relacionadas con el color, `SingleHue` y `MultiHue`. El segundo tiene la `FlagsAttribute` atributo; no es el primero. En el ejemplo se muestra la diferencia de comportamiento cuando un intervalo de enteros, incluidos los enteros que no representen valores subyacentes del tipo de enumeración, se convierte en el tipo de enumeración y sus representaciones de cadena que se muestra.   Por ejemplo, tenga en cuenta que 3 no se puede representar como un `SingleHue` valor porque 3 no es el valor subyacente de cualquier `SingleHue` miembro, mientras que la `FlagsAttribute` atributo hace posible representar 3 como un `MultiHue` valo `Black, Red`.  
  
 [!code-cpp[System.FlagsAttribute#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.FlagsAttribute/CPP/flags1.cpp#2)]
 [!code-csharp[System.FlagsAttribute#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.FlagsAttribute/CS/flags1.cs#2)]
 [!code-vb[System.FlagsAttribute#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.FlagsAttribute/VB/flags1.vb#2)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FlagsAttribute ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.FlagsAttribute.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FlagsAttribute();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.FlagsAttribute" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 En el ejemplo siguiente se define un `PhoneService` las enumeraciones que representan formas de comunicación proporcionada por una compañía telefónica. Se inicializa tres variables que representan el servicio proporcionado a los hogares diferentes tres y, a continuación, indica que los hogares no tienen ningún servicio, qué hogares tienen solo el servicio de teléfono móvil y los hogares tienen servicio de línea de teléfono móvil y terrenos. Por último, llama implícitamente el <xref:System.Enum.ToString%28System.String%29?displayProperty=nameWithType> método para mostrar los tipos de servicio proporcionado a cada núcleo.  
  
 [!code-cpp[System.FlagsAttribute#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.FlagsAttribute/CPP/flags1.cpp#2)]
 [!code-csharp[System.FlagsAttribute#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.FlagsAttribute/CS/flags1.cs#2)]
 [!code-vb[System.FlagsAttribute#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.FlagsAttribute/VB/flags1.vb#2)]  
  
 En el ejemplo siguiente se muestra el uso de la `FlagsAttribute` de atributo y se muestra el efecto en el <xref:System.Enum.ToString%2A> método de utilizar `FlagsAttribute` en un <xref:System.Enum> declaración.  
  
 [!code-cpp[System.FlagsAttribute#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.FlagsAttribute/CPP/flags.cpp#1)]
 [!code-csharp[System.FlagsAttribute#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.FlagsAttribute/CS/flags.cs#1)]
 [!code-vb[System.FlagsAttribute#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.FlagsAttribute/VB/flags.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>