<Type Name="Char" FullName="System.Char">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="f90130b026aaf3798579f0dc134e2a16e103fde2" />
    <Meta Name="ms.sourcegitcommit" Value="16d2d159872fd213cae4b8f371d7ae9c8b027c89" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="es-ES" />
    <Meta Name="ms.lasthandoff" Value="11/17/2018" />
    <Meta Name="ms.locfileid" Value="51889948" />
  </Metadata>
  <TypeSignature Language="C#" Value="public struct Char : IComparable, IComparable&lt;char&gt;, IConvertible, IEquatable&lt;char&gt;" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi serializable sealed beforefieldinit char extends System.ValueType implements class System.IComparable, class System.IComparable`1&lt;char&gt;, class System.IConvertible, class System.IEquatable`1&lt;char&gt;" />
  <TypeSignature Language="DocId" Value="T:System.Char" />
  <TypeSignature Language="VB.NET" Value="Public Structure Char&#xA;Implements IComparable, IComparable(Of Char), IConvertible, IEquatable(Of Char)" />
  <TypeSignature Language="C++ CLI" Value="public value class Char : IComparable, IComparable&lt;char&gt;, IConvertible, IEquatable&lt;char&gt;" />
  <TypeSignature Language="F#" Value="type char = struct&#xA;    interface IConvertible" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.ValueType</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IComparable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IComparable&lt;System.Char&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IConvertible</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IEquatable&lt;System.Char&gt;</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Representa un carácter como unidad de código UTF-16.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)] usa el <xref:System.Char> estructura para representar un carácter Unicode. El estándar Unicode identifica cada carácter Unicode con un número escalar de 21 bits único denominado punto de código y define el formato de codificación UTF-16 que especifica cómo se codifica un punto de código en una secuencia de uno o más valores de 16 bits. Cada valor de 16 bits comprendido entre hexadecimal 0 x 0000 a 0xFFFF y se almacena en un <xref:System.Char> estructura.  El valor de un <xref:System.Char> objeto es su valor numérico de 16 bits (ordinal).  
  
 Las secciones siguientes examinan la relación entre un <xref:System.Char> objeto y un carácter y se describen algunas tareas comunes realizadas con <xref:System.Char> instancias.  
  
 [Cadenas, caracteres Unicode y objetos Char](#Relationship)   
 [Caracteres y las categorías de caracteres](#Categories)   
 [Elementos de texto y caracteres adicionales.](#Elements)   
 [Operaciones comunes](#Operations)   
 [Interoperabilidad y valores char](#Interop)  
  
<a name="Relationship"></a>   
## <a name="char-objects-unicode-characters-and-strings"></a>Cadenas, caracteres Unicode y objetos Char  
 Un <xref:System.String> objeto es una colección secuencial de <xref:System.Char> estructuras que representa una cadena de texto. Mayoría de los caracteres Unicode se puede representar mediante un único <xref:System.Char> objeto, pero un carácter que se codifica como un carácter base, par suplente o combinación de secuencia de caracteres se representa mediante varias <xref:System.Char> objetos. Por este motivo, un <xref:System.Char> estructura en un <xref:System.String> objeto no es necesariamente equivalente a un único carácter Unicode.  
  
 Varias unidades de código de 16 bits se utilizan para representar caracteres Unicode en los casos siguientes:  
  
-   Glifos, que pueden constar de un solo carácter o de un carácter base seguido de uno o más caracteres de combinación. Por ejemplo, el carácter Unicote se representa mediante un <xref:System.Char> cuyo código está en la unidad U + 0061 seguido de un objeto <xref:System.Char> objeto cuya unidad de código es + u+0308. (El Unicote caracteres también puede definirse mediante una sola <xref:System.Char> objeto que tiene una unidad de código de 00E4 U +.) El ejemplo siguiente se muestra que el Unicote carácter consta de dos <xref:System.Char> objetos.  
  
     [!code-csharp[System.Char.Class#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.char.class/cs/grapheme1.cs#1)]
     [!code-vb[System.Char.Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.char.class/vb/grapheme1.vb#1)]  
  
-   Carácter fuera del plano multilingüe básico de Unicode (BMP). Unicode es compatible con dieciséis planos además del BMP, que representa el plano de 0. Un punto de código Unicode se representa en UTF-32 por un valor de 21 bits que incluye el plano. Por ejemplo, U + 1D160 representa el carácter de MUSICAL de OCTAVA símbolos. Dado que la codificación UTF-16 tiene solo de 16 bits, los caracteres fuera del BMP se representan mediante pares suplentes UTF-16. El ejemplo siguiente se muestra que el equivalente de UTF-32 de U + 1D160, el carácter de OCTAVA símbolo MUSICAL, U + D834 U + DD60. U + D834 es un suplente alto; intervalo de caracteres suplentes altos de U+D800 a U+DBFF. U + DD60 es un suplente bajo; intervalo de caracteres suplentes bajos u+DC00 a U+DFFF.  
  
     [!code-csharp[System.Char.Class#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.char.class/cs/surrogate1.cs#2)]
     [!code-vb[System.Char.Class#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.char.class/vb/surrogate1.vb#2)]  
  
<a name="Categories"></a>   
## <a name="characters-and-character-categories"></a>Caracteres y las categorías de caracteres  
 Cada carácter Unicode o par suplente válido pertenece a una categoría de Unicode. En .NET Framework, las categorías Unicode se representan mediante los miembros de la <xref:System.Globalization.UnicodeCategory> enumeración y no incluya valores como <xref:System.Globalization.UnicodeCategory.CurrencySymbol?displayProperty=nameWithType>, <xref:System.Globalization.UnicodeCategory.LowercaseLetter?displayProperty=nameWithType>, y <xref:System.Globalization.UnicodeCategory.SpaceSeparator?displayProperty=nameWithType>, por ejemplo.  
  
 Para determinar la categoría Unicode de un carácter, llame a la <xref:System.Char.GetUnicodeCategory%2A> método. Por ejemplo, en el ejemplo siguiente se llama el <xref:System.Char.GetUnicodeCategory%2A> para mostrar la categoría Unicode de cada carácter en una cadena.  
  
 [!code-csharp[System.Char.Class#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.char.class/cs/GetUnicodeCategory3.cs#6)]
 [!code-vb[System.Char.Class#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.char.class/vb/GetUnicodeCategory3.vb#6)]  
  
 Internamente, para los caracteres fuera del intervalo ASCII (U + 0000 a U + 00FF), el <xref:System.Char.GetUnicodeCategory%2A> método depende de las categorías Unicode notificadas por el <xref:System.Globalization.CharUnicodeInfo> clase. A partir de la [!INCLUDE[net_v462](~/includes/net-v462-md.md)], caracteres Unicode se clasifican según [el estándar Unicode, versión 8.0.0](https://www.unicode.org/versions/Unicode8.0.0/). En las versiones de .NET Framework desde el [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)] a la [!INCLUDE[net_v461](~/includes/net-v461-md.md)], se clasifican según [el estándar Unicode, versión 6.3.0](https://www.unicode.org/versions/Unicode6.3.0/).  
  
<a name="Elements"></a>   
## <a name="characters-and-text-elements"></a>Elementos de texto y caracteres adicionales.  
 Dado que un solo carácter puede representarse mediante varias <xref:System.Char> objetos, no siempre es significativo para trabajar con la persona <xref:System.Char> objetos. Por ejemplo, el siguiente ejemplo convierte los puntos de código Unicode que representan los números menores del 0 al 9 para unidades de código con codificación UTF-16. Porque equipara erróneamente <xref:System.Char> objetos con caracteres adicionales, de manera inexacta informa de que la cadena resultante tiene 20 caracteres.  
  
 [!code-csharp[System.Char.Class#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.char.class/cs/textelements2.cs#3)]
 [!code-vb[System.Char.Class#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.char.class/vb/textelements2.vb#3)]  
  
 Puede hacer lo siguiente para evitar la suposición de que un <xref:System.Char> objeto representa un único carácter.  
  
-   Puede trabajar con un <xref:System.String> objeto en su totalidad en lugar de trabajar con sus caracteres individuales para representar y analizar el contenido lingüístico.  
  
-   Puede usar el <xref:System.Globalization.StringInfo> clase para trabajar con elementos de texto en lugar de persona <xref:System.Char> objetos. En el ejemplo siguiente se usa el <xref:System.Globalization.StringInfo> objeto para contar el número de elementos de texto en una cadena que consta del Egeo números cero a nueve. Porque considera que un par suplente de un único carácter, se notifica correctamente que la cadena contiene diez caracteres.  
  
     [!code-csharp[System.Char.Class#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.char.class/cs/textelements2a.cs#4)]
     [!code-vb[System.Char.Class#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.char.class/vb/textelements2a.vb#4)]  
  
-   Si una cadena contiene un carácter base que tiene uno o más caracteres de combinación, puede llamar a la <xref:System.String.Normalize%2A?displayProperty=nameWithType> método para convertir la subcadena en una sola unidad de código con codificación UTF-16. El ejemplo siguiente se llama el <xref:System.String.Normalize%2A?displayProperty=nameWithType> método para convertir el carácter base u+0061 (A letra minúscula del alfabeto LATINO) y caracteres combinables + u+0308 (DIÉRESIS combinar) U + 00E4 (LATÍN pequeña letra A con DIÉRESIS).  
  
     [!code-csharp[System.Char.Class#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.char.class/cs/normalized.cs#5)]
     [!code-vb[System.Char.Class#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.char.class/vb/normalized.vb#5)]  
  
<a name="Operations"></a>   
## <a name="common-operations"></a>Operaciones comunes  
 El <xref:System.Char> estructura proporciona métodos para comparar <xref:System.Char> objetos, convertir el valor del elemento actual <xref:System.Char> a un objeto de otro tipo de objeto y determinar la categoría Unicode de un <xref:System.Char> objeto:  
  
|Para|Use estos `System.Char` métodos|  
|----------------|-------------------------------------|  
|Comparar <xref:System.Char> objetos|<xref:System.Char.CompareTo%2A> y <xref:System.Char.Equals%2A>|  
|Convertir un punto de código en una cadena|<xref:System.Char.ConvertFromUtf32%2A>|  
|Convertir un <xref:System.Char> objeto o un par suplente de <xref:System.Char> objetos a un punto de código|Para un único carácter: <xref:System.Convert.ToInt32%28System.Char%29?displayProperty=nameWithType><br /><br /> Para un par suplente o un carácter en una cadena: <xref:System.Char.ConvertToUtf32%2A?displayProperty=nameWithType>|  
|Obtiene la categoría de Unicode de un carácter|<xref:System.Char.GetUnicodeCategory%2A>|  
|Determinar si un carácter está en una categoría Unicode determinada como dígitos, letras, signos de puntuación, carácter de control etc.|<xref:System.Char.IsControl%2A>, <xref:System.Char.IsDigit%2A>, <xref:System.Char.IsHighSurrogate%2A>, <xref:System.Char.IsLetter%2A>, <xref:System.Char.IsLetterOrDigit%2A>, <xref:System.Char.IsLower%2A>, <xref:System.Char.IsLowSurrogate%2A>, <xref:System.Char.IsNumber%2A>, <xref:System.Char.IsPunctuation%2A>, <xref:System.Char.IsSeparator%2A>, <xref:System.Char.IsSurrogate%2A>, <xref:System.Char.IsSurrogatePair%2A>, <xref:System.Char.IsSymbol%2A>, <xref:System.Char.IsUpper%2A>, y <xref:System.Char.IsWhiteSpace%2A>|  
|Convertir un <xref:System.Char> objeto que representa un número en un tipo de valor numérico|<xref:System.Char.GetNumericValue%2A>|  
|Convierte un carácter en una cadena en un <xref:System.Char> objeto|<xref:System.Char.Parse%2A> y <xref:System.Char.TryParse%2A>|  
|Convertir un <xref:System.Char> objeto a un <xref:System.String> objeto|<xref:System.Char.ToString%2A>|  
|Cambiar el caso de un <xref:System.Char> objeto|<xref:System.Char.ToLower%2A>, <xref:System.Char.ToLowerInvariant%2A>, <xref:System.Char.ToUpper%2A> y <xref:System.Char.ToUpperInvariant%2A>|  
  
<a name="Interop"></a>   
## <a name="char-values-and-interop"></a>Interoperabilidad y valores char  
Cuando un administrado <xref:System.Char> tipo, que se representa como una unidad de código con codificación Unicode UTF-16, se pasa a código no administrado, el serializador de interoperabilidad convierte el carácter ANSI establecido de forma predeterminada. Puede aplicar el <xref:System.Runtime.InteropServices.DllImportAttribute> las declaraciones de invocación de atributo para la plataforma y el <xref:System.Runtime.InteropServices.StructLayoutAttribute> atributo a una declaración de interoperabilidad COM para controlar qué juego de caracteres un cálculo de referencias <xref:System.Char> tipo que utiliza.  
  
   
  
## Examples  
 El ejemplo de código siguiente muestra algunos de los métodos de <xref:System.Char>.  
  
 [!code-cpp[System.Char &#91;Type Level&#93;#23](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Char [Type Level]/CPP/charstructure.cpp#23)]
 [!code-csharp[System.Char &#91;Type Level&#93;#23](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Char [Type Level]/CS/charstructure.cs#23)]
 [!code-vb[System.Char &#91;Type Level&#93;#23](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Char [Type Level]/VB/charstructure.vb#23)]  
  
 ]]></format>
    </remarks>
    <threadsafe>Todos los miembros de este tipo son seguros para subprocesos. Los miembros que aparecen modificar el estado de instancia devuelven realmente una nueva instancia inicializada con el nuevo valor. Como con cualquier otro tipo, leer y escribir en una variable compartida que contiene una instancia de este tipo deben protegerse mediante un bloqueo para garantizar la seguridad para subprocesos.</threadsafe>
    <altmember cref="T:System.IComparable" />
    <altmember cref="T:System.IConvertible" />
    <altmember cref="T:System.String" />
  </Docs>
  <Members>
    <MemberGroup MemberName="CompareTo">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Compara esta instancia con un objeto o tipo de valor especificados e indica si esta instancia precede o sigue al objeto o tipo de valor especificado o aparece en la misma posición que él en el criterio de ordenación.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CompareTo">
      <MemberSignature Language="C#" Value="public int CompareTo (char value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 CompareTo(char value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.CompareTo(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Function CompareTo (value As Char) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int CompareTo(char value);" />
      <MemberSignature Language="F#" Value="abstract member CompareTo : char -&gt; int&#xA;override this.CompareTo : char -&gt; int" Usage="char.CompareTo value" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IComparable`1.CompareTo(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="value">Objeto <see cref="T:System.Char" /> que se va a comparar.</param>
        <summary>Compara esta instancia con un objeto <see cref="T:System.Char" /> especificado e indica si esta instancia precede o sigue al objeto <see cref="T:System.Char" /> especificado o aparece en la misma posición que él en el criterio de ordenación.</summary>
        <returns>Número con signo que indica la posición de esta instancia en el criterio de ordenación respecto al parámetro <paramref name="value" />.  
  
 <list type="table"><listheader><term> Valor devuelto 
 </term><description> Descripción 
 </description></listheader><item><term> Menor que cero 
 </term><description> Esta instancia precede a <paramref name="value" />.  
  
 </description></item><item><term> Cero 
 </term><description> En el criterio de ordenación, esta instancia tiene la misma posición que <paramref name="value" />.  
  
 </description></item><item><term> Mayor que cero 
 </term><description> Esta instancia es posterior a <paramref name="value" />.  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método implementa el <xref:System.IComparable%601?displayProperty=nameWithType> interfaz y realiza un poco mejor que el <xref:System.Char.CompareTo%2A?displayProperty=nameWithType> método porque no tiene que convertir el `value` parámetro a un objeto.  
  
 La comparación realizada por este método se basa en los valores codificados de esta instancia y `value`, no en sus características lexicográficas.  
  
 Si el <xref:System.Char.CompareTo%2A> tipo de parámetro de método tiene menos bits (es más estrecho) que el tipo de instancia, algunos lenguajes de programación realizan una conversión de ampliación implícita que transforma el valor del parámetro en un valor con más bits.  
  
 Por ejemplo, suponga que el tipo de instancia es <xref:System.Int32> y el tipo de parámetro es <xref:System.Byte>. El compilador de Microsoft C# genera instrucciones para representar el valor del parámetro como un <xref:System.Int32> objeto, a continuación, genera un <xref:System.Int32.CompareTo%2A?displayProperty=nameWithType> método que compara los valores de la <xref:System.Int32> instancia y el <xref:System.Int32> parámetro representación.  
  
 Normalmente, las conversiones de ampliación implícitas se realizan en tipos numéricos. Consulte la documentación de su lenguaje de programación para determinar si el compilador realiza las conversiones de ampliación. Si no está disponible la discordancia de tipos de instancia y los parámetros y una conversión adecuada, el compilador genera instrucciones cuadro del parámetro e invocar el <xref:System.Char.CompareTo%2A> sobrecarga que toma un <xref:System.Object> parámetro.  
  
   
  
## Examples  
 El ejemplo de código siguiente muestra las versiones no genéricas y de la `CompareTo` método para varios tipos de valor y de referencia.  
  
 [!code-cpp[T.CompareTo#1](~/samples/snippets/cpp/VS_Snippets_CLR/T.CompareTo/CPP/cat.cpp#1)]
 [!code-csharp[T.CompareTo#1](~/samples/snippets/csharp/VS_Snippets_CLR/T.CompareTo/CS/cat.cs#1)]
 [!code-vb[T.CompareTo#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/T.CompareTo/VB/cat.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.IComparable" />
        <altmember cref="M:System.Char.Equals(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="CompareTo">
      <MemberSignature Language="C#" Value="public int CompareTo (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 CompareTo(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.CompareTo(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function CompareTo (value As Object) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int CompareTo(System::Object ^ value);" />
      <MemberSignature Language="F#" Value="abstract member CompareTo : obj -&gt; int&#xA;override this.CompareTo : obj -&gt; int" Usage="char.CompareTo value" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IComparable.CompareTo(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">Objeto que se va a comparar con esta instancia o <see langword="null" />.</param>
        <summary>Compara esta instancia con un objeto <see cref="T:System.Object" /> especificado e indica si esta instancia precede o sigue al objeto especificado o aparece en la misma posición que él en el criterio de ordenación.</summary>
        <returns>Número con signo que indica la posición de esta instancia en el criterio de ordenación respecto al parámetro <paramref name="value" />.  
  
 <list type="table"><listheader><term> Valor devuelto 
 </term><description> Descripción 
 </description></listheader><item><term> Menor que cero 
 </term><description> Esta instancia precede a <paramref name="value" />.  
  
 </description></item><item><term> Cero 
 </term><description> En el criterio de ordenación, esta instancia tiene la misma posición que <paramref name="value" />.  
  
 </description></item><item><term> Mayor que cero 
 </term><description> Esta instancia es posterior a <paramref name="value" />.  
  
O bien 
 El valor de <paramref name="value" /> es <see langword="null" />.  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Char.CompareTo%2A> método implementa el <xref:System.IComparable> interfaz.  
  
 El `value` parámetro debe ser `null` o una instancia de <xref:System.Char>; de lo contrario, se produce una excepción.  
  
 La comparación realizada por este método se basa en los valores codificados de esta instancia y `value`, no necesariamente en sus características lexicográficas. Cualquier instancia de <xref:System.Char>, independientemente de su valor, se considera mayor `null`.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra <xref:System.Char.CompareTo%2A>.  
  
 [!code-cpp[System.Char.CompareTo#19](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Char.CompareTo/CPP/compareto.cpp#19)]
 [!code-csharp[System.Char.CompareTo#19](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Char.CompareTo/CS/compareto.cs#19)]
 [!code-vb[System.Char.CompareTo#19](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Char.CompareTo/VB/compareto.vb#19)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="value" /> no es un objeto <see cref="T:System.Char" />.</exception>
        <altmember cref="T:System.IComparable" />
        <altmember cref="M:System.Char.Equals(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="ConvertFromUtf32">
      <MemberSignature Language="C#" Value="public static string ConvertFromUtf32 (int utf32);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string ConvertFromUtf32(int32 utf32) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.ConvertFromUtf32(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ConvertFromUtf32 (utf32 As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ ConvertFromUtf32(int utf32);" />
      <MemberSignature Language="F#" Value="static member ConvertFromUtf32 : int -&gt; string" Usage="System.char.ConvertFromUtf32 utf32" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="utf32" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="utf32">Punto de código Unicode de 21 bits.</param>
        <summary>Convierte el punto de código Unicode especificado en una cadena codificada mediante UTF-16.</summary>
        <returns>Cadena que está compuesta de un objeto <see cref="T:System.Char" /> o un par suplente de objetos <see cref="T:System.Char" /> que equivalen al punto de código especificado por el parámetro <paramref name="utf32" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilice este método para convertir un punto de código Unicode de 21 bits en una cadena codificada en UTF-16 antes de probar la cadena con métodos como <xref:System.Char.IsLowSurrogate%28System.Char%29> y <xref:System.Char.IsHighSurrogate%28System.Char%29>.  
  
 Un punto de código válido fuera el plano multilingüe básico (BMP) siempre produce un par suplente válido. Sin embargo, un punto de código válido dentro de BMP podría no producir un resultado válido según el estándar Unicode porque no se utiliza ningún procesamiento lingüístico en la conversión. Por ese motivo, utilice el <xref:System.Text.UTF32Encoding?displayProperty=nameWithType> clase para convertir de forma masiva datos UTF-32 en forma masiva datos UTF-16.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra el <xref:System.Char.ConvertToUtf32%2A> y <xref:System.Char.ConvertFromUtf32%2A> métodos.  
  
 [!code-cpp[char.cvtutf32#1](~/samples/snippets/cpp/VS_Snippets_CLR/char.cvtutf32/CPP/utf.cpp#1)]
 [!code-csharp[char.cvtutf32#1](~/samples/snippets/csharp/VS_Snippets_CLR/char.cvtutf32/CS/utf.cs#1)]
 [!code-vb[char.cvtutf32#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/char.cvtutf32/VB/utf.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="utf32" /> no es un punto de código Unicode válido de 21 bits comprendido entre U+0 y U+10FFFF, excluyendo el intervalo del par suplente de U+D800 a U+DFFF.</exception>
        <altmember cref="M:System.Char.ConvertToUtf32(System.Char,System.Char)" />
        <altmember cref="T:System.Text.UTF32Encoding" />
      </Docs>
    </Member>
    <MemberGroup MemberName="ConvertToUtf32">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Convierte el valor de un par suplente codificado mediante UTF-16 en un punto de código Unicode.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ConvertToUtf32">
      <MemberSignature Language="C#" Value="public static int ConvertToUtf32 (char highSurrogate, char lowSurrogate);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 ConvertToUtf32(char highSurrogate, char lowSurrogate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.ConvertToUtf32(System.Char,System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ConvertToUtf32 (highSurrogate As Char, lowSurrogate As Char) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int ConvertToUtf32(char highSurrogate, char lowSurrogate);" />
      <MemberSignature Language="F#" Value="static member ConvertToUtf32 : char * char -&gt; int" Usage="System.char.ConvertToUtf32 (highSurrogate, lowSurrogate)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="highSurrogate" Type="System.Char" />
        <Parameter Name="lowSurrogate" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="highSurrogate">Unidad de código suplente alto (es decir, una unidad de código que va de U+D800 a U+DBFF).</param>
        <param name="lowSurrogate">Unidad de código suplente bajo (es decir, una unidad de código que va de U+DC00 a U+DFFF).</param>
        <summary>Convierte el valor de un par suplente codificado mediante UTF-16 en un punto de código Unicode.</summary>
        <returns>Punto de código Unicode de 21 bits que representan los parámetros <paramref name="highSurrogate" /> y <paramref name="lowSurrogate" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilice este método para convertir a un par suplente en un punto de código Unicode de 21 bits. Para convertir datos UTF-16 en datos UTF-32, utilice el <xref:System.Text.UTF32Encoding?displayProperty=nameWithType> clase.  
  
 Normalmente, la codificación UTF-16 representa un único carácter Unicode como una unidad de código de 16 bits. Sin embargo, también admite pares suplentes, que permiten un único carácter abstracto para representarse como dos unidades de código de 16 bits. Estos dos <xref:System.Char> objetos deben tener unidades de código de ese intervalo de U+D800 a U+DBFF, para el primer suplente (alto) y de U+DC00 a U+DFFF para el segundo suplente (bajo). Los pares suplentes son compatibles únicamente con UTF-16 de codificación. Este método permite un carácter representado por un par suplente UTF-16 para convertirse en un carácter mediante la codificación UTF-32.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra el <xref:System.Char.ConvertToUtf32%2A> y <xref:System.Char.ConvertFromUtf32%2A> métodos.  
  
 [!code-cpp[char.cvtutf32#1](~/samples/snippets/cpp/VS_Snippets_CLR/char.cvtutf32/CPP/utf.cpp#1)]
 [!code-csharp[char.cvtutf32#1](~/samples/snippets/csharp/VS_Snippets_CLR/char.cvtutf32/CS/utf.cs#1)]
 [!code-vb[char.cvtutf32#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/char.cvtutf32/VB/utf.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="highSurrogate" /> no está en el intervalo de U+D800 a U+DBFF, o <paramref name="lowSurrogate" /> no está en el intervalo de U+DC00 a U+DFFF.</exception>
        <altmember cref="M:System.Char.ConvertFromUtf32(System.Int32)" />
        <altmember cref="T:System.Text.UTF32Encoding" />
      </Docs>
    </Member>
    <Member MemberName="ConvertToUtf32">
      <MemberSignature Language="C#" Value="public static int ConvertToUtf32 (string s, int index);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 ConvertToUtf32(string s, int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.ConvertToUtf32(System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ConvertToUtf32 (s As String, index As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int ConvertToUtf32(System::String ^ s, int index);" />
      <MemberSignature Language="F#" Value="static member ConvertToUtf32 : string * int -&gt; int" Usage="System.char.ConvertToUtf32 (s, index)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="s">Cadena que contiene un carácter o par suplente.</param>
        <param name="index">Posición de índice del carácter o par suplente en <c>s</c>.</param>
        <summary>Convierte el valor de un par suplente o carácter codificado mediante UTF-16 que está situado en una posición concreta de una cadena en un punto de código Unicode.</summary>
        <returns>Punto de código Unicode de 21 bits representado por el carácter o par suplente situado en la posición del parámetro <paramref name="s" /> que especifica el parámetro <paramref name="index" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilice este método para convertir a un carácter o par suplente en un punto de código Unicode de 21 bits. Para convertir datos UTF-16 en datos UTF-32, utilice el <xref:System.Text.UTF32Encoding?displayProperty=nameWithType> clase.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra el <xref:System.Char.ConvertToUtf32%2A> y <xref:System.Char.ConvertFromUtf32%2A> métodos.  
  
 [!code-cpp[char.cvtutf32#1](~/samples/snippets/cpp/VS_Snippets_CLR/char.cvtutf32/CPP/utf.cpp#1)]
 [!code-csharp[char.cvtutf32#1](~/samples/snippets/csharp/VS_Snippets_CLR/char.cvtutf32/CS/utf.cs#1)]
 [!code-vb[char.cvtutf32#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/char.cvtutf32/VB/utf.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El valor de <paramref name="s" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> no es una posición dentro de <paramref name="s" />.</exception>
        <exception cref="T:System.ArgumentException">La posición de índice especificada contiene un par suplente y el primer carácter del par no es un suplente alto válido o el segundo carácter del par no es un suplente bajo válido.</exception>
        <altmember cref="M:System.Char.ConvertFromUtf32(System.Int32)" />
        <altmember cref="T:System.Text.UTF32Encoding" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Equals">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Devuelve un valor que indica si esta instancia es igual a un objeto o a un valor <see cref="T:System.Char" /> especificado.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public bool Equals (char obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Equals(char obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.Equals(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Function Equals (obj As Char) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Equals(char obj);" />
      <MemberSignature Language="F#" Value="override this.Equals : char -&gt; bool" Usage="char.Equals obj" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IEquatable`1.Equals(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="obj">Un objeto que se va a comparar con esta instancia.</param>
        <summary>Devuelve un valor que indica si esta instancia es igual que el objeto <see cref="T:System.Char" /> especificado.</summary>
        <returns>
          <see langword="true" /> si el parámetro <paramref name="obj" /> es igual al valor de esta instancia; en caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método implementa el <xref:System.IEquatable%601?displayProperty=nameWithType> interfaz y realiza un poco mejor que <xref:System.Char.Equals%28System.Object%29?displayProperty=nameWithType> porque no es necesario aplicar conversión unboxing a la `obj` parámetro.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Char.Equals(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (obj As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="override this.Equals : obj -&gt; bool" Usage="char.Equals obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">Objeto que se va a comparar con esta instancia o <see langword="null" />.</param>
        <summary>Devuelve un valor que indica si esta instancia es igual que un objeto especificado.</summary>
        <returns>Es <see langword="true" /> si <paramref name="obj" /> es una instancia de <see cref="T:System.Char" /> y es igual al valor de esta instancia; en caso contrario, es <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La comparación realizada por este método se basa en los valores codificados de esta instancia y `obj`, no necesariamente en sus características lexicográficas.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra <xref:System.Char.Equals%2A>.  
  
 [!code-cpp[System.Char.Equals#20](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Char.Equals/CPP/equals.cpp#20)]
 [!code-csharp[System.Char.Equals#20](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Char.Equals/CS/equals.cs#20)]
 [!code-vb[System.Char.Equals#20](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Char.Equals/VB/equals.vb#20)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Char.CompareTo(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="char.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Devuelve el código hash de esta instancia.</summary>
        <returns>Código hash de un entero de 32 bits con signo.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetNumericValue">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Convierte un carácter Unicode numérico especificado en un número de punto flotante de precisión doble.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetNumericValue">
      <MemberSignature Language="C#" Value="public static double GetNumericValue (char c);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 GetNumericValue(char c) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.GetNumericValue(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetNumericValue (c As Char) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double GetNumericValue(char c);" />
      <MemberSignature Language="F#" Value="static member GetNumericValue : char -&gt; double" Usage="System.char.GetNumericValue c" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="c" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="c">Carácter Unicode que se va a convertir.</param>
        <summary>Convierte el carácter Unicode numérico especificado en un número de punto flotante de precisión doble.</summary>
        <returns>Valor numérico de <paramref name="c" /> si dicho carácter representa un número; en caso contrario, -1,0.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El `c` parámetro debe ser el <xref:System.Char> representación de un valor numérico. Por ejemplo, si `c` es "5", el valor devuelto es 5. Sin embargo, si `c` es la "z", el valor devuelto es -1,0.  
  
 Un carácter tiene un valor numérico asociado sólo si se trata de un miembro de uno de los siguientes <xref:System.Globalization.UnicodeCategory> categorías: `DecimalDigitNumber`, `LetterNumber`, o `OtherNumber`.  
  
 El <xref:System.Char.GetNumericValue%2A> método supone que `c` corresponde a un único carácter lingüístico y comprueba si dicho carácter puede convertirse en un dígito decimal. Sin embargo, algunos números en el estándar Unicode están representadas por dos <xref:System.Char> objetos que forman un par suplente. Por ejemplo, el sistema de numeración de Egeo consta de 10107 U + U + 10133 a través de los puntos de código. En el ejemplo siguiente se usa el <xref:System.Char.ConvertFromUtf32%2A> método para crear instancias de una cadena que representa el número uno de menores. Como la salida muestra el ejemplo, el <xref:System.Char.GetNumericValue%28System.Char%29> método devuelve -1 si se pasa un suplente alto o un suplente bajo de este carácter.  
  
 [!code-csharp[System.Char.GetNumericValue#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Char.GetNumericValue/CS/getnumericvalue1.cs#2)]
 [!code-vb[System.Char.GetNumericValue#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Char.GetNumericValue/VB/getnumericvalue1.vb#2)]  
  
   
  
## Examples  
 En el ejemplo siguiente se muestra <xref:System.Char.GetNumericValue%2A>.  
  
 [!code-cpp[System.Char.GetNumericValue#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Char.GetNumericValue/CPP/getnumericvalue.cpp#1)]
 [!code-csharp[System.Char.GetNumericValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Char.GetNumericValue/CS/getnumericvalue.cs#1)]
 [!code-vb[System.Char.GetNumericValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Char.GetNumericValue/VB/getnumericvalue.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetNumericValue">
      <MemberSignature Language="C#" Value="public static double GetNumericValue (string s, int index);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 GetNumericValue(string s, int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.GetNumericValue(System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetNumericValue (s As String, index As Integer) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double GetNumericValue(System::String ^ s, int index);" />
      <MemberSignature Language="F#" Value="static member GetNumericValue : string * int -&gt; double" Usage="System.char.GetNumericValue (s, index)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="s">Objeto <see cref="T:System.String" />.</param>
        <param name="index">Posición de caracteres en <c>s</c>.</param>
        <summary>Convierte el carácter Unicode numérico situado en la posición especificada de una cadena especificada en un número de punto flotante de precisión doble.</summary>
        <returns>Valor numérico del carácter que ocupa la posición <paramref name="index" /> en <paramref name="s" /> si dicho carácter representa un número; en caso contrario, -1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El `s` parámetro debe ser la representación de cadena de un valor numérico. Por ejemplo, si el carácter que ocupa la posición `index` en `s` es "5", el valor devuelto es 5. Sin embargo, si el carácter que ocupa la posición `index` en `s` es la "z", el valor devuelto es -1.  
  
 Posiciones de caracteres en una cadena se indizan empezando desde cero.  
  
 Un carácter tiene un valor numérico asociado sólo si se trata de un miembro de uno de los siguientes <xref:System.Globalization.UnicodeCategory> categorías: `DecimalDigitNumber`, `LetterNumber`, o `OtherNumber`.  
  
 Si el <xref:System.Char> objeto en la posición `index` es el primer carácter de un par suplente válido, el <xref:System.Char.GetNumericValue%28System.String%2CSystem.Int32%29> método determina si el par suplente forms un dígito numérico. Por ejemplo, el sistema de numeración de Egeo consta de 10107 U + U + 10133 a través de los puntos de código. En el ejemplo siguiente se usa el <xref:System.Char.ConvertFromUtf32%2A> método para crear instancias de una cadena que representa cada número menores. Como la salida muestra el ejemplo, el <xref:System.Char.GetNumericValue%28System.String%2CSystem.Int32%29> método devuelve el valor numérico correcto si se pasa el suplente alto de un número de menores. Sin embargo, si se pasa al suplente bajo, considere a solo el suplente bajo de forma aislada y devuelve -1.  
  
 [!code-csharp[System.Char.GetNumericValue#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Char.GetNumericValue/CS/getnumericvalue1.cs#3)]
 [!code-vb[System.Char.GetNumericValue#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Char.GetNumericValue/VB/getnumericvalue1.vb#3)]  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra <xref:System.Char.GetNumericValue%2A>.  
  
 [!code-cpp[System.Char.GetNumericValue#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Char.GetNumericValue/CPP/getnumericvalue.cpp#1)]
 [!code-csharp[System.Char.GetNumericValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Char.GetNumericValue/CS/getnumericvalue.cs#1)]
 [!code-vb[System.Char.GetNumericValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Char.GetNumericValue/VB/getnumericvalue.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El valor de <paramref name="s" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> es menor que cero o mayor que la última posición en <paramref name="s" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetTypeCode">
      <MemberSignature Language="C#" Value="public TypeCode GetTypeCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.TypeCode GetTypeCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.GetTypeCode" />
      <MemberSignature Language="VB.NET" Value="Public Function GetTypeCode () As TypeCode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual TypeCode GetTypeCode();" />
      <MemberSignature Language="F#" Value="abstract member GetTypeCode : unit -&gt; TypeCode&#xA;override this.GetTypeCode : unit -&gt; TypeCode" Usage="char.GetTypeCode " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.GetTypeCode</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.TypeCode</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Devuelve el <see cref="T:System.TypeCode" /> para el tipo de valor <see cref="T:System.Char" />.</summary>
        <returns>Constante enumerada, <see cref="F:System.TypeCode.Char" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetUnicodeCategory">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Clasifica un carácter Unicode dentro de un grupo identificado por uno de los valores de <see cref="T:System.Globalization.UnicodeCategory" />.</summary>
        <altmember cref="M:System.Globalization.CharUnicodeInfo.GetUnicodeCategory(System.Char)" />
      </Docs>
    </MemberGroup>
    <Member MemberName="GetUnicodeCategory">
      <MemberSignature Language="C#" Value="public static System.Globalization.UnicodeCategory GetUnicodeCategory (char c);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Globalization.UnicodeCategory GetUnicodeCategory(char c) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.GetUnicodeCategory(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetUnicodeCategory (c As Char) As UnicodeCategory" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Globalization::UnicodeCategory GetUnicodeCategory(char c);" />
      <MemberSignature Language="F#" Value="static member GetUnicodeCategory : char -&gt; System.Globalization.UnicodeCategory" Usage="System.char.GetUnicodeCategory c" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Globalization.UnicodeCategory</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="c" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="c">Carácter Unicode que se va a clasificar por categorías.</param>
        <summary>Clasifica un carácter Unicode especificado dentro de un grupo identificado por uno de los valores de <see cref="T:System.Globalization.UnicodeCategory" />.</summary>
        <returns>Valor de <see cref="T:System.Globalization.UnicodeCategory" /> que identifica el grupo que contiene <paramref name="c" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Char.GetUnicodeCategory%2A?displayProperty=nameWithType> método no siempre devuelven el mismo <xref:System.Globalization.UnicodeCategory> valor como el <xref:System.Globalization.CharUnicodeInfo.GetUnicodeCategory%28System.Char%29?displayProperty=nameWithType> cuando se pasa un carácter determinado como un parámetro de método. El <xref:System.Globalization.CharUnicodeInfo.GetUnicodeCategory%28System.Char%29?displayProperty=nameWithType> método está diseñado para reflejar la versión actual del estándar Unicode. En cambio, aunque el <xref:System.Char.GetUnicodeCategory%2A?displayProperty=nameWithType> método normalmente refleja la versión actual del estándar Unicode, puede devolver la categoría de un carácter basándose en una versión anterior del estándar o puede devolver una categoría que difiera del estándar en orden para mantener la compatibilidad con versiones anteriores. Como resultado, se recomienda que utilice el <xref:System.Globalization.CharUnicodeInfo.GetUnicodeCategory%28System.Char%29?displayProperty=nameWithType> método en lugar de <xref:System.Char.GetUnicodeCategory%28System.Char%29?displayProperty=nameWithType>.  
  
 A partir de la [!INCLUDE[net_v462](~/includes/net-v462-md.md)], caracteres Unicode se clasifican según [el estándar de Unix, versión 8.0.0](https://www.unicode.org/versions/Unicode8.0.0/). En las versiones de .NET Framework desde el [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)] a la [!INCLUDE[net_v461](~/includes/net-v461-md.md)], se clasifican según [el estándar de Unix, versión 6.3.0](https://www.unicode.org/versions/Unicode6.3.0/).  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra <xref:System.Char.GetUnicodeCategory%2A>.  
  
 [!code-cpp[System.Char.GetUnicodeCategory#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Char.GetUnicodeCategory/CPP/getunicodecategory.cpp#1)]
 [!code-csharp[System.Char.GetUnicodeCategory#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Char.GetUnicodeCategory/CS/getunicodecategory.cs#1)]
 [!code-vb[System.Char.GetUnicodeCategory#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Char.GetUnicodeCategory/VB/getunicodecategory.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Globalization.CharUnicodeInfo.GetUnicodeCategory(System.Char)" />
      </Docs>
    </Member>
    <Member MemberName="GetUnicodeCategory">
      <MemberSignature Language="C#" Value="public static System.Globalization.UnicodeCategory GetUnicodeCategory (string s, int index);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Globalization.UnicodeCategory GetUnicodeCategory(string s, int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.GetUnicodeCategory(System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetUnicodeCategory (s As String, index As Integer) As UnicodeCategory" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Globalization::UnicodeCategory GetUnicodeCategory(System::String ^ s, int index);" />
      <MemberSignature Language="F#" Value="static member GetUnicodeCategory : string * int -&gt; System.Globalization.UnicodeCategory" Usage="System.char.GetUnicodeCategory (s, index)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Globalization.UnicodeCategory</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="s">Objeto <see cref="T:System.String" />.</param>
        <param name="index">Posición de caracteres en <c>s</c>.</param>
        <summary>Clasifica el carácter que ocupa la posición especificada en una cadena especificada dentro de un grupo identificado por uno de los valores de <see cref="T:System.Globalization.UnicodeCategory" />.</summary>
        <returns>Constante enumerada <see cref="T:System.Globalization.UnicodeCategory" /> que identifica el grupo que contiene el carácter que ocupa la posición <paramref name="index" /> en <paramref name="s" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Posiciones de caracteres en una cadena se indizan empezando desde cero.  
  
 El <xref:System.Char.GetUnicodeCategory%2A?displayProperty=nameWithType> método no siempre devuelven el mismo <xref:System.Globalization.UnicodeCategory> valor como el <xref:System.Globalization.CharUnicodeInfo.GetUnicodeCategory%28System.String%2CSystem.Int32%29?displayProperty=nameWithType> cuando se pasa un carácter determinado como un parámetro de método. El <xref:System.Globalization.CharUnicodeInfo.GetUnicodeCategory%28System.String%2CSystem.Int32%29?displayProperty=nameWithType> método está diseñado para reflejar la versión actual del estándar Unicode. En cambio, aunque el <xref:System.Char.GetUnicodeCategory%2A?displayProperty=nameWithType> método normalmente refleja la versión actual del estándar Unicode, puede devolver la categoría de un carácter basándose en una versión anterior del estándar o puede devolver una categoría que difiera del estándar en orden para mantener la compatibilidad con versiones anteriores. Como resultado, se recomienda que utilice el <xref:System.Globalization.CharUnicodeInfo.GetUnicodeCategory%28System.Char%29?displayProperty=nameWithType> método en lugar de <xref:System.Char.GetUnicodeCategory%28System.String%2CSystem.Int32%29?displayProperty=nameWithType>.  
  
 A partir de la [!INCLUDE[net_v462](~/includes/net-v462-md.md)], caracteres Unicode se clasifican según [el estándar de Unix, versión 8.0.0](https://www.unicode.org/versions/Unicode8.0.0/). En las versiones de .NET Framework desde el [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)] a la [!INCLUDE[net_v461](~/includes/net-v461-md.md)], se clasifican según [el estándar de Unix, versión 6.3.0](https://www.unicode.org/versions/Unicode6.3.0/).  
  
   
  
## Examples  
 En el ejemplo siguiente se muestra <xref:System.Char.GetUnicodeCategory%2A>.  
  
 [!code-cpp[System.Char.GetUnicodeCategory#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Char.GetUnicodeCategory/CPP/getunicodecategory.cpp#1)]
 [!code-csharp[System.Char.GetUnicodeCategory#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Char.GetUnicodeCategory/CS/getunicodecategory.cs#1)]
 [!code-vb[System.Char.GetUnicodeCategory#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Char.GetUnicodeCategory/VB/getunicodecategory.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El valor de <paramref name="s" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> es menor que cero o mayor que la última posición en <paramref name="s" />.</exception>
        <altmember cref="M:System.Globalization.CharUnicodeInfo.GetUnicodeCategory(System.Char)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="IsControl">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Indica si un carácter Unicode especificado se clasifica por categorías como un carácter de control.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se da formato los caracteres de control y otros caracteres no imprimibles, por ejemplo, confirmación, BEL, CR, FF, LF y VT. El estándar Unicode asigna los puntos de código desde \U0000 a \U001F, \U007F y de \U0080 a \U009F a caracteres de control. Según el estándar Unicode, estos valores tienen que interpretarse como caracteres de control, a menos que su uso en caso contrario, se define mediante una aplicación. Caracteres de control válidos son miembros de la <xref:System.Globalization.UnicodeCategory.Control?displayProperty=nameWithType> categoría.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="IsControl">
      <MemberSignature Language="C#" Value="public static bool IsControl (char c);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsControl(char c) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.IsControl(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsControl (c As Char) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsControl(char c);" />
      <MemberSignature Language="F#" Value="static member IsControl : char -&gt; bool" Usage="System.char.IsControl c" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="c" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="c">Carácter Unicode que se va a evaluar.</param>
        <summary>Indica si el carácter Unicode especificado se clasifica por categorías como un carácter de control.</summary>
        <returns>Es <see langword="true" /> si <paramref name="c" /> es un carácter de control; en caso contrario, es <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se da formato los caracteres de control y otros caracteres no imprimibles, por ejemplo, confirmación, BEL, CR, FF, LF y VT. El estándar de Unicode T asigna los puntos de código desde \U0000 a \U001F, \U007F y de \U0080 a \U009F a caracteres de control. Según el estándar Unicode, estos valores tienen que interpretarse como caracteres de control, a menos que su uso en caso contrario, se define mediante una aplicación. Caracteres de control válidos son miembros de la <xref:System.Globalization.UnicodeCategory.Control?displayProperty=nameWithType> categoría.  
  
   
  
## Examples  
 El ejemplo siguiente muestra el punto de código Unicode de cada uno de los caracteres de control.  
  
 [!code-cpp[System.Char.IsControl#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Char.IsControl/CPP/iscontrol1.cpp#1)]
 [!code-csharp[System.Char.IsControl#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Char.IsControl/CS/IsControl1.cs#1)]
 [!code-vb[System.Char.IsControl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Char.IsControl/VB/IsControl1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsControl">
      <MemberSignature Language="C#" Value="public static bool IsControl (string s, int index);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsControl(string s, int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.IsControl(System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsControl (s As String, index As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsControl(System::String ^ s, int index);" />
      <MemberSignature Language="F#" Value="static member IsControl : string * int -&gt; bool" Usage="System.char.IsControl (s, index)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="s">Una cadena.</param>
        <param name="index">Posición del carácter que se va a evaluar en <c>s</c>.</param>
        <summary>Indica si el carácter que ocupa la posición especificada en una cadena especificada se clasifica por categorías como un carácter de control.</summary>
        <returns>
          <see langword="true" /> si el carácter que ocupa la posición <paramref name="index" /> en <paramref name="s" /> es un carácter de control; en caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Posiciones de caracteres en una cadena se indizan empezando desde cero.  
  
 Se da formato los caracteres de control y otros caracteres no imprimibles, por ejemplo, confirmación, BEL, CR, FF, LF y VT. El estándar Unicode asigna los puntos de código desde \U0000 a \U001F, \U007F y de \U0080 a \U009F a caracteres de control. Según el estándar Unicode, estos valores tienen que interpretarse como caracteres de control, a menos que su uso en caso contrario, se define mediante una aplicación. Caracteres de control válidos son miembros de la <xref:System.Globalization.UnicodeCategory.Control?displayProperty=nameWithType> categoría.  
  
   
  
## Examples  
 El ejemplo siguiente enumera los caracteres de una cadena y determina si alguno es un carácter de control.  
  
 [!code-cpp[System.Char.IsControl#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Char.IsControl/CPP/iscontrol2.cpp#2)]
 [!code-csharp[System.Char.IsControl#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Char.IsControl/CS/IsControl2.cs#2)]
 [!code-vb[System.Char.IsControl#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Char.IsControl/VB/IsControl2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El valor de <paramref name="s" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> es menor que cero o mayor que la última posición en <paramref name="s" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="IsDigit">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Indica si un carácter Unicode se clasifica por categorías como un dígito decimal.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dígitos válidos son miembros de la <xref:System.Globalization.UnicodeCategory.DecimalDigitNumber?displayProperty=nameWithType> categoría.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="IsDigit">
      <MemberSignature Language="C#" Value="public static bool IsDigit (char c);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsDigit(char c) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.IsDigit(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsDigit (c As Char) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsDigit(char c);" />
      <MemberSignature Language="F#" Value="static member IsDigit : char -&gt; bool" Usage="System.char.IsDigit c" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="c" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="c">Carácter Unicode que se va a evaluar.</param>
        <summary>Indica si el carácter Unicode especificado se clasifica por categorías como un dígito decimal.</summary>
        <returns>
          <see langword="true" /> si <paramref name="c" /> es un dígito decimal; en caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método determina si un <xref:System.Char> es un dígito en base 10. Esto contrasta con <xref:System.Char.IsNumber%2A>, que determina si un `Char` es cualquier categoría numérica de Unicode. Números de incluir caracteres como fracciones, subíndices, superíndices, números romanos, numeradores de moneda, números rodeados con un círculo y dígitos específicos de la secuencia de comandos.  
  
 Dígitos válidos son miembros de la <xref:System.Globalization.UnicodeCategory.DecimalDigitNumber?displayProperty=nameWithType> categoría.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra <xref:System.Char.IsDigit%2A>.  
  
 [!code-cpp[System.Char.IsDigit#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Char.IsDigit/CPP/isdigit.cpp#4)]
 [!code-csharp[System.Char.IsDigit#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Char.IsDigit/CS/isdigit.cs#4)]
 [!code-vb[System.Char.IsDigit#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Char.IsDigit/VB/isdigit.vb#4)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Boolean" />
        <altmember cref="M:System.Char.IsNumber(System.Char)" />
      </Docs>
    </Member>
    <Member MemberName="IsDigit">
      <MemberSignature Language="C#" Value="public static bool IsDigit (string s, int index);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsDigit(string s, int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.IsDigit(System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsDigit (s As String, index As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsDigit(System::String ^ s, int index);" />
      <MemberSignature Language="F#" Value="static member IsDigit : string * int -&gt; bool" Usage="System.char.IsDigit (s, index)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="s">Una cadena.</param>
        <param name="index">Posición del carácter que se va a evaluar en <c>s</c>.</param>
        <summary>Indica si el carácter que ocupa la posición especificada en una cadena especificada se clasifica por categorías como un dígito decimal.</summary>
        <returns>
          <see langword="true" /> si el carácter que ocupa la posición <paramref name="index" /> en <paramref name="s" /> es un dígito decimal; en caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método determina si un <xref:System.Char> es un dígito en base 10. Esto contrasta con <xref:System.Char.IsNumber%2A>, que determina si un <xref:System.Char> es cualquier categoría numérica de Unicode. Números de incluir caracteres como fracciones, subíndices, superíndices, números romanos, numeradores de moneda, números rodeados con un círculo y dígitos específicos de la secuencia de comandos.  
  
 Posiciones de caracteres en una cadena se indizan empezando desde cero.  
  
 Dígitos válidos son miembros de la <xref:System.Globalization.UnicodeCategory.DecimalDigitNumber?displayProperty=nameWithType> categoría.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra <xref:System.Char.IsDigit%2A>.  
  
 [!code-cpp[System.Char.IsDigit#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Char.IsDigit/CPP/isdigit.cpp#4)]
 [!code-csharp[System.Char.IsDigit#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Char.IsDigit/CS/isdigit.cs#4)]
 [!code-vb[System.Char.IsDigit#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Char.IsDigit/VB/isdigit.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El valor de <paramref name="s" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> es menor que cero o mayor que la última posición en <paramref name="s" />.</exception>
        <altmember cref="T:System.Boolean" />
        <altmember cref="M:System.Char.IsNumber(System.Char)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="IsHighSurrogate">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Indica si el objeto <see cref="T:System.Char" /> especificado es un suplente alto.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="IsHighSurrogate">
      <MemberSignature Language="C#" Value="public static bool IsHighSurrogate (char c);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsHighSurrogate(char c) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.IsHighSurrogate(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsHighSurrogate (c As Char) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsHighSurrogate(char c);" />
      <MemberSignature Language="F#" Value="static member IsHighSurrogate : char -&gt; bool" Usage="System.char.IsHighSurrogate c" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="c" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="c">Carácter Unicode que se va a evaluar.</param>
        <summary>Indica si el objeto <see cref="T:System.Char" /> especificado es un suplente alto.</summary>
        <returns>
          <see langword="true" /> si el valor numérico del parámetro <paramref name="c" /> va de U+D800 a U+DBFF; de lo contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Además de representar los caracteres individuales mediante un punto de código de 16 bits, la codificación UTF-16 permite representar caracteres abstractas mediante dos puntos de código de 16 bits, que se conoce como un par suplente. El primer elemento en este par es el suplente alto. Su punto de código puede oscilar entre U+D800 y U+DBFF. Un suplente individual no tiene una interpretación propia; tiene sentido sólo cuando se usa como parte de un par suplente.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra el <xref:System.Char.IsHighSurrogate%2A>, <xref:System.Char.IsLowSurrogate%2A>, y <xref:System.Char.IsSurrogatePair%2A> métodos.  
  
 [!code-cpp[char.surrogate#1](~/samples/snippets/cpp/VS_Snippets_CLR/char.surrogate/CPP/sur.cpp#1)]
 [!code-csharp[char.surrogate#1](~/samples/snippets/csharp/VS_Snippets_CLR/char.surrogate/CS/sur.cs#1)]
 [!code-vb[char.surrogate#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/char.surrogate/VB/sur.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsHighSurrogate">
      <MemberSignature Language="C#" Value="public static bool IsHighSurrogate (string s, int index);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsHighSurrogate(string s, int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.IsHighSurrogate(System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsHighSurrogate (s As String, index As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsHighSurrogate(System::String ^ s, int index);" />
      <MemberSignature Language="F#" Value="static member IsHighSurrogate : string * int -&gt; bool" Usage="System.char.IsHighSurrogate (s, index)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="s">Una cadena.</param>
        <param name="index">Posición del carácter que se va a evaluar en <c>s</c>.</param>
        <summary>Indica si el objeto <see cref="T:System.Char" /> situado en la posición especificada de una cadena es un suplente alto.</summary>
        <returns>
          <see langword="true" /> si el valor numérico del carácter especificado en el parámetro <paramref name="s" /> va de U+D800 a U+DBFF; en caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El `index` parámetro está basado en cero.  
  
 Además de representar los caracteres individuales mediante un punto de código de 16 bits, la codificación UTF-16 permite representar caracteres abstractas mediante dos puntos de código de 16 bits, que se conoce como un par suplente. El primer elemento en este par es el suplente alto. Su punto de código puede oscilar entre U+D800 y U+DBFF. Un suplente individual no tiene una interpretación propia; tiene sentido sólo cuando se usa como parte de un par suplente.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra el <xref:System.Char.IsHighSurrogate%2A>, <xref:System.Char.IsLowSurrogate%2A>, y <xref:System.Char.IsSurrogatePair%2A> métodos.  
  
 [!code-cpp[char.surrogate#1](~/samples/snippets/cpp/VS_Snippets_CLR/char.surrogate/CPP/sur.cpp#1)]
 [!code-csharp[char.surrogate#1](~/samples/snippets/csharp/VS_Snippets_CLR/char.surrogate/CS/sur.cs#1)]
 [!code-vb[char.surrogate#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/char.surrogate/VB/sur.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El valor de <paramref name="s" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> no es una posición dentro de <paramref name="s" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="IsLetter">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Indica si un carácter Unicode se clasifica por categorías como una letra Unicode.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método determina si un <xref:System.Char> es un miembro de cualquier categoría de letras Unicode. Las letras de Unicode siguientes:  
  
-   Letras mayúsculas, como u+0041 (LATIN CAPITAL letra A) a través de U + 005A (letra mayúscula latina Z), o u+0400 (CIRÍLICO letra mayúscula IE con acento GRAVE) a través de U + 042F (letra mayúscula CIRÍLICA YA). Estos caracteres son miembros de la <xref:System.Globalization.UnicodeCategory.UppercaseLetter?displayProperty=nameWithType> categoría.  
  
-   Letras minúsculas, como u+0061 (letra latina A) a través de 007A U + (pequeña letra latina Z), o U + 03AC (letra pequeña GRIEGA alfa con TONOS) a través de U + 03CE (letra pequeña GRIEGA OMEGA con TONOS). Estos caracteres son miembros de la <xref:System.Globalization.UnicodeCategory.LowercaseLetter?displayProperty=nameWithType> categoría.  
  
-   Título de letras mayúsculas, como 01 U + C 5 (LATÍN letra mayúscula D con pequeña letra Z con acento circunflejo) o U + 1FFC (GRIEGO letra mayúscula OMEGA con PROSGEGRAMMENI). Estos caracteres son miembros de la <xref:System.Globalization.UnicodeCategory.TitlecaseLetter?displayProperty=nameWithType> categoría.  
  
-   Modificadores, como U + 02B0 (letra MODIFICADORA minúscula H) a través de u+02C1 (modificador letra GLÓTICO invertido), o U + 1D2C (letra MODIFICADORA mayúscula A) a través de u+1D61 (letra MODIFICADORA minúscula CHI). Estos caracteres son miembros de la <xref:System.Globalization.UnicodeCategory.ModifierLetter?displayProperty=nameWithType> categoría.  
  
-   Otras letras, como U + 05 D 0 (HEBREO letra ALEF) a través de U + 05EA (letra hebrea TAV), u+0621 (letra árabe HAMZA) a través de U + 063A (letra árabe GHAIN), o U + 4E00 (\<a de Ideogramas CJK, primero >) a través de FC U + 9 3 (\<a de Ideogramas CJK, último >). Estos caracteres son miembros de la <xref:System.Globalization.UnicodeCategory.OtherLetter?displayProperty=nameWithType> categoría.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="IsLetter">
      <MemberSignature Language="C#" Value="public static bool IsLetter (char c);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsLetter(char c) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.IsLetter(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsLetter (c As Char) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsLetter(char c);" />
      <MemberSignature Language="F#" Value="static member IsLetter : char -&gt; bool" Usage="System.char.IsLetter c" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="c" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="c">Carácter Unicode que se va a evaluar.</param>
        <summary>Indica si el carácter Unicode especificado pertenece a alguna categoría de letras Unicode.</summary>
        <returns>
          <see langword="true" /> si <paramref name="c" /> es una letra; en caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método determina si un <xref:System.Char> es un miembro de cualquier categoría de letras Unicode. Las letras de Unicode siguientes:  
  
-   Letras mayúsculas, como u+0041 (LATIN CAPITAL letra A) a través de U + 005A (letra mayúscula latina Z), o u+0400 (CIRÍLICO letra mayúscula IE con acento GRAVE) a través de U + 042F (letra mayúscula CIRÍLICA YA). Estos caracteres son miembros de la <xref:System.Globalization.UnicodeCategory.UppercaseLetter?displayProperty=nameWithType> categoría.  
  
-   Letras minúsculas, como u+0061 (letra latina A) a través de 007A U + (pequeña letra latina Z), o U + 03AC (letra pequeña GRIEGA alfa con TONOS) a través de U + 03CE (letra pequeña GRIEGA OMEGA con TONOS). Estos caracteres son miembros de la <xref:System.Globalization.UnicodeCategory.LowercaseLetter?displayProperty=nameWithType> categoría.  
  
-   Título de letras mayúsculas, como 01 U + C 5 (LATÍN letra mayúscula D con pequeña letra Z con acento circunflejo) o U + 1FFC (GRIEGO letra mayúscula OMEGA con PROSGEGRAMMENI). Estos caracteres son miembros de la <xref:System.Globalization.UnicodeCategory.TitlecaseLetter?displayProperty=nameWithType> categoría.  
  
-   Modificadores, como U + 02B0 (letra MODIFICADORA minúscula H) a través de u+02C1 (modificador letra GLÓTICO invertido), o U + 1D2C (letra MODIFICADORA mayúscula A) a través de u+1D61 (letra MODIFICADORA minúscula CHI). Estos caracteres son miembros de la <xref:System.Globalization.UnicodeCategory.ModifierLetter?displayProperty=nameWithType> categoría.  
  
-   Otras letras, como U + 05 D 0 (HEBREO letra ALEF) a través de U + 05EA (letra hebrea TAV), u+0621 (letra árabe HAMZA) a través de U + 063A (letra árabe GHAIN), o U + 4E00 (\<a de Ideogramas CJK, primero >) a través de FC U + 9 3 (\<a de Ideogramas CJK, último >). Estos caracteres son miembros de la <xref:System.Globalization.UnicodeCategory.OtherLetter?displayProperty=nameWithType> categoría.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra <xref:System.Char.IsLetter%2A>.  
  
 [!code-cpp[System.Char.IsLetter#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Char.IsLetter/CPP/isletter.cpp#5)]
 [!code-csharp[System.Char.IsLetter#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Char.IsLetter/CS/isletter.cs#5)]
 [!code-vb[System.Char.IsLetter#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Char.IsLetter/VB/isletter.vb#5)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Boolean" />
      </Docs>
    </Member>
    <Member MemberName="IsLetter">
      <MemberSignature Language="C#" Value="public static bool IsLetter (string s, int index);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsLetter(string s, int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.IsLetter(System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsLetter (s As String, index As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsLetter(System::String ^ s, int index);" />
      <MemberSignature Language="F#" Value="static member IsLetter : string * int -&gt; bool" Usage="System.char.IsLetter (s, index)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="s">Una cadena.</param>
        <param name="index">Posición del carácter que se va a evaluar en <c>s</c>.</param>
        <summary>Indica si el carácter que ocupa la posición especificada en una determinada cadena pertenece a alguna categoría de letras Unicode.</summary>
        <returns>
          <see langword="true" /> si el carácter que ocupa la posición <paramref name="index" /> en <paramref name="s" /> es una letra; en caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Posiciones de caracteres en una cadena se indizan empezando desde cero.  
  
 Este método determina si el carácter que ocupa una posición de índice especificada en una cadena es un miembro de cualquier categoría de letras Unicode. Las letras de Unicode siguientes:  
  
-   Letras mayúsculas, como u+0041 (LATIN CAPITAL letra A) a través de U + 005A (letra mayúscula latina Z), o u+0400 (CIRÍLICO letra mayúscula IE con acento GRAVE) a través de U + 042F (letra mayúscula CIRÍLICA YA). Estos caracteres son miembros de la <xref:System.Globalization.UnicodeCategory.UppercaseLetter?displayProperty=nameWithType> categoría.  
  
-   Letras minúsculas, como u+0061 (letra latina A) a través de 007A U + (pequeña letra latina Z), o U + 03AC (letra pequeña GRIEGA alfa con TONOS) a través de U + 03CE (letra pequeña GRIEGA OMEGA con TONOS). Estos caracteres son miembros de la <xref:System.Globalization.UnicodeCategory.LowercaseLetter?displayProperty=nameWithType> categoría.  
  
-   Título de letras mayúsculas, como 01 U + C 5 (LATÍN letra mayúscula D con pequeña letra Z con acento circunflejo) o U + 1FFC (GRIEGO letra mayúscula OMEGA con PROSGEGRAMMENI). Estos caracteres son miembros de la <xref:System.Globalization.UnicodeCategory.TitlecaseLetter?displayProperty=nameWithType> categoría.  
  
-   Modificadores, como U + 02B0 (letra MODIFICADORA minúscula H) a través de u+02C1 (modificador letra GLÓTICO invertido), o U + 1D2C (letra MODIFICADORA mayúscula A) a través de u+1D61 (letra MODIFICADORA minúscula CHI). Estos caracteres son miembros de la <xref:System.Globalization.UnicodeCategory.ModifierLetter?displayProperty=nameWithType> categoría.  
  
-   Otras letras, como U + 05 D 0 (HEBREO letra ALEF) a través de U + 05EA (letra hebrea TAV), u+0621 (letra árabe HAMZA) a través de U + 063A (letra árabe GHAIN), o U + 4E00 (\<a de Ideogramas CJK, primero >) a través de FC U + 9 3 (\<a de Ideogramas CJK, último >). Estos caracteres son miembros de la <xref:System.Globalization.UnicodeCategory.OtherLetter?displayProperty=nameWithType> categoría.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra <xref:System.Char.IsLetter%2A>.  
  
 [!code-cpp[System.Char.IsLetter#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Char.IsLetter/CPP/isletter.cpp#5)]
 [!code-csharp[System.Char.IsLetter#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Char.IsLetter/CS/isletter.cs#5)]
 [!code-vb[System.Char.IsLetter#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Char.IsLetter/VB/isletter.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El valor de <paramref name="s" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> es menor que cero o mayor que la última posición en <paramref name="s" />.</exception>
        <altmember cref="T:System.Boolean" />
      </Docs>
    </Member>
    <MemberGroup MemberName="IsLetterOrDigit">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Indica si un carácter Unicode pertenece a alguna categoría de letras o dígitos decimales.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dígitos decimales y las letras válidas son miembros de las siguientes categorías de <xref:System.Globalization.UnicodeCategory>: `UppercaseLetter`, `LowercaseLetter`, `TitlecaseLetter`, `ModifierLetter`, `OtherLetter`, o `DecimalDigitNumber`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="IsLetterOrDigit">
      <MemberSignature Language="C#" Value="public static bool IsLetterOrDigit (char c);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsLetterOrDigit(char c) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.IsLetterOrDigit(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsLetterOrDigit (c As Char) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsLetterOrDigit(char c);" />
      <MemberSignature Language="F#" Value="static member IsLetterOrDigit : char -&gt; bool" Usage="System.char.IsLetterOrDigit c" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="c" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="c">Carácter Unicode que se va a evaluar.</param>
        <summary>Indica si el carácter Unicode especificado pertenece a alguna categoría de letras o dígitos decimales.</summary>
        <returns>
          <see langword="true" /> si <paramref name="c" /> es una letra o dígito decimal; en caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dígitos decimales y las letras válidas son miembros de las siguientes categorías de <xref:System.Globalization.UnicodeCategory>: `UppercaseLetter`, `LowercaseLetter`, `TitlecaseLetter`, `ModifierLetter`, `OtherLetter`, o `DecimalDigitNumber`.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra <xref:System.Char.IsLetterOrDigit%2A>.  
  
 [!code-cpp[System.Char.IsLetterOrDigit#6](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Char.IsLetterOrDigit/CPP/isletterordigit.cpp#6)]
 [!code-csharp[System.Char.IsLetterOrDigit#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Char.IsLetterOrDigit/CS/isletterordigit.cs#6)]
 [!code-vb[System.Char.IsLetterOrDigit#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Char.IsLetterOrDigit/VB/isletterordigit.vb#6)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Boolean" />
      </Docs>
    </Member>
    <Member MemberName="IsLetterOrDigit">
      <MemberSignature Language="C#" Value="public static bool IsLetterOrDigit (string s, int index);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsLetterOrDigit(string s, int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.IsLetterOrDigit(System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsLetterOrDigit (s As String, index As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsLetterOrDigit(System::String ^ s, int index);" />
      <MemberSignature Language="F#" Value="static member IsLetterOrDigit : string * int -&gt; bool" Usage="System.char.IsLetterOrDigit (s, index)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="s">Una cadena.</param>
        <param name="index">Posición del carácter que se va a evaluar en <c>s</c>.</param>
        <summary>Indica si el carácter que ocupa la posición especificada en una cadena especificada pertenece a alguna categoría de letras o dígitos decimales.</summary>
        <returns>
          <see langword="true" /> si el carácter que ocupa la posición <paramref name="index" /> en <paramref name="s" /> es una letra o dígito decimal; en caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Posiciones de caracteres en una cadena se indizan empezando desde cero.  
  
 Dígitos decimales y las letras válidas son miembros de las siguientes categorías de <xref:System.Globalization.UnicodeCategory>: `UppercaseLetter`, `LowercaseLetter`, `TitlecaseLetter`, `ModifierLetter`, `OtherLetter`, o `DecimalDigitNumber`.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra <xref:System.Char.IsLetterOrDigit%2A>.  
  
 [!code-cpp[System.Char.IsLetterOrDigit#6](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Char.IsLetterOrDigit/CPP/isletterordigit.cpp#6)]
 [!code-csharp[System.Char.IsLetterOrDigit#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Char.IsLetterOrDigit/CS/isletterordigit.cs#6)]
 [!code-vb[System.Char.IsLetterOrDigit#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Char.IsLetterOrDigit/VB/isletterordigit.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El valor de <paramref name="s" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> es menor que cero o mayor que la última posición en <paramref name="s" />.</exception>
        <altmember cref="T:System.Boolean" />
      </Docs>
    </Member>
    <MemberGroup MemberName="IsLower">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Indica si un carácter Unicode se clasifica por categorías como una letra minúscula.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="IsLower">
      <MemberSignature Language="C#" Value="public static bool IsLower (char c);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsLower(char c) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.IsLower(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsLower (c As Char) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsLower(char c);" />
      <MemberSignature Language="F#" Value="static member IsLower : char -&gt; bool" Usage="System.char.IsLower c" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="c" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="c">Carácter Unicode que se va a evaluar.</param>
        <summary>Indica si el carácter Unicode especificado se clasifica por categorías como una letra minúscula.</summary>
        <returns>
          <see langword="true" /> si <paramref name="c" /> es una letra minúscula; en caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Letras minúsculas válidas son miembros de la siguiente categoría de <xref:System.Globalization.UnicodeCategory>: `LowercaseLetter`.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra <xref:System.Char.IsLower%2A>.  
  
 [!code-cpp[System.Char.IsLower#7](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Char.IsLower/CPP/islower.cpp#7)]
 [!code-csharp[System.Char.IsLower#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Char.IsLower/CS/islower.cs#7)]
 [!code-vb[System.Char.IsLower#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Char.IsLower/VB/islower.vb#7)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Boolean" />
        <altmember cref="M:System.Char.IsUpper(System.Char)" />
      </Docs>
    </Member>
    <Member MemberName="IsLower">
      <MemberSignature Language="C#" Value="public static bool IsLower (string s, int index);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsLower(string s, int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.IsLower(System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsLower (s As String, index As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsLower(System::String ^ s, int index);" />
      <MemberSignature Language="F#" Value="static member IsLower : string * int -&gt; bool" Usage="System.char.IsLower (s, index)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="s">Una cadena.</param>
        <param name="index">Posición del carácter que se va a evaluar en <c>s</c>.</param>
        <summary>Indica si el carácter que ocupa la posición especificada en una cadena especificada se clasifica por categorías como una letra minúscula.</summary>
        <returns>
          <see langword="true" /> si el carácter que ocupa la posición <paramref name="index" /> en <paramref name="s" /> es una letra minúscula; en caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Posiciones de caracteres en una cadena se indizan empezando desde cero.  
  
 Letras minúsculas válidas son miembros de la siguiente categoría de <xref:System.Globalization.UnicodeCategory>: `LowercaseLetter`.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra <xref:System.Char.IsLower%2A>.  
  
 [!code-cpp[System.Char.IsLower#7](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Char.IsLower/CPP/islower.cpp#7)]
 [!code-csharp[System.Char.IsLower#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Char.IsLower/CS/islower.cs#7)]
 [!code-vb[System.Char.IsLower#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Char.IsLower/VB/islower.vb#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El valor de <paramref name="s" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> es menor que cero o mayor que la última posición en <paramref name="s" />.</exception>
        <altmember cref="T:System.Boolean" />
        <altmember cref="T:System.String" />
        <altmember cref="M:System.Char.IsUpper(System.Char)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="IsLowSurrogate">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Indica si el objeto <see cref="T:System.Char" /> especificado es un suplente bajo.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="IsLowSurrogate">
      <MemberSignature Language="C#" Value="public static bool IsLowSurrogate (char c);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsLowSurrogate(char c) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.IsLowSurrogate(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsLowSurrogate (c As Char) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsLowSurrogate(char c);" />
      <MemberSignature Language="F#" Value="static member IsLowSurrogate : char -&gt; bool" Usage="System.char.IsLowSurrogate c" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="c" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="c">Carácter que se va a evaluar.</param>
        <summary>Indica si el objeto <see cref="T:System.Char" /> especificado es un suplente bajo.</summary>
        <returns>
          <see langword="true" /> si el valor numérico del parámetro <paramref name="c" /> va de U+DC00 a U+DFFF; en caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Además de representar los caracteres individuales mediante un punto de código de 16 bits, la codificación UTF-16 permite representar caracteres abstractas mediante dos puntos de código de 16 bits, que se conoce como un par suplente. El segundo elemento en este par es el suplente bajo. Su punto de código puede oscilar entre U+DC00 y U+DFFF. Un suplente individual no tiene una interpretación propia; tiene sentido sólo cuando se usa como parte de un par suplente.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra el <xref:System.Char.IsHighSurrogate%2A>, <xref:System.Char.IsLowSurrogate%2A>, y <xref:System.Char.IsSurrogatePair%2A> métodos.  
  
 [!code-cpp[char.surrogate#1](~/samples/snippets/cpp/VS_Snippets_CLR/char.surrogate/CPP/sur.cpp#1)]
 [!code-csharp[char.surrogate#1](~/samples/snippets/csharp/VS_Snippets_CLR/char.surrogate/CS/sur.cs#1)]
 [!code-vb[char.surrogate#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/char.surrogate/VB/sur.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsLowSurrogate">
      <MemberSignature Language="C#" Value="public static bool IsLowSurrogate (string s, int index);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsLowSurrogate(string s, int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.IsLowSurrogate(System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsLowSurrogate (s As String, index As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsLowSurrogate(System::String ^ s, int index);" />
      <MemberSignature Language="F#" Value="static member IsLowSurrogate : string * int -&gt; bool" Usage="System.char.IsLowSurrogate (s, index)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="s">Una cadena.</param>
        <param name="index">Posición del carácter que se va a evaluar en <c>s</c>.</param>
        <summary>Indica si el objeto <see cref="T:System.Char" /> situado en la posición especificada de una cadena es un suplente bajo.</summary>
        <returns>
          <see langword="true" /> si el valor numérico del carácter especificado en el parámetro <paramref name="s" /> va de U+DC00 a U+DFFF; en caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El `index` parámetro está basado en cero.  
  
 Además de representar los caracteres individuales mediante un punto de código de 16 bits, la codificación UTF-16 permite representar caracteres abstractas mediante dos puntos de código de 16 bits, que se conoce como un par suplente. El segundo elemento en este par es el suplente bajo. Su punto de código puede oscilar entre U+DC00 y U+DFFF. Un suplente individual no tiene una interpretación propia; tiene sentido sólo cuando se usa como parte de un par suplente.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra el <xref:System.Char.IsHighSurrogate%2A>, <xref:System.Char.IsLowSurrogate%2A>, y <xref:System.Char.IsSurrogatePair%2A> métodos.  
  
 [!code-cpp[char.surrogate#1](~/samples/snippets/cpp/VS_Snippets_CLR/char.surrogate/CPP/sur.cpp#1)]
 [!code-csharp[char.surrogate#1](~/samples/snippets/csharp/VS_Snippets_CLR/char.surrogate/CS/sur.cs#1)]
 [!code-vb[char.surrogate#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/char.surrogate/VB/sur.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El valor de <paramref name="s" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> no es una posición dentro de <paramref name="s" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="IsNumber">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Indica si un carácter Unicode se clasifica por categorías como un número.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="IsNumber">
      <MemberSignature Language="C#" Value="public static bool IsNumber (char c);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsNumber(char c) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.IsNumber(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsNumber (c As Char) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsNumber(char c);" />
      <MemberSignature Language="F#" Value="static member IsNumber : char -&gt; bool" Usage="System.char.IsNumber c" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="c" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="c">Carácter Unicode que se va a evaluar.</param>
        <summary>Indica si el carácter Unicode especificado se clasifica por categorías como un número.</summary>
        <returns>
          <see langword="true" /> si <paramref name="c" /> es un número; en caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método determina si un <xref:System.Char> es cualquier categoría numérica de Unicode. Además de incluir dígitos, los números incluyen caracteres, fracciones, subíndices, superíndices, números romanos, numeradores de divisa y números rodeados con un círculo. Este método se contrasta con la <xref:System.Char.IsDigit%2A> método, que determina si un <xref:System.Char> es un dígito en base 10.  
  
> [!IMPORTANT]
>  El <xref:System.Char.IsNumber%28System.Char%29> método no está pensado para determinar si una cadena formada por caracteres numéricos (por ejemplo, llamando al método para cada carácter en una cadena). Para determinar si una cadena consta de caracteres numéricos, llamar a las sobrecargas de los `TryParse` método (como <xref:System.Int32.TryParse%2A?displayProperty=nameWithType> o <xref:System.Double.TryParse%2A?displayProperty=nameWithType> de un tipo entero o de punto flotante.  
  
 Números válidos son miembros de la <xref:System.Globalization.UnicodeCategory.DecimalDigitNumber?displayProperty=nameWithType>, <xref:System.Globalization.UnicodeCategory.LetterNumber?displayProperty=nameWithType>, o <xref:System.Globalization.UnicodeCategory.OtherNumber?displayProperty=nameWithType> categoría.  
  
 El <xref:System.Char.IsNumber%28System.Char%29> método supone que `c` corresponde a un único carácter lingüístico y comprueba si dicho carácter representa un número. Sin embargo, algunos números en el estándar Unicode están representadas por dos <xref:System.Char> objetos que forman un par suplente. Por ejemplo, el sistema de numeración de Egeo consta de 10107 U + U + 10133 a través de los puntos de código. En el ejemplo siguiente se usa el <xref:System.Char.ConvertFromUtf32%2A> método para crear instancias de una cadena que representa el número uno de menores. Como la salida muestra el ejemplo, el <xref:System.Char.IsNumber%28System.Char%29> devuelve del método `false` si se pasa un suplente alto o un suplente bajo de este carácter.  
  
 [!code-csharp[System.Char.IsNumber#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Char.IsNumber/CS/isnumber1.cs#1)]
 [!code-vb[System.Char.IsNumber#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Char.IsNumber/VB/isnumber1.vb#1)]  
  
   
  
## Examples  
 En el ejemplo siguiente se muestra <xref:System.Char.IsNumber%2A>.  
  
 [!code-cpp[System.Char.IsNumber#8](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Char.IsNumber/CPP/isnumber.cpp#8)]
 [!code-csharp[System.Char.IsNumber#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Char.IsNumber/CS/isnumber.cs#8)]
 [!code-vb[System.Char.IsNumber#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Char.IsNumber/VB/isnumber.vb#8)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Boolean" />
        <altmember cref="M:System.Char.IsDigit(System.Char)" />
      </Docs>
    </Member>
    <Member MemberName="IsNumber">
      <MemberSignature Language="C#" Value="public static bool IsNumber (string s, int index);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsNumber(string s, int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.IsNumber(System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsNumber (s As String, index As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsNumber(System::String ^ s, int index);" />
      <MemberSignature Language="F#" Value="static member IsNumber : string * int -&gt; bool" Usage="System.char.IsNumber (s, index)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="s">Una cadena.</param>
        <param name="index">Posición del carácter que se va a evaluar en <c>s</c>.</param>
        <summary>Indica si el carácter que ocupa la posición especificada en una cadena especificada se clasifica por categorías como un número.</summary>
        <returns>
          <see langword="true" /> si el carácter que ocupa la posición <paramref name="index" /> en <paramref name="s" /> es un número; en caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método determina si un <xref:System.Char> es cualquier categoría numérica de Unicode. Además de incluir dígitos, los números incluyen caracteres, fracciones, subíndices, superíndices, números romanos, numeradores de divisa y números rodeados con un círculo. Este método se contrasta con la <xref:System.Char.IsDigit%2A> método, que determina si un <xref:System.Char> es un dígito en base 10.  
  
 Posiciones de caracteres en una cadena se indizan empezando desde cero.  
  
> [!IMPORTANT]
>  El <xref:System.Char.IsNumber%28System.String%2CSystem.Int32%29> método no está pensado para determinar si una cadena formada por caracteres numéricos (por ejemplo, llamando al método para cada carácter en una cadena). Para determinar si una cadena consta de caracteres numéricos, llamar a las sobrecargas de los `TryParse` método (como <xref:System.Int32.TryParse%2A?displayProperty=nameWithType> o <xref:System.Double.TryParse%2A?displayProperty=nameWithType> de un tipo entero o de punto flotante.  
  
 Números válidos son miembros de la <xref:System.Globalization.UnicodeCategory.DecimalDigitNumber?displayProperty=nameWithType>, <xref:System.Globalization.UnicodeCategory.LetterNumber?displayProperty=nameWithType>, o <xref:System.Globalization.UnicodeCategory.OtherNumber?displayProperty=nameWithType> categoría.  
  
 Si el <xref:System.Char> objeto en la posición `index` es el primer carácter de un par suplente válido, el <xref:System.Char.IsNumber%28System.String%2CSystem.Int32%29> método determina si el par suplente forms un dígito numérico. Por ejemplo, el sistema de numeración de Egeo consta de 10107 U + U + 10133 a través de los puntos de código. En el ejemplo siguiente se usa el <xref:System.Char.ConvertFromUtf32%2A> método para crear instancias de una cadena que representa el número uno de menores. Como la salida muestra el ejemplo, el <xref:System.Char.IsNumber%28System.String%2CSystem.Int32%29> devuelve del método `true` si se pasa el suplente alto de mar EGEO número uno. Sin embargo, si se pasa el suplente bajo, considera solo la categoría de suplente bajo y devuelve `false`.  
  
 [!code-csharp[System.Char.IsNumber#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Char.IsNumber/CS/isnumber1.cs#2)]
 [!code-vb[System.Char.IsNumber#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Char.IsNumber/VB/isnumber1.vb#2)]  
  
   
  
## Examples  
 En el ejemplo siguiente se muestra <xref:System.Char.IsNumber%2A>.  
  
 [!code-cpp[System.Char.IsNumber#8](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Char.IsNumber/CPP/isnumber.cpp#8)]
 [!code-csharp[System.Char.IsNumber#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Char.IsNumber/CS/isnumber.cs#8)]
 [!code-vb[System.Char.IsNumber#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Char.IsNumber/VB/isnumber.vb#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El valor de <paramref name="s" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> es menor que cero o mayor que la última posición en <paramref name="s" />.</exception>
        <altmember cref="T:System.Boolean" />
        <altmember cref="T:System.String" />
        <altmember cref="M:System.Char.IsDigit(System.Char)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="IsPunctuation">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Indica si un carácter Unicode se clasifica por categorías como un signo de puntuación.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Signos de puntuación válidos son miembros de las siguientes categorías de <xref:System.Globalization.UnicodeCategory>: `ConnectorPunctuation`, `DashPunctuation`, `OpenPunctuation`, `ClosePunctuation`, `InititalQuotePunctuation`, `FinalQuotePunctuation`, o `OtherPunctuation`. Incluyen caracteres con los puntos de código Unicode enumerados en la tabla siguiente.  
  
|||||  
|-|-|-|-|  
|U+0021 a u+0023|U+060C y U+060D|U + 1800 a 180A U +|3014 U + a 301F U +|  
|0025 U + a 002A U +|061B U +|U+1944 y u+1945|3030 U +|  
|U + 002C a U + 002F|U + 061E y 061F U +|U + 19DE y 19DF U +|303D U +|  
|003A U + y 003B U +|066A U + a U+066D|U + 1A1E y 1A1F U +|30A0 U +|  
|003F U + y 0040 U +|U + 06D 4|1B5A U + a 1B60 U +|30FB U +|  
|005B U + a U+005D|U+0700 a U+070D|U + 2010 a 2027 U +|U+A874 a U+A877|  
|005F U +|07F7 U + a 07F9 U +|U+2030 a 2043 U +|U + FD3E y FD3F + U|  
|007B U +|U+0964 y u+0965|2045 U + a 2051 U +|U+FE10 a U+FE19|  
|U + 007D|0970 U +|2053 U + a 205E U +|U+FE30 a U+FE52|  
|00A1 U +|0DF4 U +|U + 207D y 207E U +|U+FE54 a U+FE61|  
|00AB U +|0E4F U + a 0E5B U +|U + 208D y 208E U +|U + FE63|  
|00AD U +|0F04 U + a 0F12 U +|U + 232A de u+2329 y|U + FE68|  
|00B7 U +|0F3A U + a 0F3D U +|U+2768 a u+2775|U + FE6A y FE6B + U|  
|00BB U +|0F85 U +|U + 5 27C a u+27C6 U +|U + FF01 a U + FF03|  
|00BF U +|U+0FD0 y 0FD1 U +|27E6 U + a 27EB U +|U+FF05 a U + FF0A|  
|037E U +|U + 104A a 104F U +|U+2983 a u+2998|U + FF0C a FF0F + U|  
|0387 U +|10FB U +|U + 8 29D a 29DB U +|U + FF1A y FF1B + U|  
|055A U + a 055F U +|U+1361 a u+1368|U + 29FC y 29FD U +|U + FF1F y U+FF20|  
|U + 058A de u+0589 y|U + 166D y 166E U +|2CF9 U + a 2CFC U +|U + FF3B a U + FF3D|  
|05BE U +|U + 169B y U + 169C|U + 2CFE y 2CFF U +|U + FF3F|  
|U + 05C 0|16EB U + a 16ED U +|2E00 U + a 2E17 U +|U + FF5B|  
|U + 05C 3|U+1735 y u+1736|U + 2E1C y 2E1D U +|U + FF5D|  
|U + 05C 6|U + 4 17D a U + u+17D6|3001 U + a 3003 U +|U + FF5F a U+FF65|  
|U + 05F3 y 05F4 U +|U + 8 17D a 17DA U +|3008 U + a U + 3011||  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="IsPunctuation">
      <MemberSignature Language="C#" Value="public static bool IsPunctuation (char c);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsPunctuation(char c) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.IsPunctuation(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsPunctuation (c As Char) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsPunctuation(char c);" />
      <MemberSignature Language="F#" Value="static member IsPunctuation : char -&gt; bool" Usage="System.char.IsPunctuation c" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="c" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="c">Carácter Unicode que se va a evaluar.</param>
        <summary>Indica si el carácter Unicode especificado se clasifica por categorías como un signo de puntuación.</summary>
        <returns>
          <see langword="true" /> si <paramref name="c" /> es un signo de puntuación; en caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Signos de puntuación válidos son miembros de las siguientes categorías de <xref:System.Globalization.UnicodeCategory>: `ConnectorPunctuation`, `DashPunctuation`, `OpenPunctuation`, `ClosePunctuation`, `InititalQuotePunctuation`, `FinalQuotePunctuation`, o `OtherPunctuation`. Incluyen caracteres con los puntos de código Unicode enumerados en la tabla siguiente.  
  
|||||  
|-|-|-|-|  
|U+0021 a u+0023|U+060C y U+060D|U + 1800 a 180A U +|3014 U + a 301F U +|  
|0025 U + a 002A U +|061B U +|U+1944 y u+1945|3030 U +|  
|U + 002C a U + 002F|U + 061E y 061F U +|U + 19DE y 19DF U +|303D U +|  
|003A U + y 003B U +|066A U + a U+066D|U + 1A1E y 1A1F U +|30A0 U +|  
|003F U + y 0040 U +|U + 06D 4|1B5A U + a 1B60 U +|30FB U +|  
|005B U + a U+005D|U+0700 a U+070D|U + 2010 a 2027 U +|U+A874 a U+A877|  
|005F U +|07F7 U + a 07F9 U +|U+2030 a 2043 U +|U + FD3E y FD3F + U|  
|007B U +|U+0964 y u+0965|2045 U + a 2051 U +|U+FE10 a U+FE19|  
|U + 007D|0970 U +|2053 U + a 205E U +|U+FE30 a U+FE52|  
|00A1 U +|0DF4 U +|U + 207D y 207E U +|U+FE54 a U+FE61|  
|00AB U +|0E4F U + a 0E5B U +|U + 208D y 208E U +|U + FE63|  
|00AD U +|0F04 U + a 0F12 U +|U + 232A de u+2329 y|U + FE68|  
|00B7 U +|0F3A U + a 0F3D U +|U+2768 a u+2775|U + FE6A y FE6B + U|  
|00BB U +|0F85 U +|U + 5 27C a u+27C6 U +|U + FF01 a U + FF03|  
|00BF U +|U+0FD0 y 0FD1 U +|27E6 U + a 27EB U +|U+FF05 a U + FF0A|  
|037E U +|U + 104A a 104F U +|U+2983 a u+2998|U + FF0C a FF0F + U|  
|0387 U +|10FB U +|U + 8 29D a 29DB U +|U + FF1A y FF1B + U|  
|055A U + a 055F U +|U+1361 a u+1368|U + 29FC y 29FD U +|U + FF1F y U+FF20|  
|U + 058A de u+0589 y|U + 166D y 166E U +|2CF9 U + a 2CFC U +|U + FF3B a U + FF3D|  
|05BE U +|U + 169B y U + 169C|U + 2CFE y 2CFF U +|U + FF3F|  
|U + 05C 0|16EB U + a 16ED U +|2E00 U + a 2E17 U +|U + FF5B|  
|U + 05C 3|U+1735 y u+1736|U + 2E1C y 2E1D U +|U + FF5D|  
|U + 05C 6|U + 4 17D a U + u+17D6|3001 U + a 3003 U +|U + FF5F a U+FF65|  
|U + 05F3 y 05F4 U +|U + 8 17D a 17DA U +|3008 U + a U + 3011||  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra <xref:System.Char.IsPunctuation%2A>.  
  
 [!code-cpp[System.Char.IsPunctuation#9](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Char.IsPunctuation/CPP/ispunctuation.cpp#9)]
 [!code-csharp[System.Char.IsPunctuation#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Char.IsPunctuation/CS/ispunctuation.cs#9)]
 [!code-vb[System.Char.IsPunctuation#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Char.IsPunctuation/VB/ispunctuation.vb#9)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Boolean" />
      </Docs>
    </Member>
    <Member MemberName="IsPunctuation">
      <MemberSignature Language="C#" Value="public static bool IsPunctuation (string s, int index);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsPunctuation(string s, int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.IsPunctuation(System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsPunctuation (s As String, index As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsPunctuation(System::String ^ s, int index);" />
      <MemberSignature Language="F#" Value="static member IsPunctuation : string * int -&gt; bool" Usage="System.char.IsPunctuation (s, index)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="s">Una cadena.</param>
        <param name="index">Posición del carácter que se va a evaluar en <c>s</c>.</param>
        <summary>Indica si el carácter que ocupa la posición especificada en una cadena especificada se clasifica por categorías como un signo de puntuación.</summary>
        <returns>
          <see langword="true" /> si el carácter que ocupa la posición <paramref name="index" /> en <paramref name="s" /> es un signo de puntuación; en caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Posiciones de caracteres en una cadena se indizan empezando desde cero.  
  
 Signos de puntuación válidos son miembros de las siguientes categorías de <xref:System.Globalization.UnicodeCategory>: `ConnectorPunctuation`, `DashPunctuation`, `OpenPunctuation`, `ClosePunctuation`, `InititalQuotePunctuation`, `FinalQuotePunctuation`, o `OtherPunctuation`. Incluyen caracteres con los puntos de código Unicode enumerados en la tabla siguiente.  
  
|||||  
|-|-|-|-|  
|U+0021 a u+0023|U+060C y U+060D|U + 1800 a 180A U +|3014 U + a 301F U +|  
|0025 U + a 002A U +|061B U +|U+1944 y u+1945|3030 U +|  
|U + 002C a U + 002F|U + 061E y 061F U +|U + 19DE y 19DF U +|303D U +|  
|003A U + y 003B U +|066A U + a U+066D|U + 1A1E y 1A1F U +|30A0 U +|  
|003F U + y 0040 U +|U + 06D 4|1B5A U + a 1B60 U +|30FB U +|  
|005B U + a U+005D|U+0700 a U+070D|U + 2010 a 2027 U +|U+A874 a U+A877|  
|005F U +|07F7 U + a 07F9 U +|U+2030 a 2043 U +|U + FD3E y FD3F + U|  
|007B U +|U+0964 y u+0965|2045 U + a 2051 U +|U+FE10 a U+FE19|  
|U + 007D|0970 U +|2053 U + a 205E U +|U+FE30 a U+FE52|  
|00A1 U +|0DF4 U +|U + 207D y 207E U +|U+FE54 a U+FE61|  
|00AB U +|0E4F U + a 0E5B U +|U + 208D y 208E U +|U + FE63|  
|00AD U +|0F04 U + a 0F12 U +|U + 232A de u+2329 y|U + FE68|  
|00B7 U +|0F3A U + a 0F3D U +|U+2768 a u+2775|U + FE6A y FE6B + U|  
|00BB U +|0F85 U +|U + 5 27C a u+27C6 U +|U + FF01 a U + FF03|  
|00BF U +|U+0FD0 y 0FD1 U +|27E6 U + a 27EB U +|U+FF05 a U + FF0A|  
|037E U +|U + 104A a 104F U +|U+2983 a u+2998|U + FF0C a FF0F + U|  
|0387 U +|10FB U +|U + 8 29D a 29DB U +|U + FF1A y FF1B + U|  
|055A U + a 055F U +|U+1361 a u+1368|U + 29FC y 29FD U +|U + FF1F y U+FF20|  
|U + 058A de u+0589 y|U + 166D y 166E U +|2CF9 U + a 2CFC U +|U + FF3B a U + FF3D|  
|05BE U +|U + 169B y U + 169C|U + 2CFE y 2CFF U +|U + FF3F|  
|U + 05C 0|16EB U + a 16ED U +|2E00 U + a 2E17 U +|U + FF5B|  
|U + 05C 3|U+1735 y u+1736|U + 2E1C y 2E1D U +|U + FF5D|  
|U + 05C 6|U + 4 17D a U + u+17D6|3001 U + a 3003 U +|U + FF5F a U+FF65|  
|U + 05F3 y 05F4 U +|U + 8 17D a 17DA U +|3008 U + a U + 3011||  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra <xref:System.Char.IsPunctuation%2A>.  
  
 [!code-cpp[System.Char.IsPunctuation#9](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Char.IsPunctuation/CPP/ispunctuation.cpp#9)]
 [!code-csharp[System.Char.IsPunctuation#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Char.IsPunctuation/CS/ispunctuation.cs#9)]
 [!code-vb[System.Char.IsPunctuation#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Char.IsPunctuation/VB/ispunctuation.vb#9)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El valor de <paramref name="s" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> es menor que cero o mayor que la última posición en <paramref name="s" />.</exception>
        <altmember cref="T:System.Boolean" />
        <altmember cref="T:System.String" />
      </Docs>
    </Member>
    <MemberGroup MemberName="IsSeparator">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Indica si un carácter Unicode se clasifica por categorías como un carácter separador.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El estándar Unicode reconoce tres subcategorías de separadores:  
  
-   Separadores de espacio (el <xref:System.Globalization.UnicodeCategory.SpaceSeparator?displayProperty=nameWithType> categoría), que incluye caracteres como \u0020.  
  
-   Separadores de líneas (el <xref:System.Globalization.UnicodeCategory.LineSeparator?displayProperty=nameWithType> categoría), que incluye \u2028.  
  
-   Separadores de párrafos (el <xref:System.Globalization.UnicodeCategory.ParagraphSeparator?displayProperty=nameWithType> categoría), que incluye \u2029.  
  
> [!NOTE]
>  El estándar Unicode clasifica los caracteres \u000A (LF), \u000C (FF) y \u000D (CR) como caracteres de control (miembros de la <xref:System.Globalization.UnicodeCategory.Control?displayProperty=nameWithType> categoría), no como caracteres separadores.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="IsSeparator">
      <MemberSignature Language="C#" Value="public static bool IsSeparator (char c);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsSeparator(char c) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.IsSeparator(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsSeparator (c As Char) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsSeparator(char c);" />
      <MemberSignature Language="F#" Value="static member IsSeparator : char -&gt; bool" Usage="System.char.IsSeparator c" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="c" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="c">Carácter Unicode que se va a evaluar.</param>
        <summary>Indica si el carácter Unicode especificado se clasifica por categorías como un carácter separador.</summary>
        <returns>
          <see langword="true" /> si <paramref name="c" /> es un carácter separador; en caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El estándar Unicode reconoce tres subcategorías de separadores:  
  
-   Separadores de espacio (el <xref:System.Globalization.UnicodeCategory.SpaceSeparator?displayProperty=nameWithType> categoría), que incluye caracteres como \u0020.  
  
-   Separadores de líneas (el <xref:System.Globalization.UnicodeCategory.LineSeparator?displayProperty=nameWithType> categoría), que incluye \u2028.  
  
-   Separadores de párrafos (el <xref:System.Globalization.UnicodeCategory.ParagraphSeparator?displayProperty=nameWithType> categoría), que incluye \u2029.  
  
> [!NOTE]
>  El estándar Unicode clasifica los caracteres \u000A (LF), \u000C (FF) y \u000D (CR) como caracteres de control (miembros de la <xref:System.Globalization.UnicodeCategory.Control?displayProperty=nameWithType> categoría), no como caracteres separadores.  
  
   
  
## Examples  
 El ejemplo siguiente se muestra el <xref:System.Char> objetos que se clasifican como caracteres separadores.  
  
 [!code-cpp[System.Char.IsSeparator#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Char.IsSeparator/CPP/isseparator1.cpp#1)]
 [!code-csharp[System.Char.IsSeparator#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Char.IsSeparator/CS/isseparator1.cs#1)]
 [!code-vb[System.Char.IsSeparator#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Char.IsSeparator/VB/isseparator1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Globalization.UnicodeCategory" />
      </Docs>
    </Member>
    <Member MemberName="IsSeparator">
      <MemberSignature Language="C#" Value="public static bool IsSeparator (string s, int index);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsSeparator(string s, int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.IsSeparator(System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsSeparator (s As String, index As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsSeparator(System::String ^ s, int index);" />
      <MemberSignature Language="F#" Value="static member IsSeparator : string * int -&gt; bool" Usage="System.char.IsSeparator (s, index)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="s">Una cadena.</param>
        <param name="index">Posición del carácter que se va a evaluar en <c>s</c>.</param>
        <summary>Indica si el carácter que ocupa la posición especificada en una cadena especificada se clasifica por categorías como un carácter separador.</summary>
        <returns>
          <see langword="true" /> si el carácter que ocupa la posición <paramref name="index" /> en <paramref name="s" /> es un carácter separador; en caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Posiciones de caracteres en una cadena se indizan empezando desde cero.  
  
 El estándar Unicode reconoce tres subcategorías de separadores:  
  
-   Separadores de espacio (el <xref:System.Globalization.UnicodeCategory.SpaceSeparator?displayProperty=nameWithType> categoría), que incluye caracteres como \u0020.  
  
-   Separadores de líneas (el <xref:System.Globalization.UnicodeCategory.LineSeparator?displayProperty=nameWithType> categoría), que incluye \u2028.  
  
-   Separadores de párrafos (el <xref:System.Globalization.UnicodeCategory.ParagraphSeparator?displayProperty=nameWithType> categoría), que incluye \u2029.  
  
> [!NOTE]
>  El estándar Unicode clasifica los caracteres \u000A (LF), \u000C (FF) y \u000D (CR) como caracteres de control (miembros de la <xref:System.Globalization.UnicodeCategory.Control?displayProperty=nameWithType> categoría), no como caracteres separadores.  
  
   
  
## Examples  
 En el ejemplo siguiente se muestra <xref:System.Char.IsSeparator%2A>.  
  
 [!code-cpp[System.Char.IsSeparator#10](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Char.IsSeparator/CPP/isseparator.cpp#10)]
 [!code-csharp[System.Char.IsSeparator#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Char.IsSeparator/CS/isseparator.cs#10)]
 [!code-vb[System.Char.IsSeparator#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Char.IsSeparator/VB/isseparator.vb#10)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El valor de <paramref name="s" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> es menor que cero o mayor que la última posición en <paramref name="s" />.</exception>
        <altmember cref="T:System.Boolean" />
        <altmember cref="T:System.String" />
      </Docs>
    </Member>
    <MemberGroup MemberName="IsSurrogate">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Indica si un carácter tiene una unidad de código suplente.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="IsSurrogate">
      <MemberSignature Language="C#" Value="public static bool IsSurrogate (char c);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsSurrogate(char c) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.IsSurrogate(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsSurrogate (c As Char) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsSurrogate(char c);" />
      <MemberSignature Language="F#" Value="static member IsSurrogate : char -&gt; bool" Usage="System.char.IsSurrogate c" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="c" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="c">Carácter Unicode que se va a evaluar.</param>
        <summary>Indica si el carácter especificado tiene una unidad de código suplente.</summary>
        <returns>Es <see langword="true" /> si <paramref name="c" /> es un suplente alto o un suplente bajo; de lo contrario, es <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un suplente es un <xref:System.Char> objeto con una unidad de código UTF-16 en el intervalo de U+D800 a U+DFFF. Cada carácter con una unidad de código de este intervalo pertenece a la <xref:System.Globalization.UnicodeCategory.Surrogate?displayProperty=nameWithType> categoría. La unidad de código suplente individual no tiene una interpretación propia, pero tiene significado solo cuando se usan como parte de un par suplente. Para obtener más información sobre los pares suplentes, vea el estándar Unicode en el [página principal de Unicode](https://go.microsoft.com/fwlink/?linkid=37123).  
  
   
  
## Examples  
 En el ejemplo siguiente se muestra el <xref:System.Char.IsSurrogate%2A> método.  
  
 [!code-cpp[System.Char.IsSurrogate#11](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Char.IsSurrogate/CPP/issurrogate.cpp#11)]
 [!code-csharp[System.Char.IsSurrogate#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Char.IsSurrogate/CS/issurrogate.cs#11)]
 [!code-vb[System.Char.IsSurrogate#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Char.IsSurrogate/VB/issurrogate.vb#11)]  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Char.IsHighSurrogate" />
        <altmember cref="Overload:System.Char.IsLowSurrogate" />
        <altmember cref="Overload:System.Char.IsSurrogatePair" />
      </Docs>
    </Member>
    <Member MemberName="IsSurrogate">
      <MemberSignature Language="C#" Value="public static bool IsSurrogate (string s, int index);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsSurrogate(string s, int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.IsSurrogate(System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsSurrogate (s As String, index As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsSurrogate(System::String ^ s, int index);" />
      <MemberSignature Language="F#" Value="static member IsSurrogate : string * int -&gt; bool" Usage="System.char.IsSurrogate (s, index)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="s">Una cadena.</param>
        <param name="index">Posición del carácter que se va a evaluar en <c>s</c>.</param>
        <summary>Indica si el carácter situado en la posición especificada de la cadena especificada tiene una unidad de código suplente.</summary>
        <returns>
          <see langword="true" /> si el carácter que ocupa la posición <paramref name="index" /> en <paramref name="s" /> es un suplente alto o un suplente bajo; en caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Posiciones de caracteres en una cadena se indizan empezando desde cero.  
  
 Un suplente es un <xref:System.Char> objeto con una unidad de código UTF-16 en el intervalo de U+D800 a U+DFFF. Cada carácter con una unidad de código de este intervalo pertenece a la <xref:System.Globalization.UnicodeCategory.Surrogate?displayProperty=nameWithType> categoría. La unidad de código suplente individual no tiene una interpretación propia, pero tiene significado solo cuando se usan como parte de un par suplente. Para obtener más información sobre los pares suplentes, vea el estándar Unicode en el [página principal de Unicode](https://go.microsoft.com/fwlink/?linkid=37123).  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra <xref:System.Char.IsSurrogate%2A>.  
  
 [!code-cpp[System.Char.IsSurrogate#11](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Char.IsSurrogate/CPP/issurrogate.cpp#11)]
 [!code-csharp[System.Char.IsSurrogate#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Char.IsSurrogate/CS/issurrogate.cs#11)]
 [!code-vb[System.Char.IsSurrogate#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Char.IsSurrogate/VB/issurrogate.vb#11)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El valor de <paramref name="s" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> es menor que cero o mayor que la última posición en <paramref name="s" />.</exception>
        <altmember cref="Overload:System.Char.IsHighSurrogate" />
        <altmember cref="Overload:System.Char.IsLowSurrogate" />
        <altmember cref="Overload:System.Char.IsSurrogatePair" />
      </Docs>
    </Member>
    <MemberGroup MemberName="IsSurrogatePair">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Indica si dos objetos <see cref="T:System.Char" /> especificados forman un par suplente.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="IsSurrogatePair">
      <MemberSignature Language="C#" Value="public static bool IsSurrogatePair (char highSurrogate, char lowSurrogate);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsSurrogatePair(char highSurrogate, char lowSurrogate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.IsSurrogatePair(System.Char,System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsSurrogatePair (highSurrogate As Char, lowSurrogate As Char) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsSurrogatePair(char highSurrogate, char lowSurrogate);" />
      <MemberSignature Language="F#" Value="static member IsSurrogatePair : char * char -&gt; bool" Usage="System.char.IsSurrogatePair (highSurrogate, lowSurrogate)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="highSurrogate" Type="System.Char" />
        <Parameter Name="lowSurrogate" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="highSurrogate">Carácter que se va a evaluar como suplente alto de un par suplente.</param>
        <param name="lowSurrogate">Carácter que se va a evaluar como suplente bajo de un par suplente.</param>
        <summary>Indica si los dos objetos <see cref="T:System.Char" /> especificados forman un par suplente.</summary>
        <returns>
          <see langword="true" /> si el valor numérico del parámetro <paramref name="highSurrogate" /> va de U+D800 a U+DBFF, y el valor numérico del parámetro <paramref name="lowSurrogate" /> va de U+DC00 a U+DFFF; en caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Normalmente, un único carácter se representa mediante una sola unidad de código Unicode de 16 bits. Codificación UTF-16 también es compatible con los pares suplentes, lo que permite un único carácter abstracto representarlo mediante dos unidades de código de 16 bits. La primera unidad de código, cuyo valor puede oscilar entre U+D800 y u+DBFF, es el suplente alto. La segunda unidad de código, cuyo valor puede oscilar entre U+DC00 a U+DFFF, es el suplente bajo. Puntos de código suplente individuales no tienen ninguna interpretación de sus propios. Para obtener más información sobre caracteres suplentes y el estándar Unicode, vea el [página principal de Unicode](https://go.microsoft.com/fwlink/?LinkId=37123).  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra el <xref:System.Char.IsHighSurrogate%2A>, <xref:System.Char.IsLowSurrogate%2A>, y <xref:System.Char.IsSurrogatePair%2A> métodos.  
  
 [!code-cpp[char.surrogate#1](~/samples/snippets/cpp/VS_Snippets_CLR/char.surrogate/CPP/sur.cpp#1)]
 [!code-csharp[char.surrogate#1](~/samples/snippets/csharp/VS_Snippets_CLR/char.surrogate/CS/sur.cs#1)]
 [!code-vb[char.surrogate#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/char.surrogate/VB/sur.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Char.IsHighSurrogate(System.Char)" />
        <altmember cref="M:System.Char.IsLowSurrogate(System.Char)" />
      </Docs>
    </Member>
    <Member MemberName="IsSurrogatePair">
      <MemberSignature Language="C#" Value="public static bool IsSurrogatePair (string s, int index);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsSurrogatePair(string s, int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.IsSurrogatePair(System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsSurrogatePair (s As String, index As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsSurrogatePair(System::String ^ s, int index);" />
      <MemberSignature Language="F#" Value="static member IsSurrogatePair : string * int -&gt; bool" Usage="System.char.IsSurrogatePair (s, index)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="s">Una cadena.</param>
        <param name="index">Posición inicial del par de caracteres que se va a evaluar dentro de <c>s</c>.</param>
        <summary>Indica si dos objetos <see cref="T:System.Char" /> adyacentes en la posición especificada de una cadena forman un par suplente.</summary>
        <returns>
          <see langword="true" /> si el parámetro <paramref name="s" /> incluye caracteres adyacentes en las posiciones <paramref name="index" /> y <paramref name="index" /> + 1, el valor numérico del carácter situado en la posición <paramref name="index" /> va de U+D800 a U+DBFF y el valor numérico del carácter situado en la posición <paramref name="index" /> +1 va de U+DC00 a U+DFFF; en caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Normalmente, un único carácter se representa mediante una sola unidad de código Unicode de 16 bits. Codificación UTF-16 también es compatible con los pares suplentes, lo que permite un único carácter abstracto representarlo mediante dos unidades de código de 16 bits. La primera unidad de código, cuyo valor puede oscilar entre U+D800 y u+DBFF, es el suplente alto. La segunda unidad de código, cuyo valor puede oscilar entre U+DC00 a U+DFFF, es el suplente bajo. Puntos de código suplente individuales no tienen ninguna interpretación de sus propios. Para obtener más información sobre caracteres suplentes y el estándar Unicode, vea el [página principal de Unicode](https://go.microsoft.com/fwlink/?LinkId=37123).  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra el <xref:System.Char.IsHighSurrogate%2A>, <xref:System.Char.IsLowSurrogate%2A>, y <xref:System.Char.IsSurrogatePair%2A> métodos.  
  
 [!code-cpp[char.surrogate#1](~/samples/snippets/cpp/VS_Snippets_CLR/char.surrogate/CPP/sur.cpp#1)]
 [!code-csharp[char.surrogate#1](~/samples/snippets/csharp/VS_Snippets_CLR/char.surrogate/CS/sur.cs#1)]
 [!code-vb[char.surrogate#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/char.surrogate/VB/sur.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El valor de <paramref name="s" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> no es una posición dentro de <paramref name="s" />.</exception>
        <altmember cref="M:System.Char.IsHighSurrogate(System.Char)" />
        <altmember cref="M:System.Char.IsLowSurrogate(System.Char)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="IsSymbol">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Indica si un carácter Unicode se clasifica por categorías como un carácter de símbolo.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Símbolos válidos son miembros de las siguientes categorías de <xref:System.Globalization.UnicodeCategory>: `MathSymbol`, `CurrencySymbol`, `ModifierSymbol`, y `OtherSymbol`.  
  
 Símbolos en el estándar Unicode son un conjunto definido de acoplamiento flexible de caracteres que incluyen lo siguiente:  
  
-   Símbolos de moneda.  
  
-   Símbolos tipo letra, que incluyen un conjunto de símbolos alfanuméricos matemáticos, así como los símbolos como ℅, № y™.  
  
-   Número de formas, como superíndices y subíndices.  
  
-   Operadores matemáticos y flechas.  
  
-   Símbolos geométricos.  
  
-   Símbolos técnicos.  
  
-   Patrones de Braille.  
  
-   Dingbats.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="IsSymbol">
      <MemberSignature Language="C#" Value="public static bool IsSymbol (char c);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsSymbol(char c) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.IsSymbol(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsSymbol (c As Char) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsSymbol(char c);" />
      <MemberSignature Language="F#" Value="static member IsSymbol : char -&gt; bool" Usage="System.char.IsSymbol c" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="c" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="c">Carácter Unicode que se va a evaluar.</param>
        <summary>Indica si el carácter Unicode especificado se clasifica por categorías como un carácter de símbolo.</summary>
        <returns>
          <see langword="true" /> si <paramref name="c" /> es un carácter de símbolo; en caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Símbolos válidos son miembros de las siguientes categorías de <xref:System.Globalization.UnicodeCategory>: `MathSymbol`, `CurrencySymbol`, `ModifierSymbol`, y `OtherSymbol`.  
  
 Símbolos en el estándar Unicode son un conjunto definido de acoplamiento flexible de caracteres que incluyen lo siguiente:  
  
-   Símbolos de moneda.  
  
-   Símbolos tipo letra, que incluyen un conjunto de símbolos alfanuméricos matemáticos, así como los símbolos como ℅, № y™.  
  
-   Número de formas, como superíndices y subíndices.  
  
-   Operadores matemáticos y flechas.  
  
-   Símbolos geométricos.  
  
-   Símbolos técnicos.  
  
-   Patrones de Braille.  
  
-   Dingbats.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra <xref:System.Char.IsSymbol%2A>.  
  
 [!code-cpp[System.Char.IsSymbol#12](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Char.IsSymbol/CPP/issymbol.cpp#12)]
 [!code-csharp[System.Char.IsSymbol#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Char.IsSymbol/CS/issymbol.cs#12)]
 [!code-vb[System.Char.IsSymbol#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Char.IsSymbol/VB/issymbol.vb#12)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Boolean" />
      </Docs>
    </Member>
    <Member MemberName="IsSymbol">
      <MemberSignature Language="C#" Value="public static bool IsSymbol (string s, int index);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsSymbol(string s, int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.IsSymbol(System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsSymbol (s As String, index As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsSymbol(System::String ^ s, int index);" />
      <MemberSignature Language="F#" Value="static member IsSymbol : string * int -&gt; bool" Usage="System.char.IsSymbol (s, index)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="s">Una cadena.</param>
        <param name="index">Posición del carácter que se va a evaluar en <c>s</c>.</param>
        <summary>Indica si el carácter que ocupa la posición especificada en una cadena especificada se clasifica por categorías como un carácter de símbolo.</summary>
        <returns>
          <see langword="true" /> si el carácter que ocupa la posición <paramref name="index" /> en <paramref name="s" /> es un carácter de símbolo; en caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Posiciones de caracteres en una cadena se indizan empezando desde cero.  
  
 Símbolos válidos son miembros de las siguientes categorías de <xref:System.Globalization.UnicodeCategory?displayProperty=nameWithType>: `MathSymbol`, `CurrencySymbol`, `ModifierSymbol`, y `OtherSymbol`.  
  
 Símbolos en el estándar Unicode son un conjunto definido de acoplamiento flexible de caracteres que incluyen lo siguiente:  
  
-   Símbolos de moneda.  
  
-   Símbolos tipo letra, que incluyen un conjunto de símbolos alfanuméricos matemáticos, así como los símbolos como ℅, № y™.  
  
-   Número de formas, como superíndices y subíndices.  
  
-   Operadores matemáticos y flechas.  
  
-   Símbolos geométricos.  
  
-   Símbolos técnicos.  
  
-   Patrones de Braille.  
  
-   Dingbats.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra <xref:System.Char.IsSymbol%2A>.  
  
 [!code-cpp[System.Char.IsSymbol#12](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Char.IsSymbol/CPP/issymbol.cpp#12)]
 [!code-csharp[System.Char.IsSymbol#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Char.IsSymbol/CS/issymbol.cs#12)]
 [!code-vb[System.Char.IsSymbol#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Char.IsSymbol/VB/issymbol.vb#12)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El valor de <paramref name="s" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> es menor que cero o mayor que la última posición en <paramref name="s" />.</exception>
        <altmember cref="T:System.Boolean" />
        <altmember cref="T:System.String" />
      </Docs>
    </Member>
    <MemberGroup MemberName="IsUpper">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Indica si un carácter Unicode se clasifica por categorías como una letra mayúscula.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="IsUpper">
      <MemberSignature Language="C#" Value="public static bool IsUpper (char c);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsUpper(char c) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.IsUpper(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsUpper (c As Char) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsUpper(char c);" />
      <MemberSignature Language="F#" Value="static member IsUpper : char -&gt; bool" Usage="System.char.IsUpper c" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="c" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="c">Carácter Unicode que se va a evaluar.</param>
        <summary>Indica si el carácter Unicode especificado se clasifica por categorías como una letra mayúscula.</summary>
        <returns>
          <see langword="true" /> si <paramref name="c" /> es una letra mayúscula; en caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Las letras mayúsculas válidas son miembros de la siguiente categoría de <xref:System.Globalization.UnicodeCategory>: `UppercaseLetter`.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Boolean" />
        <altmember cref="M:System.Char.IsLower(System.Char)" />
      </Docs>
    </Member>
    <Member MemberName="IsUpper">
      <MemberSignature Language="C#" Value="public static bool IsUpper (string s, int index);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsUpper(string s, int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.IsUpper(System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsUpper (s As String, index As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsUpper(System::String ^ s, int index);" />
      <MemberSignature Language="F#" Value="static member IsUpper : string * int -&gt; bool" Usage="System.char.IsUpper (s, index)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="s">Una cadena.</param>
        <param name="index">Posición del carácter que se va a evaluar en <c>s</c>.</param>
        <summary>Indica si el carácter que ocupa la posición especificada en una cadena especificada se clasifica por categorías como una letra mayúscula.</summary>
        <returns>
          <see langword="true" /> si el carácter que ocupa la posición <paramref name="index" /> en <paramref name="s" /> es una letra mayúscula; en caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Posiciones de caracteres en una cadena se indizan empezando desde cero.  
  
 Las letras mayúsculas válidas son miembros de la siguiente categoría de <xref:System.Globalization.UnicodeCategory>: `UppercaseLetter`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El valor de <paramref name="s" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> es menor que cero o mayor que la última posición en <paramref name="s" />.</exception>
        <altmember cref="T:System.Boolean" />
        <altmember cref="T:System.String" />
      </Docs>
    </Member>
    <MemberGroup MemberName="IsWhiteSpace">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Indica si un carácter Unicode se clasifica por categorías como un espacio en blanco.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Caracteres de espacio en blanco son los siguientes caracteres Unicode:  
  
-   Los miembros de la <xref:System.Globalization.UnicodeCategory.SpaceSeparator?displayProperty=nameWithType> categoría, que incluye los caracteres de espacio (u+0020), espacio de NO separación (00A0), marca de espacio OGHAM (u+1680), Cuadrante corto (u+2000), EM QUAD (U + 2001), EN espacio (2002), EM espacio (U + 2003), espacio tres por largo (U + 2004), (cuatro por EM espacio U+ 2005), espacio seis por largo (U + 2006), espacio en la figura (U + 2007), fino (U + 2008), signo de puntuación del espacio espacio (U + 2009), espacio pelo (200A), espacio de NO separación estrecha (202F), espacio matemático intermedio (205F) y espacio ideográfico (u+3000).  
  
-   Los miembros de la <xref:System.Globalization.UnicodeCategory.LineSeparator?displayProperty=nameWithType> categoría, que consiste únicamente en el carácter separador de línea (u+2028).  
  
-   Los miembros de la <xref:System.Globalization.UnicodeCategory.ParagraphSeparator?displayProperty=nameWithType> categoría, que consiste únicamente en el carácter separador de párrafo (u+2029).  
  
-   Los caracteres del carácter de tabulación (u+0009), línea fuente (000A), tabulación de línea (000B), avance de página (U+000C), retorno de carro (U+000D) y, a continuación de línea (0085).  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="IsWhiteSpace">
      <MemberSignature Language="C#" Value="public static bool IsWhiteSpace (char c);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsWhiteSpace(char c) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.IsWhiteSpace(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsWhiteSpace (c As Char) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsWhiteSpace(char c);" />
      <MemberSignature Language="F#" Value="static member IsWhiteSpace : char -&gt; bool" Usage="System.char.IsWhiteSpace c" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="c" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="c">Carácter Unicode que se va a evaluar.</param>
        <summary>Indica si el carácter Unicode especificado se clasifica por categorías como un espacio en blanco.</summary>
        <returns>
          <see langword="true" /> si <paramref name="c" /> es un espacio en blanco; en caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Caracteres de espacio en blanco son los siguientes caracteres Unicode:  
  
-   Los miembros de la <xref:System.Globalization.UnicodeCategory.SpaceSeparator?displayProperty=nameWithType> categoría, que incluye los caracteres de espacio (u+0020), espacio de NO separación (00A0), marca de espacio OGHAM (u+1680), Cuadrante corto (u+2000), EM QUAD (U + 2001), EN espacio (2002), EM espacio (U + 2003), espacio tres por largo (U + 2004), (cuatro por EM espacio U+ 2005), espacio seis por largo (U + 2006), espacio en la figura (U + 2007), fino (U + 2008), signo de puntuación del espacio espacio (U + 2009), espacio pelo (200A), espacio de NO separación estrecha (202F), espacio matemático intermedio (205F) y espacio ideográfico (u+3000).  
  
-   Los miembros de la <xref:System.Globalization.UnicodeCategory.LineSeparator?displayProperty=nameWithType> categoría, que consiste únicamente en el carácter separador de línea (u+2028).  
  
-   Los miembros de la <xref:System.Globalization.UnicodeCategory.ParagraphSeparator?displayProperty=nameWithType> categoría, que consiste únicamente en el carácter separador de párrafo (u+2029).  
  
-   Los caracteres del carácter de tabulación (u+0009), línea fuente (000A), tabulación de línea (000B), avance de página (U+000C), retorno de carro (U+000D) y, a continuación de línea (0085).  
  
   
  
## Examples  
 En el ejemplo siguiente se muestra el <xref:System.Char.IsWhiteSpace%28System.Char%29> método.  
  
 [!code-cpp[System.Char.IsWhiteSpace#14](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Char.IsWhiteSpace/CPP/iswhitespace.cpp#14)]
 [!code-csharp[System.Char.IsWhiteSpace#14](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Char.IsWhiteSpace/CS/iswhitespace.cs#14)]
 [!code-vb[System.Char.IsWhiteSpace#14](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Char.IsWhiteSpace/VB/iswhitespace.vb#14)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Boolean" />
        <altmember cref="T:System.Globalization.UnicodeCategory" />
      </Docs>
    </Member>
    <Member MemberName="IsWhiteSpace">
      <MemberSignature Language="C#" Value="public static bool IsWhiteSpace (string s, int index);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsWhiteSpace(string s, int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.IsWhiteSpace(System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsWhiteSpace (s As String, index As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsWhiteSpace(System::String ^ s, int index);" />
      <MemberSignature Language="F#" Value="static member IsWhiteSpace : string * int -&gt; bool" Usage="System.char.IsWhiteSpace (s, index)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="s">Una cadena.</param>
        <param name="index">Posición del carácter que se va a evaluar en <c>s</c>.</param>
        <summary>Indica si el carácter que ocupa la posición especificada en una cadena especificada se clasifica por categorías como un espacio en blanco.</summary>
        <returns>
          <see langword="true" /> si el carácter que ocupa la posición <paramref name="index" /> en <paramref name="s" /> es un espacio en blanco; en caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Posiciones de caracteres en una cadena se indizan empezando desde cero.  
  
 Caracteres de espacio en blanco son los siguientes caracteres Unicode:  
  
-   Los miembros de la <xref:System.Globalization.UnicodeCategory.SpaceSeparator?displayProperty=nameWithType> categoría, que incluye los caracteres de espacio (u+0020), espacio de NO separación (00A0), marca de espacio OGHAM (u+1680), Cuadrante corto (u+2000), EM QUAD (U + 2001), EN espacio (2002), EM espacio (U + 2003), espacio tres por largo (U + 2004), (cuatro por EM espacio U+ 2005), espacio seis por largo (U + 2006), espacio en la figura (U + 2007), fino (U + 2008), signo de puntuación del espacio espacio (U + 2009), espacio pelo (200A), espacio de NO separación estrecha (202F), espacio matemático intermedio (205F) y espacio ideográfico (u+3000).  
  
-   Los miembros de la <xref:System.Globalization.UnicodeCategory.LineSeparator?displayProperty=nameWithType> categoría, que consiste únicamente en el carácter separador de línea (u+2028).  
  
-   Los miembros de la <xref:System.Globalization.UnicodeCategory.ParagraphSeparator?displayProperty=nameWithType> categoría, que consiste únicamente en el carácter separador de párrafo (u+2029).  
  
-   Los caracteres del carácter de tabulación (u+0009), línea fuente (000A), tabulación de línea (000B), avance de página (U+000C), retorno de carro (U+000D) y, a continuación de línea (0085).  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra <xref:System.Char.IsWhiteSpace%2A>.  
  
 [!code-cpp[System.Char.IsWhiteSpace#14](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Char.IsWhiteSpace/CPP/iswhitespace.cpp#14)]
 [!code-csharp[System.Char.IsWhiteSpace#14](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Char.IsWhiteSpace/CS/iswhitespace.cs#14)]
 [!code-vb[System.Char.IsWhiteSpace#14](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Char.IsWhiteSpace/VB/iswhitespace.vb#14)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El valor de <paramref name="s" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> es menor que cero o mayor que la última posición en <paramref name="s" />.</exception>
        <altmember cref="T:System.Boolean" />
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Globalization.UnicodeCategory" />
      </Docs>
    </Member>
    <Member MemberName="MaxValue">
      <MemberSignature Language="C#" Value="public const char MaxValue;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal char MaxValue" />
      <MemberSignature Language="DocId" Value="F:System.Char.MaxValue" />
      <MemberSignature Language="VB.NET" Value="Public Const MaxValue As Char " />
      <MemberSignature Language="C++ CLI" Value="public: char MaxValue;" />
      <MemberSignature Language="F#" Value="val mutable MaxValue : char" Usage="System.char.MaxValue" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Representa el mayor valor posible de un <see cref="T:System.Char" />. Este campo es constante.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El valor de esta constante es el hexadecimal 0xFFFF.  
  
 ]]></format>
        </remarks>
        <altmember cref="F:System.Char.MinValue" />
      </Docs>
    </Member>
    <Member MemberName="MinValue">
      <MemberSignature Language="C#" Value="public const char MinValue;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal char MinValue" />
      <MemberSignature Language="DocId" Value="F:System.Char.MinValue" />
      <MemberSignature Language="VB.NET" Value="Public Const MinValue As Char " />
      <MemberSignature Language="C++ CLI" Value="public: char MinValue;" />
      <MemberSignature Language="F#" Value="val mutable MinValue : char" Usage="System.char.MinValue" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Representa el menor valor posible de un <see cref="T:System.Char" />. Este campo es constante.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El valor de esta constante es el hexadecimal 0 x 00.  
  
 ]]></format>
        </remarks>
        <altmember cref="F:System.Char.MaxValue" />
      </Docs>
    </Member>
    <Member MemberName="Parse">
      <MemberSignature Language="C#" Value="public static char Parse (string s);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig char Parse(string s) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.Parse(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Parse (s As String) As Char" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static char Parse(System::String ^ s);" />
      <MemberSignature Language="F#" Value="static member Parse : string -&gt; char" Usage="System.char.Parse s" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="s">Una cadena que contiene un carácter único, o <see langword="null" />.</param>
        <summary>Convierte el valor de la cadena especificada en el carácter Unicode equivalente.</summary>
        <returns>Carácter Unicode equivalente al carácter único de <paramref name="s" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 En el ejemplo de código siguiente se muestra <xref:System.Char.Parse%2A>.  
  
 [!code-cpp[System.Char.Parse#15](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Char.Parse/CPP/parse.cpp#15)]
 [!code-csharp[System.Char.Parse#15](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Char.Parse/CS/parse.cs#15)]
 [!code-vb[System.Char.Parse#15](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Char.Parse/VB/parse.vb#15)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El valor de <paramref name="s" /> es <see langword="null" />.</exception>
        <exception cref="T:System.FormatException">La longitud de <paramref name="s" /> no es 1.</exception>
        <altmember cref="M:System.Char.ToString" />
        <related type="Article" href="https://msdn.microsoft.com/library/d139bc00-3c4e-4d78-ac9a-5c951b258d28">Analizar otras cadenas en .NET Framework</related>
      </Docs>
    </Member>
    <Member MemberName="System.IComparable.CompareTo">
      <MemberSignature Language="C#" Value="int IComparable.CompareTo (object value);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int32 System.IComparable.CompareTo(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.System#IComparable#CompareTo(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Function CompareTo (value As Object) As Integer Implements IComparable.CompareTo" />
      <MemberSignature Language="C++ CLI" Value=" virtual int System.IComparable.CompareTo(System::Object ^ value) = IComparable::CompareTo;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IComparable.CompareTo(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.GetTypeCode">
      <MemberSignature Language="C#" Value="TypeCode IConvertible.GetTypeCode ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance valuetype System.TypeCode System.IConvertible.GetTypeCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.System#IConvertible#GetTypeCode" />
      <MemberSignature Language="VB.NET" Value="Function GetTypeCode () As TypeCode Implements IConvertible.GetTypeCode" />
      <MemberSignature Language="C++ CLI" Value=" virtual TypeCode System.IConvertible.GetTypeCode() = IConvertible::GetTypeCode;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.GetTypeCode</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.TypeCode</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToBoolean">
      <MemberSignature Language="C#" Value="bool IConvertible.ToBoolean (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool System.IConvertible.ToBoolean(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.System#IConvertible#ToBoolean(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToBoolean (provider As IFormatProvider) As Boolean Implements IConvertible.ToBoolean" />
      <MemberSignature Language="C++ CLI" Value=" virtual bool System.IConvertible.ToBoolean(IFormatProvider ^ provider) = IConvertible::ToBoolean;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToBoolean(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Este parámetro se ignora.</param>
        <summary>**Nota** No se admite esta conversión. Si se intenta, se produce una excepción <see cref="T:System.InvalidCastException" />.</summary>
        <returns>No se admite esta conversión. No se devuelve ningún valor.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidCastException">No se admite esta conversión.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToByte">
      <MemberSignature Language="C#" Value="byte IConvertible.ToByte (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance unsigned int8 System.IConvertible.ToByte(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.System#IConvertible#ToByte(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToByte (provider As IFormatProvider) As Byte Implements IConvertible.ToByte" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Byte System.IConvertible.ToByte(IFormatProvider ^ provider) = IConvertible::ToByte;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToByte(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Este parámetro se ignora.</param>
        <summary>Para una descripción de este miembro, vea <see cref="M:System.IConvertible.ToByte(System.IFormatProvider)" />.</summary>
        <returns>Valor convertido del objeto <see cref="T:System.Char" /> actual.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este miembro es una implementación explícita de un miembro de interfaz. Solo se puede utilizar cuando la instancia de <xref:System.Char> se convierte en una interfaz <xref:System.IConvertible>. La alternativa recomendada es llamar a la <xref:System.Convert.ToByte%28System.Char%29?displayProperty=nameWithType> método en su lugar.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToChar">
      <MemberSignature Language="C#" Value="char IConvertible.ToChar (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance char System.IConvertible.ToChar(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.System#IConvertible#ToChar(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToChar (provider As IFormatProvider) As Char Implements IConvertible.ToChar" />
      <MemberSignature Language="C++ CLI" Value=" virtual char System.IConvertible.ToChar(IFormatProvider ^ provider) = IConvertible::ToChar;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToChar(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Este parámetro se ignora.</param>
        <summary>Para una descripción de este miembro, vea <see cref="M:System.IConvertible.ToChar(System.IFormatProvider)" />.</summary>
        <returns>Valor del objeto actual <see cref="T:System.Char" /> sin modificar.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este miembro es una implementación explícita de un miembro de interfaz. Solo se puede utilizar cuando la instancia de <xref:System.Char> se convierte en una interfaz <xref:System.IConvertible>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToDateTime">
      <MemberSignature Language="C#" Value="DateTime IConvertible.ToDateTime (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance valuetype System.DateTime System.IConvertible.ToDateTime(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.System#IConvertible#ToDateTime(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToDateTime (provider As IFormatProvider) As DateTime Implements IConvertible.ToDateTime" />
      <MemberSignature Language="C++ CLI" Value=" virtual DateTime System.IConvertible.ToDateTime(IFormatProvider ^ provider) = IConvertible::ToDateTime;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToDateTime(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Este parámetro se ignora.</param>
        <summary>**Nota** No se admite esta conversión. Si se intenta, se produce una excepción <see cref="T:System.InvalidCastException" />.</summary>
        <returns>No se devuelve ningún valor.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidCastException">No se admite esta conversión.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToDecimal">
      <MemberSignature Language="C#" Value="decimal IConvertible.ToDecimal (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance valuetype System.Decimal System.IConvertible.ToDecimal(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.System#IConvertible#ToDecimal(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToDecimal (provider As IFormatProvider) As Decimal Implements IConvertible.ToDecimal" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Decimal System.IConvertible.ToDecimal(IFormatProvider ^ provider) = IConvertible::ToDecimal;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToDecimal(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Este parámetro se ignora.</param>
        <summary>**Nota** No se admite esta conversión. Si se intenta, se produce una excepción <see cref="T:System.InvalidCastException" />.</summary>
        <returns>No se devuelve ningún valor.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidCastException">No se admite esta conversión.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToDouble">
      <MemberSignature Language="C#" Value="double IConvertible.ToDouble (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance float64 System.IConvertible.ToDouble(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.System#IConvertible#ToDouble(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToDouble (provider As IFormatProvider) As Double Implements IConvertible.ToDouble" />
      <MemberSignature Language="C++ CLI" Value=" virtual double System.IConvertible.ToDouble(IFormatProvider ^ provider) = IConvertible::ToDouble;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToDouble(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Este parámetro se ignora.</param>
        <summary>**Nota** No se admite esta conversión. Si se intenta, se produce una excepción <see cref="T:System.InvalidCastException" />.</summary>
        <returns>No se devuelve ningún valor.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidCastException">No se admite esta conversión.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToInt16">
      <MemberSignature Language="C#" Value="short IConvertible.ToInt16 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int16 System.IConvertible.ToInt16(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.System#IConvertible#ToInt16(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToInt16 (provider As IFormatProvider) As Short Implements IConvertible.ToInt16" />
      <MemberSignature Language="C++ CLI" Value=" virtual short System.IConvertible.ToInt16(IFormatProvider ^ provider) = IConvertible::ToInt16;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToInt16(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Este parámetro se ignora.</param>
        <summary>Para una descripción de este miembro, vea <see cref="M:System.IConvertible.ToInt16(System.IFormatProvider)" />.</summary>
        <returns>Valor convertido del objeto <see cref="T:System.Char" /> actual.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este miembro es una implementación explícita de un miembro de interfaz. Solo se puede utilizar cuando la instancia de <xref:System.Char> se convierte en una interfaz <xref:System.IConvertible>. La alternativa recomendada es llamar a la <xref:System.Convert.ToInt16%28System.Char%29?displayProperty=nameWithType> método en su lugar.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToInt32">
      <MemberSignature Language="C#" Value="int IConvertible.ToInt32 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int32 System.IConvertible.ToInt32(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.System#IConvertible#ToInt32(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToInt32 (provider As IFormatProvider) As Integer Implements IConvertible.ToInt32" />
      <MemberSignature Language="C++ CLI" Value=" virtual int System.IConvertible.ToInt32(IFormatProvider ^ provider) = IConvertible::ToInt32;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToInt32(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Este parámetro se ignora.</param>
        <summary>Para una descripción de este miembro, vea <see cref="M:System.IConvertible.ToInt32(System.IFormatProvider)" />.</summary>
        <returns>Valor convertido del objeto <see cref="T:System.Char" /> actual.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este miembro es una implementación explícita de un miembro de interfaz. Solo se puede utilizar cuando la instancia de <xref:System.Char> se convierte en una interfaz <xref:System.IConvertible>. La alternativa recomendada es llamar a la <xref:System.Convert.ToInt32%28System.Char%29?displayProperty=nameWithType> método en su lugar.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToInt64">
      <MemberSignature Language="C#" Value="long IConvertible.ToInt64 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int64 System.IConvertible.ToInt64(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.System#IConvertible#ToInt64(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToInt64 (provider As IFormatProvider) As Long Implements IConvertible.ToInt64" />
      <MemberSignature Language="C++ CLI" Value=" virtual long System.IConvertible.ToInt64(IFormatProvider ^ provider) = IConvertible::ToInt64;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToInt64(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Este parámetro se ignora.</param>
        <summary>Para una descripción de este miembro, vea <see cref="M:System.IConvertible.ToInt64(System.IFormatProvider)" />.</summary>
        <returns>Valor convertido del objeto <see cref="T:System.Char" /> actual.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este miembro es una implementación explícita de un miembro de interfaz. Solo se puede utilizar cuando la instancia de <xref:System.Char> se convierte en una interfaz <xref:System.IConvertible>. La alternativa recomendada es llamar a la <xref:System.Convert.ToInt64%28System.Char%29?displayProperty=nameWithType> método en su lugar.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToSByte">
      <MemberSignature Language="C#" Value="sbyte IConvertible.ToSByte (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int8 System.IConvertible.ToSByte(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.System#IConvertible#ToSByte(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToSByte (provider As IFormatProvider) As SByte Implements IConvertible.ToSByte" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::SByte System.IConvertible.ToSByte(IFormatProvider ^ provider) = IConvertible::ToSByte;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToSByte(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.SByte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Este parámetro se ignora.</param>
        <summary>Para una descripción de este miembro, vea <see cref="M:System.IConvertible.ToSByte(System.IFormatProvider)" />.</summary>
        <returns>Valor convertido del objeto <see cref="T:System.Char" /> actual.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este miembro es una implementación explícita de un miembro de interfaz. Solo se puede utilizar cuando la instancia de <xref:System.Char> se convierte en una interfaz <xref:System.IConvertible>. La alternativa recomendada es llamar a la <xref:System.Convert.ToSByte%28System.Char%29?displayProperty=nameWithType> método en su lugar.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToSingle">
      <MemberSignature Language="C#" Value="float IConvertible.ToSingle (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance float32 System.IConvertible.ToSingle(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.System#IConvertible#ToSingle(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToSingle (provider As IFormatProvider) As Single Implements IConvertible.ToSingle" />
      <MemberSignature Language="C++ CLI" Value=" virtual float System.IConvertible.ToSingle(IFormatProvider ^ provider) = IConvertible::ToSingle;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToSingle(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Este parámetro se ignora.</param>
        <summary>**Nota** No se admite esta conversión. Si se intenta, se produce una excepción <see cref="T:System.InvalidCastException" />.</summary>
        <returns>No se devuelve ningún valor.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidCastException">No se admite esta conversión.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToString">
      <MemberSignature Language="C#" Value="string IConvertible.ToString (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance string System.IConvertible.ToString(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.System#IConvertible#ToString(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToString (provider As IFormatProvider) As String Implements IConvertible.ToString" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::String ^ System.IConvertible.ToString(IFormatProvider ^ provider) = IConvertible::ToString;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToString(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToType">
      <MemberSignature Language="C#" Value="object IConvertible.ToType (Type type, IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance object System.IConvertible.ToType(class System.Type type, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.System#IConvertible#ToType(System.Type,System.IFormatProvider)" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Object ^ System.IConvertible.ToType(Type ^ type, IFormatProvider ^ provider) = IConvertible::ToType;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToType(System.Type,System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="type">Un objeto <see cref="T:System.Type" />.</param>
        <param name="provider">Un objeto <see cref="T:System.IFormatProvider" />.</param>
        <summary>Para una descripción de este miembro, vea <see cref="M:System.IConvertible.ToType(System.Type,System.IFormatProvider)" />.</summary>
        <returns>Objeto del tipo especificado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este miembro es una implementación explícita de un miembro de interfaz. Solo se puede utilizar cuando la instancia de <xref:System.Char> se convierte en una interfaz <xref:System.IConvertible>. La alternativa recomendada es llamar a la <xref:System.Convert.ChangeType%28System.Object%2CSystem.Type%2CSystem.IFormatProvider%29> método en su lugar.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El valor de <paramref name="type" /> es <see langword="null" />.</exception>
        <exception cref="T:System.InvalidCastException">El valor del objeto <see cref="T:System.Char" /> actual no se puede convertir al tipo especificado por el parámetro <paramref name="type" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToUInt16">
      <MemberSignature Language="C#" Value="ushort IConvertible.ToUInt16 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance unsigned int16 System.IConvertible.ToUInt16(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.System#IConvertible#ToUInt16(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToUInt16 (provider As IFormatProvider) As UShort Implements IConvertible.ToUInt16" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::UInt16 System.IConvertible.ToUInt16(IFormatProvider ^ provider) = IConvertible::ToUInt16;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToUInt16(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Un objeto <see cref="T:System.IFormatProvider" />. (Especifique <see langword="null" />, ya que se omite el parámetro <c>provider</c>).</param>
        <summary>Para una descripción de este miembro, vea <see cref="M:System.IConvertible.ToUInt16(System.IFormatProvider)" />.</summary>
        <returns>Valor convertido del objeto <see cref="T:System.Char" /> actual.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este miembro es una implementación explícita de un miembro de interfaz. Solo se puede utilizar cuando la instancia de <xref:System.Char> se convierte en una interfaz <xref:System.IConvertible>. La alternativa recomendada es llamar a la <xref:System.Convert.ToUInt16%28System.Char%29?displayProperty=nameWithType> método en su lugar.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToUInt32">
      <MemberSignature Language="C#" Value="uint IConvertible.ToUInt32 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance unsigned int32 System.IConvertible.ToUInt32(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.System#IConvertible#ToUInt32(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToUInt32 (provider As IFormatProvider) As UInteger Implements IConvertible.ToUInt32" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::UInt32 System.IConvertible.ToUInt32(IFormatProvider ^ provider) = IConvertible::ToUInt32;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToUInt32(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Un objeto <see cref="T:System.IFormatProvider" />. (Especifique <see langword="null" />, ya que se omite el parámetro <c>provider</c>).</param>
        <summary>Para una descripción de este miembro, vea <see cref="M:System.IConvertible.ToUInt32(System.IFormatProvider)" />.</summary>
        <returns>Valor convertido del objeto <see cref="T:System.Char" /> actual.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este miembro es una implementación explícita de un miembro de interfaz. Solo se puede utilizar cuando la instancia de <xref:System.Char> se convierte en una interfaz <xref:System.IConvertible>. La alternativa recomendada es llamar a la <xref:System.Convert.ToUInt32%28System.Char%29?displayProperty=nameWithType> método en su lugar.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToUInt64">
      <MemberSignature Language="C#" Value="ulong IConvertible.ToUInt64 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance unsigned int64 System.IConvertible.ToUInt64(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.System#IConvertible#ToUInt64(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToUInt64 (provider As IFormatProvider) As ULong Implements IConvertible.ToUInt64" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::UInt64 System.IConvertible.ToUInt64(IFormatProvider ^ provider) = IConvertible::ToUInt64;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToUInt64(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Un objeto <see cref="T:System.IFormatProvider" />. (Especifique <see langword="null" />, ya que se omite el parámetro <c>provider</c>).</param>
        <summary>Para una descripción de este miembro, vea <see cref="M:System.IConvertible.ToUInt64(System.IFormatProvider)" />.</summary>
        <returns>Valor convertido del objeto <see cref="T:System.Char" /> actual.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este miembro es una implementación explícita de un miembro de interfaz. Solo se puede utilizar cuando la instancia de <xref:System.Char> se convierte en una interfaz <xref:System.IConvertible>. La alternativa recomendada es llamar a la <xref:System.Convert.ToUInt64%28System.Char%29?displayProperty=nameWithType> método en su lugar.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="ToLower">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Convierte el valor de un carácter Unicode en un carácter equivalente, pero en minúsculas.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ToLower">
      <MemberSignature Language="C#" Value="public static char ToLower (char c);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig char ToLower(char c) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.ToLower(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ToLower (c As Char) As Char" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static char ToLower(char c);" />
      <MemberSignature Language="F#" Value="static member ToLower : char -&gt; char" Usage="System.char.ToLower c" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="c" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="c">Carácter Unicode que se va a convertir.</param>
        <summary>Convierte el valor de un carácter Unicode en un carácter equivalente, pero en minúsculas.</summary>
        <returns>Equivalente en minúsculas de <paramref name="c" /> o el valor sin modificar de <paramref name="c" /> si <paramref name="c" /> ya está en minúsculas o no es un carácter alfabético.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Las reglas de mayúsculas y minúsculas se obtienen de la referencia cultural actual.  
  
 Use <xref:System.String.ToLower%2A?displayProperty=nameWithType> para convertir una cadena a minúsculas.  
  
   
  
## Examples  
 En el ejemplo siguiente se muestra <xref:System.Char.ToLower%2A>.  
  
 [!code-cpp[System.Char.ToLower#16](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Char.ToLower/CPP/tolower.cpp#16)]
 [!code-csharp[System.Char.ToLower#16](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Char.ToLower/CS/tolower.cs#16)]
 [!code-vb[System.Char.ToLower#16](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Char.ToLower/VB/tolower.vb#16)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage">
          <para>Como se explica en [prácticas recomendadas para el uso de cadenas](~/docs/standard/base-types/best-practices-strings.md), le recomendamos que evite llamar a métodos de grafía de carácter y cadena de mayúsculas y minúsculas que sustituyen los valores predeterminados. En su lugar, debe llamar a métodos que requieren parámetros para especificarse explícitamente. Para convertir un carácter a minúsculas mediante las convenciones de mayúsculas y minúsculas de la referencia cultural actual, llame a la <see cref="M:System.Char.ToLower(System.Char,System.Globalization.CultureInfo)" /> sobrecarga del método con un valor de <see cref="P:System.Globalization.CultureInfo.CurrentCulture" /> para su <paramref name="culture" /> parámetro.</para>
        </block>
        <altmember cref="M:System.String.ToLower" />
        <altmember cref="M:System.Char.ToUpper(System.Char,System.Globalization.CultureInfo)" />
      </Docs>
    </Member>
    <Member MemberName="ToLower">
      <MemberSignature Language="C#" Value="public static char ToLower (char c, System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig char ToLower(char c, class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.ToLower(System.Char,System.Globalization.CultureInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ToLower (c As Char, culture As CultureInfo) As Char" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static char ToLower(char c, System::Globalization::CultureInfo ^ culture);" />
      <MemberSignature Language="F#" Value="static member ToLower : char * System.Globalization.CultureInfo -&gt; char" Usage="System.char.ToLower (c, culture)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="c" Type="System.Char" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
      </Parameters>
      <Docs>
        <param name="c">Carácter Unicode que se va a convertir.</param>
        <param name="culture">Objeto que proporciona reglas de mayúsculas y minúsculas específicas de la referencia cultural.</param>
        <summary>Convierte el valor de un carácter Unicode especificado en un carácter equivalente pero en minúsculas mediante la información de formato específica de la referencia cultural especificada.</summary>
        <returns>Equivalente en minúsculas de <paramref name="c" />, modificado conforme a <paramref name="culture" />, o el valor sin modificar de <paramref name="c" /> si <paramref name="c" /> ya está en minúsculas o no es un carácter alfabético.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use <xref:System.String.ToLower%2A?displayProperty=nameWithType> para convertir una cadena a minúsculas.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra <xref:System.Char.ToLower%2A>.  
  
 [!code-cpp[System.Char.ToLower#16](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Char.ToLower/CPP/tolower.cpp#16)]
 [!code-csharp[System.Char.ToLower#16](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Char.ToLower/CS/tolower.cs#16)]
 [!code-vb[System.Char.ToLower#16](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Char.ToLower/VB/tolower.vb#16)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El valor de <paramref name="culture" /> es <see langword="null" />.</exception>
        <altmember cref="P:System.Globalization.CultureInfo.CurrentCulture" />
        <altmember cref="M:System.String.ToLower" />
        <altmember cref="M:System.Char.ToUpper(System.Char,System.Globalization.CultureInfo)" />
      </Docs>
    </Member>
    <Member MemberName="ToLowerInvariant">
      <MemberSignature Language="C#" Value="public static char ToLowerInvariant (char c);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig char ToLowerInvariant(char c) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.ToLowerInvariant(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ToLowerInvariant (c As Char) As Char" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static char ToLowerInvariant(char c);" />
      <MemberSignature Language="F#" Value="static member ToLowerInvariant : char -&gt; char" Usage="System.char.ToLowerInvariant c" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="c" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="c">Carácter Unicode que se va a convertir.</param>
        <summary>Convierte el valor de un carácter Unicode en su equivalente en minúsculas utilizando las reglas sobre mayúsculas y minúsculas de la referencia cultural de todos los idiomas.</summary>
        <returns>Equivalente en minúsculas del parámetro <paramref name="c" /> o el valor sin modificar de <paramref name="c" /> si <paramref name="c" /> ya está en minúsculas o no es un carácter alfabético.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si la aplicación se ve afectada por la referencia cultural y depende en el caso de un carácter que cambien de forma predecible, use el <xref:System.Char.ToLowerInvariant%2A> método. El <xref:System.Char.ToLowerInvariant%2A> método es equivalente a `ToLower(Char, CultureInfo.InvariantCulture)`.  
  
 Use <xref:System.String.ToLowerInvariant%2A?displayProperty=nameWithType> para convertir una cadena a minúsculas.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.String.ToLower" />
        <altmember cref="M:System.Char.ToUpper(System.Char,System.Globalization.CultureInfo)" />
        <altmember cref="P:System.Globalization.CultureInfo.InvariantCulture" />
      </Docs>
    </Member>
    <MemberGroup MemberName="ToString">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Convierte el valor de esta instancia en la representación de cadena equivalente.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="char.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Convierte el valor de esta instancia en la representación de cadena equivalente.</summary>
        <returns>Representación de cadena del valor de esta instancia.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 En el ejemplo de código siguiente se muestra <xref:System.Char.ToString%2A>.  
  
 [!code-cpp[System.Char.ToString#17](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Char.ToString/CPP/tostring.cpp#17)]
 [!code-csharp[System.Char.ToString#17](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Char.ToString/CS/tostring.cs#17)]
 [!code-vb[System.Char.ToString#17](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Char.ToString/VB/tostring.vb#17)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Char.Parse(System.String)" />
        <altmember cref="T:System.String" />
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public static string ToString (char c);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string ToString(char c) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.ToString(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ToString (c As Char) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ ToString(char c);" />
      <MemberSignature Language="F#" Value="static member ToString : char -&gt; string" Usage="System.char.ToString c" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="c" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="c">Carácter Unicode que se va a convertir.</param>
        <summary>Convierte el carácter Unicode especificado en la representación de cadena equivalente.</summary>
        <returns>Representación de cadena del valor de <paramref name="c" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 En el ejemplo de código siguiente se muestra <xref:System.Char.ToString%2A>.  
  
 [!code-cpp[System.Char.ToString#17](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Char.ToString/CPP/tostring.cpp#17)]
 [!code-csharp[System.Char.ToString#17](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Char.ToString/CS/tostring.cs#17)]
 [!code-vb[System.Char.ToString#17](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Char.ToString/VB/tostring.vb#17)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Char.Parse(System.String)" />
        <altmember cref="T:System.String" />
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public string ToString (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string ToString(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.ToString(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToString (provider As IFormatProvider) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ ToString(IFormatProvider ^ provider);" />
      <MemberSignature Language="F#" Value="override this.ToString : IFormatProvider -&gt; string" Usage="char.ToString provider" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToString(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">(Reservado) Un objeto que aporta información de formato específica de la referencia cultural.</param>
        <summary>Convierte el valor de esta instancia en la representación de cadena equivalente mediante la información de formato específica de la referencia cultural especificada.</summary>
        <returns>Representación en forma de cadena del valor de esta instancia, tal y como especifica <paramref name="provider" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El `provider` parámetro se omite; no participa en esta operación.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra una sobrecarga de <xref:System.Char.ToString%2A>.  
  
 [!code-cpp[System.Char.ToString#17](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Char.ToString/CPP/tostring.cpp#17)]
 [!code-csharp[System.Char.ToString#17](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Char.ToString/CS/tostring.cs#17)]
 [!code-vb[System.Char.ToString#17](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Char.ToString/VB/tostring.vb#17)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Char.Parse(System.String)" />
        <altmember cref="T:System.String" />
      </Docs>
    </Member>
    <MemberGroup MemberName="ToUpper">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Convierte el valor de un carácter Unicode en un carácter equivalente, pero en mayúsculas.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ToUpper">
      <MemberSignature Language="C#" Value="public static char ToUpper (char c);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig char ToUpper(char c) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.ToUpper(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ToUpper (c As Char) As Char" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static char ToUpper(char c);" />
      <MemberSignature Language="F#" Value="static member ToUpper : char -&gt; char" Usage="System.char.ToUpper c" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="c" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="c">Carácter Unicode que se va a convertir.</param>
        <summary>Convierte el valor de un carácter Unicode en un carácter equivalente, pero en mayúsculas.</summary>
        <returns>Equivalente en mayúsculas del parámetro <paramref name="c" /> o el valor sin modificar de <paramref name="c" /> si <paramref name="c" /> ya está en mayúsculas, no tiene equivalente en mayúsculas o no es un carácter alfabético.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Las reglas de mayúsculas y minúsculas se obtienen de la referencia cultural actual.  
  
 Use <xref:System.String.ToUpper%2A?displayProperty=nameWithType> para convertir una cadena a mayúsculas.  
  
   
  
## Examples  
 El ejemplo siguiente convierte cada carácter de una matriz a su equivalente en mayúsculas.  
  
 [!code-csharp[System.Char.ToUpper#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.char.toupper/cs/toupper1.cs#1)]
 [!code-vb[System.Char.ToUpper#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.char.toupper/vb/toupper1.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage">
          <para>Como se explica en [prácticas recomendadas para el uso de cadenas](~/docs/standard/base-types/best-practices-strings.md), le recomendamos que evite llamar a métodos de grafía de carácter y cadena de mayúsculas y minúsculas que sustituyen los valores predeterminados. En su lugar, debe llamar a métodos que requieren parámetros para especificarse explícitamente. Para convertir un carácter a mayúsculas mediante las convenciones de mayúsculas y minúsculas de la referencia cultural actual, llame a la <see cref="M:System.Char.ToUpper(System.Char,System.Globalization.CultureInfo)" /> sobrecarga del método con un valor de <see cref="P:System.Globalization.CultureInfo.CurrentCulture" /> para su <paramref name="culture" /> parámetro.</para>
        </block>
        <altmember cref="M:System.String.ToUpper" />
        <altmember cref="M:System.Char.ToLower(System.Char,System.Globalization.CultureInfo)" />
      </Docs>
    </Member>
    <Member MemberName="ToUpper">
      <MemberSignature Language="C#" Value="public static char ToUpper (char c, System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig char ToUpper(char c, class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.ToUpper(System.Char,System.Globalization.CultureInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ToUpper (c As Char, culture As CultureInfo) As Char" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static char ToUpper(char c, System::Globalization::CultureInfo ^ culture);" />
      <MemberSignature Language="F#" Value="static member ToUpper : char * System.Globalization.CultureInfo -&gt; char" Usage="System.char.ToUpper (c, culture)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="c" Type="System.Char" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
      </Parameters>
      <Docs>
        <param name="c">Carácter Unicode que se va a convertir.</param>
        <param name="culture">Objeto que proporciona reglas de mayúsculas y minúsculas específicas de la referencia cultural.</param>
        <summary>Convierte el valor de un carácter Unicode especificado en el carácter equivalente pero en mayúsculas mediante la información de formato específica de la referencia cultural especificada.</summary>
        <returns>Equivalente en mayúsculas de <paramref name="c" />, modificado conforme a <paramref name="culture" />, o el valor sin modificar de <paramref name="c" /> si <paramref name="c" /> ya está en mayúsculas, no tiene equivalente en mayúsculas o no es alfabético.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use <xref:System.String.ToUpper%2A?displayProperty=nameWithType> para convertir una cadena a mayúsculas.  
  
   
  
## Examples  
 El ejemplo siguiente convierte cada carácter de una matriz a su equivalente en mayúsculas para la referencia cultural en-US, la referencia cultural y la referencia cultural tr-TR. En este ejemplo, el equivalente en mayúsculas de cada letra minúscula es idéntico para todas las referencias culturales, excepto un caso. Carácter de la letra minúscula "i" (u+0069) se convierte en "I" (u+0049) en la en-US y referencias culturales invariables, pero a"i" (0130) en la referencia cultural tr-TR.  
  
 [!code-csharp[System.Char.ToUpper#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.char.toupper/cs/toupper5.cs#2)]
 [!code-vb[System.Char.ToUpper#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.char.toupper/vb/toupper5.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El valor de <paramref name="culture" /> es <see langword="null" />.</exception>
        <altmember cref="P:System.Globalization.CultureInfo.CurrentCulture" />
        <altmember cref="M:System.String.ToUpper" />
        <altmember cref="M:System.Char.ToLower(System.Char,System.Globalization.CultureInfo)" />
      </Docs>
    </Member>
    <Member MemberName="ToUpperInvariant">
      <MemberSignature Language="C#" Value="public static char ToUpperInvariant (char c);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig char ToUpperInvariant(char c) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.ToUpperInvariant(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ToUpperInvariant (c As Char) As Char" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static char ToUpperInvariant(char c);" />
      <MemberSignature Language="F#" Value="static member ToUpperInvariant : char -&gt; char" Usage="System.char.ToUpperInvariant c" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="c" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="c">Carácter Unicode que se va a convertir.</param>
        <summary>Convierte el valor de un carácter Unicode en su equivalente en mayúsculas utilizando las reglas sobre mayúsculas y minúsculas de la referencia cultural de todos los idiomas.</summary>
        <returns>Equivalente mayúsculas minúsculas del parámetro <paramref name="c" /> o el valor sin modificar de <paramref name="c" /> si <paramref name="c" /> ya está en mayúsculas o no es un carácter alfabético.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si la aplicación se ve afectada por la referencia cultural y depende en el caso de un carácter que cambien de forma predecible, use el <xref:System.Char.ToUpperInvariant%2A> método.  El <xref:System.Char.ToUpperInvariant%2A> método es equivalente a `ToUpper(Char, CultureInfo.InvariantCulture)`.  
  
 Use <xref:System.String.ToUpperInvariant%2A?displayProperty=nameWithType> para convertir una cadena a mayúsculas.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.String.ToUpper" />
        <altmember cref="M:System.Char.ToUpper(System.Char,System.Globalization.CultureInfo)" />
        <altmember cref="P:System.Globalization.CultureInfo.InvariantCulture" />
      </Docs>
    </Member>
    <Member MemberName="TryParse">
      <MemberSignature Language="C#" Value="public static bool TryParse (string s, out char result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryParse(string s, [out] char&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Char.TryParse(System.String,System.Char@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryParse (s As String, ByRef result As Char) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryParse(System::String ^ s, [Runtime::InteropServices::Out] char % result);" />
      <MemberSignature Language="F#" Value="static member TryParse : string *  -&gt; bool" Usage="System.char.TryParse (s, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="result" Type="System.Char" RefType="out" />
      </Parameters>
      <Docs>
        <param name="s">Una cadena que contiene un carácter único, o <see langword="null" />.</param>
        <param name="result">Cuando este método devuelve un valor, si la conversión se ha realizado correctamente, contiene un carácter Unicode equivalente al único carácter de <c>s</c>; si se ha producido un error en la conversión, contiene un valor indefinido. Se produce un error en la conversión si el parámetro <c>s</c> es <see langword="null" /> o la longitud de <c>s</c> no es 1. Este parámetro se pasa sin inicializar.</param>
        <summary>Convierte el valor de la cadena especificada en el carácter Unicode equivalente. Un código devuelto indica si la conversión fue correcta o no.</summary>
        <returns>
          <see langword="true" /> si el parámetro <paramref name="s" /> se convierte correctamente; en caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Char.TryParse%2A> método es similar a la <xref:System.Char.Parse%2A> método, excepto el <xref:System.Char.TryParse%2A> método no produce una excepción si se produce un error en la conversión.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra las sobrecargas de los <xref:System.Char.TryParse%2A> método para varios tipos base y el <xref:System.DateTime.TryParseExact%2A> método para el <xref:System.DateTime> tipo base.  
  
 [!code-cpp[T.TryParse#1](~/samples/snippets/cpp/VS_Snippets_CLR/T.TryParse/CPP/tp.cpp#1)]
 [!code-csharp[T.TryParse#1](~/samples/snippets/csharp/VS_Snippets_CLR/T.TryParse/CS/tp.cs#1)]
 [!code-vb[T.TryParse#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/T.TryParse/VB/tp.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Char.Parse(System.String)" />
        <altmember cref="M:System.Char.ToString" />
        <related type="Article" href="https://msdn.microsoft.com/library/d139bc00-3c4e-4d78-ac9a-5c951b258d28">Analizar otras cadenas en .NET Framework</related>
      </Docs>
    </Member>
  </Members>
</Type>