<Type Name="AppDomainSetup" FullName="System.AppDomainSetup">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="8c404b68e0b334c6cfb991a00e0ce944782e2a15" />
    <Meta Name="ms.sourcegitcommit" Value="0e1f030650a307c745ee84ed547ef858acaea587" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="es-ES" />
    <Meta Name="ms.lasthandoff" Value="11/29/2018" />
    <Meta Name="ms.locfileid" Value="52610789" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class AppDomainSetup : IAppDomainSetup" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi serializable sealed beforefieldinit AppDomainSetup extends System.Object implements class System.IAppDomainSetup" />
  <TypeSignature Language="DocId" Value="T:System.AppDomainSetup" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class AppDomainSetup&#xA;Implements IAppDomainSetup" />
  <TypeSignature Language="C++ CLI" Value="public ref class AppDomainSetup sealed : IAppDomainSetup" />
  <TypeSignature Language="F#" Value="type AppDomainSetup = class&#xA;    interface IAppDomainSetup" />
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IAppDomainSetup</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ClassInterface(System.Runtime.InteropServices.ClassInterfaceType.None)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Representa la información de enlace del ensamblado que puede agregarse a una instancia de <see cref="T:System.AppDomain" />.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cambiar las propiedades de un <xref:System.AppDomainSetup> instancia no afecta a cualquier existente <xref:System.AppDomain>. Puede afectar a solo la creación de un nuevo <xref:System.AppDomain>, cuando el <xref:System.AppDomain.CreateDomain%2A> se llama al método con el <xref:System.AppDomainSetup> instancia como un parámetro.  
  
 Esta clase implementa la interfaz <xref:System.IAppDomainSetup> .  
  
> [!CAUTION]
>  El valor predeterminado para el <xref:System.AppDomainSetup.DisallowCodeDownload%2A> propiedad es false. Esta configuración no es segura para los servicios. Para ayudar a evitar que los servicios de descarga de código de confianza parcial, establezca esta propiedad en true  
  
 ]]></format>
    </remarks>
    <related type="Article" href="https://msdn.microsoft.com/library/07ea8438-7a34-49f0-a7e8-3d6ff7e4a482">Cómo: Configurar un dominio de aplicación</related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.AppDomainSetup" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public AppDomainSetup ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomainSetup.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; AppDomainSetup();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.AppDomainSetup" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public AppDomainSetup (ActivationContext activationContext);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.ActivationContext activationContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomainSetup.#ctor(System.ActivationContext)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; AppDomainSetup(ActivationContext ^ activationContext);" />
      <MemberSignature Language="F#" Value="new AppDomainSetup : ActivationContext -&gt; AppDomainSetup" Usage="new System.AppDomainSetup activationContext" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="activationContext" Type="System.ActivationContext" />
      </Parameters>
      <Docs>
        <param name="activationContext">Contexto de activación que se va a usar para un dominio de aplicación.</param>
        <summary>Inicializa una nueva instancia de la clase  <see cref="T:System.AppDomainSetup" /> con el contexto de activación especificado que se va a usar para la activación basada en manifiestos de un dominio de aplicación.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.ActivationContext> especificado para el objeto `activationContext` se usa para generar un <xref:System.Runtime.Hosting.ActivationArguments> objeto que contiene información necesaria para activar un nuevo dominio de aplicación. Esto <xref:System.Runtime.Hosting.ActivationArguments> puede tener acceso al objeto mediante el uso de la <xref:System.AppDomainSetup.ActivationArguments%2A> propiedad.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El valor de <paramref name="activationContext" /> es <see langword="null" />.</exception>
        <altmember cref="P:System.AppDomainSetup.ActivationArguments" />
        <altmember cref="T:System.Runtime.Hosting.ActivationArguments" />
        <altmember cref="T:System.ActivationContext" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public AppDomainSetup (System.Runtime.Hosting.ActivationArguments activationArguments);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Runtime.Hosting.ActivationArguments activationArguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomainSetup.#ctor(System.Runtime.Hosting.ActivationArguments)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; AppDomainSetup(System::Runtime::Hosting::ActivationArguments ^ activationArguments);" />
      <MemberSignature Language="F#" Value="new AppDomainSetup : System.Runtime.Hosting.ActivationArguments -&gt; AppDomainSetup" Usage="new System.AppDomainSetup activationArguments" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="activationArguments" Type="System.Runtime.Hosting.ActivationArguments" />
      </Parameters>
      <Docs>
        <param name="activationArguments">Un objeto que especifica la información necesaria para la activación basada en manifiestos de un nuevo dominio de aplicación.</param>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.AppDomainSetup" /> con los argumentos de activación especificados que son necesarios para la activación basada en manifiestos de un dominio de aplicación.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El objeto especificado para `activationArguments` puede obtenerse utilizando el <xref:System.AppDomainSetup.ActivationArguments%2A> propiedad.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El valor de <paramref name="activationArguments" /> es <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ActivationArguments">
      <MemberSignature Language="C#" Value="public System.Runtime.Hosting.ActivationArguments ActivationArguments { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Runtime.Hosting.ActivationArguments ActivationArguments" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.ActivationArguments" />
      <MemberSignature Language="VB.NET" Value="Public Property ActivationArguments As ActivationArguments" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Runtime::Hosting::ActivationArguments ^ ActivationArguments { System::Runtime::Hosting::ActivationArguments ^ get(); void set(System::Runtime::Hosting::ActivationArguments ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ActivationArguments : System.Runtime.Hosting.ActivationArguments with get, set" Usage="System.AppDomainSetup.ActivationArguments" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Hosting.ActivationArguments</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece los datos sobre la activación de un dominio de aplicación.</summary>
        <value>Un objeto que contiene los datos sobre la activación de un dominio de aplicación.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se produce ninguna excepción si esta propiedad se establece en `null`.  
  
 La información proporcionada por el <xref:System.Runtime.Hosting.ActivationArguments> objeto admite la activación basada en manifiesto.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">La propiedad se establece en un objeto <see cref="T:System.Runtime.Hosting.ActivationArguments" /> cuya identidad de aplicación no coincide con la identidad de aplicación del objeto <see cref="T:System.Security.Policy.ApplicationTrust" /> devuelto por la propiedad <see cref="P:System.AppDomainSetup.ApplicationTrust" />. No se genera ninguna excepción si la propiedad <see cref="P:System.AppDomainSetup.ApplicationTrust" /> es <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="AppDomainInitializer">
      <MemberSignature Language="C#" Value="public AppDomainInitializer AppDomainInitializer { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.AppDomainInitializer AppDomainInitializer" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.AppDomainInitializer" />
      <MemberSignature Language="VB.NET" Value="Public Property AppDomainInitializer As AppDomainInitializer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property AppDomainInitializer ^ AppDomainInitializer { AppDomainInitializer ^ get(); void set(AppDomainInitializer ^ value); };" />
      <MemberSignature Language="F#" Value="member this.AppDomainInitializer : AppDomainInitializer with get, set" Usage="System.AppDomainSetup.AppDomainInitializer" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.AppDomainInitializer</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece el delegado de <see cref="T:System.AppDomainInitializer" />, que representa un método de devolución de llamada que se invoca cuando se inicializa el dominio de aplicación.</summary>
        <value>Un delegado que representa un método de devolución de llamada que se invoca cuando se inicializa el dominio de aplicación.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para pasar información al método de devolución de llamada, asignar una matriz de cadenas para el <xref:System.AppDomainSetup.AppDomainInitializerArguments%2A> propiedad. La matriz se pasa al método de devolución de llamada cada vez que un <xref:System.AppDomain> se ha inicializado.  
  
 El método de devolución de llamada se ejecuta en el contexto del dominio de aplicación recién creado.  
  
   
  
## Examples  
 En el ejemplo siguiente se crea un dominio de aplicación secundario denominado `ChildDomain`, utilizando un <xref:System.AppDomainSetup> objeto y evidencia del dominio de aplicación predeterminado. El <xref:System.AppDomainSetup.AppDomainInitializer%2A> propiedad está establecida en el método de devolución de llamada `AppDomainInit`, que se invoca cuando se inicializa el dominio secundario. Los argumentos para el método de devolución de llamada se colocan en una matriz de cadenas, que se asigna a la <xref:System.AppDomainSetup.AppDomainInitializerArguments%2A> propiedad. Cuando se crea el dominio secundario, el método de devolución de llamada simplemente imprime las cadenas.  
  
 [!code-cpp[AppDomainInitializer#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomainInitializer/cpp/source.cpp#1)]
 [!code-csharp[AppDomainInitializer#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomainInitializer/CS/source.cs#1)]
 [!code-vb[AppDomainInitializer#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomainInitializer/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.AppDomainInitializer" />
        <altmember cref="P:System.AppDomainSetup.AppDomainInitializerArguments" />
      </Docs>
    </Member>
    <Member MemberName="AppDomainInitializerArguments">
      <MemberSignature Language="C#" Value="public string[] AppDomainInitializerArguments { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string[] AppDomainInitializerArguments" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.AppDomainInitializerArguments" />
      <MemberSignature Language="VB.NET" Value="Public Property AppDomainInitializerArguments As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property cli::array &lt;System::String ^&gt; ^ AppDomainInitializerArguments { cli::array &lt;System::String ^&gt; ^ get(); void set(cli::array &lt;System::String ^&gt; ^ value); };" />
      <MemberSignature Language="F#" Value="member this.AppDomainInitializerArguments : string[] with get, set" Usage="System.AppDomainSetup.AppDomainInitializerArguments" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece los argumentos pasados al método de devolución de llamada que representa el delegado de  <see cref="T:System.AppDomainInitializer" />. El método de devolución de llamada se invoca cuando se inicializa el dominio de aplicación.</summary>
        <value>Una matriz de cadenas que se pasa al método de devolución de llamada representado por el delegado de  <see cref="T:System.AppDomainInitializer" />, cuando se invoca dicho método durante la inicialización de <see cref="T:System.AppDomain" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use la <xref:System.AppDomainSetup.AppDomainInitializer%2A> propiedad para especificar un método de devolución de llamada que se invoca durante <xref:System.AppDomain> inicialización. Si el <xref:System.AppDomainSetup.AppDomainInitializer%2A> no está establecida la propiedad, no se utiliza la matriz asignada a esta propiedad.  
  
 El método de devolución de llamada se ejecuta en el contexto del dominio de aplicación recién creado.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se crea un dominio de aplicación secundario denominado `ChildDomain`, utilizando un <xref:System.AppDomainSetup> objeto y evidencia del dominio de aplicación predeterminado. El <xref:System.AppDomainSetup.AppDomainInitializer%2A> propiedad está establecida en el método de devolución de llamada `AppDomainInit`, que se invoca cuando se inicializa el dominio secundario. Los argumentos para el método de devolución de llamada se colocan en una matriz de cadenas, que se asigna a la <xref:System.AppDomainSetup.AppDomainInitializerArguments%2A> propiedad. Cuando se crea el dominio secundario, el método de devolución de llamada simplemente imprime las cadenas.  
  
 [!code-cpp[AppDomainInitializer#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomainInitializer/cpp/source.cpp#1)]
 [!code-csharp[AppDomainInitializer#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomainInitializer/CS/source.cs#1)]
 [!code-vb[AppDomainInitializer#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomainInitializer/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.AppDomainInitializer" />
        <altmember cref="P:System.AppDomainSetup.AppDomainInitializer" />
      </Docs>
    </Member>
    <Member MemberName="AppDomainManagerAssembly">
      <MemberSignature Language="C#" Value="public string AppDomainManagerAssembly { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string AppDomainManagerAssembly" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.AppDomainManagerAssembly" />
      <MemberSignature Language="VB.NET" Value="Public Property AppDomainManagerAssembly As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ AppDomainManagerAssembly { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.AppDomainManagerAssembly : string with get, set" Usage="System.AppDomainSetup.AppDomainManagerAssembly" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece el nombre para mostrar del ensamblado que proporciona el tipo del administrador del dominio de aplicación para los dominios de aplicación creados mediante este objeto <see cref="T:System.AppDomainSetup" />.</summary>
        <value>Nombre para mostrar del ensamblado que proporciona el objeto <see cref="T:System.Type" /> del administrador del dominio de aplicación.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para especificar el tipo del administrador del dominio de aplicación, establezca esta propiedad y el <xref:System.AppDomainSetup.AppDomainManagerType%2A> propiedad. Si cualquiera de estas propiedades no se establece, se omite el resto.  
  
 Si se proporciona ningún tipo, el Administrador de dominio de aplicación se crea a partir del mismo tipo que el dominio de aplicación principal (es decir, el dominio de aplicación desde el que el <xref:System.AppDomain.CreateDomain%2A?displayProperty=nameWithType> se llama al método).  
  
 Cuando se carga el dominio de aplicación, <xref:System.TypeLoadException> se produce si el ensamblado no existe, o si el ensamblado no contiene el tipo especificado por el <xref:System.AppDomainSetup.AppDomainManagerType%2A> propiedad. <xref:System.IO.FileLoadException> se produce si se encuentra el ensamblado, pero no coincide con la información de versión.  
  
 Para establecer el Administrador de dominio de aplicación para el dominio de aplicación predeterminado, use el [ \<appDomainManagerAssembly >](~/docs/framework/configure-apps/file-schema/runtime/appdomainmanagerassembly-element.md) y [ \<appDomainManagerType >](~/docs/framework/configure-apps/file-schema/runtime/appdomainmanagertype-element.md) elementos en la [ \<en tiempo de ejecución >](~/docs/framework/configure-apps/file-schema/runtime/runtime-element.md) sección del archivo de configuración de aplicación, o el uso de las variables de entorno descritas en <xref:System.AppDomainManager>.  
  
 Esta característica requiere que la aplicación tenga plena confianza. (Por ejemplo, una aplicación que se ejecuta en el escritorio tiene plena confianza). Si la aplicación no tiene plena confianza, un <xref:System.TypeLoadException> se produce.  
  
 El formato del nombre para mostrar ensamblado viene dado por la <xref:System.Reflection.Assembly.FullName%2A?displayProperty=nameWithType> propiedad.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AppDomainManagerType">
      <MemberSignature Language="C#" Value="public string AppDomainManagerType { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string AppDomainManagerType" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.AppDomainManagerType" />
      <MemberSignature Language="VB.NET" Value="Public Property AppDomainManagerType As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ AppDomainManagerType { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.AppDomainManagerType : string with get, set" Usage="System.AppDomainSetup.AppDomainManagerType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece el nombre completo del tipo que proporciona el administrador del dominio de aplicación para los dominios de aplicación creados mediante este objeto <see cref="T:System.AppDomainSetup" />.</summary>
        <value>Nombre completo del tipo, incluido el espacio de nombres.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para especificar el tipo del administrador del dominio de aplicación, establezca esta propiedad y el <xref:System.AppDomainSetup.AppDomainManagerAssembly%2A> propiedad. Si cualquiera de estas propiedades no se establece, se omite el resto.  
  
 Si se proporciona ningún tipo, el Administrador de dominio de aplicación se crea a partir del mismo tipo que el dominio de aplicación principal (es decir, el dominio de aplicación desde el que el <xref:System.AppDomain.CreateDomain%2A?displayProperty=nameWithType> se llama al método).  
  
 Cuando se carga el dominio de aplicación, <xref:System.TypeLoadException> se produce si el ensamblado especificado por el <xref:System.AppDomainSetup.AppDomainManagerAssembly%2A> propiedad no contiene el tipo especificado por esta propiedad.  
  
 Para establecer el Administrador de dominio de aplicación para el dominio de aplicación predeterminado, use el [ \<appDomainManagerAssembly >](~/docs/framework/configure-apps/file-schema/runtime/appdomainmanagerassembly-element.md) y [ \<appDomainManagerType >](~/docs/framework/configure-apps/file-schema/runtime/appdomainmanagertype-element.md) elementos en la [ \<en tiempo de ejecución >](~/docs/framework/configure-apps/file-schema/runtime/runtime-element.md) sección del archivo de configuración de aplicación, o el uso de las variables de entorno descritas en <xref:System.AppDomainManager>.  
  
 Esta característica requiere que la aplicación tenga plena confianza. (Por ejemplo, una aplicación que se ejecuta en el escritorio tiene plena confianza). Si la aplicación no tiene plena confianza, un <xref:System.TypeLoadException> se produce.  
  
 El formato del nombre completo de un tipo viene dado por la <xref:System.Type.FullName%2A?displayProperty=nameWithType> propiedad.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ApplicationBase">
      <MemberSignature Language="C#" Value="public string ApplicationBase { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ApplicationBase" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.ApplicationBase" />
      <MemberSignature Language="VB.NET" Value="Public Property ApplicationBase As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ ApplicationBase { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ApplicationBase : string with get, set" Usage="System.AppDomainSetup.ApplicationBase" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.IAppDomainSetup.ApplicationBase</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece el nombre del directorio que contiene la aplicación.</summary>
        <value>El nombre del directorio base de la aplicación.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El directorio de base de la aplicación es donde el Administrador de ensamblados comienza la búsqueda de ensamblados.  
  
 El <xref:System.AppDomainSetup.ApplicationBase%2A> propiedad puede influir en qué permisos se conceden a un dominio de aplicación. Por ejemplo, un dominio de aplicación que se origina en el equipo local normalmente recibe plena confianza en función de su ubicación de origen. Sin embargo, si la <xref:System.AppDomainSetup.ApplicationBase%2A> propiedad eso <xref:System.AppDomain> se establece en el nombre completo del directorio de la intranet, el <xref:System.AppDomainSetup.ApplicationBase%2A> valor restringe los permisos concedidos al dominio de aplicación para una concesión de intranet local, aunque el dominio de aplicación en realidad se origina en el equipo local.  
  
   
  
## Examples  
 En el ejemplo siguiente se muestra cómo usar el <xref:System.AppDomainSetup.ApplicationBase%2A> propiedad para establecer la ubicación donde el cargador de ensamblados comienza la búsqueda de ensamblados cargar en un dominio de aplicación.  
  
> [!NOTE]
>  Debe asegurarse de que existe la carpeta que especifique.  
  
 [!code-cpp[ADApplicationBase#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADApplicationBase/CPP/adapplicationbase.cpp#1)]
 [!code-csharp[ADApplicationBase#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADApplicationBase/CS/adapplicationbase.cs#1)]
 [!code-vb[ADApplicationBase#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADApplicationBase/VB/adapplicationbase.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Para obtener acceso a la información de ruta de acceso. Enumeración asociada: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
      </Docs>
    </Member>
    <Member MemberName="ApplicationName">
      <MemberSignature Language="C#" Value="public string ApplicationName { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ApplicationName" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.ApplicationName" />
      <MemberSignature Language="VB.NET" Value="Public Property ApplicationName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ ApplicationName { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ApplicationName : string with get, set" Usage="System.AppDomainSetup.ApplicationName" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.IAppDomainSetup.ApplicationName</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece el nombre de la aplicación.</summary>
        <value>El nombre de la aplicación.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 El ejemplo siguiente muestra cómo establecer el <xref:System.AppDomainSetup.ApplicationName%2A> propiedad cuando se crea un nuevo dominio de aplicación.  
  
 En el ejemplo se crea un nuevo dominio de aplicación y, a continuación, llama a la <xref:System.AppDomain.CreateInstanceAndUnwrap%2A?displayProperty=nameWithType> método para cargar el ensamblado de ejemplo en el nuevo dominio de aplicación y crear una instancia de la `Worker` clase. El `Worker` clase hereda <xref:System.MarshalByRefObject>, por lo que en el ejemplo se puede usar el proxy devuelto por <xref:System.AppDomain.CreateInstanceAndUnwrap%2A> para llamar a la `TestLoad` método.  
  
 El `TestLoad` método carga un ensamblado que especifique. Debe especificar un nombre de ensamblado válido y completo, o convierta en comentario la <xref:System.Reflection.Assembly.Load%28System.String%29> método. El `TestLoad` método enumera los ensamblados que se cargan en el nuevo dominio de aplicación, que muestra que se cargan el ensamblado especificado y el ensamblado de ejemplo.  
  
 El ejemplo se usa el <xref:System.LoaderOptimizationAttribute> atributo para indicar que el cargador de ensamblados cómo la aplicación compartirá el código en dominios de aplicación.  
  
 [!code-cpp[ADMultiDomain#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADMultiDomain/CPP/admultidomain.cpp#1)]
 [!code-csharp[ADMultiDomain#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADMultiDomain/CS/admultidomain.cs#1)]
 [!code-vb[ADMultiDomain#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADMultiDomain/VB/admultidomain.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ApplicationTrust">
      <MemberSignature Language="C#" Value="public System.Security.Policy.ApplicationTrust ApplicationTrust { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Security.Policy.ApplicationTrust ApplicationTrust" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.ApplicationTrust" />
      <MemberSignature Language="VB.NET" Value="Public Property ApplicationTrust As ApplicationTrust" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Security::Policy::ApplicationTrust ^ ApplicationTrust { System::Security::Policy::ApplicationTrust ^ get(); void set(System::Security::Policy::ApplicationTrust ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ApplicationTrust : System.Security.Policy.ApplicationTrust with get, set" Usage="System.AppDomainSetup.ApplicationTrust" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Security.Policy.ApplicationTrust</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece un objeto que contiene información sobre la seguridad y la confianza.</summary>
        <value>Objeto que contiene información de seguridad y confianza.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esta propiedad es `null` cuando el <xref:System.AppDomainSetup> se crea. Una vez cambiado, no se puede restablecer en una referencia nula.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">La propiedad se establece en un objeto <see cref="T:System.Security.Policy.ApplicationTrust" /> cuya identidad de aplicación no coincide con la identidad de aplicación del objeto <see cref="T:System.Runtime.Hosting.ActivationArguments" /> devuelto por la propiedad <see cref="P:System.AppDomainSetup.ActivationArguments" />. No se genera ninguna excepción si la propiedad <see cref="P:System.AppDomainSetup.ActivationArguments" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentNullException">La propiedad se establece en <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="CachePath">
      <MemberSignature Language="C#" Value="public string CachePath { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string CachePath" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.CachePath" />
      <MemberSignature Language="VB.NET" Value="Public Property CachePath As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ CachePath { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.CachePath : string with get, set" Usage="System.AppDomainSetup.CachePath" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.IAppDomainSetup.CachePath</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece el nombre de un área específica de la aplicación donde se realiza la instantánea de los archivos.</summary>
        <value>Nombre completo de la ruta de acceso al directorio y nombre del archivo donde se realiza la instantánea de los archivos.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para esta propiedad tener un efecto, el <xref:System.AppDomainSetup.ApplicationName%2A> también debe establecerse la propiedad. Si el <xref:System.AppDomainSetup.ApplicationName%2A> no se establece la propiedad, el <xref:System.AppDomainSetup.CachePath%2A> se omite y el valor predeterminado es la ubicación de memoria caché la instantánea a la caché de descarga.  
  
 Para obtener más información sobre las instantáneas, vea [copias sombra de ensamblados](~/docs/framework/app-domains/shadow-copy-assemblies.md).  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Para obtener acceso a la información de ruta de acceso. Enumeración asociada: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
        <altmember cref="P:System.AppDomainSetup.ShadowCopyFiles" />
        <altmember cref="P:System.AppDomainSetup.ShadowCopyDirectories" />
        <related type="Article" href="~/docs/framework/app-domains/shadow-copy-assemblies.md">Copias sombra de ensamblados</related>
      </Docs>
    </Member>
    <Member MemberName="ConfigurationFile">
      <MemberSignature Language="C#" Value="public string ConfigurationFile { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ConfigurationFile" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.ConfigurationFile" />
      <MemberSignature Language="VB.NET" Value="Public Property ConfigurationFile As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ ConfigurationFile { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ConfigurationFile : string with get, set" Usage="System.AppDomainSetup.ConfigurationFile" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.IAppDomainSetup.ConfigurationFile</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece el nombre del archivo de configuración de un dominio de aplicación.</summary>
        <value>Nombre del archivo de configuración.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El archivo de configuración describe las reglas de búsqueda y datos de configuración para el dominio de aplicación. El host que crea el dominio de aplicación es responsable de suministrar estos datos porque los valores significativos varían situaciones.  
  
 Por ejemplo, los datos de configuración para las aplicaciones ASP.NET se almacenan para cada aplicación, el sitio y el equipo, mientras que los datos de configuración de un archivo ejecutable se almacena para cada aplicación, usuario y equipo. Sólo el host conoce los aspectos específicos de los datos de configuración para una circunstancia determinada.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Para obtener acceso a la información de ruta de acceso. Enumeración asociada: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
        <related type="Article" href="https://msdn.microsoft.com/library/f04816ab-110d-4e28-9283-845d6d9a4a68">Esquema de la configuración de Common Language Runtime</related>
      </Docs>
    </Member>
    <Member MemberName="DisallowApplicationBaseProbing">
      <MemberSignature Language="C#" Value="public bool DisallowApplicationBaseProbing { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool DisallowApplicationBaseProbing" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.DisallowApplicationBaseProbing" />
      <MemberSignature Language="VB.NET" Value="Public Property DisallowApplicationBaseProbing As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool DisallowApplicationBaseProbing { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.DisallowApplicationBaseProbing : bool with get, set" Usage="System.AppDomainSetup.DisallowApplicationBaseProbing" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Especifica si se examinan la ruta de acceso binaria privada y la ruta de acceso base de la aplicación cuando se buscan los ensamblados que se van a cargar.</summary>
        <value>
          <see langword="true" /> si no se permite el sondeo; de lo contrario, <see langword="false" />. El valor predeterminado es <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si el <xref:System.AppDomainSetup.DisallowApplicationBaseProbing%2A> propiedad es `true`, el valor de la <xref:System.AppDomainSetup.ApplicationBase%2A> propiedad se omite. Es decir, no se examina ningún ensamblado en los directorios especificados por el <xref:System.AppDomainSetup.ApplicationBase%2A> propiedad. Además, los valores de la <xref:System.AppDomainSetup.PrivateBinPath%2A> propiedad y el <xref:System.AppDomainSetup.PrivateBinPathProbe%2A> propiedad se omite. No se examina ningún ensamblado en los directorios especificados por el <xref:System.AppDomainSetup.PrivateBinPath%2A> propiedad.  
  
 El <xref:System.AppDomainSetup.DisallowApplicationBaseProbing%2A> propiedad proporciona una capa adicional de control sobre el proceso de carga. En el ensamblado normal que carga la secuencia, se busca en la base de la aplicación antes de la <xref:System.AppDomain.AssemblyResolve?displayProperty=nameWithType> provoca el evento. Sin embargo, algunas aplicaciones es posible que deba cargar ensamblados desde un archivo compuesto OLE dentro de un documento, o desde una ubicación única y conocida que no está en la caché global de ensamblados ni en los directorios especificados por el <xref:System.AppDomainSetup.ApplicationBase%2A> y <xref:System.AppDomainSetup.PrivateBinPath%2A> propiedades. Pueden usar estas aplicaciones las <xref:System.AppDomainSetup.DisallowApplicationBaseProbing%2A> propiedad para evitar el retraso causado por sondeo normal y para evitar cargar copias del ensamblado necesario que pueden estar ubicados en las rutas de acceso de sondeo normales.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DisallowBindingRedirects">
      <MemberSignature Language="C#" Value="public bool DisallowBindingRedirects { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool DisallowBindingRedirects" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.DisallowBindingRedirects" />
      <MemberSignature Language="VB.NET" Value="Public Property DisallowBindingRedirects As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool DisallowBindingRedirects { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.DisallowBindingRedirects : bool with get, set" Usage="System.AppDomainSetup.DisallowBindingRedirects" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece un valor que indica si un dominio de aplicación permite redirigir los enlaces con los ensamblados.</summary>
        <value>
          <see langword="true" /> si no se permite la redirección de los ensamblados; <see langword="false" /> si se permite.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.AppDomainSetup.DisallowBindingRedirects%2A> propiedad está diseñada para usarse por los servicios y aplicaciones de servidor donde la redirección de enlace de ensamblado no forma parte del escenario de aplicación.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DisallowCodeDownload">
      <MemberSignature Language="C#" Value="public bool DisallowCodeDownload { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool DisallowCodeDownload" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.DisallowCodeDownload" />
      <MemberSignature Language="VB.NET" Value="Public Property DisallowCodeDownload As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool DisallowCodeDownload { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.DisallowCodeDownload : bool with get, set" Usage="System.AppDomainSetup.DisallowCodeDownload" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece un valor que indica si se permite la descarga HTTP de ensamblados para un dominio de aplicación.</summary>
        <value>
          <see langword="true" /> si no se permite la descarga HTTP de los ensamblados; <see langword="false" /> si se permite.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.AppDomainSetup.DisallowCodeDownload%2A> propiedad está diseñada para usarse por los servicios y aplicaciones de servidor donde la descarga de código desde una intranet o Internet no forma parte del escenario de aplicación.  
  
> [!CAUTION]
>  El valor predeterminado para el <xref:System.AppDomainSetup.DisallowCodeDownload%2A> propiedad es `false`. Esta configuración no es segura para los servicios. Para ayudar a evitar que los servicios de descarga de código de confianza parcial, establezca esta propiedad en `true`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DisallowPublisherPolicy">
      <MemberSignature Language="C#" Value="public bool DisallowPublisherPolicy { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool DisallowPublisherPolicy" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.DisallowPublisherPolicy" />
      <MemberSignature Language="VB.NET" Value="Public Property DisallowPublisherPolicy As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool DisallowPublisherPolicy { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.DisallowPublisherPolicy : bool with get, set" Usage="System.AppDomainSetup.DisallowPublisherPolicy" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece un valor que indica si la sección [&lt;publisherPolicy&gt;](~/docs/framework/configure-apps/file-schema/runtime/publisherpolicy-element.md) del archivo de configuración se aplica a un dominio de aplicación.</summary>
        <value>
          <see langword="true" /> si se omite la sección <see langword="&lt;publisherPolicy&gt;" /> del archivo de configuración correspondiente para un dominio de aplicación; <see langword="false" /> si se admite la directiva de publicador declarada.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.AppDomainSetup.DisallowPublisherPolicy%2A> propiedad se aplica específicamente a una aplicación Web que se cargaron localmente. Utilice esta propiedad para ayudar a evitar un intento malicioso para ejecutar una aplicación Web no segura en modo seguro.  
  
 Para obtener más información sobre cómo omitir la directiva de edición, vea el [Redirecting Assembly Versions](~/docs/framework/configure-apps/redirect-assembly-versions.md) tema. Para obtener más información acerca del modo seguro, vea la sección "Examen de los archivos de configuración" de la [How the Runtime Locates Assemblies](~/docs/framework/deployment/how-the-runtime-locates-assemblies.md) tema.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DynamicBase">
      <MemberSignature Language="C#" Value="public string DynamicBase { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string DynamicBase" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.DynamicBase" />
      <MemberSignature Language="VB.NET" Value="Public Property DynamicBase As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ DynamicBase { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.DynamicBase : string with get, set" Usage="System.AppDomainSetup.DynamicBase" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.IAppDomainSetup.DynamicBase</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>set: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece el directorio base donde está ubicado el directorio de los archivos dinámicamente generados.</summary>
        <value>Directorio donde se encuentra <see cref="P:System.AppDomain.DynamicDirectory" />.  

 <block subset="none" type="note"><para>  
 El valor devuelto de esta propiedad es diferente del valor asignado.
</para></block></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  

## Remarks  
 Utilice esta propiedad para establecer el directorio base donde se ubicará el directorio dinámico para el nuevo dominio de aplicación. Cuando el código en el nuevo dominio de aplicación carga un ensamblado, la resolución de ensamblados busca primero en las rutas de acceso de sondeo normales. Si no se encuentra el ensamblado, busca en el directorio dinámico, que es devuelto por la <xref:System.AppDomain.DynamicDirectory%2A?displayProperty=nameWithType> propiedad. Ensamblados dinámicos que se cargarán y ejecutados por el nuevo dominio de aplicación se pueden colocar allí.  
  
 Al asignar una ruta de acceso a la <xref:System.AppDomainSetup.DynamicBase%2A> propiedad, se agrega un subdirectorio adicional; el nombre de este subdirectorio es el código hash del valor asignado a la <xref:System.AppDomainSetup.ApplicationName%2A> propiedad. Por lo tanto, el directorio base posteriormente devuelto por esta propiedad siempre es diferente del valor asignado.  
  
> [!IMPORTANT]
>  Asignar un valor a esta propiedad no crea los directorios. Deben crear los directorios o verificados por el código que los usa.  
  
 El directorio dinámico es un subdirectorio de <xref:System.AppDomainSetup.DynamicBase%2A>. Su nombre simple es el valor devuelto por la <xref:System.AppDomainSetup.ApplicationName%2A> propiedad, por lo que su formato es *ruta de acceso original*\\*código hash*\\*nombre de la aplicación*.  
  
   
  
## Examples  
 En el ejemplo siguiente se muestra cómo usar el <xref:System.AppDomainSetup.DynamicBase%2A> sondeos de propiedad para establecer la ruta de acceso de un dominio de aplicación cuando se cargan los ensamblados dinámicos.  
  
 El ejemplo se crea un <xref:System.AppDomainSetup> objeto y establece su <xref:System.AppDomainSetup.ApplicationName%2A> propiedad en "Ejemplo" y su <xref:System.AppDomainSetup.DynamicBase%2A> propiedad en "C:\DynamicAssemblyDir". El ejemplo se muestra a continuación, el <xref:System.AppDomainSetup.DynamicBase%2A> propiedad para mostrar que el código hash del nombre de la aplicación se ha anexado como un subdirectorio de la ruta de acceso que se asignó originalmente.  
  
> [!NOTE]
>  El directorio base en este ejemplo está pensado para estar fuera de la ruta de acceso de sondeo para la aplicación de ejemplo. Asegúrese de compilar el ejemplo en una ubicación diferente. Eliminar el directorio base y todos sus subdirectorios cada vez que ejecute el ejemplo.  
  
 El ejemplo crea un nuevo dominio de aplicación mediante el <xref:System.AppDomainSetup> objeto. En el ejemplo, a continuación, crea el directorio dinámico si aún no existe. Aunque el ejemplo usa el dominio de aplicación <xref:System.AppDomain.DynamicDirectory%2A?displayProperty=nameWithType> propiedad va a obtener el nombre del directorio dinámico, podría crear fácilmente el directorio con antelación mediante la concatenación de la ruta de acceso original, el código hash del nombre de la aplicación y la nombre de la aplicación.  
  
 El ejemplo tiene un `GenerateDynamicAssembly` método que emite un ensamblado denominado `DynamicHelloWorld.dll` y lo almacena en el directorio dinámico del dominio de aplicación nuevo. El ensamblado dinámico contiene un solo tipo, `HelloWorld`, que tiene un método estático (`Shared` método en Visual Basic) denominada `HelloFromAD`. Llamar a este método muestra el nombre del dominio de aplicación.  
  
 El `Example` clase se deriva de <xref:System.MarshalByRefObject>, por lo que en el ejemplo se puede crear una instancia de la clase en el nuevo dominio de aplicación y llamar a su `Test` método. El `Test` método carga el ensamblado dinámico por su nombre para mostrar y llama a estático `HelloFromAD` método.  
  
 Puede mostrar que se busca en el directorio dinámico después de las rutas de acceso de sondeo normales al escribir código para un ensamblado denominado `DynamicHelloWorld.dll` y compilarlo en el mismo directorio que este ejemplo. El ensamblado debe tener una clase denominada `HelloWorld` con un método estático denominado `HelloFromAD`. Este método no tiene que tienen la misma funcionalidad que aparece en el ejemplo; simplemente puede mostrar una cadena en la consola. El ensamblado debe tener también un <xref:System.Reflection.AssemblyVersionAttribute> atributo que se establece su versión a 1.0.0.0. Al ejecutar el ejemplo, se encuentra el ensamblado que se ha compilado en el directorio actual antes de que se busca en el directorio dinámico.  
  
 [!code-cpp[ADDynamicBase#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADDynamicBase/CPP/addynamicbase.cpp#1)]
 [!code-csharp[ADDynamicBase#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADDynamicBase/CS/addynamicbase.cs#1)]
 [!code-vb[ADDynamicBase#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADDynamicBase/VB/addynamicbase.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.MemberAccessException">Esta propiedad no se puede establecer porque el nombre de la aplicación en el dominio de aplicación es <see langword="null" />.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Para obtener acceso a la información de ruta de acceso. Enumeración asociada: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
      </Docs>
    </Member>
    <Member MemberName="GetConfigurationBytes">
      <MemberSignature Language="C#" Value="public byte[] GetConfigurationBytes ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance unsigned int8[] GetConfigurationBytes() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomainSetup.GetConfigurationBytes" />
      <MemberSignature Language="VB.NET" Value="Public Function GetConfigurationBytes () As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::Byte&gt; ^ GetConfigurationBytes();" />
      <MemberSignature Language="F#" Value="member this.GetConfigurationBytes : unit -&gt; byte[]" Usage="appDomainSetup.GetConfigurationBytes " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Devuelve la información de configuración XML establecida por el método <see cref="M:System.AppDomainSetup.SetConfigurationBytes(System.Byte[])" />, que reemplaza la información de configuración XML de la aplicación.</summary>
        <returns>Una matriz que contiene la información de configuración XML establecida por el método <see cref="M:System.AppDomainSetup.SetConfigurationBytes(System.Byte[])" />, o <see langword="null" /> si no se ha llamado al método <see cref="M:System.AppDomainSetup.SetConfigurationBytes(System.Byte[])" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.AppDomainSetup.SetConfigurationBytes%2A> método proporciona una forma de reemplazar la información de configuración de una aplicación que crea un nuevo dominio de aplicación. La información del archivo de configuración en `value` invalida la información del archivo de configuración de la aplicación. Por ejemplo, cuando la aplicación Example.exe crea un nuevo dominio de aplicación, puede invalidar la información de configuración originalmente obtenida del archivo Example.exe.config.  
  
> [!IMPORTANT]
>  Algunos consumidores de la información del archivo de configuración no usan la información almacenada por el <xref:System.AppDomainSetup.SetConfigurationBytes%2A> método. El tiempo de ejecución no exigir esto. Para asegurarse de que toda información de archivo de configuración se reemplaza en un dominio de aplicación, use el <xref:System.AppDomainSetup.ConfigurationFile%2A> propiedad para especificar un archivo de configuración. El <xref:System.AppDomainSetup.SetConfigurationBytes%2A> método afecta al enlace de ensamblados.  
  
 El código XML de `value` es el mismo que el XML en un archivo de configuración normal, excepto en que se almacena como un <xref:System.Byte> matriz.  
  
 Para acceder a los bytes de la configuración para un dominio de aplicación, use la <xref:System.AppDomain.SetupInformation%2A?displayProperty=nameWithType> propiedad va a obtener el <xref:System.AppDomainSetup> de objeto para el dominio de aplicación y, después, usar el <xref:System.AppDomainSetup.GetConfigurationBytes%2A> método.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LicenseFile">
      <MemberSignature Language="C#" Value="public string LicenseFile { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string LicenseFile" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.LicenseFile" />
      <MemberSignature Language="VB.NET" Value="Public Property LicenseFile As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ LicenseFile { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.LicenseFile : string with get, set" Usage="System.AppDomainSetup.LicenseFile" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.IAppDomainSetup.LicenseFile</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece la ubicación del archivo de licencia asociado a este dominio.</summary>
        <value>Nombre y ubicación del archivo de licencia.</value>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Para obtener acceso a la información de ruta de acceso. Enumeración asociada: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
      </Docs>
    </Member>
    <Member MemberName="LoaderOptimization">
      <MemberSignature Language="C#" Value="public LoaderOptimization LoaderOptimization { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.LoaderOptimization LoaderOptimization" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.LoaderOptimization" />
      <MemberSignature Language="VB.NET" Value="Public Property LoaderOptimization As LoaderOptimization" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property LoaderOptimization LoaderOptimization { LoaderOptimization get(); void set(LoaderOptimization value); };" />
      <MemberSignature Language="F#" Value="member this.LoaderOptimization : LoaderOptimization with get, set" Usage="System.AppDomainSetup.LoaderOptimization" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.LoaderOptimization</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Especifica la directiva de optimización utilizada para cargar un ejecutable.</summary>
        <value>Una constante enumerada que se usa con <see cref="T:System.LoaderOptimizationAttribute" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 El ejemplo siguiente se crea un ensamblado dinámico y lo guarda en disco y, a continuación, utiliza el <xref:System.AppDomainSetup.LoaderOptimization%2A> propiedad para establecer la directiva de optimización que se usa para cargar el ensamblado en un dominio de aplicación.  
  
 [!code-cpp[ADDyno#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADDyno/CPP/addyno.cpp#1)]
 [!code-csharp[ADDyno#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADDyno/CS/addyno.cs#1)]
 [!code-vb[ADDyno#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADDyno/VB/addyno.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PartialTrustVisibleAssemblies">
      <MemberSignature Language="C#" Value="public string[] PartialTrustVisibleAssemblies { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string[] PartialTrustVisibleAssemblies" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.PartialTrustVisibleAssemblies" />
      <MemberSignature Language="VB.NET" Value="Public Property PartialTrustVisibleAssemblies As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property cli::array &lt;System::String ^&gt; ^ PartialTrustVisibleAssemblies { cli::array &lt;System::String ^&gt; ^ get(); void set(cli::array &lt;System::String ^&gt; ^ value); };" />
      <MemberSignature Language="F#" Value="member this.PartialTrustVisibleAssemblies : string[] with get, set" Usage="System.AppDomainSetup.PartialTrustVisibleAssemblies" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece una lista de ensamblados señalada con la marca <see cref="F:System.Security.PartialTrustVisibilityLevel.NotVisibleByDefault" /> que se hace visible para el código de la confianza parcial que se ejecuta en un dominio de aplicación en espacio aislado.</summary>
        <value>Una matriz de nombres de ensamblado parciales, donde cada nombre parcial está compuesto del nombre del ensamblado simple y la clave pública.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Empezando por la [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], el <xref:System.Security.AllowPartiallyTrustedCallersAttribute> atributo (APTCA) se puede hacer condicional estableciendo su <xref:System.Security.AllowPartiallyTrustedCallersAttribute.PartialTrustVisibilityLevel%2A> propiedad <xref:System.Security.PartialTrustVisibilityLevel.NotVisibleByDefault>. Un ensamblado APTCA que se marca con <xref:System.Security.PartialTrustVisibilityLevel.NotVisibleByDefault> no se puede utilizar código de confianza parcial, a menos que la aplicación host lo permite.  
  
 El host de un dominio de aplicación en espacio aislado permite que el código en el dominio de aplicación para usar ensamblados con atributos APTCA condicionales mediante la creación de una matriz que contiene el nombre simple y la clave pública de cada ensamblado y asignar la matriz a esta propiedad. Por ejemplo, un elemento de la matriz podría ser similar al siguiente: "MyAssembly, PublicKey = 0024000004800000940000000602000000240000525341310004000001000100db2ad5e5fedc67ea526ff72ad426ef68e08e241d296c499eedfec6648dcc62b1a12f72be5833a45bbec481b68415b08a5fbc9f9ef247b523dd72bbea65bb532784ddc5c704544bd2f1c2d46fdbe41e4f949e76f9947357b2d5cf8ca9f970701bbd6e8ab64ad31b20ad 0be9b56dae4f6b83332b92a2a3b8ea2804c40efbc0b6b9 ".  
  
> [!IMPORTANT]
>  Si usa una subclase de <xref:System.AppDomainManager>y el ensamblado que lo define depende de los ensamblados marcados con el atributo APTCA condicional, debe incluir esos ensamblados en la lista que se pasa a la <xref:System.AppDomainSetup.PartialTrustVisibleAssemblies%2A> propiedad de la <xref:System.AppDomainSetup>se usa para crear dominios de aplicación. En caso contrario, se deshabilitarán los ensamblados marcados con el atributo APTCA condicional.  
  
> [!NOTE]
>  Cuando se depura una aplicación que se está ejecutando en un dominio de aplicación en espacio aislado, algunos <xref:System.Security.SecurityException> mensajes puede inducir a error. Por ejemplo, un mensaje puede indicar que uno de los ensamblados de plena confianza solo tiene permisos limitados, cuando la causa real del problema es que una petición de seguridad que supera el conjunto de permisos concedidos del dominio de aplicación en espacio aislado se ha propagado al límite de la dominio de aplicación en espacio aislado y con errores.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Security.AllowPartiallyTrustedCallersAttribute" />
        <altmember cref="P:System.Security.AllowPartiallyTrustedCallersAttribute.PartialTrustVisibilityLevel" />
        <altmember cref="F:System.Security.PartialTrustVisibilityLevel.NotVisibleByDefault" />
      </Docs>
    </Member>
    <Member MemberName="PrivateBinPath">
      <MemberSignature Language="C#" Value="public string PrivateBinPath { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string PrivateBinPath" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.PrivateBinPath" />
      <MemberSignature Language="VB.NET" Value="Public Property PrivateBinPath As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ PrivateBinPath { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.PrivateBinPath : string with get, set" Usage="System.AppDomainSetup.PrivateBinPath" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.IAppDomainSetup.PrivateBinPath</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece la lista de directorios bajo el directorio base de la aplicación donde se buscan ensamblados privados.</summary>
        <value>Una lista de nombres de directorio separados por punto y coma.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Los ensamblados privados se implementan en la misma estructura de directorio que la aplicación. Si los directorios especificados para <xref:System.AppDomainSetup.PrivateBinPath%2A> no están en <xref:System.AppDomainSetup.ApplicationBase%2A>, se pasan por alto.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PrivateBinPathProbe">
      <MemberSignature Language="C#" Value="public string PrivateBinPathProbe { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string PrivateBinPathProbe" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.PrivateBinPathProbe" />
      <MemberSignature Language="VB.NET" Value="Public Property PrivateBinPathProbe As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ PrivateBinPathProbe { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.PrivateBinPathProbe : string with get, set" Usage="System.AppDomainSetup.PrivateBinPathProbe" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.IAppDomainSetup.PrivateBinPathProbe</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece un valor de cadena que incluye o excluye <see cref="P:System.AppDomainSetup.ApplicationBase" /> de la ruta de búsqueda de la aplicación y busca solo en <see cref="P:System.AppDomainSetup.PrivateBinPath" />.</summary>
        <value>Una referencia nula (<see langword="Nothing" /> en Visual Basic) para incluir la ruta de acceso base de la aplicación al buscar ensamblados; cualquier valor de cadena no nulo para excluir la ruta de acceso. El valor predeterminado es <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Establezca esta propiedad en cualquier valor de cadena no nula, incluidos <xref:System.String.Empty?displayProperty=nameWithType> (""), para excluir la ruta de acceso del directorio de aplicación, es decir, <xref:System.AppDomainSetup.ApplicationBase%2A> : desde la ruta de acceso de búsqueda de la aplicación y para buscar ensamblados solo en <xref:System.AppDomainSetup.PrivateBinPath%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SandboxInterop">
      <MemberSignature Language="C#" Value="public bool SandboxInterop { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool SandboxInterop" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.SandboxInterop" />
      <MemberSignature Language="VB.NET" Value="Public Property SandboxInterop As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool SandboxInterop { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.SandboxInterop : bool with get, set" Usage="System.AppDomainSetup.SandboxInterop" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece un valor que indica si el almacenamiento en caché de interfaces para las llamadas de interoperabilidad en el dominio de aplicación está deshabilitado, de modo que se ejecute un método <c>QueryInterface</c> en cada llamada.</summary>
        <value>Es <see langword="true" /> si el almacenamiento en caché de interfaces para las llamadas de interoperabilidad en los dominios de aplicación creados con el actual objeto <see cref="T:System.AppDomainSetup" /> está deshabilitado; de lo contrario, es <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Deshabilitar la interfaz de almacenamiento en caché no tiene un impacto significativo en el rendimiento de las llamadas de interoperabilidad.  
  
 Este miembro se especificó en el [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)].  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetCompatibilitySwitches">
      <MemberSignature Language="C#" Value="public void SetCompatibilitySwitches (System.Collections.Generic.IEnumerable&lt;string&gt; switches);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetCompatibilitySwitches(class System.Collections.Generic.IEnumerable`1&lt;string&gt; switches) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomainSetup.SetCompatibilitySwitches(System.Collections.Generic.IEnumerable{System.String})" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetCompatibilitySwitches (switches As IEnumerable(Of String))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetCompatibilitySwitches(System::Collections::Generic::IEnumerable&lt;System::String ^&gt; ^ switches);" />
      <MemberSignature Language="F#" Value="member this.SetCompatibilitySwitches : seq&lt;string&gt; -&gt; unit" Usage="appDomainSetup.SetCompatibilitySwitches switches" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="switches" Type="System.Collections.Generic.IEnumerable&lt;System.String&gt;" />
      </Parameters>
      <Docs>
        <param name="switches">Conjunto enumerable de valores de cadena que especifican los modificadores de compatibilidad, o <see langword="null" /> para borrar los modificadores de compatibilidad existentes.</param>
        <summary>Establece los modificadores especificados de modo que el dominio de aplicación sea compatible con las versiones anteriores de .NET Framework para los problemas indicados.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Las versiones principales de .NET Framework a veces introducen cambios importantes de la versión anterior. Por ejemplo, el [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)] presenta un pequeño número de cambios importantes desde el [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]. Use el <xref:System.AppDomainSetup.SetCompatibilitySwitches%2A> método para especificar que uno o varios de estos cambios se debería deshacer para que el dominio de aplicación, para que el comportamiento sea compatible con la versión anterior de .NET Framework.  
  
 Cada vez que llama a este método, reemplaza la configuración del conmutador existente. Para borrar la configuración, especifique `null` para el `switches` parámetro.  
  
 El conjunto de valores de cadena que proporcione para `switches` puede ser una matriz de cadena simple, porque las matrices implementan la <xref:System.Collections.IEnumerable> interfaz.  
  
 En la tabla siguiente se proporciona ejemplos de modificadores de compatibilidad que se pueden establecer para restaurar el comportamiento de versiones anteriores de .NET Framework.  
  
|Modificador|Significado|  
|------------|-------------|  
|"NetFx40_LegacySecurityPolicy"|Acceso del código (CAS) para el [!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)] está habilitada en este dominio de aplicación. Consulte [ &lt;NetFx40_LegacySecurityPolicy&gt; elemento](~/docs/framework/configure-apps/file-schema/runtime/netfx40-legacysecuritypolicy-element.md).|  
|"NetFx40_Legacy20SortingBehavior"|Cadena de ordenación de los valores predeterminados para el [!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)] están habilitados en este dominio de aplicación. Restaurar correctamente el comportamiento de ordenación heredado, también requiere la biblioteca de vínculos dinámicos sort00001000.dll esté disponible en el sistema local. Consulte [ &lt;CompatSortNLSVersion&gt; elemento](~/docs/framework/configure-apps/file-schema/runtime/compatsortnlsversion-element.md).|  
|"NetFx40_Legacy40SortingBehavior"|Cadena de ordenación de los valores predeterminados para el [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] y Unicode 5.0 están habilitadas en este dominio de aplicación. Restaurar correctamente el comportamiento de ordenación heredado, también requiere la biblioteca de vínculos dinámicos sort00060101.dll esté disponible en el sistema local.|  
|"NetFx40_TimeSpanLegacyFormatMode"|<xref:System.TimeSpan> formato de comportamiento para el [!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)] está habilitada en este dominio de aplicación. Consulte [ &lt;TimeSpan_LegacyFormatMode&gt; elemento](~/docs/framework/configure-apps/file-schema/runtime/timespan-legacyformatmode-element.md) y la sección "Restauración de formato de TimeSpan de heredado" de la <xref:System.TimeSpan> tema.|  
|"UseRandomizedStringHashAlgorithm"|El runtime calcula los códigos hash para cadenas en una por cada dominio de aplicación en lugar de usar un solo algoritmo hash que genera un código hash coherente entre dominios de aplicación. Consulte [ &lt;UseRandomizedStringHashAlgorithm&gt; elemento](~/docs/framework/configure-apps/file-schema/runtime/userandomizedstringhashalgorithm-element.md).|  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.AppDomain.IsCompatibilitySwitchSet(System.String)" />
        <related type="Article" href="https://msdn.microsoft.com/library/07132b9c-4a72-4710-99d7-e702405e02d4">&lt;NetFx40_LegacySecurityPolicy&gt; elemento</related>
        <related type="Article" href="https://msdn.microsoft.com/library/782cc82e-83f7-404a-80b7-6d3061a8b6e3">&lt;CompatSortNLSVersion&gt; elemento</related>
        <related type="Article" href="https://msdn.microsoft.com/library/865e7207-d050-4442-b574-57ea29d5e2d6">&lt;TimeSpan_LegacyFormatMode&gt; elemento</related>
        <related type="Article" href="https://msdn.microsoft.com/library/c08125d6-56cc-4b23-b482-813ff85dc630">&lt;UseRandomizedStringHashAlgorithm&gt; elemento</related>
      </Docs>
    </Member>
    <Member MemberName="SetConfigurationBytes">
      <MemberSignature Language="C#" Value="public void SetConfigurationBytes (byte[] value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetConfigurationBytes(unsigned int8[] value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomainSetup.SetConfigurationBytes(System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetConfigurationBytes (value As Byte())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetConfigurationBytes(cli::array &lt;System::Byte&gt; ^ value);" />
      <MemberSignature Language="F#" Value="member this.SetConfigurationBytes : byte[] -&gt; unit" Usage="appDomainSetup.SetConfigurationBytes value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="value">Una matriz de que contiene la información de configuración XML que se va a usar para el dominio de aplicación.</param>
        <summary>Proporciona información de configuración XML para el dominio de aplicación, reemplazando la información de configuración XML de la aplicación.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.AppDomainSetup.SetConfigurationBytes%2A> método proporciona una forma de reemplazar la información de configuración de una aplicación que crea un nuevo dominio de aplicación. La información del archivo de configuración en `value` reemplaza la información del archivo de configuración de la aplicación. Por ejemplo, cuando la aplicación Example.exe crea un nuevo dominio de aplicación, puede reemplazar la información de configuración obtenida originalmente el archivo Example.exe.config.  
  
> [!IMPORTANT]
>  Algunos consumidores de la información del archivo de configuración no usan la información almacenada por el <xref:System.AppDomainSetup.SetConfigurationBytes%2A> método. El tiempo de ejecución no exigir esto. Para asegurarse de que toda información de archivo de configuración se reemplaza en un nuevo dominio de aplicación, use el <xref:System.AppDomainSetup.ConfigurationFile%2A> propiedad para especificar un archivo de configuración. El <xref:System.AppDomainSetup.SetConfigurationBytes%2A> método afecta al enlace de ensamblados.  
  
 El código XML de `value` es el mismo que el XML en un archivo de configuración normal, excepto en que se almacena como un <xref:System.Byte> matriz.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/f04816ab-110d-4e28-9283-845d6d9a4a68">Esquema de la configuración de Common Language Runtime</related>
      </Docs>
    </Member>
    <Member MemberName="SetNativeFunction">
      <MemberSignature Language="C#" Value="public void SetNativeFunction (string functionName, int functionVersion, IntPtr functionPointer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetNativeFunction(string functionName, int32 functionVersion, native int functionPointer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomainSetup.SetNativeFunction(System.String,System.Int32,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetNativeFunction (functionName As String, functionVersion As Integer, functionPointer As IntPtr)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetNativeFunction(System::String ^ functionName, int functionVersion, IntPtr functionPointer);" />
      <MemberSignature Language="F#" Value="member this.SetNativeFunction : string * int * nativeint -&gt; unit" Usage="appDomainSetup.SetNativeFunction (functionName, functionVersion, functionPointer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="functionName" Type="System.String" />
        <Parameter Name="functionVersion" Type="System.Int32" />
        <Parameter Name="functionPointer" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="functionName">Nombre de la función de comparación de cadenas que se va a invalidar.</param>
        <param name="functionVersion">Versión de la función. Para [!INCLUDE[net_v45](~/includes/net-v45-md.md)], su valor debe ser igual o mayor que 1.</param>
        <param name="functionPointer">Puntero a la función que reemplaza  <paramref name="functionName" />.</param>
        <summary>Proporciona el Common Language Runtime con una implementación alternativa de una función de comparación de cadenas.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La siguiente comparación de cadenas y métodos de ordenación pueden reemplazarse por el <xref:System.AppDomainSetup.SetNativeFunction%2A> método:  
  
-   `IsNLSDefinedString`  
  
-   `CompareStringEx`  
  
-   `LCMapStringEx`  
  
-   `FindNLSStringEx`  
  
-   `CompareStringOrdinal`  
  
-   `GetNLSVersion`  
  
 Para obtener información acerca de estas funciones, vea [las funciones de compatibilidad de idioma nacional](https://go.microsoft.com/fwlink/?LinkId=228134).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">El valor de <paramref name="functionName" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="functionVersion" /> no es 1 o superior.  
  
O bien 
 El valor de <paramref name="functionPointer" /> es <see cref="F:System.IntPtr.Zero" />.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requiere plena confianza para el llamador inmediato. Este miembro no se puede usar código de confianza parcial o transparente.</permission>
      </Docs>
    </Member>
    <Member MemberName="ShadowCopyDirectories">
      <MemberSignature Language="C#" Value="public string ShadowCopyDirectories { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ShadowCopyDirectories" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.ShadowCopyDirectories" />
      <MemberSignature Language="VB.NET" Value="Public Property ShadowCopyDirectories As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ ShadowCopyDirectories { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ShadowCopyDirectories : string with get, set" Usage="System.AppDomainSetup.ShadowCopyDirectories" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.IAppDomainSetup.ShadowCopyDirectories</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece los nombres de los directorios que contienen los ensamblados de los que van a hacerse copias sombra.</summary>
        <value>Una lista de nombres de directorio separados por punto y coma.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cuando copia sombra está habilitada, el valor predeterminado es para instantáneas de todos los ensamblados se encuentran a través de la búsqueda es decir, en los directorios especificados por el <xref:System.AppDomainSetup.PrivateBinPath%2A> y <xref:System.AppDomainSetup.ApplicationBase%2A> propiedades. El <xref:System.AppDomainSetup.ShadowCopyDirectories%2A> propiedad restringe la instantánea a los ensamblados en los directorios especificados por <xref:System.AppDomainSetup.ShadowCopyDirectories%2A>.  
  
 Si no asigna una cadena a la <xref:System.AppDomainSetup.ShadowCopyDirectories%2A> propiedad, o si establece esta propiedad en `null`, todos los ensamblados en los directorios especificados por el <xref:System.AppDomainSetup.ApplicationBase%2A> y <xref:System.AppDomainSetup.PrivateBinPath%2A> propiedades son instantáneas.  
  
> [!IMPORTANT]
>  Las rutas de acceso de directorio no deben contener ningún carácter de punto y coma, porque el punto y coma es el carácter delimitador. No hay ningún carácter de escape para el punto y coma.  
  
 Cuando copia sombra está en vigor, se copian los archivos de ensamblado a otra ubicación antes de que se cargan los ensamblados. El archivo de ensamblado original no está bloqueado, por lo que se puede actualizar. Para obtener más información sobre las instantáneas, vea [copias sombra de ensamblados](~/docs/framework/app-domains/shadow-copy-assemblies.md).  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Para obtener acceso a la información de ruta de acceso. Enumeración asociada: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
        <altmember cref="P:System.AppDomainSetup.CachePath" />
        <altmember cref="P:System.AppDomainSetup.ShadowCopyFiles" />
        <related type="Article" href="~/docs/framework/app-domains/shadow-copy-assemblies.md">Copias sombra de ensamblados</related>
      </Docs>
    </Member>
    <Member MemberName="ShadowCopyFiles">
      <MemberSignature Language="C#" Value="public string ShadowCopyFiles { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ShadowCopyFiles" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.ShadowCopyFiles" />
      <MemberSignature Language="VB.NET" Value="Public Property ShadowCopyFiles As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ ShadowCopyFiles { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ShadowCopyFiles : string with get, set" Usage="System.AppDomainSetup.ShadowCopyFiles" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.IAppDomainSetup.ShadowCopyFiles</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece una cadena que indica si la operación de instantánea está activada o desactivada.</summary>
        <value>Un valor de cadena "true" para indicar que la operación de instantánea está activada; o bien, "false" para indicar que la operación de instantánea está desactivada.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para obtener más información sobre las instantáneas, vea [copias sombra de ensamblados](~/docs/framework/app-domains/shadow-copy-assemblies.md).  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.AppDomainSetup.CachePath" />
        <altmember cref="P:System.AppDomainSetup.ShadowCopyDirectories" />
        <related type="Article" href="~/docs/framework/app-domains/shadow-copy-assemblies.md">Copias sombra de ensamblados</related>
      </Docs>
    </Member>
    <Member MemberName="TargetFrameworkName">
      <MemberSignature Language="C#" Value="public string TargetFrameworkName { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string TargetFrameworkName" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.TargetFrameworkName" />
      <MemberSignature Language="VB.NET" Value="Public Property TargetFrameworkName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ TargetFrameworkName { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.TargetFrameworkName : string with get, set" Usage="System.AppDomainSetup.TargetFrameworkName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece una cadena que especifica la versión de destino y el perfil de .NET Framework para el dominio de aplicación, en un formato que el constructor <see cref="M:System.Runtime.Versioning.FrameworkName.#ctor(System.String)" /> pueda analizar.</summary>
        <value>Versión de destino y perfil de .NET Framework.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Establezca esta propiedad para indicar a la versión actualmente en ejecución de .NET Framework que se utilizará el dominio de aplicación para cargar y ejecutar ensamblados que se han compilado para la versión de destino y el perfil. Si la versión de .NET Framework que se está ejecutando tiene comportamientos opcionales que afectan a la compatibilidad de código que se compiló con la versión de destino, puede habilitar o deshabilitar esos comportamientos, según corresponda mejorar la compatibilidad. Esto puede ser útil cuando una aplicación admite complementos compilados con varias versiones de .NET Framework al ejecutarlas en dominios de aplicación independientes.  
  
 Para las aplicaciones cliente, el valor de la <xref:System.AppDomainSetup.TargetFrameworkName%2A> propiedad se deduce de la <xref:System.Runtime.Versioning.TargetFrameworkAttribute> atributo. En [!INCLUDE[vs_dev10_long](~/includes/vs-dev10-long-md.md)] y versiones posteriores, se agrega este atributo al ensamblado automáticamente según la configuración del proyecto **.NET Framework de destino** propiedad.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>