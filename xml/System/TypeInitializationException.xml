<Type Name="TypeInitializationException" FullName="System.TypeInitializationException">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="4e010e0c78c65b529ed1ad5c97ca2f1013dd01bc" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="es-ES" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
    <Meta Name="ms.locfileid" Value="30728519" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class TypeInitializationException : SystemException" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable sealed beforefieldinit TypeInitializationException extends System.SystemException" />
  <TypeSignature Language="DocId" Value="T:System.TypeInitializationException" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class TypeInitializationException&#xA;Inherits SystemException" />
  <TypeSignature Language="C++ CLI" Value="public ref class TypeInitializationException sealed : SystemException" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Exception</BaseTypeName>
    <BaseTypeName FrameworkAlternate="netframework-4.5">System.SystemException</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Excepción que se produce como contenedor de la excepción producida por el inicializador de la clase. Esta clase no puede heredarse.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cuando el inicializador de clase no logra inicializar un tipo, se crea una excepción <xref:System.TypeInitializationException> y se pasa una referencia a la excepción producida por el inicializador de clase del tipo. El <xref:System.Exception.InnerException%2A> propiedad de <xref:System.TypeInitializationException> contiene la excepción subyacente.  
  
 Normalmente, el <xref:System.TypeInitializationException> excepción refleja una condición grave (el tiempo de ejecución es no se puede crear una instancia de un tipo) que impide que una aplicación de continuar.  Normalmente, el <xref:System.TypeInitializationException> se produce en respuesta a algún cambio en el entorno de ejecución de la aplicación. Por lo tanto, no sea posiblemente para solucionar problemas de código de depuración, la excepción no se debería tratar en un `try` / `catch` bloque. En su lugar, se debe investigar la causa de la excepción y eliminarse.  
  
 <xref:System.TypeInitializationException> utiliza HRESULT COR_E_TYPEINITIALIZATION, que tiene el valor 0 x 80131534.  
  
 Para obtener una lista de valores de propiedad iniciales para una instancia de <xref:System.TypeInitializationException>, consulte el <xref:System.TypeInitializationException.%23ctor%2A> constructores.  
  
 En las siguientes secciones se describen algunas de las situaciones en que un <xref:System.TypeInitializationException> se produce la excepción.  
  
 [Constructores estáticos y TypeInitializationException (excepción)](#Static)   
 [Valor de tiempo de espera de coincidencia de expresión regular](#Timeout)   
 [Calendarios y los datos de referencia culturales](#Calendars)  
  
<a name="Static"></a>   
## <a name="static-constructors-and-the-typeinitializationexception-exception"></a>Constructores estáticos y TypeInitializationException (excepción)  
 Un constructor estático, si existe, se llama automáticamente en tiempo de ejecución antes de crear una nueva instancia de un tipo. Constructores estáticos se pueden definir explícitamente por un desarrollador. Si no se define explícitamente un constructor estático, compiladores crean automáticamente una de ellas para inicializar ninguno `static` (en C#) o `Shared` (en Visual Basic) miembros del tipo.  Para obtener más información sobre los constructores estáticos, vea [constructores estáticos](~/docs/csharp/programming-guide/classes-and-structs/static-constructors.md).  
  
 Normalmente, un <xref:System.TypeInitializationException> excepción se produce cuando un constructor estático no puede crear una instancia de un tipo.  El <xref:System.Exception.InnerException%2A> propiedad indica por qué el constructor estático no pudo crear instancias del tipo. Algunas de las causas más comunes de una <xref:System.TypeInitializationException> excepción son:  
  
 Una excepción no controlada en un constructor estático  
 Si se produce una excepción en un constructor estático, esa excepción se encapsula en un <xref:System.TypeInitializationException> excepción y el tipo no se pueden crear instancias.  
  
 Lo que a menudo hace difícil de solucionar esta excepción es que los constructores estáticos no se definen siempre explícitamente en el código fuente. Un constructor estático existe en un tipo si:  
  
-   Que se defina explícitamente como un miembro de un tipo.  
  
-   El tipo tiene `static` (en C#) o `Shared` (en Visual Basic) las variables que se declaran e inicializan en una sola instrucción. En este caso, el compilador de lenguaje genera un constructor estático para el tipo. Puede inspeccionar con una utilidad como [Desensamblador de IL](~/docs/framework/tools/ildasm-exe-il-disassembler.md). Por ejemplo, cuando los compiladores VB y C# compilan el ejemplo siguiente, que generan el IL para un constructor estático que es similar al siguiente:  
  
    ```  
  
    .method private specialname rtspecialname static   
            void  .cctor() cil managed  
    {  
      // Code size       12 (0xc)  
      .maxstack  8  
      IL_0000:  ldc.i4.3  
      IL_0001:  newobj     instance void TestClass::.ctor(int32)  
      IL_0006:  stsfld     class TestClass Example::test  
      IL_000b:  ret  
    } // end of method Example::.cctor  
  
    ```  
  
 El ejemplo siguiente muestra un <xref:System.TypeInitializationException> excepción producida por un constructor estático generado por el compilador. El `Example` clase incluye una `static` (en C#) o `Shared` (en Visual Basic) campo de tipo `TestClass` que se crea una instancia, pasando el valor de 3 a su constructor de clase.  Ese valor, sin embargo, no es válido; se permiten únicamente los valores de 0 ó 1. Como resultado, el `TestClass` clase constructor produce un <xref:System.ArgumentOutOfRangeException>. Puesto que no se controla esta excepción, se encapsula en un <xref:System.TypeInitializationException> excepción.  
  
 [!code-csharp[System.TypeInitializationException#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.TypeInitializationException/cs/ctorException1.cs#3)]
 [!code-vb[System.TypeInitializationException#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.TypeInitializationException/vb/CtorException1.vb#3)]  
  
 Tenga en cuenta que el mensaje de excepción muestra información sobre la <xref:System.Exception.InnerException%2A> propiedad.  
  
 Un archivo de ensamblado o datos que faltan  
 Una causa común de un <xref:System.TypeInitializationException> excepción es que un ensamblado o archivo de datos que ya estaba presente en entornos de desarrollo y prueba de una aplicación está presente en su entorno en tiempo de ejecución. Por ejemplo, puede compilar el ejemplo siguiente para un ensamblado denominado Missing1a.dll mediante el uso de esta sintaxis de línea de comandos:  
  
```csharp  
csc /t:library Missing1a.cs  
```  
  
```vb  
vbc Missing1a.vb /t:library  
```  
  
 [!code-csharp[System.TypeInitializationException#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.TypeInitializationException/cs/Missing1a.cs#1)]
 [!code-vb[System.TypeInitializationException#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.TypeInitializationException/vb/Missing1a.vb#1)]  
  
 A continuación, puede compilar el ejemplo siguiente en un archivo ejecutable denominado Missing1.exe mediante la inclusión de una referencia a Missing1a.dll:  
  
```csharp  
csc Missing1.cs /r:Missing1a.dll  
```  
  
```vb  
vbc Missing1.vb /r:Missing1a.dll  
```  
  
 Sin embargo, si, cambiar el nombre de mover o eliminar Missing1a.dll y ejecutar el ejemplo, produce un <xref:System.TypeInitializationException> excepción y muestra el resultado que aparece en el ejemplo.  Tenga en cuenta que el mensaje de excepción incluye información sobre la <xref:System.Exception.InnerException%2A> propiedad. En este caso, la excepción interna es un <xref:System.IO.FileNotFoundException> que se produce porque el tiempo de ejecución no puede encontrar el ensamblado dependiente.  
  
 [!code-csharp[System.TypeInitializationException#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.TypeInitializationException/cs/Missing1.cs#2)]
 [!code-vb[System.TypeInitializationException#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.TypeInitializationException/vb/Missing1.vb#2)]  
  
> [!NOTE]
>  En este ejemplo, un <xref:System.TypeInitializationException> excepción porque no se pudo cargar un ensamblado. También se puede producir la excepción si un constructor estático intenta abrir un archivo de datos, como un archivo de configuración, un archivo XML o un archivo que contiene los datos, que no se encuentra serializados.  
  
<a name="Timeout"></a>   
## <a name="regular-expression-match-timeout-values"></a>Valor de tiempo de espera de coincidencia de expresión regular  
 Puede establecer el valor de tiempo de espera predeterminado para una operación en una base por dominio de aplicación de coincidencia de expresión regular. El tiempo de espera se define especificando un un <xref:System.TimeSpan> valor para la propiedad "REGEX_DEFAULT_MATCH_TIMEOUT" para el <xref:System.AppDomain.SetData%2A?displayProperty=nameWithType> método. El intervalo de tiempo debe ser válido <xref:System.TimeSpan> objeto que es mayor que cero y menor que aproximadamente 24 días. Si no se cumplen estos requisitos, el intento de establecer el valor de tiempo de espera predeterminado produce una <xref:System.ArgumentOutOfRangeException>, que a su vez se encapsula en un <xref:System.TypeInitializationException> excepción.  
  
 El siguiente ejemplo se muestra el <xref:System.TypeInitializationException> que se produce cuando el valor asignado a la propiedad "REGEX_DEFAULT_MATCH_TIMEOUT" no es válido. Para eliminar la excepción, establezca la propiedad "REGEX_DEFAULT_MATCH_TIMEOUT" en un <xref:System.TimeSpan> valor que es mayor que cero y menor que aproximadamente 24 días.  
  
 [!code-csharp[System.TypeInitializationException#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.TypeInitializationException/cs/Regex1.cs#4)]
 [!code-vb[System.TypeInitializationException#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.TypeInitializationException/vb/Regex1.vb#4)]  
  
<a name="Calendars"></a>   
## <a name="calendars-and-cultural-data"></a>Calendarios y los datos de referencia culturales  
 Si intenta crear una instancia de un calendario, pero el tiempo de ejecución es no se puede crear una instancia de la <xref:System.Globalization.CultureInfo> objeto que corresponde a ese calendario, produce un <xref:System.TypeInitializationException> excepción. Los constructores de clase de calendario siguientes puede producir esta excepción:  
  
-   El constructor predeterminado de la <xref:System.Globalization.JapaneseCalendar> clase.  
  
-   El constructor predeterminado de la <xref:System.Globalization.KoreanCalendar> clase.  
  
-   El constructor predeterminado de la <xref:System.Globalization.TaiwanCalendar> clase.  
  
 Puesto que los datos de referencia culturales para estas referencias culturales deben estar disponibles en todos los sistemas, se debe en contadas ocasiones, si alguna vez, producir esta excepción.  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Exception" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public TypeInitializationException (string fullTypeName, Exception innerException);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string fullTypeName, class System.Exception innerException) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.TypeInitializationException.#ctor(System.String,System.Exception)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (fullTypeName As String, innerException As Exception)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; TypeInitializationException(System::String ^ fullTypeName, Exception ^ innerException);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="fullTypeName" Type="System.String" />
        <Parameter Name="innerException" Type="System.Exception" />
      </Parameters>
      <Docs>
        <param name="fullTypeName">Nombre completo del tipo que no se puede inicializar.</param>
        <param name="innerException">Excepción que es la causa de la excepción actual. Si el parámetro <c>innerException</c> no es una referencia nula (<see langword="Nothing" /> en Visual Basic), la excepción actual se inicia en un bloque <see langword="catch" /> que controla la excepción interna.</param>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.TypeInitializationException" /> con el mensaje de error predeterminado, el nombre del tipo especificado y una referencia a la excepción interna que representa la causa principal de esta excepción.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Una excepción que se produce como resultado directo de una excepción anterior puede incluir una referencia a la excepción anterior de la propiedad <xref:System.Exception.InnerException%2A>. La propiedad <xref:System.Exception.InnerException%2A> devuelve el mismo valor pasado al constructor, o una referencia nula (`Nothing` en Visual Basic) si la propiedad <xref:System.Exception.InnerException%2A> no proporciona el valor de la excepción interna al constructor.  
  
 En la tabla siguiente se muestran los valores de propiedad iniciales para una instancia de <xref:System.TypeInitializationException>.  
  
|Propiedad.|Valor|  
|--------------|-----------|  
|<xref:System.Exception.InnerException%2A>|Referencia a la excepción interna.|  
|<xref:System.Exception.Message%2A>|La cadena del mensaje de error localizado.|  
|<xref:System.TypeInitializationException.TypeName%2A>|Nombre del tipo.|  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Exception" />
      </Docs>
    </Member>
    <Member MemberName="GetObjectData">
      <MemberSignature Language="C#" Value="public override void GetObjectData (System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void GetObjectData(class System.Runtime.Serialization.SerializationInfo info, valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.TypeInitializationException.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub GetObjectData (info As SerializationInfo, context As StreamingContext)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void GetObjectData(System::Runtime::Serialization::SerializationInfo ^ info, System::Runtime::Serialization::StreamingContext context);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="info" Type="System.Runtime.Serialization.SerializationInfo" />
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" />
      </Parameters>
      <Docs>
        <param name="info">
          <see cref="T:System.Runtime.Serialization.SerializationInfo" /> que contiene los datos serializados del objeto que hacen referencia a la excepción que se va a producir.</param>
        <param name="context">
          <see cref="T:System.Runtime.Serialization.StreamingContext" /> que contiene información contextual sobre el origen o el destino.</param>
        <summary>Establece el objeto <see cref="T:System.Runtime.Serialization.SerializationInfo" /> con el nombre del tipo y la información adicional de la excepción.</summary>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requiere plena confianza para el llamador inmediato. Este miembro no puede usarse por código de confianza parcial o transparente.</permission>
      </Docs>
    </Member>
    <Member MemberName="TypeName">
      <MemberSignature Language="C#" Value="public string TypeName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string TypeName" />
      <MemberSignature Language="DocId" Value="P:System.TypeInitializationException.TypeName" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property TypeName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ TypeName { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene el nombre completo del tipo que no se puede inicializar.</summary>
        <value>Nombre completo del tipo que no se puede inicializar.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>