<Type Name="Array" FullName="System.Array">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="c944cf7be94887e0f4378125ec8f970b8db26fd0" />
    <Meta Name="ms.sourcegitcommit" Value="9e06b87bcfa4347dbbaaa4b3cc36b43b93b5badb" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="es-ES" />
    <Meta Name="ms.lasthandoff" Value="11/20/2018" />
    <Meta Name="ms.locfileid" Value="52225875" />
  </Metadata>
  <TypeSignature Language="C#" Value="public abstract class Array : ICloneable, System.Collections.IList, System.Collections.IStructuralComparable, System.Collections.IStructuralEquatable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract serializable beforefieldinit Array extends System.Object implements class System.Collections.ICollection, class System.Collections.IEnumerable, class System.Collections.IList, class System.Collections.IStructuralComparable, class System.Collections.IStructuralEquatable, class System.ICloneable" />
  <TypeSignature Language="DocId" Value="T:System.Array" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class Array&#xA;Implements ICloneable, IList, IStructuralComparable, IStructuralEquatable" />
  <TypeSignature Language="C++ CLI" Value="public ref class Array abstract : ICloneable, System::Collections::IList, System::Collections::IStructuralComparable, System::Collections::IStructuralEquatable" />
  <TypeSignature Language="F#" Value="type Array = class&#xA;    interface ICloneable&#xA;    interface ICollection&#xA;    interface IList&#xA;    interface IEnumerable&#xA;    interface IStructuralComparable&#xA;    interface IStructuralEquatable" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Collections.ICollection</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.IEnumerable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.IList</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.IStructuralComparable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.IStructuralEquatable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.ICloneable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Proporciona métodos para la creación, manipulación, búsqueda y ordenación de matrices, por lo tanto, sirve como clase base para todas las matrices de Common Language Runtime.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Array> clase no es parte de la <xref:System.Collections> espacios de nombres. Sin embargo, todavía se considera una colección porque se basa en el <xref:System.Collections.IList> interfaz.  
  
 La <xref:System.Array> clase es la clase base para las implementaciones de lenguajes que admiten las matrices. Sin embargo, el sistema y los compiladores pueden derivar explícitamente de la <xref:System.Array> clase. Los usuarios deben utilizar los constructores de matriz proporcionados por el lenguaje.  
  
 Un elemento es un valor en un <xref:System.Array>. La longitud de un <xref:System.Array> es el número total de elementos que puede contener. El límite inferior de un <xref:System.Array> es el índice de su primer elemento. Un <xref:System.Array> puede tener cualquier límite inferior, pero tiene un límite inferior de cero de forma predeterminada. Se puede definir un límite inferior diferente al crear una instancia de la <xref:System.Array> mediante la clase <xref:System.Array.CreateInstance%2A>. Multidimensional <xref:System.Array> puede tener distintos límites para cada dimensión. Una matriz puede tener un máximo de 32 dimensiones.  
  
 A diferencia de las clases en el <xref:System.Collections> espacios de nombres, <xref:System.Array> tiene una capacidad fija. Para aumentar la capacidad, debe crear un nuevo <xref:System.Array> objetos con la capacidad requerida, copiar los elementos de la antigua <xref:System.Array> objeto a la nueva y eliminar la antigua <xref:System.Array>.  
  
 De forma predeterminada, el tamaño máximo de un <xref:System.Array> es de 2 gigabytes (GB). En un entorno de 64 bits, puede evitar la restricción de tamaño estableciendo el `enabled` atributo de la [gcAllowVeryLargeObjects](~/docs/framework/configure-apps/file-schema/runtime/gcallowverylargeobjects-element.md) elemento de configuración a `true` en el entorno de tiempo de ejecución. Sin embargo, la matriz todavía estará limitada a un total de elementos de 4 mil millones y a un índice máximo de 0X7FEFFFFF en cualquier dimensión determinada (0X7FFFFFC7 para las matrices de bytes y matrices de estructuras de byte único).  
  
 Las matrices unidimensionales implementan la <xref:System.Collections.Generic.IList%601?displayProperty=nameWithType>, <xref:System.Collections.Generic.ICollection%601?displayProperty=nameWithType>, <xref:System.Collections.Generic.IEnumerable%601?displayProperty=nameWithType>, <xref:System.Collections.Generic.IReadOnlyList%601?displayProperty=nameWithType> y <xref:System.Collections.Generic.IReadOnlyCollection%601?displayProperty=nameWithType> interfaces genéricas. Las implementaciones se proporcionan a las matrices en tiempo de ejecución y, como resultado, las interfaces genéricas no aparecen en la sintaxis de declaración para el <xref:System.Array> clase. Además, no hay ningún temas de referencia para los miembros de interfaz que se puede acceder solo mediante la conversión de una matriz para el tipo de interfaz genérica (implementaciones de interfaz explícitas). El aspecto clave a tener en cuenta al convertir una matriz a una de estas interfaces es que los miembros que permiten agregar, insertar o quitar elementos throw <xref:System.NotSupportedException>.  
  
 <xref:System.Type> objetos proporcionan información acerca de las declaraciones de tipo de matriz. <xref:System.Array> los objetos con el mismo tipo de matriz comparten el mismo <xref:System.Type> objeto.  
  
 <xref:System.Type.IsArray%2A?displayProperty=nameWithType> y <xref:System.Type.GetElementType%2A?displayProperty=nameWithType> no puede devolver los resultados esperados con <xref:System.Array> porque si una matriz se convierte al tipo <xref:System.Array>, el resultado es un objeto, no es una matriz. Es decir, `typeof(System.Array).IsArray` devuelve `false`, y `typeof(System.Array).GetElementType` devuelve `null`.  
  
 El <xref:System.Array.Copy%2A?displayProperty=nameWithType> método copia elementos no sólo entre matrices del mismo tipo, sino también entre matrices estándar de tipos diferentes, ya que controla automáticamente la conversión de tipos.  
  
 Algunos métodos, como <xref:System.Array.CreateInstance%2A>, <xref:System.Array.Copy%2A>, <xref:System.Array.CopyTo%2A>, <xref:System.Array.GetValue%2A>, y <xref:System.Array.SetValue%2A>, proporcionan sobrecargas que aceptan enteros de 64 bits como parámetros para dar cabida a las matrices de gran capacidad. <xref:System.Array.LongLength%2A> y <xref:System.Array.GetLongLength%2A> devuelven enteros de 64 bits que indica la longitud de la matriz.  
  
 El <xref:System.Array> no se garantiza que se va a ordenar.  Se debe ordenar el <xref:System.Array> antes de realizar operaciones (como <xref:System.Array.BinarySearch%2A>) que requieren el <xref:System.Array> esté ordenada.  
  
 Mediante un <xref:System.Array> no admite el objeto de punteros en código nativo y se producirá un <xref:System.NotSupportedException> para varios métodos.  
  
   
  
## Examples  
 El siguiente ejemplo de código muestra cómo <xref:System.Array.Copy%2A?displayProperty=nameWithType> copia elementos entre una matriz de tipo entero y una matriz de tipo <xref:System.Object>.  
  
 [!code-cpp[Classic Array Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array Example/CS/source.cs#1)]
 [!code-vb[Classic Array Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array Example/VB/source.vb#1)]  
  
 En el ejemplo de código siguiente se crea e inicializa un <xref:System.Array> y muestra sus propiedades y sus elementos.  
  
 [!code-cpp[Classic Array Example#2](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array Example/CPP/source3.cpp#2)]
 [!code-csharp[Classic Array Example#2](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array Example/CS/source3.cs#2)]
 [!code-vb[Classic Array Example#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array Example/VB/source3.vb#2)]  
  
 ]]></format>
    </remarks>
    <threadsafe>Estáticos públicos (<see langword="Shared" /> en Visual Basic) los miembros de este tipo son seguros para subprocesos. No se garantiza que los miembros de instancias sean seguros para la ejecución de subprocesos.  
  
Esta implementación no proporciona un sincronizada contenedor (es seguro para subprocesos) para un <see cref="T:System.Array" />; sin embargo, según las clases de .NET Framework <see cref="T:System.Array" /> proporcionar su propia versión sincronizada de la colección utilizando el <see cref="P:System.Array.SyncRoot" /> propiedad.  
  
Enumerar una colección no es intrínsecamente un procedimiento seguro para subprocesos. Incluso cuando una colección está sincronizada, otros subprocesos todavía pueden modificarla, lo que hace que el enumerador produzca una excepción. Con el fin de garantizar la seguridad para la ejecución de subprocesos durante la enumeración, se puede bloquear la colección durante toda la enumeración o detectar las excepciones resultantes de los cambios realizados por otros subprocesos.</threadsafe>
    <altmember cref="T:System.Object" />
    <altmember cref="T:System.Type" />
    <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">Realizar operaciones de cadenas que no tienen en cuenta las referencias culturales en matrices</related>
    <related type="Article" href="~/docs/csharp/programming-guide/arrays/index.md">Matrices (Guía de programación de C#)</related>
    <related type="Article" href="~/docs/visual-basic/programming-guide/language-features/arrays/index.md">Matrices en Visual Basic</related>
  </Docs>
  <Members>
    <Member MemberName="AsReadOnly&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.ObjectModel.ReadOnlyCollection&lt;T&gt; AsReadOnly&lt;T&gt; (T[] array);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.ObjectModel.ReadOnlyCollection`1&lt;!!T&gt; AsReadOnly&lt;T&gt;(!!T[] array) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.AsReadOnly``1(``0[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function AsReadOnly(Of T) (array As T()) As ReadOnlyCollection(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static System::Collections::ObjectModel::ReadOnlyCollection&lt;T&gt; ^ AsReadOnly(cli::array &lt;T&gt; ^ array);" />
      <MemberSignature Language="F#" Value="static member AsReadOnly : 'T[] -&gt; System.Collections.ObjectModel.ReadOnlyCollection&lt;'T&gt;" Usage="System.Array.AsReadOnly array" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ObjectModel.ReadOnlyCollection&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
      </Parameters>
      <Docs>
        <typeparam name="T">Tipo de los elementos de la matriz.</typeparam>
        <param name="array">Matriz unidimensional de base cero para ajustar en un contenedor <see cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" /> de solo lectura.</param>
        <summary>Devuelve un contenedor de solo lectura para la matriz especificada.</summary>
        <returns>Contenedor <see cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" /> de solo lectura para la matriz especificada.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para evitar las modificaciones en la matriz, exponen solo a través de este contenedor.  
  
 Una colección es de solo lectura es simplemente una colección con un contenedor que evita la modificación de la colección; por lo tanto, si se realizan cambios en la colección subyacente, la colección de solo lectura refleja los cambios.  
  
 Este método es una operación o (1).  
  
   
  
## Examples  
 En el ejemplo siguiente se ajusta una matriz de solo lectura <xref:System.Collections.ObjectModel.ReadOnlyCollection%601>.  
  
 [!code-cpp[System.Array.AsReadOnly#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array.AsReadOnly/CPP/arrayasreadonly.cpp#1)]
 [!code-csharp[System.Array.AsReadOnly#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array.AsReadOnly/CS/arrayasreadonly.cs#1)]
 [!code-vb[System.Array.AsReadOnly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array.AsReadOnly/VB/arrayasreadonly.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El valor de <paramref name="array" /> es <see langword="null" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="BinarySearch">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Busca un valor en una <see cref="T:System.Array" /> unidimensional y ordenada usando un algoritmo de búsqueda binario.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BinarySearch">
      <MemberSignature Language="C#" Value="public static int BinarySearch (Array array, object value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 BinarySearch(class System.Array array, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.BinarySearch(System.Array,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int BinarySearch(Array ^ array, System::Object ^ value);" />
      <MemberSignature Language="F#" Value="static member BinarySearch : Array * obj -&gt; int" Usage="System.Array.BinarySearch (array, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="array">Matriz <see cref="T:System.Array" /> unidimensional y ordenada en la que se va a realizar la búsqueda.</param>
        <param name="value">Objeto que se va a buscar.</param>
        <summary>Busca un elemento específico en toda una matriz unidimensional y ordenada, usando la interfaz <see cref="T:System.IComparable" /> implementada por cada elemento de la matriz y por el objeto especificado.</summary>
        <returns>Índice del elemento <paramref name="value" /> especificado en el objeto <paramref name="array" /> especificado, si se encuentra <paramref name="value" />; en caso contrario, un número negativo. Si no se encuentra <paramref name="value" /> y <paramref name="value" /> es menor que uno o varios elementos de <paramref name="array" />, el número negativo devuelto es el complemento bit a bit del índice del primer elemento que sea mayor que <paramref name="value" />. Si no se encuentra <paramref name="value" /> y <paramref name="value" /> es mayor que cualquiera de los elementos de <paramref name="array" />, el número negativo devuelto es el complemento bit a bit del índice del último elemento más 1. Si se llama a este método con un objeto <paramref name="array" /> sin clasificar, el valor devuelto puede ser incorrecto y podría devolverse un número negativo, aunque <paramref name="value" /> esté presente en <paramref name="array" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método no es compatible con Buscar en matrices que contienen índices negativo. `array` deben estar ordenados antes de llamar a este método.  
  
 Si el <xref:System.Array> no contiene el valor especificado, el método devuelve un entero negativo. Puede aplicar el operador de complemento bit a bit (~ en C#, `Not` en Visual Basic) al resultado negativo para generar un índice. Si este índice es uno mayor que el límite superior de la matriz, hay ningún elemento mayor que `value` en la matriz. De lo contrario, es el índice del primer elemento que es mayor que `value`.  
  
 Ya sea `value` o todos los elementos de `array` debe implementar la <xref:System.IComparable> interfaz, que se usa para las comparaciones. Los elementos de `array` ya deben estar ordenados al aumentar el valor según el criterio de ordenación definido por el <xref:System.IComparable> implementación; de lo contrario, el resultado puede ser incorrecto.  
  
> [!NOTE]
>  Si`value` no implementa la <xref:System.IComparable> interfaz, los elementos de `array` no se han probado para <xref:System.IComparable> antes de que comience la búsqueda. Se produce una excepción si la búsqueda encuentra un elemento que no implementa <xref:System.IComparable>.  
  
 Se permiten elementos duplicados. Si el <xref:System.Array> contiene más de un elemento igual a `value`, el método devuelve el índice de solo una de las coincidencias y no necesariamente la primera de ellas.  
  
 `null` siempre puede compararse con cualquier otro tipo de referencia; por lo tanto, las comparaciones con `null` no generan una excepción.  
  
> [!NOTE]
>  Para cada elemento probado, `value` se pasa a la correspondiente <xref:System.IComparable> implementación, incluso si `value` es `null`. Es decir, el <xref:System.IComparable> implementación determina cómo se compara con un elemento determinado `null`.  
  
 Este método es O (log `n`) operación, donde `n` es el <xref:System.Array.Length%2A> de `array`.  
  
   
  
## Examples  
 El ejemplo de código siguiente muestra cómo usar <xref:System.Array.BinarySearch%2A> para localizar un objeto específico en un <xref:System.Array>.  
  
> [!NOTE]
>  La matriz se crea con sus elementos en orden ascendente. El <xref:System.Array.BinarySearch%2A> método requiere que la matriz se ordene en orden ascendente.  
  
 [!code-cpp[Classic Array.BinarySearch Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.BinarySearch Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.BinarySearch Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.BinarySearch Example/CS/source.cs#1)]
 [!code-vb[Classic Array.BinarySearch Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.BinarySearch Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El valor de <paramref name="array" /> es <see langword="null" />.</exception>
        <exception cref="T:System.RankException">
          <paramref name="array" /> es multidimensional.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="value" /> es de un tipo que no es compatible con los elementos de <paramref name="array" />.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="value" /> no implementa la interfaz <see cref="T:System.IComparable" /> y la búsqueda encuentra un elemento que no implementa la interfaz <see cref="T:System.IComparable" />.</exception>
        <altmember cref="T:System.IComparable" />
        <altmember cref="Overload:System.Array.Sort" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">Realizar operaciones de cadenas que no tienen en cuenta las referencias culturales en matrices</related>
      </Docs>
    </Member>
    <Member MemberName="BinarySearch">
      <MemberSignature Language="C#" Value="public static int BinarySearch (Array array, object value, System.Collections.IComparer comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 BinarySearch(class System.Array array, object value, class System.Collections.IComparer comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.BinarySearch(System.Array,System.Object,System.Collections.IComparer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int BinarySearch(Array ^ array, System::Object ^ value, System::Collections::IComparer ^ comparer);" />
      <MemberSignature Language="F#" Value="static member BinarySearch : Array * obj * System.Collections.IComparer -&gt; int" Usage="System.Array.BinarySearch (array, value, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="comparer" Type="System.Collections.IComparer" />
      </Parameters>
      <Docs>
        <param name="array">Matriz <see cref="T:System.Array" /> unidimensional y ordenada en la que se va a realizar la búsqueda.</param>
        <param name="value">Objeto que se va a buscar.</param>
        <param name="comparer">Implementación de <see cref="T:System.Collections.IComparer" /> que se va a usar al comparar elementos.  
  
O bien 
 <see langword="null" /> para usar la implementación de <see cref="T:System.IComparable" /> de cada elemento.</param>
        <summary>Busca un valor por toda una matriz unidimensional y ordenada, usando la interfaz <see cref="T:System.Collections.IComparer" /> especificada.</summary>
        <returns>Índice del elemento <paramref name="value" /> especificado en el objeto <paramref name="array" /> especificado, si se encuentra <paramref name="value" />; en caso contrario, un número negativo. Si no se encuentra <paramref name="value" /> y <paramref name="value" /> es menor que uno o varios elementos de <paramref name="array" />, el número negativo devuelto es el complemento bit a bit del índice del primer elemento que sea mayor que <paramref name="value" />. Si no se encuentra <paramref name="value" /> y <paramref name="value" /> es mayor que cualquiera de los elementos de <paramref name="array" />, el número negativo devuelto es el complemento bit a bit del índice del último elemento más 1. Si se llama a este método con un objeto <paramref name="array" /> sin clasificar, el valor devuelto puede ser incorrecto y podría devolverse un número negativo, aunque <paramref name="value" /> esté presente en <paramref name="array" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método no es compatible con Buscar en matrices que contienen índices negativo. `array` deben estar ordenados antes de llamar a este método.  
  
 Si el <xref:System.Array> no contiene el valor especificado, el método devuelve un entero negativo. Puede aplicar el operador de complemento bit a bit (~ en C#, `Not` en Visual Basic) al resultado negativo para generar un índice. Si este índice es uno mayor que el límite superior de la matriz, hay ningún elemento mayor que `value` en la matriz. De lo contrario, es el índice del primer elemento que es mayor que `value`.  
  
 El comparador personaliza cómo se comparan los elementos. Por ejemplo, puede usar un <xref:System.Collections.CaseInsensitiveComparer?displayProperty=nameWithType> como comparador para realizar búsquedas de cadenas entre mayúsculas y minúsculas.  
  
 Si `comparer` no `null`, los elementos de `array` se comparan con el valor especificado mediante especificado <xref:System.Collections.IComparer> implementación. Los elementos de `array` ya deben estar ordenados al aumentar el valor según el criterio de ordenación definido por `comparer`; en caso contrario, el resultado puede ser incorrecto.  
  
 Si`comparer` es `null`, la comparación se realiza mediante el <xref:System.IComparable> implementación proporcionada por el propio elemento o el valor especificado. Los elementos de `array` ya deben estar ordenados al aumentar el valor según el criterio de ordenación definido por el <xref:System.IComparable> implementación; de lo contrario, el resultado puede ser incorrecto.  
  
> [!NOTE]
>  Si `comparer` es `null` y `value` no implementa la <xref:System.IComparable> interfaz, los elementos de `array` no se han probado para <xref:System.IComparable> antes de que comience la búsqueda. Se produce una excepción si la búsqueda encuentra un elemento que no implementa <xref:System.IComparable>.  
  
 Se permiten elementos duplicados. Si el <xref:System.Array> contiene más de un elemento igual a `value`, el método devuelve el índice de solo una de las coincidencias y no necesariamente la primera de ellas.  
  
 `null` siempre puede compararse con cualquier otro tipo de referencia; por lo tanto, las comparaciones con `null` no generan una excepción.  
  
> [!NOTE]
>  Para cada elemento probado, `value` se pasa a la correspondiente <xref:System.IComparable> implementación, incluso si `value` es `null`. Es decir, el <xref:System.IComparable> implementación determina cómo se compara con un elemento determinado `null`.  
  
 Este método es O (log `n`) operación, donde `n` es el <xref:System.Array.Length%2A> de `array`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El valor de <paramref name="array" /> es <see langword="null" />.</exception>
        <exception cref="T:System.RankException">
          <paramref name="array" /> es multidimensional.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="comparer" /> es <see langword="null" /> y <paramref name="value" /> es de un tipo que no es compatible con los elementos de <paramref name="array" />.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="comparer" /> es <see langword="null" />, <paramref name="value" /> no implementa la interfaz <see cref="T:System.IComparable" /> y la búsqueda encuentra un elemento que no implementa la interfaz <see cref="T:System.IComparable" />.</exception>
        <altmember cref="T:System.Collections.IComparer" />
        <altmember cref="T:System.IComparable" />
        <altmember cref="Overload:System.Array.Sort" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">Realizar operaciones de cadenas que no tienen en cuenta las referencias culturales en matrices</related>
      </Docs>
    </Member>
    <Member MemberName="BinarySearch">
      <MemberSignature Language="C#" Value="public static int BinarySearch (Array array, int index, int length, object value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 BinarySearch(class System.Array array, int32 index, int32 length, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.BinarySearch(System.Array,System.Int32,System.Int32,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int BinarySearch(Array ^ array, int index, int length, System::Object ^ value);" />
      <MemberSignature Language="F#" Value="static member BinarySearch : Array * int * int * obj -&gt; int" Usage="System.Array.BinarySearch (array, index, length, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="array">Matriz <see cref="T:System.Array" /> unidimensional y ordenada en la que se va a realizar la búsqueda.</param>
        <param name="index">Índice inicial del intervalo en el que se va a buscar.</param>
        <param name="length">Longitud del intervalo en el que se va a buscar.</param>
        <param name="value">Objeto que se va a buscar.</param>
        <summary>Busca un valor en un intervalo de elementos de una matriz unidimensional y ordenada, usando la interfaz <see cref="T:System.IComparable" /> implementada por cada elemento de la matriz y por el valor especificado.</summary>
        <returns>Índice del elemento <paramref name="value" /> especificado en el objeto <paramref name="array" /> especificado, si se encuentra <paramref name="value" />; en caso contrario, un número negativo. Si no se encuentra <paramref name="value" /> y <paramref name="value" /> es menor que uno o varios elementos de <paramref name="array" />, el número negativo devuelto es el complemento bit a bit del índice del primer elemento que sea mayor que <paramref name="value" />. Si no se encuentra <paramref name="value" /> y <paramref name="value" /> es mayor que cualquiera de los elementos de <paramref name="array" />, el número negativo devuelto es el complemento bit a bit del índice del último elemento más 1. Si se llama a este método con un objeto <paramref name="array" /> sin clasificar, el valor devuelto puede ser incorrecto y podría devolverse un número negativo, aunque <paramref name="value" /> esté presente en <paramref name="array" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método no es compatible con Buscar en matrices que contienen índices negativo. `array` deben estar ordenados antes de llamar a este método.  
  
 Si el <xref:System.Array> no contiene el valor especificado, el método devuelve un entero negativo. Puede aplicar el operador de complemento bit a bit (~ en C#, `Not` en Visual Basic) al resultado negativo para generar un índice. Si este índice es uno mayor que el límite superior de la matriz, hay ningún elemento mayor que `value` en la matriz. De lo contrario, es el índice del primer elemento que es mayor que `value`.  
  
 Ya sea `value` o todos los elementos de `array` debe implementar la <xref:System.IComparable> interfaz, que se usa para las comparaciones. Los elementos de `array` ya deben estar ordenados al aumentar el valor según el criterio de ordenación definido por el <xref:System.IComparable> implementación; de lo contrario, el resultado puede ser incorrecto.  
  
> [!NOTE]
>  Si `value` no implementa la <xref:System.IComparable> interfaz, los elementos de `array` no se han probado para <xref:System.IComparable> antes de que comience la búsqueda. Se produce una excepción si la búsqueda encuentra un elemento que no implementa <xref:System.IComparable>.  
  
 Se permiten elementos duplicados. Si el <xref:System.Array> contiene más de un elemento igual a `value`, el método devuelve el índice de solo una de las coincidencias y no necesariamente la primera de ellas.  
  
 `null` siempre puede compararse con cualquier otro tipo de referencia; por lo tanto, las comparaciones con `null` no generan una excepción.  
  
> [!NOTE]
>  Para cada elemento probado, `value` se pasa a la correspondiente <xref:System.IComparable> implementación, incluso si `value` es `null`. Es decir, el <xref:System.IComparable> implementación determina cómo se compara con un elemento determinado `null`.  
  
 Este método es O (log `n`) operación, donde `n` es `length`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El valor de <paramref name="array" /> es <see langword="null" />.</exception>
        <exception cref="T:System.RankException">
          <paramref name="array" /> es multidimensional.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> es menor que el límite inferior de <paramref name="array" />.  
  
O bien 
 <paramref name="length" /> es menor que cero.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="index" /> y <paramref name="length" /> no especifican un intervalo válido en <paramref name="array" />.  
  
O bien 
 <paramref name="value" /> es de un tipo que no es compatible con los elementos de <paramref name="array" />.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="value" /> no implementa la interfaz <see cref="T:System.IComparable" /> y la búsqueda encuentra un elemento que no implementa la interfaz <see cref="T:System.IComparable" />.</exception>
        <altmember cref="T:System.IComparable" />
        <altmember cref="Overload:System.Array.Sort" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">Realizar operaciones de cadenas que no tienen en cuenta las referencias culturales en matrices</related>
      </Docs>
    </Member>
    <Member MemberName="BinarySearch">
      <MemberSignature Language="C#" Value="public static int BinarySearch (Array array, int index, int length, object value, System.Collections.IComparer comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 BinarySearch(class System.Array array, int32 index, int32 length, object value, class System.Collections.IComparer comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.BinarySearch(System.Array,System.Int32,System.Int32,System.Object,System.Collections.IComparer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int BinarySearch(Array ^ array, int index, int length, System::Object ^ value, System::Collections::IComparer ^ comparer);" />
      <MemberSignature Language="F#" Value="static member BinarySearch : Array * int * int * obj * System.Collections.IComparer -&gt; int" Usage="System.Array.BinarySearch (array, index, length, value, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="comparer" Type="System.Collections.IComparer" />
      </Parameters>
      <Docs>
        <param name="array">Matriz <see cref="T:System.Array" /> unidimensional y ordenada en la que se va a realizar la búsqueda.</param>
        <param name="index">Índice inicial del intervalo en el que se va a buscar.</param>
        <param name="length">Longitud del intervalo en el que se va a buscar.</param>
        <param name="value">Objeto que se va a buscar.</param>
        <param name="comparer">Implementación de <see cref="T:System.Collections.IComparer" /> que se va a usar al comparar elementos.  
  
O bien 
 <see langword="null" /> para usar la implementación de <see cref="T:System.IComparable" /> de cada elemento.</param>
        <summary>Busca un valor en un intervalo de elementos de una matriz unidimensional y ordenada, usando la interfaz <see cref="T:System.Collections.IComparer" /> especificada.</summary>
        <returns>Índice del elemento <paramref name="value" /> especificado en el objeto <paramref name="array" /> especificado, si se encuentra <paramref name="value" />; en caso contrario, un número negativo. Si no se encuentra <paramref name="value" /> y <paramref name="value" /> es menor que uno o varios elementos de <paramref name="array" />, el número negativo devuelto es el complemento bit a bit del índice del primer elemento que sea mayor que <paramref name="value" />. Si no se encuentra <paramref name="value" /> y <paramref name="value" /> es mayor que cualquiera de los elementos de <paramref name="array" />, el número negativo devuelto es el complemento bit a bit del índice del último elemento más 1. Si se llama a este método con un objeto <paramref name="array" /> sin clasificar, el valor devuelto puede ser incorrecto y podría devolverse un número negativo, aunque <paramref name="value" /> esté presente en <paramref name="array" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método no es compatible con Buscar en matrices que contienen índices negativo. `array` deben estar ordenados antes de llamar a este método.  
  
 Si el <xref:System.Array> no contiene el valor especificado, el método devuelve un entero negativo. Puede aplicar el operador de complemento bit a bit (~ en C#, `Not` en Visual Basic) al resultado negativo para generar un índice. Si este índice es uno mayor que el límite superior de la matriz, hay ningún elemento mayor que `value` en la matriz. De lo contrario, es el índice del primer elemento que es mayor que `value`.  
  
 El comparador personaliza cómo se comparan los elementos. Por ejemplo, puede usar un <xref:System.Collections.CaseInsensitiveComparer?displayProperty=nameWithType> como comparador para realizar búsquedas de cadenas entre mayúsculas y minúsculas.  
  
 Si `comparer` no `null`, los elementos de `array` se comparan con el valor especificado mediante especificado <xref:System.Collections.IComparer> implementación. Los elementos de `array` ya deben estar ordenados al aumentar el valor según el criterio de ordenación definido por `comparer`; en caso contrario, el resultado puede ser incorrecto.  
  
 Si `comparer` es `null`, la comparación se realiza mediante el <xref:System.IComparable> implementación proporcionada por el propio elemento o el valor especificado. Los elementos de `array` ya deben estar ordenados al aumentar el valor según el criterio de ordenación definido por el <xref:System.IComparable> implementación; de lo contrario, el resultado puede ser incorrecto.  
  
> [!NOTE]
>  Si `comparer` es `null` y `value` no implementa la <xref:System.IComparable> interfaz, los elementos de `array` no se han probado para <xref:System.IComparable> antes de que comience la búsqueda. Se produce una excepción si la búsqueda encuentra un elemento que no implementa <xref:System.IComparable>.  
  
 Se permiten elementos duplicados. Si el <xref:System.Array> contiene más de un elemento igual a `value`, el método devuelve el índice de solo una de las coincidencias y no necesariamente la primera de ellas.  
  
 `null` siempre puede compararse con cualquier otro tipo de referencia; por lo tanto, las comparaciones con `null` no generan una excepción cuando se usa <xref:System.IComparable>.  
  
> [!NOTE]
>  Para cada elemento probado, `value` se pasa a la correspondiente <xref:System.IComparable> implementación, incluso si `value` es `null`. Es decir, el <xref:System.IComparable> implementación determina cómo se compara con un elemento determinado `null`.  
  
 Este método es O (log `n`) operación, donde `n` es `length`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El valor de <paramref name="array" /> es <see langword="null" />.</exception>
        <exception cref="T:System.RankException">
          <paramref name="array" /> es multidimensional.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> es menor que el límite inferior de <paramref name="array" />.  
  
O bien 
 <paramref name="length" /> es menor que cero.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="index" /> y <paramref name="length" /> no especifican un intervalo válido en <paramref name="array" />.  
  
O bien 
 <paramref name="comparer" /> es <see langword="null" />, y <paramref name="value" /> es de un tipo que no es compatible con los elementos de <paramref name="array" />.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="comparer" /> es <see langword="null" />, <paramref name="value" /> no implementa la interfaz <see cref="T:System.IComparable" /> y la búsqueda encuentra un elemento que no implementa la interfaz <see cref="T:System.IComparable" />.</exception>
        <altmember cref="T:System.Collections.IComparer" />
        <altmember cref="T:System.IComparable" />
        <altmember cref="Overload:System.Array.Sort" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">Realizar operaciones de cadenas que no tienen en cuenta las referencias culturales en matrices</related>
      </Docs>
    </Member>
    <Member MemberName="BinarySearch&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int BinarySearch&lt;T&gt; (T[] array, T value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 BinarySearch&lt;T&gt;(!!T[] array, !!T value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.BinarySearch``1(``0[],``0)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function BinarySearch(Of T) (array As T(), value As T) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static int BinarySearch(cli::array &lt;T&gt; ^ array, T value);" />
      <MemberSignature Language="F#" Value="static member BinarySearch : 'T[] * 'T -&gt; int" Usage="System.Array.BinarySearch (array, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="value" Type="T" />
      </Parameters>
      <Docs>
        <typeparam name="T">Tipo de los elementos de la matriz.</typeparam>
        <param name="array">
          <see cref="T:System.Array" /> unidimensional ordenada de base cero en la que se va a realizar la búsqueda.</param>
        <param name="value">Objeto que se va a buscar.</param>
        <summary>Busca un elemento específico en una matriz unidimensional ordenada completa, usando la interfaz genérica <see cref="T:System.IComparable`1" /> que implementan cada elemento de <see cref="T:System.Array" /> y el objeto especificado.</summary>
        <returns>Índice del elemento <paramref name="value" /> especificado en el objeto <paramref name="array" /> especificado, si se encuentra <paramref name="value" />; en caso contrario, un número negativo. Si no se encuentra <paramref name="value" /> y <paramref name="value" /> es menor que uno o varios elementos de <paramref name="array" />, el número negativo devuelto es el complemento bit a bit del índice del primer elemento que sea mayor que <paramref name="value" />. Si no se encuentra <paramref name="value" /> y <paramref name="value" /> es mayor que cualquiera de los elementos de <paramref name="array" />, el número negativo devuelto es el complemento bit a bit del índice del último elemento más 1. Si se llama a este método con un objeto <paramref name="array" /> sin clasificar, el valor devuelto puede ser incorrecto y podría devolverse un número negativo, aunque <paramref name="value" /> esté presente en <paramref name="array" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método no es compatible con Buscar en matrices que contienen índices negativo. `array` deben estar ordenados antes de llamar a este método.  
  
 Si `array` no contiene el valor especificado, el método devuelve un entero negativo. Puede aplicar el operador de complemento bit a bit (~ en C#, `Not` en Visual Basic) al resultado negativo para generar un índice. Si este índice es igual al tamaño de la matriz, no hay ningún elemento mayor que `value` en la matriz. De lo contrario, es el índice del primer elemento que es mayor que `value`.  
  
 `T` debe implementar la <xref:System.IComparable%601> interfaz genérica, que se usa para las comparaciones. Los elementos de `array` ya deben estar ordenados al aumentar el valor según el criterio de ordenación definido por el <xref:System.IComparable%601> implementación; de lo contrario, el resultado puede ser incorrecto.  
  
 Se permiten elementos duplicados. Si el <xref:System.Array> contiene más de un elemento igual a `value`, el método devuelve el índice de solo una de las coincidencias y no necesariamente la primera de ellas.  
  
 `null` siempre puede compararse con cualquier otro tipo de referencia; por lo tanto, las comparaciones con `null` no generan una excepción.  
  
> [!NOTE]
>  Para cada elemento probado, `value` se pasa a la correspondiente <xref:System.IComparable%601> implementación, incluso si `value` es `null`. Es decir, el <xref:System.IComparable%601> implementación determina cómo se compara con un elemento determinado `null`.  
  
 Este método es O (log `n`) operación, donde `n` es el <xref:System.Array.Length%2A> de `array`.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra el <xref:System.Array.Sort%60%601%28%60%600%5B%5D%29> sobrecarga del método genérico y el <xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%29> sobrecarga del método genérico. Se crea una matriz de cadenas, sin ningún orden determinado.  
  
 La matriz se muestra, ordenan y volverá a mostrar. Las matrices deben estar ordenadas para poder usar el <xref:System.Array.BinarySearch%2A> método.  
  
> [!NOTE]
>  Las llamadas a la <xref:System.Array.Sort%2A> y <xref:System.Array.BinarySearch%2A> métodos genéricos no parece diferentes de las llamadas a sus homólogas no genéricas, ya que Visual Basic, C# y C++ deducen el tipo de parámetro de tipo genérico del tipo del primer argumento. Si usas el [Ildasm.exe (Desensamblador de IL)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) para examinar el lenguaje intermedio de Microsoft (MSIL), puede ver que se llama a los métodos genéricos.  
  
 El <xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%29> sobrecarga del método genérico, a continuación, se usa para buscar dos cadenas, una que no está en la matriz y uno que es. La matriz y el valor devuelto de la <xref:System.Array.BinarySearch%2A> método se pasan a la `ShowWhere` método genérico, que muestra el valor de índice si se encuentra la cadena y, en caso contrario, los elementos de la cadena de búsqueda pudieran estar incluidos entre si estuviera en la matriz. El índice es negativo si la cadena no está en la matriz, por lo que la `ShowWhere` método toma el complemento bit a bit (el ~ operador en C# y Visual C++, `Xor`-1 en Visual Basic) para obtener el índice del primer elemento en la lista que es mayor que la búsqueda str Ing.  
  
 [!code-cpp[Array_SortSearch#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_SortSearch/cpp/source.cpp#1)]
 [!code-csharp[Array_SortSearch#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_SortSearch/cs/source.cs#1)]
 [!code-vb[Array_SortSearch#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_SortSearch/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El valor de <paramref name="array" /> es <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="T" /> no implementa la interfaz genérica <see cref="T:System.IComparable`1" />.</exception>
        <altmember cref="T:System.IComparable`1" />
        <altmember cref="Overload:System.Array.Sort" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">Realizar operaciones de cadenas que no tienen en cuenta las referencias culturales en matrices</related>
      </Docs>
    </Member>
    <Member MemberName="BinarySearch&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int BinarySearch&lt;T&gt; (T[] array, T value, System.Collections.Generic.IComparer&lt;T&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 BinarySearch&lt;T&gt;(!!T[] array, !!T value, class System.Collections.Generic.IComparer`1&lt;!!T&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.BinarySearch``1(``0[],``0,System.Collections.Generic.IComparer{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function BinarySearch(Of T) (array As T(), value As T, comparer As IComparer(Of T)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static int BinarySearch(cli::array &lt;T&gt; ^ array, T value, System::Collections::Generic::IComparer&lt;T&gt; ^ comparer);" />
      <MemberSignature Language="F#" Value="static member BinarySearch : 'T[] * 'T * System.Collections.Generic.IComparer&lt;'T&gt; -&gt; int" Usage="System.Array.BinarySearch (array, value, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="value" Type="T" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IComparer&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">Tipo de los elementos de la matriz.</typeparam>
        <param name="array">
          <see cref="T:System.Array" /> unidimensional ordenada de base cero en la que se va a realizar la búsqueda.</param>
        <param name="value">Objeto que se va a buscar.</param>
        <param name="comparer">Implementación de <see cref="T:System.Collections.Generic.IComparer`1" /> que se va a usar al comparar elementos.  
  
O bien 
 <see langword="null" /> para usar la implementación de <see cref="T:System.IComparable`1" /> de cada elemento.</param>
        <summary>Busca un valor por toda una matriz unidimensional y ordenada, usando la interfaz genérica <see cref="T:System.Collections.Generic.IComparer`1" /> especificada.</summary>
        <returns>Índice del elemento <paramref name="value" /> especificado en el objeto <paramref name="array" /> especificado, si se encuentra <paramref name="value" />; en caso contrario, un número negativo. Si no se encuentra <paramref name="value" /> y <paramref name="value" /> es menor que uno o varios elementos de <paramref name="array" />, el número negativo devuelto es el complemento bit a bit del índice del primer elemento que sea mayor que <paramref name="value" />. Si no se encuentra <paramref name="value" /> y <paramref name="value" /> es mayor que cualquiera de los elementos de <paramref name="array" />, el número negativo devuelto es el complemento bit a bit del índice del último elemento más 1. Si se llama a este método con un objeto <paramref name="array" /> sin clasificar, el valor devuelto puede ser incorrecto y podría devolverse un número negativo, aunque <paramref name="value" /> esté presente en <paramref name="array" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método no es compatible con Buscar en matrices que contienen índices negativo. `array` deben estar ordenados antes de llamar a este método.  
  
 Si el <xref:System.Array> no contiene el valor especificado, el método devuelve un entero negativo. Puede aplicar el operador de complemento bit a bit (~ en C#, `Not` en Visual Basic) al resultado negativo para generar un índice. Si este índice es igual al tamaño de la matriz, no hay ningún elemento mayor que `value` en la matriz. De lo contrario, es el índice del primer elemento que es mayor que `value`.  
  
 El comparador personaliza cómo se comparan los elementos. Por ejemplo, puede usar un <xref:System.Collections.CaseInsensitiveComparer?displayProperty=nameWithType> como comparador para realizar búsquedas de cadenas entre mayúsculas y minúsculas.  
  
 Si `comparer` no `null`, los elementos de `array` se comparan con el valor especificado mediante especificado <xref:System.Collections.Generic.IComparer%601> implementación de interfaz genérica. Los elementos de `array` ya deben estar ordenados al aumentar el valor según el criterio de ordenación definido por `comparer`; en caso contrario, el resultado puede ser incorrecto.  
  
 Si `comparer` es `null`, la comparación se realiza mediante el <xref:System.IComparable%601> implementación de interfaz genérica proporcionada por `T`. Los elementos de `array` ya deben estar ordenados al aumentar el valor según el criterio de ordenación definido por el <xref:System.IComparable%601> implementación; de lo contrario, el resultado puede ser incorrecto.  
  
> [!NOTE]
>  Si `comparer` es `null` y `value` no implementa la <xref:System.IComparable%601> interfaz genérica, los elementos de `array` no se han probado para <xref:System.IComparable%601> antes de que comience la búsqueda. Se produce una excepción si la búsqueda encuentra un elemento que no implementa <xref:System.IComparable%601>.  
  
 Se permiten elementos duplicados. Si el <xref:System.Array> contiene más de un elemento igual a `value`, el método devuelve el índice de solo una de las coincidencias y no necesariamente la primera de ellas.  
  
 `null` siempre puede compararse con cualquier otro tipo de referencia; por lo tanto, las comparaciones con `null` no generan una excepción.  
  
> [!NOTE]
>  Para cada elemento probado, `value` se pasa a la correspondiente <xref:System.IComparable%601> implementación, incluso si `value` es `null`. Es decir, el <xref:System.IComparable%601> implementación determina cómo se compara con un elemento determinado `null`.  
  
 Este método es O (log `n`) operación, donde `n` es el <xref:System.Array.Length%2A> de `array`.  
  
   
  
## Examples  
 En el ejemplo siguiente se muestra el <xref:System.Array.Sort%60%601%28%60%600%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> sobrecarga del método genérico y el <xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> sobrecarga del método genérico.  
  
 El ejemplo de código define un comparador alternativo para las cadenas, denominado `ReverseCompare`, que implementa el `IComparer<string>` (`IComparer(Of String)` en Visual Basic, `IComparer<String^>` en Visual C++) interfaz genérica. Las llamadas de comparador el <xref:System.String.CompareTo%28System.String%29> método, invertir el orden de los términos de la comparación para que las cadenas ordenen alta o baja, en lugar de bajo a alto.  
  
 La matriz se muestra, ordenan y volverá a mostrar. Las matrices deben estar ordenadas para poder usar el <xref:System.Array.BinarySearch%2A> método.  
  
> [!NOTE]
>  Las llamadas a la <xref:System.Array.Sort%60%601%28%60%600%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> y <xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> métodos genéricos no parece diferentes de las llamadas a sus homólogas no genéricas, ya que Visual Basic, C# y C++ deducen el tipo de parámetro de tipo genérico del tipo del primer argumento. Si usas el [Ildasm.exe (Desensamblador de IL)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) para examinar el lenguaje intermedio de Microsoft (MSIL), puede ver que se llama a los métodos genéricos.  
  
 El <xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> sobrecarga del método genérico, a continuación, se usa para buscar dos cadenas, una que no está en la matriz y uno que es. La matriz y el valor devuelto de la <xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> método se pasan a la `ShowWhere` método genérico, que muestra el valor de índice si se encuentra la cadena y, en caso contrario, los elementos de la cadena de búsqueda pudieran estar incluidos entre si estuviera en la matriz. El índice es negativo si la cadena no es n la matriz, por lo que la `ShowWhere` método toma el complemento bit a bit (el ~ operador en C# y Visual C++, `Xor` -1 en Visual Basic) para obtener el índice del primer elemento en la lista que es mayor que la búsqueda de Cade NG.  
  
 [!code-cpp[Array_SortSearchComparer#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_SortSearchComparer/cpp/source.cpp#1)]
 [!code-csharp[Array_SortSearchComparer#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_SortSearchComparer/cs/source.cs#1)]
 [!code-vb[Array_SortSearchComparer#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_SortSearchComparer/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El valor de <paramref name="array" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="comparer" /> es <see langword="null" />, y <paramref name="value" /> es de un tipo que no es compatible con los elementos de <paramref name="array" />.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="comparer" /> es <see langword="null" /> y <paramref name="T" /> no implementa la interfaz genérica <see cref="T:System.IComparable`1" />.</exception>
        <altmember cref="T:System.Collections.Generic.IComparer`1" />
        <altmember cref="T:System.IComparable`1" />
        <altmember cref="Overload:System.Array.Sort" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">Realizar operaciones de cadenas que no tienen en cuenta las referencias culturales en matrices</related>
      </Docs>
    </Member>
    <Member MemberName="BinarySearch&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int BinarySearch&lt;T&gt; (T[] array, int index, int length, T value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 BinarySearch&lt;T&gt;(!!T[] array, int32 index, int32 length, !!T value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.BinarySearch``1(``0[],System.Int32,System.Int32,``0)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function BinarySearch(Of T) (array As T(), index As Integer, length As Integer, value As T) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static int BinarySearch(cli::array &lt;T&gt; ^ array, int index, int length, T value);" />
      <MemberSignature Language="F#" Value="static member BinarySearch : 'T[] * int * int * 'T -&gt; int" Usage="System.Array.BinarySearch (array, index, length, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
        <Parameter Name="value" Type="T" />
      </Parameters>
      <Docs>
        <typeparam name="T">Tipo de los elementos de la matriz.</typeparam>
        <param name="array">
          <see cref="T:System.Array" /> de base cero, unidimensional y ordenada en la que se va a buscar.</param>
        <param name="index">Índice inicial del intervalo en el que se va a buscar.</param>
        <param name="length">Longitud del intervalo en el que se va a buscar.</param>
        <param name="value">Objeto que se va a buscar.</param>
        <summary>Busca un valor en un intervalo de elementos de una matriz unidimensional y ordenada, usando la interfaz genérica <see cref="T:System.IComparable`1" /> que implementan cada elemento de <see cref="T:System.Array" /> y el valor especificado.</summary>
        <returns>Índice del elemento <paramref name="value" /> especificado en el objeto <paramref name="array" /> especificado, si se encuentra <paramref name="value" />; en caso contrario, un número negativo. Si no se encuentra <paramref name="value" /> y <paramref name="value" /> es menor que uno o varios elementos de <paramref name="array" />, el número negativo devuelto es el complemento bit a bit del índice del primer elemento que sea mayor que <paramref name="value" />. Si no se encuentra <paramref name="value" /> y <paramref name="value" /> es mayor que cualquiera de los elementos de <paramref name="array" />, el número negativo devuelto es el complemento bit a bit del índice del último elemento más 1. Si se llama a este método con un objeto <paramref name="array" /> sin clasificar, el valor devuelto puede ser incorrecto y podría devolverse un número negativo, aunque <paramref name="value" /> esté presente en <paramref name="array" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método no es compatible con Buscar en matrices que contienen índices negativo. `array` deben estar ordenados antes de llamar a este método.  
  
 Si la matriz no contiene el valor especificado, el método devuelve un entero negativo. Puede aplicar el operador de complemento bit a bit (~ en C#, `Not` en Visual Basic) al resultado negativo para generar un índice. Si este índice es igual al tamaño de la matriz, no hay ningún elemento mayor que `value` en la matriz. De lo contrario, es el índice del primer elemento que es mayor que `value`.  
  
 `T` debe implementar la <xref:System.IComparable%601> interfaz genérica, que se usa para las comparaciones. Los elementos de `array` ya deben estar ordenados al aumentar el valor según el criterio de ordenación definido por el <xref:System.IComparable%601> implementación; de lo contrario, el resultado puede ser incorrecto.  
  
 Se permiten elementos duplicados. Si el <xref:System.Array> contiene más de un elemento igual a `value`, el método devuelve el índice de solo una de las coincidencias y no necesariamente la primera de ellas.  
  
 `null` siempre puede compararse con cualquier otro tipo de referencia; por lo tanto, las comparaciones con `null` no generan una excepción.  
  
> [!NOTE]
>  Para cada elemento probado, `value` se pasa a la correspondiente <xref:System.IComparable%601> implementación, incluso si `value` es `null`. Es decir, el <xref:System.IComparable%601> implementación determina cómo se compara con un elemento determinado `null`.  
  
 Este método es O (log `n`) operación, donde `n` es `length`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El valor de <paramref name="array" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> es menor que el límite inferior de <paramref name="array" />.  
  
O bien 
 <paramref name="length" /> es menor que cero.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="index" /> y <paramref name="length" /> no especifican un intervalo válido en <paramref name="array" />.  
  
O bien 
 <paramref name="value" /> es de un tipo que no es compatible con los elementos de <paramref name="array" />.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="T" /> no implementa la interfaz genérica <see cref="T:System.IComparable`1" />.</exception>
        <altmember cref="T:System.IComparable`1" />
        <altmember cref="Overload:System.Array.Sort" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">Realizar operaciones de cadenas que no tienen en cuenta las referencias culturales en matrices</related>
      </Docs>
    </Member>
    <Member MemberName="BinarySearch&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int BinarySearch&lt;T&gt; (T[] array, int index, int length, T value, System.Collections.Generic.IComparer&lt;T&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 BinarySearch&lt;T&gt;(!!T[] array, int32 index, int32 length, !!T value, class System.Collections.Generic.IComparer`1&lt;!!T&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.BinarySearch``1(``0[],System.Int32,System.Int32,``0,System.Collections.Generic.IComparer{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function BinarySearch(Of T) (array As T(), index As Integer, length As Integer, value As T, comparer As IComparer(Of T)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static int BinarySearch(cli::array &lt;T&gt; ^ array, int index, int length, T value, System::Collections::Generic::IComparer&lt;T&gt; ^ comparer);" />
      <MemberSignature Language="F#" Value="static member BinarySearch : 'T[] * int * int * 'T * System.Collections.Generic.IComparer&lt;'T&gt; -&gt; int" Usage="System.Array.BinarySearch (array, index, length, value, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
        <Parameter Name="value" Type="T" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IComparer&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">Tipo de los elementos de la matriz.</typeparam>
        <param name="array">
          <see cref="T:System.Array" /> de base cero, unidimensional y ordenada en la que se va a buscar.</param>
        <param name="index">Índice inicial del intervalo en el que se va a buscar.</param>
        <param name="length">Longitud del intervalo en el que se va a buscar.</param>
        <param name="value">Objeto que se va a buscar.</param>
        <param name="comparer">Implementación de <see cref="T:System.Collections.Generic.IComparer`1" /> que se va a usar al comparar elementos.  
  
O bien 
 <see langword="null" /> para usar la implementación de <see cref="T:System.IComparable`1" /> de cada elemento.</param>
        <summary>Busca un valor en un intervalo de elementos de una matriz unidimensional y ordenada, usando la interfaz genérica <see cref="T:System.Collections.Generic.IComparer`1" /> especificada.</summary>
        <returns>Índice del elemento <paramref name="value" /> especificado en el objeto <paramref name="array" /> especificado, si se encuentra <paramref name="value" />; en caso contrario, un número negativo. Si no se encuentra <paramref name="value" /> y <paramref name="value" /> es menor que uno o varios elementos de <paramref name="array" />, el número negativo devuelto es el complemento bit a bit del índice del primer elemento que sea mayor que <paramref name="value" />. Si no se encuentra <paramref name="value" /> y <paramref name="value" /> es mayor que cualquiera de los elementos de <paramref name="array" />, el número negativo devuelto es el complemento bit a bit del índice del último elemento más 1. Si se llama a este método con un objeto <paramref name="array" /> sin clasificar, el valor devuelto puede ser incorrecto y podría devolverse un número negativo, aunque <paramref name="value" /> esté presente en <paramref name="array" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método no es compatible con Buscar en matrices que contienen índices negativo. `array` deben estar ordenados antes de llamar a este método.  
  
 Si la matriz no contiene el valor especificado, el método devuelve un entero negativo. Puede aplicar el operador de complemento bit a bit (~ en C#, `Not` en Visual Basic) al resultado negativo para generar un índice. Si este índice es igual al tamaño de la matriz, no hay ningún elemento mayor que `value` en la matriz. De lo contrario, es el índice del primer elemento que es mayor que `value`.  
  
 El comparador personaliza cómo se comparan los elementos. Por ejemplo, puede usar un <xref:System.Collections.CaseInsensitiveComparer?displayProperty=nameWithType> como comparador para realizar búsquedas de cadenas entre mayúsculas y minúsculas.  
  
 Si `comparer` no `null`, los elementos de `array` se comparan con el valor especificado mediante especificado <xref:System.Collections.Generic.IComparer%601> implementación de interfaz genérica. Los elementos de `array` ya deben estar ordenados al aumentar el valor según el criterio de ordenación definido por `comparer`; en caso contrario, el resultado puede ser incorrecto.  
  
 Si `comparer` es `null`, la comparación se realiza mediante el <xref:System.IComparable%601> proporcionado para el tipo de implementación de interfaz genérica `T`. Los elementos de `array` ya deben estar ordenados al aumentar el valor según el criterio de ordenación definido por el <xref:System.IComparable%601> implementación; de lo contrario, el resultado puede ser incorrecto.  
  
 Se permiten elementos duplicados. Si el <xref:System.Array> contiene más de un elemento igual a `value`, el método devuelve el índice de solo una de las coincidencias y no necesariamente la primera de ellas.  
  
 `null` siempre puede compararse con cualquier otro tipo de referencia; por lo tanto, las comparaciones con `null` no generan una excepción cuando se usa <xref:System.IComparable%601>.  
  
> [!NOTE]
>  Para cada elemento probado, `value` se pasa a la correspondiente <xref:System.IComparable%601> implementación, incluso si `value` es `null`. Es decir, el <xref:System.IComparable%601> implementación determina cómo se compara con un elemento determinado `null`.  
  
 Este método es O (log `n`) operación, donde `n` es `length`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El valor de <paramref name="array" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> es menor que el límite inferior de <paramref name="array" />.  
  
O bien 
 <paramref name="length" /> es menor que cero.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="index" /> y <paramref name="length" /> no especifican un intervalo válido en <paramref name="array" />.  
  
O bien 
 <paramref name="comparer" /> es <see langword="null" />, y <paramref name="value" /> es de un tipo que no es compatible con los elementos de <paramref name="array" />.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="comparer" /> es <see langword="null" />, y <paramref name="T" /> no implementa la interfaz genérica <see cref="T:System.IComparable`1" />.</exception>
        <altmember cref="T:System.Collections.Generic.IComparer`1" />
        <altmember cref="T:System.IComparable`1" />
        <altmember cref="Overload:System.Array.Sort" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">Realizar operaciones de cadenas que no tienen en cuenta las referencias culturales en matrices</related>
      </Docs>
    </Member>
    <Member MemberName="Clear">
      <MemberSignature Language="C#" Value="public static void Clear (Array array, int index, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Clear(class System.Array array, int32 index, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Clear(System.Array,System.Int32,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Clear(Array ^ array, int index, int length);" />
      <MemberSignature Language="F#" Value="static member Clear : Array * int * int -&gt; unit" Usage="System.Array.Clear (array, index, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">La matriz cuyos elementos deben borrarse.</param>
        <param name="index">Índice inicial del intervalo de elementos que se va a borrar.</param>
        <param name="length">Número de elementos que se van a borrar.</param>
        <summary>Establece un intervalo de elementos de una matriz en el valor predeterminado de cada tipo de elemento.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método restablece cada elemento de una matriz en el valor predeterminado del tipo de elemento. Establece los elementos de tipos de referencia (incluidos <xref:System.String> elementos) a `null`y establece los elementos de tipos de valor a los valores predeterminados que se muestra en la tabla siguiente.  
  
|Tipo|Valor|  
|----------|-----------|  
|<xref:System.Boolean>|`false`|  
|Todos los tipos numéricos enteros y de punto flotante|0 (cero)|  
|<xref:System.DateTime>|<xref:System.DateTime.MinValue?displayProperty=nameWithType>|  
|Otros tipos de valor|Valor predeterminado de los campos del tipo|  
  
 El intervalo de elementos borrados se ajusta en cada fila en una matriz multidimensional.  
  
 Este método solo borra los valores de los elementos; no se eliminan los propios elementos. Una matriz tiene un tamaño fijo; por lo tanto, los elementos no pueden agregarse o quitarse.  
  
 Este método es O (`n`) operación, donde `n` es `length`.  
  
   
  
## Examples  
 En el ejemplo siguiente se usa el <xref:System.Array.Clear%2A> método para restablecer los valores enteros en una matriz unidimensional, bidimensional y tridimensional.  
  
 [!code-csharp[System.Array.Clear#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array.Clear/cs/example.cs#1)]
 [!code-vb[System.Array.Clear#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array.Clear/vb/example.vb#1)]  
  
 En el ejemplo siguiente se define un `TimeZoneTime` estructura que incluye un <xref:System.TimeZoneInfo> campo y un <xref:System.DateTimeOffset> campo. A continuación, llama el <xref:System.Array.Clear%2A> método para borrar un elemento en una matriz de dos elementos de `TimeZoneTime` valores. El método establece el valor del elemento borrado en el valor predeterminado de un <xref:System.TimeZoneInfo> objeto, que es `null`y el valor predeterminado de un <xref:System.DateTimeOffset> objeto, que es <xref:System.DateTimeOffset.MinValue?displayProperty=nameWithType>.  
  
 [!code-csharp[System.Array.Clear#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array.Clear/cs/clearstruct1.cs#2)]
 [!code-vb[System.Array.Clear#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array.Clear/vb/clearstruct1.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El valor de <paramref name="array" /> es <see langword="null" />.</exception>
        <exception cref="T:System.IndexOutOfRangeException">
          <paramref name="index" /> es menor que el límite inferior de <paramref name="array" />.  
  
O bien 
 <paramref name="length" /> es menor que cero.  
  
O bien 
La suma de <paramref name="index" /> y <paramref name="length" /> es mayor que el tamaño de <paramref name="array" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Clone">
      <MemberSignature Language="C#" Value="public object Clone ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object Clone() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Clone" />
      <MemberSignature Language="VB.NET" Value="Public Function Clone () As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ Clone();" />
      <MemberSignature Language="F#" Value="abstract member Clone : unit -&gt; obj&#xA;override this.Clone : unit -&gt; obj" Usage="array.Clone " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ICloneable.Clone</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Crea una copia superficial de la colección <see cref="T:System.Array" />.</summary>
        <returns>Copia superficial de la colección <see cref="T:System.Array" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Una copia superficial de un <xref:System.Array> sólo copia los elementos de la <xref:System.Array>, tanto si son tipos de referencia o tipos de valor, pero no copia los objetos que hacen referencia las referencias. Las referencias en el nuevo <xref:System.Array> apuntan a los mismos objetos que las referencias en el original <xref:System.Array> elija.  
  
 En cambio, una copia profunda de un <xref:System.Array> copia los elementos y todo lo que hace referencia directa o indirectamente por los elementos.  
  
 El clon es del mismo <xref:System.Type> que el original <xref:System.Array>.  
  
 Este método es O (`n`) operación, donde `n` es <xref:System.Array.Length%2A>.  
  
   
  
## Examples  
 El siguiente código de ejemplo clones un <xref:System.Globalization.CultureInfo?displayProperty=nameWithType> matriz y se muestra el comportamiento de una copia superficial.  
  
 [!code-cpp[System.Array.Clone#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array.Clone/CPP/arrayclone.cpp#1)]
 [!code-csharp[System.Array.Clone#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array.Clone/CS/arrayclone.cs#1)]
 [!code-vb[System.Array.Clone#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array.Clone/VB/arrayclone.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Array.Copy" />
        <altmember cref="M:System.Array.ConstrainedCopy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="ConstrainedCopy">
      <MemberSignature Language="C#" Value="public static void ConstrainedCopy (Array sourceArray, int sourceIndex, Array destinationArray, int destinationIndex, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void ConstrainedCopy(class System.Array sourceArray, int32 sourceIndex, class System.Array destinationArray, int32 destinationIndex, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.ConstrainedCopy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub ConstrainedCopy (sourceArray As Array, sourceIndex As Integer, destinationArray As Array, destinationIndex As Integer, length As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void ConstrainedCopy(Array ^ sourceArray, int sourceIndex, Array ^ destinationArray, int destinationIndex, int length);" />
      <MemberSignature Language="F#" Value="static member ConstrainedCopy : Array * int * Array * int * int -&gt; unit" Usage="System.Array.ConstrainedCopy (sourceArray, sourceIndex, destinationArray, destinationIndex, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceArray" Type="System.Array" />
        <Parameter Name="sourceIndex" Type="System.Int32" />
        <Parameter Name="destinationArray" Type="System.Array" />
        <Parameter Name="destinationIndex" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="sourceArray">
          <see cref="T:System.Array" /> que contiene los datos que se van a copiar.</param>
        <param name="sourceIndex">Entero de 32 bits que representa el índice de la <paramref name="sourceArray" /> en la que se empieza a copiar.</param>
        <param name="destinationArray">
          <see cref="T:System.Array" /> que recibe los datos.</param>
        <param name="destinationIndex">Entero de 32 bits que representa el índice de la <paramref name="destinationArray" /> en la que se empieza a almacenar.</param>
        <param name="length">Entero de 32 bits que representa el número de elementos que se van a copiar.</param>
        <summary>Copia un intervalo de elementos de un objeto <see cref="T:System.Array" /> a partir del índice de origen especificado y los pega en otro objeto <see cref="T:System.Array" /> a partir del índice de destino especificado.  Garantiza que se deshacen todos los cambios si la copia no se realiza de forma totalmente correcta.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El `sourceArray` y `destinationArray` parámetros deben tener el mismo número de dimensiones.  El `sourceArray` tipo debe ser igual o derivado de la `destinationArray` tipo; en caso contrario, un <xref:System.ArrayTypeMismatchException> se produce.  A diferencia de <xref:System.Array.Copy%2A>, <xref:System.Array.ConstrainedCopy%2A> comprueba la compatibilidad de los tipos de matriz antes de realizar cualquier operación.  
  
 Al copiar datos entre las matrices multidimensionales, la matriz se comporta como una matriz unidimensional larga, donde las filas (o columnas) se distribuyen conceptualmente-to-end. Por ejemplo, si una matriz tiene tres filas (o columnas) con cuatro elementos cada uno, copian seis elementos desde el principio de la matriz copiaría todos los cuatro elementos de la primera fila (o columna) y los dos primeros elementos de la segunda fila (o columna). Para empezar a copiar en el segundo elemento de la fila de terceros (o columna), `sourceIndex` debe ser el límite superior de la primera fila (o columna) y la longitud de la segunda fila (o columna) más dos.  
  
 Si `sourceArray` y `destinationArray` se superponen, este método se comporta como si los valores originales de `sourceArray` se conservaron en una ubicación temporal antes de `destinationArray` se sobrescribe.  
  
 [C++]  
  
 Este método es equivalente a la función de C o C++ estándar `memmove`, no `memcpy`.  
  
 Las matrices pueden ser matrices de tipo de referencia o matrices de tipo de valor.  Si `sourceArray` y `destinationArray` son ambas matrices de tipo de referencia o ambas matrices de tipo <xref:System.Object>, se realiza una copia superficial. Una copia superficial de un <xref:System.Array> es una nueva <xref:System.Array> que contienen referencias a los mismos elementos que el original <xref:System.Array>. Los elementos no se copian a sí mismos o cualquier cosa que hace referencia a los elementos. En cambio, una copia profunda de un <xref:System.Array> copia los elementos y todo lo que hace referencia directa o indirectamente por los elementos.  
  
 Si este método produce una excepción durante la copia, la `destinationArray` permanece sin cambios; por lo tanto, <xref:System.Array.ConstrainedCopy%2A> puede utilizarse dentro de una región de ejecución restringida (<xref:System.Runtime.ConstrainedExecution.Cer>).  
  
 Este método es O (`n`) operación, donde `n` es `length`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El valor de <paramref name="sourceArray" /> es <see langword="null" />.  
  
O bien 
 El valor de <paramref name="destinationArray" /> es <see langword="null" />.</exception>
        <exception cref="T:System.RankException">
          <paramref name="sourceArray" /> y <paramref name="destinationArray" /> tienen clasificaciones diferentes.</exception>
        <exception cref="T:System.ArrayTypeMismatchException">El tipo <paramref name="sourceArray" /> no es el mismo ni se deriva del tipo <paramref name="destinationArray" />.</exception>
        <exception cref="T:System.InvalidCastException">Al menos un elemento de <paramref name="sourceArray" /> no se puede convertir al tipo de <paramref name="destinationArray" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="sourceIndex" /> es menor que el límite inferior de la primera dimensión de <paramref name="sourceArray" />.  
  
O bien 
 <paramref name="destinationIndex" /> es menor que el límite inferior de la primera dimensión de <paramref name="destinationArray" />.  
  
O bien 
 <paramref name="length" /> es menor que cero.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="length" /> es mayor que el número de elementos desde <paramref name="sourceIndex" /> hasta el final de <paramref name="sourceArray" />.  
  
O bien 
 <paramref name="length" /> es mayor que el número de elementos desde <paramref name="destinationIndex" /> hasta el final de <paramref name="destinationArray" />.</exception>
        <altmember cref="Overload:System.Array.Copy" />
        <altmember cref="M:System.Array.Clone" />
        <altmember cref="T:System.Runtime.ConstrainedExecution.ReliabilityContractAttribute" />
        <altmember cref="T:System.Runtime.ConstrainedExecution.Cer" />
      </Docs>
    </Member>
    <Member MemberName="ConvertAll&lt;TInput,TOutput&gt;">
      <MemberSignature Language="C#" Value="public static TOutput[] ConvertAll&lt;TInput,TOutput&gt; (TInput[] array, Converter&lt;TInput,TOutput&gt; converter);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TOutput[] ConvertAll&lt;TInput, TOutput&gt;(!!TInput[] array, class System.Converter`2&lt;!!TInput, !!TOutput&gt; converter) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.ConvertAll``2(``0[],System.Converter{``0,``1})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ConvertAll(Of TInput, TOutput) (array As TInput(), converter As Converter(Of TInput, TOutput)) As TOutput()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TInput, typename TOutput&gt;&#xA; static cli::array &lt;TOutput&gt; ^ ConvertAll(cli::array &lt;TInput&gt; ^ array, Converter&lt;TInput, TOutput&gt; ^ converter);" />
      <MemberSignature Language="F#" Value="static member ConvertAll : 'Input[] * Converter&lt;'Input, 'Output&gt; -&gt; 'Output[]" Usage="System.Array.ConvertAll (array, converter)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TOutput[]</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TInput" />
        <TypeParameter Name="TOutput" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="TInput[]" />
        <Parameter Name="converter" Type="System.Converter&lt;TInput,TOutput&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TInput">Tipo de los elementos de la matriz de origen.</typeparam>
        <typeparam name="TOutput">Tipo de los elementos de la matriz de destino.</typeparam>
        <param name="array">
          <see cref="T:System.Array" /> unidimensional de base cero que se va a convertir en un tipo de destino.</param>
        <param name="converter">
          <see cref="T:System.Converter`2" /> que convierte cada elemento en otro tipo.</param>
        <summary>Convierte una matriz de un tipo en una matriz de otro tipo.</summary>
        <returns>Matriz del tipo de destino que contiene los elementos convertidos de la matriz de origen.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Converter%602> es un delegado a un método que convierte un objeto en el tipo de destino.  Los elementos de `array` individualmente se pasan a la <xref:System.Converter%602>, y los elementos convertidos se guardan en la nueva matriz.  
  
 El origen `array` permanece sin cambios.  
  
 Este método es O (`n`) operación, donde `n` es el <xref:System.Array.Length%2A> de `array`.  
  
   
  
## Examples  
 El ejemplo de código siguiente define un método denominado `PointFToPoint` que convierte un <xref:System.Drawing.PointF> estructura a un <xref:System.Drawing.Point> estructura. El ejemplo, a continuación, crea una matriz de <xref:System.Drawing.PointF> estructuras, crea un `Converter<PointF, Point>` delegar (`Converter(Of PointF, Point)` en Visual Basic) para representar el `PointFToPoint` método y pasa el delegado para el <xref:System.Array.ConvertAll%2A> método. El <xref:System.Array.ConvertAll%2A> método pasa cada elemento de la lista de entrada para el `PointFToPoint` método y coloca los elementos convertidos en una nueva lista de <xref:System.Drawing.Point> estructuras. Se muestran ambas listas.  
  
 [!code-cpp[Array_ConvertAll#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_ConvertAll/cpp/source.cpp#1)]
 [!code-csharp[Array_ConvertAll#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_ConvertAll/cs/source.cs#1)]
 [!code-vb[Array_ConvertAll#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_ConvertAll/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El valor de <paramref name="array" /> es <see langword="null" />.  
  
O bien 
 El valor de <paramref name="converter" /> es <see langword="null" />.</exception>
        <altmember cref="T:System.Converter`2" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Copy">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Copia un intervalo de elementos de una matriz <see cref="T:System.Array" /> a otra <see cref="T:System.Array" /> y realiza la conversión boxing y la conversión de tipo necesarias.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Copy">
      <MemberSignature Language="C#" Value="public static void Copy (Array sourceArray, Array destinationArray, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Copy(class System.Array sourceArray, class System.Array destinationArray, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Copy(System.Array,System.Array,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Copy (sourceArray As Array, destinationArray As Array, length As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Copy(Array ^ sourceArray, Array ^ destinationArray, int length);" />
      <MemberSignature Language="F#" Value="static member Copy : Array * Array * int -&gt; unit" Usage="System.Array.Copy (sourceArray, destinationArray, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceArray" Type="System.Array" />
        <Parameter Name="destinationArray" Type="System.Array" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="sourceArray">
          <see cref="T:System.Array" /> que contiene los datos que se van a copiar.</param>
        <param name="destinationArray">
          <see cref="T:System.Array" /> que recibe los datos.</param>
        <param name="length">Entero de 32 bits que representa el número de elementos que se van a copiar.</param>
        <summary>Copia un intervalo de elementos de una matriz <see cref="T:System.Array" /> comenzando en el primer elemento y los pega en otra matriz <see cref="T:System.Array" /> comenzando en el primer elemento. La longitud se especifica como un entero de 32 bits.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El `sourceArray` y `destinationArray` parámetros deben tener el mismo número de dimensiones. Además, `destinationArray` debe ya han dimensionada y debe tener un número suficiente de elementos para dar cabida a los datos copiados.  
  
 Al copiar datos entre las matrices multidimensionales, la matriz se comporta como una matriz unidimensional larga, donde las filas (o columnas) se distribuyen conceptualmente de extremo a extremo. Por ejemplo, si una matriz tiene tres filas (o columnas) con cuatro elementos cada uno, copian seis elementos desde el principio de la matriz copiaría todos los cuatro elementos de la primera fila (o columna) y los dos primeros elementos de la segunda fila (o columna).  
  
 Si `sourceArray` y `destinationArray` se superponen, este método se comporta como si los valores originales de `sourceArray` se conservaron en una ubicación temporal antes de `destinationArray` se sobrescribe.  
  
 [C++]  
  
 Este método es equivalente a la función de C o C++ estándar `memmove`, no `memcpy`.  
  
 Las matrices pueden ser matrices de tipo de referencia o matrices de tipo de valor. Se realiza la conversión de tipo, según sea necesario.  
  
-   Al copiar desde una matriz de tipo de referencia a una matriz de tipo de valor, cada elemento se aplica la conversión unboxing y, a continuación, se copian. Al copiar desde una matriz de tipo de valor a una matriz de tipo de referencia, cada elemento es aplicar la conversión boxing y, a continuación, se copian.  
  
-   Cuando se copian de una matriz de tipo de valor o referencia a un <xref:System.Object> matriz, un <xref:System.Object> se crea para contener cada valor o referencia y, a continuación, se copian. Al copiar desde un <xref:System.Object> matriz a una matriz de tipo de referencia o tipo de valor y la asignación no es posible, un <xref:System.InvalidCastException> se produce.  
  
-   Si `sourceArray` y `destinationArray` son ambas matrices de tipo de referencia o ambas matrices de tipo <xref:System.Object>, se realiza una copia superficial. Una copia superficial de un <xref:System.Array> es una nueva <xref:System.Array> que contienen referencias a los mismos elementos que el original <xref:System.Array>. Los elementos no se copian a sí mismos o cualquier cosa que hace referencia a los elementos. En cambio, una copia profunda de un <xref:System.Array> copia los elementos y todo lo que hace referencia directa o indirectamente por los elementos.  
  
 Un <xref:System.ArrayTypeMismatchException> se produce si las matrices son tipos incompatibles. Compatibilidad de tipo se define como sigue:  
  
-   Un tipo es compatible con sí mismo.  
  
-   Es compatible con un tipo de valor <xref:System.Object> y con un tipo de interfaz implementado por ese tipo de valor. Se considera un tipo de valor conectado a una interfaz solo si implementa esa interfaz directamente. Los tipos desconectados no son compatibles.  
  
-   Dos tipos de valor (predefinido) intrínsecos son compatibles si la copia del tipo de origen al tipo de destino es una conversión de ampliación. Una conversión de ampliación nunca pierde información, mientras que una conversión de restricción puede perder información. Por ejemplo, convertir a un entero de 32 bits con signo en un entero de 64 bits con signo es una conversión de ampliación y la conversión de un entero de 64 bits con signo en un entero de 32 bits con signo es una conversión de restricción. Para obtener más información sobre las conversiones, vea <xref:System.Convert>.  
  
-   Un tipo no intrínseco valor (definido por el usuario) es compatible sólo con sí mismo.  
  
-   Las enumeraciones tienen una conversión implícita a <xref:System.Enum> y a su tipo subyacente.  
  
 Si todos los elementos de `sourceArray` requiere una conversión inferior (por ejemplo, desde una clase base para una clase derivada o desde una interfaz a un objeto) y uno o varios elementos no se puede convertir al tipo correspondiente en `destinationArray`, un <xref:System.InvalidCastException> se produce.  
  
 Si este método produce una excepción durante la copia, el estado de `destinationArray` es indefinido.  
  
 Este método es O (`n`) operación, donde `n` es `length`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El valor de <paramref name="sourceArray" /> es <see langword="null" />.  
  
O bien 
 El valor de <paramref name="destinationArray" /> es <see langword="null" />.</exception>
        <exception cref="T:System.RankException">
          <paramref name="sourceArray" /> y <paramref name="destinationArray" /> tienen clasificaciones diferentes.</exception>
        <exception cref="T:System.ArrayTypeMismatchException">
          <paramref name="sourceArray" /> y <paramref name="destinationArray" /> son de tipos incompatibles.</exception>
        <exception cref="T:System.InvalidCastException">Al menos un elemento de la <paramref name="sourceArray" /> no se puede convertir al tipo de <paramref name="destinationArray" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="length" /> es menor que cero.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="length" /> es mayor que el número de elementos de <paramref name="sourceArray" />.  
  
O bien 
 <paramref name="length" /> es mayor que el número de elementos de <paramref name="destinationArray" />.</exception>
        <altmember cref="M:System.Array.ConstrainedCopy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)" />
        <altmember cref="M:System.Array.Clone" />
      </Docs>
    </Member>
    <Member MemberName="Copy">
      <MemberSignature Language="C#" Value="public static void Copy (Array sourceArray, Array destinationArray, long length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Copy(class System.Array sourceArray, class System.Array destinationArray, int64 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Copy(System.Array,System.Array,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Copy (sourceArray As Array, destinationArray As Array, length As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Copy(Array ^ sourceArray, Array ^ destinationArray, long length);" />
      <MemberSignature Language="F#" Value="static member Copy : Array * Array * int64 -&gt; unit" Usage="System.Array.Copy (sourceArray, destinationArray, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceArray" Type="System.Array" />
        <Parameter Name="destinationArray" Type="System.Array" />
        <Parameter Name="length" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="sourceArray">
          <see cref="T:System.Array" /> que contiene los datos que se van a copiar.</param>
        <param name="destinationArray">
          <see cref="T:System.Array" /> que recibe los datos.</param>
        <param name="length">Entero de 64 bits que representa el número de elementos que se van a copiar. El entero debe estar entre cero y <see cref="F:System.Int32.MaxValue" />, ambos inclusive.</param>
        <summary>Copia un intervalo de elementos de una matriz <see cref="T:System.Array" /> comenzando en el primer elemento y los pega en otra matriz <see cref="T:System.Array" /> comenzando en el primer elemento. La longitud se especifica como un entero de 64 bits.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El `sourceArray` y `destinationArray` parámetros deben tener el mismo número de dimensiones. Además, `destinationArray` debe ya han dimensionada y debe tener un número suficiente de elementos para dar cabida a los datos copiados.  
  
 Al copiar datos entre las matrices multidimensionales, la matriz se comporta como una matriz unidimensional larga, donde las filas (o columnas) se distribuyen conceptualmente de extremo a extremo. Por ejemplo, si una matriz tiene tres filas (o columnas) con cuatro elementos cada uno, copian seis elementos desde el principio de la matriz copiaría todos los cuatro elementos de la primera fila (o columna) y los dos primeros elementos de la segunda fila (o columna).  
  
 Si `sourceArray` y `destinationArray` se superponen, este método se comporta como si los valores originales de `sourceArray` se conservaron en una ubicación temporal antes de `destinationArray` se sobrescribe.  
  
 [C++]  
  
 Este método es equivalente a la función de C o C++ estándar `memmove`, no `memcpy`.  
  
 Las matrices pueden ser matrices de tipo de referencia o matrices de tipo de valor. Se realiza la conversión de tipo, según sea necesario.  
  
-   Al copiar desde una matriz de tipo de referencia a una matriz de tipo de valor, cada elemento se aplica la conversión unboxing y, a continuación, se copian. Al copiar desde una matriz de tipo de valor a una matriz de tipo de referencia, cada elemento es aplicar la conversión boxing y, a continuación, se copian.  
  
-   Cuando se copian de una matriz de tipo de valor o referencia a un <xref:System.Object> matriz, un <xref:System.Object> se crea para contener cada valor o referencia y, a continuación, se copian. Al copiar desde un <xref:System.Object> matriz a una matriz de tipo de referencia o tipo de valor y la asignación no es posible, un <xref:System.InvalidCastException> se produce.  
  
-   Si `sourceArray` y `destinationArray` son ambas matrices de tipo de referencia o ambas matrices de tipo <xref:System.Object>, se realiza una copia superficial. Una copia superficial de un <xref:System.Array> es una nueva <xref:System.Array> que contienen referencias a los mismos elementos que el original <xref:System.Array>. Los elementos no se copian a sí mismos o cualquier cosa que hace referencia a los elementos. En cambio, una copia profunda de un <xref:System.Array> copia los elementos y todo lo que hace referencia directa o indirectamente por los elementos.  
  
 Un <xref:System.ArrayTypeMismatchException> se produce si las matrices son tipos incompatibles. Compatibilidad de tipo se define como sigue:  
  
-   Un tipo es compatible con sí mismo.  
  
-   Es compatible con un tipo de valor <xref:System.Object> y con un tipo de interfaz implementado por ese tipo de valor. Se considera un tipo de valor conectado a una interfaz solo si implementa esa interfaz directamente. Los tipos desconectados no son compatibles.  
  
-   Dos tipos de valor (predefinido) intrínsecos son compatibles si la copia del tipo de origen al tipo de destino es una conversión de ampliación. Una conversión de ampliación nunca pierde información, mientras que una conversión de restricción puede perder información. Por ejemplo, convertir a un entero de 32 bits con signo en un entero de 64 bits con signo es una conversión de ampliación y la conversión de un entero de 64 bits con signo en un entero de 32 bits con signo es una conversión de restricción. Para obtener más información sobre las conversiones, vea <xref:System.Convert>.  
  
-   Un tipo no intrínseco valor (definido por el usuario) es compatible sólo con sí mismo.  
  
-   Las enumeraciones tienen una conversión implícita a <xref:System.Enum> y a su tipo subyacente.  
  
 Si todos los elementos de `sourceArray` requiere una conversión inferior (por ejemplo, desde una clase base para una clase derivada o desde una interfaz a un objeto) y uno o varios elementos no se puede convertir al tipo correspondiente en `destinationArray`, un <xref:System.InvalidCastException> se produce.  
  
 Si este método produce una excepción durante la copia, el estado de `destinationArray` es indefinido.  
  
 Este método es O (`n`) operación, donde `n` es `length`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El valor de <paramref name="sourceArray" /> es <see langword="null" />.  
  
O bien 
 El valor de <paramref name="destinationArray" /> es <see langword="null" />.</exception>
        <exception cref="T:System.RankException">
          <paramref name="sourceArray" /> y <paramref name="destinationArray" /> tienen clasificaciones diferentes.</exception>
        <exception cref="T:System.ArrayTypeMismatchException">
          <paramref name="sourceArray" /> y <paramref name="destinationArray" /> son de tipos incompatibles.</exception>
        <exception cref="T:System.InvalidCastException">Al menos un elemento de <paramref name="sourceArray" /> no se puede convertir al tipo de <paramref name="destinationArray" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="length" /> es menor que 0 o mayor que <see cref="F:System.Int32.MaxValue" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="length" /> es mayor que el número de elementos de <paramref name="sourceArray" />.  
  
O bien 
 <paramref name="length" /> es mayor que el número de elementos de <paramref name="destinationArray" />.</exception>
        <altmember cref="M:System.Array.ConstrainedCopy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)" />
        <altmember cref="M:System.Array.Clone" />
      </Docs>
    </Member>
    <Member MemberName="Copy">
      <MemberSignature Language="C#" Value="public static void Copy (Array sourceArray, int sourceIndex, Array destinationArray, int destinationIndex, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Copy(class System.Array sourceArray, int32 sourceIndex, class System.Array destinationArray, int32 destinationIndex, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Copy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Copy (sourceArray As Array, sourceIndex As Integer, destinationArray As Array, destinationIndex As Integer, length As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Copy(Array ^ sourceArray, int sourceIndex, Array ^ destinationArray, int destinationIndex, int length);" />
      <MemberSignature Language="F#" Value="static member Copy : Array * int * Array * int * int -&gt; unit" Usage="System.Array.Copy (sourceArray, sourceIndex, destinationArray, destinationIndex, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceArray" Type="System.Array" />
        <Parameter Name="sourceIndex" Type="System.Int32" />
        <Parameter Name="destinationArray" Type="System.Array" />
        <Parameter Name="destinationIndex" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="sourceArray">
          <see cref="T:System.Array" /> que contiene los datos que se van a copiar.</param>
        <param name="sourceIndex">Entero de 32 bits que representa el índice de la <paramref name="sourceArray" /> en la que se empieza a copiar.</param>
        <param name="destinationArray">
          <see cref="T:System.Array" /> que recibe los datos.</param>
        <param name="destinationIndex">Entero de 32 bits que representa el índice de la <paramref name="destinationArray" /> en la que se empieza a almacenar.</param>
        <param name="length">Entero de 32 bits que representa el número de elementos que se van a copiar.</param>
        <summary>Copia un intervalo de elementos de un objeto <see cref="T:System.Array" /> a partir del índice de origen especificado y los pega en otro objeto <see cref="T:System.Array" /> a partir del índice de destino especificado. La longitud y los índices se especifican como enteros de 32 bits.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El `sourceArray` y `destinationArray` parámetros deben tener el mismo número de dimensiones. Además, `destinationArray` debe ya han dimensionada y debe tener un número suficiente de elementos a partir de la `destinationIndex` posición para dar cabida a los datos copiados.  
  
 Al copiar datos entre las matrices multidimensionales, la matriz se comporta como una matriz unidimensional larga, donde las filas (o columnas) se distribuyen conceptualmente-to-end. Por ejemplo, si una matriz tiene tres filas (o columnas) con cuatro elementos cada uno, copian seis elementos desde el principio de la matriz copiaría todos los cuatro elementos de la primera fila (o columna) y los dos primeros elementos de la segunda fila (o columna). Para empezar a copiar en el segundo elemento de la fila de terceros (o columna), `sourceIndex` debe ser el límite superior de la primera fila (o columna) y la longitud de la segunda fila (o columna) más dos.  
  
 Si `sourceArray` y `destinationArray` se superponen, este método se comporta como si los valores originales de `sourceArray` se conservaron en una ubicación temporal antes de `destinationArray` se sobrescribe.  
  
 [C++]  
  
 Este método es equivalente a la función de C o C++ estándar `memmove`, no `memcpy`.  
  
 Las matrices pueden ser matrices de tipo de referencia o matrices de tipo de valor. Se realiza la conversión de tipo, según sea necesario.  
  
-   Al copiar desde una matriz de tipo de referencia a una matriz de tipo de valor, cada elemento se aplica la conversión unboxing y, a continuación, se copian. Al copiar desde una matriz de tipo de valor a una matriz de tipo de referencia, cada elemento es aplicar la conversión boxing y, a continuación, se copian.  
  
-   Cuando se copian de una matriz de tipo de valor o referencia a un <xref:System.Object> matriz, un <xref:System.Object> se crea para contener cada valor o referencia y, a continuación, se copian. Al copiar desde un <xref:System.Object> matriz a una matriz de tipo de referencia o tipo de valor y la asignación no es posible, un <xref:System.InvalidCastException> se produce.  
  
-   Si `sourceArray` y `destinationArray` son ambas matrices de tipo de referencia o ambas matrices de tipo <xref:System.Object>, se realiza una copia superficial. Una copia superficial de un <xref:System.Array> es una nueva <xref:System.Array> que contienen referencias a los mismos elementos que el original <xref:System.Array>. Los elementos no se copian a sí mismos o cualquier cosa que hace referencia a los elementos. En cambio, una copia profunda de un <xref:System.Array> copia los elementos y todo lo que hace referencia directa o indirectamente por los elementos.  
  
 Un <xref:System.ArrayTypeMismatchException> se produce si las matrices son tipos incompatibles. Compatibilidad de tipo se define como sigue:  
  
-   Un tipo es compatible con sí mismo.  
  
-   Es compatible con un tipo de valor <xref:System.Object> y con un tipo de interfaz implementado por ese tipo de valor. Se considera un tipo de valor conectado a una interfaz solo si implementa esa interfaz directamente. Los tipos desconectados no son compatibles.  
  
-   Dos tipos de valor (predefinido) intrínsecos son compatibles si la copia del tipo de origen al tipo de destino es una conversión de ampliación. Una conversión de ampliación nunca pierde información, mientras que una conversión de restricción puede perder información. Por ejemplo, convertir a un entero de 32 bits con signo en un entero de 64 bits con signo es una conversión de ampliación y la conversión de un entero de 64 bits con signo en un entero de 32 bits con signo es una conversión de restricción. Para obtener más información sobre las conversiones, vea <xref:System.Convert>.  
  
-   Un tipo no intrínseco valor (definido por el usuario) es compatible sólo con sí mismo.  
  
-   Las enumeraciones tienen una conversión implícita a <xref:System.Enum> y a su tipo subyacente.  
  
 Si todos los elementos de `sourceArray` requiere una conversión inferior (por ejemplo, desde una clase base para una clase derivada o desde una interfaz a un objeto) y uno o varios elementos no se puede convertir al tipo correspondiente en `destinationArray`, un <xref:System.InvalidCastException> se produce.  
  
 Si este método produce una excepción durante la copia, el estado de `destinationArray` es indefinido.  
  
 Este método es O (`n`) operación, donde `n` es `length`.  
  
   
  
## Examples  
 El ejemplo de código siguiente muestra cómo copiar desde una <xref:System.Array> typu <xref:System.Object> a otro <xref:System.Array> de tipo entero.  
  
 [!code-cpp[Classic Array.Copy1 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.Copy1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.Copy1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.Copy1 Example/CS/source.cs#1)]
 [!code-vb[Classic Array.Copy1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.Copy1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El valor de <paramref name="sourceArray" /> es <see langword="null" />.  
  
O bien 
 El valor de <paramref name="destinationArray" /> es <see langword="null" />.</exception>
        <exception cref="T:System.RankException">
          <paramref name="sourceArray" /> y <paramref name="destinationArray" /> tienen clasificaciones diferentes.</exception>
        <exception cref="T:System.ArrayTypeMismatchException">
          <paramref name="sourceArray" /> y <paramref name="destinationArray" /> son de tipos incompatibles.</exception>
        <exception cref="T:System.InvalidCastException">Al menos un elemento de <paramref name="sourceArray" /> no se puede convertir en el tipo de <paramref name="destinationArray" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="sourceIndex" /> es menor que el límite inferior de la primera dimensión de <paramref name="sourceArray" />.  
  
O bien 
 <paramref name="destinationIndex" /> es menor que el límite inferior de la primera dimensión de <paramref name="destinationArray" />.  
  
O bien 
 <paramref name="length" /> es menor que cero.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="length" /> es mayor que el número de elementos desde <paramref name="sourceIndex" /> hasta el final de <paramref name="sourceArray" />.  
  
O bien 
 <paramref name="length" /> es mayor que el número de elementos desde <paramref name="destinationIndex" /> hasta el final de <paramref name="destinationArray" />.</exception>
        <altmember cref="M:System.Array.ConstrainedCopy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)" />
        <altmember cref="M:System.Array.Clone" />
      </Docs>
    </Member>
    <Member MemberName="Copy">
      <MemberSignature Language="C#" Value="public static void Copy (Array sourceArray, long sourceIndex, Array destinationArray, long destinationIndex, long length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Copy(class System.Array sourceArray, int64 sourceIndex, class System.Array destinationArray, int64 destinationIndex, int64 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Copy(System.Array,System.Int64,System.Array,System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Copy (sourceArray As Array, sourceIndex As Long, destinationArray As Array, destinationIndex As Long, length As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Copy(Array ^ sourceArray, long sourceIndex, Array ^ destinationArray, long destinationIndex, long length);" />
      <MemberSignature Language="F#" Value="static member Copy : Array * int64 * Array * int64 * int64 -&gt; unit" Usage="System.Array.Copy (sourceArray, sourceIndex, destinationArray, destinationIndex, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceArray" Type="System.Array" />
        <Parameter Name="sourceIndex" Type="System.Int64" />
        <Parameter Name="destinationArray" Type="System.Array" />
        <Parameter Name="destinationIndex" Type="System.Int64" />
        <Parameter Name="length" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="sourceArray">
          <see cref="T:System.Array" /> que contiene los datos que se van a copiar.</param>
        <param name="sourceIndex">Entero de 64 bits que representa el índice de <paramref name="sourceArray" /> donde comienza la copia.</param>
        <param name="destinationArray">
          <see cref="T:System.Array" /> que recibe los datos.</param>
        <param name="destinationIndex">Entero de 64 bits que representa el índice de <paramref name="destinationArray" /> donde comienza el almacenamiento.</param>
        <param name="length">Entero de 64 bits que representa el número de elementos que se van a copiar. El entero debe estar entre cero y <see cref="F:System.Int32.MaxValue" />, ambos inclusive.</param>
        <summary>Copia un intervalo de elementos de un objeto <see cref="T:System.Array" /> a partir del índice de origen especificado y los pega en otro objeto <see cref="T:System.Array" /> a partir del índice de destino especificado. La longitud y los índices se especifican como enteros de 64 bits.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El `sourceArray` y `destinationArray` parámetros deben tener el mismo número de dimensiones. Además, `destinationArray` debe ya han dimensionada y debe tener un número suficiente de elementos a partir de la `destinationIndex` posición para dar cabida a los datos copiados.  
  
 Al copiar datos entre las matrices multidimensionales, la matriz se comporta como una matriz unidimensional larga, donde las filas (o columnas) se distribuyen conceptualmente-to-end. Por ejemplo, si una matriz tiene tres filas (o columnas) con cuatro elementos cada uno, copian seis elementos desde el principio de la matriz copiaría todos los cuatro elementos de la primera fila (o columna) y los dos primeros elementos de la segunda fila (o columna). Para empezar a copiar en el segundo elemento de la fila de terceros (o columna), `sourceIndex` debe ser el límite superior de la primera fila (o columna) y la longitud de la segunda fila (o columna) más dos.  
  
 Si `sourceArray` y `destinationArray` se superponen, este método se comporta como si los valores originales de `sourceArray` se conservaron en una ubicación temporal antes de `destinationArray` se sobrescribe.  
  
 [C++]  
  
 Este método es equivalente a la función de C o C++ estándar `memmove`, no `memcpy`.  
  
 Las matrices pueden ser matrices de tipo de referencia o matrices de tipo de valor. Se realiza la conversión de tipo, según sea necesario.  
  
-   Al copiar desde una matriz de tipo de referencia a una matriz de tipo de valor, cada elemento se aplica la conversión unboxing y, a continuación, se copian. Al copiar desde una matriz de tipo de valor a una matriz de tipo de referencia, cada elemento es aplicar la conversión boxing y, a continuación, se copian.  
  
-   Cuando se copian de una matriz de tipo de valor o referencia a un <xref:System.Object> matriz, un <xref:System.Object> se crea para contener cada valor o referencia y, a continuación, se copian. Al copiar desde un <xref:System.Object> matriz a una matriz de tipo de referencia o tipo de valor y la asignación no es posible, un <xref:System.InvalidCastException> se produce.  
  
-   Si `sourceArray` y `destinationArray` son ambas matrices de tipo de referencia o ambas matrices de tipo <xref:System.Object>, se realiza una copia superficial. Una copia superficial de un <xref:System.Array> es una nueva <xref:System.Array> que contienen referencias a los mismos elementos que el original <xref:System.Array>. Los elementos no se copian a sí mismos o cualquier cosa que hace referencia a los elementos. En cambio, una copia profunda de un <xref:System.Array> copia los elementos y todo lo que hace referencia directa o indirectamente por los elementos.  
  
 Un <xref:System.ArrayTypeMismatchException> se produce si las matrices son tipos incompatibles. Compatibilidad de tipo se define como sigue:  
  
-   Un tipo es compatible con sí mismo.  
  
-   Es compatible con un tipo de valor <xref:System.Object> y con un tipo de interfaz implementado por ese tipo de valor. Se considera un tipo de valor conectado a una interfaz solo si implementa esa interfaz directamente. Los tipos desconectados no son compatibles.  
  
-   Dos tipos de valor (predefinido) intrínsecos son compatibles si la copia del tipo de origen al tipo de destino es una conversión de ampliación. Una conversión de ampliación nunca pierde información, mientras que una conversión de restricción puede perder información. Por ejemplo, convertir a un entero de 32 bits con signo en un entero de 64 bits con signo es una conversión de ampliación y la conversión de un entero de 64 bits con signo en un entero de 32 bits con signo es una conversión de restricción. Para obtener más información sobre las conversiones, vea <xref:System.Convert>.  
  
-   Un tipo no intrínseco valor (definido por el usuario) es compatible sólo con sí mismo.  
  
-   Las enumeraciones tienen una conversión implícita a <xref:System.Enum> y a su tipo subyacente.  
  
 Si todos los elementos de `sourceArray` requiere una conversión inferior (por ejemplo, desde una clase base para una clase derivada o desde una interfaz a un objeto) y uno o varios elementos no se puede convertir al tipo correspondiente en `destinationArray`, un <xref:System.InvalidCastException> se produce.  
  
 Si este método produce una excepción durante la copia, el estado de `destinationArray` es indefinido.  
  
 Este método es O (`n`) operación, donde `n` es `length`.  
  
   
  
## Examples  
 El ejemplo de código siguiente muestra cómo copiar desde una <xref:System.Array> typu <xref:System.Object> a otro <xref:System.Array> de tipo entero.  
  
 [!code-cpp[Classic Array.Copy1 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.Copy1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.Copy1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.Copy1 Example/CS/source.cs#1)]
 [!code-vb[Classic Array.Copy1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.Copy1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El valor de <paramref name="sourceArray" /> es <see langword="null" />.  
  
O bien 
 El valor de <paramref name="destinationArray" /> es <see langword="null" />.</exception>
        <exception cref="T:System.RankException">
          <paramref name="sourceArray" /> y <paramref name="destinationArray" /> tienen clasificaciones diferentes.</exception>
        <exception cref="T:System.ArrayTypeMismatchException">
          <paramref name="sourceArray" /> y <paramref name="destinationArray" /> son de tipos incompatibles.</exception>
        <exception cref="T:System.InvalidCastException">Al menos un elemento de <paramref name="sourceArray" /> no se puede convertir al tipo de <paramref name="destinationArray" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="sourceIndex" /> está fuera del intervalo de índices válidos para <paramref name="sourceArray" />.  
  
O bien 
 <paramref name="destinationIndex" /> está fuera del intervalo de índices válidos para <paramref name="destinationArray" />.  
  
O bien 
 <paramref name="length" /> es menor que 0 o mayor que <see cref="F:System.Int32.MaxValue" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="length" /> es mayor que el número de elementos desde <paramref name="sourceIndex" /> hasta el final de <paramref name="sourceArray" />.  
  
O bien 
 <paramref name="length" /> es mayor que el número de elementos desde <paramref name="destinationIndex" /> hasta el final de <paramref name="destinationArray" />.</exception>
        <altmember cref="M:System.Array.ConstrainedCopy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)" />
        <altmember cref="M:System.Array.Clone" />
      </Docs>
    </Member>
    <MemberGroup MemberName="CopyTo">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Copia todos los elementos de la matriz unidimensional actual en la matriz unidimensional especificada.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public void CopyTo (Array array, int index);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void CopyTo(class System.Array array, int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.CopyTo(System.Array,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void CopyTo(Array ^ array, int index);" />
      <MemberSignature Language="F#" Value="abstract member CopyTo : Array * int -&gt; unit&#xA;override this.CopyTo : Array * int -&gt; unit" Usage="array.CopyTo (array, index)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.ICollection.CopyTo(System.Array,System.Int32)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">Matriz unidimensional que constituye el destino de los elementos copiados desde la matriz actual.</param>
        <param name="index">Entero de 32 bits que representa el índice de <paramref name="array" /> donde comienza la copia.</param>
        <summary>Copia todos los elementos de la matriz unidimensional actual en la matriz unidimensional especificada, empezando en el índice especificado de la matriz de destino. El índice se especifica como un entero de 32 bits.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método copia todos los elementos de la instancia actual de la matriz a la `array` matriz de destino, comenzando en el índice `index`. El `array` matriz de destino debe ya han dimensionada y debe tener un número suficiente de elementos para dar cabida a los elementos copiados. De lo contrario, el método produce una excepción.  
  
 Este método admite la <xref:System.Collections.ICollection?displayProperty=nameWithType> interfaz. Si implementa <xref:System.Collections.ICollection?displayProperty=nameWithType> es explícitamente no es necesario, utilice <xref:System.Array.Copy%2A> para evitar un direccionamiento indirecto adicional.  
  
 Si este método produce una excepción durante la copia, el estado de `array` es indefinido.  
  
 Este método es O (`n`) operación, donde `n` es <xref:System.Array.Length%2A>. Realiza solo una copia superficial.  
  
   
  
## Examples  
 El ejemplo de código siguiente muestra cómo copiar un <xref:System.Array> a otro <xref:System.Array>.  
  
 [!code-cpp[Classic Array.CopyTo Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.CopyTo Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.CopyTo Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.CopyTo Example/CS/source.cs#1)]
 [!code-vb[Classic Array.CopyTo Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.CopyTo Example/VB/source.vb#1)]  
  
 El ejemplo de código siguiente muestra cómo copiar un <xref:System.Array> a otro <xref:System.Array> con un límite inferior distinto de cero. Tenga en cuenta que el código fuente completo <xref:System.Array> se copian, incluidos los elementos vacíos que sobrescriben los elementos existentes en el destino <xref:System.Array>.  
  
 [!code-cpp[Classic Array.CopyTo Example#2](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.CopyTo Example/CPP/source.cpp#2)]
 [!code-csharp[Classic Array.CopyTo Example#2](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.CopyTo Example/CS/source.cs#2)]
 [!code-vb[Classic Array.CopyTo Example#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.CopyTo Example/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El valor de <paramref name="array" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> es menor que el límite inferior de <paramref name="array" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="array" /> es multidimensional.  
  
O bien 
El número de elementos de la matriz de origen es mayor que el número de elementos disponible desde  <paramref name="index" /> hasta el final de la <paramref name="array" /> de destino.</exception>
        <exception cref="T:System.ArrayTypeMismatchException">El tipo de la <see cref="T:System.Array" /> de origen no puede convertirse automáticamente al tipo de la <paramref name="array" /> de destino.</exception>
        <exception cref="T:System.RankException">La matriz de origen es multidimensional.</exception>
        <exception cref="T:System.InvalidCastException">Al menos un elemento de la <see cref="T:System.Array" /> de origen no se puede convertir al tipo de <paramref name="array" /> de destino.</exception>
        <altmember cref="T:System.Collections.ICollection" />
        <altmember cref="M:System.Array.Copy(System.Array,System.Array,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public void CopyTo (Array array, long index);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CopyTo(class System.Array array, int64 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.CopyTo(System.Array,System.Int64)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CopyTo(Array ^ array, long index);" />
      <MemberSignature Language="F#" Value="member this.CopyTo : Array * int64 -&gt; unit" Usage="array.CopyTo (array, index)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="index" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="array">Matriz unidimensional que constituye el destino de los elementos copiados desde la matriz actual.</param>
        <param name="index">Entero de 64 bits que representa el índice de <paramref name="array" /> donde comienza la copia.</param>
        <summary>Copia todos los elementos de la matriz unidimensional actual en la matriz unidimensional especificada, empezando en el índice especificado de la matriz de destino. El índice se especifica como un entero de 64 bits.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método copia todos los elementos de la instancia actual de la matriz a la `array` matriz de destino, comenzando en el índice `index`. El `array` matriz de destino debe ya han dimensionada y debe tener un número suficiente de elementos para dar cabida a los elementos copiados. De lo contrario, el método produce una excepción.  
  
 Este método admite la <xref:System.Collections.ICollection?displayProperty=nameWithType> interfaz. Si implementa <xref:System.Collections.ICollection?displayProperty=nameWithType> es explícitamente no es necesario, utilice <xref:System.Array.Copy%2A> para evitar un direccionamiento indirecto adicional.  
  
 Si este método produce una excepción durante la copia, el estado de `array` es indefinido.  
  
 Este método es O (`n`) operación, donde `n` es <xref:System.Array.Length%2A>. Realiza solo una copia superficial.  
  
   
  
## Examples  
 El ejemplo de código siguiente muestra cómo copiar un <xref:System.Array> a otro <xref:System.Array>.  
  
 [!code-cpp[Classic Array.CopyTo Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.CopyTo Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.CopyTo Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.CopyTo Example/CS/source.cs#1)]
 [!code-vb[Classic Array.CopyTo Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.CopyTo Example/VB/source.vb#1)]  
  
 El ejemplo de código siguiente muestra cómo copiar un <xref:System.Array> a otro <xref:System.Array> con un límite inferior distinto de cero. Tenga en cuenta que el código fuente completo <xref:System.Array> se copian, incluidos los elementos vacíos que sobrescriben los elementos existentes en el destino <xref:System.Array>.  
  
 [!code-cpp[Classic Array.CopyTo Example#2](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.CopyTo Example/CPP/source.cpp#2)]
 [!code-csharp[Classic Array.CopyTo Example#2](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.CopyTo Example/CS/source.cs#2)]
 [!code-vb[Classic Array.CopyTo Example#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.CopyTo Example/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El valor de <paramref name="array" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> está fuera del intervalo de índices válidos para <paramref name="array" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="array" /> es multidimensional.  
  
O bien 
El número de elementos de la matriz de origen es mayor que el número de elementos disponible desde  <paramref name="index" /> hasta el final de la <paramref name="array" /> de destino.</exception>
        <exception cref="T:System.ArrayTypeMismatchException">El tipo de la <see cref="T:System.Array" /> de origen no puede convertirse automáticamente al tipo de la <paramref name="array" /> de destino.</exception>
        <exception cref="T:System.RankException">La <see cref="T:System.Array" /> de origen es multidimensional.</exception>
        <exception cref="T:System.InvalidCastException">Al menos un elemento de la <see cref="T:System.Array" /> de origen no se puede convertir al tipo de <paramref name="array" /> de destino.</exception>
        <altmember cref="T:System.Collections.ICollection" />
        <altmember cref="M:System.Array.Copy(System.Array,System.Array,System.Int64)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateInstance">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Array" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public static Array CreateInstance (Type elementType, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Array CreateInstance(class System.Type elementType, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.CreateInstance(System.Type,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateInstance (elementType As Type, length As Integer) As Array" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Array ^ CreateInstance(Type ^ elementType, int length);" />
      <MemberSignature Language="F#" Value="static member CreateInstance : Type * int -&gt; Array" Usage="System.Array.CreateInstance (elementType, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Array</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="elementType" Type="System.Type" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="elementType">
          <see cref="T:System.Type" /> de la matriz <see cref="T:System.Array" /> que se va a crear.</param>
        <param name="length">Tamaño de la matriz <see cref="T:System.Array" /> que se va a crear.</param>
        <summary>Crea una matriz <see cref="T:System.Array" /> unidimensional de la longitud y el <see cref="T:System.Type" /> especificados, con una indización de base cero.</summary>
        <returns>Nueva matriz <see cref="T:System.Array" /> unidimensional de la longitud y el <see cref="T:System.Type" /> especificados, usando una indización de base cero.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A diferencia de la mayoría de las clases, <xref:System.Array> proporciona el <xref:System.Array.CreateInstance%2A> método, en lugar de constructores públicos, para permitir el acceso enlazado en tiempo de ejecución.  
  
 Elementos de tipo de referencia se inicializan en `null`. Elementos de tipo de valor se inicializan en cero.  
  
 Este método es O (`n`) operación, donde `n` es `length`.  
  
   
  
## Examples  
 El ejemplo de código siguiente muestra cómo crear e inicializar un unidimensional <xref:System.Array>.  
  
 [!code-cpp[Classic Array.CreateInstance Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.CreateInstance Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.CreateInstance Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.CreateInstance Example/CS/source.cs#1)]
 [!code-vb[Classic Array.CreateInstance Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.CreateInstance Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El valor de <paramref name="elementType" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="elementType" /> no es un <see cref="T:System.Type" /> válido.</exception>
        <exception cref="T:System.NotSupportedException">No se admite <paramref name="elementType" />. Por ejemplo, no se admite <see cref="T:System.Void" />.  
  
O bien 
 <paramref name="elementType" /> es un tipo genérico abierto.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="length" /> es menor que cero.</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public static Array CreateInstance (Type elementType, params int[] lengths);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Array CreateInstance(class System.Type elementType, int32[] lengths) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.CreateInstance(System.Type,System.Int32[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateInstance (elementType As Type, ParamArray lengths As Integer()) As Array" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Array ^ CreateInstance(Type ^ elementType, ... cli::array &lt;int&gt; ^ lengths);" />
      <MemberSignature Language="F#" Value="static member CreateInstance : Type * int[] -&gt; Array" Usage="System.Array.CreateInstance (elementType, lengths)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Array</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="elementType" Type="System.Type" />
        <Parameter Name="lengths" Type="System.Int32[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="elementType">
          <see cref="T:System.Type" /> de la matriz <see cref="T:System.Array" /> que se va a crear.</param>
        <param name="lengths">Matriz de enteros de 32 bits que representa el tamaño de cada una de las dimensiones de <see cref="T:System.Array" /> que se van a crear.</param>
        <summary>Crea una <see cref="T:System.Array" /> multidimensional de las longitudes de dimensión y el tipo <see cref="T:System.Type" /> especificados, con una indización de base cero. Las longitudes de dimensión se especifican en una matriz de enteros de 32 bits.</summary>
        <returns>Nueva matriz <see cref="T:System.Array" /> multidimensional del tipo <see cref="T:System.Type" /> especificado con la longitud especificada para cada dimensión, usando una indización de base cero.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A diferencia de la mayoría de las clases, <xref:System.Array> proporciona el <xref:System.Array.CreateInstance%2A> método, en lugar de constructores públicos, para permitir el acceso enlazado en tiempo de ejecución.  
  
 El número de elementos de la `lengths` matriz debe ser igual al número de dimensiones en el nuevo <xref:System.Array>. Cada elemento de la `lengths` matriz debe especificar la longitud de la dimensión correspondiente en el nuevo <xref:System.Array>.  
  
 Elementos de tipo de referencia se inicializan en `null`. Elementos de tipo de valor se inicializan en cero.  
  
 Este método es O (`n`) operación, donde `n` es el producto de todos los valores de `lengths`.  
  
   
  
## Examples  
 El ejemplo de código siguiente muestra cómo crear e inicializar multidimensional <xref:System.Array>.  
  
 [!code-cpp[Classic Array.CreateInstance3 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.CreateInstance3 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.CreateInstance3 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.CreateInstance3 Example/CS/source.cs#1)]
 [!code-vb[Classic Array.CreateInstance3 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.CreateInstance3 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El valor de <paramref name="elementType" /> es <see langword="null" />.  
  
O bien 
 El valor de <paramref name="lengths" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="elementType" /> no es un <see cref="T:System.Type" /> válido.  
  
O bien 
La matriz <paramref name="lengths" /> contiene menos de un elemento.</exception>
        <exception cref="T:System.NotSupportedException">No se admite <paramref name="elementType" />. Por ejemplo, no se admite <see cref="T:System.Void" />.  
  
O bien 
 <paramref name="elementType" /> es un tipo genérico abierto.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Cualquier valor en <paramref name="lengths" /> es menor que cero.</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public static Array CreateInstance (Type elementType, params long[] lengths);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Array CreateInstance(class System.Type elementType, int64[] lengths) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.CreateInstance(System.Type,System.Int64[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateInstance (elementType As Type, ParamArray lengths As Long()) As Array" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Array ^ CreateInstance(Type ^ elementType, ... cli::array &lt;long&gt; ^ lengths);" />
      <MemberSignature Language="F#" Value="static member CreateInstance : Type * int64[] -&gt; Array" Usage="System.Array.CreateInstance (elementType, lengths)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Array</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="elementType" Type="System.Type" />
        <Parameter Name="lengths" Type="System.Int64[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="elementType">
          <see cref="T:System.Type" /> de la matriz <see cref="T:System.Array" /> que se va a crear.</param>
        <param name="lengths">Matriz de enteros de 64 bits que representa el tamaño de cada una de las dimensiones de <see cref="T:System.Array" /> que se van a crear. Cada entero de la matriz debe estar entre cero y <see cref="F:System.Int32.MaxValue" />, ambos incluidos.</param>
        <summary>Crea una <see cref="T:System.Array" /> multidimensional de las longitudes de dimensión y el tipo <see cref="T:System.Type" /> especificados, con una indización de base cero. Las longitudes de dimensión se especifican en una matriz de enteros de 64 bits.</summary>
        <returns>Nueva matriz <see cref="T:System.Array" /> multidimensional del tipo <see cref="T:System.Type" /> especificado con la longitud especificada para cada dimensión, usando una indización de base cero.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A diferencia de la mayoría de las clases, <xref:System.Array> proporciona el <xref:System.Array.CreateInstance%2A> método, en lugar de constructores públicos, para permitir el acceso enlazado en tiempo de ejecución.  
  
 El número de elementos de la `lengths` matriz debe ser igual al número de dimensiones en el nuevo <xref:System.Array>. Cada elemento de la `lengths` matriz debe especificar la longitud de la dimensión correspondiente en el nuevo <xref:System.Array>.  
  
 Elementos de tipo de referencia se inicializan en `null`. Elementos de tipo de valor se inicializan en cero.  
  
 Este método es O (`n`) operación, donde `n` es el producto de todos los valores de `lengths`.  
  
   
  
## Examples  
 El ejemplo de código siguiente muestra cómo crear e inicializar multidimensional <xref:System.Array>.  
  
 [!code-cpp[Classic Array.CreateInstance3 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.CreateInstance3 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.CreateInstance3 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.CreateInstance3 Example/CS/source.cs#1)]
 [!code-vb[Classic Array.CreateInstance3 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.CreateInstance3 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El valor de <paramref name="elementType" /> es <see langword="null" />.  
  
O bien 
 El valor de <paramref name="lengths" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="elementType" /> no es un <see cref="T:System.Type" /> válido.  
  
O bien 
La matriz <paramref name="lengths" /> contiene menos de un elemento.</exception>
        <exception cref="T:System.NotSupportedException">No se admite <paramref name="elementType" />. Por ejemplo, no se admite <see cref="T:System.Void" />.  
  
O bien 
 <paramref name="elementType" /> es un tipo genérico abierto.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Cualquier valor de <paramref name="lengths" /> es menor que cero o mayor que <see cref="F:System.Int32.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public static Array CreateInstance (Type elementType, int length1, int length2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Array CreateInstance(class System.Type elementType, int32 length1, int32 length2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.CreateInstance(System.Type,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateInstance (elementType As Type, length1 As Integer, length2 As Integer) As Array" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Array ^ CreateInstance(Type ^ elementType, int length1, int length2);" />
      <MemberSignature Language="F#" Value="static member CreateInstance : Type * int * int -&gt; Array" Usage="System.Array.CreateInstance (elementType, length1, length2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Array</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="elementType" Type="System.Type" />
        <Parameter Name="length1" Type="System.Int32" />
        <Parameter Name="length2" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="elementType">
          <see cref="T:System.Type" /> de la matriz <see cref="T:System.Array" /> que se va a crear.</param>
        <param name="length1">Tamaño de la primera dimensión de la <see cref="T:System.Array" /> que se va a crear.</param>
        <param name="length2">Tamaño de la segunda dimensión de la <see cref="T:System.Array" /> que se va a crear.</param>
        <summary>Crea una matriz <see cref="T:System.Array" /> bidimensional de las longitudes de dimensión y el  <see cref="T:System.Type" /> especificados, con una indización de base cero.</summary>
        <returns>Nueva matriz <see cref="T:System.Array" /> bidimensional del tipo  <see cref="T:System.Type" /> especificado con la longitud especificada para cada dimensión, usando una indización de base cero.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A diferencia de la mayoría de las clases, <xref:System.Array> proporciona el <xref:System.Array.CreateInstance%2A> método, en lugar de constructores públicos, para permitir el acceso enlazado en tiempo de ejecución.  
  
 Elementos de tipo de referencia se inicializan en `null`. Elementos de tipo de valor se inicializan en cero.  
  
 Este método es O (`n`) operación, donde `n` es el producto de `length1` y `length2`.  
  
   
  
## Examples  
 El ejemplo de código siguiente muestra cómo crear e inicializar un bidimensional <xref:System.Array>.  
  
 [!code-cpp[Classic Array.CreateInstance1 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.CreateInstance1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.CreateInstance1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.CreateInstance1 Example/CS/source.cs#1)]
 [!code-vb[Classic Array.CreateInstance1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.CreateInstance1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El valor de <paramref name="elementType" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="elementType" /> no es un <see cref="T:System.Type" /> válido.</exception>
        <exception cref="T:System.NotSupportedException">No se admite <paramref name="elementType" />. Por ejemplo, no se admite <see cref="T:System.Void" />.  
  
O bien 
 <paramref name="elementType" /> es un tipo genérico abierto.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="length1" /> es menor que cero.  
  
O bien 
 <paramref name="length2" /> es menor que cero.</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public static Array CreateInstance (Type elementType, int[] lengths, int[] lowerBounds);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Array CreateInstance(class System.Type elementType, int32[] lengths, int32[] lowerBounds) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.CreateInstance(System.Type,System.Int32[],System.Int32[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateInstance (elementType As Type, lengths As Integer(), lowerBounds As Integer()) As Array" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Array ^ CreateInstance(Type ^ elementType, cli::array &lt;int&gt; ^ lengths, cli::array &lt;int&gt; ^ lowerBounds);" />
      <MemberSignature Language="F#" Value="static member CreateInstance : Type * int[] * int[] -&gt; Array" Usage="System.Array.CreateInstance (elementType, lengths, lowerBounds)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Array</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="elementType" Type="System.Type" />
        <Parameter Name="lengths" Type="System.Int32[]" />
        <Parameter Name="lowerBounds" Type="System.Int32[]" />
      </Parameters>
      <Docs>
        <param name="elementType">
          <see cref="T:System.Type" /> de la matriz <see cref="T:System.Array" /> que se va a crear.</param>
        <param name="lengths">Matriz unidimensional que contiene el tamaño de cada una de las dimensiones de la matriz <see cref="T:System.Array" /> que se va a crear.</param>
        <param name="lowerBounds">Matriz unidimensional que contiene el límite inferior (índice inicial) de cada una de las dimensiones de la matriz <see cref="T:System.Array" /> que se va a crear.</param>
        <summary>Crea una matriz <see cref="T:System.Array" /> multidimensional de las longitudes de dimensión y el tipo <see cref="T:System.Type" /> especificados, con los límites inferiores especificados.</summary>
        <returns>Nueva matriz <see cref="T:System.Array" /> multidimensional del tipo <see cref="T:System.Type" /> especificado con la longitud y los límites inferiores especificados para cada dimensión.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A diferencia de la mayoría de las clases, <xref:System.Array> proporciona el <xref:System.Array.CreateInstance%2A> método, en lugar de constructores públicos, para permitir el acceso enlazado en tiempo de ejecución.  
  
 El `lengths` y `lowerBounds` matrices deben tener el mismo número de elementos. El número de elementos de la `lengths` matriz debe ser igual al número de dimensiones en el nuevo <xref:System.Array>.  
  
 Cada elemento de la `lengths` matriz debe especificar la longitud de la dimensión correspondiente en el nuevo <xref:System.Array>.  
  
 Cada elemento de la `lowerBounds` matriz debe especificar el límite inferior de la dimensión correspondiente en el nuevo <xref:System.Array>. Por lo general, la biblioteca de clases de .NET Framework y muchos lenguajes de programación no controlan límites inferiores distintos de cero.  
  
 Elementos de tipo de referencia se inicializan en `null`. Elementos de tipo de valor se inicializan en cero.  
  
 Este método es O (`n`) operación, donde `n` es el producto de todos los valores de `lengths`.  
  
   
  
## Examples  
 El ejemplo de código siguiente muestra cómo crear e inicializar multidimensional <xref:System.Array> con límites inferiores especificados.  
  
 [!code-cpp[Classic Array.CreateInstance4 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.CreateInstance4 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.CreateInstance4 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.CreateInstance4 Example/CS/source.cs#1)]
 [!code-vb[Classic Array.CreateInstance4 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.CreateInstance4 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El valor de <paramref name="elementType" /> es <see langword="null" />.  
  
O bien 
 El valor de <paramref name="lengths" /> es <see langword="null" />.  
  
O bien 
 El valor de <paramref name="lowerBounds" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="elementType" /> no es un <see cref="T:System.Type" /> válido.  
  
O bien 
La matriz <paramref name="lengths" /> contiene menos de un elemento.  
  
O bien 
Las matrices <paramref name="lengths" /> y <paramref name="lowerBounds" /> no contienen el mismo número de elementos.</exception>
        <exception cref="T:System.NotSupportedException">No se admite <paramref name="elementType" />. Por ejemplo, no se admite <see cref="T:System.Void" />.  
  
O bien 
 <paramref name="elementType" /> es un tipo genérico abierto.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Cualquier valor en <paramref name="lengths" /> es menor que cero.  
  
O bien 
Cualquier valor de <paramref name="lowerBounds" /> es demasiado grande, tanto que la suma del límite inferior y de la longitud de una dimensión es mayor que <see cref="F:System.Int32.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public static Array CreateInstance (Type elementType, int length1, int length2, int length3);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Array CreateInstance(class System.Type elementType, int32 length1, int32 length2, int32 length3) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.CreateInstance(System.Type,System.Int32,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateInstance (elementType As Type, length1 As Integer, length2 As Integer, length3 As Integer) As Array" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Array ^ CreateInstance(Type ^ elementType, int length1, int length2, int length3);" />
      <MemberSignature Language="F#" Value="static member CreateInstance : Type * int * int * int -&gt; Array" Usage="System.Array.CreateInstance (elementType, length1, length2, length3)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Array</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="elementType" Type="System.Type" />
        <Parameter Name="length1" Type="System.Int32" />
        <Parameter Name="length2" Type="System.Int32" />
        <Parameter Name="length3" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="elementType">
          <see cref="T:System.Type" /> de la matriz <see cref="T:System.Array" /> que se va a crear.</param>
        <param name="length1">Tamaño de la primera dimensión de la <see cref="T:System.Array" /> que se va a crear.</param>
        <param name="length2">Tamaño de la segunda dimensión de la matriz <see cref="T:System.Array" /> que se va a crear.</param>
        <param name="length3">Tamaño de la tercera dimensión de la matriz <see cref="T:System.Array" /> que se va a crear.</param>
        <summary>Crea una <see cref="T:System.Array" /> tridimensional de las longitudes de dimensión y el <see cref="T:System.Type" /> especificados, con una indización de base cero.</summary>
        <returns>Nueva matriz <see cref="T:System.Array" /> tridimensional del tipo <see cref="T:System.Type" /> especificado con la longitud especificada para cada dimensión, usando una indización de base cero.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A diferencia de la mayoría de las clases, <xref:System.Array> proporciona el <xref:System.Array.CreateInstance%2A> método, en lugar de constructores públicos, para permitir el acceso enlazado en tiempo de ejecución.  
  
 Elementos de tipo de referencia se inicializan en `null`. Elementos de tipo de valor se inicializan en cero.  
  
 Este método es O (`n`) operación, donde `n` es el producto de `length1`, `length2`, y `length3`.  
  
   
  
## Examples  
 El ejemplo de código siguiente muestra cómo crear e inicializar una tridimensional <xref:System.Array>.  
  
 [!code-cpp[Classic Array.CreateInstance2 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.CreateInstance2 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.CreateInstance2 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.CreateInstance2 Example/CS/source.cs#1)]
 [!code-vb[Classic Array.CreateInstance2 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.CreateInstance2 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El valor de <paramref name="elementType" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="elementType" /> no es un <see cref="T:System.Type" /> válido.</exception>
        <exception cref="T:System.NotSupportedException">No se admite <paramref name="elementType" />. Por ejemplo, no se admite <see cref="T:System.Void" />.  
  
O bien 
 <paramref name="elementType" /> es un tipo genérico abierto.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="length1" /> es menor que cero.  
  
O bien 
 <paramref name="length2" /> es menor que cero.  
  
O bien 
 <paramref name="length3" /> es menor que cero.</exception>
      </Docs>
    </Member>
    <Member MemberName="Empty&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T[] Empty&lt;T&gt; ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!T[] Empty&lt;T&gt;() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Empty``1" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Empty(Of T) () As T()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static cli::array &lt;T&gt; ^ Empty();" />
      <MemberSignature Language="F#" Value="static member Empty : unit -&gt; 'T[]" Usage="System.Array.Empty " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>T[]</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters />
      <Docs>
        <typeparam name="T">Tipo de los elementos de la matriz.</typeparam>
        <summary>Devuelve una matriz vacía.</summary>
        <returns>Devuelve una <see cref="T:System.Array" /> vacía.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Exists&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static bool Exists&lt;T&gt; (T[] array, Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Exists&lt;T&gt;(!!T[] array, class System.Predicate`1&lt;!!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Exists``1(``0[],System.Predicate{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Exists(Of T) (array As T(), match As Predicate(Of T)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static bool Exists(cli::array &lt;T&gt; ^ array, Predicate&lt;T&gt; ^ match);" />
      <MemberSignature Language="F#" Value="static member Exists : 'T[] * Predicate&lt;'T&gt; -&gt; bool" Usage="System.Array.Exists (array, match)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">Tipo de los elementos de la matriz.</typeparam>
        <param name="array">
          <see cref="T:System.Array" /> unidimensional de base cero en la que se va a buscar.</param>
        <param name="match">
          <see cref="T:System.Predicate`1" /> que define las condiciones de los elementos que se van a buscar.</param>
        <summary>Determina si la matriz especificada contiene elementos que coinciden con las condiciones definidas por el predicado especificado.</summary>
        <returns>
          <see langword="true" /> si <paramref name="array" /> contiene uno o varios elementos que coinciden con las condiciones definidas por el predicado especificado; de lo contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Predicate%601> es un delegado a un método que devuelve `true` si el objeto pasado a coincide con las condiciones definidas en el delegado.  Los elementos de `array` individualmente se pasan a la <xref:System.Predicate%601>, y se detiene el procesamiento cuando encuentra una coincidencia.  
  
> [!NOTE]
>  En C# y Visual Basic, no es necesario crear la <xref:System.Predicate%601> delegar de forma explícita. Estos lenguajes deducen al delegado correcto del contexto y lo crean automáticamente.  
  
 Este método es O (`n`) operación, donde `n` es el <xref:System.Array.Length%2A> de `array`.  
  
   
  
## Examples  
 El ejemplo siguiente especifica las condiciones de coincidencia para el <xref:System.Array.Exists%2A> usinglambda expresiones de método para comprobar si se inicia un planeta con una letra determinada o si se encuentra el planeta en la matriz especificada.  
  
 [!code-csharp[System.Array.Exists#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.array.exists/cs/exists3.cs#3)]
 [!code-vb[System.Array.Exists#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.array.exists/vb/exists3.vb#3)]  
  
 En el ejemplo siguiente se usa el <xref:System.Array.Exists%2A> método para indicar si los nombres de una matriz de cadena comienzan con un carácter especificado. El ejemplo crea un `StringSearcher` pasando la cadena de búsqueda a su constructor de clase. El `StringSearcher.StartsWith` método tiene la misma firma que el <xref:System.Predicate%601> delegar. Cuando el <xref:System.Array.Exists%2A> se llama al método, cada miembro de la matriz se pasa al delegado hasta que devuelve `true` o recorre en iteración todos los elementos de la matriz.  
  
 [!code-csharp[System.Array.Exists#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.array.exists/cs/exists1.cs#1)]
 [!code-vb[System.Array.Exists#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.array.exists/vb/exists1.vb#1)]  
  
 Puede también usar una expresión lambda en lugar de definir explícitamente un método cuya firma corresponde a la del delegado. En el ejemplo siguiente se sustituye el `StringSearcher` clase y su `StartsWith` método con una expresión lambda.  
  
 [!code-csharp[System.Array.Exists#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.array.exists/cs/exists2.cs#2)]
 [!code-vb[System.Array.Exists#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.array.exists/vb/exists2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El valor de <paramref name="array" /> es <see langword="null" />.  
  
O bien 
 El valor de <paramref name="match" /> es <see langword="null" />.</exception>
        <altmember cref="M:System.Array.Find``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindLast``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindAll``1(``0[],System.Predicate{``0})" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <altmember cref="Overload:System.Array.IndexOf" />
        <altmember cref="Overload:System.Array.LastIndexOf" />
        <altmember cref="M:System.Array.TrueForAll``1(``0[],System.Predicate{``0})" />
        <altmember cref="T:System.Predicate`1" />
        <related type="Article" href="~/docs/csharp/programming-guide/statements-expressions-operators/lambda-expressions.md">Expresiones lambda (Guía de programación de C#)</related>
        <related type="Article" href="~/docs/visual-basic/programming-guide/language-features/procedures/lambda-expressions.md">Lambda (expresiones) (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Fill&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Fill&lt;T&gt; (T[] array, T value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Fill&lt;T&gt;(!!T[] array, !!T value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Fill``1(``0[],``0)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Fill(Of T) (array As T(), value As T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static void Fill(cli::array &lt;T&gt; ^ array, T value);" />
      <MemberSignature Language="F#" Value="static member Fill : 'T[] * 'T -&gt; unit" Usage="System.Array.Fill (array, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="value" Type="T" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="array">To be added.</param>
        <param name="value">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Fill&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Fill&lt;T&gt; (T[] array, T value, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Fill&lt;T&gt;(!!T[] array, !!T value, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Fill``1(``0[],``0,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Fill(Of T) (array As T(), value As T, startIndex As Integer, count As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static void Fill(cli::array &lt;T&gt; ^ array, T value, int startIndex, int count);" />
      <MemberSignature Language="F#" Value="static member Fill : 'T[] * 'T * int * int -&gt; unit" Usage="System.Array.Fill (array, value, startIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="value" Type="T" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="array">To be added.</param>
        <param name="value">To be added.</param>
        <param name="startIndex">To be added.</param>
        <param name="count">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Find&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T Find&lt;T&gt; (T[] array, Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!T Find&lt;T&gt;(!!T[] array, class System.Predicate`1&lt;!!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Find``1(``0[],System.Predicate{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Find(Of T) (array As T(), match As Predicate(Of T)) As T" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static T Find(cli::array &lt;T&gt; ^ array, Predicate&lt;T&gt; ^ match);" />
      <MemberSignature Language="F#" Value="static member Find : 'T[] * Predicate&lt;'T&gt; -&gt; 'T" Usage="System.Array.Find (array, match)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">Tipo de los elementos de la matriz.</typeparam>
        <param name="array">Matriz unidimensional de base cero en la que se va a buscar.</param>
        <param name="match">Predicado que define las condiciones del elemento que se va a buscar.</param>
        <summary>Busca un elemento que coincida con las condiciones definidas por el predicado especificado y devuelve la primera aparición en toda la matriz <see cref="T:System.Array" />.</summary>
        <returns>Primer elemento que coincide con las condiciones definidas por el predicado especificado, si se encuentra; de lo contrario, valor predeterminado para el tipo <paramref name="T" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Predicate%601> es un delegado a un método o una expresión lambda que devuelve `true` si el objeto pasado a coincide con las condiciones definidas en el delegado o expresión lambda.  Los elementos de `array` individualmente se pasan a la <xref:System.Predicate%601>, empezando por el primer elemento y terminando con el último elemento.  El procesamiento se detiene cuando encuentra una coincidencia.  
  
 Este método es O (`n`) operación, donde `n` es el <xref:System.Array.Length%2A> de `array`.  
  
   
  
## Examples  
 En el ejemplo siguiente se usa un <xref:System.Predicate%601> delegado con el <xref:System.Array.Find%2A> método genérico para buscar una matriz de <xref:System.Drawing.Point> estructuras. El método que representa el delegado, `ProductGT10`, devuelve `true` si el producto de los campos X e Y es mayor que 100 000. El <xref:System.Array.Find%2A> método llama al delegado para cada elemento de la matriz, devolviendo el primer punto que cumpla la condición de prueba.  
  
> [!NOTE]
>  Los usuarios de C# y Visual Basic no es necesario crear explícitamente el delegado o especifique el argumento de tipo del método genérico. Los compiladores determinan los tipos necesarios desde los argumentos del método que proporcione.  
  
 [!code-csharp[System.Array.Find#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.array.find/cs/source.cs#1)]
 [!code-vb[System.Array.Find#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.array.find/vb/source.vb#1)]  
  
 En lugar de definir explícitamente un método con la firma necesaria, crear instancias de un <xref:System.Predicate%601> delegar y pasando el delegado para el <xref:System.Array.Find%2A> método, es habitual usar una expresión lambda. El ejemplo siguiente es idéntico al anterior, salvo que usa una expresión lambda como la `match` argumento.  
  
 [!code-csharp[System.Array.Find#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.array.find/cs/lambda.cs#2)]
 [!code-vb[System.Array.Find#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.array.find/vb/lambda.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El valor de <paramref name="array" /> es <see langword="null" />.  
  
O bien 
 El valor de <paramref name="match" /> es <see langword="null" />.</exception>
        <altmember cref="M:System.Array.Exists``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindLast``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindAll``1(``0[],System.Predicate{``0})" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <altmember cref="Overload:System.Array.IndexOf" />
        <altmember cref="Overload:System.Array.LastIndexOf" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
    <Member MemberName="FindAll&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T[] FindAll&lt;T&gt; (T[] array, Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!T[] FindAll&lt;T&gt;(!!T[] array, class System.Predicate`1&lt;!!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.FindAll``1(``0[],System.Predicate{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FindAll(Of T) (array As T(), match As Predicate(Of T)) As T()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static cli::array &lt;T&gt; ^ FindAll(cli::array &lt;T&gt; ^ array, Predicate&lt;T&gt; ^ match);" />
      <MemberSignature Language="F#" Value="static member FindAll : 'T[] * Predicate&lt;'T&gt; -&gt; 'T[]" Usage="System.Array.FindAll (array, match)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T[]</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">Tipo de los elementos de la matriz.</typeparam>
        <param name="array">
          <see cref="T:System.Array" /> unidimensional de base cero en la que se va a buscar.</param>
        <param name="match">
          <see cref="T:System.Predicate`1" /> que define las condiciones de los elementos que se van a buscar.</param>
        <summary>Recupera todos los elementos que coinciden con las condiciones definidas por el predicado especificado.</summary>
        <returns>
          <see cref="T:System.Array" /> que contiene todos los elementos que cumplen las condiciones definidas por el predicado especificado, si se encuentran; en caso contrario, devuelve una <see cref="T:System.Array" /> vacía.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Predicate%601> es un delegado a un método que devuelve `true` si el objeto pasado a coincide con las condiciones definidas en el delegado.  Los elementos de `array` individualmente se pasan a la <xref:System.Predicate%601>, y los elementos que cumplen las condiciones se guardan en la matriz devuelta.  
  
 Este método es O (`n`) operación, donde `n` es el <xref:System.Array.Length%2A> de `array`.  
  
   
  
## Examples  
 El ejemplo siguiente crea una matriz de 50 números aleatorios con los valores pueden oscilar entre 0 y 1000. A continuación, llama el <xref:System.Array.FindAll%2A> método con una expresión lambda que devuelve los valores de ese intervalo de 300 a 600. Tenga en cuenta que la expresión lambda se pasa un parámetro denominado `x`;  representa los miembros individuales de la matriz que se pasan a la <xref:System.Predicate%601>. Tenga en cuenta también que el equipo local `lBound` y `uBound` las variables son accesibles dentro de la expresión lambda.  
  
 [!code-csharp[System.Array.FindAll#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.array.findall/cs/findall.cs#1)]
 [!code-vb[System.Array.FindAll#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.array.findall/vb/findall.vb#1)]  
  
 En el ejemplo de código siguiente se muestra el <xref:System.Array.Find%2A>, <xref:System.Array.FindLast%2A>, y <xref:System.Array.FindAll%2A> métodos genéricos. Se crea una matriz de cadenas, que contiene 8 nombres de dinosaurios, dos de los cuales (en las posiciones 1 y 5) terminan en "saurus". El ejemplo de código también define un método de predicado de búsqueda denominado `EndsWithSaurus`, que acepta un parámetro de cadena y devuelve un valor booleano que indica si la cadena de entrada termina en "saurus".  
  
 El <xref:System.Array.Find%2A> método genérico recorre la matriz desde el principio, pasando cada elemento a su vez a la `EndsWithSaurus` método. La búsqueda detiene cuando la `EndsWithSaurus` devuelve del método `true` para el elemento "Amargasaurus".  
  
> [!NOTE]
>  En C# y Visual Basic, no es necesario crear la `Predicate<string>` delegar (`Predicate(Of String)` en Visual Basic) explícitamente. Estos lenguajes deducen al delegado correcto del contexto y lo crean automáticamente.  
  
 El <xref:System.Array.FindLast%2A> método genérico se usa para buscar en la matriz hacia atrás desde el final. Busca el elemento "Dilophosaurus" en la posición 5. El <xref:System.Array.FindAll%2A> método genérico se usa para devolver una matriz que contiene todos los elementos que terminan en "saurus". Se muestran los elementos.  
  
 El ejemplo de código también muestra el <xref:System.Array.Exists%2A> y <xref:System.Array.TrueForAll%2A> métodos genéricos.  
  
 [!code-cpp[Array_FindEtAl#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_FindEtAl/cpp/source.cpp#1)]
 [!code-csharp[Array_FindEtAl#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_FindEtAl/cs/source.cs#1)]
 [!code-vb[Array_FindEtAl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_FindEtAl/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El valor de <paramref name="array" /> es <see langword="null" />.  
  
O bien 
 El valor de <paramref name="match" /> es <see langword="null" />.</exception>
        <altmember cref="M:System.Array.Exists``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.Find``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindLast``1(``0[],System.Predicate{``0})" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <altmember cref="Overload:System.Array.IndexOf" />
        <altmember cref="Overload:System.Array.LastIndexOf" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
    <MemberGroup MemberName="FindIndex&lt;T&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Busca un elemento que cumpla las condiciones definidas por el predicado especificado y devuelve el índice de base cero de la primera aparición en un objeto <see cref="T:System.Array" /> o en una parte del mismo.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="FindIndex&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int FindIndex&lt;T&gt; (T[] array, Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 FindIndex&lt;T&gt;(!!T[] array, class System.Predicate`1&lt;!!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.FindIndex``1(``0[],System.Predicate{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FindIndex(Of T) (array As T(), match As Predicate(Of T)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static int FindIndex(cli::array &lt;T&gt; ^ array, Predicate&lt;T&gt; ^ match);" />
      <MemberSignature Language="F#" Value="static member FindIndex : 'T[] * Predicate&lt;'T&gt; -&gt; int" Usage="System.Array.FindIndex (array, match)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">Tipo de los elementos de la matriz.</typeparam>
        <param name="array">
          <see cref="T:System.Array" /> unidimensional de base cero en la que se realizará la búsqueda.</param>
        <param name="match">
          <see cref="T:System.Predicate`1" /> que define las condiciones del elemento que se va a buscar.</param>
        <summary>Busca un elemento que coincida con las condiciones definidas por el predicado especificado y devuelve el índice de base cero de la primera aparición en toda la matriz <see cref="T:System.Array" />.</summary>
        <returns>Índice de base cero de la primera aparición de un elemento que coincide con las condiciones definidas por <paramref name="match" />, si se encuentra; en caso contrario, -1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Array> se buscará hacia delante a partir del primer elemento y terminando en el último elemento.  
  
 El <xref:System.Predicate%601> es un delegado a un método que devuelve `true` si el objeto pasado a coincide con las condiciones definidas en el delegado.  Los elementos de `array` individualmente se pasan a la <xref:System.Predicate%601>.  
  
 Este método es O (`n`) operación, donde `n` es el <xref:System.Array.Length%2A> de `array`.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra las tres sobrecargas de los <xref:System.Array.FindIndex%2A> método genérico. Se crea una matriz de cadenas, que contiene 8 nombres de dinosaurios, dos de los cuales (en las posiciones 1 y 5) terminan en "saurus". El ejemplo de código también define un método de predicado de búsqueda denominado `EndsWithSaurus`, que acepta un parámetro de cadena y devuelve un valor booleano que indica si la cadena de entrada termina en "saurus".  
  
 El <xref:System.Array.FindIndex%60%601%28%60%600%5B%5D%2CSystem.Predicate%7B%60%600%7D%29> sobrecarga del método recorre la matriz desde el principio, pasando cada elemento a su vez a la `EndsWithSaurus` método. La búsqueda detiene cuando la `EndsWithSaurus` devuelve del método `true` para el elemento en la posición 1.  
  
> [!NOTE]
>  En C# y Visual Basic, no es necesario crear la `Predicate<string>` delegar (`Predicate(Of String)` en Visual Basic) explícitamente. Estos lenguajes deducen al delegado correcto del contexto y lo crean automáticamente.  
  
 El <xref:System.Array.FindIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29> sobrecarga del método se utiliza para buscar en la matriz, comenzando en la posición 2 y continuando hasta el final de la matriz. Busca el elemento en la posición 5. Por último, el <xref:System.Array.FindIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29> sobrecarga del método se utiliza para buscar el intervalo de tres elementos, empezando en la posición 2. Devuelve – 1 porque no hay ningún nombre de dinosaurio en ese intervalo que terminan en "saurus".  
  
 [!code-cpp[Array_FindIndex#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_FindIndex/cpp/source.cpp#1)]
 [!code-csharp[Array_FindIndex#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_FindIndex/cs/source.cs#1)]
 [!code-vb[Array_FindIndex#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_FindIndex/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El valor de <paramref name="array" /> es <see langword="null" />.  
  
O bien 
 El valor de <paramref name="match" /> es <see langword="null" />.</exception>
        <altmember cref="M:System.Array.Exists``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.Find``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindLast``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindAll``1(``0[],System.Predicate{``0})" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <altmember cref="Overload:System.Array.IndexOf" />
        <altmember cref="Overload:System.Array.LastIndexOf" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
    <Member MemberName="FindIndex&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int FindIndex&lt;T&gt; (T[] array, int startIndex, Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 FindIndex&lt;T&gt;(!!T[] array, int32 startIndex, class System.Predicate`1&lt;!!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.FindIndex``1(``0[],System.Int32,System.Predicate{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FindIndex(Of T) (array As T(), startIndex As Integer, match As Predicate(Of T)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static int FindIndex(cli::array &lt;T&gt; ^ array, int startIndex, Predicate&lt;T&gt; ^ match);" />
      <MemberSignature Language="F#" Value="static member FindIndex : 'T[] * int * Predicate&lt;'T&gt; -&gt; int" Usage="System.Array.FindIndex (array, startIndex, match)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">Tipo de los elementos de la matriz.</typeparam>
        <param name="array">
          <see cref="T:System.Array" /> unidimensional de base cero en la que se realizará la búsqueda.</param>
        <param name="startIndex">Índice inicial de base cero de la búsqueda.</param>
        <param name="match">
          <see cref="T:System.Predicate`1" /> que define las condiciones del elemento que se va a buscar.</param>
        <summary>Busca un elemento que coincida con las condiciones definidas por el predicado especificado y devuelve el índice de base cero de la primera aparición en el intervalo de elementos de la matriz <see cref="T:System.Array" /> que va desde el índice especificado hasta el último elemento.</summary>
        <returns>Índice de base cero de la primera aparición de un elemento que coincide con las condiciones definidas por <paramref name="match" />, si se encuentra; en caso contrario, -1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Array> se buscará hacia delante, empezando en `startIndex` y terminando en el último elemento.  
  
 El <xref:System.Predicate%601> es un delegado a un método que devuelve `true` si el objeto pasado a coincide con las condiciones definidas en el delegado.  Los elementos de `array` individualmente se pasan a la <xref:System.Predicate%601>.  
  
 Este método es O (`n`) operación, donde `n` es el número de elementos de `startIndex` al final de `array`.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra las tres sobrecargas de los <xref:System.Array.FindIndex%2A> método genérico. Se crea una matriz de cadenas, que contiene 8 nombres de dinosaurios, dos de los cuales (en las posiciones 1 y 5) terminan en "saurus". El ejemplo de código también define un método de predicado de búsqueda denominado `EndsWithSaurus`, que acepta un parámetro de cadena y devuelve un valor booleano que indica si la cadena de entrada termina en "saurus".  
  
 El <xref:System.Array.FindIndex%60%601%28%60%600%5B%5D%2CSystem.Predicate%7B%60%600%7D%29> sobrecarga del método recorre la matriz desde el principio, pasando cada elemento a su vez a la `EndsWithSaurus` método. La búsqueda detiene cuando la `EndsWithSaurus` devuelve del método `true` para el elemento en la posición 1.  
  
> [!NOTE]
>  En C# y Visual Basic, no es necesario crear la `Predicate<string>` delegar (`Predicate(Of String)` en Visual Basic) explícitamente. Estos lenguajes deducen al delegado correcto del contexto y lo crean automáticamente.  
  
 El <xref:System.Array.FindIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29> sobrecarga del método se utiliza para buscar en la matriz, comenzando en la posición 2 y continuando hasta el final de la matriz. Busca el elemento en la posición 5. Por último, el <xref:System.Array.FindIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29> sobrecarga del método se utiliza para buscar el intervalo de tres elementos, empezando en la posición 2. Devuelve – 1 porque no hay ningún nombre de dinosaurio en ese intervalo que terminan en "saurus".  
  
 [!code-cpp[Array_FindIndex#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_FindIndex/cpp/source.cpp#1)]
 [!code-csharp[Array_FindIndex#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_FindIndex/cs/source.cs#1)]
 [!code-vb[Array_FindIndex#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_FindIndex/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El valor de <paramref name="array" /> es <see langword="null" />.  
  
O bien 
 El valor de <paramref name="match" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" /> está fuera del intervalo de índices válidos para la <paramref name="array" />.</exception>
        <altmember cref="M:System.Array.Exists``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.Find``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindLast``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindAll``1(``0[],System.Predicate{``0})" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <altmember cref="Overload:System.Array.IndexOf" />
        <altmember cref="Overload:System.Array.LastIndexOf" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
    <Member MemberName="FindIndex&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int FindIndex&lt;T&gt; (T[] array, int startIndex, int count, Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 FindIndex&lt;T&gt;(!!T[] array, int32 startIndex, int32 count, class System.Predicate`1&lt;!!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.FindIndex``1(``0[],System.Int32,System.Int32,System.Predicate{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FindIndex(Of T) (array As T(), startIndex As Integer, count As Integer, match As Predicate(Of T)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static int FindIndex(cli::array &lt;T&gt; ^ array, int startIndex, int count, Predicate&lt;T&gt; ^ match);" />
      <MemberSignature Language="F#" Value="static member FindIndex : 'T[] * int * int * Predicate&lt;'T&gt; -&gt; int" Usage="System.Array.FindIndex (array, startIndex, count, match)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">Tipo de los elementos de la matriz.</typeparam>
        <param name="array">
          <see cref="T:System.Array" /> unidimensional de base cero en la que se realizará la búsqueda.</param>
        <param name="startIndex">Índice inicial de base cero de la búsqueda.</param>
        <param name="count">Número de elementos de la sección en la que se va a realizar la búsqueda.</param>
        <param name="match">
          <see cref="T:System.Predicate`1" /> que define las condiciones del elemento que se va a buscar.</param>
        <summary>Busca un elemento que coincida con las condiciones definidas por el predicado especificado y devuelve el índice de base cero de la primera aparición en el intervalo de elementos de la matriz <see cref="T:System.Array" /> que comienza en el índice especificado y contiene el número especificado de elementos.</summary>
        <returns>Índice de base cero de la primera aparición de un elemento que coincide con las condiciones definidas por <paramref name="match" />, si se encuentra; en caso contrario, -1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Array> se buscará hacia delante, empezando en `startIndex` hasta `startIndex` plus `count` menos 1, si `count` es mayor que 0.  
  
 El <xref:System.Predicate%601> es un delegado a un método que devuelve `true` si el objeto pasado a coincide con las condiciones definidas en el delegado.  Los elementos de `array` individualmente se pasan a la <xref:System.Predicate%601>.  
  
 Este método es O (`n`) operación, donde `n` es `count`.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra las tres sobrecargas de los <xref:System.Array.FindIndex%2A> método genérico. Se crea una matriz de cadenas, que contiene 8 nombres de dinosaurios, dos de los cuales (en las posiciones 1 y 5) terminan en "saurus". El ejemplo de código también define un método de predicado de búsqueda denominado `EndsWithSaurus`, que acepta un parámetro de cadena y devuelve un valor booleano que indica si la cadena de entrada termina en "saurus".  
  
 El <xref:System.Array.FindIndex%60%601%28%60%600%5B%5D%2CSystem.Predicate%7B%60%600%7D%29> sobrecarga del método recorre la matriz desde el principio, pasando cada elemento a su vez a la `EndsWithSaurus` método. La búsqueda detiene cuando la `EndsWithSaurus` devuelve del método `true` para el elemento en la posición 1.  
  
> [!NOTE]
>  En C# y Visual Basic, no es necesario crear la `Predicate<string>` delegar (`Predicate(Of String)` en Visual Basic) explícitamente. Estos lenguajes deducen al delegado correcto del contexto y lo crean automáticamente.  
  
 El <xref:System.Array.FindIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29> sobrecarga del método se utiliza para buscar en la matriz, comenzando en la posición 2 y continuando hasta el final de la matriz. Busca el elemento en la posición 5. Por último, el <xref:System.Array.FindIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29> sobrecarga del método se utiliza para buscar el intervalo de tres elementos, empezando en la posición 2. Devuelve – 1 porque no hay ningún nombre de dinosaurio en ese intervalo que terminan en "saurus".  
  
 [!code-cpp[Array_FindIndex#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_FindIndex/cpp/source.cpp#1)]
 [!code-csharp[Array_FindIndex#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_FindIndex/cs/source.cs#1)]
 [!code-vb[Array_FindIndex#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_FindIndex/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El valor de <paramref name="array" /> es <see langword="null" />.  
  
O bien 
 El valor de <paramref name="match" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" /> está fuera del intervalo de índices válidos para la <paramref name="array" />.  
  
O bien 
 <paramref name="count" /> es menor que cero.  
  
O bien 
 <paramref name="startIndex" /> y <paramref name="count" /> no especifican una sección válida en <paramref name="array" />.</exception>
        <altmember cref="M:System.Array.Exists``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.Find``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindLast``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindAll``1(``0[],System.Predicate{``0})" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <altmember cref="Overload:System.Array.IndexOf" />
        <altmember cref="Overload:System.Array.LastIndexOf" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
    <Member MemberName="FindLast&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T FindLast&lt;T&gt; (T[] array, Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!T FindLast&lt;T&gt;(!!T[] array, class System.Predicate`1&lt;!!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.FindLast``1(``0[],System.Predicate{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FindLast(Of T) (array As T(), match As Predicate(Of T)) As T" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static T FindLast(cli::array &lt;T&gt; ^ array, Predicate&lt;T&gt; ^ match);" />
      <MemberSignature Language="F#" Value="static member FindLast : 'T[] * Predicate&lt;'T&gt; -&gt; 'T" Usage="System.Array.FindLast (array, match)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">Tipo de los elementos de la matriz.</typeparam>
        <param name="array">
          <see cref="T:System.Array" /> unidimensional de base cero en la que se realizará la búsqueda.</param>
        <param name="match">
          <see cref="T:System.Predicate`1" /> que define las condiciones del elemento que se va a buscar.</param>
        <summary>Busca un elemento que coincida con las condiciones definidas por el predicado especificado y devuelve la última aparición en toda la matriz <see cref="T:System.Array" />.</summary>
        <returns>Último elemento que coincide con las condiciones definidas por el predicado especificado, si se encuentra; de lo contrario, valor predeterminado para el tipo <paramref name="T" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Predicate%601> es un delegado a un método que devuelve `true` si el objeto pasado a coincide con las condiciones definidas en el delegado.  Los elementos de `array` individualmente se pasan a la <xref:System.Predicate%601>, moverse hacia atrás en el <xref:System.Array>, empezando por el último elemento y terminando por el primer elemento.  El procesamiento se detiene cuando encuentra una coincidencia.  
  
 Este método es O (`n`) operación, donde `n` es el <xref:System.Array.Length%2A> de `array`.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra el <xref:System.Array.Find%2A>, <xref:System.Array.FindLast%2A>, y <xref:System.Array.FindAll%2A> métodos genéricos. Se crea una matriz de cadenas, que contiene 8 nombres de dinosaurios, dos de los cuales (en las posiciones 1 y 5) terminan en "saurus". El ejemplo de código también define un método de predicado de búsqueda denominado `EndsWithSaurus`, que acepta un parámetro de cadena y devuelve un valor booleano que indica si la cadena de entrada termina en "saurus".  
  
 El <xref:System.Array.Find%2A> método genérico recorre la matriz desde el principio, pasando cada elemento a su vez a la `EndsWithSaurus` método. La búsqueda detiene cuando la `EndsWithSaurus` devuelve del método `true` para el elemento "Amargasaurus".  
  
> [!NOTE]
>  En C# y Visual Basic, no es necesario crear la`Predicate<string>` delegar (`Predicate(Of String)` en Visual Basic) explícitamente. Estos lenguajes deducen al delegado correcto del contexto y lo crean automáticamente.  
  
 El <xref:System.Array.FindLast%2A> método genérico se usa para buscar en la matriz hacia atrás desde el final. Busca el elemento "Dilophosaurus" en la posición 5. El <xref:System.Array.FindAll%2A> método genérico se usa para devolver una matriz que contiene todos los elementos que terminan en "saurus". Se muestran los elementos.  
  
 El ejemplo de código también muestra el <xref:System.Array.Exists%2A> y <xref:System.Array.TrueForAll%2A> métodos genéricos.  
  
 [!code-cpp[Array_FindEtAl#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_FindEtAl/cpp/source.cpp#1)]
 [!code-csharp[Array_FindEtAl#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_FindEtAl/cs/source.cs#1)]
 [!code-vb[Array_FindEtAl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_FindEtAl/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El valor de <paramref name="array" /> es <see langword="null" />.  
  
O bien 
 El valor de <paramref name="match" /> es <see langword="null" />.</exception>
        <altmember cref="M:System.Array.Exists``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.Find``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindAll``1(``0[],System.Predicate{``0})" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <altmember cref="Overload:System.Array.IndexOf" />
        <altmember cref="Overload:System.Array.LastIndexOf" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
    <MemberGroup MemberName="FindLastIndex&lt;T&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Busca un elemento que cumpla las condiciones definidas por el predicado especificado y devuelve el índice de base cero de la última aparición en un objeto <see cref="T:System.Array" /> o en una parte del mismo.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="FindLastIndex&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int FindLastIndex&lt;T&gt; (T[] array, Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 FindLastIndex&lt;T&gt;(!!T[] array, class System.Predicate`1&lt;!!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.FindLastIndex``1(``0[],System.Predicate{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FindLastIndex(Of T) (array As T(), match As Predicate(Of T)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static int FindLastIndex(cli::array &lt;T&gt; ^ array, Predicate&lt;T&gt; ^ match);" />
      <MemberSignature Language="F#" Value="static member FindLastIndex : 'T[] * Predicate&lt;'T&gt; -&gt; int" Usage="System.Array.FindLastIndex (array, match)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">Tipo de los elementos de la matriz.</typeparam>
        <param name="array">
          <see cref="T:System.Array" /> unidimensional de base cero en la que se realizará la búsqueda.</param>
        <param name="match">
          <see cref="T:System.Predicate`1" /> que define las condiciones del elemento que se va a buscar.</param>
        <summary>Busca un elemento que coincida con las condiciones definidas por el predicado especificado y devuelve el índice de base cero de la última aparición en toda la matriz <see cref="T:System.Array" />.</summary>
        <returns>Índice de base cero de la última aparición de un elemento que coincide con las condiciones definidas por <paramref name="match" />, si se encuentra; en caso contrario, -1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Array> se realiza hacia atrás a partir del último elemento y terminando en el primer elemento.  
  
 El <xref:System.Predicate%601> es un delegado a un método que devuelve `true` si el objeto pasado a coincide con las condiciones definidas en el delegado.  Los elementos de `array` individualmente se pasan a la <xref:System.Predicate%601>.  
  
 Este método es O (`n`) operación, donde `n` es el <xref:System.Array.Length%2A> de `array`.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra las tres sobrecargas de los <xref:System.Array.FindLastIndex%2A> método genérico. Se crea una matriz de cadenas, que contiene 8 nombres de dinosaurios, dos de los cuales (en las posiciones 1 y 5) terminan en "saurus". El ejemplo de código también define un método de predicado de búsqueda denominado `EndsWithSaurus`, que acepta un parámetro de cadena y devuelve un valor booleano que indica si la cadena de entrada termina en "saurus".  
  
 El <xref:System.Array.FindLastIndex%60%601%28%60%600%5B%5D%2CSystem.Predicate%7B%60%600%7D%29> sobrecarga del método recorre la matriz hacia atrás desde el final, pasando cada elemento a su vez a la `EndsWithSaurus` método. La búsqueda detiene cuando la `EndsWithSaurus` devuelve del método `true` para el elemento en la posición 5.  
  
> [!NOTE]
>  En C# y Visual Basic, no es necesario crear la `Predicate<string>` delegar (`Predicate(Of String)` en Visual Basic) explícitamente. Estos lenguajes deducen al delegado correcto del contexto y lo crean automáticamente.  
  
 El <xref:System.Array.FindLastIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29> sobrecarga del método se utiliza para buscar en la matriz, comenzando en la posición 4 y continuando hacia atrás hasta el principio de la matriz. Busca el elemento en la posición 1. Por último, el <xref:System.Array.FindLastIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29> sobrecarga del método se utiliza para buscar el intervalo de tres elementos a partir de la posición 4 y trabajando hacia atrás (es decir, elementos 2, 3 y 4). Devuelve – 1 porque no hay ningún nombre de dinosaurio en ese intervalo que terminan en "saurus".  
  
 [!code-cpp[Array_FindLastIndex#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_FindLastIndex/cpp/source.cpp#1)]
 [!code-csharp[Array_FindLastIndex#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_FindLastIndex/cs/source.cs#1)]
 [!code-vb[Array_FindLastIndex#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_FindLastIndex/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El valor de <paramref name="array" /> es <see langword="null" />.  
  
O bien 
 El valor de <paramref name="match" /> es <see langword="null" />.</exception>
        <altmember cref="M:System.Array.Exists``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.Find``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindLast``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindAll``1(``0[],System.Predicate{``0})" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <altmember cref="Overload:System.Array.IndexOf" />
        <altmember cref="Overload:System.Array.LastIndexOf" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
    <Member MemberName="FindLastIndex&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int FindLastIndex&lt;T&gt; (T[] array, int startIndex, Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 FindLastIndex&lt;T&gt;(!!T[] array, int32 startIndex, class System.Predicate`1&lt;!!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.FindLastIndex``1(``0[],System.Int32,System.Predicate{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FindLastIndex(Of T) (array As T(), startIndex As Integer, match As Predicate(Of T)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static int FindLastIndex(cli::array &lt;T&gt; ^ array, int startIndex, Predicate&lt;T&gt; ^ match);" />
      <MemberSignature Language="F#" Value="static member FindLastIndex : 'T[] * int * Predicate&lt;'T&gt; -&gt; int" Usage="System.Array.FindLastIndex (array, startIndex, match)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">Tipo de los elementos de la matriz.</typeparam>
        <param name="array">
          <see cref="T:System.Array" /> unidimensional de base cero en la que se realizará la búsqueda.</param>
        <param name="startIndex">Índice inicial de base cero de la búsqueda hacia atrás.</param>
        <param name="match">
          <see cref="T:System.Predicate`1" /> que define las condiciones del elemento que se va a buscar.</param>
        <summary>Busca un elemento que coincida con las condiciones definidas por el predicado especificado y devuelve el índice de base cero de la última aparición en el intervalo de elementos de la matriz <see cref="T:System.Array" /> que va desde el primer elemento hasta el índice especificado.</summary>
        <returns>Índice de base cero de la última aparición de un elemento que coincide con las condiciones definidas por <paramref name="match" />, si se encuentra; en caso contrario, -1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Array> es la búsqueda hacia atrás, empezando en `startIndex` y terminando en el primer elemento.  
  
 El <xref:System.Predicate%601> es un delegado a un método que devuelve `true` si el objeto pasado a coincide con las condiciones definidas en el delegado.  Los elementos de `array` individualmente se pasan a la <xref:System.Predicate%601>.  
  
 Este método es O (`n`) operación, donde `n` es el número de elementos desde el principio del `array` a `startIndex`.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra las tres sobrecargas de los <xref:System.Array.FindLastIndex%2A> método genérico. Se crea una matriz de cadenas, que contiene 8 nombres de dinosaurios, dos de los cuales (en las posiciones 1 y 5) terminan en "saurus". El ejemplo de código también define un método de predicado de búsqueda denominado `EndsWithSaurus`, que acepta un parámetro de cadena y devuelve un valor booleano que indica si la cadena de entrada termina en "saurus".  
  
 El <xref:System.Array.FindLastIndex%60%601%28%60%600%5B%5D%2CSystem.Predicate%7B%60%600%7D%29> sobrecarga del método recorre la matriz hacia atrás desde el final, pasando cada elemento a su vez a la `EndsWithSaurus` método. La búsqueda detiene cuando la `EndsWithSaurus` devuelve del método `true` para el elemento en la posición 5.  
  
> [!NOTE]
>  En C# y Visual Basic, no es necesario crear la `Predicate<string>` delegar (`Predicate(Of String)` en Visual Basic) explícitamente. Estos lenguajes deducen al delegado correcto del contexto y lo crean automáticamente.  
  
 El <xref:System.Array.FindLastIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29> sobrecarga del método se utiliza para buscar en la matriz, comenzando en la posición 4 y continuando hacia atrás hasta el principio de la matriz. Busca el elemento en la posición 1. Por último, el <xref:System.Array.FindLastIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29> sobrecarga del método se utiliza para buscar el intervalo de tres elementos a partir de la posición 4 y trabajando hacia atrás (es decir, elementos 2, 3 y 4). Devuelve – 1 porque no hay ningún nombre de dinosaurio en ese intervalo que terminan en "saurus".  
  
 [!code-cpp[Array_FindLastIndex#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_FindLastIndex/cpp/source.cpp#1)]
 [!code-csharp[Array_FindLastIndex#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_FindLastIndex/cs/source.cs#1)]
 [!code-vb[Array_FindLastIndex#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_FindLastIndex/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El valor de <paramref name="array" /> es <see langword="null" />.  
  
O bien 
 El valor de <paramref name="match" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" /> está fuera del intervalo de índices válidos para la <paramref name="array" />.</exception>
        <altmember cref="M:System.Array.Exists``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.Find``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindLast``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindAll``1(``0[],System.Predicate{``0})" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <altmember cref="Overload:System.Array.IndexOf" />
        <altmember cref="Overload:System.Array.LastIndexOf" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
    <Member MemberName="FindLastIndex&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int FindLastIndex&lt;T&gt; (T[] array, int startIndex, int count, Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 FindLastIndex&lt;T&gt;(!!T[] array, int32 startIndex, int32 count, class System.Predicate`1&lt;!!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.FindLastIndex``1(``0[],System.Int32,System.Int32,System.Predicate{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FindLastIndex(Of T) (array As T(), startIndex As Integer, count As Integer, match As Predicate(Of T)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static int FindLastIndex(cli::array &lt;T&gt; ^ array, int startIndex, int count, Predicate&lt;T&gt; ^ match);" />
      <MemberSignature Language="F#" Value="static member FindLastIndex : 'T[] * int * int * Predicate&lt;'T&gt; -&gt; int" Usage="System.Array.FindLastIndex (array, startIndex, count, match)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">Tipo de los elementos de la matriz.</typeparam>
        <param name="array">
          <see cref="T:System.Array" /> unidimensional de base cero en la que se realizará la búsqueda.</param>
        <param name="startIndex">Índice inicial de base cero de la búsqueda hacia atrás.</param>
        <param name="count">Número de elementos de la sección en la que se va a realizar la búsqueda.</param>
        <param name="match">
          <see cref="T:System.Predicate`1" /> que define las condiciones del elemento que se va a buscar.</param>
        <summary>Busca un elemento que coincida con las condiciones definidas por el predicado especificado y devuelve el índice de base cero de la última aparición en el intervalo de elementos de la matriz <see cref="T:System.Array" /> que contiene el número especificado de elementos y termina en el índice especificado.</summary>
        <returns>Índice de base cero de la última aparición de un elemento que coincide con las condiciones definidas por <paramref name="match" />, si se encuentra; en caso contrario, -1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Array> es la búsqueda hacia atrás, empezando en `startIndex` hasta `startIndex` menos `count` más 1, si `count` es mayor que 0.  
  
 El <xref:System.Predicate%601> es un delegado a un método que devuelve `true` si el objeto pasado a coincide con las condiciones definidas en el delegado.  Los elementos de `array` individualmente se pasan a la <xref:System.Predicate%601>.  
  
 Este método es O (`n`) operación, donde `n` es `count`.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra las tres sobrecargas de los <xref:System.Array.FindLastIndex%2A> método genérico. Se crea una matriz de cadenas, que contiene 8 nombres de dinosaurios, dos de los cuales (en las posiciones 1 y 5) terminan en "saurus". El ejemplo de código también define un método de predicado de búsqueda denominado `EndsWithSaurus`, que acepta un parámetro de cadena y devuelve un valor booleano que indica si la cadena de entrada termina en "saurus".  
  
 El <xref:System.Array.FindLastIndex%60%601%28%60%600%5B%5D%2CSystem.Predicate%7B%60%600%7D%29> sobrecarga del método recorre la matriz hacia atrás desde el final, pasando cada elemento a su vez a la `EndsWithSaurus` método. La búsqueda detiene cuando la `EndsWithSaurus` devuelve del método `true` para el elemento en la posición 5.  
  
> [!NOTE]
>  En C# y Visual Basic, no es necesario crear la `Predicate<string>` delegar (`Predicate(Of String)` en Visual Basic) explícitamente. Estos lenguajes deducen al delegado correcto del contexto y lo crean automáticamente.  
  
 El <xref:System.Array.FindLastIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29> sobrecarga del método se utiliza para buscar en la matriz, comenzando en la posición 4 y continuando hacia atrás hasta el principio de la matriz. Busca el elemento en la posición 1. Por último, el <xref:System.Array.FindLastIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29> sobrecarga del método se utiliza para buscar el intervalo de tres elementos a partir de la posición 4 y trabajando hacia atrás (es decir, elementos 2, 3 y 4). Devuelve – 1 porque no hay ningún nombre de dinosaurio en ese intervalo que terminan en "saurus".  
  
 [!code-cpp[Array_FindLastIndex#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_FindLastIndex/cpp/source.cpp#1)]
 [!code-csharp[Array_FindLastIndex#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_FindLastIndex/cs/source.cs#1)]
 [!code-vb[Array_FindLastIndex#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_FindLastIndex/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El valor de <paramref name="array" /> es <see langword="null" />.  
  
O bien 
 El valor de <paramref name="match" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" /> está fuera del intervalo de índices válidos para la <paramref name="array" />.  
  
O bien 
 <paramref name="count" /> es menor que cero.  
  
O bien 
 <paramref name="startIndex" /> y <paramref name="count" /> no especifican una sección válida en <paramref name="array" />.</exception>
        <altmember cref="M:System.Array.Exists``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.Find``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindLast``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindAll``1(``0[],System.Predicate{``0})" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <altmember cref="Overload:System.Array.IndexOf" />
        <altmember cref="Overload:System.Array.LastIndexOf" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
    <Member MemberName="ForEach&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void ForEach&lt;T&gt; (T[] array, Action&lt;T&gt; action);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void ForEach&lt;T&gt;(!!T[] array, class System.Action`1&lt;!!T&gt; action) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.ForEach``1(``0[],System.Action{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub ForEach(Of T) (array As T(), action As Action(Of T))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static void ForEach(cli::array &lt;T&gt; ^ array, Action&lt;T&gt; ^ action);" />
      <MemberSignature Language="F#" Value="static member ForEach : 'T[] * Action&lt;'T&gt; -&gt; unit" Usage="System.Array.ForEach (array, action)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="action" Type="System.Action&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">Tipo de los elementos de la matriz.</typeparam>
        <param name="array">Matriz <see cref="T:System.Array" /> unidimensional de base cero en cuyos elementos se va a llevar a cabo la acción.</param>
        <param name="action">Delegado <see cref="T:System.Action`1" /> que se va a ejecutar en cada elemento de <paramref name="array" />.</param>
        <summary>Realiza la acción especificada en cada elemento de la matriz especificada.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Action%601> se pasa un delegado a un método que realiza una acción en el objeto.  Los elementos de `array` individualmente se pasan a la <xref:System.Action%601>.  
  
 Este método es O (`n`) operación, donde `n` es el <xref:System.Array.Length%2A> de `array`.  
  
   
  
## Examples  
 El ejemplo siguiente muestra cómo usar <xref:System.Array.ForEach%2A> para mostrar los cuadrados de cada elemento en una matriz de enteros.  
  
 [!code-cpp[System.Array.ForEach#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.array.foreach/cpp/source.cpp#1)]
 [!code-csharp[System.Array.ForEach#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.array.foreach/cs/source.cs#1)]
 [!code-vb[System.Array.ForEach#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.array.foreach/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El valor de <paramref name="array" /> es <see langword="null" />.  
  
O bien 
 El valor de <paramref name="action" /> es <see langword="null" />.</exception>
        <altmember cref="T:System.Action`1" />
      </Docs>
    </Member>
    <Member MemberName="GetEnumerator">
      <MemberSignature Language="C#" Value="public System.Collections.IEnumerator GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.IEnumerator GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Public Function GetEnumerator () As IEnumerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Collections::IEnumerator ^ GetEnumerator();" />
      <MemberSignature Language="F#" Value="abstract member GetEnumerator : unit -&gt; System.Collections.IEnumerator&#xA;override this.GetEnumerator : unit -&gt; System.Collections.IEnumerator" Usage="array.GetEnumerator " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IEnumerable.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Devuelve una interfaz <see cref="T:System.Collections.IEnumerator" /> para la interfaz <see cref="T:System.Array" />.</summary>
        <returns>Estructura <see cref="T:System.Collections.IEnumerator" /> para la colección <see cref="T:System.Array" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 [Visual Basic, C#]  
  
 El `foreach` instrucción del lenguaje C# (`for each` en C++, `For Each` en Visual Basic) oculta la complejidad de los enumeradores. Por lo tanto, se recomienda el uso de `foreach`, en lugar de manipular directamente el enumerador.  
  
 Los enumeradores pueden usarse para leer los datos de la colección, pero no para modificar la colección subyacente.  
  
 En principio, el enumerador se coloca antes del primer elemento de la colección. <xref:System.Collections.IEnumerator.Reset%2A> también devuelve el enumerador a esta posición.  En esta posición, el valor de propiedad <xref:System.Collections.IEnumerator.Current%2A> está sin definir. Por lo tanto, debe llamar a <xref:System.Collections.IEnumerator.MoveNext%2A> para adelantar el enumerador hasta el primer elemento de la colección antes de leer el valor de <xref:System.Collections.IEnumerator.Current%2A>.  
  
 <xref:System.Collections.IEnumerator.Current%2A> devuelve el mismo objeto hasta que se llama a <xref:System.Collections.IEnumerator.MoveNext%2A> o a <xref:System.Collections.IEnumerator.Reset%2A>. <xref:System.Collections.IEnumerator.MoveNext%2A> establece <xref:System.Collections.IEnumerator.Current%2A> en el siguiente elemento.  
  
 Si <xref:System.Collections.IEnumerator.MoveNext%2A> pasa el final de la colección, el enumerador se coloca después del último elemento de la colección y <xref:System.Collections.IEnumerator.MoveNext%2A> devuelve `false`. Cuando el enumerador está en esta posición, las llamadas subsiguientes a <xref:System.Collections.IEnumerator.MoveNext%2A> también devolver `false`. Si la última llamada a <xref:System.Collections.IEnumerator.MoveNext%2A> devuelve `false`, <xref:System.Collections.IEnumerator.Current%2A> es indefinido. Para volver a establecer el valor de <xref:System.Collections.IEnumerator.Current%2A> en el primer elemento de la colección, se puede llamar primero a <xref:System.Collections.IEnumerator.Reset%2A> y después a <xref:System.Collections.IEnumerator.MoveNext%2A>.  
  
 Un enumerador es válido mientras la colección no cambie. Si se hacen cambios en la colección (como agregar, modificar o eliminar elementos), el enumerador queda invalidado permanentemente y su comportamiento es indefinido.  
  
 La enumeración en una colección no es un procedimiento seguro para subprocesos ya que el enumerador carece de acceso exclusivo.  A fin de garantizar la seguridad de los subprocesos, se puede bloquear la colección durante toda la enumeración.  Para permitir que varios subprocesos obtengan acceso de lectura y escritura a la colección, debe implementar su propia sincronización.  
  
 Este método es una operación o (1).  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra cómo utilizar <xref:System.Array.GetEnumerator%2A> para enumerar los elementos de una matriz.  
  
 [!code-cpp[System.Array_GetEnumerator#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetEnumerator/CPP/array_getenumerator.cpp#1)]
 [!code-csharp[System.Array_GetEnumerator#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetEnumerator/CS/array_getenumerator.cs#1)]
 [!code-vb[System.Array_GetEnumerator#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetEnumerator/VB/array_getenumerator.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetLength">
      <MemberSignature Language="C#" Value="public int GetLength (int dimension);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 GetLength(int32 dimension) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.GetLength(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetLength (dimension As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int GetLength(int dimension);" />
      <MemberSignature Language="F#" Value="member this.GetLength : int -&gt; int" Usage="array.GetLength dimension" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dimension" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="dimension">Dimensión de base cero de <see cref="T:System.Array" /> cuya longitud debe determinarse.</param>
        <summary>Obtiene un entero de 32 bits que representa el número de elementos de la dimensión especificada de <see cref="T:System.Array" />.</summary>
        <returns>Entero de 32 bits que representa el número de elementos de la dimensión especificada.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un ejemplo de <xref:System.Array.GetLength%2A> es `GetLength(0)`, que devuelve el número de elementos de la primera dimensión de la <xref:System.Array>.  
  
 Este método es una operación o (1).  
  
   
  
## Examples  
 El ejemplo siguiente muestra cómo usar <xref:System.Array.GetLength%2A> para mostrar las dimensiones de dos matrices con rangos diferentes.  
  
 [!code-cpp[System.Array.GetLength#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.array.getlength/cpp/source.cpp#1)]
 [!code-csharp[System.Array.GetLength#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.array.getlength/cs/source.cs#1)]
 [!code-vb[System.Array.GetLength#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.array.getlength/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IndexOutOfRangeException">
          <paramref name="dimension" /> es menor que cero.  
  
O bien 
 <paramref name="dimension" /> es igual o mayor que <see cref="P:System.Array.Rank" />.</exception>
        <altmember cref="P:System.Array.Length" />
        <altmember cref="M:System.Array.GetLongLength(System.Int32)" />
        <altmember cref="P:System.Collections.ICollection.Count" />
        <altmember cref="P:System.Array.Rank" />
      </Docs>
    </Member>
    <Member MemberName="GetLongLength">
      <MemberSignature Language="C#" Value="public long GetLongLength (int dimension);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int64 GetLongLength(int32 dimension) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.GetLongLength(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetLongLength (dimension As Integer) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; long GetLongLength(int dimension);" />
      <MemberSignature Language="F#" Value="member this.GetLongLength : int -&gt; int64" Usage="array.GetLongLength dimension" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dimension" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="dimension">Dimensión de base cero de <see cref="T:System.Array" /> cuya longitud debe determinarse.</param>
        <summary>Obtiene un entero de 64 bits que representa el número de elementos de la dimensión especificada de <see cref="T:System.Array" />.</summary>
        <returns>Entero de 64 bits que representa el número de elementos de la dimensión especificada.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un ejemplo de <xref:System.Array.GetLongLength%2A> es `GetLongLength(0)`, que devuelve el número de elementos de la primera dimensión de la <xref:System.Array>.  
  
 Este método es una operación o (1).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IndexOutOfRangeException">
          <paramref name="dimension" /> es menor que cero.  
  
O bien 
 <paramref name="dimension" /> es igual o mayor que <see cref="P:System.Array.Rank" />.</exception>
        <altmember cref="P:System.Array.Length" />
        <altmember cref="M:System.Array.GetLength(System.Int32)" />
        <altmember cref="P:System.Collections.ICollection.Count" />
        <altmember cref="P:System.Array.Rank" />
      </Docs>
    </Member>
    <Member MemberName="GetLowerBound">
      <MemberSignature Language="C#" Value="public int GetLowerBound (int dimension);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 GetLowerBound(int32 dimension) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.GetLowerBound(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetLowerBound (dimension As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int GetLowerBound(int dimension);" />
      <MemberSignature Language="F#" Value="member this.GetLowerBound : int -&gt; int" Usage="array.GetLowerBound dimension" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dimension" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="dimension">Dimensión de base cero de la matriz cuyo índice de inicio debe determinarse.</param>
        <summary>Obtiene el índice del primer elemento de la dimensión especificada en la matriz.</summary>
        <returns>Índice del primer elemento de la dimensión especificada en la matriz.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `GetLowerBound(0)` Devuelve el índice inicial de la primera dimensión de la matriz, y `GetLowerBound(Rank - 1)` devuelve el índice inicial de la última dimensión de la matriz.  
  
 El <xref:System.Array.GetLowerBound%2A> método siempre devuelve un valor que indica el índice del límite inferior de la matriz, incluso si la matriz está vacía.  
  
 Tenga en cuenta que, aunque la mayoría de las matrices de .NET Framework está basadas en cero (es decir, el <xref:System.Array.GetLowerBound%2A> método devuelve cero para cada dimensión de una matriz), .NET Framework es compatible con matrices que no son de base cero. Estas matrices se pueden crear con el <xref:System.Array.CreateInstance%28System.Type%2CSystem.Int32%5B%5D%2CSystem.Int32%5B%5D%29> método y también se puede devolver desde código no administrado.  
  
 Este método es una operación o (1).  
  
   
  
## Examples  
 En el ejemplo siguiente se usa el <xref:System.Array.GetLowerBound%2A> y <xref:System.Array.GetUpperBound%2A> métodos para mostrar los límites de una matriz unidimensional y bidimensional y para mostrar los valores de sus elementos de matriz.  
  
 [!code-cpp[System.Array.GetUpperBound#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.array.getupperbound/cpp/source.cpp#1)]
 [!code-csharp[System.Array.GetUpperBound#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.array.getupperbound/cs/source.cs#1)]
 [!code-vb[System.Array.GetUpperBound#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.array.getupperbound/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IndexOutOfRangeException">
          <paramref name="dimension" /> es menor que cero.  
  
O bien 
 <paramref name="dimension" /> es igual o mayor que <see cref="P:System.Array.Rank" />.</exception>
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="P:System.Array.Rank" />
      </Docs>
    </Member>
    <Member MemberName="GetUpperBound">
      <MemberSignature Language="C#" Value="public int GetUpperBound (int dimension);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 GetUpperBound(int32 dimension) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.GetUpperBound(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetUpperBound (dimension As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int GetUpperBound(int dimension);" />
      <MemberSignature Language="F#" Value="member this.GetUpperBound : int -&gt; int" Usage="array.GetUpperBound dimension" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dimension" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="dimension">Dimensión de base cero de la matriz cuyo límite superior debe determinarse.</param>
        <summary>Obtiene el índice del último elemento de la dimensión especificada en la matriz.</summary>
        <returns>Índice del último elemento de la dimensión especificada en la matriz o -1 si la dimensión especificada está vacía.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `GetUpperBound(0)` Devuelve el último índice de la primera dimensión de la matriz, y `GetUpperBound(Rank - 1)` devuelve el último índice de la última dimensión de la matriz.  
  
 Este método es una operación o (1).  
  
   
  
## Examples  
 En el ejemplo siguiente se usa el <xref:System.Array.GetLowerBound%2A> y <xref:System.Array.GetUpperBound%2A> métodos para mostrar los límites de una matriz unidimensional y bidimensional y para mostrar los valores de sus elementos de matriz.  
  
 [!code-cpp[System.Array.GetUpperBound#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.array.getupperbound/cpp/source.cpp#1)]
 [!code-csharp[System.Array.GetUpperBound#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.array.getupperbound/cs/source.cs#1)]
 [!code-vb[System.Array.GetUpperBound#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.array.getupperbound/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IndexOutOfRangeException">
          <paramref name="dimension" /> es menor que cero.  
  
O bien 
 <paramref name="dimension" /> es igual o mayor que <see cref="P:System.Array.Rank" />.</exception>
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="P:System.Array.Rank" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetValue">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Obtiene el valor del elemento especificado de la <see cref="T:System.Array" /> actual.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetValue">
      <MemberSignature Language="C#" Value="public object GetValue (int index);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object GetValue(int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.GetValue(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetValue (index As Integer) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ GetValue(int index);" />
      <MemberSignature Language="F#" Value="member this.GetValue : int -&gt; obj" Usage="array.GetValue index" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">Entero de 32 bits que representa la posición del elemento <see cref="T:System.Array" /> que se va a obtener.</param>
        <summary>Obtiene el valor de la posición especificada de la matriz <see cref="T:System.Array" /> unidimensional. El índice se especifica como un entero de 32 bits.</summary>
        <returns>Valor de la posición especificada de la matriz <see cref="T:System.Array" /> unidimensional.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Array.GetLowerBound%2A> y <xref:System.Array.GetUpperBound%2A> métodos pueden determinar si el valor de `index` je MIMO rozsah.  
  
 Este método es una operación o (1).  
  
   
  
## Examples  
 El ejemplo de código siguiente muestra cómo establecer y obtener un valor específico en una matriz unidimensional o multidimensional.  
  
 [!code-cpp[System.Array_GetSetValue#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetSetValue/CPP/array_getsetvalue.cpp#1)]
 [!code-csharp[System.Array_GetSetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetSetValue/CS/array_getsetvalue.cs#1)]
 [!code-vb[System.Array_GetSetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetSetValue/VB/array_getsetvalue.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">El <see cref="T:System.Array" /> actual no tiene exactamente una dimensión.</exception>
        <exception cref="T:System.IndexOutOfRangeException">
          <paramref name="index" /> está fuera del intervalo de índices válidos para el <see cref="T:System.Array" /> actual.</exception>
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="Overload:System.Array.SetValue" />
      </Docs>
    </Member>
    <Member MemberName="GetValue">
      <MemberSignature Language="C#" Value="public object GetValue (params int[] indices);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object GetValue(int32[] indices) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.GetValue(System.Int32[])" />
      <MemberSignature Language="VB.NET" Value="Public Function GetValue (ParamArray indices As Integer()) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ GetValue(... cli::array &lt;int&gt; ^ indices);" />
      <MemberSignature Language="F#" Value="member this.GetValue : int[] -&gt; obj" Usage="array.GetValue indices" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="indices" Type="System.Int32[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="indices">Matriz unidimensional de enteros de 32 bits que representan los índices que especifican la posición del elemento <see cref="T:System.Array" /> que se debe obtener.</param>
        <summary>Obtiene el valor de la posición especificada de <see cref="T:System.Array" /> multidimensional. Los índices se especifican en forma de una matriz de enteros de 32 bits.</summary>
        <returns>Valor de la posición especificada en la <see cref="T:System.Array" /> multidimensional.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El número de elementos de `indices` debe ser igual al número de dimensiones en el <xref:System.Array>. Todos los elementos de la `indices` matriz colectivamente debe especificar la posición del elemento deseado en multidimensional <xref:System.Array>.  
  
 El <xref:System.Array.GetLowerBound%2A> y <xref:System.Array.GetUpperBound%2A> métodos pueden determinar si alguno de los índices queda fuera de los límites.  
  
 Este método es una operación o (1).  
  
   
  
## Examples  
 El ejemplo de código siguiente muestra cómo establecer y obtener un valor específico en una matriz unidimensional o multidimensional.  
  
 [!code-cpp[System.Array_GetSetValue#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetSetValue/CPP/array_getsetvalue.cpp#1)]
 [!code-csharp[System.Array_GetSetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetSetValue/CS/array_getsetvalue.cs#1)]
 [!code-vb[System.Array_GetSetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetSetValue/VB/array_getsetvalue.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El valor de <paramref name="indices" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">El número de dimensiones de la <see cref="T:System.Array" /> actual no es igual al número de elementos de <paramref name="indices" />.</exception>
        <exception cref="T:System.IndexOutOfRangeException">Cualquier elemento de <paramref name="indices" /> está fuera del intervalo de índices válidos para la dimensión correspondiente de la <see cref="T:System.Array" /> actual.</exception>
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="Overload:System.Array.SetValue" />
      </Docs>
    </Member>
    <Member MemberName="GetValue">
      <MemberSignature Language="C#" Value="public object GetValue (long index);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object GetValue(int64 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.GetValue(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetValue (index As Long) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ GetValue(long index);" />
      <MemberSignature Language="F#" Value="member this.GetValue : int64 -&gt; obj" Usage="array.GetValue index" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="index">Entero de 64 bits que representa la posición del elemento <see cref="T:System.Array" /> que se va a obtener.</param>
        <summary>Obtiene el valor de la posición especificada de la matriz <see cref="T:System.Array" /> unidimensional. El índice se especifica como un entero de 64 bits.</summary>
        <returns>Valor de la posición especificada de la matriz <see cref="T:System.Array" /> unidimensional.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Array.GetLowerBound%2A> y <xref:System.Array.GetUpperBound%2A> métodos pueden determinar si el valor de `index` je MIMO rozsah.  
  
 Este método es una operación o (1).  
  
   
  
## Examples  
 El ejemplo de código siguiente muestra cómo establecer y obtener un valor específico en una matriz unidimensional o multidimensional.  
  
 [!code-cpp[System.Array_GetSetValue#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetSetValue/CPP/array_getsetvalue.cpp#1)]
 [!code-csharp[System.Array_GetSetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetSetValue/CS/array_getsetvalue.cs#1)]
 [!code-vb[System.Array_GetSetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetSetValue/VB/array_getsetvalue.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">El <see cref="T:System.Array" /> actual no tiene exactamente una dimensión.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> está fuera del intervalo de índices válidos para el <see cref="T:System.Array" /> actual.</exception>
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="Overload:System.Array.SetValue" />
      </Docs>
    </Member>
    <Member MemberName="GetValue">
      <MemberSignature Language="C#" Value="public object GetValue (params long[] indices);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object GetValue(int64[] indices) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.GetValue(System.Int64[])" />
      <MemberSignature Language="VB.NET" Value="Public Function GetValue (ParamArray indices As Long()) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ GetValue(... cli::array &lt;long&gt; ^ indices);" />
      <MemberSignature Language="F#" Value="member this.GetValue : int64[] -&gt; obj" Usage="array.GetValue indices" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="indices" Type="System.Int64[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="indices">Matriz unidimensional de enteros de 64 bits que representan los índices que especifican la posición del elemento <see cref="T:System.Array" /> que se va a obtener.</param>
        <summary>Obtiene el valor de la posición especificada de <see cref="T:System.Array" /> multidimensional. Los índices se especifican en forma de una matriz de enteros de 64 bits.</summary>
        <returns>Valor de la posición especificada en la <see cref="T:System.Array" /> multidimensional.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El número de elementos de `indices` debe ser igual al número de dimensiones en el <xref:System.Array>. Todos los elementos de la `indices` matriz colectivamente debe especificar la posición del elemento deseado en multidimensional <xref:System.Array>.  
  
 El <xref:System.Array.GetLowerBound%2A> y <xref:System.Array.GetUpperBound%2A> métodos pueden determinar si alguno de los índices queda fuera de los límites.  
  
 Este método es una operación o (1).  
  
   
  
## Examples  
 El ejemplo de código siguiente muestra cómo establecer y obtener un valor específico en una matriz unidimensional o multidimensional.  
  
 [!code-cpp[System.Array_GetSetValue#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetSetValue/CPP/array_getsetvalue.cpp#1)]
 [!code-csharp[System.Array_GetSetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetSetValue/CS/array_getsetvalue.cs#1)]
 [!code-vb[System.Array_GetSetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetSetValue/VB/array_getsetvalue.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El valor de <paramref name="indices" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">El número de dimensiones de la <see cref="T:System.Array" /> actual no es igual al número de elementos de <paramref name="indices" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Cualquier elemento de <paramref name="indices" /> está fuera del intervalo de índices válidos para la dimensión correspondiente de la <see cref="T:System.Array" /> actual.</exception>
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="Overload:System.Array.SetValue" />
      </Docs>
    </Member>
    <Member MemberName="GetValue">
      <MemberSignature Language="C#" Value="public object GetValue (int index1, int index2);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object GetValue(int32 index1, int32 index2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.GetValue(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetValue (index1 As Integer, index2 As Integer) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ GetValue(int index1, int index2);" />
      <MemberSignature Language="F#" Value="member this.GetValue : int * int -&gt; obj" Usage="array.GetValue (index1, index2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index1" Type="System.Int32" />
        <Parameter Name="index2" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index1">Entero de 32 bits que representa el índice de la primera dimensión del elemento <see cref="T:System.Array" /> que se va a obtener.</param>
        <param name="index2">Entero de 32 bits que representa el índice de la segunda dimensión del elemento <see cref="T:System.Array" /> que se va a obtener.</param>
        <summary>Obtiene el valor de la posición especificada de la matriz bidimensional <see cref="T:System.Array" />. Los índices se especifican como enteros de 32 bits.</summary>
        <returns>Valor de la posición especificada de la <see cref="T:System.Array" /> bidimensional.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Array.GetLowerBound%2A> y <xref:System.Array.GetUpperBound%2A> métodos pueden determinar si alguno de los índices queda fuera de los límites.  
  
 Este método es una operación o (1).  
  
   
  
## Examples  
 El ejemplo de código siguiente muestra cómo establecer y obtener un valor específico en una matriz unidimensional o multidimensional.  
  
 [!code-cpp[System.Array_GetSetValue#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetSetValue/CPP/array_getsetvalue.cpp#1)]
 [!code-csharp[System.Array_GetSetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetSetValue/CS/array_getsetvalue.cs#1)]
 [!code-vb[System.Array_GetSetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetSetValue/VB/array_getsetvalue.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">El <see cref="T:System.Array" /> actual no tiene exactamente dos dimensiones.</exception>
        <exception cref="T:System.IndexOutOfRangeException">
          <paramref name="index1" /> o <paramref name="index2" /> está fuera del intervalo de índices válidos para la dimensión correspondiente del <see cref="T:System.Array" /> actual.</exception>
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="Overload:System.Array.SetValue" />
      </Docs>
    </Member>
    <Member MemberName="GetValue">
      <MemberSignature Language="C#" Value="public object GetValue (long index1, long index2);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object GetValue(int64 index1, int64 index2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.GetValue(System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetValue (index1 As Long, index2 As Long) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ GetValue(long index1, long index2);" />
      <MemberSignature Language="F#" Value="member this.GetValue : int64 * int64 -&gt; obj" Usage="array.GetValue (index1, index2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index1" Type="System.Int64" />
        <Parameter Name="index2" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="index1">Entero de 64 bits que representa el índice de la primera dimensión del elemento <see cref="T:System.Array" /> que se va a obtener.</param>
        <param name="index2">Entero de 64 bits que representa el índice de la segunda dimensión del elemento <see cref="T:System.Array" /> que se va a obtener.</param>
        <summary>Obtiene el valor de la posición especificada de la matriz bidimensional <see cref="T:System.Array" />. Los índices se especifican como enteros de 64 bits.</summary>
        <returns>Valor de la posición especificada de la <see cref="T:System.Array" /> bidimensional.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Array.GetLowerBound%2A> y <xref:System.Array.GetUpperBound%2A> métodos pueden determinar si alguno de los índices queda fuera de los límites.  
  
 Este método es una operación o (1).  
  
   
  
## Examples  
 El ejemplo de código siguiente muestra cómo establecer y obtener un valor específico en una matriz unidimensional o multidimensional.  
  
 [!code-cpp[System.Array_GetSetValue#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetSetValue/CPP/array_getsetvalue.cpp#1)]
 [!code-csharp[System.Array_GetSetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetSetValue/CS/array_getsetvalue.cs#1)]
 [!code-vb[System.Array_GetSetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetSetValue/VB/array_getsetvalue.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">El <see cref="T:System.Array" /> actual no tiene exactamente dos dimensiones.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index1" /> o <paramref name="index2" /> está fuera del intervalo de índices válidos para la dimensión correspondiente del <see cref="T:System.Array" /> actual.</exception>
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="Overload:System.Array.SetValue" />
      </Docs>
    </Member>
    <Member MemberName="GetValue">
      <MemberSignature Language="C#" Value="public object GetValue (int index1, int index2, int index3);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object GetValue(int32 index1, int32 index2, int32 index3) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.GetValue(System.Int32,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetValue (index1 As Integer, index2 As Integer, index3 As Integer) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ GetValue(int index1, int index2, int index3);" />
      <MemberSignature Language="F#" Value="member this.GetValue : int * int * int -&gt; obj" Usage="array.GetValue (index1, index2, index3)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index1" Type="System.Int32" />
        <Parameter Name="index2" Type="System.Int32" />
        <Parameter Name="index3" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index1">Entero de 32 bits que representa el índice de la primera dimensión del elemento <see cref="T:System.Array" /> que se va a obtener.</param>
        <param name="index2">Entero de 32 bits que representa el índice de la segunda dimensión del elemento <see cref="T:System.Array" /> que se va a obtener.</param>
        <param name="index3">Entero de 32 bits que representa el índice de la tercera dimensión del elemento <see cref="T:System.Array" /> que se va a obtener.</param>
        <summary>Obtiene el valor de la posición especificada de la matriz <see cref="T:System.Array" /> tridimensional. Los índices se especifican como enteros de 32 bits.</summary>
        <returns>Valor de la posición especificada de la <see cref="T:System.Array" /> tridimensional.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Array.GetLowerBound%2A> y <xref:System.Array.GetUpperBound%2A> métodos pueden determinar si alguno de los índices queda fuera de los límites.  
  
 Este método es una operación o (1).  
  
   
  
## Examples  
 El ejemplo de código siguiente muestra cómo establecer y obtener un valor específico en una matriz unidimensional o multidimensional.  
  
 [!code-cpp[System.Array_GetSetValue#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetSetValue/CPP/array_getsetvalue.cpp#1)]
 [!code-csharp[System.Array_GetSetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetSetValue/CS/array_getsetvalue.cs#1)]
 [!code-vb[System.Array_GetSetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetSetValue/VB/array_getsetvalue.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">El <see cref="T:System.Array" /> actual no tiene exactamente tres dimensiones.</exception>
        <exception cref="T:System.IndexOutOfRangeException">
          <paramref name="index1" />, <paramref name="index2" /> o <paramref name="index3" /> está fuera del intervalo de índices válidos para la dimensión correspondiente del <see cref="T:System.Array" /> actual.</exception>
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="Overload:System.Array.SetValue" />
      </Docs>
    </Member>
    <Member MemberName="GetValue">
      <MemberSignature Language="C#" Value="public object GetValue (long index1, long index2, long index3);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object GetValue(int64 index1, int64 index2, int64 index3) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.GetValue(System.Int64,System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetValue (index1 As Long, index2 As Long, index3 As Long) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ GetValue(long index1, long index2, long index3);" />
      <MemberSignature Language="F#" Value="member this.GetValue : int64 * int64 * int64 -&gt; obj" Usage="array.GetValue (index1, index2, index3)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index1" Type="System.Int64" />
        <Parameter Name="index2" Type="System.Int64" />
        <Parameter Name="index3" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="index1">Entero de 64 bits que representa el índice de la primera dimensión del elemento <see cref="T:System.Array" /> que se va a obtener.</param>
        <param name="index2">Entero de 64 bits que representa el índice de la segunda dimensión del elemento <see cref="T:System.Array" /> que se va a obtener.</param>
        <param name="index3">Entero de 64 bits que representa el índice de la tercera dimensión del elemento <see cref="T:System.Array" /> que se va a obtener.</param>
        <summary>Obtiene el valor de la posición especificada de la matriz <see cref="T:System.Array" /> tridimensional. Los índices se especifican como enteros de 64 bits.</summary>
        <returns>Valor de la posición especificada de la <see cref="T:System.Array" /> tridimensional.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Array.GetLowerBound%2A> y <xref:System.Array.GetUpperBound%2A> métodos pueden determinar si alguno de los índices queda fuera de los límites.  
  
 Este método es una operación o (1).  
  
   
  
## Examples  
 El ejemplo de código siguiente muestra cómo establecer y obtener un valor específico en una matriz unidimensional o multidimensional.  
  
 [!code-cpp[System.Array_GetSetValue#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetSetValue/CPP/array_getsetvalue.cpp#1)]
 [!code-csharp[System.Array_GetSetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetSetValue/CS/array_getsetvalue.cs#1)]
 [!code-vb[System.Array_GetSetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetSetValue/VB/array_getsetvalue.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">El <see cref="T:System.Array" /> actual no tiene exactamente tres dimensiones.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index1" />, <paramref name="index2" /> o <paramref name="index3" /> está fuera del intervalo de índices válidos para la dimensión correspondiente del <see cref="T:System.Array" /> actual.</exception>
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="Overload:System.Array.SetValue" />
      </Docs>
    </Member>
    <MemberGroup MemberName="IndexOf">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Busca el objeto especificado y devuelve el índice de la primera aparición en una matriz unidimensional o en un intervalo de elementos de la matriz.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public static int IndexOf (Array array, object value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 IndexOf(class System.Array array, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.IndexOf(System.Array,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int IndexOf(Array ^ array, System::Object ^ value);" />
      <MemberSignature Language="F#" Value="static member IndexOf : Array * obj -&gt; int" Usage="System.Array.IndexOf (array, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="array">Matriz unidimensional en la que se va a buscar.</param>
        <param name="value">Objeto que se va a buscar en <paramref name="array" />.</param>
        <summary>Busca el objeto especificado y devuelve el índice de su primera aparición en una matriz unidimensional.</summary>
        <returns>Índice de la primera aparición de <paramref name="value" /> en la matriz <paramref name="array" />, si se encuentra; en caso contrario, límite inferior de la matriz menos 1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método busca en todos los elementos de un arrayfor unidimensional `value`. Para determinar si `value` existe en `array`, el método realiza una comparación de igualdad mediante una llamada a cada elemento `Equals` método hasta que encuentra una coincidencia. Esto significa que si el elemento invalida la <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> , esa invalidación se llama al método.  
  
 Dado que la mayoría de las matrices tienen un límite inferior de cero, este método normalmente devuelve – 1 si`value` no se encuentra. En el extraño caso de que el límite inferior de la matriz es igual a <xref:System.Int32.MinValue?displayProperty=nameWithType>(0 x 80000000) y `value` no se encuentra, este método devuelve <xref:System.Int32.MaxValue?displayProperty=nameWithType> (0x7FFFFFFF).  
  
 Este método es O (`n`) operación, donde `n` es el <xref:System.Array.Length%2A> de `array`.  
  
   
  
## Examples  
 El ejemplo llama a las tres siguientes sobrecargas de los <xref:System.Array.IndexOf%2A> método para encontrar el índice de una cadena en una matriz de cadenas:  
  
-   <xref:System.Array.IndexOf%28System.Array%2CSystem.Object%29>, para determinar la primera aparición de la cadena "the" en una matriz de cadenas.  
  
-   <xref:System.Array.IndexOf%28System.Array%2CSystem.Object%2CSystem.Int32%29>, para determinar la primera aparición de la cadena "the" en la cuarta a los últimos elementos de una matriz de cadenas.  
  
-   <xref:System.Array.IndexOf%28System.Array%2CSystem.Object%2CSystem.Int32%2CSystem.Int32%29>, para determinar la primera aparición de la cadena "the" en una cadena de matriz del elemento que sigue a la última coincidencia encontrada hasta el final de la matriz.  
  
 [!code-cpp[Classic Array.IndexOf Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.IndexOf Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.IndexOf Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.IndexOf Example/CS/source.cs#1)]
 [!code-vb[Classic Array.IndexOf Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.IndexOf Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El valor de <paramref name="array" /> es <see langword="null" />.</exception>
        <exception cref="T:System.RankException">
          <paramref name="array" /> es multidimensional.</exception>
        <altmember cref="Overload:System.Array.LastIndexOf" />
      </Docs>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public static int IndexOf (Array array, object value, int startIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 IndexOf(class System.Array array, object value, int32 startIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.IndexOf(System.Array,System.Object,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int IndexOf(Array ^ array, System::Object ^ value, int startIndex);" />
      <MemberSignature Language="F#" Value="static member IndexOf : Array * obj * int -&gt; int" Usage="System.Array.IndexOf (array, value, startIndex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="startIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">Matriz unidimensional en la que se va a buscar.</param>
        <param name="value">Objeto que se va a buscar en <paramref name="array" />.</param>
        <param name="startIndex">Índice inicial de la búsqueda. 0 (cero) es válido en una matriz vacía.</param>
        <summary>Busca el objeto especificado en un intervalo de elementos de la matriz unidimensional y devuelve el índice de su primera aparición. El intervalo se extiende desde un índice especificado hasta el final de la matriz.</summary>
        <returns>Índice de la primera aparición de <paramref name="value" />, si se encuentra una, en el intervalo de elementos de <paramref name="array" /> que se extiende desde <paramref name="startIndex" /> hasta el último elemento; en caso contrario, límite inferior de la matriz menos 1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método busca en una matriz unidimensional del elemento en el índice `startIndex` hasta el último elemento. Para determinar si `value` existe en `array`, el método realiza una comparación de igualdad mediante una llamada a la `Equals` método de todos los elementos hasta que encuentra una coincidencia. Esto significa que si el elemento invalida la <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> , esa invalidación se llama al método.  
  
 Dado que la mayoría de las matrices tienen un límite inferior de cero, este método normalmente devuelve – 1 si `value` no se encuentra. En el extraño caso de que el límite inferior de la matriz es igual a <xref:System.Int32.MinValue?displayProperty=nameWithType>(0 x 80000000) y `value` no se encuentra, este método devuelve <xref:System.Int32.MaxValue?displayProperty=nameWithType> (0x7FFFFFFF).  
  
 Si `startIndex` es igual a <xref:System.Array.Length%2A?displayProperty=nameWithType>, el método devuelve -1. Si `startIndex` es mayor que <xref:System.Array.Length%2A?displayProperty=nameWithType>, el método produce una <xref:System.ArgumentOutOfRangeException>.  
  
 Este método es O (`n`) operación, donde `n` es el número de elementos de `startIndex` al final de `array`.  
  
   
  
## Examples  
 El ejemplo llama a las tres siguientes sobrecargas de los <xref:System.Array.IndexOf%2A> método para encontrar el índice de una cadena en una matriz de cadenas:  
  
-   <xref:System.Array.IndexOf%28System.Array%2CSystem.Object%29>, para determinar la primera aparición de la cadena "the" en una matriz de cadenas.  
  
-   <xref:System.Array.IndexOf%28System.Array%2CSystem.Object%2CSystem.Int32%29>, para determinar la primera aparición de la cadena "the" en la cuarta a los últimos elementos de una matriz de cadenas.  
  
-   <xref:System.Array.IndexOf%28System.Array%2CSystem.Object%2CSystem.Int32%2CSystem.Int32%29>, para determinar la primera aparición de la cadena "the" en una cadena de matriz del elemento que sigue a la última coincidencia encontrada hasta el final de la matriz.  
  
 [!code-cpp[Classic Array.IndexOf Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.IndexOf Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.IndexOf Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.IndexOf Example/CS/source.cs#1)]
 [!code-vb[Classic Array.IndexOf Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.IndexOf Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El valor de <paramref name="array" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" /> está fuera del intervalo de índices válidos para <paramref name="array" />.</exception>
        <exception cref="T:System.RankException">
          <paramref name="array" /> es multidimensional.</exception>
        <altmember cref="Overload:System.Array.LastIndexOf" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">Realizar operaciones de cadenas que no tienen en cuenta las referencias culturales en matrices</related>
      </Docs>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public static int IndexOf (Array array, object value, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 IndexOf(class System.Array array, object value, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.IndexOf(System.Array,System.Object,System.Int32,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int IndexOf(Array ^ array, System::Object ^ value, int startIndex, int count);" />
      <MemberSignature Language="F#" Value="static member IndexOf : Array * obj * int * int -&gt; int" Usage="System.Array.IndexOf (array, value, startIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">Matriz unidimensional en la que se va a buscar.</param>
        <param name="value">Objeto que se va a buscar en <paramref name="array" />.</param>
        <param name="startIndex">Índice inicial de la búsqueda. 0 (cero) es válido en una matriz vacía.</param>
        <param name="count">Número de elementos que se van a buscar.</param>
        <summary>Busca el objeto especificado en un intervalo de elementos de una matriz unidimensional y devuelve el índice de su primera aparición. El intervalo se extiende desde un índice especificado durante un número especificado de elementos.</summary>
        <returns>Índice de la primera aparición de <paramref name="value" />, si se encuentra una, en la matriz <paramref name="array" /> desde el índice <paramref name="startIndex" /> hasta <paramref name="startIndex" /> + <paramref name="count" /> - 1; en caso contrario, límite inferior de la matriz menos 1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método busca en los elementos de un arrayfrom unidimensional `startIndex` a `startIndex` plus `count` menos 1, si `count` es mayor que 0. Para determinar si `value` existe en `array`, el método realiza una comparación de igualdad mediante una llamada a la `Equals` método de todos los elementos hasta que encuentra una coincidencia. Esto significa que si el elemento invalida la <xref:System.Object.Equals%2A?displayProperty=nameWithType> , esa invalidación se llama al método.  
  
 Las matrices de Becausemost tienen un límite inferior de cero, por lo general, este método devuelve-1 cuando `value` no se encuentra. En el extraño caso de que el límite inferior de la matriz es igual a <xref:System.Int32.MinValue?displayProperty=nameWithType> (0 x 80000000) y `value` no se encuentra, este método devuelve <xref:System.Int32.MaxValue?displayProperty=nameWithType> (0x7FFFFFFF).  
  
 Si `startindex` es igual a <xref:System.Array.Length%2A?displayProperty=nameWithType>, el método devuelve -1. Si `startIndex` es mayor que <xref:System.Array.Length%2A?displayProperty=nameWithType>, el método produce una <xref:System.ArgumentOutOfRangeException>.  
  
 Este método es O (`n`) operación, donde `n` es `count`.  
  
   
  
## Examples  
 El ejemplo llama a las tres siguientes sobrecargas de los <xref:System.Array.IndexOf%2A> método para encontrar el índice de una cadena en una matriz de cadenas:  
  
-   <xref:System.Array.IndexOf%28System.Array%2CSystem.Object%29>, para determinar la primera aparición de la cadena "the" en una matriz de cadenas.  
  
-   <xref:System.Array.IndexOf%28System.Array%2CSystem.Object%2CSystem.Int32%29>, para determinar la primera aparición de la cadena "the" en la cuarta a los últimos elementos de una matriz de cadenas.  
  
-   <xref:System.Array.IndexOf%28System.Array%2CSystem.Object%2CSystem.Int32%2CSystem.Int32%29>, para determinar la primera aparición de la cadena "the" en una cadena de matriz del elemento que sigue a la última coincidencia encontrada hasta el final de la matriz. Para determinar el valor de la `count` argumento, se resta el límite superior de la matriz desde el índice de inicio y agrega uno.  
  
 [!code-cpp[Classic Array.IndexOf Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.IndexOf Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.IndexOf Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.IndexOf Example/CS/source.cs#1)]
 [!code-vb[Classic Array.IndexOf Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.IndexOf Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El valor de <paramref name="array" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" /> está fuera del intervalo de índices válidos para la <paramref name="array" />.  
  
O bien 
 <paramref name="count" /> es menor que cero.  
  
O bien 
 <paramref name="startIndex" /> y <paramref name="count" /> no especifican una sección válida en <paramref name="array" />.</exception>
        <exception cref="T:System.RankException">
          <paramref name="array" /> es multidimensional.</exception>
        <altmember cref="Overload:System.Array.LastIndexOf" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">Realizar operaciones de cadenas que no tienen en cuenta las referencias culturales en matrices</related>
      </Docs>
    </Member>
    <Member MemberName="IndexOf&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int IndexOf&lt;T&gt; (T[] array, T value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 IndexOf&lt;T&gt;(!!T[] array, !!T value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.IndexOf``1(``0[],``0)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IndexOf(Of T) (array As T(), value As T) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static int IndexOf(cli::array &lt;T&gt; ^ array, T value);" />
      <MemberSignature Language="F#" Value="static member IndexOf : 'T[] * 'T -&gt; int" Usage="System.Array.IndexOf (array, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="value" Type="T" />
      </Parameters>
      <Docs>
        <typeparam name="T">Tipo de los elementos de la matriz.</typeparam>
        <param name="array">Matriz unidimensional de base cero en la que se va a buscar.</param>
        <param name="value">Objeto que se va a buscar en <paramref name="array" />.</param>
        <summary>Busca el objeto especificado y devuelve el índice de su primera aparición en una matriz unidimensional.</summary>
        <returns>Índice de base cero de la primera aparición de <paramref name="value" /> en la totalidad de <paramref name="array" />, si se encuentra; en caso contrario, -1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método busca en todos los elementos de una matriz unidimensional `value`. Para determinar si `value` existe en `array`, el método realiza una comparación de igualdad mediante una llamada a la `T.Equals` método en cada elemento. Esto significa que si `T` invalida la <xref:System.Object.Equals%2A> , esa invalidación se llama al método.  
  
 Este método es O (`n`) operación, donde `n` es el <xref:System.Array.Length%2A> de `array`.  
  
   
  
## Examples  
 El ejemplo siguiente muestra tres sobrecargas genéricas de los <xref:System.Array.IndexOf%2A> método. Se crea una matriz de cadenas, con una entrada que aparece dos veces, en la ubicación de índice 0 y la ubicación de índice 5. El <xref:System.Array.IndexOf%60%601%28%60%600%5B%5D%2C%60%600%29> sobrecarga del método busca en la matriz desde el principio y busca la primera aparición de la cadena. El <xref:System.Array.IndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%29> sobrecarga del método se utiliza para buscar el principio de la matriz en la posición de índice 3 y continuando hasta el final de la matriz y encuentra la segunda aparición de la cadena. Por último, el <xref:System.Array.IndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%2CSystem.Int32%29> sobrecarga del método se utiliza para buscar un intervalo de dos entradas, comenzando en la posición de índice dos; devuelve -1 porque no hay ninguna instancia de la cadena de búsqueda en ese intervalo.  
  
 [!code-cpp[Array_IndexOf#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_IndexOf/cpp/source.cpp#1)]
 [!code-csharp[Array_IndexOf#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_IndexOf/cs/source.cs#1)]
 [!code-vb[Array_IndexOf#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_IndexOf/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El valor de <paramref name="array" /> es <see langword="null" />.</exception>
        <altmember cref="Overload:System.Array.LastIndexOf" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">Realizar operaciones de cadenas que no tienen en cuenta las referencias culturales en matrices</related>
      </Docs>
    </Member>
    <Member MemberName="IndexOf&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int IndexOf&lt;T&gt; (T[] array, T value, int startIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 IndexOf&lt;T&gt;(!!T[] array, !!T value, int32 startIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.IndexOf``1(``0[],``0,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IndexOf(Of T) (array As T(), value As T, startIndex As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static int IndexOf(cli::array &lt;T&gt; ^ array, T value, int startIndex);" />
      <MemberSignature Language="F#" Value="static member IndexOf : 'T[] * 'T * int -&gt; int" Usage="System.Array.IndexOf (array, value, startIndex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="value" Type="T" />
        <Parameter Name="startIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <typeparam name="T">Tipo de los elementos de la matriz.</typeparam>
        <param name="array">Matriz unidimensional de base cero en la que se va a buscar.</param>
        <param name="value">Objeto que se va a buscar en <paramref name="array" />.</param>
        <param name="startIndex">Índice inicial de base cero de la búsqueda. 0 (cero) es válido en una matriz vacía.</param>
        <summary>Busca el objeto especificado en un intervalo de elementos de la matriz unidimensional y devuelve el índice de su primera aparición. El intervalo se extiende desde un índice especificado hasta el final de la matriz.</summary>
        <returns>Índice de base cero de la primera aparición de <paramref name="value" /> dentro del intervalo de elementos de <paramref name="array" /> que abarca desde <paramref name="startIndex" /> hasta el último elemento, si se encuentra; de lo contrario, –1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método busca en una matriz unidimensional del elemento en el `startIndex` al final de la matriz. Para determinar si `value` existe en `array`, el método realiza una comparación de igualdad mediante una llamada a la `T.Equals` método en cada elemento. Esto significa que si `T` invalida la <xref:System.Object.Equals%2A> , esa invalidación se llama al método.  
  
 Si `startIndex` es igual a <xref:System.Array.Length%2A>, el método devuelve - 1.If `startIndex` es mayor que <xref:System.Array.Length%2A?displayProperty=nameWithType>, el método produce una <xref:System.ArgumentOutOfRangeException>.  
  
 Este método es O (`n`) operación, donde `n` es el número de elementos de `startIndex` al final de `array`.  
  
   
  
## Examples  
 El ejemplo siguiente muestra tres sobrecargas genéricas de los <xref:System.Array.IndexOf%2A> método. Se crea una matriz de cadenas, con una entrada que aparece dos veces, en la ubicación de índice 0 y la ubicación de índice 5. El <xref:System.Array.IndexOf%60%601%28%60%600%5B%5D%2C%60%600%29> sobrecarga del método busca en la matriz desde el principio y busca la primera aparición de la cadena. El <xref:System.Array.IndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%29> sobrecarga del método se utiliza para buscar el principio de la matriz en la posición de índice 3 y continuando hasta el final de la matriz y encuentra la segunda aparición de la cadena. Por último, el <xref:System.Array.IndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%2CSystem.Int32%29> sobrecarga del método se utiliza para buscar un intervalo de dos entradas, comenzando en la posición de índice dos; devuelve -1 porque no hay ninguna instancia de la cadena de búsqueda en ese intervalo.  
  
 [!code-cpp[Array_IndexOf#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_IndexOf/cpp/source.cpp#1)]
 [!code-csharp[Array_IndexOf#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_IndexOf/cs/source.cs#1)]
 [!code-vb[Array_IndexOf#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_IndexOf/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El valor de <paramref name="array" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" /> está fuera del intervalo de índices válidos para la <paramref name="array" />.</exception>
        <altmember cref="Overload:System.Array.LastIndexOf" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">Realizar operaciones de cadenas que no tienen en cuenta las referencias culturales en matrices</related>
      </Docs>
    </Member>
    <Member MemberName="IndexOf&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int IndexOf&lt;T&gt; (T[] array, T value, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 IndexOf&lt;T&gt;(!!T[] array, !!T value, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.IndexOf``1(``0[],``0,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IndexOf(Of T) (array As T(), value As T, startIndex As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static int IndexOf(cli::array &lt;T&gt; ^ array, T value, int startIndex, int count);" />
      <MemberSignature Language="F#" Value="static member IndexOf : 'T[] * 'T * int * int -&gt; int" Usage="System.Array.IndexOf (array, value, startIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="value" Type="T" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <typeparam name="T">Tipo de los elementos de la matriz.</typeparam>
        <param name="array">Matriz unidimensional de base cero en la que se va a buscar.</param>
        <param name="value">Objeto que se va a buscar en <paramref name="array" />.</param>
        <param name="startIndex">Índice inicial de base cero de la búsqueda. 0 (cero) es válido en una matriz vacía.</param>
        <param name="count">Número de elementos de la sección en la que se va a realizar la búsqueda.</param>
        <summary>Busca el objeto especificado en un intervalo de elementos de la matriz unidimensional y devuelve el índice de su primera aparición. El intervalo se extiende desde un índice especificado durante un número especificado de elementos.</summary>
        <returns>Índice de base cero de la primera aparición de <paramref name="value" /> dentro del intervalo de elementos de <paramref name="array" /> que comienza en <paramref name="startIndex" /> y contiene el número de elementos especificados en <paramref name="count" />, si se encuentra; de lo contrario, –1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esta elementos búsquedasLos de método de una matriz unidimensional de `startIndex` a `startIndex` plus `count` menos 1, si `count` es mayor que 0. Para determinar si `value` existe en `array`, el método realiza una comparación de igualdad mediante una llamada a la `T.Equals` método en cada elemento. Esto significa que si `T` invalida la <xref:System.Object.Equals%2A> , esa invalidación se llama al método.  
  
 Si `startIndex` es igual a <xref:System.Array.Length%2A?displayProperty=nameWithType>, el método devuelve -1.  Si `startIndex` es mayor que <xref:System.Array.Length%2A?displayProperty=nameWithType>, el método produce una <xref:System.ArgumentOutOfRangeException>.  
  
 Este método es O (`n`) operación, donde `n` es `count`.  
  
   
  
## Examples  
 El ejemplo siguiente muestra tres sobrecargas genéricas de los <xref:System.Array.IndexOf%2A> método. Se crea una matriz de cadenas, con una entrada que aparece dos veces, en la ubicación de índice 0 y la ubicación de índice 5. El <xref:System.Array.IndexOf%60%601%28%60%600%5B%5D%2C%60%600%29> sobrecarga del método busca en la matriz desde el principio y busca la primera aparición de la cadena. El <xref:System.Array.IndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%29> sobrecarga del método se utiliza para buscar el principio de la matriz en la posición de índice 3 y continuando hasta el final de la matriz y encuentra la segunda aparición de la cadena. Por último, el <xref:System.Array.IndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%2CSystem.Int32%29> sobrecarga del método se utiliza para buscar un intervalo de dos entradas, comenzando en la posición de índice dos; devuelve -1 porque no hay ninguna instancia de la cadena de búsqueda en ese intervalo.  
  
 [!code-cpp[Array_IndexOf#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_IndexOf/cpp/source.cpp#1)]
 [!code-csharp[Array_IndexOf#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_IndexOf/cs/source.cs#1)]
 [!code-vb[Array_IndexOf#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_IndexOf/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El valor de <paramref name="array" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" /> está fuera del intervalo de índices válidos para la <paramref name="array" />.  
  
O bien 
 <paramref name="count" /> es menor que cero.  
  
O bien 
 <paramref name="startIndex" /> y <paramref name="count" /> no especifican una sección válida en <paramref name="array" />.</exception>
        <altmember cref="Overload:System.Array.LastIndexOf" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">Realizar operaciones de cadenas que no tienen en cuenta las referencias culturales en matrices</related>
      </Docs>
    </Member>
    <Member MemberName="Initialize">
      <MemberSignature Language="C#" Value="public void Initialize ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Initialize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Initialize" />
      <MemberSignature Language="VB.NET" Value="Public Sub Initialize ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Initialize();" />
      <MemberSignature Language="F#" Value="member this.Initialize : unit -&gt; unit" Usage="array.Initialize " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Inicializa todos los elementos de la matriz <see cref="T:System.Array" /> de tipo de valor llamando al constructor predeterminado del tipo de valor.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método está diseñado para ayudar a los compiladores compatible con matrices de tipo de valor; la mayoría de los usuarios no es necesario este método. No debe usarse en las matrices de tipo de referencia.  
  
 Si el <xref:System.Array> no es un tipo de valor <xref:System.Array> o si el tipo de valor no tiene un constructor predeterminado, el <xref:System.Array> no se modifica.  
  
 El tipo de valor <xref:System.Array> puede tener cualquier límite inferior y cualquier número de dimensiones.  
  
 Este método es O (`n`) operación, donde `n` es <xref:System.Array.Length%2A>.  
  
> [!CAUTION]
>  Puede usar este método solo en tipos de valor tienen constructores; Sin embargo, los tipos de valor son nativos de C# no tiene constructores.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsFixedSize">
      <MemberSignature Language="C#" Value="public bool IsFixedSize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsFixedSize" />
      <MemberSignature Language="DocId" Value="P:System.Array.IsFixedSize" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsFixedSize As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsFixedSize { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsFixedSize : bool" Usage="System.Array.IsFixedSize" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.IList.IsFixedSize</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene un valor que indica si la interfaz <see cref="T:System.Array" /> tiene un tamaño fijo.</summary>
        <value>Esta propiedad es siempre <see langword="true" /> para todas las matrices.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Array> implementa el <xref:System.Array.IsFixedSize%2A> propiedad porque es necesaria para la <xref:System.Collections.IList?displayProperty=nameWithType> interfaz.  
  
 Una matriz con un tamaño fijo no permite la adición o eliminación de elementos después de crea la matriz, pero sí permite modificar los elementos existentes.  
  
 La recuperación del valor de esta propiedad es una operación O(1).  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.IList" />
        <altmember cref="T:System.Collections.Generic.IList`1" />
      </Docs>
    </Member>
    <Member MemberName="IsReadOnly">
      <MemberSignature Language="C#" Value="public bool IsReadOnly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsReadOnly" />
      <MemberSignature Language="DocId" Value="P:System.Array.IsReadOnly" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsReadOnly As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsReadOnly { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsReadOnly : bool" Usage="System.Array.IsReadOnly" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.IList.IsReadOnly</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene un valor que indica si <see cref="T:System.Array" /> es de solo lectura.</summary>
        <value>Esta propiedad es siempre <see langword="false" /> para todas las matrices.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Array> implementa el <xref:System.Array.IsReadOnly%2A> propiedad porque es necesaria para la <xref:System.Collections.IList?displayProperty=nameWithType> interfaz. Una matriz que es de solo lectura no permite la adición, eliminación o modificación de elementos después de crea la matriz.  
  
 Si necesita una colección de solo lectura, use un <xref:System.Collections> clase que implementa el <xref:System.Collections.IList?displayProperty=nameWithType> interfaz.  
  
 Si convierte o convertir una matriz a un <xref:System.Collections.IList> objeto de interfaz, el <xref:System.Collections.IList.IsReadOnly%2A?displayProperty=nameWithType> propiedad devuelve `false`. Sin embargo, si convierte o convertir una matriz a un <xref:System.Collections.Generic.IList%601> interfaz, el `IsReadOnly` propiedad devuelve `true`.  
  
 La recuperación del valor de esta propiedad es una operación O(1).  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.IList" />
        <altmember cref="N:System.Collections" />
        <altmember cref="T:System.Collections.Generic.IList`1" />
        <altmember cref="N:System.Collections.Generic" />
      </Docs>
    </Member>
    <Member MemberName="IsSynchronized">
      <MemberSignature Language="C#" Value="public bool IsSynchronized { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSynchronized" />
      <MemberSignature Language="DocId" Value="P:System.Array.IsSynchronized" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsSynchronized As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsSynchronized { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSynchronized : bool" Usage="System.Array.IsSynchronized" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.IsSynchronized</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene un valor que indica si el acceso a la interfaz <see cref="T:System.Array" /> está sincronizado (es seguro para subprocesos).</summary>
        <value>Esta propiedad es siempre <see langword="false" /> para todas las matrices.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Array> implementa el <xref:System.Array.IsSynchronized%2A> propiedad porque es necesaria para la <xref:System.Collections.ICollection?displayProperty=nameWithType> interfaz.  
  
 Clases de .NET framework en función de <xref:System.Array> proporcionar su propia versión sincronizada de la colección utilizando el <xref:System.Array.SyncRoot%2A> propiedad.  
  
 Las clases que utilizan matrices también pueden implementar su propia sincronización utilizando la <xref:System.Array.SyncRoot%2A> propiedad. El código de sincronización debe realizar operaciones en el `SyncRoot` de la colección, no directamente en la colección. De este modo, se garantiza el funcionamiento correcto de las colecciones derivadas de otros objetos. En concreto, mantiene la sincronización correcta con otros subprocesos que podrían modificar simultáneamente la colección. Tenga en cuenta que algunas implementaciones de <xref:System.Array.SyncRoot%2A> podría devolver el <xref:System.Array> propio.  
  
 Enumerar una colección no es un procedimiento seguro para subprocesos. Incluso cuando una colección está sincronizada, otros subprocesos todavía pueden modificarla, lo que hace que el enumerador produzca una excepción. Con el fin de garantizar la seguridad para la ejecución de subprocesos durante la enumeración, se puede bloquear la colección durante toda la enumeración o detectar las excepciones resultantes de los cambios realizados por otros subprocesos.  
  
 La recuperación del valor de esta propiedad es una operación O(1).  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra cómo bloquear una matriz durante toda la enumeración mediante el uso de la <xref:System.Array.SyncRoot%2A> propiedad.  
  
 [!code-cpp[System.Array.SyncRoot#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array.SyncRoot/cpp/source.cpp#1)]
 [!code-csharp[System.Array.SyncRoot#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array.SyncRoot/cs/source.cs#1)]
 [!code-vb[System.Array.SyncRoot#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array.SyncRoot/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Array.SyncRoot" />
        <altmember cref="T:System.Collections.ICollection" />
      </Docs>
    </Member>
    <MemberGroup MemberName="LastIndexOf">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Devuelve el índice de la última aparición de un valor en una matriz <see cref="T:System.Array" /> unidimensional o en una parte de la matriz <see cref="T:System.Array" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public static int LastIndexOf (Array array, object value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 LastIndexOf(class System.Array array, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.LastIndexOf(System.Array,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int LastIndexOf(Array ^ array, System::Object ^ value);" />
      <MemberSignature Language="F#" Value="static member LastIndexOf : Array * obj -&gt; int" Usage="System.Array.LastIndexOf (array, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="array">
          <see cref="T:System.Array" /> unidimensional que se va a buscar.</param>
        <param name="value">Objeto que se va a buscar en <paramref name="array" />.</param>
        <summary>Busca el objeto especificado y devuelve el índice de la última aparición en toda la matriz <see cref="T:System.Array" /> unidimensional.</summary>
        <returns>Índice de la última aparición de <paramref name="value" /> en toda la matriz <paramref name="array" />, si se encuentra; en caso contrario, límite inferior de la matriz menos 1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Unidimensional <xref:System.Array> se realiza hacia atrás a partir del último elemento y terminando en el primer elemento.  
  
 Los elementos se comparan con el valor especificado mediante el <xref:System.Object.Equals%2A?displayProperty=nameWithType> método. Si el tipo de elemento es un tipo no intrínseco (definido por el usuario), el `Equals` se utiliza la implementación de ese tipo.  
  
 Como la mayoría de las matrices tienen un límite inferior de cero, este método normalmente devuelve – 1 cuando `value` no se encuentra. En el extraño caso de que el límite inferior de la matriz es igual a <xref:System.Int32.MinValue?displayProperty=nameWithType> y `value` no se encuentra, este método devuelve <xref:System.Int32.MaxValue?displayProperty=nameWithType>, que es `System.Int32.MinValue - 1`.  
  
 Este método es O (`n`) operación, donde `n` es el <xref:System.Array.Length%2A> de `array`.  
  
 En la versión 2.0 de .NET Framework, este método utiliza la <xref:System.Object.Equals%2A> y <xref:System.IComparable.CompareTo%2A> métodos de la <xref:System.Array> para determinar si el <xref:System.Object> especificado por el `value` parámetro existe. En las versiones anteriores de .NET Framework, esta determinación se realiza mediante el uso de la <xref:System.Object.Equals%2A> y <xref:System.IComparable.CompareTo%2A> métodos de la `value` <xref:System.Object> propio.  
  
 <xref:System.IComparable.CompareTo%2A> métodos de la `item` parámetro en los objetos de la colección.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra cómo determinar el índice de la última aparición de un elemento especificado en una matriz.  
  
 [!code-cpp[Classic Array.LastIndexOf Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.LastIndexOf Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.LastIndexOf Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.LastIndexOf Example/CS/source.cs#1)]
 [!code-vb[Classic Array.LastIndexOf Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.LastIndexOf Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El valor de <paramref name="array" /> es <see langword="null" />.</exception>
        <exception cref="T:System.RankException">
          <paramref name="array" /> es multidimensional.</exception>
        <altmember cref="Overload:System.Array.IndexOf" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">Realizar operaciones de cadenas que no tienen en cuenta las referencias culturales en matrices</related>
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public static int LastIndexOf (Array array, object value, int startIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 LastIndexOf(class System.Array array, object value, int32 startIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.LastIndexOf(System.Array,System.Object,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int LastIndexOf(Array ^ array, System::Object ^ value, int startIndex);" />
      <MemberSignature Language="F#" Value="static member LastIndexOf : Array * obj * int -&gt; int" Usage="System.Array.LastIndexOf (array, value, startIndex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="startIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">
          <see cref="T:System.Array" /> unidimensional que se va a buscar.</param>
        <param name="value">Objeto que se va a buscar en <paramref name="array" />.</param>
        <param name="startIndex">Índice inicial de la búsqueda hacia atrás.</param>
        <summary>Busca el objeto especificado y devuelve el índice de la última aparición en el intervalo de elementos de la matriz <see cref="T:System.Array" /> unidimensional que se extiende desde el primer elemento hasta el índice especificado.</summary>
        <returns>Índice de la última aparición de <paramref name="value" /> en el intervalo de elementos de <paramref name="array" /> que se extiende desde el primer elemento hasta <paramref name="startIndex" />, si se encuentra; en caso contrario, límite inferior de la matriz menos 1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Unidimensional <xref:System.Array> es la búsqueda hacia atrás, empezando en `startIndex` y terminando en el primer elemento.  
  
 Los elementos se comparan con el valor especificado mediante el <xref:System.Object.Equals%2A?displayProperty=nameWithType> método. Si el tipo de elemento es un tipo no intrínseco (definido por el usuario), el `Equals` se utiliza la implementación de ese tipo.  
  
 Como la mayoría de las matrices tienen un límite inferior de cero, este método normalmente devuelve – 1 cuando `value` no se encuentra. En el extraño caso de que el límite inferior de la matriz es igual a <xref:System.Int32.MinValue?displayProperty=nameWithType> y `value` no se encuentra, este método devuelve <xref:System.Int32.MaxValue?displayProperty=nameWithType>, que es `System.Int32.MinValue - 1`.  
  
 Este método es O (`n`) operación, donde `n` es el número de elementos desde el principio del `array` a `startIndex`.  
  
 En la versión 2.0 de .NET Framework, este método utiliza la <xref:System.Object.Equals%2A> y <xref:System.IComparable.CompareTo%2A> métodos de la <xref:System.Array> para determinar si el <xref:System.Object> especificado por el `value` parámetro existe. En las versiones anteriores de .NET Framework, esta determinación se realiza mediante el uso de la <xref:System.Object.Equals%2A> y <xref:System.IComparable.CompareTo%2A> métodos de la `value` <xref:System.Object> propio.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra cómo determinar el índice de la última aparición de un elemento especificado en una matriz.  
  
 [!code-cpp[Classic Array.LastIndexOf Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.LastIndexOf Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.LastIndexOf Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.LastIndexOf Example/CS/source.cs#1)]
 [!code-vb[Classic Array.LastIndexOf Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.LastIndexOf Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El valor de <paramref name="array" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" /> está fuera del intervalo de índices válidos para <paramref name="array" />.</exception>
        <exception cref="T:System.RankException">
          <paramref name="array" /> es multidimensional.</exception>
        <altmember cref="Overload:System.Array.IndexOf" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">Realizar operaciones de cadenas que no tienen en cuenta las referencias culturales en matrices</related>
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public static int LastIndexOf (Array array, object value, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 LastIndexOf(class System.Array array, object value, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.LastIndexOf(System.Array,System.Object,System.Int32,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int LastIndexOf(Array ^ array, System::Object ^ value, int startIndex, int count);" />
      <MemberSignature Language="F#" Value="static member LastIndexOf : Array * obj * int * int -&gt; int" Usage="System.Array.LastIndexOf (array, value, startIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">
          <see cref="T:System.Array" /> unidimensional que se va a buscar.</param>
        <param name="value">Objeto que se va a buscar en <paramref name="array" />.</param>
        <param name="startIndex">Índice inicial de la búsqueda hacia atrás.</param>
        <param name="count">Número de elementos de la sección en la que se va a realizar la búsqueda.</param>
        <summary>Busca el objeto especificado y devuelve el índice de la última aparición dentro del intervalo de elementos de la <see cref="T:System.Array" /> unidimensional que contiene el número especificado de elementos y termina en el índice especificado.</summary>
        <returns>El índice de la última aparición de <paramref name="value" /> dentro del intervalo de elementos de <paramref name="array" /> que contiene el número de elementos especificado en <paramref name="count" /> y termina en <paramref name="startIndex" />, si se encuentra; en caso contrario, el límite inferior de la matriz menos 1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Unidimensional <xref:System.Array> es la búsqueda hacia atrás, empezando en `startIndex` hasta `startIndex` menos `count` más 1, si `count` es mayor que 0.  
  
 Los elementos se comparan con el valor especificado mediante el <xref:System.Object.Equals%2A?displayProperty=nameWithType> método. Si el tipo de elemento es un tipo no intrínseco (definido por el usuario), el`Equals` se utiliza la implementación de ese tipo.  
  
 Como la mayoría de las matrices tienen un límite inferior de cero, este método normalmente devuelve – 1 cuando `value` no se encuentra. En el extraño caso de que el límite inferior de la matriz es igual a <xref:System.Int32.MinValue?displayProperty=nameWithType> y `value` no se encuentra, este método devuelve <xref:System.Int32.MaxValue?displayProperty=nameWithType>, que es `System.Int32.MinValue - 1`.  
  
 Este método es O (`n`) operación, donde `n` es `count`.  
  
 En la versión 2.0 de .NET Framework, este método utiliza la <xref:System.Object.Equals%2A> y <xref:System.IComparable.CompareTo%2A> métodos de la <xref:System.Array> para determinar si el <xref:System.Object> especificado por el `value` parámetro existe. En las versiones anteriores de .NET Framework, esta determinación se realiza mediante el uso de la <xref:System.Object.Equals%2A> y <xref:System.IComparable.CompareTo%2A> métodos de la `value` <xref:System.Object> propio.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra cómo determinar el índice de la última aparición de un elemento especificado en una matriz. Tenga en cuenta que el <xref:System.Array.LastIndexOf%2A> método es una búsqueda hacia atrás; por lo tanto, `count` debe ser menor o igual a (`startIndex` menos el límite inferior de la matriz, más 1).  
  
 [!code-cpp[Classic Array.LastIndexOf Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.LastIndexOf Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.LastIndexOf Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.LastIndexOf Example/CS/source.cs#1)]
 [!code-vb[Classic Array.LastIndexOf Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.LastIndexOf Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El valor de <paramref name="array" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" /> está fuera del intervalo de índices válidos para la <paramref name="array" />.  
  
O bien 
 <paramref name="count" /> es menor que cero.  
  
O bien 
 <paramref name="startIndex" /> y <paramref name="count" /> no especifican una sección válida en <paramref name="array" />.</exception>
        <exception cref="T:System.RankException">
          <paramref name="array" /> es multidimensional.</exception>
        <altmember cref="Overload:System.Array.IndexOf" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">Realizar operaciones de cadenas que no tienen en cuenta las referencias culturales en matrices</related>
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int LastIndexOf&lt;T&gt; (T[] array, T value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 LastIndexOf&lt;T&gt;(!!T[] array, !!T value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.LastIndexOf``1(``0[],``0)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function LastIndexOf(Of T) (array As T(), value As T) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static int LastIndexOf(cli::array &lt;T&gt; ^ array, T value);" />
      <MemberSignature Language="F#" Value="static member LastIndexOf : 'T[] * 'T -&gt; int" Usage="System.Array.LastIndexOf (array, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="value" Type="T" />
      </Parameters>
      <Docs>
        <typeparam name="T">Tipo de los elementos de la matriz.</typeparam>
        <param name="array">
          <see cref="T:System.Array" /> unidimensional de base cero en la que se realizará la búsqueda.</param>
        <param name="value">Objeto que se va a buscar en <paramref name="array" />.</param>
        <summary>Busca el objeto especificado y devuelve el índice de la última aparición de toda la <see cref="T:System.Array" />.</summary>
        <returns>Índice de base cero de la última aparición de <paramref name="value" /> en toda la <paramref name="array" />, si se encuentra; en caso contrario, -1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Array> se realiza hacia atrás a partir del último elemento y terminando en el primer elemento.  
  
 Los elementos se comparan con el valor especificado mediante el <xref:System.Object.Equals%2A?displayProperty=nameWithType> método. Si el tipo de elemento es un tipo no intrínseco (definido por el usuario), el `Equals` se utiliza la implementación de ese tipo.  
  
 Este método es O (`n`) operación, donde `n` es el <xref:System.Array.Length%2A> de `array`.  
  
   
  
## Examples  
 El ejemplo de código siguiente muestra tres sobrecargas genéricas de los <xref:System.Array.LastIndexOf%2A> método. Se crea una matriz de cadenas, con una entrada que aparece dos veces, en la ubicación de índice 0 y la ubicación de índice 5. El <xref:System.Array.LastIndexOf%60%601%28%60%600%5B%5D%2C%60%600%29> sobrecarga del método busca en toda la matriz desde el final y encuentra la segunda aparición de la cadena. El <xref:System.Array.LastIndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%29> sobrecarga del método se utiliza para buscar el principio con versiones anteriores de matriz en la posición de índice 3 y continuando hasta el principio de la matriz y busca la primera aparición de la cadena. Por último, el <xref:System.Array.LastIndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%2CSystem.Int32%29> sobrecarga del método se utiliza para buscar un intervalo de cuatro entradas, comenzando en la posición de índice 4 y avanzando hacia atrás (es decir, busca los elementos en ubicaciones 1, 2, 3 y 4); esta búsqueda devuelve – 1 porque no hay ninguna instancia de la búsqueda cadena en ese intervalo.  
  
 [!code-cpp[Array_LastIndexOf#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_LastIndexOf/cpp/source.cpp#1)]
 [!code-csharp[Array_LastIndexOf#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_LastIndexOf/cs/source.cs#1)]
 [!code-vb[Array_LastIndexOf#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_LastIndexOf/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El valor de <paramref name="array" /> es <see langword="null" />.</exception>
        <altmember cref="Overload:System.Array.IndexOf" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">Realizar operaciones de cadenas que no tienen en cuenta las referencias culturales en matrices</related>
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int LastIndexOf&lt;T&gt; (T[] array, T value, int startIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 LastIndexOf&lt;T&gt;(!!T[] array, !!T value, int32 startIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.LastIndexOf``1(``0[],``0,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function LastIndexOf(Of T) (array As T(), value As T, startIndex As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static int LastIndexOf(cli::array &lt;T&gt; ^ array, T value, int startIndex);" />
      <MemberSignature Language="F#" Value="static member LastIndexOf : 'T[] * 'T * int -&gt; int" Usage="System.Array.LastIndexOf (array, value, startIndex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="value" Type="T" />
        <Parameter Name="startIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <typeparam name="T">Tipo de los elementos de la matriz.</typeparam>
        <param name="array">
          <see cref="T:System.Array" /> unidimensional de base cero en la que se realizará la búsqueda.</param>
        <param name="value">Objeto que se va a buscar en <paramref name="array" />.</param>
        <param name="startIndex">Índice inicial de base cero de la búsqueda hacia atrás.</param>
        <summary>Busca el objeto especificado y devuelve el índice de la última aparición en el intervalo de elementos de la <see cref="T:System.Array" /> que se extiende desde el primer elemento hasta el índice especificado.</summary>
        <returns>Índice de base cero de la última aparición de <paramref name="value" /> dentro del intervalo de elementos de <paramref name="array" /> que abarca desde el primer elemento hasta <paramref name="startIndex" />, si se encuentra; de lo contrario, –1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Array> es la búsqueda hacia atrás, empezando en `startIndex` y terminando en el primer elemento.  
  
 Los elementos se comparan con el valor especificado mediante el <xref:System.Object.Equals%2A?displayProperty=nameWithType> método. Si el tipo de elemento es un tipo no intrínseco (definido por el usuario), el `Equals` se utiliza la implementación de ese tipo.  
  
 Este método es O (`n`) operación, donde `n` es el número de elementos desde el principio del `array` a `startIndex`.  
  
   
  
## Examples  
 El ejemplo de código siguiente muestra tres sobrecargas genéricas de los <xref:System.Array.LastIndexOf%2A> método. Se crea una matriz de cadenas, con una entrada que aparece dos veces, en la ubicación de índice 0 y la ubicación de índice 5. El <xref:System.Array.LastIndexOf%60%601%28%60%600%5B%5D%2C%60%600%29> sobrecarga del método busca en toda la matriz desde el final y encuentra la segunda aparición de la cadena. El <xref:System.Array.LastIndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%29> sobrecarga del método se utiliza para buscar el principio con versiones anteriores de matriz en la posición de índice 3 y continuando hasta el principio de la matriz y busca la primera aparición de la cadena. Por último, el <xref:System.Array.LastIndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%2CSystem.Int32%29> sobrecarga del método se utiliza para buscar un intervalo de cuatro entradas, comenzando en la posición de índice 4 y avanzando hacia atrás (es decir, busca los elementos en ubicaciones 1, 2, 3 y 4); esta búsqueda devuelve – 1 porque no hay ninguna instancia de la búsqueda cadena en ese intervalo.  
  
 [!code-cpp[Array_LastIndexOf#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_LastIndexOf/cpp/source.cpp#1)]
 [!code-csharp[Array_LastIndexOf#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_LastIndexOf/cs/source.cs#1)]
 [!code-vb[Array_LastIndexOf#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_LastIndexOf/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El valor de <paramref name="array" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" /> está fuera del intervalo de índices válidos para la <paramref name="array" />.</exception>
        <altmember cref="Overload:System.Array.IndexOf" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">Realizar operaciones de cadenas que no tienen en cuenta las referencias culturales en matrices</related>
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int LastIndexOf&lt;T&gt; (T[] array, T value, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 LastIndexOf&lt;T&gt;(!!T[] array, !!T value, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.LastIndexOf``1(``0[],``0,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function LastIndexOf(Of T) (array As T(), value As T, startIndex As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static int LastIndexOf(cli::array &lt;T&gt; ^ array, T value, int startIndex, int count);" />
      <MemberSignature Language="F#" Value="static member LastIndexOf : 'T[] * 'T * int * int -&gt; int" Usage="System.Array.LastIndexOf (array, value, startIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="value" Type="T" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <typeparam name="T">Tipo de los elementos de la matriz.</typeparam>
        <param name="array">
          <see cref="T:System.Array" /> unidimensional de base cero en la que se realizará la búsqueda.</param>
        <param name="value">Objeto que se va a buscar en <paramref name="array" />.</param>
        <param name="startIndex">Índice inicial de base cero de la búsqueda hacia atrás.</param>
        <param name="count">Número de elementos de la sección en la que se va a realizar la búsqueda.</param>
        <summary>Busca el objeto especificado y devuelve el índice de la última aparición en el intervalo de elementos de la <see cref="T:System.Array" /> que contiene el número de elementos especificado y termina en el índice especificado.</summary>
        <returns>Índice de base cero de la última aparición de <paramref name="value" /> dentro del intervalo de elementos de <paramref name="array" /> que contiene el número de elementos especificado en <paramref name="count" /> y termina en <paramref name="startIndex" />, si se encuentra; de lo contrario, –1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Array> es la búsqueda hacia atrás, empezando en `startIndex` hasta `startIndex` menos `count` más 1, si `count` es mayor que 0.  
  
 Los elementos se comparan con el valor especificado mediante el <xref:System.Object.Equals%2A?displayProperty=nameWithType> método. Si el tipo de elemento es un tipo no intrínseco (definido por el usuario), el `Equals` se utiliza la implementación de ese tipo.  
  
 Este método es O (`n`) operación, donde `n` es `count`.  
  
   
  
## Examples  
 El ejemplo de código siguiente muestra tres sobrecargas genéricas de los <xref:System.Array.LastIndexOf%2A> método. Se crea una matriz de cadenas, con una entrada que aparece dos veces, en la ubicación de índice 0 y la ubicación de índice 5. El <xref:System.Array.LastIndexOf%60%601%28%60%600%5B%5D%2C%60%600%29> sobrecarga del método busca en toda la matriz desde el final y encuentra la segunda aparición de la cadena. El <xref:System.Array.LastIndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%29> sobrecarga del método se utiliza para buscar el principio con versiones anteriores de matriz en la posición de índice 3 y continuando hasta el principio de la matriz y busca la primera aparición de la cadena. Por último, el <xref:System.Array.LastIndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%2CSystem.Int32%29> sobrecarga del método se utiliza para buscar un intervalo de cuatro entradas, comenzando en la posición de índice 4 y avanzando hacia atrás (es decir, busca los elementos en ubicaciones 1, 2, 3 y 4); esta búsqueda devuelve – 1 porque no hay ninguna instancia de la búsqueda cadena en ese intervalo.  
  
 [!code-cpp[Array_LastIndexOf#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_LastIndexOf/cpp/source.cpp#1)]
 [!code-csharp[Array_LastIndexOf#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_LastIndexOf/cs/source.cs#1)]
 [!code-vb[Array_LastIndexOf#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_LastIndexOf/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El valor de <paramref name="array" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" /> está fuera del intervalo de índices válidos para la <paramref name="array" />.  
  
O bien 
 <paramref name="count" /> es menor que cero.  
  
O bien 
 <paramref name="startIndex" /> y <paramref name="count" /> no especifican una sección válida en <paramref name="array" />.</exception>
        <altmember cref="Overload:System.Array.IndexOf" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">Realizar operaciones de cadenas que no tienen en cuenta las referencias culturales en matrices</related>
      </Docs>
    </Member>
    <Member MemberName="Length">
      <MemberSignature Language="C#" Value="public int Length { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Length" />
      <MemberSignature Language="DocId" Value="P:System.Array.Length" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Length As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Length { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Length : int" Usage="System.Array.Length" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>get: System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene el número total de elementos de todas las dimensiones de <see cref="T:System.Array" />.</summary>
        <value>Número total de elementos en todas las dimensiones de <see cref="T:System.Array" />; es cero si no hay elementos en la matriz.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La recuperación del valor de esta propiedad es una operación O(1).  
  
   
  
## Examples  
 En el ejemplo siguiente se usa el <xref:System.Array.Length%2A> propiedad va a obtener el número total de elementos en una matriz. También usa el <xref:System.Array.GetUpperBound%2A> método para determinar el número de elementos de cada dimensión de una matriz multidimensional.  
  
 [!code-csharp[System.Array.Length#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.array.length/cs/length1.cs#1)]
 [!code-vb[System.Array.Length#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.array.length/vb/length1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException">La matriz es multidimensional y contiene más de <see cref="F:System.Int32.MaxValue" /> elementos.</exception>
        <altmember cref="M:System.Array.GetLength(System.Int32)" />
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="P:System.Array.LongLength" />
        <altmember cref="P:System.Collections.ICollection.Count" />
        <altmember cref="P:System.Array.Rank" />
      </Docs>
    </Member>
    <Member MemberName="LongLength">
      <MemberSignature Language="C#" Value="public long LongLength { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 LongLength" />
      <MemberSignature Language="DocId" Value="P:System.Array.LongLength" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property LongLength As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long LongLength { long get(); };" />
      <MemberSignature Language="F#" Value="member this.LongLength : int64" Usage="System.Array.LongLength" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>get: System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene un entero de 64 bits que representa el número total de elementos de todas las dimensiones de <see cref="T:System.Array" />.</summary>
        <value>Entero de 64 bits que representa el número total de elementos de todas las dimensiones de la <see cref="T:System.Array" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La recuperación del valor de esta propiedad es una operación O(1).  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Array.GetLongLength(System.Int32)" />
        <altmember cref="P:System.Array.Length" />
        <altmember cref="P:System.Collections.ICollection.Count" />
        <altmember cref="P:System.Array.Rank" />
      </Docs>
    </Member>
    <Member MemberName="Rank">
      <MemberSignature Language="C#" Value="public int Rank { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Rank" />
      <MemberSignature Language="DocId" Value="P:System.Array.Rank" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Rank As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Rank { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Rank : int" Usage="System.Array.Rank" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>get: System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene el rango (número de dimensiones) de <see cref="T:System.Array" />. Por ejemplo, una matriz unidimensional devuelve 1, una matriz bidimensional devuelve 2, y así sucesivamente.</summary>
        <value>Rango (número de dimensiones) de <see cref="T:System.Array" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Por ejemplo, el código de Visual Basic  
  
```vb  
Dim TDArray(0,0,0) As Integer  
```  
  
 y el código de C#  
  
```csharp  
int[,,] TDArray = new int[1,1,1];  
```  
  
 crear una matriz de tres dimensiones con un <xref:System.Array.Rank%2A> propiedad cuyo valor es 3.  
  
 Una matriz escalonada (matriz de matrices) es una matriz unidimensional; el valor de su <xref:System.Array.Rank%2A> propiedad es 1.  
  
 La recuperación del valor de esta propiedad es una operación O(1).  
  
   
  
## Examples  
 El ejemplo siguiente se inicializa una matriz unidimensional, una matriz bidimensional y una matriz escalonada y recupera el <xref:System.Array.Rank%2A> propiedad de cada uno.  
  
 [!code-csharp[System.Array.Rank#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.array.rank/cs/rank1.cs#1)]
 [!code-vb[System.Array.Rank#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.array.rank/vb/rank1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Array.Length" />
        <altmember cref="M:System.Array.GetLength(System.Int32)" />
        <altmember cref="P:System.Array.LongLength" />
        <altmember cref="M:System.Array.GetLongLength(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Resize&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Resize&lt;T&gt; (ref T[] array, int newSize);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Resize&lt;T&gt;(!!T[]&amp; array, int32 newSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Resize``1(``0[]@,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Resize(Of T) (ByRef array As T(), newSize As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static void Resize(cli::array &lt;T&gt; ^ % array, int newSize);" />
      <MemberSignature Language="F#" Value="static member Resize :  * int -&gt; unit" Usage="System.Array.Resize (array, newSize)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" RefType="ref" />
        <Parameter Name="newSize" Type="System.Int32" />
      </Parameters>
      <Docs>
        <typeparam name="T">Tipo de los elementos de la matriz.</typeparam>
        <param name="array">Matriz unidimensional de base cero a la que se va a cambiar el tamaño o <see langword="null" /> para crear una nueva matriz con el tamaño especificado.</param>
        <param name="newSize">Tamaño de la nueva matriz.</param>
        <summary>Cambia el número de elementos de una matriz unidimensional al nuevo tamaño especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método asigna una nueva matriz con el tamaño especificado, copia los elementos de la matriz anterior al nuevo y, a continuación, reemplaza la matriz antigua con uno nuevo. `array` debe ser una matriz unidimensional.  
  
 Si `array` es `null`, este método crea una nueva matriz con el tamaño especificado.  
  
 Si `newSize` es mayor que el <xref:System.Array.Length%2A> de la matriz anterior, se asigna una nueva matriz y se copian todos los elementos de la matriz anterior al nuevo.  Si `newSize` es menor que el <xref:System.Array.Length%2A> de la matriz anterior, se asigna una nueva matriz y elementos se copian de la matriz anterior al nuevo hasta que se rellene uno nuevo; se omite el resto de los elementos de la matriz anterior.  Si `newSize` es igual a la <xref:System.Array.Length%2A> de la matriz anterior, este método no hace nada.  
  
 Este método es O (`n`) operación, donde `n` es `newSize`.  
  
 El <xref:System.Array.Resize%2A> método cambia el tamaño de matriz unidimensional. La <xref:System.Array> clase no incluye un método para cambiar el tamaño de las matrices multidimensionales. Para ello, debe proporcionar su propio código o llamar a un método especial en una biblioteca de terceros. El código siguiente muestra una posible implementación para un método que cambia el tamaño de una matriz de *n* dimensiones.  
  
 [!code-csharp[System.Array.Resize#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array.Resize/CS/resizexd.cs#2)]
 [!code-vb[System.Array.Resize#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array.Resize/VB/resizexd.vb#2)]  
  
   
  
## Examples  
 El ejemplo siguiente muestra cómo afecta el cambio de tamaño a la matriz.  
  
 [!code-cpp[System.Array.Resize#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array.Resize/CPP/System.Array.Resize.cpp#1)]
 [!code-csharp[System.Array.Resize#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array.Resize/CS/arrayresize.cs#1)]
 [!code-vb[System.Array.Resize#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array.Resize/VB/arrayresize.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="newSize" /> es menor que cero.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Reverse">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Invierte el orden de los elementos de una <see cref="T:System.Array" /> unidimensional o de una parte de la <see cref="T:System.Array" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Reverse">
      <MemberSignature Language="C#" Value="public static void Reverse (Array array);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Reverse(class System.Array array) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Reverse(System.Array)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Reverse(Array ^ array);" />
      <MemberSignature Language="F#" Value="static member Reverse : Array -&gt; unit" Usage="System.Array.Reverse array" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
      </Parameters>
      <Docs>
        <param name="array">
          <see cref="T:System.Array" /> unidimensional que se va a invertir.</param>
        <summary>Invierte la secuencia de los elementos de toda la matriz <see cref="T:System.Array" /> unidimensional.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Después de llamar a este método, el elemento situado `myArray[i]`, donde `i` es cualquier índice en la matriz, se mueve a `myArray[j]`, donde `j` es igual a `(myArray.Length + myArray.GetLowerBound(0)) - (i - myArray.GetLowerBound(0)) - 1`.  
  
 Este método es O (`n`) operación, donde `n` es el <xref:System.Array.Length%2A> de `array`.  
  
 Como se muestra en el ejemplo siguiente, la <xref:System.Array.Reverse%2A> método puede utilizarse para invertir una matriz escalonada. Inicializa una matriz escalonada con un elemento para cada mes del año actual en el calendario de la referencia cultural actual. Cada elemento contiene una matriz con tantos elementos como ese mes tiene días. En el ejemplo se muestra el contenido de la matriz, llama a la <xref:System.Array.Reverse%2A> método y, a continuación, muestra el contenido de la matriz inversa.  
  
 [!code-csharp[System.Array.Reverse#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.array.reverse/cs/reversejagged.cs#1)]
 [!code-vb[System.Array.Reverse#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.array.reverse/vb/reversejagged.vb#1)]  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra cómo se invierte el orden de los valores de un <xref:System.Array>.  
  
 [!code-cpp[Classic Array.Reverse Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.Reverse Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.Reverse Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.Reverse Example/CS/source.cs#1)]
 [!code-vb[Classic Array.Reverse Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.Reverse Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El valor de <paramref name="array" /> es <see langword="null" />.</exception>
        <exception cref="T:System.RankException">
          <paramref name="array" /> es multidimensional.</exception>
      </Docs>
    </Member>
    <Member MemberName="Reverse">
      <MemberSignature Language="C#" Value="public static void Reverse (Array array, int index, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Reverse(class System.Array array, int32 index, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Reverse(System.Array,System.Int32,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Reverse(Array ^ array, int index, int length);" />
      <MemberSignature Language="F#" Value="static member Reverse : Array * int * int -&gt; unit" Usage="System.Array.Reverse (array, index, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">
          <see cref="T:System.Array" /> unidimensional que se va a invertir.</param>
        <param name="index">Índice inicial de la sección que se va a invertir.</param>
        <param name="length">Número de elementos de la sección que se van a invertir.</param>
        <summary>Invierte la secuencia de los elementos de un intervalo de elementos de la <see cref="T:System.Array" /> unidimensional.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Después de llamar a este método, el elemento situado `myArray[i]`, donde `i` es cualquier índice en la matriz, se mueve a `myArray[j]`, donde `j` es igual a `(myArray.Length + myArray.GetLowerBound(0)) - (i - myArray.GetLowerBound(0)) - 1`.  
  
 El <xref:System.Array.Reverse%2A> método puede utilizarse para invertir una matriz escalonada.  
  
 Este método es O (`n`) operación, donde `n` es `length`.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra cómo se invierte el orden de los valores de un intervalo de elementos de un <xref:System.Array>.  
  
 [!code-cpp[Classic Array.Reverse1 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.Reverse1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.Reverse1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.Reverse1 Example/CS/source.cs#1)]
 [!code-vb[Classic Array.Reverse1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.Reverse1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El valor de <paramref name="array" /> es <see langword="null" />.</exception>
        <exception cref="T:System.RankException">
          <paramref name="array" /> es multidimensional.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> es menor que el límite inferior de <paramref name="array" />.  
  
O bien 
 <paramref name="length" /> es menor que cero.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="index" /> y <paramref name="length" /> no especifican un intervalo válido en <paramref name="array" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Reverse&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Reverse&lt;T&gt; (T[] array);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Reverse&lt;T&gt;(!!T[] array) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Reverse``1(``0[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Reverse(Of T) (array As T())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static void Reverse(cli::array &lt;T&gt; ^ array);" />
      <MemberSignature Language="F#" Value="static member Reverse : 'T[] -&gt; unit" Usage="System.Array.Reverse array" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="array">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Reverse&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Reverse&lt;T&gt; (T[] array, int index, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Reverse&lt;T&gt;(!!T[] array, int32 index, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Reverse``1(``0[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Reverse(Of T) (array As T(), index As Integer, length As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static void Reverse(cli::array &lt;T&gt; ^ array, int index, int length);" />
      <MemberSignature Language="F#" Value="static member Reverse : 'T[] * int * int -&gt; unit" Usage="System.Array.Reverse (array, index, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="array">To be added.</param>
        <param name="index">To be added.</param>
        <param name="length">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="SetValue">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Establece el elemento especificado del <see cref="T:System.Array" /> actual en el valor especificado.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SetValue">
      <MemberSignature Language="C#" Value="public void SetValue (object value, int index);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetValue(object value, int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.SetValue(System.Object,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetValue (value As Object, index As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetValue(System::Object ^ value, int index);" />
      <MemberSignature Language="F#" Value="member this.SetValue : obj * int -&gt; unit" Usage="array.SetValue (value, index)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">Nuevo valor para el elemento especificado.</param>
        <param name="index">Entero de 32 bits que representa la posición del elemento <see cref="T:System.Array" /> que se va a establecer.</param>
        <summary>Establece un valor en el elemento situado en la posición especificada de una matriz <see cref="T:System.Array" /> unidimensional. El índice se especifica como un entero de 32 bits.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Array.GetLowerBound%2A> y <xref:System.Array.GetUpperBound%2A> métodos pueden determinar si el valor de `index` je MIMO rozsah.  
  
 Para obtener más información sobre las conversiones, vea <xref:System.Convert>.  
  
 Este método es una operación o (1).  
  
> [!NOTE]
>  Si <xref:System.Array.SetValue%2A> se usa para asignar `null` a un elemento de una matriz de tipos de valor, todos los campos del elemento se inicializan en cero. El valor del elemento no es una referencia nula y no se encuentra buscando una referencia nula.  
  
   
  
## Examples  
 El ejemplo de código siguiente muestra cómo establecer y obtener un valor específico en una matriz unidimensional o multidimensional.  
  
 [!code-cpp[System.Array_GetSetValue#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetSetValue/CPP/array_getsetvalue.cpp#1)]
 [!code-csharp[System.Array_GetSetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetSetValue/CS/array_getsetvalue.cs#1)]
 [!code-vb[System.Array_GetSetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetSetValue/VB/array_getsetvalue.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">El <see cref="T:System.Array" /> actual no tiene exactamente una dimensión.</exception>
        <exception cref="T:System.InvalidCastException">
          <paramref name="value" /> no se puede convertir al tipo de elemento de la <see cref="T:System.Array" /> actual.</exception>
        <exception cref="T:System.IndexOutOfRangeException">
          <paramref name="index" /> está fuera del intervalo de índices válidos para el <see cref="T:System.Array" /> actual.</exception>
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="Overload:System.Array.GetValue" />
      </Docs>
    </Member>
    <Member MemberName="SetValue">
      <MemberSignature Language="C#" Value="public void SetValue (object value, params int[] indices);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetValue(object value, int32[] indices) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.SetValue(System.Object,System.Int32[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetValue (value As Object, ParamArray indices As Integer())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetValue(System::Object ^ value, ... cli::array &lt;int&gt; ^ indices);" />
      <MemberSignature Language="F#" Value="member this.SetValue : obj * int[] -&gt; unit" Usage="array.SetValue (value, indices)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="indices" Type="System.Int32[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="value">Nuevo valor para el elemento especificado.</param>
        <param name="indices">Matriz unidimensional de enteros de 32 bits que representan los índices que especifican la posición del elemento que se va a establecer.</param>
        <summary>Establece un valor en el elemento situado en la posición especificada de una matriz <see cref="T:System.Array" /> multidimensional. Los índices se especifican en forma de una matriz de enteros de 32 bits.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El número de elementos de `indices` debe ser igual al número de dimensiones en el <xref:System.Array>. Todos los elementos de la `indices` matriz colectivamente debe especificar la posición del elemento deseado en multidimensional <xref:System.Array>.  
  
 El <xref:System.Array.GetLowerBound%2A> y <xref:System.Array.GetUpperBound%2A> métodos pueden determinar si alguno de los valores de la `indices` matriz está fuera de los límites.  
  
 Para obtener más información sobre las conversiones, vea <xref:System.Convert>.  
  
 Este método es una operación o (1).  
  
> [!NOTE]
>  Si <xref:System.Array.SetValue%2A> se usa para asignar `null` a un elemento de una matriz de tipos de valor, todos los campos del elemento se inicializan en cero. El valor del elemento no es una referencia nula y no se encuentra buscando una referencia nula.  
  
   
  
## Examples  
 El ejemplo de código siguiente muestra cómo establecer y obtener un valor específico en una matriz unidimensional o multidimensional.  
  
 [!code-cpp[System.Array_GetSetValue#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetSetValue/CPP/array_getsetvalue.cpp#1)]
 [!code-csharp[System.Array_GetSetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetSetValue/CS/array_getsetvalue.cs#1)]
 [!code-vb[System.Array_GetSetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetSetValue/VB/array_getsetvalue.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El valor de <paramref name="indices" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">El número de dimensiones de la <see cref="T:System.Array" /> actual no es igual al número de elementos de <paramref name="indices" />.</exception>
        <exception cref="T:System.InvalidCastException">
          <paramref name="value" /> no se puede convertir al tipo de elemento de la <see cref="T:System.Array" /> actual.</exception>
        <exception cref="T:System.IndexOutOfRangeException">Cualquier elemento de <paramref name="indices" /> está fuera del intervalo de índices válidos para la dimensión correspondiente de la <see cref="T:System.Array" /> actual.</exception>
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="Overload:System.Array.GetValue" />
      </Docs>
    </Member>
    <Member MemberName="SetValue">
      <MemberSignature Language="C#" Value="public void SetValue (object value, long index);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetValue(object value, int64 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.SetValue(System.Object,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetValue (value As Object, index As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetValue(System::Object ^ value, long index);" />
      <MemberSignature Language="F#" Value="member this.SetValue : obj * int64 -&gt; unit" Usage="array.SetValue (value, index)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="index" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="value">Nuevo valor para el elemento especificado.</param>
        <param name="index">Entero de 64 bits que representa la posición del elemento <see cref="T:System.Array" /> que se va a establecer.</param>
        <summary>Establece un valor en el elemento situado en la posición especificada de una matriz <see cref="T:System.Array" /> unidimensional. El índice se especifica como un entero de 64 bits.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Array.GetLowerBound%2A> y <xref:System.Array.GetUpperBound%2A> métodos pueden determinar si el valor de `index` je MIMO rozsah.  
  
 Para obtener más información sobre las conversiones, vea <xref:System.Convert>.  
  
 Este método es una operación o (1).  
  
> [!NOTE]
>  Si <xref:System.Array.SetValue%2A> se usa para asignar `null` a un elemento de una matriz de tipos de valor, todos los campos del elemento se inicializan en cero. El valor del elemento no es una referencia nula y no se encuentra buscando una referencia nula.  
  
   
  
## Examples  
 El ejemplo de código siguiente muestra cómo establecer y obtener un valor específico en una matriz unidimensional o multidimensional.  
  
 [!code-cpp[System.Array_GetSetValue#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetSetValue/CPP/array_getsetvalue.cpp#1)]
 [!code-csharp[System.Array_GetSetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetSetValue/CS/array_getsetvalue.cs#1)]
 [!code-vb[System.Array_GetSetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetSetValue/VB/array_getsetvalue.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">El <see cref="T:System.Array" /> actual no tiene exactamente una dimensión.</exception>
        <exception cref="T:System.InvalidCastException">
          <paramref name="value" /> no se puede convertir al tipo de elemento de la <see cref="T:System.Array" /> actual.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> está fuera del intervalo de índices válidos para el <see cref="T:System.Array" /> actual.</exception>
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="Overload:System.Array.GetValue" />
      </Docs>
    </Member>
    <Member MemberName="SetValue">
      <MemberSignature Language="C#" Value="public void SetValue (object value, params long[] indices);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetValue(object value, int64[] indices) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.SetValue(System.Object,System.Int64[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetValue (value As Object, ParamArray indices As Long())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetValue(System::Object ^ value, ... cli::array &lt;long&gt; ^ indices);" />
      <MemberSignature Language="F#" Value="member this.SetValue : obj * int64[] -&gt; unit" Usage="array.SetValue (value, indices)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="indices" Type="System.Int64[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="value">Nuevo valor para el elemento especificado.</param>
        <param name="indices">Matriz unidimensional de enteros de 64 bits que representan los índices que especifican la posición del elemento que se va a establecer.</param>
        <summary>Establece un valor en el elemento situado en la posición especificada de una matriz <see cref="T:System.Array" /> multidimensional. Los índices se especifican en forma de una matriz de enteros de 64 bits.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El número de elementos de `indices` debe ser igual al número de dimensiones en el <xref:System.Array>. Todos los elementos de la `indices` matriz colectivamente debe especificar la posición del elemento deseado en multidimensional <xref:System.Array>.  
  
 El <xref:System.Array.GetLowerBound%2A> y <xref:System.Array.GetUpperBound%2A> métodos pueden determinar si alguno de los valores de la `indices` matriz está fuera de los límites.  
  
 Para obtener más información sobre las conversiones, vea <xref:System.Convert>.  
  
 Este método es una operación o (1).  
  
> [!NOTE]
>  Si <xref:System.Array.SetValue%2A> se usa para asignar `null` a un elemento de una matriz de tipos de valor, todos los campos del elemento se inicializan en cero. El valor del elemento no es una referencia nula y no se encuentra buscando una referencia nula.  
  
   
  
## Examples  
 El ejemplo de código siguiente muestra cómo establecer y obtener un valor específico en una matriz unidimensional o multidimensional.  
  
 [!code-cpp[System.Array_GetSetValue#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetSetValue/CPP/array_getsetvalue.cpp#1)]
 [!code-csharp[System.Array_GetSetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetSetValue/CS/array_getsetvalue.cs#1)]
 [!code-vb[System.Array_GetSetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetSetValue/VB/array_getsetvalue.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El valor de <paramref name="indices" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">El número de dimensiones de la <see cref="T:System.Array" /> actual no es igual al número de elementos de <paramref name="indices" />.</exception>
        <exception cref="T:System.InvalidCastException">
          <paramref name="value" /> no se puede convertir al tipo de elemento de la <see cref="T:System.Array" /> actual.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Cualquier elemento de <paramref name="indices" /> está fuera del intervalo de índices válidos para la dimensión correspondiente de la <see cref="T:System.Array" /> actual.</exception>
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="Overload:System.Array.GetValue" />
      </Docs>
    </Member>
    <Member MemberName="SetValue">
      <MemberSignature Language="C#" Value="public void SetValue (object value, int index1, int index2);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetValue(object value, int32 index1, int32 index2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.SetValue(System.Object,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetValue (value As Object, index1 As Integer, index2 As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetValue(System::Object ^ value, int index1, int index2);" />
      <MemberSignature Language="F#" Value="member this.SetValue : obj * int * int -&gt; unit" Usage="array.SetValue (value, index1, index2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="index1" Type="System.Int32" />
        <Parameter Name="index2" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">Nuevo valor para el elemento especificado.</param>
        <param name="index1">Entero de 32 bits que representa el índice de la primera dimensión del elemento <see cref="T:System.Array" /> que se va a establecer.</param>
        <param name="index2">Entero de 32 bits que representa el índice de la segunda dimensión del elemento <see cref="T:System.Array" /> que se va a establecer.</param>
        <summary>Establece un valor en el elemento situado en la posición especificada de la <see cref="T:System.Array" /> bidimensional. Los índices se especifican como enteros de 32 bits.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Array.GetLowerBound%2A> y <xref:System.Array.GetUpperBound%2A> métodos pueden determinar si alguno de los índices queda fuera de los límites.  
  
 Para obtener más información sobre las conversiones, vea <xref:System.Convert>.  
  
 Este método es una operación o (1).  
  
> [!NOTE]
>  Si <xref:System.Array.SetValue%2A> se usa para asignar `null` a un elemento de una matriz de tipos de valor, todos los campos del elemento se inicializan en cero. El valor del elemento no es una referencia nula y no se encuentra buscando una referencia nula.  
  
   
  
## Examples  
 El ejemplo de código siguiente muestra cómo establecer y obtener un valor específico en una matriz unidimensional o multidimensional.  
  
 [!code-cpp[System.Array_GetSetValue#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetSetValue/CPP/array_getsetvalue.cpp#1)]
 [!code-csharp[System.Array_GetSetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetSetValue/CS/array_getsetvalue.cs#1)]
 [!code-vb[System.Array_GetSetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetSetValue/VB/array_getsetvalue.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">El <see cref="T:System.Array" /> actual no tiene exactamente dos dimensiones.</exception>
        <exception cref="T:System.InvalidCastException">
          <paramref name="value" /> no se puede convertir al tipo de elemento de la <see cref="T:System.Array" /> actual.</exception>
        <exception cref="T:System.IndexOutOfRangeException">
          <paramref name="index1" /> o <paramref name="index2" /> está fuera del intervalo de índices válidos para la dimensión correspondiente del <see cref="T:System.Array" /> actual.</exception>
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="Overload:System.Array.GetValue" />
      </Docs>
    </Member>
    <Member MemberName="SetValue">
      <MemberSignature Language="C#" Value="public void SetValue (object value, long index1, long index2);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetValue(object value, int64 index1, int64 index2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.SetValue(System.Object,System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetValue (value As Object, index1 As Long, index2 As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetValue(System::Object ^ value, long index1, long index2);" />
      <MemberSignature Language="F#" Value="member this.SetValue : obj * int64 * int64 -&gt; unit" Usage="array.SetValue (value, index1, index2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="index1" Type="System.Int64" />
        <Parameter Name="index2" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="value">Nuevo valor para el elemento especificado.</param>
        <param name="index1">Entero de 64 bits que representa el índice de la primera dimensión del elemento <see cref="T:System.Array" /> que se va a establecer.</param>
        <param name="index2">Entero de 64 bits que representa el índice de la segunda dimensión del elemento <see cref="T:System.Array" /> que se va a establecer.</param>
        <summary>Establece un valor en el elemento situado en la posición especificada de la <see cref="T:System.Array" /> bidimensional. Los índices se especifican como enteros de 64 bits.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Array.GetLowerBound%2A> y <xref:System.Array.GetUpperBound%2A> métodos pueden determinar si alguno de los índices queda fuera de los límites.  
  
 Para obtener más información sobre las conversiones, vea <xref:System.Convert>.  
  
 Este método es una operación o (1).  
  
> [!NOTE]
>  Si <xref:System.Array.SetValue%2A> se usa para asignar `null` a un elemento de una matriz de tipos de valor, todos los campos del elemento se inicializan en cero. El valor del elemento no es una referencia nula y no se encuentra buscando una referencia nula.  
  
   
  
## Examples  
 El ejemplo de código siguiente muestra cómo establecer y obtener un valor específico en una matriz unidimensional o multidimensional.  
  
 [!code-cpp[System.Array_GetSetValue#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetSetValue/CPP/array_getsetvalue.cpp#1)]
 [!code-csharp[System.Array_GetSetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetSetValue/CS/array_getsetvalue.cs#1)]
 [!code-vb[System.Array_GetSetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetSetValue/VB/array_getsetvalue.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">El <see cref="T:System.Array" /> actual no tiene exactamente dos dimensiones.</exception>
        <exception cref="T:System.InvalidCastException">
          <paramref name="value" /> no se puede convertir al tipo de elemento de la <see cref="T:System.Array" /> actual.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index1" /> o <paramref name="index2" /> está fuera del intervalo de índices válidos para la dimensión correspondiente del <see cref="T:System.Array" /> actual.</exception>
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="Overload:System.Array.GetValue" />
      </Docs>
    </Member>
    <Member MemberName="SetValue">
      <MemberSignature Language="C#" Value="public void SetValue (object value, int index1, int index2, int index3);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetValue(object value, int32 index1, int32 index2, int32 index3) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.SetValue(System.Object,System.Int32,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetValue (value As Object, index1 As Integer, index2 As Integer, index3 As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetValue(System::Object ^ value, int index1, int index2, int index3);" />
      <MemberSignature Language="F#" Value="member this.SetValue : obj * int * int * int -&gt; unit" Usage="array.SetValue (value, index1, index2, index3)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="index1" Type="System.Int32" />
        <Parameter Name="index2" Type="System.Int32" />
        <Parameter Name="index3" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">Nuevo valor para el elemento especificado.</param>
        <param name="index1">Entero de 32 bits que representa el índice de la primera dimensión del elemento <see cref="T:System.Array" /> que se va a establecer.</param>
        <param name="index2">Entero de 32 bits que representa el índice de la segunda dimensión del elemento <see cref="T:System.Array" /> que se va a establecer.</param>
        <param name="index3">Entero de 32 bits que representa el índice de la tercera dimensión del elemento <see cref="T:System.Array" /> que se va a establecer.</param>
        <summary>Establece un valor en el elemento situado en la posición especificada de la <see cref="T:System.Array" /> tridimensional. Los índices se especifican como enteros de 32 bits.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Array.GetLowerBound%2A> y <xref:System.Array.GetUpperBound%2A> métodos pueden determinar si alguno de los índices queda fuera de los límites.  
  
 Para obtener más información sobre las conversiones, vea <xref:System.Convert>.  
  
 Este método es una operación o (1).  
  
> [!NOTE]
>  Si <xref:System.Array.SetValue%2A> se usa para asignar `null` a un elemento de una matriz de tipos de valor, todos los campos del elemento se inicializan en cero. El valor del elemento no es una referencia nula y no se encuentra buscando una referencia nula.  
  
   
  
## Examples  
 El ejemplo de código siguiente muestra cómo establecer y obtener un valor específico en una matriz unidimensional o multidimensional.  
  
 [!code-cpp[System.Array_GetSetValue#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetSetValue/CPP/array_getsetvalue.cpp#1)]
 [!code-csharp[System.Array_GetSetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetSetValue/CS/array_getsetvalue.cs#1)]
 [!code-vb[System.Array_GetSetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetSetValue/VB/array_getsetvalue.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">El <see cref="T:System.Array" /> actual no tiene exactamente tres dimensiones.</exception>
        <exception cref="T:System.InvalidCastException">
          <paramref name="value" /> no se puede convertir al tipo de elemento del <see cref="T:System.Array" /> actual.</exception>
        <exception cref="T:System.IndexOutOfRangeException">
          <paramref name="index1" />, <paramref name="index2" /> o <paramref name="index3" /> está fuera del intervalo de índices válidos para la dimensión correspondiente del <see cref="T:System.Array" /> actual.</exception>
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="Overload:System.Array.GetValue" />
      </Docs>
    </Member>
    <Member MemberName="SetValue">
      <MemberSignature Language="C#" Value="public void SetValue (object value, long index1, long index2, long index3);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetValue(object value, int64 index1, int64 index2, int64 index3) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.SetValue(System.Object,System.Int64,System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetValue (value As Object, index1 As Long, index2 As Long, index3 As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetValue(System::Object ^ value, long index1, long index2, long index3);" />
      <MemberSignature Language="F#" Value="member this.SetValue : obj * int64 * int64 * int64 -&gt; unit" Usage="array.SetValue (value, index1, index2, index3)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="index1" Type="System.Int64" />
        <Parameter Name="index2" Type="System.Int64" />
        <Parameter Name="index3" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="value">Nuevo valor para el elemento especificado.</param>
        <param name="index1">Entero de 64 bits que representa el índice de la primera dimensión del elemento <see cref="T:System.Array" /> que se va a establecer.</param>
        <param name="index2">Entero de 64 bits que representa el índice de la segunda dimensión del elemento <see cref="T:System.Array" /> que se va a establecer.</param>
        <param name="index3">Entero de 64 bits que representa el índice de la tercera dimensión del elemento <see cref="T:System.Array" /> que se va a establecer.</param>
        <summary>Establece un valor en el elemento situado en la posición especificada de la <see cref="T:System.Array" /> tridimensional. Los índices se especifican como enteros de 64 bits.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Array.GetLowerBound%2A> y <xref:System.Array.GetUpperBound%2A> métodos pueden determinar si alguno de los índices queda fuera de los límites.  
  
 Para obtener más información sobre las conversiones, vea <xref:System.Convert>.  
  
 Este método es una operación o (1).  
  
> [!NOTE]
>  Si <xref:System.Array.SetValue%2A> se usa para asignar `null` a un elemento de una matriz de tipos de valor, todos los campos del elemento se inicializan en cero. El valor del elemento no es una referencia nula y no se encuentra buscando una referencia nula.  
  
   
  
## Examples  
 El ejemplo de código siguiente muestra cómo establecer y obtener un valor específico en una matriz unidimensional o multidimensional.  
  
 [!code-cpp[System.Array_GetSetValue#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetSetValue/CPP/array_getsetvalue.cpp#1)]
 [!code-csharp[System.Array_GetSetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetSetValue/CS/array_getsetvalue.cs#1)]
 [!code-vb[System.Array_GetSetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetSetValue/VB/array_getsetvalue.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">El <see cref="T:System.Array" /> actual no tiene exactamente tres dimensiones.</exception>
        <exception cref="T:System.InvalidCastException">
          <paramref name="value" /> no se puede convertir al tipo de elemento del <see cref="T:System.Array" /> actual.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index1" />, <paramref name="index2" /> o <paramref name="index3" /> está fuera del intervalo de índices válidos para la dimensión correspondiente del <see cref="T:System.Array" /> actual.</exception>
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="Overload:System.Array.GetValue" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Sort">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Ordena los elementos en una matriz unidimensional.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Sort">
      <MemberSignature Language="C#" Value="public static void Sort (Array array);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort(class System.Array array) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort(System.Array)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Sort(Array ^ array);" />
      <MemberSignature Language="F#" Value="static member Sort : Array -&gt; unit" Usage="System.Array.Sort array" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
      </Parameters>
      <Docs>
        <param name="array">
          <see cref="T:System.Array" /> unidimensional que se va a ordenar.</param>
        <summary>Ordena los elementos de toda una matriz <see cref="T:System.Array" /> unidimensional usando la implementación de <see cref="T:System.IComparable" /> de cada elemento de la matriz <see cref="T:System.Array" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cada elemento de `array` debe implementar la <xref:System.IComparable> para realizar comparaciones con todos los elementos de interfaz de `array`.  
  
 Si el criterio de ordenación no se ha completado correctamente, los resultados son indefinidos.  
  
 Este método utiliza el algoritmo de ordenación introspectiva (introsort) como sigue:  
  
-   Si el tamaño de partición es menos de 16 elementos, utiliza un [orden de inserción](https://en.wikipedia.org/wiki/Insertion_sort) algoritmo.  
  
-   Si el número de particiones es superior a 2 * registro<sup>N</sup>, donde *N* es el intervalo de la matriz de entrada, usa un [Heapsort](https://en.wikipedia.org/wiki/Heapsort) algoritmo.  
  
-   De lo contrario, se usa un [Quicksort](https://en.wikipedia.org/wiki/Quicksort) algoritmo.  
  
 Esta implementación realiza a una ordenación inestable; es decir, si dos elementos son iguales, es posible que no se conserve su orden. En cambio, una ordenación estable conserva el orden de los elementos que son iguales.  
  
 Para las matrices que se ordenan mediante el uso de los algoritmos Heapsort y Quicksort, en el peor de los casos, este método es O (`n` registro `n`) operación, donde `n` es el <xref:System.Array.Length%2A> de `array`.  
  
   
  
## Examples  
 El ejemplo de código siguiente muestra cómo ordenar los valores de un <xref:System.Array> utilizando el comparador predeterminado y un comparador personalizado que invierte el criterio de ordenación. Tenga en cuenta que el resultado puede variar según la actual <xref:System.Globalization.CultureInfo>.  
  
 [!code-cpp[System.Array.Sort#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array.Sort/CPP/arraysort.cpp#1)]
 [!code-csharp[System.Array.Sort#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array.Sort/CS/arraysort.cs#1)]
 [!code-vb[System.Array.Sort#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array.Sort/VB/arraysort.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El valor de <paramref name="array" /> es <see langword="null" />.</exception>
        <exception cref="T:System.RankException">
          <paramref name="array" /> es multidimensional.</exception>
        <exception cref="T:System.InvalidOperationException">Uno o más elementos de la <paramref name="array" /> no implementan la interfaz de <see cref="T:System.IComparable" />.</exception>
        <altmember cref="T:System.IComparable" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">Realizar operaciones de cadenas que no tienen en cuenta las referencias culturales en matrices</related>
      </Docs>
    </Member>
    <Member MemberName="Sort">
      <MemberSignature Language="C#" Value="public static void Sort (Array keys, Array items);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort(class System.Array keys, class System.Array items) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort(System.Array,System.Array)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Sort (keys As Array, items As Array)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Sort(Array ^ keys, Array ^ items);" />
      <MemberSignature Language="F#" Value="static member Sort : Array * Array -&gt; unit" Usage="System.Array.Sort (keys, items)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="keys" Type="System.Array" />
        <Parameter Name="items" Type="System.Array" />
      </Parameters>
      <Docs>
        <param name="keys">La <see cref="T:System.Array" /> unidimensional que contiene las claves que se van a ordenar.</param>
        <param name="items">La <see cref="T:System.Array" /> unidimensional que contiene los elementos que se corresponden con cada una de las claves de <paramref name="keys" /><see cref="T:System.Array" />.  
  
O bien 
 <see langword="null" /> para ordenar solo las <paramref name="keys" /><see cref="T:System.Array" />.</param>
        <summary>Ordena un par de objetos <see cref="T:System.Array" /> unidimensionales (uno contiene las claves y el otro contiene los elementos correspondientes) en función de las claves de la primera <see cref="T:System.Array" /> usando la implementación de <see cref="T:System.IComparable" /> de cada clave.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cada clave de la `keys` <xref:System.Array> tiene un elemento correspondiente en el `items` <xref:System.Array>. Cuando se vuelve a ubicar una clave durante la ordenación, el elemento correspondiente en el `items` <xref:System.Array> del mismo modo se cambia de posición. Por lo tanto, el `items` <xref:System.Array> se ordenan según la disposición de las claves correspondientes en el `keys` <xref:System.Array>.  
  
 Cada clave de la `keys` <xref:System.Array> debe implementar la <xref:System.IComparable> interfaz para poder realizar comparaciones con otras claves.  
  
 Puede ordenar si hay más elementos que las claves, pero no se ordenarán los elementos que no tengan ninguna de las claves correspondientes. No se puede ordenar si hay más teclas que los elementos; al hacerlo se inicia un <xref:System.ArgumentException>.  
  
 Si el criterio de ordenación no se ha completado correctamente, los resultados son indefinidos.  
  
 Este método utiliza el algoritmo de ordenación introspectiva (introsort) como sigue:  
  
-   Si el tamaño de partición es menos de 16 elementos, utiliza un [orden de inserción](https://en.wikipedia.org/wiki/Insertion_sort) algoritmo.  
  
-   Si el número de particiones es superior a 2 * registro<sup>N</sup>, donde *N* es el intervalo de la matriz de entrada, usa un [Heapsort](https://en.wikipedia.org/wiki/Heapsort) algoritmo.  
  
-   De lo contrario, se usa un [Quicksort](https://en.wikipedia.org/wiki/Quicksort) algoritmo.  
  
 Esta implementación realiza a una ordenación inestable; es decir, si dos elementos son iguales, es posible que no se conserve su orden. En cambio, una ordenación estable conserva el orden de los elementos que son iguales.  
  
 Para las matrices que se ordenan mediante el uso de los algoritmos Heapsort y Quicksort, en el peor de los casos, este método es O (`n` registro `n`) operación, donde `n` es el <xref:System.Array.Length%2A> de `keys`.  
  
   
  
## Examples  
 El ejemplo siguiente muestra cómo ordenar dos matrices asociadas, donde la primera matriz contiene las claves y la segunda matriz contiene los valores. Ordenaciones se realizan utilizando el comparador predeterminado y un comparador personalizado que invierte el criterio de ordenación. Tenga en cuenta que el resultado puede variar según la actual <xref:System.Globalization.CultureInfo>.  
  
 [!code-cpp[System.Array.Sort2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array.Sort2/CPP/arraysort2.cpp#1)]
 [!code-csharp[System.Array.Sort2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array.Sort2/CS/arraysort2.cs#1)]
 [!code-vb[System.Array.Sort2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array.Sort2/VB/arraysort2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El valor de <paramref name="keys" /> es <see langword="null" />.</exception>
        <exception cref="T:System.RankException">
          <paramref name="keys" />
          <see cref="T:System.Array" /> es multidimensional.  
  
O bien 
<paramref name="items" /><see cref="T:System.Array" /> es multidimensional.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="items" />no es <see langword="null" /> y la longitud de <paramref name="keys" /> es mayor que la longitud de <paramref name="items" />.</exception>
        <exception cref="T:System.InvalidOperationException">Uno o más elementos del objeto <see cref="T:System.Array" /> de <paramref name="keys" /> no implementan la interfaz <see cref="T:System.IComparable" />.</exception>
        <altmember cref="T:System.IComparable" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <altmember cref="T:System.Collections.IDictionary" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">Realizar operaciones de cadenas que no tienen en cuenta las referencias culturales en matrices</related>
      </Docs>
    </Member>
    <Member MemberName="Sort">
      <MemberSignature Language="C#" Value="public static void Sort (Array array, System.Collections.IComparer comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort(class System.Array array, class System.Collections.IComparer comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort(System.Array,System.Collections.IComparer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Sort(Array ^ array, System::Collections::IComparer ^ comparer);" />
      <MemberSignature Language="F#" Value="static member Sort : Array * System.Collections.IComparer -&gt; unit" Usage="System.Array.Sort (array, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="comparer" Type="System.Collections.IComparer" />
      </Parameters>
      <Docs>
        <param name="array">Matriz unidimensional que se va a ordenar.</param>
        <param name="comparer">Implementación que se va a usar al comparar elementos.  
  
O bien 
 <see langword="null" /> para usar la implementación de <see cref="T:System.IComparable" /> de cada elemento.</param>
        <summary>Ordena los elementos de una matriz <see cref="T:System.Array" /> unidimensional usando la interfaz <see cref="T:System.Collections.IComparer" /> especificada.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si `comparer` es `null`, cada elemento de `array` debe implementar la <xref:System.IComparable> para realizar comparaciones con todos los elementos de interfaz de `array`.  
  
 Si el criterio de ordenación no se ha completado correctamente, los resultados son indefinidos.  
  
 Este método utiliza el algoritmo de ordenación introspectiva (introsort) como sigue:  
  
-   Si el tamaño de partición es menos de 16 elementos, utiliza un [orden de inserción](https://en.wikipedia.org/wiki/Insertion_sort) algoritmo.  
  
-   Si el número de particiones es superior a 2 * registro<sup>N</sup>, donde *N* es el intervalo de la matriz de entrada, usa un [Heapsort](https://en.wikipedia.org/wiki/Heapsort) algoritmo.  
  
-   De lo contrario, se usa un [Quicksort](https://en.wikipedia.org/wiki/Quicksort) algoritmo.  
  
 Esta implementación realiza a una ordenación inestable; es decir, si dos elementos son iguales, es posible que no se conserve su orden. En cambio, una ordenación estable conserva el orden de los elementos que son iguales.  
  
 Para las matrices que se ordenan mediante el uso de los algoritmos Heapsort y Quicksort, en el peor de los casos, este método es O (`n` registro `n`) operación, donde `n` es el <xref:System.Array.Length%2A> de `array`.  
  
 .NET Framework incluye predefinidos <xref:System.Collections.IComparer> implementaciones se muestran en la tabla siguiente.  
  
|Implementación|Descripción|  
|--------------------|-----------------|  
|<xref:System.Collections.CaseInsensitiveComparer?displayProperty=nameWithType>|Compara los dos objetos, pero se realiza una comparación entre mayúsculas y minúsculas de cadenas.|  
|<xref:System.Collections.Comparer.Default?displayProperty=nameWithType>|Compara los dos objetos usando las convenciones de ordenación de la referencia cultural actual.|  
|<xref:System.Collections.Comparer.DefaultInvariant?displayProperty=nameWithType>|Compara los dos objetos usando las convenciones de ordenación de la referencia cultural invariable.|  
|<xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType>|Compara dos objetos de tipo `T` utilizando el criterio de ordenación predeterminado del tipo.|  
  
 También puede admitir las comparaciones personalizadas, ya que proporciona una instancia de su propio <xref:System.Collections.IComparer> implementación para el `comparer` parámetro. El ejemplo hace esto mediante la definición de un `ReverseComparer` clase que se invierte el criterio de ordenación predeterminado para las instancias de un tipo y realiza la comparación de cadenas entre mayúsculas y minúsculas.  
  
   
  
## Examples  
 El ejemplo siguiente ordena los valores en un arrayby cadena utilizando al comparador predeterminado. También define un personalizado <xref:System.Collections.IComparer> implementación denominada `ReverseComparer` que invierte el criterio de ordenación predeterminado de un objeto mientras se realiza una comparación de cadenas entre mayúsculas y minúsculas. Tenga en cuenta que la salida puede variar según la referencia cultural actual.  
  
 [!code-cpp[System.Array.Sort#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array.Sort/CPP/arraysort.cpp#1)]
 [!code-csharp[System.Array.Sort#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array.Sort/CS/arraysort.cs#1)]
 [!code-vb[System.Array.Sort#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array.Sort/VB/arraysort.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El valor de <paramref name="array" /> es <see langword="null" />.</exception>
        <exception cref="T:System.RankException">
          <paramref name="array" /> es multidimensional.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="comparer" /> es <see langword="null" /> y uno o más elementos de la <paramref name="array" /> no implementan la interfaz de <see cref="T:System.IComparable" />.</exception>
        <exception cref="T:System.ArgumentException">La implementación de <paramref name="comparer" /> produjo un error durante la ordenación. Por ejemplo, es posible que <paramref name="comparer" /> no devuelva 0 al comparar un elemento consigo mismo.</exception>
        <block subset="none" type="usage">
          <para>El .NET Framework 4 y versiones anteriores usan solo el algoritmo Quicksort. QuickSort identifica comparadores no válidos en algunas situaciones en que se inicia la operación de ordenación una <see cref="T:System.IndexOutOfRangeException" /> excepción e inicia un <see cref="T:System.ArgumentException" /> excepción al llamador. A partir de la [!INCLUDE[net_v45](~/includes/net-v45-md.md)], es posible que las operaciones de ordenación que anteriormente produjo <see cref="T:System.ArgumentException" /> no se iniciará una excepción, ya que los algoritmos de ordenación y heapsort de inserción no detectan un comparador no válido. En su mayor parte, esto se aplica a las matrices con menos de 16 elementos.</para>
        </block>
        <altmember cref="T:System.Collections.IComparer" />
        <altmember cref="T:System.IComparable" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">Realizar operaciones de cadenas que no tienen en cuenta las referencias culturales en matrices</related>
      </Docs>
    </Member>
    <Member MemberName="Sort">
      <MemberSignature Language="C#" Value="public static void Sort (Array keys, Array items, System.Collections.IComparer comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort(class System.Array keys, class System.Array items, class System.Collections.IComparer comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort(System.Array,System.Array,System.Collections.IComparer)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Sort (keys As Array, items As Array, comparer As IComparer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Sort(Array ^ keys, Array ^ items, System::Collections::IComparer ^ comparer);" />
      <MemberSignature Language="F#" Value="static member Sort : Array * Array * System.Collections.IComparer -&gt; unit" Usage="System.Array.Sort (keys, items, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="keys" Type="System.Array" />
        <Parameter Name="items" Type="System.Array" />
        <Parameter Name="comparer" Type="System.Collections.IComparer" />
      </Parameters>
      <Docs>
        <param name="keys">La <see cref="T:System.Array" /> unidimensional que contiene las claves que se van a ordenar.</param>
        <param name="items">La <see cref="T:System.Array" /> unidimensional que contiene los elementos que se corresponden con cada una de las claves de <paramref name="keys" /><see cref="T:System.Array" />.  
  
O bien 
 <see langword="null" /> para ordenar solo las <paramref name="keys" /><see cref="T:System.Array" />.</param>
        <param name="comparer">Implementación de <see cref="T:System.Collections.IComparer" /> que se va a usar al comparar elementos.  
  
O bien 
 <see langword="null" /> para usar la implementación de <see cref="T:System.IComparable" /> de cada elemento.</param>
        <summary>Ordena un par de objetos <see cref="T:System.Array" /> unidimensionales (uno contiene las claves y el otro contiene los elementos correspondientes) en función de las claves de la primera <see cref="T:System.Array" /> usando la  <see cref="T:System.Collections.IComparer" />. especificada.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cada clave de la `keys` <xref:System.Array> tiene un elemento correspondiente en el `items` <xref:System.Array>. Cuando se vuelve a ubicar una clave durante la ordenación, el elemento correspondiente en el `items` <xref:System.Array> del mismo modo se cambia de posición. Por lo tanto, el `items` <xref:System.Array> se ordenan según la disposición de las claves correspondientes en el `keys` <xref:System.Array>.  
  
 Si `comparer` es `null`, cada clave en el `keys` <xref:System.Array> debe implementar la <xref:System.IComparable> interfaz para poder realizar comparaciones con otras claves.  
  
 Puede ordenar si hay más elementos que las claves, pero no se ordenarán los elementos que no tengan ninguna de las claves correspondientes. No se puede ordenar si hay más teclas que los elementos; al hacerlo se inicia un <xref:System.ArgumentException>.  
  
 Si el criterio de ordenación no se ha completado correctamente, los resultados son indefinidos.  
  
 .NET Framework incluye predefinidos <xref:System.Collections.IComparer> implementaciones se muestran en la tabla siguiente.  
  
|Implementación|Descripción|  
|--------------------|-----------------|  
|<xref:System.Collections.CaseInsensitiveComparer?displayProperty=nameWithType>|Compara los dos objetos, pero se realiza una comparación entre mayúsculas y minúsculas de cadenas.|  
|<xref:System.Collections.Comparer.Default?displayProperty=nameWithType>|Compara los dos objetos usando las convenciones de ordenación de la referencia cultural actual.|  
|<xref:System.Collections.Comparer.DefaultInvariant?displayProperty=nameWithType>|Compara los dos objetos usando las convenciones de ordenación de la referencia cultural invariable.|  
|<xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType>|Compara dos objetos de tipo `T` utilizando el criterio de ordenación predeterminado del tipo.|  
  
 También puede admitir las comparaciones personalizadas, ya que proporciona una instancia de su propio <xref:System.Collections.IComparer> implementación para el `comparer` parámetro. El ejemplo hace esto mediante la definición de un <xref:System.Collections.IComparer> implementación que se invierte el criterio de ordenación predeterminado y realiza la comparación de cadenas entre mayúsculas y minúsculas.  
  
 Este método utiliza el algoritmo de ordenación introspectiva (introsort) como sigue:  
  
-   Si el tamaño de partición es menos de 16 elementos, utiliza un [orden de inserción](https://en.wikipedia.org/wiki/Insertion_sort) algoritmo.  
  
-   Si el número de particiones es superior a 2 * registro<sup>N</sup>, donde *N* es el intervalo de la matriz de entrada, usa un [Heapsort](https://en.wikipedia.org/wiki/Heapsort) algoritmo.  
  
-   De lo contrario, se usa un [Quicksort](https://en.wikipedia.org/wiki/Quicksort) algoritmo.  
  
 Esta implementación realiza a una ordenación inestable; es decir, si dos elementos son iguales, es posible que no se conserve su orden. En cambio, una ordenación estable conserva el orden de los elementos que son iguales.  
  
 Para las matrices que se ordenan mediante el uso de los algoritmos Heapsort y Quicksort, en el peor de los casos, este método es O (`n` registro `n`) operación, donde `n` es el <xref:System.Array.Length%2A> de `keys`.  
  
   
  
## Examples  
 El ejemplo siguiente muestra cómo ordenar dos matrices asociadas, donde la primera matriz contiene las claves y la segunda matriz contiene los valores. Ordenaciones se realizan utilizando el comparador predeterminado y un comparador personalizado que invierte el criterio de ordenación. Tenga en cuenta que el resultado puede variar según la actual <xref:System.Globalization.CultureInfo>.  
  
 [!code-cpp[System.Array.Sort2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array.Sort2/CPP/arraysort2.cpp#1)]
 [!code-csharp[System.Array.Sort2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array.Sort2/CS/arraysort2.cs#1)]
 [!code-vb[System.Array.Sort2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array.Sort2/VB/arraysort2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El valor de <paramref name="keys" /> es <see langword="null" />.</exception>
        <exception cref="T:System.RankException">
          <paramref name="keys" />
          <see cref="T:System.Array" /> es multidimensional.  
  
O bien 
<paramref name="items" /><see cref="T:System.Array" /> es multidimensional.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="items" /> no es <see langword="null" /> y la longitud de <paramref name="keys" /> es mayor que la longitud de <paramref name="items" />.  
  
O bien 
La implementación de <paramref name="comparer" /> produjo un error durante la ordenación. Por ejemplo, es posible que <paramref name="comparer" /> no devuelva 0 al comparar un elemento consigo mismo.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="comparer" /> es <see langword="null" />, y uno o más elementos del objeto <see cref="T:System.Array" /> de <paramref name="keys" /> no implementan la interfaz de <see cref="T:System.IComparable" />.</exception>
        <block subset="none" type="usage">
          <para>El .NET Framework 4 y versiones anteriores usan solo el algoritmo Quicksort. QuickSort identifica comparadores no válidos en algunas situaciones en que se inicia la operación de ordenación una <see cref="T:System.IndexOutOfRangeException" /> excepción e inicia un <see cref="T:System.ArgumentException" /> excepción al llamador. A partir de la [!INCLUDE[net_v45](~/includes/net-v45-md.md)], es posible que las operaciones de ordenación que previouslythrew <see cref="T:System.ArgumentException" /> no se iniciará una excepción, ya que los algoritmos de ordenación y heapsort de inserción no detectan un comparador no válido. En su mayor parte, esto se aplica a las matrices con menos de 16 elementos.</para>
        </block>
        <altmember cref="T:System.Collections.IComparer" />
        <altmember cref="T:System.IComparable" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">Realizar operaciones de cadenas que no tienen en cuenta las referencias culturales en matrices</related>
      </Docs>
    </Member>
    <Member MemberName="Sort">
      <MemberSignature Language="C#" Value="public static void Sort (Array array, int index, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort(class System.Array array, int32 index, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort(System.Array,System.Int32,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Sort(Array ^ array, int index, int length);" />
      <MemberSignature Language="F#" Value="static member Sort : Array * int * int -&gt; unit" Usage="System.Array.Sort (array, index, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">
          <see cref="T:System.Array" /> unidimensional que se va a ordenar.</param>
        <param name="index">Índice inicial del intervalo que se va a ordenar.</param>
        <param name="length">Número de elementos del intervalo que se va a ordenar.</param>
        <summary>Ordena los elementos de un intervalo de elementos de una matriz <see cref="T:System.Array" /> unidimensional mediante el uso de la implementación de <see cref="T:System.IComparable" /> de cada elemento de la matriz <see cref="T:System.Array" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cada elemento dentro del intervalo especificado de elementos de `array` debe implementar la <xref:System.IComparable> para realizar comparaciones con todos los elementos de interfaz de `array`.  
  
 Si el criterio de ordenación no se ha completado correctamente, los resultados son indefinidos.  
  
 Este método utiliza el algoritmo de ordenación introspectiva (introsort) como sigue:  
  
-   Si el tamaño de partición es menos de 16 elementos, utiliza un [orden de inserción](https://en.wikipedia.org/wiki/Insertion_sort) algoritmo.  
  
-   Si el número de particiones es superior a 2 * registro<sup>N</sup>, donde *N* es el intervalo de la matriz de entrada, usa un [Heapsort](https://en.wikipedia.org/wiki/Heapsort) algoritmo.  
  
-   De lo contrario, se usa un [Quicksort](https://en.wikipedia.org/wiki/Quicksort) algoritmo.  
  
 Esta implementación realiza a una ordenación inestable; es decir, si dos elementos son iguales, es posible que no se conserve su orden. En cambio, una ordenación estable conserva el orden de los elementos que son iguales.  
  
 Para las matrices que se ordenan mediante el uso de los algoritmos Heapsort y Quicksort, en el peor de los casos, este método es O (`n` registro `n`) operación, donde `n` es `length`.  
  
   
  
## Examples  
 El ejemplo de código siguiente muestra cómo ordenar los valores de un <xref:System.Array> utilizando el comparador predeterminado y un comparador personalizado que invierte el criterio de ordenación. Tenga en cuenta que el resultado puede variar según la actual <xref:System.Globalization.CultureInfo>.  
  
 [!code-cpp[System.Array.Sort#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array.Sort/CPP/arraysort.cpp#1)]
 [!code-csharp[System.Array.Sort#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array.Sort/CS/arraysort.cs#1)]
 [!code-vb[System.Array.Sort#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array.Sort/VB/arraysort.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El valor de <paramref name="array" /> es <see langword="null" />.</exception>
        <exception cref="T:System.RankException">
          <paramref name="array" /> es multidimensional.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> es menor que el límite inferior de <paramref name="array" />.  
  
O bien 
 <paramref name="length" /> es menor que cero.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="index" /> y <paramref name="length" /> no especifican un intervalo válido en <paramref name="array" />.</exception>
        <exception cref="T:System.InvalidOperationException">Uno o más elementos de la <paramref name="array" /> no implementan la interfaz de <see cref="T:System.IComparable" />.</exception>
        <altmember cref="T:System.IComparable" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">Realizar operaciones de cadenas que no tienen en cuenta las referencias culturales en matrices</related>
      </Docs>
    </Member>
    <Member MemberName="Sort">
      <MemberSignature Language="C#" Value="public static void Sort (Array keys, Array items, int index, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort(class System.Array keys, class System.Array items, int32 index, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Sort (keys As Array, items As Array, index As Integer, length As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Sort(Array ^ keys, Array ^ items, int index, int length);" />
      <MemberSignature Language="F#" Value="static member Sort : Array * Array * int * int -&gt; unit" Usage="System.Array.Sort (keys, items, index, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="keys" Type="System.Array" />
        <Parameter Name="items" Type="System.Array" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="keys">La <see cref="T:System.Array" /> unidimensional que contiene las claves que se van a ordenar.</param>
        <param name="items">La <see cref="T:System.Array" /> unidimensional que contiene los elementos que se corresponden con cada una de las claves de <paramref name="keys" /><see cref="T:System.Array" />.  
  
O bien 
 <see langword="null" /> para ordenar solo las <paramref name="keys" /><see cref="T:System.Array" />.</param>
        <param name="index">Índice inicial del intervalo que se va a ordenar.</param>
        <param name="length">Número de elementos del intervalo que se va a ordenar.</param>
        <summary>Ordena un intervalo de elementos en un par de objetos <see cref="T:System.Array" /> unidimensionales (uno contiene las claves y el otro contiene los elementos correspondientes) en función de las claves de la primera matriz <see cref="T:System.Array" /> usando la implementación de <see cref="T:System.IComparable" /> de cada clave.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cada clave de la `keys` <xref:System.Array> tiene un elemento correspondiente en el `items` <xref:System.Array>. Cuando se vuelve a ubicar una clave durante la ordenación, el elemento correspondiente en el `items` <xref:System.Array> del mismo modo se cambia de posición. Por lo tanto, el `items` <xref:System.Array> se ordenan según la disposición de las claves correspondientes en el `keys` <xref:System.Array>.  
  
 Cada clave dentro del intervalo especificado de elementos de la `keys` <xref:System.Array> debe implementar la <xref:System.IComparable> interfaz para poder realizar comparaciones con otras claves.  
  
 Puede ordenar si hay más elementos que las claves, pero no se ordenarán los elementos que no tengan ninguna de las claves correspondientes. No se puede ordenar si hay más teclas que los elementos; al hacerlo se inicia un <xref:System.ArgumentException>.  
  
 Si el criterio de ordenación no se ha completado correctamente, los resultados son indefinidos.  
  
 Este método utiliza el algoritmo de ordenación introspectiva (introsort) como sigue:  
  
-   Si el tamaño de partición es menos de 16 elementos, utiliza un [orden de inserción](https://en.wikipedia.org/wiki/Insertion_sort) algoritmo.  
  
-   Si el número de particiones es superior a 2 * registro<sup>N</sup>, donde *N* es el intervalo de la matriz de entrada, usa un [Heapsort](https://en.wikipedia.org/wiki/Heapsort) algoritmo.  
  
-   De lo contrario, se usa un [Quicksort](https://en.wikipedia.org/wiki/Quicksort) algoritmo.  
  
 Esta implementación realiza a una ordenación inestable; es decir, si dos elementos son iguales, es posible que no se conserve su orden. En cambio, una ordenación estable conserva el orden de los elementos que son iguales.  
  
 Para las matrices que se ordenan mediante el uso de los algoritmos Heapsort y Quicksort, en el peor de los casos, este método es O (`n` registro `n`) operación, donde `n` es `length`.  
  
   
  
## Examples  
 El ejemplo de código siguiente muestra cómo ordenar dos matrices asociadas, donde la primera matriz contiene las claves y la segunda matriz contiene los valores. Ordenaciones se realizan utilizando el comparador predeterminado y un comparador personalizado que invierte el criterio de ordenación. Tenga en cuenta que el resultado puede variar según la actual <xref:System.Globalization.CultureInfo>.  
  
 [!code-cpp[System.Array.Sort2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array.Sort2/CPP/arraysort2.cpp#1)]
 [!code-csharp[System.Array.Sort2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array.Sort2/CS/arraysort2.cs#1)]
 [!code-vb[System.Array.Sort2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array.Sort2/VB/arraysort2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El valor de <paramref name="keys" /> es <see langword="null" />.</exception>
        <exception cref="T:System.RankException">
          <paramref name="keys" />
          <see cref="T:System.Array" /> es multidimensional.  
  
O bien 
La <paramref name="items" /><see cref="T:System.Array" /> es multidimensional.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> es menor que el límite inferior de <paramref name="keys" />.  
  
O bien 
 <paramref name="length" /> es menor que cero.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="items" /> no es <see langword="null" /> y la longitud de <paramref name="keys" /> es mayor que la longitud de <paramref name="items" />.  
  
O bien 
 <paramref name="index" /> y <paramref name="length" /> no especifican un intervalo válido en <paramref name="keys" /><see cref="T:System.Array" />.  
  
O bien 
 <paramref name="items" /> no es <see langword="null" /> y <paramref name="index" /> y <paramref name="length" /> no especifican un intervalo válido en <paramref name="items" /><see cref="T:System.Array" />.</exception>
        <exception cref="T:System.InvalidOperationException">Uno o más elementos del objeto <see cref="T:System.Array" /> de <paramref name="keys" /> no implementan la interfaz <see cref="T:System.IComparable" />.</exception>
        <altmember cref="T:System.IComparable" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">Realizar operaciones de cadenas que no tienen en cuenta las referencias culturales en matrices</related>
      </Docs>
    </Member>
    <Member MemberName="Sort">
      <MemberSignature Language="C#" Value="public static void Sort (Array array, int index, int length, System.Collections.IComparer comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort(class System.Array array, int32 index, int32 length, class System.Collections.IComparer comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort(System.Array,System.Int32,System.Int32,System.Collections.IComparer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Sort(Array ^ array, int index, int length, System::Collections::IComparer ^ comparer);" />
      <MemberSignature Language="F#" Value="static member Sort : Array * int * int * System.Collections.IComparer -&gt; unit" Usage="System.Array.Sort (array, index, length, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
        <Parameter Name="comparer" Type="System.Collections.IComparer" />
      </Parameters>
      <Docs>
        <param name="array">
          <see cref="T:System.Array" /> unidimensional que se va a ordenar.</param>
        <param name="index">Índice inicial del intervalo que se va a ordenar.</param>
        <param name="length">Número de elementos del intervalo que se va a ordenar.</param>
        <param name="comparer">Implementación de <see cref="T:System.Collections.IComparer" /> que se va a usar al comparar elementos.  
  
O bien 
 <see langword="null" /> para usar la implementación de <see cref="T:System.IComparable" /> de cada elemento.</param>
        <summary>Ordena los elementos de un intervalo de elementos de una matriz <see cref="T:System.Array" /> unidimensional utilizando la interfaz <see cref="T:System.Collections.IComparer" /> especificada.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si `comparer` es `null`, cada elemento dentro del intervalo especificado de elementos de `array` debe implementar la <xref:System.IComparable> para realizar comparaciones con todos los elementos de interfaz de `array`.  
  
 Si el criterio de ordenación no se ha completado correctamente, los resultados son indefinidos.  
  
 .NET Framework incluye predefinidos <xref:System.Collections.IComparer> implementaciones se muestran en la tabla siguiente.  
  
|Implementación|Descripción|  
|--------------------|-----------------|  
|<xref:System.Collections.CaseInsensitiveComparer?displayProperty=nameWithType>|Compara los dos objetos, pero se realiza una comparación entre mayúsculas y minúsculas de cadenas.|  
|<xref:System.Collections.Comparer.Default?displayProperty=nameWithType>|Compara los dos objetos usando las convenciones de ordenación de la referencia cultural actual.|  
|<xref:System.Collections.Comparer.DefaultInvariant?displayProperty=nameWithType>|Compara los dos objetos usando las convenciones de ordenación de la referencia cultural invariable.|  
|<xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType>|Compara dos objetos de tipo `T` utilizando el criterio de ordenación predeterminado del tipo.|  
  
 También puede admitir las comparaciones personalizadas, ya que proporciona una instancia de su propio <xref:System.Collections.IComparer> implementación para el `comparer` parámetro. El ejemplo hace esto mediante la definición de un `ReverseComparer` clase que se invierte el criterio de ordenación predeterminado para las instancias de un tipo y realiza la comparación de cadenas entre mayúsculas y minúsculas.  
  
 Este método utiliza el algoritmo de ordenación introspectiva (introsort) como sigue:  
  
-   Si el tamaño de partición es menos de 16 elementos, utiliza un [orden de inserción](https://en.wikipedia.org/wiki/Insertion_sort) algoritmo.  
  
-   Si el número de particiones es superior a 2 * registro<sup>N</sup>, donde *N* es el intervalo de la matriz de entrada, usa un [Heapsort](https://en.wikipedia.org/wiki/Heapsort) algoritmo.  
  
-   De lo contrario, se usa un [Quicksort](https://en.wikipedia.org/wiki/Quicksort) algoritmo.  
  
 Esta implementación realiza a una ordenación inestable; es decir, si dos elementos son iguales, es posible que no se conserve su orden. En cambio, una ordenación estable conserva el orden de los elementos que son iguales.  
  
 Para las matrices que se ordenan mediante el uso de los algoritmos Heapsort y Quicksort, en el peor de los casos, este método es O (`n` registro `n`) operación, donde `n` es `length`.  
  
   
  
## Examples  
 El ejemplo de código siguiente muestra cómo ordenar los valores de un <xref:System.Array> utilizando el comparador predeterminado y un comparador personalizado que invierte el criterio de ordenación. Tenga en cuenta que el resultado puede variar según la actual <xref:System.Globalization.CultureInfo>.  
  
 [!code-cpp[System.Array.Sort#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array.Sort/CPP/arraysort.cpp#1)]
 [!code-csharp[System.Array.Sort#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array.Sort/CS/arraysort.cs#1)]
 [!code-vb[System.Array.Sort#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array.Sort/VB/arraysort.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El valor de <paramref name="array" /> es <see langword="null" />.</exception>
        <exception cref="T:System.RankException">
          <paramref name="array" /> es multidimensional.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> es menor que el límite inferior de <paramref name="array" />.  
  
O bien 
 <paramref name="length" /> es menor que cero.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="index" /> y <paramref name="length" /> no especifican un intervalo válido en <paramref name="array" />.  
  
O bien 
La implementación de <paramref name="comparer" /> produjo un error durante la ordenación. Por ejemplo, es posible que <paramref name="comparer" /> no devuelva 0 al comparar un elemento consigo mismo.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="comparer" /> es <see langword="null" /> y uno o más elementos de la <paramref name="array" /> no implementan la interfaz de <see cref="T:System.IComparable" />.</exception>
        <block subset="none" type="usage">
          <para>El .NET Framework 4 y versiones anteriores usan solo el algoritmo Quicksort. QuickSort identifica comparadores no válidos en algunas situaciones en que se inicia la operación de ordenación una <see cref="T:System.IndexOutOfRangeException" /> excepción e inicia un <see cref="T:System.ArgumentException" /> excepción al llamador. A partir de la [!INCLUDE[net_v45](~/includes/net-v45-md.md)], es posible que las operaciones de ordenación que anteriormente produjo <see cref="T:System.ArgumentException" /> no se iniciará una excepción, ya que los algoritmos de ordenación y heapsort de inserción no detectan un comparador no válido. En su mayor parte, esto se aplica a las matrices con menos de 16 elementos.</para>
        </block>
        <altmember cref="T:System.Collections.IComparer" />
        <altmember cref="T:System.IComparable" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">Realizar operaciones de cadenas que no tienen en cuenta las referencias culturales en matrices</related>
      </Docs>
    </Member>
    <Member MemberName="Sort">
      <MemberSignature Language="C#" Value="public static void Sort (Array keys, Array items, int index, int length, System.Collections.IComparer comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort(class System.Array keys, class System.Array items, int32 index, int32 length, class System.Collections.IComparer comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32,System.Collections.IComparer)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Sort (keys As Array, items As Array, index As Integer, length As Integer, comparer As IComparer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Sort(Array ^ keys, Array ^ items, int index, int length, System::Collections::IComparer ^ comparer);" />
      <MemberSignature Language="F#" Value="static member Sort : Array * Array * int * int * System.Collections.IComparer -&gt; unit" Usage="System.Array.Sort (keys, items, index, length, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="keys" Type="System.Array" />
        <Parameter Name="items" Type="System.Array" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
        <Parameter Name="comparer" Type="System.Collections.IComparer" />
      </Parameters>
      <Docs>
        <param name="keys">La <see cref="T:System.Array" /> unidimensional que contiene las claves que se van a ordenar.</param>
        <param name="items">La <see cref="T:System.Array" /> unidimensional que contiene los elementos que se corresponden con cada una de las claves de <paramref name="keys" /><see cref="T:System.Array" />.  
  
O bien 
 <see langword="null" /> para ordenar solo las <paramref name="keys" /><see cref="T:System.Array" />.</param>
        <param name="index">Índice inicial del intervalo que se va a ordenar.</param>
        <param name="length">Número de elementos del intervalo que se va a ordenar.</param>
        <param name="comparer">Implementación de <see cref="T:System.Collections.IComparer" /> que se va a usar al comparar elementos.  
  
O bien 
 <see langword="null" /> para usar la implementación de <see cref="T:System.IComparable" /> de cada elemento.</param>
        <summary>Ordena un intervalo de elementos de un par de objetos <see cref="T:System.Array" /> unidimensionales (uno contiene las claves y el otro contiene los elementos correspondientes) en función de las claves de la primera <see cref="T:System.Array" /> usando la interfaz <see cref="T:System.Collections.IComparer" /> especificada.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cada clave de la `keys` <xref:System.Array> tiene un elemento correspondiente en el `items` <xref:System.Array>. Cuando se vuelve a ubicar una clave durante la ordenación, el elemento correspondiente en el `items` <xref:System.Array> del mismo modo se cambia de posición. Por lo tanto, el `items` <xref:System.Array> se ordenan según la disposición de las claves correspondientes en el `keys` <xref:System.Array>.  
  
 Si `comparer` es `null`, cada clave dentro del intervalo especificado de elementos de la `keys` <xref:System.Array> debe implementar la <xref:System.IComparable> interfaz para poder realizar comparaciones con otras claves.  
  
 Puede ordenar si hay más elementos que las claves, pero no se ordenarán los elementos que no tengan ninguna de las claves correspondientes. No se puede ordenar si hay más teclas que los elementos; al hacerlo se inicia un <xref:System.ArgumentException>.  
  
 Si el criterio de ordenación no se ha completado correctamente, los resultados son indefinidos.  
  
 .NET Framework incluye predefinidos <xref:System.Collections.IComparer> implementaciones se muestran en la tabla siguiente.  
  
|Implementación|Descripción|  
|--------------------|-----------------|  
|<xref:System.Collections.CaseInsensitiveComparer?displayProperty=nameWithType>|Compara los dos objetos, pero se realiza una comparación entre mayúsculas y minúsculas de cadenas.|  
|<xref:System.Collections.Comparer.Default?displayProperty=nameWithType>|Compara los dos objetos usando las convenciones de ordenación de la referencia cultural actual.|  
|<xref:System.Collections.Comparer.DefaultInvariant?displayProperty=nameWithType>|Compara los dos objetos usando las convenciones de ordenación de la referencia cultural invariable.|  
|<xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType>|Compara dos objetos de tipo `T` utilizando el criterio de ordenación predeterminado del tipo.|  
  
 También puede admitir las comparaciones personalizadas, ya que proporciona una instancia de su propio <xref:System.Collections.IComparer> implementación para el `comparer` parámetro. El ejemplo hace esto definiendo un personalizado <xref:System.Collections.IComparer> implementación que se invierte el criterio de ordenación predeterminado y realiza la comparación de cadenas entre mayúsculas y minúsculas.  
  
 Este método utiliza el algoritmo de ordenación introspectiva (introsort) como sigue:  
  
-   Si el tamaño de partición es menos de 16 elementos, utiliza un [orden de inserción](https://en.wikipedia.org/wiki/Insertion_sort) algoritmo.  
  
-   Si el número de particiones es superior a 2 * registro<sup>N</sup>, donde *N* es el intervalo de la matriz de entrada, usa un [Heapsort](https://en.wikipedia.org/wiki/Heapsort) algoritmo.  
  
-   De lo contrario, se usa un [Quicksort](https://en.wikipedia.org/wiki/Quicksort) algoritmo.  
  
 Esta implementación realiza a una ordenación inestable; es decir, si dos elementos son iguales, es posible que no se conserve su orden. En cambio, una ordenación estable conserva el orden de los elementos que son iguales.  
  
 Para las matrices que se ordenan mediante el uso de los algoritmos Heapsort y Quicksort, en el peor de los casos, este método es O (`n` registro `n`) operación, donde `n` es `length`.  
  
   
  
## Examples  
 El ejemplo de código siguiente muestra cómo ordenar dos matrices asociadas, donde la primera matriz contiene las claves y la segunda matriz contiene los valores. Ordenaciones se realizan utilizando el comparador predeterminado y un comparador personalizado que invierte el criterio de ordenación. Tenga en cuenta que el resultado puede variar según la actual <xref:System.Globalization.CultureInfo>.  
  
 [!code-cpp[System.Array.Sort2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array.Sort2/CPP/arraysort2.cpp#1)]
 [!code-csharp[System.Array.Sort2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array.Sort2/CS/arraysort2.cs#1)]
 [!code-vb[System.Array.Sort2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array.Sort2/VB/arraysort2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El valor de <paramref name="keys" /> es <see langword="null" />.</exception>
        <exception cref="T:System.RankException">
          <paramref name="keys" />
          <see cref="T:System.Array" /> es multidimensional.  
  
O bien 
La <paramref name="items" /><see cref="T:System.Array" /> es multidimensional.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> es menor que el límite inferior de <paramref name="keys" />.  
  
O bien 
 <paramref name="length" /> es menor que cero.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="items" /> no es <see langword="null" /> y el límite inferior de <paramref name="keys" /> no coincide con el límite inferior de <paramref name="items" />.  
  
O bien 
 <paramref name="items" /> no es <see langword="null" /> y la longitud de <paramref name="keys" /> es mayor que la longitud de <paramref name="items" />.  
  
O bien 
 <paramref name="index" /> y <paramref name="length" /> no especifican un intervalo válido en <paramref name="keys" /><see cref="T:System.Array" />.  
  
O bien 
 <paramref name="items" /> no es <see langword="null" />, y <paramref name="index" /> y <paramref name="length" /> no especifican un intervalo válido en el objeto <see cref="T:System.Array" /> de <paramref name="items" />.  
  
O bien 
La implementación de <paramref name="comparer" /> produjo un error durante la ordenación. Por ejemplo, es posible que <paramref name="comparer" /> no devuelva 0 al comparar un elemento consigo mismo.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="comparer" /> es <see langword="null" />, y uno o más elementos del objeto <see cref="T:System.Array" /> de <paramref name="keys" /> no implementan la interfaz de <see cref="T:System.IComparable" />.</exception>
        <block subset="none" type="usage">
          <para>El .NET Framework 4 y versiones anteriores usan solo el algoritmo Quicksort. QuickSort identifica comparadores no válidos en algunas situaciones en que se inicia la operación de ordenación una <see cref="T:System.IndexOutOfRangeException" /> excepción e inicia un <see cref="T:System.ArgumentException" /> excepción al llamador. A partir de la [!INCLUDE[net_v45](~/includes/net-v45-md.md)], es posible que las operaciones de ordenación que anteriormente produjo <see cref="T:System.ArgumentException" /> no se iniciará una excepción, ya que los algoritmos de ordenación y heapsort de inserción no detectan un comparador no válido. En su mayor parte, esto se aplica a las matrices con menos de 16 elementos.</para>
        </block>
        <altmember cref="T:System.Collections.IComparer" />
        <altmember cref="T:System.IComparable" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">Realizar operaciones de cadenas que no tienen en cuenta las referencias culturales en matrices</related>
      </Docs>
    </Member>
    <Member MemberName="Sort&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Sort&lt;T&gt; (T[] array);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort&lt;T&gt;(!!T[] array) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort``1(``0[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Sort(Of T) (array As T())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static void Sort(cli::array &lt;T&gt; ^ array);" />
      <MemberSignature Language="F#" Value="static member Sort : 'T[] -&gt; unit" Usage="System.Array.Sort array" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
      </Parameters>
      <Docs>
        <typeparam name="T">Tipo de los elementos de la matriz.</typeparam>
        <param name="array">
          <see cref="T:System.Array" /> unidimensional de base cero que se va a ordenar.</param>
        <summary>Ordena los elementos de toda una matriz <see cref="T:System.Array" /> usando la implementación de la interfaz genérica <see cref="T:System.IComparable`1" /> de cada elemento de <see cref="T:System.Array" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cada elemento de `array` debe implementar la <xref:System.IComparable%601> interfaz genérica para poder realizar comparaciones con todos los elementos de `array`.  
  
 Si el criterio de ordenación no se ha completado correctamente, los resultados son indefinidos.  
  
 Este método utiliza el algoritmo de ordenación introspectiva (introsort) como sigue:  
  
-   Si el tamaño de partición es menos de 16 elementos, utiliza un [orden de inserción](https://en.wikipedia.org/wiki/Insertion_sort) algoritmo.  
  
-   Si el número de particiones es superior a 2 * registro<sup>N</sup>, donde *N* es el intervalo de la matriz de entrada, usa un [Heapsort](https://en.wikipedia.org/wiki/Heapsort) algoritmo.  
  
-   De lo contrario, se usa un [Quicksort](https://en.wikipedia.org/wiki/Quicksort) algoritmo.  
  
 Esta implementación realiza a una ordenación inestable; es decir, si dos elementos son iguales, es posible que no se conserve su orden. En cambio, una ordenación estable conserva el orden de los elementos que son iguales.  
  
 Para las matrices que se ordenan mediante el uso de los algoritmos Heapsort y Quicksort, en el peor de los casos, este método es O (`n` registro `n`) operación, donde `n` es el <xref:System.Array.Length%2A> de `array`.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra el <xref:System.Array.Sort%60%601%28%60%600%5B%5D%29> sobrecarga del método genérico y el <xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%29> sobrecarga del método genérico. Se crea una matriz de cadenas, sin ningún orden determinado.  
  
 La matriz se muestra, ordenan y volverá a mostrar.  
  
> [!NOTE]
>  Las llamadas a la <xref:System.Array.Sort%2A> y <xref:System.Array.BinarySearch%2A> métodos genéricos no parece diferentes de las llamadas a sus homólogas no genéricas, ya que Visual Basic, C# y C++ deducen el tipo de parámetro de tipo genérico del tipo del primer argumento. Si usas el [Ildasm.exe (Desensamblador de IL)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) para examinar el lenguaje intermedio de Microsoft (MSIL), puede ver que se llama a los métodos genéricos.  
  
 El <xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%29> sobrecarga del método genérico, a continuación, se usa para buscar dos cadenas, una que no está en la matriz y uno que es. La matriz y el valor devuelto de la <xref:System.Array.BinarySearch%2A> método se pasan a la `ShowWhere` método genérico, que muestra el valor de índice si se encuentra la cadena y, en caso contrario, los elementos de la cadena de búsqueda pudieran estar incluidos entre si estuviera en la matriz. El índice es negativo si la cadena no es n la matriz, por lo que la `ShowWhere` método toma el complemento bit a bit (el ~ operador en C# y Visual C++, `Xor` -1 en Visual Basic) para obtener el índice del primer elemento en la lista que es mayor que la búsqueda de Cade NG.  
  
 [!code-cpp[Array_SortSearch#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_SortSearch/cpp/source.cpp#1)]
 [!code-csharp[Array_SortSearch#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_SortSearch/cs/source.cs#1)]
 [!code-vb[Array_SortSearch#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_SortSearch/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El valor de <paramref name="array" /> es <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Uno o más elementos de <paramref name="array" /> no implementan la interfaz genérica <see cref="T:System.IComparable`1" />.</exception>
        <altmember cref="T:System.IComparable`1" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">Realizar operaciones de cadenas que no tienen en cuenta las referencias culturales en matrices</related>
      </Docs>
    </Member>
    <Member MemberName="Sort&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Sort&lt;T&gt; (T[] array, System.Collections.Generic.IComparer&lt;T&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort&lt;T&gt;(!!T[] array, class System.Collections.Generic.IComparer`1&lt;!!T&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort``1(``0[],System.Collections.Generic.IComparer{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Sort(Of T) (array As T(), comparer As IComparer(Of T))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static void Sort(cli::array &lt;T&gt; ^ array, System::Collections::Generic::IComparer&lt;T&gt; ^ comparer);" />
      <MemberSignature Language="F#" Value="static member Sort : 'T[] * System.Collections.Generic.IComparer&lt;'T&gt; -&gt; unit" Usage="System.Array.Sort (array, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IComparer&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">Tipo de los elementos de la matriz.</typeparam>
        <param name="array">
          <see cref="T:System.Array" /> unidimensional de base cero que se va a ordenar.</param>
        <param name="comparer">La implementación de la interfaz genérica <see cref="T:System.Collections.Generic.IComparer`1" /> que se va a usar al comparar elementos o <see langword="null" /> para usar la implementación de la interfaz genérica <see cref="T:System.IComparable`1" /> de cada elemento.</param>
        <summary>Ordena los elementos de una <see cref="T:System.Array" /> usando la interfaz genérica <see cref="T:System.Collections.Generic.IComparer`1" /> especificada.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si `comparer` es `null`, cada elemento de `array` debe implementar la <xref:System.IComparable%601> interfaz genérica para poder realizar comparaciones con todos los elementos de `array`.  
  
 Si el criterio de ordenación no se ha completado correctamente, los resultados son indefinidos.  
  
 Este método utiliza el algoritmo de ordenación introspectiva (introsort) como sigue:  
  
-   Si el tamaño de partición es menos de 16 elementos, utiliza un [orden de inserción](https://en.wikipedia.org/wiki/Insertion_sort) algoritmo.  
  
-   Si el número de particiones es superior a 2 * registro<sup>N</sup>, donde *N* es el intervalo de la matriz de entrada, usa un [Heapsort](https://en.wikipedia.org/wiki/Heapsort) algoritmo.  
  
-   De lo contrario, se usa un [Quicksort](https://en.wikipedia.org/wiki/Quicksort) algoritmo.  
  
 Esta implementación realiza a una ordenación inestable; es decir, si dos elementos son iguales, es posible que no se conserve su orden. En cambio, una ordenación estable conserva el orden de los elementos que son iguales.  
  
 Para las matrices que se ordenan mediante el uso de los algoritmos Heapsort y Quicksort, en el peor de los casos, este método es O (`n` registro `n`) operación, donde `n` es el <xref:System.Array.Length%2A> de `array`.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra el <xref:System.Array.Sort%60%601%28%60%600%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> sobrecarga del método genérico y el <xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> sobrecarga del método genérico.  
  
 El ejemplo de código define un comparador alternativo para las cadenas, denominado `ReverseCompare`, que implementa el `IComparer<string>` (`IComparer(Of String)` en Visual Basic, `IComparer<String^>` en Visual C++) interfaz genérica. Las llamadas de comparador el <xref:System.String.CompareTo%28System.String%29> método, invertir el orden de los términos de la comparación para que las cadenas ordenen alta o baja, en lugar de bajo a alto.  
  
 La matriz se muestra, ordenan y volverá a mostrar. Las matrices deben estar ordenadas para poder usar el <xref:System.Array.BinarySearch%2A> método.  
  
> [!NOTE]
>  Las llamadas a la <xref:System.Array.Sort%60%601%28%60%600%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> y <xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> métodos genéricos no parece diferentes de las llamadas a sus homólogas no genéricas, ya que Visual Basic, C# y C++ deducen el tipo de parámetro de tipo genérico del tipo del primer argumento. Si usas el [Ildasm.exe (Desensamblador de IL)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) para examinar el lenguaje intermedio de Microsoft (MSIL), puede ver que se llama a los métodos genéricos.  
  
 El <xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> sobrecarga del método genérico, a continuación, se usa para buscar dos cadenas, una que no está en la matriz y uno que es. La matriz y el valor devuelto de la <xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> método se pasan a la `ShowWhere` método genérico, que muestra el valor de índice si se encuentra la cadena y, en caso contrario, los elementos de la cadena de búsqueda pudieran estar incluidos entre si estuviera en la matriz. El índice es negativo si la cadena no es n la matriz, por lo que la `ShowWhere` método toma el complemento bit a bit (el ~ operador en C# y Visual C++, `Xor` -1 en Visual Basic) para obtener el índice del primer elemento en la lista que es mayor que la búsqueda de Cade NG.  
  
 [!code-cpp[Array_SortSearchComparer#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_SortSearchComparer/cpp/source.cpp#1)]
 [!code-csharp[Array_SortSearchComparer#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_SortSearchComparer/cs/source.cs#1)]
 [!code-vb[Array_SortSearchComparer#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_SortSearchComparer/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El valor de <paramref name="array" /> es <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="comparer" /> es <see langword="null" /> y uno o varios elementos de <paramref name="array" /> no implementan la interfaz genérica <see cref="T:System.IComparable`1" />.</exception>
        <exception cref="T:System.ArgumentException">La implementación de <paramref name="comparer" /> produjo un error durante la ordenación. Por ejemplo, es posible que <paramref name="comparer" /> no devuelva 0 al comparar un elemento consigo mismo.</exception>
        <block subset="none" type="usage">
          <para>El .NET Framework 4 y versiones anteriores usan solo el algoritmo Quicksort. QuickSort identifica comparadores no válidos en algunas situaciones en que se inicia la operación de ordenación una <see cref="T:System.IndexOutOfRangeException" /> excepción e inicia un <see cref="T:System.ArgumentException" /> excepción al llamador. A partir de la [!INCLUDE[net_v45](~/includes/net-v45-md.md)], es posible que las operaciones de ordenación que anteriormente produjo <see cref="T:System.ArgumentException" /> no se iniciará una excepción, ya que los algoritmos de ordenación y heapsort de inserción no detectan un comparador no válido. En su mayor parte, esto se aplica a las matrices con menos de 16 elementos.</para>
        </block>
        <altmember cref="T:System.Collections.Generic.IComparer`1" />
        <altmember cref="T:System.IComparable`1" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">Realizar operaciones de cadenas que no tienen en cuenta las referencias culturales en matrices</related>
      </Docs>
    </Member>
    <Member MemberName="Sort&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Sort&lt;T&gt; (T[] array, Comparison&lt;T&gt; comparison);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort&lt;T&gt;(!!T[] array, class System.Comparison`1&lt;!!T&gt; comparison) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort``1(``0[],System.Comparison{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Sort(Of T) (array As T(), comparison As Comparison(Of T))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static void Sort(cli::array &lt;T&gt; ^ array, Comparison&lt;T&gt; ^ comparison);" />
      <MemberSignature Language="F#" Value="static member Sort : 'T[] * Comparison&lt;'T&gt; -&gt; unit" Usage="System.Array.Sort (array, comparison)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="comparison" Type="System.Comparison&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">Tipo de los elementos de la matriz.</typeparam>
        <param name="array">
          <see cref="T:System.Array" /> unidimensional, basado en cero, que se va a ordenar</param>
        <param name="comparison">
          <see cref="T:System.Comparison`1" /> que se va a utilizar al comparar elementos.</param>
        <summary>Ordena los elementos de una <see cref="T:System.Array" /> usando el <see cref="T:System.Comparison`1" /> especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si el criterio de ordenación no se ha completado correctamente, los resultados son indefinidos.  
  
 Este método usa el algoritmo de ordenación introspectiva (introsort) como sigue:  
  
-   Si el tamaño de partición es menos de 16 elementos, utiliza un [orden de inserción](https://en.wikipedia.org/wiki/Insertion_sort) algoritmo.  
  
-   Si el número de particiones es superior a 2 * registro<sup>N</sup>, donde *N* es el intervalo de la matriz de entrada, usa un [Heapsort](https://en.wikipedia.org/wiki/Heapsort) algoritmo.  
  
-   De lo contrario, se usa un [Quicksort](https://en.wikipedia.org/wiki/Quicksort) algoritmo.  
  
 Esta implementación realiza a una ordenación inestable; es decir, si dos elementos son iguales, es posible que no se conserve su orden. En cambio, una ordenación estable conserva el orden de los elementos que son iguales.  
  
 Para las matrices que se ordenan mediante el uso de los algoritmos Heapsort y Quicksort, en el peor de los casos, este método es O (`n` registro `n`) operación, donde `n` es el <xref:System.Array.Length%2A> de `array`.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra el <xref:System.Collections.Generic.List%601.Sort%28System.Comparison%7B%600%7D%29> sobrecarga del método.  
  
 El ejemplo de código define un método de comparación alternativo para las cadenas, denominado `CompareDinosByLength`. Este método funciona del siguiente modo: en primer lugar, busca el comparandsare`null`, y una referencia nula se considera menor que un valor no null. En segundo lugar, se comparan las longitudes de cadena, y se considera que la cadena más larga para que sea mayor. En tercer lugar, si las longitudes son iguales, se usa la comparación de cadenas normales.  
  
 Se crea una matriz de cadenas y se rellena con cuatro cadenas, sin ningún orden determinado. La lista también incluye una cadena vacía y una referencia nula. Se muestra la lista, se ordena usando un <xref:System.Comparison%601> delegado genérico que representa el `CompareDinosByLength` método y volverá a mostrar.  
  
 [!code-cpp[Array_SortComparison#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_SortComparison/cpp/source.cpp#1)]
 [!code-csharp[Array_SortComparison#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_SortComparison/cs/source.cs#1)]
 [!code-vb[Array_SortComparison#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_SortComparison/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El valor de <paramref name="array" /> es <see langword="null" />.  
  
O bien 
 El valor de <paramref name="comparison" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">La implementación de <paramref name="comparison" /> ha producido un error durante la ordenación. Por ejemplo, es posible que <paramref name="comparison" /> no devuelva 0 al comparar un elemento consigo mismo.</exception>
        <block subset="none" type="usage">
          <para>El .NET Framework 4 y versiones anteriores usan solo el algoritmo Quicksort. QuickSort identifica comparadores no válidos en algunas situaciones en que se inicia la operación de ordenación una <see cref="T:System.IndexOutOfRangeException" /> excepción e inicia un <see cref="T:System.ArgumentException" /> excepción al llamador. A partir de la [!INCLUDE[net_v45](~/includes/net-v45-md.md)], es posible que las operaciones de ordenación que anteriormente produjo <see cref="T:System.ArgumentException" /> no se iniciará una excepción, ya que los algoritmos de ordenación y heapsort de inserción no detectan un comparador no válido. En su mayor parte, esto se aplica a las matrices con menos de 16 elementos.</para>
        </block>
        <altmember cref="T:System.Comparison`1" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">Realizar operaciones de cadenas que no tienen en cuenta las referencias culturales en matrices</related>
      </Docs>
    </Member>
    <Member MemberName="Sort&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Sort&lt;T&gt; (T[] array, int index, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort&lt;T&gt;(!!T[] array, int32 index, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort``1(``0[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Sort(Of T) (array As T(), index As Integer, length As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static void Sort(cli::array &lt;T&gt; ^ array, int index, int length);" />
      <MemberSignature Language="F#" Value="static member Sort : 'T[] * int * int -&gt; unit" Usage="System.Array.Sort (array, index, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <typeparam name="T">Tipo de los elementos de la matriz.</typeparam>
        <param name="array">
          <see cref="T:System.Array" /> unidimensional, basado en cero, que se va a ordenar</param>
        <param name="index">Índice inicial del intervalo que se va a ordenar.</param>
        <param name="length">Número de elementos del intervalo que se va a ordenar.</param>
        <summary>Ordena los elementos en un intervalo de elementos en una <see cref="T:System.Array" /> mediante la implementación de interfaz genérica <see cref="T:System.IComparable`1" /> de cada elemento de la <see cref="T:System.Array" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cada elemento dentro del intervalo especificado de elementos de `array` debe implementar la <xref:System.IComparable%601> interfaz genérica para poder realizar comparaciones con todos los elementos de `array`.  
  
 Si el criterio de ordenación no se ha completado correctamente, los resultados son indefinidos.  
  
 Este método utiliza el algoritmo de ordenación introspectiva (introsort) como sigue:  
  
-   Si el tamaño de partición es menos de 16 elementos, utiliza un [orden de inserción](https://en.wikipedia.org/wiki/Insertion_sort) algoritmo.  
  
-   Si el número de particiones es superior a 2 * registro<sup>N</sup>, donde *N* es el intervalo de la matriz de entrada, usa un [Heapsort](https://en.wikipedia.org/wiki/Heapsort) algoritmo.  
  
-   De lo contrario, se usa un [Quicksort](https://en.wikipedia.org/wiki/Quicksort) algoritmo.  
  
 Esta implementación realiza a una ordenación inestable; es decir, si dos elementos son iguales, es posible que no se conserve su orden. En cambio, una ordenación estable conserva el orden de los elementos que son iguales.  
  
 Para las matrices que se ordenan mediante el uso de los algoritmos Heapsort y Quicksort, en el peor de los casos, este método es O (`n` registro `n`) operación, donde `n` es `length`.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra el <xref:System.Array.Sort%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Int32%29> sobrecarga del método genérico y el <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> sobrecarga del método genérico para ordenar un intervalo en una matriz.  
  
 El ejemplo de código define un comparador alternativo para las cadenas, denominado `ReverseCompare`, que implementa el `IComparer<string>` (`IComparer(Of String)` en Visual Basic, `IComparer<String^>` en Visual C++) interfaz genérica. Las llamadas de comparador el <xref:System.String.CompareTo%28System.String%29> método, invertir el orden de los términos de la comparación para que las cadenas ordenen alta o baja, en lugar de bajo a alto.  
  
 El ejemplo de código se crea y muestra una matriz de nombres de dinosaurios, que consta de tres herbívoros seguidos por tres carnívoros (tiranosaurios, para ser precisos). El <xref:System.Array.Sort%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Int32%29> sobrecarga del método genérico se usa para ordenar los tres últimos elementos de la matriz, que se muestra a continuación. El <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> se usa la sobrecarga del método genérico con `ReverseCompare` para ordenar los tres últimos elementos en orden inverso. Los dinosaurios exhaustivamente confundirse aparecerán de nuevo.  
  
> [!NOTE]
>  Las llamadas a la <xref:System.Array.Sort%60%601%28%60%600%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> y <xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> métodos genéricos no parece diferentes de las llamadas a sus homólogas no genéricas, ya que Visual Basic, C# y C++ deducen el tipo de parámetro de tipo genérico del tipo del primer argumento. Si usas el [Ildasm.exe (Desensamblador de IL)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) para examinar el lenguaje intermedio de Microsoft (MSIL), puede ver que se llama a los métodos genéricos.  
  
 [!code-cpp[Array_SortIntIntIComparer#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_SortIntIntIComparer/cpp/source.cpp#1)]
 [!code-csharp[Array_SortIntIntIComparer#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_SortIntIntIComparer/cs/source.cs#1)]
 [!code-vb[Array_SortIntIntIComparer#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_SortIntIntIComparer/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El valor de <paramref name="array" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> es menor que el límite inferior de <paramref name="array" />.  
  
O bien 
 <paramref name="length" /> es menor que cero.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="index" /> y <paramref name="length" /> no especifican un intervalo válido en <paramref name="array" />.</exception>
        <exception cref="T:System.InvalidOperationException">Uno o más elementos de <paramref name="array" /> no implementan la interfaz genérica <see cref="T:System.IComparable`1" />.</exception>
        <altmember cref="T:System.IComparable`1" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">Realizar operaciones de cadenas que no tienen en cuenta las referencias culturales en matrices</related>
      </Docs>
    </Member>
    <Member MemberName="Sort&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Sort&lt;T&gt; (T[] array, int index, int length, System.Collections.Generic.IComparer&lt;T&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort&lt;T&gt;(!!T[] array, int32 index, int32 length, class System.Collections.Generic.IComparer`1&lt;!!T&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort``1(``0[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Sort(Of T) (array As T(), index As Integer, length As Integer, comparer As IComparer(Of T))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static void Sort(cli::array &lt;T&gt; ^ array, int index, int length, System::Collections::Generic::IComparer&lt;T&gt; ^ comparer);" />
      <MemberSignature Language="F#" Value="static member Sort : 'T[] * int * int * System.Collections.Generic.IComparer&lt;'T&gt; -&gt; unit" Usage="System.Array.Sort (array, index, length, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IComparer&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">Tipo de los elementos de la matriz.</typeparam>
        <param name="array">
          <see cref="T:System.Array" /> unidimensional de base cero que se va a ordenar.</param>
        <param name="index">Índice inicial del intervalo que se va a ordenar.</param>
        <param name="length">Número de elementos del intervalo que se va a ordenar.</param>
        <param name="comparer">La implementación de la interfaz genérica <see cref="T:System.Collections.Generic.IComparer`1" /> que se va a usar al comparar elementos o <see langword="null" /> para usar la implementación de la interfaz genérica <see cref="T:System.IComparable`1" /> de cada elemento.</param>
        <summary>Ordena los elementos de un intervalo de elementos en un elemento <see cref="T:System.Array" /> mediante la interfaz genérica <see cref="T:System.Collections.Generic.IComparer`1" /> especificada.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si `comparer` es `null`, cada elemento dentro del intervalo especificado de elementos de `array` debe implementar la <xref:System.IComparable%601> interfaz genérica para poder realizar comparaciones con todos los elementos de `array`.  
  
 Si el criterio de ordenación no se ha completado correctamente, los resultados son indefinidos.  
  
 Este método utiliza el algoritmo de ordenación introspectiva (introsort) como sigue:  
  
-   Si el tamaño de partición es menos de 16 elementos, utiliza un [orden de inserción](https://en.wikipedia.org/wiki/Insertion_sort) algoritmo.  
  
-   Si el número de particiones es superior a 2 * registro<sup>N</sup>, donde *N* es el intervalo de la matriz de entrada, usa un [Heapsort](https://en.wikipedia.org/wiki/Heapsort) algoritmo.  
  
-   De lo contrario, se usa un [Quicksort](https://en.wikipedia.org/wiki/Quicksort) algoritmo.  
  
 Esta implementación realiza a una ordenación inestable; es decir, si dos elementos son iguales, es posible que no se conserve su orden. En cambio, una ordenación estable conserva el orden de los elementos que son iguales.  
  
 Para las matrices que se ordenan mediante el uso de los algoritmos Heapsort y Quicksort, en el peor de los casos, este método es O (`n` registro `n`) operación, donde `n` es `length`.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra el <xref:System.Array.Sort%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Int32%29> sobrecarga del método genérico y el <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> sobrecarga del método genérico para ordenar un intervalo en una matriz.  
  
 El ejemplo de código define un comparador alternativo para las cadenas, denominado `ReverseCompare`, que implementa el `IComparer<string>` (`IComparer(Of String)` en Visual Basic, `IComparer<String^>` en Visual C++) interfaz genérica. Las llamadas de comparador el <xref:System.String.CompareTo%28System.String%29> método, invertir el orden de los términos de la comparación para que las cadenas ordenen alta o baja, en lugar de bajo a alto.  
  
 El ejemplo de código se crea y muestra una matriz de nombres de dinosaurios, que consta de tres herbívoros seguidos por tres carnívoros (tiranosaurios, para ser precisos). El <xref:System.Array.Sort%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Int32%29> sobrecarga del método genérico se usa para ordenar los tres últimos elementos de la matriz, que se muestra a continuación. El <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> se usa la sobrecarga del método genérico con `ReverseCompare` para ordenar los tres últimos elementos en orden inverso. Los dinosaurios exhaustivamente confundirse aparecerán de nuevo.  
  
> [!NOTE]
>  Las llamadas a la <xref:System.Array.Sort%60%601%28%60%600%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> y <xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> métodos genéricos no parece diferentes de las llamadas a sus homólogas no genéricas, ya que Visual Basic, C# y C++ deducen el tipo de parámetro de tipo genérico del tipo del primer argumento. Si usas el [Ildasm.exe (Desensamblador de IL)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) para examinar el lenguaje intermedio de Microsoft (MSIL), puede ver que se llama a los métodos genéricos.  
  
 [!code-cpp[Array_SortIntIntIComparer#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_SortIntIntIComparer/cpp/source.cpp#1)]
 [!code-csharp[Array_SortIntIntIComparer#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_SortIntIntIComparer/cs/source.cs#1)]
 [!code-vb[Array_SortIntIntIComparer#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_SortIntIntIComparer/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El valor de <paramref name="array" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> es menor que el límite inferior de <paramref name="array" />.  
  
O bien 
 <paramref name="length" /> es menor que cero.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="index" /> y <paramref name="length" /> no especifican un intervalo válido en <paramref name="array" />.  
  
O bien 
La implementación de <paramref name="comparer" /> produjo un error durante la ordenación. Por ejemplo, es posible que <paramref name="comparer" /> no devuelva 0 al comparar un elemento consigo mismo.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="comparer" /> es <see langword="null" /> y uno o varios elementos de <paramref name="array" /> no implementan la interfaz genérica <see cref="T:System.IComparable`1" />.</exception>
        <block subset="none" type="usage">
          <para>El .NET Framework 4 y versiones anteriores usan solo el algoritmo Quicksort. QuickSort identifica comparadores no válidos en algunas situaciones en que se inicia la operación de ordenación una <see cref="T:System.IndexOutOfRangeException" /> excepción e inicia un <see cref="T:System.ArgumentException" /> excepción al llamador. A partir de la [!INCLUDE[net_v45](~/includes/net-v45-md.md)], es posible que las operaciones de ordenación que anteriormente produjo <see cref="T:System.ArgumentException" /> no se iniciará una excepción, ya que los algoritmos de ordenación y heapsort de inserción no detectan un comparador no válido. En su mayor parte, esto se aplica a las matrices con menos de 16 elementos.</para>
        </block>
        <altmember cref="T:System.Collections.Generic.IComparer`1" />
        <altmember cref="T:System.IComparable`1" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">Realizar operaciones de cadenas que no tienen en cuenta las referencias culturales en matrices</related>
      </Docs>
    </Member>
    <Member MemberName="Sort&lt;TKey,TValue&gt;">
      <MemberSignature Language="C#" Value="public static void Sort&lt;TKey,TValue&gt; (TKey[] keys, TValue[] items);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort&lt;TKey, TValue&gt;(!!TKey[] keys, !!TValue[] items) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort``2(``0[],``1[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Sort(Of TKey, TValue) (keys As TKey(), items As TValue())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TKey, typename TValue&gt;&#xA; static void Sort(cli::array &lt;TKey&gt; ^ keys, cli::array &lt;TValue&gt; ^ items);" />
      <MemberSignature Language="F#" Value="static member Sort : 'Key[] * 'Value[] -&gt; unit" Usage="System.Array.Sort (keys, items)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TKey" />
        <TypeParameter Name="TValue" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="keys" Type="TKey[]" />
        <Parameter Name="items" Type="TValue[]" />
      </Parameters>
      <Docs>
        <typeparam name="TKey">Tipo de los elementos de la matriz de claves.</typeparam>
        <typeparam name="TValue">Tipo de los elementos de la matriz de elementos.</typeparam>
        <param name="keys">
          <see cref="T:System.Array" /> unidimensional de base cero que contiene las claves que se van a ordenar.</param>
        <param name="items">
          <see cref="T:System.Array" /> unidimensional de base cero que contiene los elementos que se corresponden con las claves de <paramref name="keys" /> o <see langword="null" /> para ordenar solo <paramref name="keys" />.</param>
        <summary>Ordena un par de objetos <see cref="T:System.Array" /> (uno contiene las claves y el otro contiene los elementos correspondientes) en función de las claves de la primera <see cref="T:System.Array" /> usando la implementación de la interfaz genérica <see cref="T:System.IComparable`1" /> de cada clave.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cada clave de la `keys` <xref:System.Array> tiene un elemento correspondiente en el `items` <xref:System.Array>. Cuando se vuelve a ubicar una clave durante la ordenación, el elemento correspondiente en el `items` <xref:System.Array> del mismo modo se cambia de posición. Por lo tanto, el `items` <xref:System.Array> se ordenan según la disposición de las claves correspondientes en el `keys` <xref:System.Array>.  
  
 Cada clave de la `keys` <xref:System.Array> debe implementar la <xref:System.IComparable%601> interfaz genérica para poder realizar comparaciones con otras claves.  
  
 Puede ordenar si hay más elementos que las claves, pero no se ordenarán los elementos que no tengan ninguna de las claves correspondientes. No se puede ordenar si hay más teclas que los elementos; al hacerlo se inicia un <xref:System.ArgumentException>.  
  
 Si el criterio de ordenación no se ha completado correctamente, los resultados son indefinidos.  
  
 Este método utiliza el algoritmo de ordenación introspectiva (introsort) como sigue:  
  
-   Si el tamaño de partición es menos de 16 elementos, utiliza un [orden de inserción](https://en.wikipedia.org/wiki/Insertion_sort) algoritmo.  
  
-   Si el número de particiones es superior a 2 * registro<sup>N</sup>, donde *N* es el intervalo de la matriz de entrada, usa un [Heapsort](https://en.wikipedia.org/wiki/Heapsort) algoritmo.  
  
-   De lo contrario, se usa un [Quicksort](https://en.wikipedia.org/wiki/Quicksort) algoritmo.  
  
 Esta implementación realiza a una ordenación inestable; es decir, si dos elementos son iguales, es posible que no se conserve su orden. En cambio, una ordenación estable conserva el orden de los elementos que son iguales.  
  
 Para las matrices que se ordenan mediante el uso de los algoritmos Heapsort y Quicksort, en el peor de los casos, este método es O (`n` registro `n`) operación, donde `n` es el <xref:System.Array.Length%2A> de `array`.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra el <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%29>, <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29>, <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%29>, y <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> sobrecargas de método genérico, para ordenar pares de matrices que representan las claves y valores.  
  
 El ejemplo de código define un comparador alternativo para las cadenas, denominado `ReverseCompare`, que implementa el `IComparer<string>` (`IComparer(Of String)` en Visual Basic, `IComparer<String^>` en Visual C++) interfaz genérica. Las llamadas de comparador el <xref:System.String.CompareTo%28System.String%29> método, invertir el orden de los términos de la comparación para que las cadenas ordenen alta o baja, en lugar de bajo a alto.  
  
 El ejemplo de código se crea y muestra una matriz de nombres de dinosaurios (las claves) y una matriz de enteros que representa la longitud máxima de cada dinosaurio en metros (los valores). Las matrices, a continuación, se ordena y se muestran varias veces:  
  
-   El <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%29> sobrecarga se utiliza para ordenar ambas matrices en orden de los nombres de dinosaurios de la primera matriz.  
  
-   El <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> sobrecarga y una instancia de `ReverseCompare` se usan para invertir el criterio de ordenación de las matrices emparejadas.  
  
-   El <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%29> sobrecarga se utiliza para ordenar los tres últimos elementos de ambas matrices.  
  
-   El <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> sobrecarga se utiliza para ordenar los tres últimos elementos de ambas matrices en orden inverso.  
  
> [!NOTE]
>  Las llamadas a los métodos genéricos no parece diferentes de las llamadas a sus homólogas no genéricas, ya que Visual Basic, C# y C++ deducen el tipo de parámetro de tipo genérico del tipo de los dos primeros argumentos. Si usas el [Ildasm.exe (Desensamblador de IL)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) para examinar el lenguaje intermedio de Microsoft (MSIL), puede ver que se llama a los métodos genéricos.  
  
 [!code-cpp[Array_Sort2IntIntIComparer#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_Sort2IntIntIComparer/cpp/source.cpp#1)]
 [!code-csharp[Array_Sort2IntIntIComparer#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_Sort2IntIntIComparer/cs/source.cs#1)]
 [!code-vb[Array_Sort2IntIntIComparer#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_Sort2IntIntIComparer/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El valor de <paramref name="keys" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="items" /> no es <see langword="null" /> y el límite inferior de <paramref name="keys" /> no coincide con el límite inferior de <paramref name="items" />.  
  
O bien 
 <paramref name="items" /> no es <see langword="null" /> y la longitud de <paramref name="keys" /> es mayor que la longitud de <paramref name="items" />.</exception>
        <exception cref="T:System.InvalidOperationException">Uno o más elementos del objeto <see cref="T:System.Array" /> de <paramref name="keys" /> no implementan la interfaz genérica <see cref="T:System.IComparable`1" />.</exception>
        <altmember cref="T:System.IComparable`1" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <altmember cref="T:System.Collections.Generic.IDictionary`2" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">Realizar operaciones de cadenas que no tienen en cuenta las referencias culturales en matrices</related>
      </Docs>
    </Member>
    <Member MemberName="Sort&lt;TKey,TValue&gt;">
      <MemberSignature Language="C#" Value="public static void Sort&lt;TKey,TValue&gt; (TKey[] keys, TValue[] items, System.Collections.Generic.IComparer&lt;TKey&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort&lt;TKey, TValue&gt;(!!TKey[] keys, !!TValue[] items, class System.Collections.Generic.IComparer`1&lt;!!TKey&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort``2(``0[],``1[],System.Collections.Generic.IComparer{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Sort(Of TKey, TValue) (keys As TKey(), items As TValue(), comparer As IComparer(Of TKey))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TKey, typename TValue&gt;&#xA; static void Sort(cli::array &lt;TKey&gt; ^ keys, cli::array &lt;TValue&gt; ^ items, System::Collections::Generic::IComparer&lt;TKey&gt; ^ comparer);" />
      <MemberSignature Language="F#" Value="static member Sort : 'Key[] * 'Value[] * System.Collections.Generic.IComparer&lt;'Key&gt; -&gt; unit" Usage="System.Array.Sort (keys, items, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TKey" />
        <TypeParameter Name="TValue" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="keys" Type="TKey[]" />
        <Parameter Name="items" Type="TValue[]" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IComparer&lt;TKey&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TKey">Tipo de los elementos de la matriz de claves.</typeparam>
        <typeparam name="TValue">Tipo de los elementos de la matriz de elementos.</typeparam>
        <param name="keys">
          <see cref="T:System.Array" /> unidimensional de base cero que contiene las claves que se van a ordenar.</param>
        <param name="items">
          <see cref="T:System.Array" /> unidimensional de base cero que contiene los elementos que se corresponden con las claves de <paramref name="keys" /> o <see langword="null" /> para ordenar solo <paramref name="keys" />.</param>
        <param name="comparer">La implementación de la interfaz genérica <see cref="T:System.Collections.Generic.IComparer`1" /> que se va a usar al comparar elementos o <see langword="null" /> para usar la implementación de la interfaz genérica <see cref="T:System.IComparable`1" /> de cada elemento.</param>
        <summary>Ordena un par de objetos <see cref="T:System.Array" /> (uno contiene las claves y el otro contiene los elementos correspondientes) en función de las claves de la primera matriz <see cref="T:System.Array" /> usando la interfaz genérica <see cref="T:System.Collections.Generic.IComparer`1" /> especificada.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cada clave de la `keys` <xref:System.Array> tiene un elemento correspondiente en el `items` <xref:System.Array>. Cuando se vuelve a ubicar una clave durante la ordenación, el elemento correspondiente en el `items` <xref:System.Array> del mismo modo se cambia de posición. Por lo tanto, el `items` <xref:System.Array> se ordenan según la disposición de las claves correspondientes en el `keys` <xref:System.Array>.  
  
 Si `comparer` es `null`, cada clave en el `keys` <xref:System.Array> debe implementar la <xref:System.IComparable%601> interfaz genérica para poder realizar comparaciones con otras claves.  
  
 Puede ordenar si hay más elementos que las claves, pero no se ordenarán los elementos que no tengan ninguna de las claves correspondientes. No se puede ordenar si hay más teclas que los elementos; al hacerlo se inicia un <xref:System.ArgumentException>.  
  
 Si el criterio de ordenación no se ha completado correctamente, los resultados son indefinidos.  
  
 Este método utiliza el algoritmo de ordenación introspectiva (introsort) como sigue:  
  
-   Si el tamaño de partición es menos de 16 elementos, utiliza un [orden de inserción](https://en.wikipedia.org/wiki/Insertion_sort) algoritmo.  
  
-   Si el número de particiones es superior a 2 * registro<sup>N</sup>, donde *N* es el intervalo de la matriz de entrada, usa un [Heapsort](https://en.wikipedia.org/wiki/Heapsort) algoritmo.  
  
-   De lo contrario, se usa un [Quicksort](https://en.wikipedia.org/wiki/Quicksort) algoritmo.  
  
 Esta implementación realiza a una ordenación inestable; es decir, si dos elementos son iguales, es posible que no se conserve su orden. En cambio, una ordenación estable conserva el orden de los elementos que son iguales.  
  
 Para las matrices que se ordenan mediante el uso de los algoritmos Heapsort y Quicksort, en el peor de los casos, este método es O (`n` registro `n`) operación, donde `n` es el <xref:System.Array.Length%2A> de `array`.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra el <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%29>, [\], TValue\<xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29 >,<xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%29>, y <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> sobrecargas de método genérico, para ordenar pares de matrices que representan las claves y valores.  
  
 El ejemplo de código define un comparador alternativo para las cadenas, denominado `ReverseCompare`, que implementa el `IComparer<string>` (`IComparer(Of String)` en Visual Basic, `IComparer<String^>` en Visual C++) interfaz genérica. Las llamadas de comparador el <xref:System.String.CompareTo%28System.String%29> método, invertir el orden de los términos de la comparación para que las cadenas ordenen alta o baja, en lugar de bajo a alto.  
  
 El ejemplo de código se crea y muestra una matriz de nombres de dinosaurios (las claves) y una matriz de enteros que representa la longitud máxima de cada dinosaurio en metros (los valores). Las matrices, a continuación, se ordena y se muestran varias veces:  
  
-   El <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%29> sobrecarga se utiliza para ordenar ambas matrices en orden de los nombres de dinosaurios de la primera matriz.  
  
-   El [\], TValue\<xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29 > sobrecarga y una instancia de `ReverseCompare` se usan para invertir el criterio de ordenación de las matrices emparejadas.  
  
-   El <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%29> sobrecarga se utiliza para ordenar los tres últimos elementos de ambas matrices.  
  
-   El <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> sobrecarga se utiliza para ordenar los tres últimos elementos de ambas matrices en orden inverso.  
  
> [!NOTE]
>  Las llamadas a los métodos genéricos no parece diferentes de las llamadas a sus homólogas no genéricas, ya que Visual Basic, C# y C++ deducen el tipo de parámetro de tipo genérico del tipo de los dos primeros argumentos. Si usas el [Ildasm.exe (Desensamblador de IL)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) para examinar el lenguaje intermedio de Microsoft (MSIL), puede ver que se llama a los métodos genéricos.  
  
 [!code-cpp[Array_Sort2IntIntIComparer#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_Sort2IntIntIComparer/cpp/source.cpp#1)]
 [!code-csharp[Array_Sort2IntIntIComparer#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_Sort2IntIntIComparer/cs/source.cs#1)]
 [!code-vb[Array_Sort2IntIntIComparer#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_Sort2IntIntIComparer/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El valor de <paramref name="keys" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="items" /> no es <see langword="null" /> y el límite inferior de <paramref name="keys" /> no coincide con el límite inferior de <paramref name="items" />.  
  
O bien 
 <paramref name="items" /> no es <see langword="null" /> y la longitud de <paramref name="keys" /> es mayor que la longitud de <paramref name="items" />.  
  
O bien 
La implementación de <paramref name="comparer" /> produjo un error durante la ordenación. Por ejemplo, es posible que <paramref name="comparer" /> no devuelva 0 al comparar un elemento consigo mismo.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="comparer" /> es <see langword="null" /> y uno o más elementos del objeto <see cref="T:System.Array" /> de <paramref name="keys" /> no implementan la interfaz genérica <see cref="T:System.IComparable`1" />.</exception>
        <block subset="none" type="usage">
          <para>El .NET Framework 4 y versiones anteriores usan solo el algoritmo Quicksort. QuickSort identifica comparadores no válidos en algunas situaciones en que se inicia la operación de ordenación una <see cref="T:System.IndexOutOfRangeException" /> excepción e inicia un <see cref="T:System.ArgumentException" /> excepción al llamador. A partir de la [!INCLUDE[net_v45](~/includes/net-v45-md.md)], es posible que las operaciones de ordenación que anteriormente produjo <see cref="T:System.ArgumentException" /> no se iniciará una excepción, ya que los algoritmos de ordenación y heapsort de inserción no detectan un comparador no válido. En su mayor parte, esto se aplica a las matrices con menos de 16 elementos.</para>
        </block>
        <altmember cref="T:System.Collections.Generic.IComparer`1" />
        <altmember cref="T:System.IComparable`1" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">Realizar operaciones de cadenas que no tienen en cuenta las referencias culturales en matrices</related>
      </Docs>
    </Member>
    <Member MemberName="Sort&lt;TKey,TValue&gt;">
      <MemberSignature Language="C#" Value="public static void Sort&lt;TKey,TValue&gt; (TKey[] keys, TValue[] items, int index, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort&lt;TKey, TValue&gt;(!!TKey[] keys, !!TValue[] items, int32 index, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Sort(Of TKey, TValue) (keys As TKey(), items As TValue(), index As Integer, length As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TKey, typename TValue&gt;&#xA; static void Sort(cli::array &lt;TKey&gt; ^ keys, cli::array &lt;TValue&gt; ^ items, int index, int length);" />
      <MemberSignature Language="F#" Value="static member Sort : 'Key[] * 'Value[] * int * int -&gt; unit" Usage="System.Array.Sort (keys, items, index, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TKey" />
        <TypeParameter Name="TValue" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="keys" Type="TKey[]" />
        <Parameter Name="items" Type="TValue[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <typeparam name="TKey">Tipo de los elementos de la matriz de claves.</typeparam>
        <typeparam name="TValue">Tipo de los elementos de la matriz de elementos.</typeparam>
        <param name="keys">
          <see cref="T:System.Array" /> unidimensional de base cero que contiene las claves que se van a ordenar.</param>
        <param name="items">Matriz <see cref="T:System.Array" /> unidimensional de base cero que contiene los elementos que se corresponden con las claves del parámetro <paramref name="keys" />; o <see langword="null" /> para ordenar solo <paramref name="keys" />.</param>
        <param name="index">Índice inicial del intervalo que se va a ordenar.</param>
        <param name="length">Número de elementos del intervalo que se va a ordenar.</param>
        <summary>Ordena un intervalo de elementos en un par de objetos <see cref="T:System.Array" /> (uno contiene las claves y el otro contiene los elementos correspondientes) en función de las claves de la primera matriz <see cref="T:System.Array" /> usando la implementación de la interfaz genérica <see cref="T:System.IComparable`1" /> de cada clave.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cada clave de la `keys` <xref:System.Array> tiene un elemento correspondiente en el `items` <xref:System.Array>. Cuando se vuelve a ubicar una clave durante la ordenación, el elemento correspondiente en el `items` <xref:System.Array> del mismo modo se cambia de posición. Por lo tanto, el `items` <xref:System.Array> se ordenan según la disposición de las claves correspondientes en el `keys` <xref:System.Array>.  
  
 Cada clave dentro del intervalo especificado de elementos de la `keys` <xref:System.Array> debe implementar la <xref:System.IComparable%601> interfaz genérica para poder realizar comparaciones con otras claves.  
  
 Puede ordenar si hay más elementos que las claves, pero no se ordenarán los elementos que no tengan ninguna de las claves correspondientes. No se puede ordenar si hay más teclas que los elementos; al hacerlo se inicia un <xref:System.ArgumentException>.  
  
 Si el criterio de ordenación no se ha completado correctamente, los resultados son indefinidos.  
  
 Este método utiliza el algoritmo de ordenación introspectiva (introsort) como sigue:  
  
-   Si el tamaño de partición es menos de 16 elementos, utiliza un [orden de inserción](https://en.wikipedia.org/wiki/Insertion_sort) algoritmo.  
  
-   Si el número de particiones es superior a 2 * registro<sup>N</sup>, donde *N* es el intervalo de la matriz de entrada, usa un [Heapsort](https://en.wikipedia.org/wiki/Heapsort) algoritmo.  
  
-   De lo contrario, se usa un [Quicksort](https://en.wikipedia.org/wiki/Quicksort) algoritmo.  
  
 Esta implementación realiza a una ordenación inestable; es decir, si dos elementos son iguales, es posible que no se conserve su orden. En cambio, una ordenación estable conserva el orden de los elementos que son iguales.  
  
 Para las matrices que se ordenan mediante el uso de los algoritmos Heapsort y Quicksort, en el peor de los casos, este método es O (`n` registro `n`) operación, donde `n` es `length`.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra el <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%29>, <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29>, [\], TValue\<xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%29 >, y <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> sobrecargas de método genérico para ordenar pares de matrices que representan las claves y valores.  
  
 El ejemplo de código define un comparador alternativo para las cadenas, denominado `ReverseCompare`, que implementa el `IComparer<string>` (`IComparer(Of String)` en Visual Basic, `IComparer<String^>` en Visual C++) interfaz genérica. Las llamadas de comparador el <xref:System.String.CompareTo%28System.String%29> método, invertir el orden de los términos de la comparación para que las cadenas ordenen alta o baja, en lugar de bajo a alto.  
  
 El ejemplo de código se crea y muestra una matriz de nombres de dinosaurios (las claves) y una matriz de enteros que representa la longitud máxima de cada dinosaurio en metros (los valores). Las matrices, a continuación, se ordena y se muestran varias veces:  
  
-   El <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%29> sobrecarga se utiliza para ordenar ambas matrices en orden de los nombres de dinosaurios de la primera matriz.  
  
-   El <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> sobrecarga y una instancia de `ReverseCompare` se usan para invertir el criterio de ordenación de las matrices emparejadas.  
  
-   El [\], TValue\<xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%29 > sobrecarga se utiliza para ordenar los tres últimos elementos de ambas matrices.  
  
-   El <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> sobrecarga se utiliza para ordenar los tres últimos elementos de ambas matrices en orden inverso.  
  
> [!NOTE]
>  Las llamadas a los métodos genéricos no parece diferentes de las llamadas a sus homólogas no genéricas, ya que Visual Basic, C# y C++ deducen el tipo de parámetro de tipo genérico del tipo de los dos primeros argumentos. Si usas el [Ildasm.exe (Desensamblador de IL)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) para examinar el lenguaje intermedio de Microsoft (MSIL), puede ver que se llama a los métodos genéricos.  
  
 [!code-cpp[Array_Sort2IntIntIComparer#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_Sort2IntIntIComparer/cpp/source.cpp#1)]
 [!code-csharp[Array_Sort2IntIntIComparer#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_Sort2IntIntIComparer/cs/source.cs#1)]
 [!code-vb[Array_Sort2IntIntIComparer#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_Sort2IntIntIComparer/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El valor de <paramref name="keys" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> es menor que el límite inferior de <paramref name="keys" />.  
  
O bien 
 <paramref name="length" /> es menor que cero.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="items" /> no es <see langword="null" /> y el límite inferior de <paramref name="keys" /> no coincide con el límite inferior de <paramref name="items" />.  
  
O bien 
 <paramref name="items" /> no es <see langword="null" /> y la longitud de <paramref name="keys" /> es mayor que la longitud de <paramref name="items" />.  
  
O bien 
 <paramref name="index" /> y <paramref name="length" /> no especifican un intervalo válido en <paramref name="keys" /><see cref="T:System.Array" />.  
  
O bien 
 <paramref name="items" /> no es <see langword="null" />, y <paramref name="index" /> y <paramref name="length" /> no especifican un intervalo válido en <paramref name="items" /><see cref="T:System.Array" />.</exception>
        <exception cref="T:System.InvalidOperationException">Uno o más elementos del objeto <see cref="T:System.Array" /> de <paramref name="keys" /> no implementan la interfaz genérica <see cref="T:System.IComparable`1" />.</exception>
        <altmember cref="T:System.IComparable`1" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">Realizar operaciones de cadenas que no tienen en cuenta las referencias culturales en matrices</related>
      </Docs>
    </Member>
    <Member MemberName="Sort&lt;TKey,TValue&gt;">
      <MemberSignature Language="C#" Value="public static void Sort&lt;TKey,TValue&gt; (TKey[] keys, TValue[] items, int index, int length, System.Collections.Generic.IComparer&lt;TKey&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort&lt;TKey, TValue&gt;(!!TKey[] keys, !!TValue[] items, int32 index, int32 length, class System.Collections.Generic.IComparer`1&lt;!!TKey&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Sort(Of TKey, TValue) (keys As TKey(), items As TValue(), index As Integer, length As Integer, comparer As IComparer(Of TKey))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TKey, typename TValue&gt;&#xA; static void Sort(cli::array &lt;TKey&gt; ^ keys, cli::array &lt;TValue&gt; ^ items, int index, int length, System::Collections::Generic::IComparer&lt;TKey&gt; ^ comparer);" />
      <MemberSignature Language="F#" Value="static member Sort : 'Key[] * 'Value[] * int * int * System.Collections.Generic.IComparer&lt;'Key&gt; -&gt; unit" Usage="System.Array.Sort (keys, items, index, length, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TKey" />
        <TypeParameter Name="TValue" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="keys" Type="TKey[]" />
        <Parameter Name="items" Type="TValue[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IComparer&lt;TKey&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TKey">Tipo de los elementos de la matriz de claves.</typeparam>
        <typeparam name="TValue">Tipo de los elementos de la matriz de elementos.</typeparam>
        <param name="keys">
          <see cref="T:System.Array" /> unidimensional de base cero que contiene las claves que se van a ordenar.</param>
        <param name="items">Matriz <see cref="T:System.Array" /> unidimensional de base cero que contiene los elementos que se corresponden con las claves del parámetro <paramref name="keys" />; o <see langword="null" /> para ordenar solo <paramref name="keys" />.</param>
        <param name="index">Índice inicial del intervalo que se va a ordenar.</param>
        <param name="length">Número de elementos del intervalo que se va a ordenar.</param>
        <param name="comparer">La implementación de la interfaz genérica <see cref="T:System.Collections.Generic.IComparer`1" /> que se va a usar al comparar elementos o <see langword="null" /> para usar la implementación de la interfaz genérica <see cref="T:System.IComparable`1" /> de cada elemento.</param>
        <summary>Ordena un intervalo de elementos de un par de objetos <see cref="T:System.Array" /> (uno contiene las claves y el otro contiene los elementos correspondientes) en función de las claves de la primera matriz <see cref="T:System.Array" /> usando la interfaz genérica <see cref="T:System.Collections.Generic.IComparer`1" /> especificada.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cada clave de la `keys` <xref:System.Array> tiene un elemento correspondiente en el `items` <xref:System.Array>. Cuando se vuelve a ubicar una clave durante la ordenación, el elemento correspondiente en el `items` <xref:System.Array> del mismo modo se cambia de posición. Por lo tanto, el `items` <xref:System.Array> se ordenan según la disposición de las claves correspondientes en el `keys` <xref:System.Array>.  
  
 Si `comparer` es `null`, cada clave dentro del intervalo especificado de elementos de la `keys` <xref:System.Array> debe implementar la <xref:System.IComparable%601> interfaz genérica para poder realizar comparaciones con otras claves.  
  
 Puede ordenar si hay más elementos que las claves, pero no se ordenarán los elementos que no tengan ninguna de las claves correspondientes. No se puede ordenar si hay más teclas que los elementos; al hacerlo se inicia un <xref:System.ArgumentException>.  
  
 Si el criterio de ordenación no se ha completado correctamente, los resultados son indefinidos.  
  
 Este método utiliza el algoritmo de ordenación introspectiva (introsort) como sigue:  
  
-   Si el tamaño de partición es menos de 16 elementos, utiliza un [orden de inserción](https://en.wikipedia.org/wiki/Insertion_sort) algoritmo.  
  
-   Si el número de particiones es superior a 2 * registro<sup>N</sup>, donde *N* es el intervalo de la matriz de entrada, usa un [Heapsort](https://en.wikipedia.org/wiki/Heapsort) algoritmo.  
  
-   De lo contrario, se usa un [Quicksort](https://en.wikipedia.org/wiki/Quicksort) algoritmo.  
  
 Esta implementación realiza a una ordenación inestable; es decir, si dos elementos son iguales, es posible que no se conserve su orden. En cambio, una ordenación estable conserva el orden de los elementos que son iguales.  
  
 Para las matrices que se ordenan mediante el uso de los algoritmos Heapsort y Quicksort, en el peor de los casos, este método es O (`n` registro `n`) operación, donde `n` es `length`.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra el <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%29>, <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29>, <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%29>, y [\], TValue\<xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32% 2CSystem.Collections.Generic.IComparer%7b%60%600%7D%29 > sobrecargas de método genérico, para ordenar pares de matrices que representan las claves y valores.  
  
 El ejemplo de código define un comparador alternativo para las cadenas, denominado `ReverseCompare`, que implementa el `IComparer<string>`(`IComparer(Of String)` en Visual Basic, `IComparer<String^>` en Visual C++) interfaz genérica. Las llamadas de comparador el <xref:System.String.CompareTo%28System.String%29> método, invertir el orden de los términos de la comparación para que las cadenas ordenen alta o baja, en lugar de bajo a alto.  
  
 El ejemplo de código se crea y muestra una matriz de nombres de dinosaurios (las claves) y una matriz de enteros que representa la longitud máxima de cada dinosaurio en metros (los valores). Las matrices, a continuación, se ordena y se muestran varias veces:  
  
-   El <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%29> sobrecarga se utiliza para ordenar ambas matrices en orden de los nombres de dinosaurios de la primera matriz.  
  
-   El <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> sobrecarga y una instancia de `ReverseCompare` se usan para invertir el criterio de ordenación de las matrices emparejadas.  
  
-   El <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%29> sobrecarga se utiliza para ordenar los tres últimos elementos de ambas matrices.  
  
-   El [\], TValue\<xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29 > sobrecarga se utiliza para ordenar los tres últimos elementos de ambas matrices en orden inverso.  
  
> [!NOTE]
>  Las llamadas a los métodos genéricos no parece diferentes de las llamadas a sus homólogas no genéricas, ya que Visual Basic, C# y C++ deducen el tipo de parámetro de tipo genérico del tipo de los dos primeros argumentos. Si usas el [Ildasm.exe (Desensamblador de IL)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) para examinar el lenguaje intermedio de Microsoft (MSIL), puede ver que se llama a los métodos genéricos.  
  
 [!code-cpp[Array_Sort2IntIntIComparer#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_Sort2IntIntIComparer/cpp/source.cpp#1)]
 [!code-csharp[Array_Sort2IntIntIComparer#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_Sort2IntIntIComparer/cs/source.cs#1)]
 [!code-vb[Array_Sort2IntIntIComparer#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_Sort2IntIntIComparer/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El valor de <paramref name="keys" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> es menor que el límite inferior de <paramref name="keys" />.  
  
O bien 
 <paramref name="length" /> es menor que cero.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="items" /> no es <see langword="null" /> y el límite inferior de <paramref name="keys" /> no coincide con el límite inferior de <paramref name="items" />.  
  
O bien 
 <paramref name="items" /> no es <see langword="null" /> y la longitud de <paramref name="keys" /> es mayor que la longitud de <paramref name="items" />.  
  
O bien 
 <paramref name="index" /> y <paramref name="length" /> no especifican un intervalo válido en <paramref name="keys" /><see cref="T:System.Array" />.  
  
O bien 
 <paramref name="items" /> no es <see langword="null" />, y <paramref name="index" /> y <paramref name="length" /> no especifican un intervalo válido en el objeto <see cref="T:System.Array" /> de <paramref name="items" />.  
  
O bien 
La implementación de <paramref name="comparer" /> produjo un error durante la ordenación. Por ejemplo, es posible que <paramref name="comparer" /> no devuelva 0 al comparar un elemento consigo mismo.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="comparer" /> es <see langword="null" /> y uno o más elementos del objeto <see cref="T:System.Array" /> de <paramref name="keys" /> no implementan la interfaz genérica <see cref="T:System.IComparable`1" />.</exception>
        <block subset="none" type="usage">
          <para>El .NET Framework 4 y versiones anteriores usan solo el algoritmo Quicksort. QuickSort identifica comparadores no válidos en algunas situaciones en que se inicia la operación de ordenación una <see cref="T:System.IndexOutOfRangeException" /> excepción e inicia un <see cref="T:System.ArgumentException" /> excepción al llamador. A partir de la [!INCLUDE[net_v45](~/includes/net-v45-md.md)], es posible que las operaciones de ordenación que anteriormente produjo <see cref="T:System.ArgumentException" /> no se iniciará una excepción, ya que los algoritmos de ordenación y heapsort de inserción no detectan un comparador no válido. En su mayor parte, esto se aplica a las matrices con menos de 16 elementos.</para>
        </block>
        <altmember cref="T:System.Collections.Generic.IComparer`1" />
        <altmember cref="T:System.IComparable`1" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">Realizar operaciones de cadenas que no tienen en cuenta las referencias culturales en matrices</related>
      </Docs>
    </Member>
    <Member MemberName="SyncRoot">
      <MemberSignature Language="C#" Value="public object SyncRoot { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object SyncRoot" />
      <MemberSignature Language="DocId" Value="P:System.Array.SyncRoot" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property SyncRoot As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ SyncRoot { System::Object ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.SyncRoot : obj" Usage="System.Array.SyncRoot" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.SyncRoot</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene un objeto que se puede usar para sincronizar el acceso a <see cref="T:System.Array" />.</summary>
        <value>Objeto que se puede usar para sincronizar el acceso a <see cref="T:System.Array" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esta propiedad se implementa el <xref:System.Collections.ICollection?displayProperty=nameWithType> interfaz.  
  
 Clases de .NET framework en función de <xref:System.Array> proporcionar su propia versión sincronizada de la colección utilizando el <xref:System.Array.SyncRoot%2A> propiedad.  
  
 Las clases que utilizan matrices también pueden implementar su propia sincronización utilizando la <xref:System.Array.SyncRoot%2A> propiedad. El código de sincronización debe realizar operaciones en el `SyncRoot` de la colección, no directamente en la colección. De este modo, se garantiza el funcionamiento correcto de las colecciones derivadas de otros objetos. En concreto, mantiene la sincronización correcta con otros subprocesos que podrían modificar simultáneamente la colección. Tenga en cuenta que algunas implementaciones de <xref:System.Array.SyncRoot%2A> podría devolver el <xref:System.Array> propio.  
  
 Enumerar una colección no es un procedimiento seguro para subprocesos. Incluso cuando una colección está sincronizada, otros subprocesos todavía pueden modificarla, lo que hace que el enumerador produzca una excepción. Con el fin de garantizar la seguridad para la ejecución de subprocesos durante la enumeración, se puede bloquear la colección durante toda la enumeración o detectar las excepciones resultantes de los cambios realizados por otros subprocesos.  
  
 La recuperación del valor de esta propiedad es una operación O(1).  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra cómo bloquear una matriz durante toda la enumeración mediante el uso de la <xref:System.Array.SyncRoot%2A> propiedad.  
  
 [!code-cpp[System.Array.SyncRoot#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array.SyncRoot/cpp/source.cpp#1)]
 [!code-csharp[System.Array.SyncRoot#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array.SyncRoot/cs/source.cs#1)]
 [!code-vb[System.Array.SyncRoot#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array.SyncRoot/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Array.IsSynchronized" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.ICollection.Count">
      <MemberSignature Language="C#" Value="int System.Collections.ICollection.Count { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 System.Collections.ICollection.Count" />
      <MemberSignature Language="DocId" Value="P:System.Array.System#Collections#ICollection#Count" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property Count As Integer Implements ICollection.Count" />
      <MemberSignature Language="C++ CLI" Value="property int System::Collections::ICollection::Count { int get(); };" />
      <MemberSignature Language="F#" Usage="System.Collections.ICollection.Count" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.Count</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene el número de elementos incluidos en <see cref="T:System.Array" />.</summary>
        <value>Número de elementos contenidos en la colección.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este miembro es una implementación explícita de un miembro de interfaz. Solo se puede utilizar cuando la instancia de <xref:System.Array> se convierte en una interfaz <xref:System.Collections.ICollection>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.ICollection.IsSynchronized">
      <MemberSignature Language="C#" Value="bool System.Collections.ICollection.IsSynchronized { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Collections.ICollection.IsSynchronized" />
      <MemberSignature Language="DocId" Value="P:System.Array.System#Collections#ICollection#IsSynchronized" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsSynchronized As Boolean Implements ICollection.IsSynchronized" />
      <MemberSignature Language="C++ CLI" Value="property bool System::Collections::ICollection::IsSynchronized { bool get(); };" />
      <MemberSignature Language="F#" Usage="System.Collections.ICollection.IsSynchronized" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.IsSynchronized</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.ICollection.SyncRoot">
      <MemberSignature Language="C#" Value="object System.Collections.ICollection.SyncRoot { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object System.Collections.ICollection.SyncRoot" />
      <MemberSignature Language="DocId" Value="P:System.Array.System#Collections#ICollection#SyncRoot" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property SyncRoot As Object Implements ICollection.SyncRoot" />
      <MemberSignature Language="C++ CLI" Value="property System::Object ^ System::Collections::ICollection::SyncRoot { System::Object ^ get(); };" />
      <MemberSignature Language="F#" Usage="System.Collections.ICollection.SyncRoot" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.SyncRoot</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.Add">
      <MemberSignature Language="C#" Value="int IList.Add (object value);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int32 System.Collections.IList.Add(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.System#Collections#IList#Add(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Function Add (value As Object) As Integer Implements IList.Add" />
      <MemberSignature Language="C++ CLI" Value=" virtual int System.Collections.IList.Add(System::Object ^ value) = System::Collections::IList::Add;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IList.Add(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">Objeto que se va a agregar a <see cref="T:System.Collections.IList" />.</param>
        <summary>Cuando se llama a este método, siempre se produce una excepción <see cref="T:System.NotSupportedException" />.</summary>
        <returns>No se admite el agregar un valor a una matriz. No se devuelve ningún valor.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Normalmente, un <xref:System.Collections.IList.Add%2A?displayProperty=nameWithType> implementación agrega un miembro a una colección. Sin embargo, dado que las matrices tienen un tamaño fijo (la <xref:System.Array.IsFixedSize%2A> propiedad siempre devuelve `true`), este método siempre produce una <xref:System.NotSupportedException> excepción.  
  
 Este miembro es una implementación explícita de un miembro de interfaz. Solo se puede utilizar cuando la instancia de <xref:System.Array> se convierte en una interfaz <xref:System.Collections.IList>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">
          <see cref="T:System.Collections.IList" /> tiene un tamaño fijo.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.Clear">
      <MemberSignature Language="C#" Value="void IList.Clear ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Collections.IList.Clear() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.System#Collections#IList#Clear" />
      <MemberSignature Language="VB.NET" Value="Sub Clear () Implements IList.Clear" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Collections.IList.Clear() = System::Collections::IList::Clear;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IList.Clear</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Quita todos los elementos de <see cref="T:System.Collections.IList" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este miembro es una implementación explícita de un miembro de interfaz. Solo se puede utilizar cuando la instancia de <xref:System.Array> se convierte en una interfaz <xref:System.Collections.IList>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">
          <see cref="T:System.Collections.IList" /> es de solo lectura.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.Contains">
      <MemberSignature Language="C#" Value="bool IList.Contains (object value);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool System.Collections.IList.Contains(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.System#Collections#IList#Contains(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Function Contains (value As Object) As Boolean Implements IList.Contains" />
      <MemberSignature Language="C++ CLI" Value=" virtual bool System.Collections.IList.Contains(System::Object ^ value) = System::Collections::IList::Contains;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IList.Contains(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">Objeto que se va a buscar en la lista actual. El elemento que se va a buscar puede ser <see langword="null" /> para los tipos de referencia.</param>
        <summary>Determina si un elemento se encuentra en <see cref="T:System.Collections.IList" />.</summary>
        <returns>
          <see langword="true" /> si <paramref name="value" /> se encuentra en la matriz <see cref="T:System.Collections.IList" />; en caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este miembro es una implementación explícita de un miembro de interfaz. Solo se puede utilizar cuando la instancia de <xref:System.Array> se convierte en una interfaz <xref:System.Collections.IList>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.IndexOf">
      <MemberSignature Language="C#" Value="int IList.IndexOf (object value);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int32 System.Collections.IList.IndexOf(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.System#Collections#IList#IndexOf(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Function IndexOf (value As Object) As Integer Implements IList.IndexOf" />
      <MemberSignature Language="C++ CLI" Value=" virtual int System.Collections.IList.IndexOf(System::Object ^ value) = System::Collections::IList::IndexOf;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IList.IndexOf(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">Objeto que se va a buscar en la lista actual.</param>
        <summary>Determina el índice de un elemento específico de <see cref="T:System.Collections.IList" />.</summary>
        <returns>Es el índice del valor si se encuentra en la lista; en caso contrario, es -1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este miembro es una implementación explícita de un miembro de interfaz. Solo se puede utilizar cuando la instancia de <xref:System.Array> se convierte en una interfaz <xref:System.Collections.IList>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.Insert">
      <MemberSignature Language="C#" Value="void IList.Insert (int index, object value);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Collections.IList.Insert(int32 index, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.System#Collections#IList#Insert(System.Int32,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Sub Insert (index As Integer, value As Object) Implements IList.Insert" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Collections.IList.Insert(int index, System::Object ^ value) = System::Collections::IList::Insert;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IList.Insert(System.Int32,System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="index">Índice en el que debe insertarse <paramref name="value" />.</param>
        <param name="value">Objeto que se va a insertar.</param>
        <summary>Inserta un elemento en la interfaz <see cref="T:System.Collections.IList" />, en el índice especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este miembro es una implementación explícita de un miembro de interfaz. Solo se puede utilizar cuando la instancia de <xref:System.Array> se convierte en una interfaz <xref:System.Collections.IList>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> no es un índice válido para <see cref="T:System.Collections.IList" />.</exception>
        <exception cref="T:System.NotSupportedException">
          <see cref="T:System.Collections.IList" /> es de solo lectura.  
  
O bien 
El objeto <see cref="T:System.Collections.IList" /> tiene un tamaño fijo.</exception>
        <exception cref="T:System.NullReferenceException">
          <paramref name="value" /> es una referencia nula en la <see cref="T:System.Collections.IList" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.IsFixedSize">
      <MemberSignature Language="C#" Value="bool System.Collections.IList.IsFixedSize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Collections.IList.IsFixedSize" />
      <MemberSignature Language="DocId" Value="P:System.Array.System#Collections#IList#IsFixedSize" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsFixedSize As Boolean Implements IList.IsFixedSize" />
      <MemberSignature Language="C++ CLI" Value="property bool System::Collections::IList::IsFixedSize { bool get(); };" />
      <MemberSignature Language="F#" Usage="System.Collections.IList.IsFixedSize" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.IList.IsFixedSize</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.IsReadOnly">
      <MemberSignature Language="C#" Value="bool System.Collections.IList.IsReadOnly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Collections.IList.IsReadOnly" />
      <MemberSignature Language="DocId" Value="P:System.Array.System#Collections#IList#IsReadOnly" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsReadOnly As Boolean Implements IList.IsReadOnly" />
      <MemberSignature Language="C++ CLI" Value="property bool System::Collections::IList::IsReadOnly { bool get(); };" />
      <MemberSignature Language="F#" Usage="System.Collections.IList.IsReadOnly" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.IList.IsReadOnly</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.Item">
      <MemberSignature Language="C#" Value="object System.Collections.IList.Item[int index] { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object System.Collections.IList.Item(int32)" />
      <MemberSignature Language="DocId" Value="P:System.Array.System#Collections#IList#Item(System.Int32)" />
      <MemberSignature Language="VB.NET" Value=" Property Item(index As Integer) As Object Implements IList.Item" />
      <MemberSignature Language="C++ CLI" Value="property System::Object ^ System::Collections::IList::Item[int] { System::Object ^ get(int index); void set(int index, System::Object ^ value); };" />
      <MemberSignature Language="F#" Usage="System.Collections.IList.Item" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.IList.Item(System.Int32)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">Índice del elemento que se va a obtener o establecer.</param>
        <summary>Obtiene o establece el elemento en el índice especificado.</summary>
        <value>Elemento en el índice especificado.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este miembro es una implementación explícita de un miembro de interfaz. Solo se puede utilizar cuando la instancia de <xref:System.Array> se convierte en una interfaz <xref:System.Collections.IList>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> es menor que cero.  
  
O bien 
 <paramref name="index" /> es igual o mayor que <see cref="P:System.Collections.ICollection.Count" />.</exception>
        <exception cref="T:System.ArgumentException">El <see cref="T:System.Array" /> actual no tiene exactamente una dimensión.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.Remove">
      <MemberSignature Language="C#" Value="void IList.Remove (object value);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Collections.IList.Remove(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.System#Collections#IList#Remove(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Sub Remove (value As Object) Implements IList.Remove" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Collections.IList.Remove(System::Object ^ value) = System::Collections::IList::Remove;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IList.Remove(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">Objeto que se va a quitar de <see cref="T:System.Collections.IList" />.</param>
        <summary>Quita la primera aparición de un objeto específico de la interfaz <see cref="T:System.Collections.IList" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este miembro es una implementación explícita de un miembro de interfaz. Solo se puede utilizar cuando la instancia de <xref:System.Array> se convierte en una interfaz <xref:System.Collections.IList>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">
          <see cref="T:System.Collections.IList" /> es de solo lectura.  
  
O bien 
<see cref="T:System.Collections.IList" /> tiene un tamaño fijo.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.RemoveAt">
      <MemberSignature Language="C#" Value="void IList.RemoveAt (int index);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Collections.IList.RemoveAt(int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.System#Collections#IList#RemoveAt(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Sub RemoveAt (index As Integer) Implements IList.RemoveAt" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Collections.IList.RemoveAt(int index) = System::Collections::IList::RemoveAt;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IList.RemoveAt(System.Int32)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">Índice del elemento que se va a quitar.</param>
        <summary>Quita el elemento de la interfaz <see cref="T:System.Collections.IList" /> que se encuentra en el índice especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este miembro es una implementación explícita de un miembro de interfaz. Solo se puede utilizar cuando la instancia de <xref:System.Array> se convierte en una interfaz <xref:System.Collections.IList>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">El índice no es válido en <see cref="T:System.Collections.IList" />.</exception>
        <exception cref="T:System.NotSupportedException">
          <see cref="T:System.Collections.IList" /> es de solo lectura.  
  
O bien 
<see cref="T:System.Collections.IList" /> tiene un tamaño fijo.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IStructuralComparable.CompareTo">
      <MemberSignature Language="C#" Value="int IStructuralComparable.CompareTo (object other, System.Collections.IComparer comparer);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int32 System.Collections.IStructuralComparable.CompareTo(object other, class System.Collections.IComparer comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.System#Collections#IStructuralComparable#CompareTo(System.Object,System.Collections.IComparer)" />
      <MemberSignature Language="VB.NET" Value="Function CompareTo (other As Object, comparer As IComparer) As Integer Implements IStructuralComparable.CompareTo" />
      <MemberSignature Language="C++ CLI" Value=" virtual int System.Collections.IStructuralComparable.CompareTo(System::Object ^ other, System::Collections::IComparer ^ comparer) = System::Collections::IStructuralComparable::CompareTo;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IStructuralComparable.CompareTo(System.Object,System.Collections.IComparer)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.Object" />
        <Parameter Name="comparer" Type="System.Collections.IComparer" />
      </Parameters>
      <Docs>
        <param name="other">Objeto que se va a comparar con la instancia actual.</param>
        <param name="comparer">Objeto que compara el objeto actual y <paramref name="other" />.</param>
        <summary>Determina si el objeto de colección actual precede o sigue a otro objeto en el criterio de ordenación, o aparece en la misma posición que él.</summary>
        <returns>Un entero que indica la relación del objeto de la colección actual con otros, tal y como se muestra en la tabla siguiente.  
  
 <list type="table"><listheader><term> Valor devuelto 
 </term><description> Descripción 
 </description></listheader><item><term> -1 
 </term><description> La instancia actual precede a <paramref name="other" />.  
  
 </description></item><item><term> 0 
 </term><description> La instancia actual y <paramref name="other" /> son iguales.  
  
 </description></item><item><term> 1 
 </term><description> La instancia actual se encuentra detrás de <paramref name="other" />.  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este miembro es una implementación explícita de un miembro de interfaz. Solo se puede utilizar cuando la instancia de <xref:System.Array> se convierte en una interfaz <xref:System.Collections.IStructuralComparable>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IStructuralEquatable.Equals">
      <MemberSignature Language="C#" Value="bool IStructuralEquatable.Equals (object other, System.Collections.IEqualityComparer comparer);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool System.Collections.IStructuralEquatable.Equals(object other, class System.Collections.IEqualityComparer comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.System#Collections#IStructuralEquatable#Equals(System.Object,System.Collections.IEqualityComparer)" />
      <MemberSignature Language="VB.NET" Value="Function Equals (other As Object, comparer As IEqualityComparer) As Boolean Implements IStructuralEquatable.Equals" />
      <MemberSignature Language="C++ CLI" Value=" virtual bool System.Collections.IStructuralEquatable.Equals(System::Object ^ other, System::Collections::IEqualityComparer ^ comparer) = System::Collections::IStructuralEquatable::Equals;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IStructuralEquatable.Equals(System.Object,System.Collections.IEqualityComparer)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.Object" />
        <Parameter Name="comparer" Type="System.Collections.IEqualityComparer" />
      </Parameters>
      <Docs>
        <param name="other">Objeto que se va a comparar con la instancia actual.</param>
        <param name="comparer">Un objeto que determina si la instancia actual y <paramref name="other" /> son iguales.</param>
        <summary>Determina si un objeto especificado es igual a la instancia actual.</summary>
        <returns>Es <see langword="true" /> si los dos objetos son iguales; en caso contrario, es <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este miembro es una implementación explícita de un miembro de interfaz. Solo se puede utilizar cuando la instancia de <xref:System.Array> se convierte en una interfaz <xref:System.Collections.IStructuralEquatable>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IStructuralEquatable.GetHashCode">
      <MemberSignature Language="C#" Value="int IStructuralEquatable.GetHashCode (System.Collections.IEqualityComparer comparer);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int32 System.Collections.IStructuralEquatable.GetHashCode(class System.Collections.IEqualityComparer comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.System#Collections#IStructuralEquatable#GetHashCode(System.Collections.IEqualityComparer)" />
      <MemberSignature Language="VB.NET" Value="Function GetHashCode (comparer As IEqualityComparer) As Integer Implements IStructuralEquatable.GetHashCode" />
      <MemberSignature Language="C++ CLI" Value=" virtual int System.Collections.IStructuralEquatable.GetHashCode(System::Collections::IEqualityComparer ^ comparer) = System::Collections::IStructuralEquatable::GetHashCode;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IStructuralEquatable.GetHashCode(System.Collections.IEqualityComparer)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="comparer" Type="System.Collections.IEqualityComparer" />
      </Parameters>
      <Docs>
        <param name="comparer">Objeto que calcula el código hash del objeto actual.</param>
        <summary>Devuelve un código hash de la instancia actual.</summary>
        <returns>Código hash de la instancia actual.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este miembro es una implementación explícita de un miembro de interfaz. Solo se puede utilizar cuando la instancia de <xref:System.Array> se convierte en una interfaz <xref:System.Collections.IStructuralEquatable>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TrueForAll&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static bool TrueForAll&lt;T&gt; (T[] array, Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TrueForAll&lt;T&gt;(!!T[] array, class System.Predicate`1&lt;!!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.TrueForAll``1(``0[],System.Predicate{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TrueForAll(Of T) (array As T(), match As Predicate(Of T)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static bool TrueForAll(cli::array &lt;T&gt; ^ array, Predicate&lt;T&gt; ^ match);" />
      <MemberSignature Language="F#" Value="static member TrueForAll : 'T[] * Predicate&lt;'T&gt; -&gt; bool" Usage="System.Array.TrueForAll (array, match)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">Tipo de los elementos de la matriz.</typeparam>
        <param name="array">Matriz <see cref="T:System.Array" /> unidimensional de base cero en la que se van a comprobar las condiciones.</param>
        <param name="match">El predicado que define las condiciones que se van a comprobar en los elementos.</param>
        <summary>Determina si cada elemento de la matriz cumple las condiciones definidas por el predicado especificado.</summary>
        <returns>
          <see langword="true" /> si cada elemento de <paramref name="array" /> cumple las condiciones definidas por el predicado especificado; de lo contrario, <see langword="false" />. Si no hay ningún elemento en la matriz, el valor devuelto es <see langword="true" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Predicate%601> es un delegado a un método que devuelve`true` si el objeto pasado a coincide con las condiciones definidas en el delegado.  Los elementos de `array` individualmente se pasan a la <xref:System.Predicate%601>, y se detiene el procesamiento cuando el delegado devuelve `false` para cualquier elemento.  
  
 Este método es O (`n`) operación, donde `n` es el <xref:System.Array.Length%2A> de `array`.  
  
   
  
## Examples  
 El ejemplo siguiente determina si el último carácter de cada elemento de una matriz de cadenas es un número. Crea dos matrices de cadenas. El primer arrayincludes ambas cadenas que finalicen con cadenas que finalizan con caracteres alfanuméricos y caracteres alfabéticos. La segunda matriz consta solo de cadenas que finalizan con caracteres numéricos. El ejemplo también define un `EndWithANumber` método cuya firma coincida con el <xref:System.Predicate%601> delegar. En el ejemplo se pasa cada matriz a la <xref:System.Array.TrueForAll%2A> método junto con un delegado que representa el `EndsWithANumber` método.  
  
 [!code-csharp[System.Array.TrueForAll#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.array.trueforall/cs/trueforall2.cs#2)]
 [!code-vb[System.Array.TrueForAll#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.array.trueforall/vb/trueforall2.vb#2)]  
  
 El ejemplo siguiente es similar a la primera, excepto en que pasa la matriz de cadenas para el <xref:System.Array.TrueForAll%2A> método junto con una expresión lambda que determina si un elemento de matriz en particular termina con la representación de cadena de un número.  
  
 [!code-csharp[System.Array.TrueForAll#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.array.trueforall/cs/trueforall1.cs#1)]
 [!code-vb[System.Array.TrueForAll#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.array.trueforall/vb/trueforall1.vb#1)]  
  
 En ambos casos, el <xref:System.Array.TrueForAll%2A> devuelve del método `false` tan pronto como encuentra el primer elemento de matriz no termina con un número. De lo contrario, devuelve `true` después de recorrer en iteración todos los elementos de la matriz.  
  
> [!NOTE]
>  Como se muestra en ambos ejemplos, en C# y Visual Basic, no es necesario crear la `Predicate<string>` delegar (`Predicate(Of String)` en Visual Basic) explícitamente. Estos lenguajes deducen al delegado correcto del contexto y lo crean automáticamente.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El valor de <paramref name="array" /> es <see langword="null" />.  
  
O bien 
 El valor de <paramref name="match" /> es <see langword="null" />.</exception>
        <altmember cref="M:System.Array.Exists``1(``0[],System.Predicate{``0})" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
  </Members>
</Type>