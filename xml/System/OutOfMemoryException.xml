<Type Name="OutOfMemoryException" FullName="System.OutOfMemoryException">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="910934c01288ec01071b99b363ba0c0e473ede08" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="es-ES" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
    <Meta Name="ms.locfileid" Value="30728559" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class OutOfMemoryException : SystemException" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable beforefieldinit OutOfMemoryException extends System.SystemException" />
  <TypeSignature Language="DocId" Value="T:System.OutOfMemoryException" />
  <TypeSignature Language="VB.NET" Value="Public Class OutOfMemoryException&#xA;Inherits SystemException" />
  <TypeSignature Language="C++ CLI" Value="public ref class OutOfMemoryException : SystemException" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Exception</BaseTypeName>
    <BaseTypeName FrameworkAlternate="netframework-4.5">System.SystemException</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Excepción que se produce cuando no hay suficiente memoria para continuar con la ejecución de un programa.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un <xref:System.OutOfMemoryException> excepción tiene dos causas principales:  
  
-   Está intentando ampliar un <xref:System.Text.StringBuilder> objeto más allá de la longitud definida por su <xref:System.Text.StringBuilder.MaxCapacity%2A?displayProperty=nameWithType> propiedad.  
  
-   Common language runtime no puede asignar suficiente memoria contigua para realizar correctamente una operación. Se puede producir esta excepción por cualquier llamada de asignación o un método de propiedad que requiere una asignación de memoria. Para obtener más información sobre la causa de la <xref:System.OutOfMemoryException> excepción, vea ["memoria insuficiente" no hace referencia a la memoria física](http://blogs.msdn.com/b/ericlippert/archive/2009/06/08/out-of-memory-does-not-refer-to-physical-memory.aspx).  
  
     Este tipo de <xref:System.OutOfMemoryException> excepción representa un error catastrófico. Si opta por controlar la excepción, debe incluir un `catch` bloque que llama el <xref:System.Environment.FailFast%2A?displayProperty=nameWithType> método para finalizar la aplicación y agregue una entrada al registro de eventos del sistema, como en el ejemplo siguiente se hace.  
  
     [!code-csharp[System.OutOfMemoryException#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.outofmemoryexception/cs/failfast1.cs#2)]
     [!code-vb[System.OutOfMemoryException#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.outofmemoryexception/vb/failfast1.vb#2)]  
  
 Algunas de las condiciones en las que se produce la excepción y las acciones que puede realizar para eliminar incluyen los siguientes:  
  
 Se está llamando a la <xref:System.Text.StringBuilder.Insert%2A?displayProperty=nameWithType> método.  
 Está intentando aumentar la longitud de un <xref:System.Text.StringBuilder> objeto más allá del tamaño especificado por su <xref:System.Text.StringBuilder.MaxCapacity%2A?displayProperty=nameWithType> propiedad. En el ejemplo siguiente se muestra la <xref:System.OutOfMemoryException> excepción producida por una llamada a la <xref:System.Text.StringBuilder.Insert%28System.Int32%2CSystem.String%2CSystem.Int32%29?displayProperty=nameWithType> método cuando el ejemplo se intenta insertar una cadena que puede provocar que el objeto <xref:System.Text.StringBuilder.Length%2A> propiedad supere su capacidad máxima.  
  
 [!code-csharp[System.OutOfMemoryException#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.outofmemoryexception/cs/sb_example1.cs#1)]
 [!code-vb[System.OutOfMemoryException#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.outofmemoryexception/vb/sb_example1.vb#1)]  
  
 Puede realizar una de las siguientes acciones para solucionar el error:  
  
-   Reemplace la llamada a la <xref:System.Text.StringBuilder.%23ctor%28System.Int32%2CSystem.Int32%29?displayProperty=nameWithType> constructor con una llamada a cualquier otro <xref:System.Text.StringBuilder> sobrecarga del constructor. La capacidad máxima de la <xref:System.Text.StringBuilder> objeto se establecerá en su valor predeterminado, que es <xref:System.Int32.MaxValue?displayProperty=nameWithType>.  
  
-   Llame a la <xref:System.Text.StringBuilder.%23ctor%28System.Int32%2CSystem.Int32%29?displayProperty=nameWithType> constructor con un `maxCapacity` valor que es lo suficientemente grande como para dar cabida a las expansiones para los <xref:System.Text.StringBuilder> objeto.  
  
 La aplicación se ejecuta como un proceso de 32 bits.  
 procesos de 32 bits pueden asignar un máximo de 2GB de memoria de modo de usuario virtual en los sistemas de 32 bits y 4GB de memoria de modo de usuario virtual en los sistemas de 64 bits. Esto puede que sea más difícil para common language runtime asignar memoria contigua suficiente cuando se necesita una asignación grande. En cambio, los procesos de 64 bits pueden asignar hasta 8TB de memoria virtual. Para resolver esta excepción, vuelva a compilar la aplicación que tenga como destino una plataforma de 64 bits. Para obtener información sobre plataformas específicas en Visual Studio de destino, vea [Cómo: configurar proyectos para plataformas de destino](http://msdn.microsoft.com/library/845302fc-273d-4f81-820a-7296ce91bd76).  
  
 La aplicación pierde recursos no administrados  
 Aunque el recolector de elementos no utilizados puede liberar memoria asignada a los tipos administrados, no administra la memoria asignada a los recursos no administrados como identificadores de sistema operativo (incluidos los identificadores de archivos, archivos asignados en memoria, canalizaciones, las claves del registro y controladores de espera) y bloques de memoria asignados directamente por llamadas a la API de Windows o mediante llamadas a funciones de asignación de memoria como `malloc`. Los tipos que consumen recursos no administrados que implementan el <xref:System.IDisposable> interfaz.  
  
 Si va a consumir un tipo que usa recursos no administrados, debe asegurarse de llamar a su <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType> método cuando termine de usarlo. (Algunos tipos también implementan un `Close` método que es idéntico en función de para un `Dispose` método.) Para obtener más información, consulte el [utilizando objetos que implemente IDisposable](~/docs/standard/garbage-collection/using-objects.md) tema.  
  
 Si ha creado un tipo que usa recursos no administrados, asegúrese de que ha implementado el patrón de Dispose y, si es necesario, proporciona un finalizador. Para obtener más información, consulte el [patrón Dispose](~/docs/standard/design-guidelines/dispose-pattern.md), [implementa un método Dispose](~/docs/standard/garbage-collection/implementing-dispose.md), y <xref:System.Object.Finalize%2A?displayProperty=nameWithType> temas.  
  
 Está intentando crear una matriz grande en un proceso de 64 bits.  
 De forma predeterminada, common language runtime no permite solo objetos cuyo tamaño supera los 2GB. Para invalidar este comportamiento predeterminado, puede usar el archivo de configuración para habilitar matrices cuyo tamaño total supera los 2 GB.  
  
 Se trabaja con grandes conjuntos de datos (por ejemplo, matrices, colecciones ni conjuntos de datos de la base de datos) en la memoria.  
 Cuando las estructuras de datos o conjuntos de datos que residen en la memoria sea tan grandes que common language runtime es no se puede asignar suficiente memoria contigua para ellos, un <xref:System.OutOfMemoryException> resultados de la excepción.  
  
 Para evitar la <xref:System.OutOfMemoryException> excepciones, debe modificar la aplicación para que los datos con menos están residentes en memoria o los datos se dividen en segmentos que requieren la asignación de memoria menor. Por ejemplo:  
  
-   Si va a recuperar todos los datos de una base de datos y, a continuación, filtrarlos en su aplicación para minimizar los recorridos y en el servidor, debe modificar las consultas para devolver sólo el subconjunto de datos que necesita la aplicación. Al trabajar con tablas de gran tamaño, varias consultas casi siempre son más eficaz que recuperar todos los datos en una sola tabla y, a continuación, la manipulación.  
  
-   Si va a ejecutar las consultas que los usuarios crear dinámicamente, debe asegurarse de que se limita el número de registros devueltos por la consulta.  
  
-   Si está utilizando matrices de gran tamaño u otra colección de objetos cuyos resultados de tamaño en un <xref:System.OutOfMemoryException> excepción, debe modificar la aplicación para que funcione de los datos en subconjuntos, en lugar de trabajar con ellos a la vez.  
  
 En el ejemplo siguiente se obtiene una matriz que consta de 200 millones de valores de punto flotante y, a continuación, calcula su Media. El resultado del ejemplo muestra que, dado que el ejemplo almacena toda la matriz en la memoria antes de que calcula la media, un <xref:System.OutOfMemoryException> es se produce.  
  
 [!code-csharp[System.OutOfMemoryException#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.outofmemoryexception/cs/data1.cs#3)]
 [!code-vb[System.OutOfMemoryException#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.outofmemoryexception/vb/data1.vb#3)]  
  
 En el ejemplo siguiente se elimina el <xref:System.OutOfMemoryException> excepción al procesar los datos de entrada sin almacenar todo el conjunto de datos en memoria, serializar los datos en un archivo si es necesario para permitir un procesamiento posterior (estas líneas se incluyen entre comentarios en el ejemplo, puesto que en este caso que generan un archivo cuyo tamaño es mayor que 1 GB) y devuelve el promedio calculado y el número de casos a la rutina que realiza la llamada.  
  
 [!code-csharp[System.OutOfMemoryException#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.outofmemoryexception/cs/data2.cs#4)]
 [!code-vb[System.OutOfMemoryException#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.outofmemoryexception/vb/data2.vb#4)]  
  
 Repetidamente va a concatenar cadenas de gran tamaño.  
 Dado que las cadenas son inmutables, cada operación de concatenación de cadenas crea una nueva cadena. El impacto de las cadenas pequeñas o para un pequeño número de operaciones de concatenación es insignificante. Pero para cadenas de gran tamaño o un gran número de operaciones de concatenación, concatenación de cadenas puede conducir a un gran número de asignaciones de memoria y la fragmentación de memoria, un rendimiento bajo y posiblemente <xref:System.OutOfMemoryException> excepciones.  
  
 Cuando la concatenación de cadenas de gran tamaño o realizar un gran número de operaciones de concatenación, debe usar el <xref:System.Text.StringBuilder> clase en lugar de la <xref:System.String> clase. Cuando haya terminado de manipular la cadena, convertir la <xref:System.Text.StringBuilder> instancia en una cadena mediante una llamada a la <xref:System.Text.StringBuilder.ToString%2A?displayProperty=nameWithType> método.  
  
 Anclar un gran número de objetos en memoria.  
 Anclar un gran número de objetos en la memoria durante largos períodos puede dificultar el recolector de elementos no utilizados asignar bloques de memoria contiguas. Si se ancló un gran número de objetos en memoria, por ejemplo mediante el uso de la `fixed` instrucción en C# o mediante una llamada a la <xref:System.Runtime.InteropServices.GCHandle.Alloc%28System.Object%2CSystem.Runtime.InteropServices.GCHandleType%29?displayProperty=nameWithType> método con un tipo de identificador de <xref:System.Runtime.InteropServices.GCHandleType.Pinned?displayProperty=nameWithType>, puede hacer lo siguiente a la dirección el <xref:System.OutOfMemoryException> excepción.  
  
-   Evaluar si realmente necesita cada objeto fijarse,  
  
-   Asegúrese de que cada objeto está anclado tan pronto como sea posible.  
  
-   Asegúrese de que cada llamada a la <xref:System.Runtime.InteropServices.GCHandle.Alloc%28System.Object%2CSystem.Runtime.InteropServices.GCHandleType%29?displayProperty=nameWithType> método en la memoria del pin tiene una llamada correspondiente a la <xref:System.Runtime.InteropServices.GCHandle.Free%2A?displayProperty=nameWithType> método Desanclar esa memoria.  
  
 El siguiente Microsoft intermedias instrucciones (MSIL) producen un <xref:System.OutOfMemoryException> excepción:  
  
-   [box](http://msdn.microsoft.com/library/system.reflection.emit.opcodes.box.aspx)  
  
-   [newarr](http://msdn.microsoft.com/library/system.reflection.emit.opcodes.newarr.aspx)  
  
-   [newobj](http://msdn.microsoft.com/library/system.reflection.emit.opcodes.newobj.aspx)newobj  
  
 <xref:System.OutOfMemoryException> usa el valor HRESULT `COR_E_OUTOFMEMORY`, que tiene el valor 0x8007000E.  
  
 Para obtener una lista de valores de propiedad iniciales para una instancia de <xref:System.OutOfMemoryException>, consulte el <xref:System.OutOfMemoryException.%23ctor%2A> constructores.  
  
> [!NOTE]
>  El valor de los heredados <xref:System.Exception.Data%2A> propiedad es siempre `null`.  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Exception" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.OutOfMemoryException" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public OutOfMemoryException ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.OutOfMemoryException.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; OutOfMemoryException();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.OutOfMemoryException" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este constructor inicializa la <xref:System.Exception.Message%2A> propiedad de la nueva instancia en un mensaje proporcionado por el sistema que describe el error, como"no hay suficiente memoria para continuar con la ejecución del programa". Este mensaje tiene en cuenta la referencia cultural del sistema actual.  
  
 En la tabla siguiente se muestran los valores de propiedad iniciales para una instancia de <xref:System.OutOfMemoryException>.  
  
|Propiedad.|Valor|  
|--------------|-----------|  
|<xref:System.Exception.InnerException%2A>|`null`.|  
|<xref:System.Exception.Message%2A>|La cadena del mensaje de error localizado.|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public OutOfMemoryException (string message);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string message) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.OutOfMemoryException.#ctor(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (message As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; OutOfMemoryException(System::String ^ message);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="message" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="message">Mensaje que describe el error.</param>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.OutOfMemoryException" /> con el mensaje de error especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se pretende que el contenido del parámetro `message` sea inteligible. El autor de llamada de este constructor debe asegurarse de que la cadena se haya adaptado para la referencia cultural actual del sistema.  
  
 En la tabla siguiente se muestran los valores de propiedad iniciales para una instancia de <xref:System.OutOfMemoryException>.  
  
|Propiedad.|Valor|  
|--------------|-----------|  
|<xref:System.Exception.InnerException%2A>|Referencia nula (`Nothing` en Visual Basic).|  
|<xref:System.Exception.Message%2A>|Cadena con el mensaje de error.|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected OutOfMemoryException (System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(class System.Runtime.Serialization.SerializationInfo info, valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.OutOfMemoryException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New (info As SerializationInfo, context As StreamingContext)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; OutOfMemoryException(System::Runtime::Serialization::SerializationInfo ^ info, System::Runtime::Serialization::StreamingContext context);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="info" Type="System.Runtime.Serialization.SerializationInfo" />
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" />
      </Parameters>
      <Docs>
        <param name="info">Objeto que contiene los datos del objeto serializados.</param>
        <param name="context">Información contextual acerca del origen o del destino.</param>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.OutOfMemoryException" /> con datos serializados.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Durante la deserialización se llama a este constructor para reconstituir el objeto de excepción transmitido en una secuencia. Para obtener más información, consulte [serialización XML y SOAP](~/docs/standard/serialization/xml-and-soap-serialization.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public OutOfMemoryException (string message, Exception innerException);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string message, class System.Exception innerException) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.OutOfMemoryException.#ctor(System.String,System.Exception)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (message As String, innerException As Exception)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; OutOfMemoryException(System::String ^ message, Exception ^ innerException);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="message" Type="System.String" />
        <Parameter Name="innerException" Type="System.Exception" />
      </Parameters>
      <Docs>
        <param name="message">Mensaje de error que explica el motivo de la excepción.</param>
        <param name="innerException">Excepción que es la causa de la excepción actual. Si el parámetro <c>innerException</c> no es una referencia nula (<see langword="Nothing" /> en Visual Basic), la excepción actual se inicia en un bloque <see langword="catch" /> que controla la excepción interna.</param>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.OutOfMemoryException" /> con el mensaje de error especificado y una referencia a la excepción interna que representa la causa de esta excepción.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Una excepción que se produce como resultado directo de una excepción anterior puede incluir una referencia a la excepción anterior de la propiedad <xref:System.Exception.InnerException%2A>. La propiedad <xref:System.Exception.InnerException%2A> devuelve el mismo valor pasado al constructor, o una referencia nula (`Nothing` en Visual Basic) si la propiedad <xref:System.Exception.InnerException%2A> no proporciona el valor de la excepción interna al constructor.  
  
 En la tabla siguiente se muestran los valores de propiedad iniciales para una instancia de <xref:System.OutOfMemoryException>.  
  
|Propiedad.|Valor|  
|--------------|-----------|  
|<xref:System.Exception.InnerException%2A>|Referencia a la excepción interna.|  
|<xref:System.Exception.Message%2A>|Cadena con el mensaje de error.|  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Exception" />
      </Docs>
    </Member>
  </Members>
</Type>