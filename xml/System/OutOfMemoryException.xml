<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="OutOfMemoryException.xml" source-language="en-US" target-language="es-ES">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-15c36f0" tool-company="Microsoft" />
      <xliffext:skl_file_name xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">02cd5861-7ce2-4a82-b358-31f8435a0ac5910934c01288ec01071b99b363ba0c0e473ede08.skl</xliffext:skl_file_name>
      <xliffext:version xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">1.2</xliffext:version>
      <xliffext:ms.openlocfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">910934c01288ec01071b99b363ba0c0e473ede08</xliffext:ms.openlocfilehash>
      <xliffext:ms.sourcegitcommit xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b</xliffext:ms.sourcegitcommit>
      <xliffext:ms.lasthandoff xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">04/03/2018</xliffext:ms.lasthandoff>
      <xliffext:moniker_ids xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">netcore-1.0,netcore-1.1,netcore-2.0,netcore-2.1,netframework-4.5.1,netframework-4.5.2,netframework-4.5,netframework-4.6.1,netframework-4.6.2,netframework-4.6,netframework-4.7.1,netframework-4.7,netstandard-1.0,netstandard-1.1,netstandard-1.2,netstandard-1.3,netstandard-1.4,netstandard-1.5,netstandard-1.6,netstandard-2.0,xamarinandroid-7.1,xamarinios-10.8,xamarinmac-3.0</xliffext:moniker_ids>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve" uid="T:System.OutOfMemoryException">
          <source>The exception that is thrown when there is not enough memory to continue the execution of a program.</source>
          <target state="translated">Excepción que se produce cuando no hay suficiente memoria para continuar con la ejecución de un programa.</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.OutOfMemoryException">
          <source>An <ph id="ph1">&lt;xref:System.OutOfMemoryException&gt;</ph> exception has two major causes:</source>
          <target state="translated">Un <ph id="ph1">&lt;xref:System.OutOfMemoryException&gt;</ph> excepción tiene dos causas principales:</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.OutOfMemoryException">
          <source>You are attempting to expand a <ph id="ph1">&lt;xref:System.Text.StringBuilder&gt;</ph> object beyond the length defined by its <ph id="ph2">&lt;xref:System.Text.StringBuilder.MaxCapacity%2A?displayProperty=nameWithType&gt;</ph> property.</source>
          <target state="translated">Está intentando ampliar un <ph id="ph1">&lt;xref:System.Text.StringBuilder&gt;</ph> objeto más allá de la longitud definida por su <ph id="ph2">&lt;xref:System.Text.StringBuilder.MaxCapacity%2A?displayProperty=nameWithType&gt;</ph> propiedad.</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.OutOfMemoryException">
          <source>The common language runtime cannot allocate enough contiguous memory to successfully perform an operation.</source>
          <target state="translated">Common language runtime no puede asignar suficiente memoria contigua para realizar correctamente una operación.</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.OutOfMemoryException">
          <source>This exception can be thrown by any property assignment or method call that requires a memory allocation.</source>
          <target state="translated">Se puede producir esta excepción por cualquier llamada de asignación o un método de propiedad que requiere una asignación de memoria.</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.OutOfMemoryException">
          <source>For more information on the cause of the <ph id="ph1">&lt;xref:System.OutOfMemoryException&gt;</ph> exception, see <bpt id="p1">[</bpt>"Out of Memory" Does Not Refer to Physical Memory<ept id="p1">](http://blogs.msdn.com/b/ericlippert/archive/2009/06/08/out-of-memory-does-not-refer-to-physical-memory.aspx)</ept>.</source>
          <target state="translated">Para obtener más información sobre la causa de la <ph id="ph1">&lt;xref:System.OutOfMemoryException&gt;</ph> excepción, vea <bpt id="p1">[</bpt>"memoria insuficiente" no hace referencia a la memoria física<ept id="p1">](http://blogs.msdn.com/b/ericlippert/archive/2009/06/08/out-of-memory-does-not-refer-to-physical-memory.aspx)</ept>.</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.OutOfMemoryException">
          <source>This type of <ph id="ph1">&lt;xref:System.OutOfMemoryException&gt;</ph> exception represents a catastrophic failure.</source>
          <target state="translated">Este tipo de <ph id="ph1">&lt;xref:System.OutOfMemoryException&gt;</ph> excepción representa un error catastrófico.</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.OutOfMemoryException">
          <source>If you choose to handle the exception, you should include a <ph id="ph1">`catch`</ph> block that calls the <ph id="ph2">&lt;xref:System.Environment.FailFast%2A?displayProperty=nameWithType&gt;</ph> method to terminate your app and add an entry to the system event log, as the following example does.</source>
          <target state="translated">Si opta por controlar la excepción, debe incluir un <ph id="ph1">`catch`</ph> bloque que llama el <ph id="ph2">&lt;xref:System.Environment.FailFast%2A?displayProperty=nameWithType&gt;</ph> método para finalizar la aplicación y agregue una entrada al registro de eventos del sistema, como en el ejemplo siguiente se hace.</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.OutOfMemoryException">
          <source>Some of the conditions under which the exception is thrown and the actions you can take to eliminate it include the following:</source>
          <target state="translated">Algunas de las condiciones en las que se produce la excepción y las acciones que puede realizar para eliminar incluyen los siguientes:</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.OutOfMemoryException">
          <source>You are calling the <ph id="ph1">&lt;xref:System.Text.StringBuilder.Insert%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">Se está llamando a la <ph id="ph1">&lt;xref:System.Text.StringBuilder.Insert%2A?displayProperty=nameWithType&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.OutOfMemoryException">
          <source>You are attempting to increase the length of a <ph id="ph1">&lt;xref:System.Text.StringBuilder&gt;</ph> object beyond the size specified by its <ph id="ph2">&lt;xref:System.Text.StringBuilder.MaxCapacity%2A?displayProperty=nameWithType&gt;</ph> property.</source>
          <target state="translated">Está intentando aumentar la longitud de un <ph id="ph1">&lt;xref:System.Text.StringBuilder&gt;</ph> objeto más allá del tamaño especificado por su <ph id="ph2">&lt;xref:System.Text.StringBuilder.MaxCapacity%2A?displayProperty=nameWithType&gt;</ph> propiedad.</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.OutOfMemoryException">
          <source>The following example illustrates the <ph id="ph1">&lt;xref:System.OutOfMemoryException&gt;</ph> exception thrown by a call to the <ph id="ph2">&lt;xref:System.Text.StringBuilder.Insert%28System.Int32%2CSystem.String%2CSystem.Int32%29?displayProperty=nameWithType&gt;</ph> method when the example tries to insert a string that would cause the object's <ph id="ph3">&lt;xref:System.Text.StringBuilder.Length%2A&gt;</ph> property to exceed its maximum capacity.</source>
          <target state="translated">En el ejemplo siguiente se muestra la <ph id="ph1">&lt;xref:System.OutOfMemoryException&gt;</ph> excepción producida por una llamada a la <ph id="ph2">&lt;xref:System.Text.StringBuilder.Insert%28System.Int32%2CSystem.String%2CSystem.Int32%29?displayProperty=nameWithType&gt;</ph> método cuando el ejemplo se intenta insertar una cadena que puede provocar que el objeto <ph id="ph3">&lt;xref:System.Text.StringBuilder.Length%2A&gt;</ph> propiedad supere su capacidad máxima.</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.OutOfMemoryException">
          <source>You can do either of the following to address the error:</source>
          <target state="translated">Puede realizar una de las siguientes acciones para solucionar el error:</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.OutOfMemoryException">
          <source>Replace the call to the <ph id="ph1">&lt;xref:System.Text.StringBuilder.%23ctor%28System.Int32%2CSystem.Int32%29?displayProperty=nameWithType&gt;</ph> constructor with a call any other <ph id="ph2">&lt;xref:System.Text.StringBuilder&gt;</ph> constructor overload.</source>
          <target state="translated">Reemplace la llamada a la <ph id="ph1">&lt;xref:System.Text.StringBuilder.%23ctor%28System.Int32%2CSystem.Int32%29?displayProperty=nameWithType&gt;</ph> constructor con una llamada a cualquier otro <ph id="ph2">&lt;xref:System.Text.StringBuilder&gt;</ph> sobrecarga del constructor.</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.OutOfMemoryException">
          <source>The maximum capacity of your <ph id="ph1">&lt;xref:System.Text.StringBuilder&gt;</ph> object will be set to its default value, which is <ph id="ph2">&lt;xref:System.Int32.MaxValue?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">La capacidad máxima de la <ph id="ph1">&lt;xref:System.Text.StringBuilder&gt;</ph> objeto se establecerá en su valor predeterminado, que es <ph id="ph2">&lt;xref:System.Int32.MaxValue?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.OutOfMemoryException">
          <source>Call the <ph id="ph1">&lt;xref:System.Text.StringBuilder.%23ctor%28System.Int32%2CSystem.Int32%29?displayProperty=nameWithType&gt;</ph> constructor with a <ph id="ph2">`maxCapacity`</ph> value that is large enough to accommodate any expansions to the <ph id="ph3">&lt;xref:System.Text.StringBuilder&gt;</ph> object.</source>
          <target state="translated">Llame a la <ph id="ph1">&lt;xref:System.Text.StringBuilder.%23ctor%28System.Int32%2CSystem.Int32%29?displayProperty=nameWithType&gt;</ph> constructor con un <ph id="ph2">`maxCapacity`</ph> valor que es lo suficientemente grande como para dar cabida a las expansiones para los <ph id="ph3">&lt;xref:System.Text.StringBuilder&gt;</ph> objeto.</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.OutOfMemoryException">
          <source>Your app runs as a 32-bit process.</source>
          <target state="translated">La aplicación se ejecuta como un proceso de 32 bits.</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.OutOfMemoryException">
          <source>32-bit processes can allocate a maximum of 2GB of virtual user-mode memory on 32-bit systems, and 4GB of virtual user-mode memory on 64-bit systems.</source>
          <target state="translated">procesos de 32 bits pueden asignar un máximo de 2GB de memoria de modo de usuario virtual en los sistemas de 32 bits y 4GB de memoria de modo de usuario virtual en los sistemas de 64 bits.</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.OutOfMemoryException">
          <source>This can make it more difficult for the common language runtime to allocate sufficient contiguous memory when a large allocation is needed.</source>
          <target state="translated">Esto puede que sea más difícil para common language runtime asignar memoria contigua suficiente cuando se necesita una asignación grande.</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.OutOfMemoryException">
          <source>In contrast, 64-bit processes can allocate up to 8TB of virtual memory.</source>
          <target state="translated">En cambio, los procesos de 64 bits pueden asignar hasta 8TB de memoria virtual.</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.OutOfMemoryException">
          <source>To address this exception, recompile your app to target a 64-bit platform.</source>
          <target state="translated">Para resolver esta excepción, vuelva a compilar la aplicación que tenga como destino una plataforma de 64 bits.</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.OutOfMemoryException">
          <source>For information on targeting specific platforms in Visual Studio, see <bpt id="p1">[</bpt>How to: Configure Projects to Target Platforms<ept id="p1">](http://msdn.microsoft.com/library/845302fc-273d-4f81-820a-7296ce91bd76)</ept>.</source>
          <target state="translated">Para obtener información sobre plataformas específicas en Visual Studio de destino, vea <bpt id="p1">[</bpt>Cómo: configurar proyectos para plataformas de destino<ept id="p1">](http://msdn.microsoft.com/library/845302fc-273d-4f81-820a-7296ce91bd76)</ept>.</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.OutOfMemoryException">
          <source>Your app is leaking unmanaged resources</source>
          <target state="translated">La aplicación pierde recursos no administrados</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.OutOfMemoryException">
          <source>Although the garbage collector is able to free memory allocated to managed types, it does not manage memory allocated to unmanaged resources such as operating system handles (including handles to files, memory-mapped files, pipes, registry keys, and wait handles) and memory blocks allocated directly by Windows API calls or by calls to memory allocation functions such as <ph id="ph1">`malloc`</ph>.</source>
          <target state="translated">Aunque el recolector de elementos no utilizados puede liberar memoria asignada a los tipos administrados, no administra la memoria asignada a los recursos no administrados como identificadores de sistema operativo (incluidos los identificadores de archivos, archivos asignados en memoria, canalizaciones, las claves del registro y controladores de espera) y bloques de memoria asignados directamente por llamadas a la API de Windows o mediante llamadas a funciones de asignación de memoria como <ph id="ph1">`malloc`</ph>.</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.OutOfMemoryException">
          <source>Types that consume unmanaged resources implement the <ph id="ph1">&lt;xref:System.IDisposable&gt;</ph> interface.</source>
          <target state="translated">Los tipos que consumen recursos no administrados que implementan el <ph id="ph1">&lt;xref:System.IDisposable&gt;</ph> interfaz.</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.OutOfMemoryException">
          <source>If you are consuming a type that uses unmanaged resources, you should be sure to call its <ph id="ph1">&lt;xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType&gt;</ph> method when you have finished using it.</source>
          <target state="translated">Si va a consumir un tipo que usa recursos no administrados, debe asegurarse de llamar a su <ph id="ph1">&lt;xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType&gt;</ph> método cuando termine de usarlo.</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.OutOfMemoryException">
          <source>(Some types also implement a <ph id="ph1">`Close`</ph> method that is identical in function to a <ph id="ph2">`Dispose`</ph> method.) For more information, see the <bpt id="p1">[</bpt>Using Objects That Implement IDisposable<ept id="p1">](~/docs/standard/garbage-collection/using-objects.md)</ept> topic.</source>
          <target state="translated">(Algunos tipos también implementan un <ph id="ph1">`Close`</ph> método que es idéntico en función de para un <ph id="ph2">`Dispose`</ph> método.) Para obtener más información, consulte el <bpt id="p1">[</bpt>utilizando objetos que implemente IDisposable<ept id="p1">](~/docs/standard/garbage-collection/using-objects.md)</ept> tema.</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.OutOfMemoryException">
          <source>If you have created a type that uses unmanaged resources, make sure that you have implemented the Dispose pattern and, if necessary, supplied a finalizer.</source>
          <target state="translated">Si ha creado un tipo que usa recursos no administrados, asegúrese de que ha implementado el patrón de Dispose y, si es necesario, proporciona un finalizador.</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.OutOfMemoryException">
          <source>For more information, see the <bpt id="p1">[</bpt>Dispose Pattern<ept id="p1">](~/docs/standard/design-guidelines/dispose-pattern.md)</ept>, <bpt id="p2">[</bpt>Implementing a Dispose Method<ept id="p2">](~/docs/standard/garbage-collection/implementing-dispose.md)</ept>, and <ph id="ph1">&lt;xref:System.Object.Finalize%2A?displayProperty=nameWithType&gt;</ph> topics.</source>
          <target state="translated">Para obtener más información, consulte el <bpt id="p1">[</bpt>patrón Dispose<ept id="p1">](~/docs/standard/design-guidelines/dispose-pattern.md)</ept>, <bpt id="p2">[</bpt>implementa un método Dispose<ept id="p2">](~/docs/standard/garbage-collection/implementing-dispose.md)</ept>, y <ph id="ph1">&lt;xref:System.Object.Finalize%2A?displayProperty=nameWithType&gt;</ph> temas.</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.OutOfMemoryException">
          <source>You are attempting to create a large array in a 64-bit process.</source>
          <target state="translated">Está intentando crear una matriz grande en un proceso de 64 bits.</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.OutOfMemoryException">
          <source>By default, the common language runtime does not allow single objects whose size exceeds 2GB.</source>
          <target state="translated">De forma predeterminada, common language runtime no permite solo objetos cuyo tamaño supera los 2GB.</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.OutOfMemoryException">
          <source>To override this default, you can use the  configuration file setting to enable arrays whose total size exceeds 2 GB.</source>
          <target state="translated">Para invalidar este comportamiento predeterminado, puede usar el archivo de configuración para habilitar matrices cuyo tamaño total supera los 2 GB.</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.OutOfMemoryException">
          <source>You are working with very large sets of data (such as arrays, collections, or database data sets) in memory.</source>
          <target state="translated">Se trabaja con grandes conjuntos de datos (por ejemplo, matrices, colecciones ni conjuntos de datos de la base de datos) en la memoria.</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.OutOfMemoryException">
          <source>When data structures or data sets that reside in memory become so large that the common language runtime is unable to allocate enough contiguous memory for them, an <ph id="ph1">&lt;xref:System.OutOfMemoryException&gt;</ph> exception results.</source>
          <target state="translated">Cuando las estructuras de datos o conjuntos de datos que residen en la memoria sea tan grandes que common language runtime es no se puede asignar suficiente memoria contigua para ellos, un <ph id="ph1">&lt;xref:System.OutOfMemoryException&gt;</ph> resultados de la excepción.</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.OutOfMemoryException">
          <source>To prevent the <ph id="ph1">&lt;xref:System.OutOfMemoryException&gt;</ph> exceptions, you must modify your application so that less data is resident in memory, or the data is divided into segments that require smaller memory allocations.</source>
          <target state="translated">Para evitar la <ph id="ph1">&lt;xref:System.OutOfMemoryException&gt;</ph> excepciones, debe modificar la aplicación para que los datos con menos están residentes en memoria o los datos se dividen en segmentos que requieren la asignación de memoria menor.</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.OutOfMemoryException">
          <source>For example:</source>
          <target state="translated">Por ejemplo:</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.OutOfMemoryException">
          <source>If you are retrieving all of the data from a database and then filtering it in your app to minimize trips to the server, you should modify your queries to return only the subset of data that your app needs.</source>
          <target state="translated">Si va a recuperar todos los datos de una base de datos y, a continuación, filtrarlos en su aplicación para minimizar los recorridos y en el servidor, debe modificar las consultas para devolver sólo el subconjunto de datos que necesita la aplicación.</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.OutOfMemoryException">
          <source>When working with large tables, multiple queries are almost always more efficient than retrieving all of the data in a single table and then manipulating it.</source>
          <target state="translated">Al trabajar con tablas de gran tamaño, varias consultas casi siempre son más eficaz que recuperar todos los datos en una sola tabla y, a continuación, la manipulación.</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.OutOfMemoryException">
          <source>If you are executing queries that users create dynamically, you should ensure that the number of records returned by the query is limited.</source>
          <target state="translated">Si va a ejecutar las consultas que los usuarios crear dinámicamente, debe asegurarse de que se limita el número de registros devueltos por la consulta.</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.OutOfMemoryException">
          <source>If you are using large arrays or other collection objects whose size results in an <ph id="ph1">&lt;xref:System.OutOfMemoryException&gt;</ph> exception, you should modify your application to work the data in subsets rather than to work with it all at once.</source>
          <target state="translated">Si está utilizando matrices de gran tamaño u otra colección de objetos cuyos resultados de tamaño en un <ph id="ph1">&lt;xref:System.OutOfMemoryException&gt;</ph> excepción, debe modificar la aplicación para que funcione de los datos en subconjuntos, en lugar de trabajar con ellos a la vez.</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.OutOfMemoryException">
          <source>The following example gets a array that consists of 200 million floating-point values and then calculates their mean.</source>
          <target state="translated">En el ejemplo siguiente se obtiene una matriz que consta de 200 millones de valores de punto flotante y, a continuación, calcula su Media.</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.OutOfMemoryException">
          <source>The output from the example shows that, because the example stores the entire array in memory before it calculates the mean, an <ph id="ph1">&lt;xref:System.OutOfMemoryException&gt;</ph> is is thrown.</source>
          <target state="translated">El resultado del ejemplo muestra que, dado que el ejemplo almacena toda la matriz en la memoria antes de que calcula la media, un <ph id="ph1">&lt;xref:System.OutOfMemoryException&gt;</ph> es se produce.</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.OutOfMemoryException">
          <source>The following example eliminates the <ph id="ph1">&lt;xref:System.OutOfMemoryException&gt;</ph> exception by processing the incoming data without storing the entire data set in memory, serializing the data to a file if necessary to permit further processing (these lines are commented out in the example, since in this case they produce a file whose size is greater than 1GB), and returning the calculated mean and the number of cases to the calling routine.</source>
          <target state="translated">En el ejemplo siguiente se elimina el <ph id="ph1">&lt;xref:System.OutOfMemoryException&gt;</ph> excepción al procesar los datos de entrada sin almacenar todo el conjunto de datos en memoria, serializar los datos en un archivo si es necesario para permitir un procesamiento posterior (estas líneas se incluyen entre comentarios en el ejemplo, puesto que en este caso que generan un archivo cuyo tamaño es mayor que 1 GB) y devuelve el promedio calculado y el número de casos a la rutina que realiza la llamada.</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.OutOfMemoryException">
          <source>You are repeatedly concatenating large strings.</source>
          <target state="translated">Repetidamente va a concatenar cadenas de gran tamaño.</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.OutOfMemoryException">
          <source>Because strings are immutable, each string concatenation operation creates a new string.</source>
          <target state="translated">Dado que las cadenas son inmutables, cada operación de concatenación de cadenas crea una nueva cadena.</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.OutOfMemoryException">
          <source>The impact for small strings, or for a small number of concatenation operations, is negligible.</source>
          <target state="translated">El impacto de las cadenas pequeñas o para un pequeño número de operaciones de concatenación es insignificante.</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.OutOfMemoryException">
          <source>But for large strings or a very large number of concatenation operations, string concatenation can lead to a large number of memory allocations and memory fragmentation, poor performance, and possibly <ph id="ph1">&lt;xref:System.OutOfMemoryException&gt;</ph> exceptions.</source>
          <target state="translated">Pero para cadenas de gran tamaño o un gran número de operaciones de concatenación, concatenación de cadenas puede conducir a un gran número de asignaciones de memoria y la fragmentación de memoria, un rendimiento bajo y posiblemente <ph id="ph1">&lt;xref:System.OutOfMemoryException&gt;</ph> excepciones.</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.OutOfMemoryException">
          <source>When concatenating large strings or performing a large number of concatenation operations, you should use the <ph id="ph1">&lt;xref:System.Text.StringBuilder&gt;</ph> class instead of the <ph id="ph2">&lt;xref:System.String&gt;</ph> class.</source>
          <target state="translated">Cuando la concatenación de cadenas de gran tamaño o realizar un gran número de operaciones de concatenación, debe usar el <ph id="ph1">&lt;xref:System.Text.StringBuilder&gt;</ph> clase en lugar de la <ph id="ph2">&lt;xref:System.String&gt;</ph> clase.</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.OutOfMemoryException">
          <source>When you have finished manipulating the string, convert the <ph id="ph1">&lt;xref:System.Text.StringBuilder&gt;</ph> instance to a string by calling the <ph id="ph2">&lt;xref:System.Text.StringBuilder.ToString%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">Cuando haya terminado de manipular la cadena, convertir la <ph id="ph1">&lt;xref:System.Text.StringBuilder&gt;</ph> instancia en una cadena mediante una llamada a la <ph id="ph2">&lt;xref:System.Text.StringBuilder.ToString%2A?displayProperty=nameWithType&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.OutOfMemoryException">
          <source>You pin a large number of objects in memory.</source>
          <target state="translated">Anclar un gran número de objetos en memoria.</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.OutOfMemoryException">
          <source>Pinning a large number of objects in memory for long periods can make it difficult for the garbage collector to allocate contiguous blocks of memory.</source>
          <target state="translated">Anclar un gran número de objetos en la memoria durante largos períodos puede dificultar el recolector de elementos no utilizados asignar bloques de memoria contiguas.</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.OutOfMemoryException">
          <source>If you've pinned a large number of objects in memory, for example by using the <ph id="ph1">`fixed`</ph> statement in C# or by calling the <ph id="ph2">&lt;xref:System.Runtime.InteropServices.GCHandle.Alloc%28System.Object%2CSystem.Runtime.InteropServices.GCHandleType%29?displayProperty=nameWithType&gt;</ph> method with a handle type of <ph id="ph3">&lt;xref:System.Runtime.InteropServices.GCHandleType.Pinned?displayProperty=nameWithType&gt;</ph>, you can do the following to address the <ph id="ph4">&lt;xref:System.OutOfMemoryException&gt;</ph> exception.</source>
          <target state="translated">Si se ancló un gran número de objetos en memoria, por ejemplo mediante el uso de la <ph id="ph1">`fixed`</ph> instrucción en C# o mediante una llamada a la <ph id="ph2">&lt;xref:System.Runtime.InteropServices.GCHandle.Alloc%28System.Object%2CSystem.Runtime.InteropServices.GCHandleType%29?displayProperty=nameWithType&gt;</ph> método con un tipo de identificador de <ph id="ph3">&lt;xref:System.Runtime.InteropServices.GCHandleType.Pinned?displayProperty=nameWithType&gt;</ph>, puede hacer lo siguiente a la dirección el <ph id="ph4">&lt;xref:System.OutOfMemoryException&gt;</ph> excepción.</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.OutOfMemoryException">
          <source>Evaluate whether each object really needs to be pinned,</source>
          <target state="translated">Evaluar si realmente necesita cada objeto fijarse,</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.OutOfMemoryException">
          <source>Ensure that each object is unpinned as soon as possible.</source>
          <target state="translated">Asegúrese de que cada objeto está anclado tan pronto como sea posible.</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.OutOfMemoryException">
          <source>Make sure that each call to the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.GCHandle.Alloc%28System.Object%2CSystem.Runtime.InteropServices.GCHandleType%29?displayProperty=nameWithType&gt;</ph> method to pin memory has a corresponding call to the <ph id="ph2">&lt;xref:System.Runtime.InteropServices.GCHandle.Free%2A?displayProperty=nameWithType&gt;</ph> method to unpin that memory.</source>
          <target state="translated">Asegúrese de que cada llamada a la <ph id="ph1">&lt;xref:System.Runtime.InteropServices.GCHandle.Alloc%28System.Object%2CSystem.Runtime.InteropServices.GCHandleType%29?displayProperty=nameWithType&gt;</ph> método en la memoria del pin tiene una llamada correspondiente a la <ph id="ph2">&lt;xref:System.Runtime.InteropServices.GCHandle.Free%2A?displayProperty=nameWithType&gt;</ph> método Desanclar esa memoria.</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.OutOfMemoryException">
          <source>The following Microsoft intermediate (MSIL) instructions throw an <ph id="ph1">&lt;xref:System.OutOfMemoryException&gt;</ph> exception:</source>
          <target state="translated">El siguiente Microsoft intermedias instrucciones (MSIL) producen un <ph id="ph1">&lt;xref:System.OutOfMemoryException&gt;</ph> excepción:</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.OutOfMemoryException">
          <source><bpt id="p1">[</bpt>box<ept id="p1">](http://msdn.microsoft.com/library/system.reflection.emit.opcodes.box.aspx)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>box<ept id="p1">](http://msdn.microsoft.com/library/system.reflection.emit.opcodes.box.aspx)</ept></target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.OutOfMemoryException">
          <source><bpt id="p1">[</bpt>newarr<ept id="p1">](http://msdn.microsoft.com/library/system.reflection.emit.opcodes.newarr.aspx)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>newarr<ept id="p1">](http://msdn.microsoft.com/library/system.reflection.emit.opcodes.newarr.aspx)</ept></target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.OutOfMemoryException">
          <source><bpt id="p1">[</bpt>newobj<ept id="p1">](http://msdn.microsoft.com/library/system.reflection.emit.opcodes.newobj.aspx)</ept>newobj</source>
          <target state="translated"><bpt id="p1">[</bpt>newobj<ept id="p1">](http://msdn.microsoft.com/library/system.reflection.emit.opcodes.newobj.aspx)</ept>newobj</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.OutOfMemoryException">
          <source><ph id="ph1">&lt;xref:System.OutOfMemoryException&gt;</ph> uses the HRESULT <ph id="ph2">`COR_E_OUTOFMEMORY`</ph>, which has the value 0x8007000E.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.OutOfMemoryException&gt;</ph> usa el valor HRESULT <ph id="ph2">`COR_E_OUTOFMEMORY`</ph>, que tiene el valor 0x8007000E.</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.OutOfMemoryException">
          <source>For a list of initial property values for an instance of <ph id="ph1">&lt;xref:System.OutOfMemoryException&gt;</ph>, see the <ph id="ph2">&lt;xref:System.OutOfMemoryException.%23ctor%2A&gt;</ph> constructors.</source>
          <target state="translated">Para obtener una lista de valores de propiedad iniciales para una instancia de <ph id="ph1">&lt;xref:System.OutOfMemoryException&gt;</ph>, consulte el <ph id="ph2">&lt;xref:System.OutOfMemoryException.%23ctor%2A&gt;</ph> constructores.</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.OutOfMemoryException">
          <source>The value of the inherited <ph id="ph1">&lt;xref:System.Exception.Data%2A&gt;</ph> property is always <ph id="ph2">`null`</ph>.</source>
          <target state="translated">El valor de los heredados <ph id="ph1">&lt;xref:System.Exception.Data%2A&gt;</ph> propiedad es siempre <ph id="ph2">`null`</ph>.</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve" uid="T:System.OutOfMemoryException">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.OutOfMemoryException" /&gt;</ph> class.</source>
          <target state="translated">Inicializa una nueva instancia de la clase <ph id="ph1">&lt;see cref="T:System.OutOfMemoryException" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve" uid="M:System.OutOfMemoryException.#ctor">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.OutOfMemoryException" /&gt;</ph> class.</source>
          <target state="translated">Inicializa una nueva instancia de la clase <ph id="ph1">&lt;see cref="T:System.OutOfMemoryException" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.OutOfMemoryException.#ctor">
          <source>This constructor initializes the <ph id="ph1">&lt;xref:System.Exception.Message%2A&gt;</ph> property of the new instance to a system-supplied message that describes the error, such as "There was not enough memory to continue the execution of the program."</source>
          <target state="translated">Este constructor inicializa la <ph id="ph1">&lt;xref:System.Exception.Message%2A&gt;</ph> propiedad de la nueva instancia en un mensaje proporcionado por el sistema que describe el error, como"no hay suficiente memoria para continuar con la ejecución del programa".</target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.OutOfMemoryException.#ctor">
          <source>This message takes into account the current system culture.</source>
          <target state="translated">Este mensaje tiene en cuenta la referencia cultural del sistema actual.</target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.OutOfMemoryException.#ctor">
          <source>The following table shows the initial property values for an instance of <ph id="ph1">&lt;xref:System.OutOfMemoryException&gt;</ph>.</source>
          <target state="translated">En la tabla siguiente se muestran los valores de propiedad iniciales para una instancia de <ph id="ph1">&lt;xref:System.OutOfMemoryException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.OutOfMemoryException.#ctor">
          <source>Property</source>
          <target state="translated">Propiedad.</target>       </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.OutOfMemoryException.#ctor">
          <source>Value</source>
          <target state="translated">Valor</target>       </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.OutOfMemoryException.#ctor">
          <source><ph id="ph1">`null`</ph>.</source>
          <target state="translated"><ph id="ph1">`null`</ph>.</target>       </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.OutOfMemoryException.#ctor">
          <source>The localized error message string.</source>
          <target state="translated">La cadena del mensaje de error localizado.</target>       </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve" uid="M:System.OutOfMemoryException.#ctor(System.String)">
          <source>The message that describes the error.</source>
          <target state="translated">Mensaje que describe el error.</target>       </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve" uid="M:System.OutOfMemoryException.#ctor(System.String)">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.OutOfMemoryException" /&gt;</ph> class with a specified error message.</source>
          <target state="translated">Inicializa una nueva instancia de la clase <ph id="ph1">&lt;see cref="T:System.OutOfMemoryException" /&gt;</ph> con el mensaje de error especificado.</target>       </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.OutOfMemoryException.#ctor(System.String)">
          <source>The content of the <ph id="ph1">`message`</ph> parameter is intended to be understood by humans.</source>
          <target state="translated">Se pretende que el contenido del parámetro <ph id="ph1">`message`</ph> sea inteligible.</target>       </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.OutOfMemoryException.#ctor(System.String)">
          <source>The caller of this constructor is required to ensure that this string has been localized for the current system culture.</source>
          <target state="translated">El autor de llamada de este constructor debe asegurarse de que la cadena se haya adaptado para la referencia cultural actual del sistema.</target>       </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.OutOfMemoryException.#ctor(System.String)">
          <source>The following table shows the initial property values for an instance of <ph id="ph1">&lt;xref:System.OutOfMemoryException&gt;</ph>.</source>
          <target state="translated">En la tabla siguiente se muestran los valores de propiedad iniciales para una instancia de <ph id="ph1">&lt;xref:System.OutOfMemoryException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.OutOfMemoryException.#ctor(System.String)">
          <source>Property</source>
          <target state="translated">Propiedad.</target>       </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.OutOfMemoryException.#ctor(System.String)">
          <source>Value</source>
          <target state="translated">Valor</target>       </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.OutOfMemoryException.#ctor(System.String)">
          <source>A null reference (<ph id="ph1">`Nothing`</ph> in Visual Basic).</source>
          <target state="translated">Referencia nula (<ph id="ph1">`Nothing`</ph> en Visual Basic).</target>       </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.OutOfMemoryException.#ctor(System.String)">
          <source>The error message string.</source>
          <target state="translated">Cadena con el mensaje de error.</target>       </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve" uid="M:System.OutOfMemoryException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
          <source>The object that holds the serialized object data.</source>
          <target state="translated">Objeto que contiene los datos del objeto serializados.</target>       </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve" uid="M:System.OutOfMemoryException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
          <source>The contextual information about the source or destination.</source>
          <target state="translated">Información contextual acerca del origen o del destino.</target>       </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve" uid="M:System.OutOfMemoryException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.OutOfMemoryException" /&gt;</ph> class with serialized data.</source>
          <target state="translated">Inicializa una nueva instancia de la clase <ph id="ph1">&lt;see cref="T:System.OutOfMemoryException" /&gt;</ph> con datos serializados.</target>       </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.OutOfMemoryException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
          <source>This constructor is called during deserialization to reconstitute the exception object transmitted over a stream.</source>
          <target state="translated">Durante la deserialización se llama a este constructor para reconstituir el objeto de excepción transmitido en una secuencia.</target>       </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.OutOfMemoryException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
          <source>For more information, see <bpt id="p1">[</bpt>XML and SOAP Serialization<ept id="p1">](~/docs/standard/serialization/xml-and-soap-serialization.md)</ept>.</source>
          <target state="translated">Para obtener más información, consulte <bpt id="p1">[</bpt>serialización XML y SOAP<ept id="p1">](~/docs/standard/serialization/xml-and-soap-serialization.md)</ept>.</target>       </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve" uid="M:System.OutOfMemoryException.#ctor(System.String,System.Exception)">
          <source>The error message that explains the reason for the exception.</source>
          <target state="translated">Mensaje de error que explica el motivo de la excepción.</target>       </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve" uid="M:System.OutOfMemoryException.#ctor(System.String,System.Exception)">
          <source>The exception that is the cause of the current exception.</source>
          <target state="translated">Excepción que es la causa de la excepción actual.</target>       </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve" uid="M:System.OutOfMemoryException.#ctor(System.String,System.Exception)">
          <source>If the <bpt id="p1">&lt;c&gt;</bpt>innerException<ept id="p1">&lt;/c&gt;</ept> parameter is not a null reference (<ph id="ph1">&lt;see langword="Nothing" /&gt;</ph> in Visual Basic), the current exception is raised in a <ph id="ph2">&lt;see langword="catch" /&gt;</ph> block that handles the inner exception.</source>
          <target state="translated">Si el parámetro <bpt id="p1">&lt;c&gt;</bpt>innerException<ept id="p1">&lt;/c&gt;</ept> no es una referencia nula (<ph id="ph1">&lt;see langword="Nothing" /&gt;</ph> en Visual Basic), la excepción actual se inicia en un bloque <ph id="ph2">&lt;see langword="catch" /&gt;</ph> que controla la excepción interna.</target>       </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve" uid="M:System.OutOfMemoryException.#ctor(System.String,System.Exception)">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.OutOfMemoryException" /&gt;</ph> class with a specified error message and a reference to the inner exception that is the cause of this exception.</source>
          <target state="translated">Inicializa una nueva instancia de la clase <ph id="ph1">&lt;see cref="T:System.OutOfMemoryException" /&gt;</ph> con el mensaje de error especificado y una referencia a la excepción interna que representa la causa de esta excepción.</target>       </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.OutOfMemoryException.#ctor(System.String,System.Exception)">
          <source>An exception that is thrown as a direct result of a previous exception can include a reference to the previous exception in the <ph id="ph1">&lt;xref:System.Exception.InnerException%2A&gt;</ph> property.</source>
          <target state="translated">Una excepción que se produce como resultado directo de una excepción anterior puede incluir una referencia a la excepción anterior de la propiedad <ph id="ph1">&lt;xref:System.Exception.InnerException%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.OutOfMemoryException.#ctor(System.String,System.Exception)">
          <source>The <ph id="ph1">&lt;xref:System.Exception.InnerException%2A&gt;</ph> property returns the same value that is passed into the constructor, or a null reference (<ph id="ph2">`Nothing`</ph> in Visual Basic) if the <ph id="ph3">&lt;xref:System.Exception.InnerException%2A&gt;</ph> property does not supply the inner exception value to the constructor.</source>
          <target state="translated">La propiedad <ph id="ph1">&lt;xref:System.Exception.InnerException%2A&gt;</ph> devuelve el mismo valor pasado al constructor, o una referencia nula (<ph id="ph2">`Nothing`</ph> en Visual Basic) si la propiedad <ph id="ph3">&lt;xref:System.Exception.InnerException%2A&gt;</ph> no proporciona el valor de la excepción interna al constructor.</target>       </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.OutOfMemoryException.#ctor(System.String,System.Exception)">
          <source>The following table shows the initial property values for an instance of <ph id="ph1">&lt;xref:System.OutOfMemoryException&gt;</ph>.</source>
          <target state="translated">En la tabla siguiente se muestran los valores de propiedad iniciales para una instancia de <ph id="ph1">&lt;xref:System.OutOfMemoryException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.OutOfMemoryException.#ctor(System.String,System.Exception)">
          <source>Property</source>
          <target state="translated">Propiedad.</target>       </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.OutOfMemoryException.#ctor(System.String,System.Exception)">
          <source>Value</source>
          <target state="translated">Valor</target>       </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.OutOfMemoryException.#ctor(System.String,System.Exception)">
          <source>The inner exception reference.</source>
          <target state="translated">Referencia a la excepción interna.</target>       </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.OutOfMemoryException.#ctor(System.String,System.Exception)">
          <source>The error message string.</source>
          <target state="translated">Cadena con el mensaje de error.</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>